<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>前端疑难杂症 on Bablvsj&#39;s Blog</title>
    <link>https://bablvsj.github.io/tags/%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/</link>
    <description>Recent content in 前端疑难杂症 on Bablvsj&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 01 Feb 2020 17:11:35 +0800</lastBuildDate><atom:link href="https://bablvsj.github.io/tags/%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Common.js 与 ES6 Module</title>
      <link>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/common.js-%E4%B8%8E-es6-module/</link>
      <pubDate>Sat, 01 Feb 2020 17:11:35 +0800</pubDate>
      
      <guid>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/common.js-%E4%B8%8E-es6-module/</guid>
      <description>ES6 模块与 CommonJS 模块有什么异同？ ES6 Module 和 CommonJS 模块的区别： CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变</description>
    </item>
    
    <item>
      <title>js 执行机制 宏任务微任务</title>
      <link>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/js-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Sat, 01 Feb 2020 17:11:35 +0800</pubDate>
      
      <guid>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/js-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1/</guid>
      <description>js执行机制 说出结果并说出why 这道题考察的是，js的任务执行流程，对宏任务和微任务的理解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25</description>
    </item>
    
    <item>
      <title>this指向、apply、call、bind</title>
      <link>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/4-this%E6%8C%87%E5%90%91applycallbind/</link>
      <pubDate>Sat, 01 Feb 2020 17:11:35 +0800</pubDate>
      
      <guid>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/4-this%E6%8C%87%E5%90%91applycallbind/</guid>
      <description>1. this指向问题 1.1 this永远指向最后调用它的那个对象 1 2 3 4 5 6 7 8 9 10 严格模式下 var name = &amp;#34;windowsName&amp;#34;; function a() { var name = &amp;#34;Cherry&amp;#34;; console.log(this.name); // windowsName console.log(&amp;#34;inner:&amp;#34; + this); // inner: Window } a(); //类似于</description>
    </item>
    
    <item>
      <title>前端跨域Nginx、CORS</title>
      <link>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/2-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9Fnginxcors/</link>
      <pubDate>Sat, 01 Feb 2020 17:11:35 +0800</pubDate>
      
      <guid>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/2-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9Fnginxcors/</guid>
      <description>什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1 2 3 1.) 资源跳转： A链接、重定向、表单提交</description>
    </item>
    
    <item>
      <title>原型、原型链</title>
      <link>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</link>
      <pubDate>Sat, 01 Feb 2020 17:11:35 +0800</pubDate>
      
      <guid>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/</guid>
      <description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 任何一个对象都有 _proto_ 属性 ,#这个属性会指向该对象的原型 构造函数 _proto_ 属性下 有contructor 属性 per.__proto__.constructor === per.constructor per.constructor.__proto__ __pr</description>
    </item>
    
    <item>
      <title>同源和跨域</title>
      <link>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/04-%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Sat, 01 Feb 2020 17:11:35 +0800</pubDate>
      
      <guid>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/04-%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/</guid>
      <description>同源和跨域 同源 同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。 跨域问题的解决方案 从我自己的网站访问别人网站的内容，就</description>
    </item>
    
    <item>
      <title>浏览器兼容适配</title>
      <link>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/</link>
      <pubDate>Sat, 01 Feb 2020 17:11:35 +0800</pubDate>
      
      <guid>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/</guid>
      <description>解决方案： 1、媒体查询 百度分辨率统计 ：https://tongji.baidu.com/research/site?source=index</description>
    </item>
    
    <item>
      <title>赋值、深拷贝、浅拷贝</title>
      <link>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/3-%E8%B5%8B%E5%80%BC%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Sat, 01 Feb 2020 17:11:35 +0800</pubDate>
      
      <guid>https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/3-%E8%B5%8B%E5%80%BC%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description>浅拷贝（复制数据内存地址，赋值会改变原数据） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var p = { &amp;#34;id&amp;#34;:&amp;#34;007&amp;#34;, &amp;#34;name&amp;#34;:&amp;#34;刘德华&amp;#34</description>
    </item>
    
  </channel>
</rss>
