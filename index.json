[{"categories":null,"contents":"11111111111111\n","permalink":"https://lvsijun.gitee.io/website/home/%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E4%B8%80%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/","tags":null,"title":"电影"},{"categories":null,"contents":" 备注： async/await 的内容还有待完善。\nasync/await （异步函数）概述 async/await 是在 ES7 中引入的新语法，可以更加方便地进行异步操作。\n本质： Generator 的语法糖。\nasync 的返回值是 Promise 实例对象。\nawait 可以得到异步结果。\n我们在普通的函数前面加上 async 关键字，就成了 async 函数。\nasync/await 的基本用法 async 后面可以跟一个 Promise 实例对象。代码举例如下：\nconst request1 = function() { const promise = new Promise(resolve =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, function(response) { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39;+ response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; async function queryData() { const response = await request1(); }); return response; } queryData().then(data =\u0026gt; { console.log(data); }); 基于 async/await 处理多次 Ajax 请求【重要】 实际开发中，现在有三个网络请求，请求2必须依赖请求1的结果，请求3必须依赖请求2的结果，如果按照往常的写法，会有三层回调，会陷入“回调地狱”。\n这种场景其实就是接口的多层嵌套调用。之前学过 Promise，它可以把原本的多层嵌套调用改进为链式调用。\n而今天要学习的 async/await ，可以把原本的“多层嵌套调用”改成类似于同步的写法，非常优雅。\n代码举例：\n暂略。\nPromise、async\u0026hellip;await、Generator的对比 我们在使用 Promise、async\u0026hellip;await、Generator 的时候，返回的都是 Promise 的实例。\n如果直接使用 Promise，则需要通过 then 来进行链式调用；如果使用 async\u0026hellip;await、Generator，写起来更像同步的代码。\n参考链接 js async await 终极异步解决方案\n理解 JavaScript 的 async/await\n","permalink":"https://lvsijun.gitee.io/website/home/12-es7async%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","tags":null,"title":"async函数详解"},{"categories":null,"contents":"JSON 对象 1、js对象(数组) \u0026ndash;\u0026gt; json对象(数组)：\nJSON.stringify(obj/arr) 2、json对象(数组) \u0026ndash;\u0026gt; js对象(数组)：\nJSON.parse(json) 上面这两个方法是ES5中提供的。\n我们要记住，我们通常说的“json字符串”，只有两种：json对象、json数组。\ntypeof json字符串的返回结果是string。\nObject的扩展 ES5给Object扩展了一些静态方法，常用的有2个，我们接下来讲解。\n方法一 Object.create(prototype, [descriptors]) 作用: 以指定对象为原型，创建新的对象。同时，第二个参数可以为为新的对象添加新的属性，并对此属性进行描述。\n举例1：（没有第二个参数时）\nvar obj1 = {username: \u0026#39;smyhvae\u0026#39;, age: 26}; var obj2 = {address:\u0026#39;shenzhen\u0026#39;}; obj2 = Object.create(obj1); console.log(obj2); 打印结果：\n我们发现，obj1成为了obj2的原型。\n举例2：（有第二个参数时）\n第二个参数可以给新的对象添加新的属性。我们修改上面的代码，尝试给obj2添加新属性sex：\nvar obj1 = {username: \u0026#39;smyhvae\u0026#39;, age: 26}; var obj2 = {address: \u0026#39;shenzhen\u0026#39;}; obj2 = Object.create(obj1, { sex: {//给obj2添加新的属性`sex`。注意，这一行的冒号不要漏掉 value: \u0026#39;男\u0026#39;, //通过value关键字设置sex的属性值 writable: false, configurable: true, enumerable: true } }); console.log(obj2); 上方代码中，我们通过第5行的sex给obj2设置了一个新的属性sex，但是要通过value来设置属性值（第6行）。\n设置完属性值后，这个属性值默认是不可修改的，要通过writable来设置。总而言之，这几个关键字的解释如下：\nvalue：设置属性值。\nwritable：标识当前属性值是否可修改。如果不写的话，默认为false，不可修改。\nconfigurable：标识当前属性是否可以被删除。默认为false，不可删除。\nenumerable：标识当前属性是否能用 for in 枚举。 默认为false，不可。\n方法二 这个方法有点难理解。\nObject.defineProperties(object, descriptors) 作用：为指定对象定义扩展多个属性。\n代码举例：\nvar obj2 = { firstName : \u0026#39;smyh\u0026#39;, lastName : \u0026#39;vae\u0026#39; }; Object.defineProperties(obj2, { fullName : { get : function () { return this.firstName + \u0026#39;-\u0026#39; + this.lastName }, set : function (data) { //监听扩展属性，当扩展属性发生变化的时候自动调用，自动调用后将变化的值作为实参注入到set函数 var names = data.split(\u0026#39;-\u0026#39;); this.firstName = names[0]; this.lastName = names[1]; } } }); console.log(obj2.fullName); obj2.firstName = \u0026#39;tim\u0026#39;; obj2.lastName = \u0026#39;duncan\u0026#39;; console.log(obj2.fullName); obj2.fullName = \u0026#39;kobe-bryant\u0026#39;; console.log(obj2.fullName); get ：用来获取当前属性值的回调函数\nset ：修改当前属性值得触发的回调函数，并且实参即为修改后的值\n存取器属性：setter,getter一个用来存值，一个用来取值。\nObject的扩展（二） obj对象本身就自带了两个方法。格式如下：\nget 属性名(){} 用来得到当前属性值的回调函数 set 属性名(){} 用来监视当前属性值变化的回调函数 举例如下：\nvar obj = { firstName : \u0026#39;kobe\u0026#39;, lastName : \u0026#39;bryant\u0026#39;, get fullName(){ return this.firstName + \u0026#39; \u0026#39; + this.lastName }, set fullName(data){ var names = data.split(\u0026#39; \u0026#39;); this.firstName = names[0]; this.lastName = names[1]; } }; console.log(obj.fullName); obj.fullName = \u0026#39;curry stephen\u0026#39;; console.log(obj.fullName); 数组的扩展 下面讲的这几个方法，都是给数组的实例用的。\n下面提到的数组的这五个方法，更详细的内容，可以看《03-JavaScript基础/15-数组的常见方法.md》\n方法1：\nArray.prototype.indexOf(value) 作用：获取 value 在数组中的第一个下标。\n方法2：\nArray.prototype.lastIndexOf(value) 作用：获取 value 在数组中的最后一个下标。\n方法3：遍历数组\nArray.prototype.forEach(function(item, index){}) 方法4：\nArray.prototype.map(function(item, index){}) 作用：遍历数组返回一个新的数组，返回的是加工之后的新数组。\n方法5：\nArray.prototype.filter(function(item, index){}) 作用：遍历过滤出一个新的子数组，返回条件为true的值。\n函数function的扩展：bind() ES5中新增了bind()函数来改变this的指向。\nFunction.prototype.bind(obj) 作用：将函数内的this绑定为obj, 并将函数返回。\n面试题: call()、apply()和bind()的区别：\n都能改变this的指向\ncall()/apply()是立即调用函数\nbind()：绑定完this后，不会立即调用当前函数，而是将函数返回，因此后面还需要再加()才能调用。\nPS：bind()传参的方式和call()一样。\n分析：\n为什么ES5中要加入bind()方法来改变this的指向呢？因为bind()不会立即调用当前函数。\nbind()通常使用在回调函数中，因为回调函数并不会立即调用。如果你希望在回调函数中改变this，不妨使用bind()。\n","permalink":"https://lvsijun.gitee.io/website/archives/es5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%89%A9%E5%B1%95.html/","tags":null,"title":"ES5的一些扩展"},{"categories":null,"contents":"ES 的几个重要版本 ES5 : 09 年发布。\nES6(ES2015) : 2015 年发布，也称为 ECMA2015。\nES7(ES2016) : 2016 年发布，也称为 ECMA2016 (变化不大)。\n严格模式的理解 概念 理解：除了正常运行模式(混杂模式)，ES5 添加了第二种运行模式：\u0026ldquo;严格模式\u0026rdquo;（strict mode）。\n顾名思义，这种模式使得 Javascript 在更严格的语法条件下运行。\n目的：\n消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为\n消除代码运行的一些不安全之处，为代码的安全运行保驾护航\n为未来新版本的 Javascript 做好铺垫\n使用 针对整个脚本文件：将use strict放在脚本文件的第一行，则整个脚本文件将以严格模式运行。\n针对单个函数：将use strict放在函数体的第一行，则整个函数以严格模式运行。\nPS：如果浏览器不支持，则这句话只解析为一条简单的语句, 没有任何副作用。\n脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。\n语法和行为改变 必须用 var 声明变量\n禁止自定义的函数中的 this 指向 window\n创建 eval 作用域\n对象不能有重名的属性\n严格模式和普通模式的区别 下面列举几条严格模式的内容。\n全局变量显式声明 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n禁止 this 关键字指向全局对象： var foo = function () { console.log(this); }; foo(); 上方代码中，普通模式打印的是 window。严格模式下打印的是 undefined。\n创设 eval 作用域 禁止使用 with 语句 因为 with 语句无法在编译时就确定，属性到底归属哪个对象。\n构造函数必须通过 new 实例化对象 构造函数必须通过 new 实例化对象，否则报错。因为 this 为 undefined，此时无法设置属性。\n比如说：\nvar Cat = function (name) {\rthis.name = name;\r}\rCat(\u0026#39;haha\u0026#39;); 上方代码中，如果在严格模式下，则会报错。\n为了让代码更安全，禁止函数内部遍历调用栈 严格模式下无法删除变量 属性相关 普通模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n普通模式下，如果函数有多个重名的参数，可以用 arguments[i]读取。严格模式下，多个重名的参数属于语法错误。\n比如下面这样的代码：\nvar obj = { username: \u0026#39;smyh\u0026#39;; username: \u0026#39;vae\u0026#39; } 上面的代码，在严格模式下属于语法错误，因为有重名的属性。\n函数必须声明在顶层 将来 Javascript 的新版本会引入\u0026quot;块级作用域\u0026quot;。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n新增关键字 为了向将来 Javascript 的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n总结 至少要能答出四五条。\n参考链接：\n阮一峰 | Javascript 严格模式详解 ","permalink":"https://lvsijun.gitee.io/website/archives/es5%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html/","tags":null,"title":"ES5中的严格模式"},{"categories":null,"contents":"前言 ECMAScript 简介 ES 的全称是 ECMAScript，它是由 ECMA 国际标准化组织 制定的一套脚本语言的标准化规范。\n详细来说，ES 是由 ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等公司。\nPS：简单来说，ECMAScript 是 JS 的语言标准。当然，ECMAScript 还包括其他脚本语言的语言标准。\nECMAScript 版本发布记录 1995 年：ECMAScript 诞生。\n1997 年：ECMAScript 标准确立。ECMA 发布 ECMA-262 标准，推出浏览器标准语言 ECMAScript 1.0。\n1999 年：发布 ES3；与此同时，IE5 风靡一时。\n2009 年：发布 ECMAScript 5.0（简称 ES5）。例如 foreach、Object.keys、Object.create 和 json 标准。\n2011 年：发布 ECMAScript5.1，成为 ISO 国际标准，从而推动所有浏览器都支持。\n2015 年 6 月：发布 ECMAScript 6（简称 ES6），即 ECMAScript 2015。（注意，前者是按版本号区分，后者是按年份区分。ES 的后续的版本，请尽量用年份来命名。）\n2016 年 6 月：发布 ECMAScript 7，即 ECMAScript 2016。\n2017 年 6 月：发布 ECMAScript 8，即 ECMAScript 2017。\n2018 年 6 月：发布 ECMAScript 9，即 ECMAScript 2018。\n2019 年 6 月：发布 ECMAScript 10，即 ECMAScript 2019。\n2020 年 6 月：发布 ECMAScript 11，即 ECMAScript 2020。\n\u0026hellip;\u0026hellip;\n此后，每年更新一版。 ES6 简介 从上面的 ES 的版本记录可以看出：2015 年 6 月，ES6 正式发布。如果用年份来命名版本号，也可以称之为 ES2015。\nES6 是新的 JS 语法标准。ES6 实际上是一个泛指，泛指 ES 2015 及后续的版本。\n很多人在做业务选型的时候，会倾向于选 jQuery。其实 jQuery 的语法是偏向于 ES3 的。而现在主流的框架 Vue.js 和 React.js 的默认语法，都是用的 ES6。\nES6 的改进如下：\nES6 之前的变量提升，会导致程序在运行时有一些不可预测性。而 ES6 中通过 let、const 变量优化了这一点。\nES6 增加了很多功能，比如：常量、作用域、对象代理、异步处理、类、继承等。这些在 ES5 中想实现，比较复杂，但是 ES6 对它们进行了封装。\nES6 之前的语法过于松散，实现相同的功能，不同的人可能会写出不同的代码。\nES6 的目标是：让 JS 语言可以编写复杂的大型应用程序，成为企业级开发语言。\nES6 的环境配置（为了兼容 ES5） 掌握 ES6 之后，如果要考虑 ES5 的兼容性，可以这样做：写 ES6 语法的 js 代码，然后通过 Babel将 ES6 转换为 ES5。\nbabel 的作用是将 ES6 语法转为 ES5 语法，支持低端浏览器。\n但是，在这之前，我们需要配置一下相关的环境。\n建立工程目录 （1）先建立一个空的工程目录 ES6Demo，并在目录下建立两个文件夹 src和 dist：\nsrc：书写 ES6 代码，我们写的 js 程序都放在这里。\ndist：利用 Babel 编译生成的 ES5 代码。我们在 HTML 页面需要引入 dist 里的 js 文件。\n（2）在 src 里新建文件 index.html：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;!-- 我们引入 ES5 中的 js 文件，而不是引入 ES6 中的 js 文件。 --\u0026gt; \u0026lt;script src=\u0026#34;./dist/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意，上方代码中，我们引入的是dist目录下的 js 文件。\n然后我们新建文件 src/index.js：\nlet a = \u0026#39;smyhvae\u0026#39;; const b = \u0026#39;qianguyihao\u0026#39;; console.log(a); console.log(b); 这个文件是一个 ES6 语法 的 js 文件，稍后，我们尝试把这个 ES6 语法的 js 文件转化为 ES5 的 js 文件。\nPS：我们在写代码时，能用单引号尽量用单引号，而不是双引号，前者在压缩之后，程序执行会更快。\n全局安装 Babel-cli （1）初始化项目：\n在安装 Babel 之前，需要先用 npm init 先初始化我们的项目。打开终端或者通过 cmd 打开命令行工具，进入项目目录，输入如下命令：\nnpm init -y 上方代码中，-y 代表全部默认同意，就不用一次次按回车了（稍后再根据需要，在文件中手动修改）。命令执行完成后，会在项目的根目录下生成 package.json 文件：\n{ \u0026#34;name\u0026#34;: \u0026#34;es6demo\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;smyhvae\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } PS：VS Code 里打开终端的快捷键是：Contol + ~。\n（2）全局安装 Babel-cli：\n在终端中输入以下命令：\nnpm install -g babel-cli 如果安装比较慢的话，Mac 下可以使用cnpm进行安装 ，windows 下可以使用nrm切换到 taobao 的镜像。\n（3）本地安装 babel-preset-es2015 和 babel-cli：\nnpm install --save-dev babel-preset-es2015 babel-cli 安装完成后，会发现package.json文件，已经多了 devDependencies 选项：\n（4）新建.babelrc：\n在根目录下新建文件.babelrc，输入如下内容：\n{\r\u0026#34;presets\u0026#34;:[\r\u0026#34;es2015\u0026#34;\r],\r\u0026#34;plugins\u0026#34;:[]\r} （5）开始转换：\n现在，我们应该可以将 ES6 的文件转化为 ES5 的文件了，命令如下：（此命令略显复杂）\nbabel src/index.js -o dist/index.js 我们可以将上面这个命令进行简化一下。操作如下：\n在文件 package.json 中修改键 scripts中的内容：\n\u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;babel src/index.js -o dist/index.js\u0026#34; }, 修改后的效果如下：\n目前为止，环境配置好了。以后，我们执行如下命令，即可将src/index.js这个 ES6 文件转化为 dist/index.js这个 ES5 文件：\nnpm run build 我们执行上面的命令之后，会发现， dist 目录下会生成 ES5 的 js 文件：\nindex.js：\n\u0026#39;use strict\u0026#39;; var a = \u0026#39;smyhvae\u0026#39;; var b = \u0026#39;qianguyihao\u0026#39;; console.log(a); console.log(b); 当我们打开网页后，就可以在浏览器的控制台，看到代码的输出结果。\n本段内容的参考链接：http://jspang.com/2017/06/03/es6/\n","permalink":"https://lvsijun.gitee.io/website/archives/es6%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html/","tags":null,"title":"Es6的介绍和环境配置"},{"categories":null,"contents":"","permalink":"https://lvsijun.gitee.io/website/home/helloworld/","tags":null,"title":"HelloWorld"},{"categories":null,"contents":"ES6 的变量声明 ES5 中，使用 var 定义全局变量（ var 是 variable 的简写）。\nES6 中，新增了 let 和 const 来定义变量：\nlet：定义局部变量，替代 var。\nconst：定义常量（定义后，不可修改）。\n1、var：定义全局变量 看下面的代码：\n{ var a = 1; } console.log(a); //这里的 a，指的是 区块 里的 a 上方代码是可以输出结果的，输出结果为 1。因为 var 是全局声明的，所以，即使是在区块里声明，但仍然在全局起作用。\n也就是说：使用 var 声明的变量不具备块级作用域特性。\n再来看下面这段代码：\nvar a = 1; { var a = 2; } console.log(a); //这里的 a，指的是 区块 里的 a 上方代码的输出结果为 2 ，因为 var 是全局声明的。\n总结：\n用 var 定义的全部变量，有时候会污染整个 js 的作用域。我们在如今的实战中，基本都是用的 ES6 语法，所以请尽量避免使用 var 定义变量。\n2、let：定义局部变量 举例 1：\n{ let a = \u0026#39;hello\u0026#39;; } console.log(a); // 打印结果报错：Uncaught ReferenceError: a is not defined 上方代码，打印报错。\n举例 2：\nvar a = 2; { let a = 3; } console.log(a); // 打印结果：2 通过上面两个例子可以看出，用 let 声明的变量，只在局部（块级作用域内）起作用。\n经典面试题：\nlet 可以防止数据污染，我们来看下面这个 for 循环的经典面试题。\n1、用 var 声明变量：\nfor (var i = 0; i \u0026lt; 10; i++) { console.log(\u0026#39;循环体中:\u0026#39; + i); } console.log(\u0026#39;循环体外:\u0026#39; + i); 上方代码可以正常打印结果，且最后一行的打印结果是 10。说明循环体外定义的变量 i，是全局作用域下的 i。\n2、用 let 声明变量：\nfor (let i = 0; i \u0026lt; 10; i++) { console.log(\u0026#39;循环体中:\u0026#39; + i); // // 每循环一次，就会在 { } 所在的块级作用域中，重新定义一个新的变量 i } console.log(\u0026#39;循环体外:\u0026#39; + i); 上方代码的关键在于：每次循环都会产生一个块级作用域，每个块级作用域中会重新定义一个新的变量 i。\n另外，上方代码的最后一行无法打印结果，也就是说打印会报错。因为用 let 定义的变量 i，只在{ }这个块级作用域里生效。\n总结：我们要习惯用 let 声明，减少 var 声明带来的污染全局空间。\n为了进一步说明 let 不会带来污染，需要说明的是：当我们定义了let a = 1时，如果我们在同一个作用域内继续定义let a = 2，是会报错的。\n3、const：定义常量 在程序开发中，有些变量是希望声明后，在业务层就不再发生变化，此时可以用 const 来定义常量。常量就是值（内存地址）不能变化的量。\n举例：\nconst name = \u0026#39;smyhvae\u0026#39;; //定义常量 用 const 声明的常量，只在局部（块级作用域内）起作用；而且，用 const 声明常量时，必须赋值，否则报错。\nlet 和 const 的特点【重要】 不存在变量提升\n禁止重复声明\n支持块级作用域\n暂时性死区\n相反， 用var声明的变量：存在变量提升、可以重复声明、没有块级作用域。\nvar/let/const 的共同点 全局作用域中定义的变量，可以在函数中使用。\n函数中声明的变量，只能在函数及其子函数中使用，外部无法使用。\n总结 关于 let、const、var 更详细的介绍和区别，可以看本项目的另一篇文章《JavaScript 进阶/var、let、const 的区别.md》。\nfor 循环举例（经典案例） 代码 1、我们先来看看如下代码：（用 var 定义变量 i）\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;aa\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;bb\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;cc\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;dd\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; var myBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;); for (var i = 0; i \u0026lt; myBtn.length; i++) { myBtn[i].onclick = function () { alert(i); }; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中的运行效果如下：\n你可能会感到诧异，为何点击任何一个按钮，弹出的内容都是 4 呢？这是因为，我们用 var 定义的变量 i，是在全局作用域声明的。整个代码中，自始至终只有一个变量。\nfor 循环是同步代码，而 onclick 点击事件是异步代码。当我们还没点击按钮之前，同步代码已经执行完了，变量 i 已经循环到 4 了。\n也就是说，上面的 for 循环，相当于如下代码：\nvar i = 0; myBtn[0].onclick = function () { alert(i); }; i++; myBtn[1].onclick = function () { alert(i); }; i++; myBtn[2].onclick = function () { alert(i); }; i++; myBtn[3].onclick = function () { alert(i); }; i++; // 到这里，i 的值已经是4了。因此，当我们点击按钮时，i的值一直都是4 代码 2、上面的代码中，如果我们改为用 let 定义变量 i：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;aa\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;bb\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;cc\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;dd\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; var myBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;); for (let i = 0; i \u0026lt; myBtn.length; i++) { myBtn[i].onclick = function () { alert(i); }; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中的运行效果如下：\n上面这个运行结果，才是我们预期的效果。我们用 let 定义变量 i，在循环的过程中，每执行一次循环体，就会诞生一个新的 i。循环体执行 4 次，就会有四个 i。\n暂时性死区 DTC ES6 规定：使用 let/const 声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。\n也就是说，在使用 let/const 声明变量时，变量需要先声明，再使用（声明语句必须放在使用之前）。这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）。\nDTC 其实是一种保护机制，可以让我们养成良好的编程习惯。\n代码举例：\nconst name = \u0026#39;qianguyihao\u0026#39;; function foo() { console.log(name); const name = \u0026#39;hello\u0026#39;; } foo(); // 执行函数后，控制台报错：Uncaught ReferenceError: Cannot access \u0026#39;name\u0026#39; before initialization 参考链接： 阮一峰 | ECMAScript 6 入门 ","permalink":"https://lvsijun.gitee.io/website/archives/letconst%E5%92%8C%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F.html/","tags":null,"title":"let、const和块级作用域"},{"categories":null,"contents":"链式调用：基于 Promise 处理多次 Ajax 请求【重要】 实际开发中，我们经常需要同时请求多个接口。比如说：在请求完接口1的数据data1之后，需要根据data1的数据，继续请求接口 2，获取data2；然后根据data2的数据，继续请求接口 3。\n换而言之，现在有三个网络请求，请求 2 必须依赖请求 1 的结果，请求 3 必须依赖请求 2 的结果，如果按照往常的写法，会有三层回调，会陷入“回调地狱”。\n这种场景其实就是接口的多层嵌套调用。有了 Promise 之后，我们可以把多层嵌套调用按照线性的方式进行书写，非常优雅。也就是说：Promise 可以把原本的多层嵌套调用改进为链式调用。\n代码举例：（多次 Ajax 请求，链式调用）\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const request = require(\u0026#39;request\u0026#39;); // Promise 封装接口1 const request1 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // Promise 封装接口2 const request2 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.jd.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口2的返回结果 resolve(\u0026#39;request2 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // Promise 封装接口3 const request3 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.taobao.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口3的返回结果 resolve(\u0026#39;request3 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // 先发起request1，等resolve后再发起request2；紧接着，等 request2有了 resolve之后，再发起 request3 request1() .then((res1) =\u0026gt; { // 接口1请求成功后，打印接口1的返回结果 console.log(res1); return request2(); }) .then((res2) =\u0026gt; { // 接口2请求成功后，打印接口2的返回结果 console.log(res2); return request3(); }) .then((res3) =\u0026gt; { // 接口3请求成功后，打印接口3的返回结果 console.log(res3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面代码中，then 是可以链式调用的，后面的 then 可以拿到前面 resolve 出来的数据。\n这个举例很经典，需要多看几遍。\nreturn 的函数返回值 return 后面的返回值，有两种情况：\n情况 1：返回 Promise 实例对象。返回的该实例对象会调用下一个 then。\n情况 2：返回普通值。返回的普通值会直接传递给下一个 then，通过 then 参数中函数的参数接收该值。\n我们针对上面这两种情况，详细解释一下。\n情况 1：返回 Promise 实例对象 举例如下：（这个例子，跟上一段 Ajax 链式调用 的例子差不多）\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 基于Promise发送Ajax请求 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常情况 resolve(xhr.responseText); } else { // 处理异常情况 reject(\u0026#39;接口请求失败\u0026#39;); } }; xhr.responseType = \u0026#39;json\u0026#39;; // 设置返回的数据类型 xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); // 请求接口 }); } // 发送多个ajax请求并且保证顺序 queryData(\u0026#39;http://localhost:3000/api1\u0026#39;) .then( (data1) =\u0026gt; { console.log(JSON.stringify(data1)); return queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); }, (error1) =\u0026gt; { console.log(error1); } ) .then( (data2) =\u0026gt; { console.log(JSON.stringify(data2)); // 这里的 return，返回的是 Promise 实例对象 return new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;qianguyihao\u0026#39;); }); }, (error2) =\u0026gt; { console.log(error2); } ) .then((data3) =\u0026gt; { console.log(data3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 情况 2：返回 普通值 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 基于Promise发送Ajax请求 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常情况 resolve(xhr.responseText); } else { // 处理异常情况 reject(\u0026#39;接口请求失败\u0026#39;); } }; xhr.responseType = \u0026#39;json\u0026#39;; // 设置返回的数据类型 xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); // 请求接口 }); } // 发送多个ajax请求并且保证顺序 queryData(\u0026#39;http://localhost:3000/api1\u0026#39;) .then( (data1) =\u0026gt; { console.log(JSON.stringify(data1)); return queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); }, (error1) =\u0026gt; { console.log(error1); } ) .then( (data2) =\u0026gt; { console.log(JSON.stringify(data2)); // 返回普通值 return \u0026#39;qianguyihao\u0026#39;; }, (error2) =\u0026gt; { console.log(error2); } ) /* 既然上方返回的是 普通值，那么，这里的 then 是谁来调用呢？ 答案是：这里会产生一个新的 默认的 promise实例，来调用这里的then，确保可以继续进行链式操作。 */ .then((data3) =\u0026gt; { // 这里的 data3 接收的是 普通值 \u0026#39;qianguyihao\u0026#39; console.log(data3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Promise 的常用 API：实例方法【重要】 Promise 自带的 API 提供了如下实例方法：\npromise.then()：获取异步任务的正常结果。\npromise.catch()：获取异步任务的异常结果。\npromise.finaly()：异步任务无论成功与否，都会执行。\n代码举例如下。\n写法 1：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function queryData() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(function () { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } queryData() .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(\u0026#39;接口请求成功时，走这里\u0026#39;); console.log(data); }) .catch((data) =\u0026gt; { // 从 reject 获取异常结果 console.log(\u0026#39;接口请求失败时，走这里\u0026#39;); console.log(data); }) .finally(() =\u0026gt; { console.log(\u0026#39;无论接口请求成功与否，都会走这里\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 写法 2：（和上面的写法 1 等价）\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function queryData() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(function () { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } queryData() .then( (data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(\u0026#39;接口请求成功时，走这里\u0026#39;); console.log(data); }, (data) =\u0026gt; { // 从 reject 获取异常结果 console.log(\u0026#39;接口请求失败时，走这里\u0026#39;); console.log(data); } ) .finally(() =\u0026gt; { console.log(\u0026#39;无论接口请求成功与否，都会走这里\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意：写法 1 和写法 2 的作用是完全等价的。只不过，写法 2 是把 catch 里面的代码作为 then 里面的第二个参数而已。\nPromise 的常用 API：对象方法【重要】 Promise 自带的 API 提供了如下对象方法：\nPromise.all()：并发处理多个异步任务，所有任务都执行成功，才能得到结果。\nPromise.race(): 并发处理多个异步任务，只要有一个任务执行成功，就能得到结果。\n下面来详细介绍。\nPromise.all() 代码举例 代码举例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 封装 Promise 接口调用 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常结果 resolve(xhr.responseText); } else { // 处理异常结果 reject(\u0026#39;服务器错误\u0026#39;); } }; xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); }); } var promise1 = queryData(\u0026#39;http://localhost:3000/api1\u0026#39;); var promise2 = queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); var promise3 = queryData(\u0026#39;http://localhost:3000/api3\u0026#39;); Promise.all([promise1, promise2, promise3]).then((result) =\u0026gt; { console.log(result); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Promise.race() 代码举例 代码举例：\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 封装 Promise 接口调用 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常结果 resolve(xhr.responseText); } else { // 处理异常结果 reject(\u0026#39;服务器错误\u0026#39;); } }; xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); }); } var promise1 = queryData(\u0026#39;http://localhost:3000/api1\u0026#39;); var promise2 = queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); var promise3 = queryData(\u0026#39;http://localhost:3000/api3\u0026#39;); Promise.race([promise1, promise2, promise3]).then((result) =\u0026gt; { console.log(result); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://lvsijun.gitee.io/website/home/11-promise%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E5%92%8Capi/","tags":null,"title":"Promise的常见用法"},{"categories":null,"contents":"前言：异步和回调 异步 JavaScript 的执行环境是单线程。\n所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。\n异步模式可以一起执行多个任务。常见的异步模式有以下几种：\n定时器\n接口调用\n事件函数\n今天这篇文章，我们重点讲一下接口调用。接口调用里，重点讲一下Promise。\n接口调用的方式 js 中常见的接口调用方式，有以下几种：\n原生 ajax、基于 jQuery 的 ajax Promise Fetch axios 多次异步调用的顺序 多次异步调用的结果，顺序可能不同步。\n异步调用的结果如果存在依赖，则需要通过回调函数进行嵌套。\n回调地狱的举例 假设买菜、做饭、洗碗、倒厨余垃圾都是异步的。\n但真实的场景中，实际的操作流程是：买菜成功之后，才能开始做饭。做饭成功后，才能开始洗碗。洗碗结束后， 再倒厨余垃圾。这里的一系列动作就涉及到了多层嵌套调用，也就是回调地狱。\n在 ES5 中，当进行多层嵌套回调时，会导致代码层次过多，很难进行后续维护和二次开发；而且会导致回调地狱的问题。ES6 中的 Promise 就可以解决这两个问题。\nPromise 概述 为什么需要 Promise？ 如上一段所述，Javascript 是⼀⻔单线程语⾔。早期我们解决异步场景时，⼤部分情况都是通过回调函数来进⾏。\n例如在浏览器中发送 ajax 请求，就是常⻅的⼀个异步场景，发送请求后，需要等待一段时间，等服务端响应之后我们才能拿到结果。如果我们希望在异步结束之后执⾏某个操作，就只能通过回调函数这样的⽅式进⾏操作。\nvar dynamicFunc = function (callback) { setTimeout(function () { callback(); }, 1000); }; dynamicFunc(function () { console.log(\u0026#39;qian gu\u0026#39;); }); 例如上⾯这个例⼦，dynamicFunc 就是⼀个异步函数，⾥⾯ setTimeout 会在 1s 之后调⽤传⼊的 callback 函数。按照上⾯的调⽤⽅式，最终 1s 之后，会打印 qian gu 这个结果。\n同样的，如果后续还有内容需要在异步函数结束时输出，就需要多个异步函数进⾏嵌套，⾮常不利于后续的维护，而且会导致回调地狱的问题：\nsetTimeout(function () { console.log(\u0026#39;qiangu1\u0026#39;); setTimeout(function () { console.log(\u0026#39;qiangu2\u0026#39;); }, 2000); }, 1000); 为了能使回调函数以更优雅的⽅式进⾏调⽤，在 ES6 语法中，新增了⼀个名为 Promise 的新规范。\nPromise 的介绍和优点 ES6 中的 Promise 是异步编程的一种方案。从语法上讲，Promise 是一个对象，它可以获取异步操作的消息。\nPromise 对象, 可以用同步的表现形式来书写异步代码（也就是说，代码看起来是同步的，但本质上的运行过程是异步的）。使用 Promise 主要有以下好处：\n可以很好地解决回调地狱的问题（避免了层层嵌套的回调函数）。\n语法非常简洁、可读性强，便于后期维护。Promise 对象提供了简洁的 API，使得控制异步操作更加容易。\nPromise 基础 Promise 的基本用法 （1）通过 new Promise() 构造出一个 Promise 实例。Promise 的构造函数中传入一个参数，这个参数是一个函数，该函数用于处理异步任务。\n（2）函数中传入两个参数：resolve 和 reject，分别表示异步执行成功后的回调函数和异步执行失败后的回调函数。代表着我们需要改变当前实例的状态到已完成或是已拒绝。\n（3）通过 promise.then() 处理返回结果（这里的 promise 指的是 Promise 实例）。\n接下来，我们来具体看看， promise 的代码是怎么写的。\nPromise 处理异步任务的过程 通过 Promise 处理异步任务的典型写法如下：\n// 第一步：model层的接口封装 function promiseA() { return new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如 ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } // 第二步：业务层的接口调用。这里的 data 就是 从 resolve 和 reject 传过来的，也就是从接口拿到的数据 promiseA() .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(data); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 上方代码中，当从接口返回的数据data.retCode的值（接口返回码）不同时，可能会走 resolve，也可能会走 reject，这个由你自己的业务决定。\n上面的写法中，是将 promise 实例定义成了一个函数 PromiseA。我们也可以将 promise 实例定义成一个变量 promiseB，达到的效果是一模一样的。写法如下：（写法上略有区别）\n// 第一步：model层的接口封装 const promiseB = new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); // 第二步：业务层的接口调用。这里的 data 就是 从 resolve 和 reject 传过来的，也就是从接口拿到的数据 promiseB .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(data); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 捕获 reject 异常状态的两种写法 我们有两种写法可以捕获并处理 reject 异常状态。上一小段中，用的就是其中一种写法。\n这两种写法的代码举例如下：\n// 第一步：model层的接口封装 function promiseA() { return new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如 ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } const onResolve = function (value) { console.log(value); }; const onReject = function (e) { console.log(e); }; // 写法1：通过 catch 方法捕获 状态变为已拒绝时的 promise promiseA().then(onResolve).catch(onReject); // 写法2：then 可以传两个参数，第⼀个参数为 resolve 后执⾏，第⼆个参数为 reject 后执⾏ promiseA().then(onResolve, onReject); // 【错误写法】写法3：通过 try catch 捕获 状态变为已拒绝时的 promise // 这种写法是错误的，因为 try catch只能捕获同步代码里的异常，而 promise.reject() 是异步代码。 try { promiseA().then(onResolve); } catch (e) { // 语法上，catch必须要传入一个参数，否则报错 onReject(e); } 需要注意的是：\n（1）上面的写法 3 是错误的。运行之后，控制台会报如下错误：\n解释如下：\ntry-catch 主要用于捕获异常，注意，这里的异常是指同步函数的异常。如果 try 里面的异步方法出现了异常，此时 catch 是无法捕获到异常的。\n原因是：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言（比如 promise）promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。\n（2）写法1中，promiseA().then().catch()和promiseA().catch().then()区别在于：前者可以捕获到 then 里面的异常，后者不可以。\n小结 1、promise 有三种状态：等待中、成功、失败。等待中状态可以更改为成功或失败，已经更改过状态后⽆法继续更改（例如从失败改为成功）。\n2、promise 实例中需要传⼊⼀个函数，他接受两个函数参数，执⾏第⼀个参数之后就会改变当前 promise 为「成功」状态，执⾏第⼆个参数之后就会变为「失败」状态。\n3、通过 .then ⽅法，即可在上⼀个 promise 达到成功时继续执⾏下⼀个函数或 promise。同时通过 resolve 或 reject 时传⼊参数，即可给下⼀个函数或 promise 传⼊初始值。\n4、失败的 promise，后续可以通过 promise 自带的 .catch ⽅法或是 .then ⽅法的第⼆个参数进⾏捕获。\nPromise 规范 Promise 规范解读 Promise 是⼀个拥有 then ⽅法的对象或函数。任何符合 promise 规范的对象或函数都可以成为 Promise。\n关于promise 规范的详细解读，可以看下面这个链接：\nPromises/A+ 规范：https://promisesaplus.com/ promise 对象的 3 个状态 初始化（等待中）：pending\n成功：fulfilled\n失败：rejected\n（1）当 new Promise()执行之后，promise 对象的状态会被初始化为pending，这个状态是初始化状态。new Promise()这行代码，括号里的内容是同步执行的。括号里定义一个 function，function 有两个参数：resolve 和 reject。如下：\n如果请求成功了，则执行 resolve()，此时，promise 的状态会被自动修改为 fulfilled。\n如果请求失败了，则执行 reject()，此时，promise 的状态会被自动修改为 rejected\n（2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2：\n如果 promise 的状态为 fulfilled（意思是：如果请求成功），则执行 function1 里的内容\n如果 promise 的状态为 rejected（意思是，如果请求失败），则执行 function2 里的内容\n另外，resolve()和 reject()这两个方法，是可以给 promise.then()传递参数的。\n完整代码举例如下：\nlet promise = new Promise((resolve, reject) =\u0026gt; { //进来之后，状态为pending console.log(\u0026#39;111\u0026#39;); //这行代码是同步的 //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器） if (异步的ajax请求成功) { console.log(\u0026#39;333\u0026#39;); resolve(\u0026#39;haha\u0026#39;); //如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fulfilled } else { reject(\u0026#39;555\u0026#39;); //如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected } }); console.log(\u0026#39;222\u0026#39;); //调用promise的then() promise.then( (successMsg) =\u0026gt; { //如果promise的状态为fulfilled，则执行这里的代码 console.log(successMsg, \u0026#39;成功了\u0026#39;); }, (errorMsg) =\u0026gt; { //如果promise的状态为rejected，则执行这里的代码 console.log(errorMsg, \u0026#39;失败了\u0026#39;); } ); 如何封装异步操作为 promise Promise 封装异步任务 传统写法：\n写法 1：\n// 定义一个异步的延迟函数：异步函数结束1秒之后，再执行cb回调函数 function fun1(cb) { setTimeout(function () { console.log(\u0026#39;即将执行cb回调函数\u0026#39;); cb(); }, 1000); } // 先执行异步函数 fun1，再执行回调函数 myCallback fun1(myCallback); // 定义回调函数 function myCallback() { console.log(\u0026#39;我是延迟执行的cb回调函数\u0026#39;); } 写法 2：（精简版，更常见）\n// 定义一个异步的延迟函数：异步函数结束1秒之后，再执行cb回调函数 function fun1(cb) { setTimeout(cb, 1000); } // 先执行异步函数fun1，再执行回调函数 fun1(function () { console.log(\u0026#39;我是延迟执行的cb回调函数\u0026#39;); }); 上⾯的例⼦就是最传统的写法，在异步结束后通过传入回调函数的方式执⾏函数。\n学习 Promise 之后，我们可以将这个异步函数封装为 Promise，如下。\nPromise 写法：\nfunction fun2() { return new Promise((resolve) =\u0026gt; { setTimeout(resolve, 1000); }); } /* 【重要】上面的 fun2 也可以写成： function fun2() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(); }, 1000); }); } */ // 先执行异步函数fun1，再执行回调函数 fun2().then(() =\u0026gt; { console.log(\u0026#39;我是延迟执行的回调函数\u0026#39;); }); Promise 封装 Ajax 请求 传统写法：\n// 定义 ajax 请求：传入回调函数 success 和 fail function ajax(url, success, fail) { var client = new XMLHttpRequest(); client.open(\u0026#39;GET\u0026#39;, url); client.onreadystatechange = function () { if (this.readyState !== 4) { return; } if (this.status === 200) { success(this.response); } else { fail(new Error(this.statusText)); } }; client.send(); } // 执行 ajax 请求 ajax( \u0026#39;/ajax.json\u0026#39;, function () { console.log(\u0026#39;qianguyihao 成功\u0026#39;); }, function () { console.log(\u0026#39;失败\u0026#39;); } ); 上面的传统写法里，定义和执行 ajax 时需要传⼊ success 和 fail 这两个回调函数，进而执行回调函数。\n有了 Promise 之后，我们不需要传入回调函数，而是：\n先将 promise 实例化；\n然后在原来执行回调函数的地方，改为执行对应的改变 promise 状态的函数；\n并通过 then \u0026hellip; catch 或者 then \u0026hellip;then 等写法，实现链式调用，提高代码可读性。\n和传统写法相比，promise 在写法上的大致区别是：定义异步函数的时候，将 callback 改为 resolve 和 reject，待状态改变之后，我们在外面控制具体执行哪些函数。\nPromise 写法：\nconst request = require(\u0026#39;request\u0026#39;); // Promise 定义接口 function request1() { return new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, (response) =\u0026gt; { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); } request1() .then((res1) =\u0026gt; { // 接口1请求成功后，打印接口1的返回结果 console.log(res1); return request2(); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 总结 了解这些内容之后， 你已经对 Promise 有了基本了解。下一篇文章，我们来讲一讲 Promise在实战开发的常见用法。\n参考链接 当面试官问你 Promise 的时候，他究竟想听到什么？\n手写一个 Promise/A+,完美通过官方 872 个测试用例\n","permalink":"https://lvsijun.gitee.io/website/home/10-promise%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/","tags":null,"title":"Promise入门详解"},{"categories":null,"contents":"Symbol 概述 背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。\n概念：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n特点：\nSymbol属性对应的值是唯一的，解决命名冲突问题\nSymbol值不能与其他数据进行计算，包括同字符串拼串\nfor in、for of 遍历时不会遍历Symbol属性。\n创建Symbol属性值 Symbol是函数，但并不是构造函数。创建一个Symbol数据类型：\nlet mySymbol = Symbol(); console.log(typeof mySymbol); //打印结果：symbol console.log(mySymbol); //打印结果：Symbol() 打印结果：\n下面来讲一下Symbol的使用。\n1、将Symbol作为对象的属性值 let mySymbol = Symbol(); let obj = { name: \u0026#39;smyhvae\u0026#39;, age: 26 }; //obj.mySymbol = \u0026#39;male\u0026#39;; //错误：不能用 . 这个符号给对象添加 Symbol 属性。 obj[mySymbol] = \u0026#39;hello\u0026#39;; //正确：通过**属性选择器**给对象添加 Symbol 属性。后面的属性值随便写。 console.log(obj); 上面的代码中，我们尝试给obj添加一个Symbol类型的属性值，但是添加的时候，不能采用.这个符号，而是应该用属性选择器的方式。打印结果：\n现在我们用for in尝试对上面的obj进行遍历：\nlet mySymbol = Symbol(); let obj = { name: \u0026#39;smyhvae\u0026#39;, age: 26 }; obj[mySymbol] = \u0026#39;hello\u0026#39;; console.log(obj); //遍历obj for (let i in obj) { console.log(i); } 打印结果：\n从打印结果中可以看到：for in、for of 遍历时不会遍历Symbol属性。\n创建Symbol属性值时，传参作为标识 如果我通过 Symbol()函数创建了两个值，这两个值是不一样的：\nlet mySymbol1 = Symbol(); let mySymbol2 = Symbol(); console.log(mySymbol1 == mySymbol2); //打印结果：false console.log(mySymbol1); //打印结果：Symbol() console.log(mySymbol2); //打印结果：Symbol() 上面代码中，倒数第三行的打印结果也就表明了，二者的值确实是不相等的。\n最后两行的打印结果却发现，二者的打印输出，肉眼看到的却相同。那该怎么区分它们呢？\n既然Symbol()是函数，函数就可以传入参数，我们可以通过参数的不同来作为标识。比如：\n//在括号里加入参数，来标识不同的Symbol let mySymbol1 = Symbol(\u0026#39;one\u0026#39;); let mySymbol2 = Symbol(\u0026#39;two\u0026#39;); console.log(mySymbol1 == mySymbol2); //打印结果：false console.log(mySymbol1); //打印结果：Symbol(one) console.log(mySymbol2); //打印结果：Symbol(two)。颜色为红色。 console.log(mySymbol2.toString());//打印结果：Symbol(two)。颜色为黑色。 打印结果：\n定义常量 Symbol 可以用来定义常量：\nconst MY_NAME = Symbol(\u0026#39;my_name\u0026#39;); 内置的 Symbol 值 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。\nSymbol.iterator属性 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\n","permalink":"https://lvsijun.gitee.io/website/home/es6symbol/","tags":null,"title":"Symbol"},{"categories":null,"contents":"解构赋值的概念 解构赋值：ES6 允许我们，按照一一对应的方式，从数组或者对象中提取值，再将提取出来的值赋值给变量。\n解构：分解数据结构；赋值：给变量赋值。\n解构赋值在实际开发中可以大量减少我们的代码量，并且让程序结构更清晰。\n数组的解构赋值 数组的结构赋值：将数组中的值按照位置提取出来，然后赋值给变量。\n语法 在 ES6 之前，当我们在为一组变量赋值时，一般是这样写：\nvar a = 1; var b = 2; var c = 3; 或者是这样写：\nvar arr = [1, 2, 3]; var a = arr[0]; var b = arr[1]; var c = arr[2]; 现在有了 ES6 之后，我们可以通过数组解构的方式进行赋值：（根据位置进行一一对应）\nlet [a, b, c] = [1, 2, 3]; 二者的效果是一样的，但明显后者的代码更简洁优雅。\n未匹配到的情况 数据的结构赋值，是根据位置进行一一对应来赋值的。可如果左边的数量大于右边的数量时（也就是变量的数量大于值的数量时），多余的变量要怎么处理呢？\n答案是：如果变量在一一对应时，没有找到对应的值，那么，多余的变量会被赋值为 undefined。\n解构时，左边允许有默认值 在解构赋值时，是允许使用默认值的。举例如下：\n{ //一个变量时 let [foo = true] = []; console.log(foo); //输出结果：true } { //两个变量时 let [a, b] = [\u0026#39;生命壹号\u0026#39;]; //a 赋值为：生命壹号。b没有赋值 console.log(a + \u0026#39;,\u0026#39; + b); //输出结果：生命壹号,undefined } { //两个变量时 let [a, b = \u0026#39;smyhvae\u0026#39;] = [\u0026#39;生命壹号\u0026#39;]; //a 赋值为：生命壹号。b 采用默认值 smyhvae console.log(a + \u0026#39;,\u0026#39; + b); //输出结果：生命壹号,smyhvae } 将右边的 undefined和null赋值给变量 如果我们在赋值时，采用的是 undefined或者null，那会有什么区别呢？\n{ let [a, b = \u0026#39;smyhvae\u0026#39;] = [\u0026#39;生命壹号\u0026#39;, undefined]; //b 虽然被赋值为 undefined，但是 b 会采用默认值 console.log(a + \u0026#39;,\u0026#39; + b); //输出结果：生命壹号,smyhvae } { let [a, b = \u0026#39;smyhvae\u0026#39;] = [\u0026#39;生命壹号\u0026#39;, null]; //b 被赋值为 null console.log(a + \u0026#39;,\u0026#39; + b); //输出结果：生命壹号,null } 上方代码分析：\nundefined：相当于什么都没有，此时 b 采用默认值。\nnull：相当于有值，但值为 null。\n对象的解构赋值 对象的结构赋值：将对象中的值按照属性匹配的方式提取出来，然后赋值给变量。\n语法 在 ES6 之前，我们从接口拿到 json 数据后，一般这么赋值：\nvar name = json.name; var age = json.age; var sex = json.sex; 上面这种写法，过于麻烦了。\n现在，有了 ES6 之后，我们可以使用对象解构的方式进行赋值。举例如下：\nconst person = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, sex: \u0026#39;男\u0026#39; }; let { name, age, sex } = person; // 对象的结构赋值 console.log(name); // 打印结果：qianguyihao console.log(age); // 打印结果：28 console.log(sex); // 打印结果：男 上方代码可以看出，对象的解构与数组的结构，有一个重要的区别：数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，是根据键来取值的。\n未匹配到的情况 对象的结构赋值，是根据属性名进行一一对应来赋值的。可如果左边的数量大于右边的数量时（也就是变量的数量大于值的数量时），多余的变量要怎么处理呢？\n答案是：如果变量在一一对应时，没有找到对应的值，那么，多余的变量会被赋值为 undefined。\n给左边的变量自定义命名 对象的结构赋值里，左边的变量名一定要跟右边的属性名保持一致么？答案是不一定。我们可以单独给左边的变量自定义命名。\n举例如下：\nconst person = { name: \u0026#39;qianguyihao\u0026#39;, age: 28 }; let { name: myName, age: myAge } = person; // 对象的结构赋值 console.log(myName); // 打印结果：qianguyihao console.log(myAge); // 打印结果：28 console.log(name); // 打印报错：Uncaught ReferenceError: name is not defined console.log(age); // 打印报错：Uncaught ReferenceError: age is not defined 上方的第 2 行代码中：（请牢记）\n等号左边的属性名 name、age 是对应等号右边的属性名。\n等号左边的 myName、myAge 是左边自定义的变量名。\n或者，我们也可以理解为：将右边 name 的值赋值给左边的 myName 变量，将右边 age 的值赋值给左边的 myAge 变量。现在，你应该一目了然了吧？\n圆括号的使用 如果变量 foo 在解构之前就已经定义了，此时你再去解构，就会出现问题。下面是错误的代码，编译会报错：\nlet foo = \u0026#39;haha\u0026#39;; { foo } = { foo: \u0026#39;smyhvae\u0026#39; }; console.log(foo); 要解决报错，只要在解构的语句外边，加一个圆括号即可：\nlet foo = \u0026#39;haha\u0026#39;; ({ foo } = { foo: \u0026#39;smyhvae\u0026#39; }); console.log(foo); //输出结果：smyhvae 字符串解构 字符串也可以解构，这是因为，此时字符串被转换成了一个类似数组的对象。举例如下：\nconst [a, b, c, d] = \u0026#39;hello\u0026#39;; console.log(a); console.log(b); console.log(c); console.log(typeof a); //输出结果：string 打印结果：\nh\re\rl\rstring ","permalink":"https://lvsijun.gitee.io/website/archives/%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.html/","tags":null,"title":"变量的解构赋值"},{"categories":null,"contents":"前言 ES6 在函数扩展方面，新增了很多特性。例如：\n箭头函数\n参数默认值\n参数结构赋值\n剩余参数\n扩展运算符\nthis 绑定\n尾调用\n今天这篇文章，我们讲一下箭头函数。\n箭头函数 定义箭头函数的语法 语法：\n(参数1, 参数2 ...) =\u0026gt; { 函数体 } 解释：\n如果有且仅有 1 个形参，则()可以省略\n如果函数体内有且仅有 1 条语句，则{}可以省略，但前提是，这条语句必须是 return 语句。\n需要强调的是，箭头函数是没有函数名的，既然如此，那要怎么调用箭头函数呢？你可以将箭头函数赋值给一个变量，通过变量名调用函数；也可以直接使用箭头函数。我们来看看下面的例子。\n举例 写法 1、定义和调用函数：（传统写法）\nfunction fn1(a, b) { console.log(\u0026#39;haha\u0026#39;); return a + b; } console.log(fn1(1, 2)); //输出结果：3 写法 2、定义和调用函数：（ES6 中的写法）\nconst fn2 = (a, b) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + b; }; console.log(fn2(1, 2)); //输出结果：3 上面的两种写法，效果是一样的。\n从上面的箭头函数中，我们可以很清晰地看到变量名、参数名、函数体。\n另外，箭头函数的写法还可以精简一下，继续往下看。\n在箭头函数中，如果方法体内只有一句话，且这句话是 return 语句，那就可以把 {}省略。写法如下：\nconst fn2 = (a, b) =\u0026gt; a + b; console.log(fn2(1, 2)); //输出结果：3 在箭头函数中，如果形参只有一个参数，则可以把()省略。写法如下：\nconst fn2 = (a) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + 1; }; console.log(fn2(1)); //输出结果：2 箭头函数的 this 的指向 箭头函数只是为了让函数写起来更简洁优雅吗？当然不只是这个原因，还有一个很大的作用是与 this 的指向有关。\nES6 之前的普通函数中：this 指向的是函数被调用的对象（也就是说，谁调用了函数，this 就指向谁）。\n而 ES6 的箭头函数中：箭头函数本身不绑定 this，this 指向的是箭头函数定义位置的 this（也就是说，箭头函数在哪个位置定义的，this 就跟这个位置的 this 指向相同）。\n代码举例：\nconst obj = { name: \u0026#39;千古壹号\u0026#39; }; function fn1() { console.log(this); // 第一个 this return () =\u0026gt; { console.log(this); // 第二个 this }; } const fn2 = fn1.call(obj); fn2(); 打印结果：\nobj\robj 代码解释：（一定要好好理解下面这句话）\n上面的代码中，箭头函数是在 fn1()函数里面定义的，所以第二个 this 跟 第一个 this 指向的是同一个位置。又因为，在执行 fn1.call(obj)之后，第一个 this 就指向了 obj，所以第二个 this 也是指向 了 obj。\n面试题：箭头函数的 this 指向 代码举例：\nconst name = \u0026#39;许嵩\u0026#39;; const obj = { name: \u0026#39;千古壹号\u0026#39;, sayHello: () =\u0026gt; { console.log(this.name); }, }; obj.sayHello(); 上方代码的打印结果是什么？你可能很难想到。\n正确答案的打印结果是许嵩。因为 obj 这个对象并不产生作用域， sayHello() 这个箭头函数实际仍然是定义在 window 当中的，所以 这里的 this 指向是 window。\n参数默认值 传统写法：\nfunction fn(param) { let p = param || \u0026#39;hello\u0026#39;; console.log(p); } 上方代码中，函数体内的写法是：如果 param 不存在，就用 hello字符串做兜底。这样写比较啰嗦。\nES6 写法：（参数默认值的写法，很简洁）\nfunction fn(param = \u0026#39;hello\u0026#39;) { console.log(param); } 在 ES6 中定义方法时，我们可以给方法里的参数加一个默认值（缺省值）：\n方法被调用时，如果没有给参数赋值，那就是用默认值；\n方法被调用时，如果给参数赋值了新的值，那就用新的值。\n如下：\nvar fn2 = (a, b = 5) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + b; }; console.log(fn2(1)); //第二个参数使用默认值 5。输出结果：6 console.log(fn2(1, 8)); //输出结果：9 提醒 1：默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。\n提醒 2：\n我们来看下面这段代码：\nlet x = \u0026#39;smyh\u0026#39;; function fn(x, y = x) { console.log(x, y); } fn(\u0026#39;vae\u0026#39;); 注意第二行代码，我们给 y 赋值为x，这里的x是括号里的第一个参数，并不是第一行代码里定义的x。打印结果：vae vae。\n如果我把第一个参数改一下，改成：\nlet x = \u0026#39;smyh\u0026#39;; function fn(z, y = x) { console.log(z, y); } fn(\u0026#39;vae\u0026#39;); 此时打印结果是：vae smyh。\n","permalink":"https://lvsijun.gitee.io/website/home/06-es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","tags":null,"title":"箭头函数"},{"categories":null,"contents":"Set 数据结构 Set 数据结构的介绍 ES6 提供了 新的数据结构 Set。Set 类似于数组，但成员的值都是唯一的，没有重复的值。\nSet 的应用有很多。比如，在 H5 页面的搜索功能里，用户可能会多次搜索重复的关键字；但是在数据存储上，不需要存储重复的关键字。此时，我们就可以用 Set 来存储用户的搜索记录，Set 内部会自动判断值是否重复，如果重复，则不会进行存储，十分方便。\n生成 Set 数据结构 Set 本身就是一个构造函数，可通过 new Set() 生成一个 Set 的实例。\n举例 1：\nconst set1 = new Set(); console.log(set1.size); // 打印结果：0 举例 2、可以接收一个数组作为参数，实现数组去重：\nconst set2 = new Set([\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;, \u0026#39;张三\u0026#39;]); // 注意，这个数组里有重复的值 // 注意，这里的 set2 并不是数组，而是一个单纯的 Set 数据结构 console.log(set2); // {\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;} // 通过扩展运算符，拿到 set 中的元素（用逗号分隔的序列） // ...set2 // \u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34; // 注意，到这一步，才获取到了真正的数组 console.log([...set2]); // [\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;] 注意上方的第一行代码，虽然参数里传递的是数组结构，但拿到的 set2 不是数组结构，而是 Set 结构，而且里面元素是去重了的。通过 [...set2]就可以拿到set2对应的数组。\n","permalink":"https://lvsijun.gitee.io/website/home/09-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","tags":null,"title":"内置对象扩展：set数据结构"},{"categories":null,"contents":"剩余参数 剩余参数允许我们将不确定数量的剩余的元素放到一个数组中。\n比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。\n传统写法：\nES5 中，在定义方法时，参数要确定个数，如下：（程序会报错）\nfunction fn(a, b, c) { console.log(a); console.log(b); console.log(c); console.log(d); } fn(1, 2, 3); 上方代码中，因为方法的参数是三个，但使用时是用到了四个参数，所以会报错：\nES6 写法：\nES6 中，我们有了剩余参数，就不用担心报错的问题了。代码可以这样写：\nconst fn = (...args) =\u0026gt; { //当不确定方法的参数时，可以使用剩余参数 console.log(args[0]); console.log(args[1]); console.log(args[2]); console.log(args[3]); }; fn(1, 2); fn(1, 2, 3); //方法的定义中了四个参数，但调用函数时只使用了三个参数，ES6 中并不会报错。 打印结果：\n1 2 undefined undefined 1 2 3 undefined 上方代码中注意，args 参数之后，不能再加别的参数，否则编译报错。\n下面这段代码，也是利用到了剩余参数：\nfunction fn1(first, ...args) { console.log(first); // 10 console.log(args); // 数组：[20, 30] } fn1(10, 20, 30); 剩余参数的举例：参数求和 代码举例：\nconst sum = (...args) =\u0026gt; { let total = 0; args.forEach(item =\u0026gt; total += item); // 注意 forEach里面的代码，写得 很精简 return total; }; console.log(sum(10, 20, 30)); 打印结果：60\n剩余参数和解构赋值配合使用 代码举例：\nconst students = [\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;]; let [s1, ...s2] = students; console.log(s1); // \u0026#39;张三\u0026#39; console.log(s2); // [\u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;] 扩展运算符（展开语法） 扩展运算符和剩余参数是相反的。\n剩余参数是将剩余的元素放到一个数组中；而扩展运算符是将数组或者对象拆分成逗号分隔的参数序列。\n代码举例：\nconst arr = [10, 20, 30]; ...arr // 10, 20, 30 注意，这一行是伪代码，这里用到了扩展运算符 console.log(...arr); // 10 20 30 console.log(10, 20, 30); // 10 20 30 上面的代码要仔细看：\narr是一个数组，而...arr则表示10, 20, 30这样的序列。\n我们把...arr 打印出来，发现打印结果竟然是 10 20 30，为啥逗号不见了呢？因为逗号被当作了 console.log 的参数分隔符。如果你不信，可以直接打印 console.log(10, 20, 30) 看看。\n接下来，我们看一下扩展运算符的应用。\n举例1：数组赋值 数组赋值的代码举例：\nlet arr2 = [...arr1]; // 将 arr1 赋值给 arr2 为了理解上面这行代码，我们先来分析一段代码：（将数组 arr1 赋值给 arr2）\nlet arr1 = [\u0026#39;www\u0026#39;, \u0026#39;smyhvae\u0026#39;, \u0026#39;com\u0026#39;]; let arr2 = arr1; // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); console.log(\u0026#39;---------------------\u0026#39;); arr2.push(\u0026#39;你懂得\u0026#39;); //往 arr2 里添加一部分内容 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); 运行结果：\n上方代码中，我们往往 arr2 里添加了你懂的，却发现，arr1 里也有这个内容。原因是：let arr2 = arr1;其实是让 arr2 指向 arr1 的地址。也就是说，二者指向的是同一个内存地址。\n如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做：\nlet arr1 = [\u0026#39;www\u0026#39;, \u0026#39;smyhvae\u0026#39;, \u0026#39;com\u0026#39;]; let arr2 = [...arr1]; //【重要代码】arr2 会重新开辟内存地址 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); console.log(\u0026#39;---------------------\u0026#39;); arr2.push(\u0026#39;你懂得\u0026#39;); //往arr2 里添加一部分内容 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); 运行结果：\narr1:www,smyhvae,com arr2:www,smyhvae,com --------------------- arr1:www,smyhvae,com arr2:www,smyhvae,com,你懂得 我们明白了这个例子，就可以避免开发中的很多业务逻辑上的 bug。\n举例2：合并数组 代码举例：\nlet arr1 = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; let arr2 = [\u0026#39;王四\u0026#39;, \u0026#39;王五\u0026#39;, \u0026#39;王六\u0026#39;]; // ...arr1 // \u0026#39;王一\u0026#39;,\u0026#39;王二\u0026#39;,\u0026#39;王三\u0026#39; // ...arr2 // \u0026#39;王四\u0026#39;,\u0026#39;王五\u0026#39;,\u0026#39;王六\u0026#39; // 方法1 let arr3 = [...arr1, ...arr2]; console.log(arr3); // [\u0026#34;王一\u0026#34;, \u0026#34;王二\u0026#34;, \u0026#34;王三\u0026#34;, \u0026#34;王四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;王六\u0026#34;] // 方法2 arr1.push(...arr2); console.log(arr1); // [\u0026#34;王一\u0026#34;, \u0026#34;王二\u0026#34;, \u0026#34;王三\u0026#34;, \u0026#34;王四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;王六\u0026#34;] 举例3：将伪数组或者可遍历对象转换为真正的数组 代码举例：\nconst myDivs = document.getElementsByClassName(\u0026#39;div\u0026#39;); const divArr = [...myDivs]; // 利用扩展运算符，将伪数组转为真正的数组 补充：\n我们在《JavaScript基础/数组的常见方法》中也学过，还有一种方式，可以将伪数组（或者可遍历对象）转换为真正的数组。语法格式如下：\nlet arr2 = Array.from(arrayLike); ","permalink":"https://lvsijun.gitee.io/website/home/07-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E5%92%8C%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/","tags":null,"title":"剩余参数和扩展运算符"},{"categories":null,"contents":"字符串的扩展 下面提到的字符串的几个方法，更详细的内容，可以看《04-JavaScript 基础/内置对象 String：字符串的常见方法.md》。\nES6 中的字符串扩展如下：\nincludes(str)：判断是否包含指定的字符串\nstartsWith(str)：判断是否以指定字符串开头\nendsWith(str)：判断是否以指定字符串结尾\nrepeat(count)：重复指定次数\n举例如下：\nlet str = \u0026#39;abcdefg\u0026#39;; console.log(str.includes(\u0026#39;a\u0026#39;)); //true console.log(str.includes(\u0026#39;h\u0026#39;)); //false //startsWith(str) : 判断是否以指定字符串开头 console.log(str.startsWith(\u0026#39;a\u0026#39;)); //true console.log(str.startsWith(\u0026#39;d\u0026#39;)); //false //endsWith(str) : 判断是否以指定字符串结尾 console.log(str.endsWith(\u0026#39;g\u0026#39;)); //true console.log(str.endsWith(\u0026#39;d\u0026#39;)); //false //repeat(count) : 重复指定次数a console.log(str.repeat(5)); 打印结果：\nNumber 的扩展 二进制与八进制数值表示法: 二进制用0b, 八进制用0o。 举例：\nconsole.log(0b1010); //10 console.log(0o56); //46 Number.isFinite(i)：判断是否为有限大的数。比如Infinity这种无穷大的数，返回的就是 false。\nNumber.isNaN(i)：判断是否为 NaN。\nNumber.isInteger(i)：判断是否为整数。\nNumber.parseInt(str)：将字符串转换为对应的数值。\nMath.trunc(i)：去除小数部分。\n举例：\n//Number.isFinite(i) : 判断是否是有限大的数 console.log(Number.isFinite(NaN)); //false console.log(Number.isFinite(5)); //true console.log(Number.isFinite(Infinity)); //false //Number.isNaN(i) : 判断是否是NaN console.log(Number.isNaN(NaN)); //true console.log(Number.isNaN(5)); //falsse //Number.isInteger(i) : 判断是否是整数 console.log(Number.isInteger(5.23)); //false console.log(Number.isInteger(5.0)); //true console.log(Number.isInteger(5)); //true //Number.parseInt(str) : 将字符串转换为对应的数值 console.log(Number.parseInt(\u0026#39;123abc\u0026#39;)); //123 console.log(Number.parseInt(\u0026#39;a123abc\u0026#39;)); //NaN // Math.trunc(i) : 直接去除小数部分 console.log(Math.trunc(13.123)); //13 数组的扩展 下面提到的数组的几个方法，更详细的内容，可以看《04-JavaScript 基础/数组的常见方法.md》。\nArray.from()\nfind()\nfindIndex()\n对象的扩展 扩展 1 Object.is(v1, v2); 作用：判断两个数据是否完全相等。底层是通过字符串来判断的。\n我们先来看下面这两行代码的打印结果：\nconsole.log(0 == -0); console.log(NaN == NaN); 打印结果：\ntrue\rfalse 上方代码中，第一行代码的打印结果为 true，这个很好理解。第二行代码的打印结果为 false，因为 NaN 和任何值都不相等。\n但是，如果换成下面这种方式来比较：\nconsole.log(Object.is(0, -0)); console.log(Object.is(NaN, NaN)); 打印结果却是：\nfalse true 代码解释：还是刚刚说的那样，Object.is(v1, v2)比较的是字符串是否相等。\nObject.assign() Object.assign() 在实战开发中，使用到的频率非常高，一定要重视。关于它的内容，详见《04-JavaScript 基础/浅拷贝和深拷贝.md》。\n扩展 3：__proto__属性 举例：\nlet obj1 = { name: \u0026#39;smyhvae\u0026#39; }; let obj2 = {}; obj2.__proto__ = obj1; console.log(obj1); console.log(obj2); console.log(obj2.name); 打印结果：\n上方代码中，obj2 本身是没有属性的，但是通过__proto__属性和 obj1 产生关联，于是就可以获得 obj1 里的属性。\n","permalink":"https://lvsijun.gitee.io/website/home/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/","tags":null,"title":"字符串、数组、对象的扩展"},{"categories":null,"contents":"\n个人说明 我是小布。\n这是一个我在闲暇时间写的博客，记录一些生活琐事，也会写一些技术笔记。\n欢迎和我一起探讨一些问题，或者聊聊人生与想。 the road ahead will be long and our climb will be steep. ✨2023，面朝大海，春暖花开！。 \u0026ndash;2022.12\n博客日志 2022-12-15: 引用hugo主题 hugo-theme-Reader。\n2022-12-10: 博客使用hugo构建。\n友情链接 一些文章写的不错的博主\n涛叔 江卮可乐 梦繁星 依然 王宜楷工作室 随望淡思 叶开楗博客 东东博客 涓滴意念汇成河 南弦 SharpG.的博客 碗里有肉丝 Java码农博客\n推荐网站 繁星API 梦繁星做的api网站，本站多处使用该站接口，稳定速度快。\n版权声明：网站文章所有版权如无特殊说明，均归本人所有。允许转载，标明出处即可。\n","permalink":"https://lvsijun.gitee.io/website/about/","tags":null,"title":"关于"},{"categories":null,"contents":"","permalink":"https://lvsijun.gitee.io/website/message/","tags":null,"title":"留言"},{"categories":null,"contents":"","permalink":"https://lvsijun.gitee.io/website/lab/","tags":null,"title":"实验室"},{"categories":null,"contents":"","permalink":"https://lvsijun.gitee.io/website/search/","tags":null,"title":"搜索"},{"categories":null,"contents":"记录我订阅的周刊，质量不错，内容挺有意思。如果你有推荐，欢迎在评论区分享。\n(以下排名不分先后，仅以记录的先后顺序。)\n周刊 1. DecoHack周刊\nhttps://decohack.zhubai.love/\n为独立创造者提供独立见解，帮助你发现新产品方向，启动和完善你的项目。\n2. 好工具周刊\nhttps://bestxtools.zhubai.love/\n发现并分享有趣，有创意，免费、好用的工具，每周四发布。\n3. 老胡的周刊\nhttps://weekly.howie6879.cn/\n每周记录看到的有价值的信息，主要针对计算机领域，内容主题极大程度被我个人喜好主导。这个项目核心目的在于记录让自己有印象的信息做一个留存以及共享。\n4. 前段精读周刊\nhttps://github.com/ascoders/weekly\n前端界的好文精读，每周更新。\n5. 科技爱好者周刊-阮一峰\nhttps://github.com/ruanyf/weekly\n记录每周值得分享的科技内容，周五发布。\n6. 开发者简报\nhttps://dev.com.cn/\n每周为你轻解读技术创业🚀、酷产品📱、编程语言👨‍💻、开发工具🛠️…等内容\n月刊 hellogithub - https://hellogithub.com/\n每月28号发布\n播客 枫言枫语\nhttps://fyfy.fm/\n听见科技与人文的声音 一档由开发者 @枫影JustinYan 和设计师 @自力hzlzh 主持的播客节目。\n","permalink":"https://lvsijun.gitee.io/website/weekly/","tags":null,"title":"周刊"}]