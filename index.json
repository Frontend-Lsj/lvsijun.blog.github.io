[{"content":"概念 浅拷贝：\n1.创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 2.如果属性是基本类型，拷贝的就是基本类型的值。 3.如果属性是引用类型，拷贝的就是内存地址 。 4.所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\n深拷贝：整个对象拷贝到另一个内存中，修改内容互不影响。\n实现 乞丐版 JSON.. 1 JSON.parse(JSON.stringify()) 可以应对大部分的应用场景，但有很大缺陷， 比如拷贝其他引用类型、拷贝函数、循环引用等情况。\ndeepClone 涉及普通数据类型、复杂数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function clone(target) { if (target === null || typeof target !== \u0026#39;object\u0026#39;) { //如果不是复杂数据类型，直接返回 return target; } if (target instanceof RegExp) return new RegExp(target); if (target instanceof Date) return new Date(target); if (typeof target === \u0026#39;object\u0026#39;) { let cloneTarget = target instanceof Array ? [] : {}; for (const key in target) { cloneTarget[key] = clone(target[key]); } return cloneTarget; } }; ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/20230823-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","summary":"概念 浅拷贝： 1.创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 2.如果属性是基本类型，拷贝的就是基本类型的值。 3.如果属性是引用","title":"深浅拷贝"},{"content":"什么是原型 任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的 prototype 指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有 prototype，只有方法才有 prototype。\n什么是原型链？ 原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。我们知道，每个构造函数都有一个原型对象，每个原型对象都有一个指向构造函数的指针，而实例又包涵一个指向原型对象的内部指 针。 原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到 Object 时，就没有_proto_指向了。 因为_proto_实质找的是 prototype，所以我们只要找这个链条上的构造函数的 prototype。其中 Object.prototype 是没有_proto_属性的，它==null。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的 指针，而实例都包含指向原型对象内部的指针。 我们让原型对象（1）等于另一个原型对象的实例（2）,此时原型对象（2）将包含一个指向原型对象（1）的指针，再让原型对象（2）的实例等于原型对象（3），如此层层递进就构成了实例和原型的链条，这就是原型链的概念每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数想指针(constructor)，而实例对象都包含一个指向原型对象的内部指针(proto)。如果让原型对象等于另一个原型对象的实例，此时的原型对象将包含一个指向另一个原型的指针(proto)，另一个原型也包含着一个指向另一个构造函数的指针(constructor)。假如另一个原型又是另一个类型的实例……这就构成了实例与原型的链条。也叫原型链\n原型继承是 js 的一种继承方式，原型链作为实现继承的主要方法,其基本思路是利用原型让一个引用类型继承另一个引用类型的属性和方法,\n原型继承 利用原型中的成员可以被和其相关的对象共享这一特性，可以实现继承，这种实现继承的方式，就叫做原型继承.\n","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AE%80%E8%BF%B0%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/","summary":"什么是原型 任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的 prototype 指向的对象，即任何对象都是由","title":"简述原型、原型链、(原型)继承"},{"content":"1.判断数据类型 typeof\n1 2 3 4 5 6 7 8 9 10 typeof \u0026#39;seymoe\u0026#39; // \u0026#39;string\u0026#39; typeof true // \u0026#39;boolean\u0026#39; typeof 10 // \u0026#39;number\u0026#39; typeof Symbol() // \u0026#39;symbol\u0026#39; typeof null // \u0026#39;object\u0026#39; `无法判定是否为 null ` typeof undefined // \u0026#39;undefined\u0026#39; typeof {} // \u0026#39;object\u0026#39; typeof [] // \u0026#39;object\u0026#39; typeof(() =\u0026gt; {}) // \u0026#39;function\u0026#39; 弊端：\nnull 的判定有误差 数组、对象都判定为 object instanceof\n1 2 3 4 5 6 7 8 9 10 {} instanceof Object //true [] instanceof Array //true (()=\u0026gt;{}) instanceof Function //true `instanceof 也不是万能的` let arr = [] let obj = {} arr instanceof Array // true arr instanceof Object // true obj instanceof Object // true Object.prototype.toString() 可以说是判定 JavaScript 中数据类型的终极解决方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Object.prototype.toString.call({}) // \u0026#39;[object Object]\u0026#39; Object.prototype.toString.call([]) // \u0026#39;[object Array]\u0026#39; Object.prototype.toString.call(() =\u0026gt; {}) // \u0026#39;[object Function]\u0026#39; Object.prototype.toString.call(\u0026#39;seymoe\u0026#39;) // \u0026#39;[object String]\u0026#39; Object.prototype.toString.call(1) // \u0026#39;[object Number]\u0026#39; Object.prototype.toString.call(true) // \u0026#39;[object Boolean]\u0026#39; Object.prototype.toString.call(Symbol()) // \u0026#39;[object Symbol]\u0026#39; Object.prototype.toString.call(null) // \u0026#39;[object Null]\u0026#39; Object.prototype.toString.call(undefined) // \u0026#39;[object Undefined]\u0026#39; Object.prototype.toString.call(new Date()) // \u0026#39;[object Date]\u0026#39; Object.prototype.toString.call(Math) // \u0026#39;[object Math]\u0026#39; Object.prototype.toString.call(new Set()) // \u0026#39;[object Set]\u0026#39; Object.prototype.toString.call(new WeakSet()) // \u0026#39;[object WeakSet]\u0026#39; Object.prototype.toString.call(new Map()) // \u0026#39;[object Map]\u0026#39; Object.prototype.toString.call(new WeakMap()) // \u0026#39;[object WeakMap]\u0026#39; 2.toString和String的区别 toString()可以将数据都转为字符串，但是null和undefined不可以转换。\n1 2 console.log(null.toString()) //报错 TypeError: Cannot read property \u0026#39;toString\u0026#39; of null console.log(undefined.toString())//报错 TypeError: Cannot read property \u0026#39;toString\u0026#39; of undefined toString()括号中可以写数字，代表进制\n1 2 3 4 二进制：.toString(2); 八进制：.toString(8); 十进制：.toString(10); 十六进制：.toString(16); String()可以将null和undefined转换为字符串，但是没法转进制字符串\n1 2 console.log(String(null));// null console.log(String(undefined));// undefined 3.JS 闭包经典使用场景和含闭包必刷题 闭包是什么？ 闭包是指有权访问另一个函数作用域中变量的函数\n形成闭包的原因 内部的函数存在外部作用域的引用就会导致闭包。\n1 2 3 4 5 6 7 8 9 var a = 0 function foo(){ var b =14 function fo(){ console.log(a, b) } fo() } foo() 变量提升 问题：说一下你对JavaScript变量提升的理解。\n定义：\n在函数体内部，声明变量，会把该变量提升到函数体的最顶端。注意：只提升变量声明，不赋值。\n代码1：\n1 2 3 4 5 fn(); function fn() { var x = 1; var y = 2; } 上方代码中：\n（1）给fn创建函数上下文，找到fn中所有用var声明的变量（即x和y）； （2）将这些变量初始化为undefined； （3）将x赋值为1，将y赋值为2。\n代码2：\n1 2 3 4 fn2(); function fn2() { console.log(2); } 上方代码中：\n（1）创建全局上下文，找到所有用function声明的变量，在环境中“创建”这些变量。 （2）将这些变量初始化，并赋值为 function(){ console.log(2) }（并不是undefined） （3）开始执行代码fn2();\n代码3：（let的出现）\n1 2 3 4 { let x = 1 x = 2 } 上方代码中：\n（1）找到所有用 let 声明的变量，在环境中「创建」这些变量 （2）开始执行代码（注意现在还没有初始化） （3）执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined） （4）执行 x = 2，对 x 进行「赋值」\n代码4：\n1 2 3 4 5 let x = \u0026#39;global\u0026#39; { console.log(x) // Uncaught ReferenceError: x is not defined let x = 1 } 原因有两个：\nconsole.log(x) 中的 x 指的是下面的 x，而不是全局的 x\n执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）\n看到这里，你应该明白了 let 到底有没有提升：\nlet 的「创建」过程被提升了，但是初始化没有提升。\nvar 的「创建」和「初始化」都被提升了。\nfunction 的「创建」「初始化」和「赋值」都被提升了。\n参考链接：\n我用了两个月的时间才理解 let this 问题：下方代码的打印结果是什么？\n1 2 3 4 5 6 7 8 9 10 11 12 function A() { this.name = \u0026#39;smyhvae\u0026#39;; } A.prototype.test = function () { setTimeout(function () { console.log(this.name); }, 1) } var a = new A(); a.test(); 打印结果是window.name，但实际的结果是空的。\n总结1：this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。即：谁调用，指向谁。\n举例：\n1 2 3 4 5 6 7 8 var name = \u0026#39;全局\u0026#39;; function getName() { var name = \u0026#39;局部\u0026#39;; return this.name; }; alert(getName()); 上方代码的打印结果是：全局。\n分析：getName()这个函数其实是window调用的，所以this指向的window，因为外部有name这个变量，所以打印结果为全局。\n总结2：没有明确的当前对象时，this永远指向window。这个在setTimeout里比较常见。\nJS 的 new 操作符做了哪些事情 new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。\nJS 中的垃圾回收机制 必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必 须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。\n这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时 候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：\n1 var a=\u0026#34;hello world\u0026#34;; var b=\u0026#34;world\u0026#34;;var a=b;//这时，会释放掉\u0026#34;hello world\u0026#34;， **释放内存以便再引用垃圾回收的方法：\n标记清除、计数引用。\n**标记清除\n这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可 能用到他们。当离开环境时，就标记为离开环境。 垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。\n**引用计数法\n引用计数法的意思就是每个值没引用的次数， 当声明了一个变量，并用一个引用类型的值赋值给改变量， 则这个值的引用次数为 1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。 用引用计数法会存在内存泄露，下面来看原因：\n1 2 3 4 function problem() { var objA = new Object(); var objB = new Object(); objA.someOtherObject = objB; objB.anotherObject = objA; } 在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。特 别 是 在 DOM对 象 中 ， 也 容 易 存 在 这 种 问 题 ：\n1 2 3 varelement=document.getElementById （ ’‘ ）； var myObj=new Object(); myObj.element=element; element.someObject=myObj; 这样就不会有垃圾回收的过程。\n手写区域 1.自己实现一个 bind 函数 原理：通过 apply 或者 call 方法来实现。\n(1)初始版本\n1 2 3 4 5 6 7 8 Function.prototype.bind=function(obj,arg){ var arg = Array.prototype.slice.call(arguments,1); var context = this; return function(newArg){ arg = arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); } } (2) 考虑到原型链 为什么要考虑？因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型\n1 2 3 4 5 6 7 8 9 10 11 12 13 Function.prototype.bind=function(obj,arg){ var arg = Array.prototype.slice.call(arguments,1); var context = this; var bound = function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); } var F=function(){} //这里需要一个寄生组合继承 F.prototype=context.prototype; bound.prototype=new F(); return bound; } 2.实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正 则对象）\n通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象 Number，String ，Boolean，以及 Date 对象，RegExp 对象的复制。 (1) 前文的方法\n1 2 3 4 5 6 7 function deepClone(obj){ var newObj= obj instanceof Array?[]:{}; for(var i in obj){ newObj[i]=typeof obj[i]==\u0026#39;object\u0026#39;? deepClone(obj[i]) : obj[i]; } return newObj; } 这种方法可以实现一般对象和数组对象的克隆，比如：\n1 2 3 4 5 6 var arr=[1,2,3]; var newArr=deepClone(arr); //newArr-\u0026gt;[1,2,3] var obj={x:1,y:2} var newObj=deepClone(obj); // newObj={x:1,y:2} 但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Number 包装对象 var num = new Number(1); typeof num // \u0026#34;object\u0026#34; var newNum=deepClone(num); //newNum -\u0026gt; {} 空对象 //String 包装对象 var str=new String(\u0026#34;hello\u0026#34;); typeof str //\u0026#34;object\u0026#34; var newStr=deepClone(str); //newStr-\u0026gt; {0:\u0026#39;h\u0026#39;,1:\u0026#39;e\u0026#39;,2:\u0026#39;l\u0026#39;,3:\u0026#39;l\u0026#39;,4:\u0026#39;o\u0026#39;}; //Boolean 包装对象 var bol=new Boolean(true); typeof bol //\u0026#34;object\u0026#34; var newBol=deepClone(bol); // newBol -\u0026gt;{} 空对象 (2) valueof()函数 所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值， 因此默认的 valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。 对 于 原 始 值 或 者 包 装 类 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function baseClone(base){ return base.valueOf(); } //Number var num = new Number(1); var newNum = baseClone(num); //newNum-\u0026gt;1 //String var str = new String(\u0026#39;hello\u0026#39;); var newStr = baseClone(str); // newStr-\u0026gt;\u0026#34;hello\u0026#34; //Boolean var bol = new Boolean(true); var newBol = baseClone(bol); //newBol-\u0026gt; true 其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， 这里用 valueOf 实现，语法上比较符合 规范。\n对于 Date 类型： 因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1 月 1 日以来的毫秒数.因此我们可以在 Date的原型上定义克隆的方法：\n1 2 3 4 5 6 Date.prototype.clone = function(){ return new Date(this.valueOf()); } var date=new Date(\u0026#39;2010\u0026#39;); var newDate=date.clone(); // newDate-\u0026gt; Fri Jan 01 2010 08:00:00 GMT+0800 对 于 正 则 对 象\n1 2 3 4 5 6 7 8 9 10 11 12 RegExp：RegExp.prototype.clone = function() { var pattern = this.valueOf(); var flags = \u0026#39;\u0026#39;; flags += pattern.global ? \u0026#39;g\u0026#39; : \u0026#39;\u0026#39;; flags += pattern.ignoreCase ? \u0026#39;i\u0026#39; : \u0026#39;\u0026#39;; flags += pattern.multiline ? \u0026#39;m\u0026#39; : \u0026#39;\u0026#39;; return new RegExp(pattern.source, flags); }; var reg = new RegExp(\u0026#39;/111/\u0026#39;); var newReg = reg.clone(); //newReg-\u0026gt; /\\/111\\// ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%9F%BA%E7%A1%80/","summary":"1.判断数据类型 typeof 1 2 3 4 5 6 7 8 9 10 typeof \u0026#39;seymoe\u0026#39; // \u0026#39;string\u0026#39; typeof true // \u0026#39;boolean\u0026#39; typeof 10 // \u0026#39;number\u0026#39; typeof Symbol() // \u0026#39;symbol\u0026#39; typeof null // \u0026#39;object\u0026#39; `无法判定是否为 null ` typeof undefined // \u0026#39;undefined\u0026#39; typeof {} // \u0026#39;object\u0026#39; typeof [] // \u0026#39;object\u0026#39; typeof(() =\u0026gt; {}) // \u0026#39;function\u0026#39; 弊端： null","title":"JS基础"},{"content":"1.css 选择器 CSS选择器包括行内样式、id选择器、class选择器、标签选择器，优先级依次降低，!important可用于优先级提升，比行内样式优先级还要高，权重的计算依次为1000,100,10,1，!important的优先级为正无穷。\n2.BFC Block Formatting Context : 块级格式化上下文\nBFC有哪些特性？ 属于同一个BFC的两个相邻容器的上下margin可能会重叠 计算BFC高度时浮动元素也会被计算 BFC的区域不会与浮动容器发生重叠 所有属于BFC中的盒子默认左对齐，并且它们的左边距可以触及到容器的左边线。最后一个盒子，尽管是浮动的，但依然遵循这个原则 BFC是独立容器，容器内部元素不会影响容器外部元素 我们可以解决哪些问题？ 解决外边框的塌陷问题 解决父元素高度塌陷问题 解决浮动重叠问题 怎么生成一个BFC区域？ 设置定位（position）, 不为static或relative（为 absolute 、 fixed） 设置 display 为这些值 inline-block、flex、grid、table、table-cell、table-caption 设置 overflow，且值不为visible (为 auto、scroll、hidden) 设置浮动（float），且值不为none（为 left、right）， 3.盒模型 标准盒模型：width/height = content + padding + border + margin content = content box-sizing:content-box\nie 盒模型：width/height = content + margin content = content + padding + border box-sizing: border-box\n4.实现元素水平垂直居中的多种办法 **4.1 flex\n1 2 3 display:flex; justify-content:center; align-items:center; **4.2 grid\n1 2 3 4 display:grid; justify-content:center; align-items:center; peace-content:center; **4.3 absolute + translate\n1 2 3 4 position:absolute; letf:50%; top:50%; transform:translate(-50%,-50%) **4.4 absolute + 知道元素宽高\n1 2 3 4 5 6 7 width:100px; height:200px; position:absolute; left:50%; top:50%; margin-left:-50px; margin-top:-100px **4.5 absolute + margin:auto\n1 2 3 4 5 6 position:absolute; left:0; right:0; top:0; bottom:0; margin:auto; **4.6 line-height=元素高度 + text-align:center\n1 2 3 4 5 6 .wrap{ width: 400px; height: 300px; line-height: 300px; text-align: center; } 5.css加载会造成堵塞吗？ css并不会阻塞DOM树的解析 css加载会阻塞DOM树渲染 css加载会阻塞后面的js语句的执行\n6.position relative、absolute、static、fixed、sticky\nsticky 粘性定位 relative与fixed的结合体，元素在跨越特定值前被认为是相对定位，之后为固定定位\n7.grid布局 Grid网格布局，是一个基于栅格的二维布局系统，相对于flex一维布局，Grid布局的功能更为强大\nGrid布局可以将网页分成一个个网格，可以任意组合不同的网格，做出各种各样的布局\n网格布局生成属性 1 display:grid | inline-grid grid为块级网格布局，inline-grid为内联块级网格布局\n容器属性 1.grid-template-columns、grid-template-rows grid-template-columns 属性定义每一列的列宽 grid-template-rows 属性定义每一行的行高 值有几个就代表有几列或几行\n1 grid-template-columns\u0026lt;rows\u0026gt;: length | percent(百分比) | auto | fr; 列宽行高都是200px\n1 2 grid-template-columns: 200px 200px 200px; grid-template-rows: 200px 200px 200px; **百分比\n1 2 grid-template-columns: 30% 40% 30%; grid-template-rows: 30% 40% 30%; auto，子项会自适应容器剩余大小撑开\n1 2 grid-template-columns: 200px 100px auto; grid-template-rows: 200px auto 100px; fr，可以理解为比例值，将行与列都分成3份\n1 2 grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; 将第二行与第二列都划分为2份\n1 2 grid-template-columns: 1fr 2fr 1fr; grid-template-rows: 1fr 2fr 1fr; 2.grid-template-areas 网格布局允许指定区域，一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域，以及配合项目上的属性grid-area\n1 2 3 4 5 6 7 grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; grid-template-areas: \u0026#39;f i b\u0026#39; \u0026#39;d a g\u0026#39; \u0026#39;e h c\u0026#39;; // 6 9 2 // 4 1 7 // 5 8 3 3. justify-content、align-content、place-content align-content属性是整个内容区域的垂直位置 justify-content属性是整个内容区域在容器里面的水平位置 place-content 是 align-centent 和 justify-content 的简写\n1 place-content: \u0026lt;align-content\u0026gt; \u0026lt;justify-content\u0026gt;; 4.justify-items、align-items、place-items justify-items属性设置单元格内容的水平位置 align-items属性设置单元格内容的垂直位置 默认值都是stretch，在没给定子项宽高的情况下，会自动拉伸铺满整个容器\nstretch当项目没设置宽度(高度)或是auto的时候，将会自动占满整个容器。 当项目有宽高度是，默认值为start\n1 justify-items\u0026lt;align-items\u0026gt;: start | end | center | stretch; place-items属性是align-items属性和justify-items属性的简写\n1 place-items: \u0026lt;align-items\u0026gt; \u0026lt;justify-items\u0026gt;; 5. repeat()、auto-fill、minmax() repeat()去简化重复的值 auto-fill关键字表示自动填充 minmax()函数产生一个长度范围，表示长度就在这个范围之中，它接受两个参数，分别为最小值和最大值\n项目属性 1.grid-area 通过grid-area属性就可以指定项目放在哪一个区域，但前提是容器需要使用grid-template-areas属性指定了区域\n1 2 3 4 5 6 .father{ display:grid; grid-template-areas: \u0026#39;a a b\u0026#39;\u0026#39;c d d\u0026#39;\u0026#39;e h i\u0026#39;; } .aaa { grid-area: a; background-color: red; } 1 grid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end; 2.grid-column-start、grid-column-end和grid-row-start、grid-row-end与span关键字 表示grid子项占据的区域的起始和终止位置，具体方法就是指定项目的四个边框，分别定位在哪根网格线\ngrid-column-start左边框所在的垂直网格线 grid-column-end右边框所在的垂直网格线 grid-row-start上边框所在的水平网格线 grid-row-end下边框所在的水平网格线 1 2 3 4 grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3; 除了使用默认网格线名字，还可以直接命名网格线\n1 2 3 4 5 6 7 8 9 10 grid-template-columns: [col1] 200px [col2] 200px [col3] 200px [col4]; grid-template-rows: [row1] 200px [row2] 200px [row3] 200px [row4]; .aaa { grid-column-start: col2; grid-column-end: col3; grid-row-start: row2; grid-row-end: row3; background-color: red; } span表示跨越，即左右变宽(上下边框)之间跨越多少个网格\n1 2 grid-column-start: 2; grid-column-end: span 2; 3.grid-row、grid-column grid-column属性是grid-column-start和grid-column-end的简写 grid-row属性是grid-row-start和grid-row-end的简写\n1 2 grid-column: \u0026lt;start-line\u0026gt;/ \u0026lt;end-line\u0026gt;; grid-row: \u0026lt;start-line\u0026gt;/ \u0026lt;end-line\u0026gt;; 4.justify-self、align-self、place-self justify-self属性设置单元格内容的水平位置，跟justify-items属性的用法完全一致，但只作用于单个项目 align-self属性设置单元格内容的垂直位置，跟align-items属性的用法完全一致，只作用于单个项目 place-self属性是align-self属性和justify-self属性的简写\n1 2 3 4 justify-self: start | end | center | stretch; align-self: start | end | center | stretch; place-self: \u0026lt;align-self\u0026gt; \u0026lt;justify-self\u0026gt;; 布局案例 栅格化布局 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 .main { display: grid; grid-template-columns: repeat(12, 1fr); grid-template-rows: 200px; grid-auto-rows: 200px; gap: 20px; width: 600px; height: 600px; margin: 50px auto; padding: 20px; background-color: beige; } .item { display: flex; justify-content: center; align-items: center; color: #fff; font-size: 72px; text-align: center; } .col-1 { grid-area: auto/auto/auto/span 1; background-color: red; } .col-2 { grid-area: auto/auto/auto/span 2; background-color: orange; } .col-3 { grid-area: auto/auto/auto/span 3; background-color: green; } .col-4 { grid-area: auto/auto/auto/span 4; background-color: blue; } .col-5 { grid-area: auto/auto/auto/span 5; background-color: pink; } .col-6 { grid-area: auto/auto/auto/span 6; background-color: aqua; } .col-7 { grid-area: auto/auto/auto/span 7; background-color: darkgoldenrod; } .col-8 { grid-area: auto/auto/auto/span 8; background-color: blueviolet; } .col-9 { grid-area: auto/auto/auto/span 9; background-color: darkcyan; } .col-10 { grid-area: auto/auto/auto/span 10; background-color: blueviolet; } .col-11 { grid-area: auto/auto/auto/span 11; background-color: crimson; } .col-12 { grid-area: auto/auto/auto/span 12; background-color: rgb(183, 241, 241); } \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item col-6\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item col-4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item col-8\u0026#34;\u0026gt;8\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 不规则子项排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 .list { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(4, 1fr); grid-template-areas: \u0026#39;a1 a2 a2\u0026#39;\u0026#39;a3 a2 a2\u0026#39;\u0026#39;a4 a4 a5\u0026#39;\u0026#39;a6 a7 a7\u0026#39;; gap: 20px; width: 600px; height: 800px; margin: 50px auto; padding: 20px; } .item1 { grid-area: a1; background-color: pink; } .item2 { grid-area: a2; background-color: pink; } .item3 { grid-area: a3; background-color: skyblue; } .item4 { grid-area: a4; background-color: pink; } .item5 { grid-area: a5; background-color: pink; } .item6 { grid-area: a6; background-color: orange; } .item7 { grid-area: a7; background-color: orange; } \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item item1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item5\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item6\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item7\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 两栏布局 1 2 3 4 5 6 7 8 9 10 \u0026lt;style\u0026gt; .container{ display: grid; grid-template-columns: 100px auto; /* 或者 100px 1fr */ } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;aside\u0026gt;\u0026lt;/aside\u0026gt; \u0026lt;main\u0026gt;\u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /*自适应列,每列200px*/ grid-template-columns: repeat(auto-fit,200px); /*5列,每列等宽*/ grid-template-columns: repeat(5, 1fr); /*自适应列,每列最小200px*/ grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /*第一列100px,二三列按1:2比例*/ grid-template-columns: 100px 1fr 2fr; /*第一列100px,后面列自适应剩余空间*/ grid-template-columns: 100px auto auto auto; /*前面两列11等宽,后面最后一列最小40px，正常情况下是前一列2倍*/ grid-template-columns: 1fr 1fr minmax(40px,2fr); ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/css/","summary":"1.css 选择器 CSS选择器包括行内样式、id选择器、class选择器、标签选择器，优先级依次降低，!important可用于优先级提升，比行内样式","title":"Css库"},{"content":"事件循环概念 JavaScript代码的执行过程中，除了依靠函数调用栈来限制函数的执行顺序外，还要依靠任务队列(task queue)来约束其它代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。\n**macro-task大概包括：\nscript(整体代码) setTimeout setInterval setImmediate I/O UI render **micro-task大概包括:\nprocess.nextTick Promise Async/Await(实际就是promise) MutationObserver(html5新特性) 执行顺序：\n执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。举个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 async function async1(){ await async2() console.log(\u0026#34;async1 end\u0026#34;) // 入微任务 } async function async2(){ console.log(\u0026#34;async2 end\u0026#34;) } async1() setTimeout(()=\u0026gt;{ console.log(\u0026#39;setTimeout\u0026#39;) // 入宏任务 },0) new Promise(resolve =\u0026gt;{ console.log(\u0026#39;Promise\u0026#39;) resolve() }).then(()=\u0026gt;{ console.log(\u0026#34;promise1\u0026#34;) // 入微任务 }).then(()=\u0026gt;{ console.log(\u0026#34;promise2\u0026#34;) // 入微任务 }) // async2 end -\u0026gt; Promise -\u0026gt; async1 end -\u0026gt; promise1 -\u0026gt; promise2 -\u0026gt;setTimeout async/await执行顺序 我们知道async隐式返回 Promise 作为结果的函数,那么可以简单理解为， await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。 但是我们要注意这个微任务产生的时机，它是执行完await之后，直接跳出async函数，执行其他代码(此处就是协程的运作，A暂停执行，控制权交给B)。其他代码执行完毕后，再回到async函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中。我们来看个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 console.log(\u0026#39;script start\u0026#39;) async function async1() { await async2() console.log(\u0026#39;async1 end\u0026#39;) // 入微任务1 } async function async2() { console.log(\u0026#39;async2 end\u0026#39;) } async1() setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;) // 入宏任务1 }, 0) new Promise(resolve =\u0026gt; { console.log(\u0026#39;Promise\u0026#39;) resolve() }) .then(function() { console.log(\u0026#39;promise1\u0026#39;) }) .then(function() { console.log(\u0026#39;promise2\u0026#39;) }) console.log(\u0026#39;script end\u0026#39;) script start -\u0026gt; async2 end -\u0026gt; Promise -\u0026gt; script end -\u0026gt; async1 end -\u0026gt; promise1 -\u0026gt; promise2 -\u0026gt; set // 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动 // script start =\u0026gt; async2 end =\u0026gt; Promise =\u0026gt; script end =\u0026gt; promise1 =\u0026gt; promise2 =\u0026gt; async1 end =\u0026gt; setTimeout ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","summary":"事件循环概念 JavaScript代码的执行过程中，除了依靠函数调用栈来限制函数的执行顺序外，还要依靠任务队列(task queue)来约束其它","title":"事件循环机制"},{"content":"源码实现 基础功能 1 2 3 4 5 6 7 8 9 10 const p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;fulfilled\u0026#39;) reject(\u0026#39;rejected\u0026#39;) }) p.then(value=\u0026gt;{ consolo.log(value) },reason=\u0026gt;{ console.log(reason) }) new Promise 的实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 const PENDING = \u0026#39;pending\u0026#39; const FULFILLED = \u0026#39;fulfilled\u0026#39; const REJECTED = \u0026#39;rejected\u0026#39; class SelfPromise { status = PENDING; //初始状态值pending value = null; //成功之后的值 reason = null; //失败之后的值 // 保存 onFulfilled 回调函数 onFulfilledCallback = null; // 保存 onRejected 回调函数 onRejectedCallback = null; constructor(executor){ executor(this.resolve,this.reject) // 将 resolve 和 reject 传给 new Promsie 的回调函数 } // 箭头函数可以使函数里面的 this 始终指向 Promise 实例对象 resolve = (value) =\u0026gt; { // status 只有是pending 的情况下，才改变为 fulfilled 的状态 if(this.status === PENDING) { this.status = FULFILLED this.value = value; this.onFulfilledCallback \u0026amp;\u0026amp; this.onFulfilledCallback(value); } } reject = (reason) =\u0026gt; { // status 只有是pending 的情况下，才改变为 rejected 的状态 if(this.status === PENDING) { this.status = REJECTED this.reason = reason this.onRejectedCallback \u0026amp;\u0026amp; this.onRejectedCallback(reason) } } then(onFulfilled,onRejected){ if(this.status === FULFILLED){ // 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。 onFulfilled(this.value) }else if(this.status === REJECTED){ // 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。 onRejected(this.reason) }else { // pending 状态下保存回调函数 （处理异步逻辑） this.onFulfilledCallback = onFulFilled this.onRejectedCallback = onRejected } } } then 的多次调用 目前的代码只能输出1个fulfilled，关键在于源码当中 then 方法保存回调函数的方式：\n回调函数会直接保存在 this.onFulfilledCallback 或 this.onRejectedCallback 中，这样就会导致保存的是最后一个 then 方法的回调函数，所以这里不能直接用两个变量来保存，而是用两个数组来保存所有的回调函数，同时 Promise 内部的 resolve 和 reject 方法也需要循环调用所有的回调函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 const PENDING = \u0026#39;pending\u0026#39; const FULFILLED = \u0026#39;fulfilled\u0026#39; const REJECTED = \u0026#39;rejected\u0026#39; class SelfPromise { status = PENDING; //初始状态值pending value = null; //成功之后的值 reason = null; //失败之后的值 // 保存 onFulfilled 回调函数 onFulfilledCallbacks = []; // 保存 onRejected 回调函数 onRejectedCallbacks = []; constructor(executor){ executor(this.resolve,this.reject) // 将 resolve 和 reject 传给 new Promsie 的回调函数 } // 箭头函数可以使函数里面的 this 始终指向 Promise 实例对象 resolve = (value) =\u0026gt; { // status 只有是pending 的情况下，才改变为 fulfilled 的状态 if(this.status === PENDING) { this.status = FULFILLED this.value = value; //this.onFulfilledCallback \u0026amp;\u0026amp; this.onFulfilledCallback(value); // 执行所有的 onFulfilled 回调函数 this.onFulfilledCallbacks.forEach((fn) =\u0026gt; fn(value)); } } reject = (reason) =\u0026gt; { // status 只有是pending 的情况下，才改变为 rejected 的状态 if(this.status === PENDING) { this.status = REJECTED this.reason = reason //this.onRejectedCallback \u0026amp;\u0026amp; this.onRejectedCallback(reason) this.onRejectedCallbacks.forEach((fn) =\u0026gt; fn(reason)); } } then(onFulfilled,onRejected){ if(this.status === FULFILLED){ // 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。 onFulfilled(this.value) }else if(this.status === REJECTED){ // 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。 onRejected(this.reason) }else { // pending 状态下保存回调函数 （处理异步逻辑） this.onFulfilledCallbacks.push(onFulFilled) this.onRejectedCallbacks.push(onRejected) } } } then 方法的链式调用 Promise 最核心的功能就是 then 方法的链式调用，这也是解决回调地狱的关键所在。就目前我们手动实现的代码来看，是不能够进行 then 方法的链式调用的，因为 then 方法没有任何返回值。\n","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/20230814-%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3promise/","summary":"源码实现 基础功能 1 2 3 4 5 6 7 8 9 10 const p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;fulfilled\u0026#39;) reject(\u0026#39;rejected\u0026#39;) }) p.then(value=\u0026gt;{ consolo.log(value) },reason=\u0026gt;{ console.log(reason) }) new Promise 的实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29","title":"真正理解Promise"},{"content":"TypeScript的特性 类型系统 TypeScript是静态类型 （根据类型检查的时机来分类） 动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误。JavaScript 是一门解释型语言，没有编译阶段，所以它是动态类型，以下这段代码在运行时才会报错：\n1 2 3 4 let foo = 1; foo.split(\u0026#39; \u0026#39;); // Uncaught TypeError: foo.split is not a function // 运行时会报错（foo.split 不是一个函数），造成线上 bug 静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 TypeScript 是静态类型，这段 TypeScript 代码在编译阶段就会报错了：\n1 2 3 4 let foo = 1; //类型推断 let foo: number = 1; foo.split(\u0026#39; \u0026#39;); // Property \u0026#39;split\u0026#39; does not exist on type \u0026#39;number\u0026#39;. // 编译时会报错（数字没有 split 方法），无法通过编译 TypeScript / JavaScript 都是弱类型 （根据是否允许隐式类型转换来分类） 安装typescript 1 2 3 npm install -g typescript tsc -v // Version x.x.x TS基础 1.基础类型 布尔值 boolean 1 2 3 4 let isDone: boolean = false; let createdByNewBoolean: Boolean = new Boolean(1); //非布尔值！ 返回的是一个 Boolean对象 let createdByBoolean: Boolean = Boolean(1) // 直接调用可返回一个 boolean 类型 数值 number 1 2 3 4 5 6 7 8 let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; //ES6的二进制表示法 会被编译成十进制 let octalLiteral: number = 0o744; //ES6的八进制表示法 ... let notANumber: number = NaN; let infinityNumber: number = Infinity; 字符串 string 1 2 3 4 5 6 let myName: string = \u0026#39;Tom\u0026#39;; let myAge: number = 25; // 模板字符串 let sentence: string = `Hello, my name is ${myName}. I\u0026#39;ll be ${myAge + 1} years old next month.`; null 和 undefined 在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n1 2 let u: undefined = undefined; let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n1 2 // 这样不会报错 let num: number = undefined; 1 2 3 // 这样也不会报错 let u: undefined; let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量：\n1 2 3 let u: void; let num: number = u; // Type \u0026#39;void\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. 任意值 any 什么是任意值类型 如果是一个普通类型，在赋值过程中改变类型是不被允许的：\n1 2 3 let myFavoriteNumber: string = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. 但如果是 any 类型，则允许被赋值为任意类型。\n1 2 let myFavoriteNumber: any = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 任意值的属性和方法 在任意值上访问任何属性都是允许的：\n1 2 3 let anyThing: any = \u0026#39;hello\u0026#39;; console.log(anyThing.myName); console.log(anyThing.myName.firstName); 也允许调用任何方法：\n1 2 3 4 let anyThing: any = \u0026#39;Tom\u0026#39;; anyThing.setName(\u0026#39;Jerry\u0026#39;); anyThing.setName(\u0026#39;Jerry\u0026#39;).sayHello(); anyThing.myName.setFirstName(\u0026#39;Cat\u0026#39;); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。\n未声明类型的变量 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n1 2 3 4 let something; something = \u0026#39;seven\u0026#39;; something = 7; something.setName(\u0026#39;Tom\u0026#39;); 等价于\n1 2 3 4 let something: any; something = \u0026#39;seven\u0026#39;; something = 7; something.setName(\u0026#39;Tom\u0026#39;); unknow 类型 就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。\n1 2 3 4 5 6 7 8 9 10 11 12 let value: unknown; value = true; // OK value = 42; // OK value = \u0026#34;Hello World\u0026#34;; // OK value = []; // OK value = {}; // OK value = Math.random; // OK value = null; // OK value = undefined; // OK value = new TypeError(); // OK value = Symbol(\u0026#34;type\u0026#34;); // OK 不能将 unknown的值 赋值给其他类型的变量，unknown类型只能被赋值给 any 类型和 unknown 类型本身\n1 2 3 4 5 6 7 8 9 10 let value: unknown; let value1: unknown = value; // OK let value2: any = value; // OK let value3: boolean = value; // Error let value4: number = value; // Error let value5: string = value; // Error let value6: object = value; // Error let value7: any[] = value; // Error let value8: Function = value; // Error **unknown 应用场景\n1 2 3 4 5 6 7 8 // any 写法，不推荐 function divide(param: any) { return param / 2; } // unknown写法，推荐 function divide(param:unknown) { return param as number / 2 } 空值 void void 表示没有任何返回值的函数\n1 2 3 function alertName(): void { alert(\u0026#39;My name is Lv\u0026#39;); } 声明一个 void 类型的变量没用，因为你只能将它赋值为 undefined 和 null（只在 \u0026ndash;strictNullChecks 未指定时）：\n1 let unusable: void = undefined; never 类型 never类型表示的是那些用不存在的值的类型。\n有些情况下值会永不存在，比如，\n如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值，因为抛出异常会直接中断程序运行。 函数中执行无限循环的代码，使得程序永远无法运行到函数返回值那一步。 1 2 3 4 5 6 7 8 9 // 异常 function fn(msg: string): never { throw new Error(msg) } // 死循环 千万别这么写，会内存溢出 function fn(): never { while (true) {} } never 类型是任何类型的子类型，也可以赋值给任何类型。\n1 2 let test1: never; test1 = \u0026#39;lin\u0026#39; // 报错，Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;never\u0026#39; 没有类型是 never 的子类型，没有类型可以赋值给 never 类型（除了 never 本身之外）。 即使 any也不可以赋值给 never 。\n1 2 3 4 let test1: never; let test2: any; test1 = test2 // 报错，Type \u0026#39;any\u0026#39; is not assignable to type \u0026#39;never\u0026#39; 数组的类型 类型+方括号 表示法 1 let fibonacci: number[] = [1, 1, 2, 3, 5]; 数组的项中不允许出现其他的类型：\n1 2 let fibonacci: number[] = [1, \u0026#39;1\u0026#39;, 2, 3, 5]; // Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n1 2 3 let fibonacci: number[] = [1, 1, 2, 3, 5]; fibonacci.push(\u0026#39;8\u0026#39;); // Argument of type \u0026#39;\u0026#34;8\u0026#34;\u0026#39; is not assignable to parameter of type \u0026#39;number\u0026#39;. 数组泛型 array\u0026lt;elemType\u0026gt; 我们也可以使用数组泛型（Array Generic） Array\u0026lt;elemType\u0026gt;来表示数组：\n1 let fibonacci: Array\u0026lt;number\u0026gt; = [1, 1, 2, 3, 5]; 用接口表示数组 1 2 3 4 interface NumberArray { [index: number]: number; } let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 元组 Tuple 类型 在单个变量中存储不同类型的值\n1 2 let tupleType: [string, boolean]; tupleType = [\u0026#34;semlinker\u0026#34;, true]; 在元组初始化的时候，如果出现类型不匹配的话，比如：\n1 2 3 4 tupleType = [true, \u0026#34;semlinker\u0026#34;]; //报错 [0]: Type \u0026#39;true\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. [1]: Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;boolean\u0026#39;. 在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误。\n可以对元组使用数组的方法，比如使用 push 时，不会有越界报错\n1 2 let tuple: [number, string] = [18, \u0026#39;lin\u0026#39;] tuple.push(100) // 但是只能 push 定义的 number 或者 string 类型 2.函数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function sum(x: number, y: number): number { return x + y; } //可选参数 function buildName(firstName: string, lastName?: string) { if (lastName) { return firstName + \u0026#39; \u0026#39; + lastName; } else { return firstName; } } let tomcat = buildName(\u0026#39;Tom\u0026#39;, \u0026#39;Cat\u0026#39;); let tom = buildName(\u0026#39;Tom\u0026#39;); //参数默认值 function buildName(firstName: string, lastName: string = \u0026#39;Cat\u0026#39;) { return firstName + \u0026#39; \u0026#39; + lastName; } let tomcat = buildName(\u0026#39;Tom\u0026#39;, \u0026#39;Cat\u0026#39;); let tom = buildName(\u0026#39;Tom\u0026#39;); //剩余参数 ...rest rest 参数只能是最后一个参数 function push(array, ...items) { items.forEach(function(item) { array.push(item); }); } let a: any[] = []; push(a, 1, 2, 3); 函数重载 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。\n利用联合类型，我们可以这么实现：\n1 2 3 4 5 6 7 function reverse(x: number | string): number | string | void { if (typeof x === \u0026#39;number\u0026#39;) { return Number(x.toString().split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)); } else if (typeof x === \u0026#39;string\u0026#39;) { return x.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n这时，我们可以使用重载定义多个 reverse 的函数类型：\n1 2 3 4 5 6 7 8 9 function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string | void { if (typeof x === \u0026#39;number\u0026#39;) { return Number(x.toString().split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)); } else if (typeof x === \u0026#39;string\u0026#39;) { return x.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。\nTypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n其实写起来挺麻烦的，后面了解泛型之后写起来会简洁一些，不必太纠结函数重载，知道有这个概念即可，平时一般用泛型来解决类似问题。\n3.interface 接口 基本概念 TypeScript 中的接口是一个非常灵活的概念，常用于对「对象的形状（Shape）」进行描述。\n1 2 3 4 5 6 7 8 9 interface Person { name: string; age: number; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, age: 25 }; 定义的变量比接口少了一些属性或多一些属性都是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致\n可选属性 ？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface Person { name: string; age?: number; } let tom: Person = { name: \u0026#39;Tom\u0026#39; }; let tom: Person = { name: \u0026#39;Tom\u0026#39;, age:100, gender:\u0026#34;male\u0026#34; //报错 仍然不允许添加未定义的属性 }; 只读属性 readonly 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { id: 89757, name: \u0026#39;Tom\u0026#39;, gender: \u0026#39;male\u0026#39; }; tom.id = 9527; // index.ts(14,5): error TS2540: Cannot assign to \u0026#39;id\u0026#39; because it is a constant or a read-only property. 只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候\n1 2 3 4 5 6 7 8 9 10 11 12 13 interface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, gender: \u0026#39;male\u0026#39; }; tom.id = 89757; //第一错没有给id初始值，第二错id为只读属性 interface 描述函数类型 interface 也可以用来描述函数类型，代码如下：\n1 2 3 4 5 6 7 interface ISum { (x:number,y:number):number } const add:ISum = (num1, num2) =\u0026gt; { return num1 + num2 } 任意属性 一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n1 2 3 4 5 6 7 8 9 10 11 interface Person { name: string; age?: number; [propName: string]: string | number; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, age: 25, gender: \u0026#39;male\u0026#39; }; duck typing ( 鸭子类型 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 const fn: FunctionWithProps = (x) =\u0026gt; { return x } fn.fnName = \u0026#39;hello world\u0026#39; //React 的 `FunctionComponent（函数式组件）` interface FunctionComponent\u0026lt;P = {}\u0026gt; { (props: PropsWithChildren\u0026lt;P\u0026gt;, context?: any): ReactElement\u0026lt;any, any\u0026gt; | null; propTypes?: WeakValidationMap\u0026lt;P\u0026gt; | undefined; contextTypes?: ValidationMap\u0026lt;any\u0026gt; | undefined; defaultProps?: Partial\u0026lt;P\u0026gt; | undefined; displayName?: string | undefined; } 4.class 类 类的属性与方法 在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。\n我们可以用Class关键字来定义一个类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person { // 成员属性 name: string //构造函数 - 执行初始化操作 constructor(name: string) { this.name = name } speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lin\u0026#39;) // 新建实例 p1.name // 访问属性和方法 p1.speak() 继承 继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。\n我们可以通过 extends 关键字来实现继承\n1 2 3 4 5 6 7 8 9 class Student extends Person { study() { console.log(`${this.name} needs study`) } } const s1 = new Student(\u0026#39;lin\u0026#39;) s1.study() super关键字 注意，上例中 Student 类没有定义自己的属性，可以不写 super ，但是如果 Student 类有自己的属性，就要用到 super 关键字来把父类的属性继承过来。\n比如，Student 类新增一个 grade(成绩) 属性，就要这么写：\n1 2 3 4 5 6 7 8 9 10 11 class Student extends Person { grade: number constructor(name: string,grade:number) { super(name) this.grade = grade } } const s1 = new Student(\u0026#39;lin\u0026#39;, 100) //不写 super 会报错。 多态 子类对父类的方法进行了重写，子类和父类调同一个方法时会不一样。\n1 2 3 4 5 class Student extends Person { speak() { return `Student ${super.speak()}` } } 私有字段 与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：\n私有字段以 # 字符开头，有时我们称之为私有名称； 每个私有字段名称都唯一地限定于其包含的类； 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）； 私有字段不能在包含的类之外访问，甚至不能被检测到。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person { #name: string; //私有字段 constructor(name: string) { this.#name = name; } greet() { console.log(`Hello, my name is ${this.#name}!`); } } let semlinker = new Person(\u0026#34;Semlinker\u0026#34;); semlinker.#name; // ~~~~~ // Property \u0026#39;#name\u0026#39; is not accessible outside class \u0026#39;Person\u0026#39; // because it has a private identifier. 只属于类自己 它的实例能否访问 继承它的子类能否访问 public 公有的 能 能 private 私有的 是 不能 不能 protected 受保护的 不能 能 static 不能 能 private\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Person { private name: string public constructor(name: string) { this.name = name } public speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lv\u0026#39;) p1.name //报错 “name” is private... class Student extends Person { study(){ console.log(`${this.name} needs study`) //报错 “name” is private... } } protected\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Person { protected name: string public constructor(name: string) { this.name = name } public speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lv\u0026#39;) p1.name //报错 “name” is protected... class Student extends Person { study(){ console.log(`${this.name} needs study`) } } 访问器 我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 let passcode = \u0026#34;Hello TypeScript\u0026#34;; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode \u0026amp;\u0026amp; passcode == \u0026#34;Hello TypeScript\u0026#34;) { this._fullName = newName; } else { console.log(\u0026#34;Error: Unauthorized update of employee!\u0026#34;); } } } let employee = new Employee(); employee.fullName = \u0026#34;Semlinker\u0026#34;; if (employee.fullName) { console.log(employee.fullName); } 抽象类 使用 abstract 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多个抽象方法。所谓的抽象方法，是指不包含具体实现的方法：\n1 2 3 4 5 6 7 8 abstract class Person { constructor(public name: string){} abstract say(words: string) :void; } // Cannot create an instance of an abstract class.(2511) const lolo = new Person(); // Error 抽象类不能被直接实例化，我们只能实例化实现了所有抽象方法的子类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 abstract class Person { constructor(public name: string){} // 抽象方法 abstract say(words: string) :void; } class Developer extends Person { constructor(name: string) { super(name); } say(words: string): void { console.log(`${this.name} says ${words}`); } } const lolo = new Developer(\u0026#34;lolo\u0026#34;); lolo.say(\u0026#34;I love ts!\u0026#34;); // lolo says I love ts! 类方法重载 对于类的方法来说，它也支持重载。比如，示例中我们重载了 ProductService 类的 getProducts 成员方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class ProductService { getProducts(): void; getProducts(id: number): void; getProducts(id?: number) { if(typeof id === \u0026#39;number\u0026#39;) { console.log(`获取id为 ${id} 的产品信息`); } else { console.log(`获取所有的产品信息`); } } } const productService = new ProductService(); productService.getProducts(666); // 获取id为 666 的产品信息 productService.getProducts(); // 获取所有的产品信息 5.interface 和 class 的关系 interface 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。 interface 同样可以用来约束 class，要实现约束，需要用到 implements 关键字。\nimplements implements 是实现的意思，class 实现 interface。\n比如手机有播放音乐的功能，可以这么写：\n1 2 3 4 5 6 7 interface MusicInterface { playMusic(): void } class Cellphone implements MusicInterface { playMusic() {} // 如果 Cellphone 类上不写 playMusic 方法，会报错。 } 定义了约束后，class 必须要满足接口上的所有条件。\n处理公共的属性和方法 不同的类有一些共同的属性和方法，使用继承很难完成。\n比如汽车（Car 类）也有播放音乐的功能，你可以这么做：\n用 Car 类继承 Cellphone 类 找一个 Car 类和 Cellphone 类的父类，父类有播放音乐的方法，他们俩继承这个父类 很显然这两种方法都不合常理。\n实际上，使用 implements，问题就会迎刃而解\n1 2 3 4 5 6 7 8 9 10 11 interface MusicInterface { playMusic(): void } //Car 类和 Cellphone 类都约束了播放音乐的功能。 class Car implements MusicInterface { playMusic() {} } class Cellphone implements MusicInterface { playMusic() {} } 再比如，手机还有打电话的功能，就可以这么做，Cellphone 类 implements 两个 interface。\n1 2 3 4 5 6 7 8 9 10 11 12 interface MusicInterface { playMusic(): void } interface CallInterface { makePhoneCall(): void } class Cellphone implements MusicInterface, CallInterface { playMusic() {} makePhoneCall() {} } interface 来约束 class，class 实现了 interface 规定的属性或方法，没有继承那么多条条框框，非常灵活。\n约束构造函数和静态属性 使用 implements 只能约束类实例上的属性和方法，要约束构造函数和静态属性，需要这么写。\n以我们上文提过的 Circl 类为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 interface CircleStatic { new (radius: number): void pi: number } const Circle:CircleStatic = class Circle { static pi: 3.14 public radius: number public constructor(radius: number) { this.radius = radius } } const Circle:CircleStatic = class Circle { public radius: number //未定义静态属性 pi，会报错： \u0026#39;pi\u0026#39; is missing public constructor(radius:string){ //constructor 入参类型不对，会报错： type \u0026#39;number\u0026#39; is not... to type \u0026#39;string\u0026#39; this.radius = radius } } 6.Enum 枚举类型 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。\n数字枚举 1 2 3 4 5 6 7 8 enum Direction { NORTH, //0 SOUTH, EAST, WEST, //3 } let dir: Direction = Direction.NORTH; 设置 NORTH 的初始值，比如：\n1 enum Direction { NORTH = 3, SOUTH, EAST, WEST, }` 字符串枚举 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\n1 2 3 4 5 6 enum Direction { NORTH = \u0026#34;NORTH\u0026#34;, SOUTH = \u0026#34;SOUTH\u0026#34;, EAST = \u0026#34;EAST\u0026#34;, WEST = \u0026#34;WEST\u0026#34;, } 异构枚举 1 2 3 4 5 6 7 8 9 10 11 12 enum Enum { A, B, C = \u0026#34;C\u0026#34;, D = \u0026#34;D\u0026#34;, E = 8, F, } //反向映射 console.log(Enum.A) //输出：0 console.log(Enum[0]) // 输出：A 7.类型推论 TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n1 2 3 4 let myFavoriteNumber = \u0026#39;seven\u0026#39;; // let myFavoriteNumber: string = \u0026#39;seven\u0026#39; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查\n1 2 3 let myFavoriteNumber; myFavoriteNumber = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 虽然 TS 可以推导出最合适的类型，但最好还是在写的时候就定义好类型，下面的例子，可以用ts这么写：\n1 2 3 4 5 6 // let arr = [0, 1, null, \u0026#39;lin\u0026#39;]; type arrItem = number | string | null let arr: arrItem[] = [0, 1, null, \u0026#39;lin\u0026#39;]; let pets: Pets[] = [new Dog(), new Cat()] 8.内置类型 JS 八种内置类型 1 2 3 4 5 6 7 8 let name: string = \u0026#34;lin\u0026#34;; let age: number = 18; let isHandsome: boolean = true; let u: undefined = undefined; let n: null = null; let obj: object = {name: \u0026#39;lin\u0026#39;, age: 18}; let big: bigint = 100n; let sym: symbol = Symbol(\u0026#34;lin\u0026#34;); ECMAScript 的内置对象 比如，Array、Date、Error 等\n1 2 3 4 5 const nums: Array\u0026lt;number\u0026gt; = [1,2,3] const date: Date = new Date() const err: Error = new Error(\u0026#39;Error!\u0026#39;); const reg: RegExp = /abc/; Math.pow(2, 9) DOM 和 BOM 比如 HTMLElement、NodeList、MouseEvent 等\n1 2 3 4 5 6 7 8 let body: HTMLElement = document.body let allDiv: NodeList = document.querySelectorAll(\u0026#39;div\u0026#39;); document.addEventListener(\u0026#39;click\u0026#39;, (e: MouseEvent) =\u0026gt; { e.preventDefault() // Do something }); TS 进阶 1.高级类型（一） 联合类型 联合类型表示可以取值为多类型中的一种\n1 2 3 let myFavoriteNumber: string | number; myFavoriteNumber = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 只能访问此联合类型的所有类型里共有的属性或方法：\n1 2 3 4 5 6 function getLength(something: string | number): number { return something.length; } // index.ts(2,22): error TS2339: Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;string | number\u0026#39;. // Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;number\u0026#39;. 上例中，length 不是 string 和 number 的共有属性，所以会报错。 访问 string 和 number 的共有属性是没问题的：\n1 2 3 function getString(something: string | number): string { return something.toString(); } 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型\n1 2 3 4 5 6 7 let myFavoriteNumber: string | number; myFavoriteNumber = \u0026#39;seven\u0026#39;; console.log(myFavoriteNumber.length); // 5 被推断为string myFavoriteNumber = 7; console.log(myFavoriteNumber.length); // 编译时报错 被推断为number // index.ts(5,30): error TS2339: Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;number\u0026#39;. 交叉类型 \u0026amp; 运算符 在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 \u0026amp; 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\n1 2 3 4 5 6 interface Person { name: string age: number } type Student = Person \u0026amp; { grade: number } 联合类型 | 是指可以取几种类型中的任意一种，而交叉类型 \u0026amp; 是指把几种类型合并起来。\n交叉类型和 interface 的 extends 非常类似，都是为了实现对象形状的组合和扩展。\n类型别名（ type ） 类型别名（type aliase），听名字就很好理解，就是给类型起个别名。\n就像 NBA 球员 扬尼斯-阿德托昆博，名字太长难记，我们叫他字母哥。\n就像我们项目中配置 alias，不用写相对路径就能很方便地引入文件\n1 2 3 import componentA from \u0026#39;../../../../components/componentA/index.vue\u0026#39; 变成 import componentA from \u0026#39;@/components/componentA/index.vue 类型别名用 type 关键字来书写，有了类型别名，我们书写 TS 的时候可以更加方便简洁。\n比如下面这个例子，getName 这个函数接收的参数可能是字符串，可能是函数，就可以这么写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Name = string type NameResolver = () =\u0026gt; string type NameOrResolver = Name | NameResolver // 联合类型 function getName(n: NameOrResolver): Name { if (typeof n === \u0026#39;string\u0026#39;) { return n } else { return n() } } getName(\u0026#39;lin\u0026#39;) getName(() =\u0026gt; \u0026#39;lin\u0026#39;) 类型别名的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Name = string // 基本类型 type arrItem = number | string // 联合类型 const arr: arrItem[] = [1,\u0026#39;2\u0026#39;, 3] type Person = { name: Name } type Student = Person \u0026amp; { grade: number } // 交叉类型 type Teacher = Person \u0026amp; { major: string } type StudentAndTeacherList = [Student, Teacher] // 元组类型 const list:StudentAndTeacherList = [ { name: \u0026#39;lin\u0026#39;, grade: 100 }, { name: \u0026#39;liu\u0026#39;, major: \u0026#39;Chinese\u0026#39; } ] 接口与类型别名的区别 共同点 都可以用来描述对象或函数签名： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //接口 interface Point { x: number; y: number; } interface SetPoint { (x: number, y: number): void; } //类型别名 type Point = { x: number; y: number; }; type SetPoint = (x: number, y: number) =\u0026gt; void; 都允许继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // interface 继承 interface interface PartialPointX { x: number; } interface Point extends PartialPointX { y: number; } // type 继承 type type PartialPointX = { x: number; }; type Point = PartialPointX \u0026amp; { y: number; }; // interface 继承 type type Person = { name: string } interface Student extends Person { \u0026#34;interface用 extends 来继承\u0026#34; grade: number } // type 继承 interface interface Person { name: string } type Student = Person \u0026amp; { grade: number } \u0026#34;type用交叉类型来继承\u0026#34; 不同点 设计角度 interface（接口） 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。\ntype 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\ntype 用于其它类型 与 interface 不一样，**type 可以声明基本类型、联合类型、交叉类型、元组\n1 2 3 4 5 6 7 8 9 10 11 12 // primitive type Name = string; // object type PartialPointX = { x: number; }; type PartialPointY = { y: number; }; // union type PartialPoint = PartialPointX | PartialPointY; // tuple type Data = [number, string]; interface可以合并重复声明，type 不行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 interface Person { name: string } interface Person { // 重复声明 interface，就合并了 age: number } const person: Person = { name: \u0026#39;lin\u0026#39;, age: 18 } type Person = { name: string } type Person = { // 报错，Duplicate identifier \u0026#39;Person\u0026#39; age: number } const person: Person = { name: \u0026#39;lin\u0026#39;, age: 18 } Implements 类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 interface Point { x: number; y: number; } class SomePoint implements Point { x = 1; y = 2; } type Point2 = { x: number; y: number; }; class SomePoint2 implements Point2 { x = 1; y = 2; } // 错误示例 type PartialPoint = { x: number; } | { y: number; }; // A class can only implement an object type or // intersection of object types with statically known members. class SomePartialPoint implements PartialPoint { // Error x = 1; y = 2; } 这两者的区别说了这么多，其实本不该把这两个东西拿来做对比，他们俩是完全不同的概念。\ninterface 是接口，用于描述一个对象。\ntype 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\n只是有时候两者都能实现同样的功能，才会经常被混淆\n平时开发中，一般使用组合或者交叉类型的时候，用 type。\n一般要用类的 extends 或 implements 时，用 interface。\n其他情况，比如定义一个对象或者函数，就看你心情了。\n类型保护 如果有一个 getLength 函数，入参是联合类型 number | string，返回入参的 length，\n1 2 3 function getLength(arg: number | string): number { return arg.length } 从上文可知，这么写会报错，因为 number 类型上没有 length 属性。\n这个时候，类型保护（Type Guards）出现了，可以使用 typeof 关键字判断变量的类型。\n我们把 getLength 方法改造一下，就可以精准地获取到 string 类型的 length 属性了，\n1 2 3 4 5 6 7 function getLength(arg: number | string): number { if(typeof arg === \u0026#39;string\u0026#39;) { return arg.length } else { return arg.toString().length } } 类型断言 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n尖括号语法 1 2 let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (\u0026lt;string\u0026gt;someValue).length; as语法 1 2 let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (someValue as string).length; 注意，类型断言不是类型转换，把一个类型断言成联合类型中不存在的类型会报错。 字面量类型 有时候，我们需要定义一些常量，就需要用到字面量类型，比如，\n1 2 3 4 5 type ButtonSize = \u0026#39;mini\u0026#39; | \u0026#39;small\u0026#39; | \u0026#39;normal\u0026#39; | \u0026#39;large\u0026#39; type Sex = \u0026#39;男\u0026#39; | \u0026#39;女\u0026#39; const theSet: Sex = \u0026#34;不男不女\u0026#34; // Type \u0026#39;不男不女\u0026#39; is not assignable to type \u0026#39;sex\u0026#39; 这样就只能从这些定义的常量中取值，乱取值会报错。\n2.泛型 泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。\n它可以轻松解决输入输出要一致的问题。\n泛型基本使用 处理函数参数 其中 T 代表 Type，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。除了 T 之外，以下是常见泛型变量代表的意思：\nK（Key）：表示对象中的键类型； V（Value）：表示对象中的值类型； E（Element）：表示元素类型。 其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数：\n1 2 3 4 5 function identity \u0026lt;T, U\u0026gt;(value: T, message: U) : T { console.log(message); return value; } console.log(identity\u0026lt;Number, string\u0026gt;(68, \u0026#34;Semlinker\u0026#34;)); TS 类型推断，自动推导出类型。\n1 console.log(identity(68, \u0026#34;Semlinker\u0026#34;)); **ype 和 interface 都可以定义函数类型，也用泛型来写一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // type type Print = \u0026lt;T\u0026gt;(arg: T) =\u0026gt; T const printFn:Print = function print(arg) { console.log(arg) return arg } // interface interface Iprint\u0026lt;T\u0026gt; { (arg: T): T } function print\u0026lt;T\u0026gt;(arg:T) { console.log(arg) return arg } const myPrint: Iprint\u0026lt;number\u0026gt; = print 默认参数 1 2 3 4 5 6 7 8 9 10 interface Iprint\u0026lt;T = number\u0026gt; { (arg: T): T } function print\u0026lt;T\u0026gt;(arg:T) { console.log(arg) return arg } const myPrint: Iprint = print 处理多个函数参数 传入一个只有两项的元组，交换元组的第 0 项和第 1 项，返回这个元组。\n1 2 3 4 5 6 7 function swap\u0026lt;T,U\u0026gt;(tuple:[T,U]):[U,T]{ return [tuple[1], tuple[0]] } const swap = \u0026lt;T,U\u0026gt;(tuple:[T,U]): [U,T] =\u0026gt;{ return [tuple[1],tuple[0]] } 函数副作用操作 调用 API 都清晰的知道返回类型是什么数据结构\n1 2 3 4 5 6 7 8 9 10 11 12 interface UserInfo { name: string age: number } function request\u0026lt;T\u0026gt;(url:string): Promise\u0026lt;T\u0026gt; { return fetch(url).then(res =\u0026gt; res.json()) } request\u0026lt;UserInfo\u0026gt;(\u0026#39;user/info\u0026#39;).then(res =\u0026gt;{ console.log(res) }) 约束泛型 假设现在有这么一个函数，打印传入参数的长度，我们这么写：\n1 2 3 4 function printLength\u0026lt;T\u0026gt;(arg: T): T { console.log(arg.length) //不确定 T 是否有 length 属性，会报错： property \u0026#39;length\u0026#39; does not ... return arg } 那么现在我想约束这个泛型，一定要有 length 属性，怎么办？\n可以和 interface 结合，来约束类型。\n1 2 3 4 5 6 7 8 interface ILength { length: number } function printLength\u0026lt;T extends ILength\u0026gt;(arg: T): T { console.log(arg.length) return arg } 泛型的一些应用 **泛型约束类 定义一个栈，有入栈和出栈两个方法，如果想入栈和出栈的元素类型统一，就可以这么写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Stack\u0026lt;T\u0026gt; { private data: T[] = [] push(item:T) { return this.data.push(item) } static pop():T | undefined { //给pop方法定义 static 关键字，报错 return this.data.pop() \u0026#39;泛型无法约束类的静态成员\u0026#39; } } const stack = new Stack\u0026lt;string\u0026gt;() stack.push(\u0026#39;124\u0026#39;) stack.push(123) // 类型number 不能复制给string stack.pop() **泛型约束接口 1 2 3 4 5 6 7 interface IKeyValue\u0026lt;T, U\u0026gt; { key: T value: U } const k1:IKeyValue\u0026lt;number, string\u0026gt; = { key: 18, value: \u0026#39;lin\u0026#39;} const k2:IKeyValue\u0026lt;string, number\u0026gt; = { key: \u0026#39;lin\u0026#39;, value: 18} **泛型定义数组 1 2 3 4 5 //之前我们这么写 const arr: number[] = [1,2,3] //现在可以这样写 const arr: Array\u0026lt;number\u0026gt; = [1,2,3] 小结 泛型的好处 函数和类可以轻松地支持多种类型，增强程序的拓展性\n不必写冗长的联合类型，增强代码的可读性\n灵活控制类型之间的约束\n泛型接口 1 2 3 interface GenericIdentityFn\u0026lt;T\u0026gt; { (arg: T): T; } 泛型类 1 2 3 4 5 6 7 8 9 10 class GenericNumber\u0026lt;T\u0026gt; { zeroValue: T; add: (x: T, y: T) =\u0026gt; T; } let myGenericNumber = new GenericNumber\u0026lt;number\u0026gt;(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function (x, y) { return x + y; }; 泛型工具类型 3.高级类型（二） 索引类型 从对象中抽取一些属性的值，然后拼接成数组，可以这么写\n1 2 3 4 5 6 7 8 9 10 11 12 13 const userInfo = { name: \u0026#39;lin\u0026#39;, age: \u0026#39;18\u0026#39;, } function getValues(userInfo: any, keys: string[]) { return keys.map(key =\u0026gt; userInfo[key]) } // 抽取指定属性的值 console.log(getValues(userInfo, [\u0026#39;name\u0026#39;,\u0026#39;age\u0026#39;])) // [\u0026#39;lin\u0026#39;, \u0026#39;18\u0026#39;] // 抽取obj中没有的属性: console.log(getValues(userInfo, [\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;])) // [undefined, undefined] keyof（索引查询） keyof 操作符用于获取某种类型的所有键，其返回类型是联合类型。\n1 2 3 4 5 6 7 8 interface Person { name: string; age: number; } type K1 = keyof Person; // \u0026#34;name\u0026#34; | \u0026#34;age\u0026#34; type K2 = keyof Person[]; // \u0026#34;length\u0026#34; | \u0026#34;toString\u0026#34; | \u0026#34;pop\u0026#34; | \u0026#34;push\u0026#34; | \u0026#34;concat\u0026#34; | \u0026#34;join\u0026#34; type K3 = keyof { [x: string]: Person }; // string | number T[K]（索引访问） T[K]，表示接口 T 的属性 K 所代表的类型\n1 2 3 4 5 6 7 interface IPerson { name: string; age: number; } let type1: IPerson[\u0026#39;name\u0026#39;] // string let type2: IPerson[\u0026#39;age\u0026#39;] // number extends (泛型约束) T extends U，表示泛型变量可以通过继承某个类型，获得某些属性。\n1 2 3 4 5 6 7 8 interface Lengthwise { length: number; } function loggingIdentity\u0026lt;T extends Lengthwise\u0026gt;(arg: T): T { console.log(arg.length); return arg; } 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n1 loggingIdentity(3); // Error, number doesn\u0026#39;t have a .length property 这时我们需要传入符合约束类型的值，必须包含必须的属性\n1 loggingIdentity({length: 10, value: 3}); 检查动态属性 对 getValue 函数进行改造，实现对象上动态属性的检查。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //改造前 const userInfo = { name: \u0026#39;lin\u0026#39;, age: \u0026#39;18\u0026#39;, } function getValues(userInfo: any, keys: string[]) { return keys.map(key =\u0026gt; userInfo[key]) } // 抽取指定属性的值 console.log(getValues(userInfo, [\u0026#39;name\u0026#39;,\u0026#39;age\u0026#39;])) // [\u0026#39;lin\u0026#39;, \u0026#39;18\u0026#39;] // 抽取obj中没有的属性: console.log(getValues(userInfo, [\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;])) // [undefined, undefined] //改造后 - 定义泛型 T、K，用于约束 userInfo 和 keys - 为 K 增加一个泛型约束,使 K 继承 userInfo 的所有属性的联合类型, 即`K extends keyof T` function getValues\u0026lt;T, K extends keyof T\u0026gt;(userInfo: T, keys: K[]): T[K][] { return keys.map(key =\u0026gt; userInfo[key]) } getValues(userInfo,[\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;]) //这样当我们指定不在对象里的属性时，就会报错，Type \u0026#39;sex\u0026#39; is not assignable to type \u0026#39;\u0026#34;name\u0026#34;|\u0026#34;age\u0026#34;\u0026#39; 映射类型 TS允许将一个类型映射成另外一个类型。\nin in 用来遍历枚举类型\n1 2 3 4 5 type Keys = \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; type Obj = { [p in Keys]: any } // -\u0026gt; { a: any, b: any, c: any } Partial Partial\u0026lt;T\u0026gt; 的作用就是将某个类型里的属性全部变为可选项 ?。\n1 2 3 4 5 6 7 /** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface Todo { title: string; description: string; } function updateTodo(todo: Todo, fieldsToUpdate: Partial\u0026lt;Todo\u0026gt;) { return { ...todo, ...fieldsToUpdate }; } const todo1 = { title: \u0026#34;Learn TS\u0026#34;, description: \u0026#34;Learn TypeScript\u0026#34;, }; const todo2 = updateTodo(todo1, { description: \u0026#34;Learn TypeScript Enum\u0026#34;, }); 上面的 updateTodo 方法中，我们利用 Partial\u0026lt;T\u0026gt; 工具类型，定义 fieldsToUpdate 的类型为 Partial\u0026lt;Todo\u0026gt;，即：\n1 2 3 4 { title?: string | undefined; description?: string | undefined; } Partial 原理\nPartial 的实现用到了 in 和 keyof\n1 2 3 4 5 6 /** * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P] } [P in keyof T]遍历T上的所有属性 ?:设置属性为可选的 T[P]设置类型为原来的类型 Readonly Readonly\u0026lt;T\u0026gt;将T的所有属性映射为只读的，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 interface IPerson { name: string age: number } type IReadOnly = Readonly\u0026lt;IPerson\u0026gt; let p1: IReadOnly = { name: \u0026#39;lin\u0026#39;, age: 18 } p1.name = \u0026#39;lv\u0026#39; //报错，Cannot assign to \u0026#39;name\u0026#39; because it is a read-only property. **Readonly 原理\n和 Partial 几乎完全一样\n1 2 3 4 5 6 /** * Make all properties in T readonly */ type Readonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P] } typeof typeof 操作符用来获取一个变量声明或对象的类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 interface Person { name: string; age: number; } const sem: Person = { name: \u0026#39;semlinker\u0026#39;, age: 33 }; type Sem= typeof sem; // -\u0026gt; Person function toArray(x: number): Array\u0026lt;number\u0026gt; { return [x]; } type Func = typeof toArray; // -\u0026gt; (x: number) =\u0026gt; number[] 条件类型 工具类型（Utility Types） 类型体操是什么？ 4.TS声明文件 TS 实战 todolist 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;div style=\u0026#34;padding: 50px; background: pink\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;todoMsg\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;clearHasDone\u0026#34;\u0026gt;清理\u0026lt;/button\u0026gt; \u0026lt;div v-if=\u0026#34;lists.length\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;(item, index) in lists\u0026#34; :key=\u0026#34;item.msg\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;item.done\u0026#34; /\u0026gt; \u0026lt;span :class=\u0026#34;{ done: item.done }\u0026#34;\u0026gt;{{ item.msg }}\u0026lt;/span\u0026gt; \u0026lt;span @click=\u0026#34;deleteItem(index)\u0026#34;\u0026gt;❎\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;全选\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;isAllDone\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ hasDone }} / {{ lists.length }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;暂无数据\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; import { ElMessage } from \u0026#34;element-plus\u0026#34;; import { ref, computed } from \u0026#34;vue\u0026#34;; interface listType { done: boolean; msg: string; } const lists = ref\u0026lt;listType[]\u0026gt;([ { msg: \u0026#34;吃饭\u0026#34;, done: true }, { msg: \u0026#34;睡觉\u0026#34;, done: false }, { msg: \u0026#34;打游戏\u0026#34;, done: false } ]); const todoMsg = ref\u0026lt;string\u0026gt;(\u0026#34;\u0026#34;); const add = () =\u0026gt; { if (!todoMsg.value) { ElMessage.error(\u0026#34;请输入相关值！\u0026#34;); return; } let params: listType = { done: false, msg: todoMsg.value }; lists.value.push(params); todoMsg.value = \u0026#34;\u0026#34;; }; const clearHasDone = () =\u0026gt; { lists.value = lists.value.filter(item =\u0026gt; !item.done); }; const deleteItem = (index: number) =\u0026gt; { lists.value.splice(index, 1); }; const hasDone = computed(() =\u0026gt; { return lists.value.filter(item =\u0026gt; item.done).length; }); const isAllDone = computed\u0026lt;boolean\u0026gt;({ // 所有的事项是否完成，双向绑定到全选按钮 get() { // isAllDone 的获取方法，用于双向绑定数据 return hasDone.value === lists.value.length; }, set(value: boolean) { // isAllDone 的更改方法，用于实现全选 和 取消全选功能 lists.value.forEach(item =\u0026gt; { item.done = value; }); } }); 泛型约束后端接口参数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import axios from \u0026#39;axios\u0026#39; interface API { \u0026#39;/book/detail\u0026#39;: { id: number, }, \u0026#39;/book/comment\u0026#39;: { id: number comment: string } ... } function request\u0026lt;T extends keyof API\u0026gt;(url: T, obj: API[T]) { return axios.post(url, obj) } request(\u0026#39;/book/comment\u0026#39;, { id: 1, comment: \u0026#39;非常棒！\u0026#39; }) TS 封装 axios 请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 import { HttpResponse } from \u0026#39;@/common/interface\u0026#39; import Taro from \u0026#39;@tarojs/taro\u0026#39; import publicConfig from \u0026#39;@/config/index\u0026#39; import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, Canceler } from \u0026#39;axios-miniprogram\u0026#39; import errorHandle from \u0026#39;../common/errorHandle\u0026#39; const CancelToken = axios.CancelToken class HttpRequest { private baseUrl: string private pending: Record\u0026lt;string, Canceler\u0026gt; constructor(baseUrl: string) { this.baseUrl = baseUrl this.pending = {} } // 获取axios配置 getInsideConfig() { const config = { baseURL: this.baseUrl, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json;charset=utf-8\u0026#39; }, timeout: 10000 } return config } removePending(key: string, isRequest = false) { if (this.pending[key] \u0026amp;\u0026amp; isRequest) { this.pending[key](\u0026#39;取消重复请求\u0026#39;) } delete this.pending[key] } // 设定拦截器 interceptors(instance: AxiosInstance) { instance.interceptors.request.use( config =\u0026gt; { let isPublic = false publicConfig.publicPath.map(path =\u0026gt; { isPublic = isPublic || path.test(config.url || \u0026#39;\u0026#39;) }) const token = Taro.getStorageSync(\u0026#39;token\u0026#39;) if (!isPublic \u0026amp;\u0026amp; token) { config.headers.Authorization = \u0026#39;Bearer \u0026#39; + token } const key = config.url + \u0026#39;\u0026amp;\u0026#39; + config.method this.removePending(key, true) config.cancelToken = new CancelToken(c =\u0026gt; { this.pending[key] = c }) return config }, err =\u0026gt; { errorHandle(err) return Promise.reject(err) } ) // 响应请求的拦截器 instance.interceptors.response.use( res =\u0026gt; { const key = res.config.url + \u0026#39;\u0026amp;\u0026#39; + res.config.method this.removePending(key) if (res.status === 200) { return Promise.resolve(res.data) } else { return Promise.reject(res) } }, err =\u0026gt; { errorHandle(err) return Promise.reject(err) } ) } // 创建实例 request(options: AxiosRequestConfig) { const instance = axios.create() const newOptions = Object.assign(this.getInsideConfig(), options) this.interceptors(instance) return instance(newOptions) } get(url: string, config?: AxiosRequestConfig): Promise\u0026lt;AxiosResponse\u0026gt; | Promise\u0026lt;HttpResponse\u0026gt; { const options = Object.assign( { method: \u0026#39;get\u0026#39;, url: url }, config ) return this.request(options) } post(url: string, data?: unknown): Promise\u0026lt;AxiosResponse\u0026gt; | Promise\u0026lt;HttpResponse\u0026gt; { return this.request({ method: \u0026#39;post\u0026#39;, url: url, data: data }) } } export default HttpRequest waiting 七、TypeScript 数组 **数组解构\n1 2 3 let x: number; let y: number; let z: number; let five_array = [0,1,2,3,4]; [x,y,z] = five_array; **数组展开运算符\n1 2 let two_array = [0, 1]; let five_array = [...two_array, 2, 3, 4]; **数组遍历\n1 2 3 4 5 let colors: string[] = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;]; for (let i of colors) { //获取每一个对象 console.log(i); } // for (let i in colors) 获取下标 八、TypeScript 对象 1 2 3 4 5 6 //公共数组 let person = { name: \u0026#34;Semlinker\u0026#34;, gender: \u0026#34;Male\u0026#34;, address: \u0026#34;Xiamen\u0026#34;, }; **对象解构\n1 let {name, gender} = person **对象展开运算符\n组装对象 1 let personWithAge = { ...person, age: 33 }; 获取除了某些项外的其它项 1 let { name, ...rest } = person; 十三、配置文件 tsconfig.json 作用： 用于标识 TypeScript 项目的根路径； 用于配置 TypeScript 编译器； 用于指定编译的文件。 重要字段 files - 设置要编译的文件的名称； include - 设置需要进行编译的文件，支持路径模式匹配； exclude - 设置无需进行编译的文件，支持路径模式匹配； compilerOptions - 设置与编译流程相关的选项 compilerOptions 选项 compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。\ncompilerOptions 每个选项的详细说明如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 { \u0026#34;compilerOptions\u0026#34;: { /* 基本选项 */ \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, // 指定 ECMAScript 目标版本: \u0026#39;ES3\u0026#39; (default), \u0026#39;ES5\u0026#39;, \u0026#39;ES6\u0026#39;/\u0026#39;ES2015\u0026#39;, \u0026#39;ES2016\u0026#39;, \u0026#39;ES2017\u0026#39;, or \u0026#39;ESNEXT\u0026#39; \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, // 指定使用模块: \u0026#39;commonjs\u0026#39;, \u0026#39;amd\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;umd\u0026#39; or \u0026#39;es2015\u0026#39; \u0026#34;lib\u0026#34;: [], // 指定要包含在编译中的库文件 \u0026#34;allowJs\u0026#34;: true, // 允许编译 javascript 文件 \u0026#34;checkJs\u0026#34;: true, // 报告 javascript 文件中的错误 \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, // 指定 jsx 代码的生成: \u0026#39;preserve\u0026#39;, \u0026#39;react-native\u0026#39;, or \u0026#39;react\u0026#39; \u0026#34;declaration\u0026#34;: true, // 生成相应的 \u0026#39;.d.ts\u0026#39; 文件 \u0026#34;sourceMap\u0026#34;: true, // 生成相应的 \u0026#39;.map\u0026#39; 文件 \u0026#34;outFile\u0026#34;: \u0026#34;./\u0026#34;, // 将输出文件合并为一个文件 \u0026#34;outDir\u0026#34;: \u0026#34;./\u0026#34;, // 指定输出目录 \u0026#34;rootDir\u0026#34;: \u0026#34;./\u0026#34;, // 用来控制输出目录结构 --outDir. \u0026#34;removeComments\u0026#34;: true, // 删除编译后的所有的注释 \u0026#34;noEmit\u0026#34;: true, // 不生成输出文件 \u0026#34;importHelpers\u0026#34;: true, // 从 tslib 导入辅助工具函数 \u0026#34;isolatedModules\u0026#34;: true, // 将每个文件做为单独的模块 （与 \u0026#39;ts.transpileModule\u0026#39; 类似）. /* 严格的类型检查选项 */ \u0026#34;strict\u0026#34;: true, // 启用所有严格类型检查选项 \u0026#34;noImplicitAny\u0026#34;: true, // 在表达式和声明上有隐含的 any类型时报错 \u0026#34;strictNullChecks\u0026#34;: true, // 启用严格的 null 检查 \u0026#34;noImplicitThis\u0026#34;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \u0026#34;alwaysStrict\u0026#34;: true, // 以严格模式检查每个模块，并在每个文件里加入 \u0026#39;use strict\u0026#39; /* 额外的检查 */ \u0026#34;noUnusedLocals\u0026#34;: true, // 有未使用的变量时，抛出错误 \u0026#34;noUnusedParameters\u0026#34;: true, // 有未使用的参数时，抛出错误 \u0026#34;noImplicitReturns\u0026#34;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, // 选择模块解析策略： \u0026#39;node\u0026#39; (Node.js) or \u0026#39;classic\u0026#39; (TypeScript pre-1.6) \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 用于解析非相对模块名称的基目录 \u0026#34;paths\u0026#34;: {}, // 模块名到基于 baseUrl 的路径映射的列表 \u0026#34;rootDirs\u0026#34;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \u0026#34;typeRoots\u0026#34;: [], // 包含类型声明的文件列表 \u0026#34;types\u0026#34;: [], // 需要包含的类型声明文件名列表 \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \u0026#34;sourceRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \u0026#34;mapRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到映射文件而不是生成文件的位置 \u0026#34;inlineSourceMap\u0026#34;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \u0026#34;inlineSources\u0026#34;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \u0026#34;experimentalDecorators\u0026#34;: true, // 启用装饰器 \u0026#34;emitDecoratorMetadata\u0026#34;: true // 为装饰器提供元数据的支持 } } 3.2 非空断言 在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。具体而言，x! 将从 x 值域中排除 null 和 undefined 。\n那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。\n1.忽略 undefined 和 null 类型 1 2 3 4 5 6 function myFunc(maybeString: string | undefined | null) { // Type \u0026#39;string | null | undefined\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. // Type \u0026#39;undefined\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. const onlyString: string = maybeString; // Error const ignoreUndefinedAndNull: string = maybeString!; // Ok } 2.调用函数时忽略 undefined 类型 1 2 3 4 5 6 7 8 type NumGenerator = () =\u0026gt; number; function myFunc(numGenerator: NumGenerator | undefined) { // Object is possibly \u0026#39;undefined\u0026#39;.(2532) // Cannot invoke an object which is possibly \u0026#39;undefined\u0026#39;.(2722) const num1 = numGenerator(); // Error const num2 = numGenerator!(); //OK } 因为 ! 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：\n1 2 3 const a: number | undefined = undefined; const b: number = a!; console.log(b); 以上 TS 代码会编译生成以下 ES5 代码：\n1 2 3 const a: number | undefined = undefined; const b: number = a!; console.log(b); 虽然在 TS 代码中，我们使用了非空断言，使得 const b: number = a!; 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，! 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 undefined。\n3.3 确定赋值断言 在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：\n1 2 3 4 5 6 7 8 let x: number; initialize(); // Variable \u0026#39;x\u0026#39; is used before being assigned.(2454) console.log(2 * x); // Error function initialize() { x = 10; } 很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：\n1 2 3 4 5 6 7 let x!: number; initialize(); console.log(2 * x); // Ok function initialize() { x = 10; } 通过 let x!: number; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。\n","permalink":"https://bablvsj.github.io/posts/tech/codelanguage/20230815-typescript/","summary":"TypeScript的特性 类型系统 TypeScript是静态类型 （根据类型检查的时机来分类） 动态类型是指在运行时才会进行类型检查，这种语言的","title":"TypeScript"},{"content":"作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。\n分词/词法分析（Tokenizing/Lexing） 由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，程序 var a = 2;。这段程序通常会被分解成为这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。\n分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。 解析/语法分析（Parsing） 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。\n代码生成 将 AST 转换为可执行代码的过程称被称为代码生成。\n比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。\n首先，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。\n对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。\n简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。\n1.2 理解作用域 LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。 赋值操作还有其他几种形式，因此在概念上最好将其理解为 赋值操作的目标是谁（LHS） 以及谁是赋值操作的源头（RHS）。\nLHS 赋值操作，如a = 2；对a进行了 LHS查询\nRHS 查找源头，如 console.log(b)，对b进行了RHS查询\n如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。\n赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。\nLHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。\n不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。\n小测及答案 1 2 3 4 5 6 7 8 9 function foo(a) { var b = a; return a + b; } var c = foo( 2 ); 1. 找出所有的 LHS 查询（这里有 3 处！） c = ..;、a = 2（隐式变量分配）、b = .. 2. 找出所有的 RHS 查询（这里有 4 处！） foo(2..、= a;、a ..、.. b 第2章 词法作用域 2.1 词法阶段 词法作用域就是定义在词法阶段的作用域。\n查找\n作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。\n无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\nJavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。\n这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。\n第3章 函数作用域和块作用域 3.2隐藏内部实现 **最小授权或最小暴露原则： 应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。\n这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //示例代码 function doSomething(a) { b = a + doSomethingElse( a * 2 ); console.log( b * 3 ); } function doSomethingElse(a) { return a - 1; } var b; doSomething( 2 ); // 15 // 优化后 function doSomething(a) { function doSomethingElse(a) { return a - 1; } var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 ); } doSomething( 2 ); // 15 b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。\n规避冲突\n“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。\n1 2 3 4 5 6 7 8 9 10 function foo() { function bar(a) { i = 3; // 修改 for 循环所属作用域中的 i console.log( a + i ); } for (var i=0; i\u0026lt;10; i++) { bar( i * 2 ); // 糟糕，无限循环了！ } } foo(); 3.3 函数作用域 函数声明\n1 2 3 4 5 6 7 var a = 2; function foo() { var a = 3; console.log( a ); // 3 } foo(); console.log( a ); // 2 函数表达式\n1 2 3 4 5 6 var a = 2; (function foo(){ var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。 比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。 换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。\n3.3.1 匿名和具名 对于函数表达式你最熟悉的场景可能就是回调参数了，比如：\n1 2 3 setTimeout( function() { console.log(\u0026#34;I waited 1 second!\u0026#34;); }, 1000 ); 这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它有几个缺点需要考虑。\n匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：\n1 2 3 setTimeout( function timeoutHandler() { // \u0026lt;-- 快看，我有名字了！ console.log( \u0026#34;I waited 1 second!\u0026#34; ); }, 1000 ); 3.3.2 立即执行函数表达式 IIFE\n1 2 3 4 5 6 var a = 2; (function foo() { var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2 比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。\n传递参数\n1 2 3 4 5 6 7 var a = 2; (function IIFE( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 })( window ); console.log( a ); // 2 IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Definition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。\n1 2 3 4 5 6 7 8 var a = 2; (function IIFE( def ) { def( window ); })(function def( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 }); 函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值。\n3.4 块作用域 with / try catch / let / cost\n第4章 提升 任何声明在某个作用域内的变量，都将附属于这个作用域。\n4.1 先有鸡还是先有蛋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 例1： a = 2; var a; console.log( a ); // 2 形如： var a; a = 2; console.log(a) 例2： console.log( a ); // undefined var a = 2; 形如： var a; console.log(a) a = 2; 提升：变量和函数声明从它们在代码中出现的位置被“移动”到了最上面的过程。 就是先有声明后有赋值。\n4.3 函数优先 函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。\n1 2 3 4 5 6 7 8 foo(); // 1 var foo; function foo() { console.log( 1 ); } foo = function() { console.log( 2 ); }; var foo 尽管出现在 function foo()\u0026hellip; 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。\n尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的\n1 2 3 4 5 6 7 8 9 10 foo(); // 3 function foo() { console.log( 1 ); } var foo = function() { console.log( 2 ); }; function foo() { console.log( 3 ); } 第5章 作用域闭包 JavaScript中闭包无处不在，你只需要能够识别并拥抱它。\n5.1 实质问题 1 2 3 4 5 6 7 8 9 function foo() { var a = 2; function bar() { console.log( a ); } return bar; } var baz = foo(); baz(); // 2 —— 朋友，这就是闭包的效果。 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。\n而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n1 2 3 4 5 6 7 8 9 10 function foo() { var a = 2; function baz() { console.log( a ); // 2 } bar( baz ); } function bar(fn) { fn(); // 妈妈快看呀，这就是闭包！ } 1 2 3 4 5 6 7 8 9 10 11 12 13 var fn; function foo() { var a = 2; function baz() { console.log( a ); } fn = baz; // 将 baz 分配给全局变量 } function bar() { fn(); // 妈妈快看呀，这就是闭包！ } foo(); bar(); // 2 5.3 现在我懂了 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。 这就是闭包。\n通常认为 IIFE 是典型的闭包例子，但根据先前对闭包的定义，我并不是很同意这个观点。\n1 2 3 4 var a = 2; (function IIFE() { console.log( a ); })(); 虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有 a）。a 是通过普通的词法作用域查找而非闭包被发现的。\n5.4 循环和闭包 当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。\n1 2 3 4 5 6 for (var i=1; i\u0026lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 ); } // 6 6 6 6 6 代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？ 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，**实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。\nIIFE 会通过声明并立即执行一个函数来创建作用域。我们来试一下：\n1 2 3 4 5 6 7 8 for (var i=1; i\u0026lt;=5; i++) { (function (){ setTimeout( function timer() { console.log( i ); }, i*1000 ); })(); } // 6 6 6 6 6 如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。\n它需要有自己的变量，用来在每个迭代中储存 i 的值：\n1 2 3 4 5 6 7 8 for (var i=1; i\u0026lt;=5; i++) { (function (j){ setTimeout( function timer() { console.log( j ); }, i*1000 ); })(i); } // 1 2 3 4 5 重返块作用域\nlet 声明 ，本质上这是将一个块转换成一个可以被关闭的作用域\nfor 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n1 2 3 4 5 6 for (let i=1; i\u0026lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 ); } // 1 2 3 4 5 5.5 模块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function CoolModule() { var something = \u0026#34;cool\u0026#34;; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( \u0026#34; ! \u0026#34; ) ); } return { doSomething: doSomething, doAnother: doAnother }; } var foo = CoolModule(); foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3 这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。\n模块模式需要具备两个必要条件。\n必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。\n","permalink":"https://bablvsj.github.io/posts/tech/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-%E4%B8%8A/","summary":"作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（T","title":"你不知道的JavaScript-上"},{"content":"第一章 C++语言简介 第一节 C++语言的发展简史 1、程序语言分为三类：低级语言、中级语言、高级语言\n机器语言和汇编语言属于低级语言，直接能够操纵寄存器和内存\n机器语言依赖于 CPU 的指令系统，使用二进制代码编写程程序，直接被机器识别。 汇编语言使用助记符编写程序，是符号化了的机器语言，通用性差 高级语言是面向用户的语言，通用性强，C++属于高级语言 2、C 与 C++的关系\nC++98 为 C++标准第一版，C 语言是 C++的前身，C++是 C 的一个超集，进一步扩充和完善了 C，C++比 C 更安全。\n3、C++是一种编译式的、通用式、大小写敏感的编程语言，完全支 持面向对象程序设计。\n第二节 C++语言的特点 知识点 1 输入/输出与命名空间\n1、基本输入输出 C++将数据从一个对象流向另一个对象的流动的抽象称为“流”。从 流中获取数据的操作称 为提取操作。向流中添加数据的操作称为插 入操作。cin 用来处理标准输入，即键盘输入。\n输入：cin cin\u0026raquo;变量 1\u0026raquo;变量 2\u0026raquo;…\u0026raquo;变量 n; 连续从键盘读取想要的数据时，以空格、制表符 Tab 或 Enter 键作为 分隔符，如果要输入 这三种字符给变量，可以使用 getchar()函数。\n输出：cout cout\u0026laquo;表达式 1\u0026laquo;表达式 2\u0026laquo;…\u0026laquo;表达式 n; cout 用来处理标准输出，即屏幕输出。 需要在程序中包含头文件#include\u0026lt;iostream\u0026gt; \u0026lt;iostream\u0026gt;为标准输入输出流\n2、常用的头文件 \u0026lt;iostream\u0026gt;为标准输入输出流 \u0026lt;fstream\u0026gt;为标准文件流 \u0026lt;string\u0026gt;为标准字符串处理函数 \u0026lt;cmath\u0026gt;为标准数学函数\n3、命名空间 所谓命名空间（namespace）是一种将程序库名称封装起来的方法，它提高了程序的性能和可靠性。可消除同名引起的冲突 标准程序库的命名空间 using namespace std; 引入其他命名空间标识符为：命名空间 名::标识符名\n知识点 2 类型转换\n4、强制类型转换 static_cast \u0026lt;类型名\u0026gt; 表达式 ","permalink":"https://bablvsj.github.io/posts/exams/c++/","summary":"第一章 C++语言简介 第一节 C++语言的发展简史 1、程序语言分为三类：低级语言、中级语言、高级语言 机器语言和汇编语言属于低级语言，直接能够操纵","title":"C++"},{"content":"1. 重绘与重排的区别 重绘：更换背景色 重排/回流：隐藏删除元素，页面dom重新渲染，重新生成布局，重新排列元素，非常影响性能。 『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。\n2. BFC 的原理/BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：\n（1）BFC 内部的子元素，在垂直方向，边距会发生重叠。 （2）BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。 （3）BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。 （4）计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 3. 如何生成BFC 有以下几种方法：\n方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex 参考链接：\nBFC原理详解 BFC详解 前端精选文摘：BFC 神奇背后的原理 4. 标准 / IE盒子模型 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：\nwidth和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别：\n在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-css-%E9%A2%98%E5%BA%93/","summary":"1. 重绘与重排的区别 重绘：更换背景色 重排/回流：隐藏删除元素，页面dom重新渲染，重新生成布局，重新排列元素，非常影响性能。 『重绘』不一定会出","title":"Css题库"},{"content":"英语（二）不规则动词表\n中文 原形 动词过去式 过去分词 1.出现，升起 arise arose arisen 2.开始 begin began begun 3.吹 blow blew blown 4打断break broke broken\n5选择choose chose chosen\n6做do did done\n7画draw drew drawn\n8喝drink drank drunk\n9开车,驾驶drive drove driven\n10吃eat ate eaten\n11落下fall fell fallen\n12飞fly flew flown\n13冻结freeze froze frozen\n14给give gave given\n15去go went gone\n16长大grow grew grown\n17知道know knew known\n18误解, 弄错mistake mistook mistaken\n19成长速度超outgrow o utgrew outgrown\n20骑ride rode ridden\n21响铃ring rang rung\n22上升rise rose risen\n23看see saw seen\n24摇shake shook shaken\n25唱sing sang sung\n26下沉，沉没sink sank sunk\n27说speak spoke spoken\n28偷steal stole stolen\n29发誓swear swore sworn\n30游泳swim swam swum\n31拿take took taken\n32撕，扯破tear tore torn\n33扔throw threw thrown\n34穿wear wore worn\n35写write wrote written\n现在分词为：writing\n以下各词过去式与过去分词相同\n36弯曲bend bent bent\n37捆bind bound bound\n38带来bring brought brought\n39建造build built built\n40买buy bought bought\n41抓住catch caught caught\n42挖dig dug dug\n43喂feed fed fed\n44觉得feel felt felt\n45找到find found found\n46打仗fight fought fought\n47有have had had\n48听hear heard heard\n49抓拿hold held held\n50保持keep kept kept\n51放lay laid laid\n52领导lead led led\n53离开leave left left\n54借出lend lent lent\n55丢失lose lost lost\n56制做make made made\n57意思是mean meant meant\n58遇见meet met met\n59误解，误会 misunderstand misunderstood misunderstood\n60恐慌 panic panicked panicked\n61付钱pay paid paid\n62说 say said said\n63寻求 seek sought sought 64卖sell sold sold\n65送 send sent sent\n66射击shoot shot shot\n67坐sit sat sat\n68睡sleep slept slept\n69花费spend spent spent\n70站stand stood stood\n71扫sweep swept swept\n72教teach taught taught\n73告诉tell\ntold told\n74想think thought thought\n75知道understand understood understood\n76哭泣weep wept wept\n77赢win won won\n78吹风，绕wind wound wound\n下列各词的原形、过去式、过去分词都一样\n79爆炸burst burst burst 80投扔cast cast cast\n81价值花费cost cost cost\n82切cut cut cut 83打击hit hit hit\n84伤害hurt hurt hurt 85让let let let\n86放put put put\n87读read read read\n88流出shed shed shed\n89关闭shut shut shut\n90分离split split split\n91伸开spread spread spread\n92插刺thrust thrust thrust\n93弄翻心烦upset upset upset\n下列各词的原形和过去分词相同\n94变得成为 become became become\n95来come came come\n96跑run ran run\n97、98是特殊变化\n97击打 beat beat beaten\n98忍受出生 bear b ore born / borne\n后面各词的过去式或过去分词为两可型\n99咬 bite bit bit / bitten\n100忘记 forget forgot forgot/ forgotten\n101得到 get got got / gotten\n102躲藏 hide h id hid / hidden\n103证实 prove proved proved /proven\n104缝 sew sewed sewed / sewn\n105出示展示 show showed showed / shown\n106打击 strike struck struck / stricken\n107唤醒 awake awoke /awaked awoke / awaked\n108打赌bet bet / betted bet / betted\n109广播broadcast broadcast/broadcasted broadcast/broadcasted\n110燃烧burn burnt/burned burnt / burned\n111做梦dream dreamt/dreamed dreamt/dreamed\n112适合fit fit /fitted fit/fitted\n113* 处死hang hanged hanged\n113悬挂hang hung hung\n114倾斜lean leant /\nleaned\nleant / leaned\n115学习learn learnt /\nlearned\nlearnt / learned\n116* 撒谎lie lied lied\n116躺lie lay lain\n117摆脱rid rid / ridded rid / ridded\n118发光shine shined /\nshone\nshined / shone\n119嗅, 闻smell smelled /\nsmelt\nsmelled / smelt\n120加速speed sped\n/speeded\nsped / speeded\n121拼写spell spelt /\nspelled\nspelt / spelled\n122溢出spill spilt/spilled spilt / spilled\n123醒wake woke / wakedwoke /waked / woken\n124弄湿wet wet / wetted wet / wetted\n","permalink":"https://bablvsj.github.io/posts/exams/english/","summary":"英语（二）不规则动词表 中文 原形 动词过去式 过去分词 1.出现，升起 arise arose arisen 2.开始 begin began begun 3.吹 blow blew blown 4打断break broke broken 5选择choose chose chosen 6做","title":"English"},{"content":" am pm 28 Java程序设计 数据库原理 29 C++程序设计 英语二 Java程序设计 04747 - 2017\n数据库原理 04735 - 2018\nC++程序设计 04727 - 2019\n英语二 00015 - 2012\n","permalink":"https://bablvsj.github.io/posts/exams/20231028-for-four-exams/","summary":"am pm 28 Java程序设计 数据库原理 29 C++程序设计 英语二 Java程序设计 04747 - 2017 数据库原理 04735 - 2018 C++程序设计 04727 - 2019 英语二 00015 - 2012","title":"for four exams"},{"content":"This is Java ","permalink":"https://bablvsj.github.io/posts/exams/java/","summary":"This is Java","title":"Java"},{"content":"在Vue 3中，reactive和ref是用于创建响应式数据的两种不同方式。\nreactive函数用于将一个普通的JavaScript对象转换为响应式对象。它会递归地将对象的所有属性转换为响应式属性，这意味着当属性的值发生变化时，Vue会自动追踪和更新相关的视图。使用reactive函数创建的对象可以像普通对象一样使用，可以直接访问和修改属性。\n1 2 3 4 5 6 7 8 import { reactive } from \u0026#39;vue\u0026#39; const state = reactive({ count: 0 }) console.log(state.count) // 输出: 0 state.count++ // 修改count的值 console.log(state.count) // 输出: 1 ref函数用于创建一个简单的响应式引用。它将一个普通的JavaScript值转换为一个响应式对象，该对象具有一个名为value的属性，该属性包含实际的值。与reactive不同，ref只能用于包装单个值，而不是对象。\n1 2 3 4 5 6 import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) console.log(count.value) // 输出: 0 count.value++ // 修改值 console.log(count.value) // 输出: 1 当在模板中使用响应式对象时，可以直接访问ref包装的值，而不需要访问.value属性。Vue会自动进行解包。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) const increment = () =\u0026gt; { count.value++ } \u0026lt;/script\u0026gt; 综上所述，reactive用于创建响应式对象，适用于复杂的数据结构，而ref用于创建简单的响应式引用，适用于单个值。\n","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/20230810-reactive%E4%B8%8Eref%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"在Vue 3中，reactive和ref是用于创建响应式数据的两种不同方式。 reactive函数用于将一个普通的JavaScript对象转换为","title":"reactive与ref的区别"},{"content":"","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/ts/","summary":"","title":"TS面试题"},{"content":"你知道Vue3.x响应式数据原理吗？ Vue3.x改用Proxy替代Object.defineProperty。\n因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。\nProxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？\n判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。 Proxy 与 Object.defineProperty 优劣对比 Proxy 的优势如下: Proxy 可以直接监听对象而非属性；\nProxy 可以直接监听数组的变化；\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下:\n兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 什么情况下使用 Vuex？ 如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可\n需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态\nVuex和单纯的全局对象有什么区别？ Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 为什么 Vuex 的 mutation 中不能做异步操作？ Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。 新增：vuex的action有返回值吗？返回的是什么？ store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise\nAction 通常是异步的，要知道 action 什么时候结束或者组合多个 action以处理更加复杂的异步流程，可以通过定义action时返回一个promise对象，就可以在派发action的时候就可以通过处理返回的 Promise处理异步流程\n一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n新增：为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态 mutation 必须同步执行，我们可以在 action 内部执行异步操作 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更） 对于即将到来的 vue3.0 特性你有什么了解的吗？ 监测机制的改变\n3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象\n检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 模板\n模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 对象式的组件声明方式\nvue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易 其它方面的更改\n支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 tree shaking 优化，提供了更多的内置功能 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue3-%E7%9F%A5%E8%AF%86%E7%82%B9/","summary":"你知道Vue3.x响应式数据原理吗？ Vue3.x改用Proxy替代Object.defineProperty。 因为Proxy可以直接监听对象","title":"Vue3 知识点"},{"content":"勒布朗（LeBlanc）法则：稍后等于永不（Later equals never）\n","permalink":"https://bablvsj.github.io/posts/tech/think.md/","summary":"勒布朗（LeBlanc）法则：稍后等于永不（Later equals never）","title":"些许思考"},{"content":" 你讲一下vue双向绑定的原理\n讲一下vue3相比vue2，它在diff算法上做了哪些优化？\nVue2为什么要对数组的常用方法进行重写？\nVue的nextTick是怎么实现的？\n讲一下你对EventLoop的理解吧\n讲一下webpack5的模块联邦\n讲一下webpack的打包原理\n讲一下webpack的loader和plugin\n讲一下webpack5的模块联邦\n讲一下Babel的原理，讲一下AST抽象语法树\n讲一下你所知道的设计模式\n讲一下浏览器的垃圾回收机制\n讲一下浏览器的渲染流程\n讲一下浏览器多进程的渲染优势\n谈谈你对浏览器架构的理解\n观察一组数列，写一个方法求出第31个数字是什么？（通过观察后，发现那是一组斐波那契数列）\n实现一个深拷贝函数\n写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式。\n假设要设计一个全局的弹窗组件你会怎么设计？\n如果这个弹窗组件可以弹出多个，消息会垂直排列，新消息会把旧消息顶起来，每个消息都可以设置一个停留时间，到了时间后就会消失，这一块你会怎么设计？\n你了解堆这种数据结构吗？讲一讲你对它的理解\n讲一下V8的垃圾回收机制\n讲一下chrome是如何渲染一个网页的\n大文件分块上传以及断点续传，你会怎么实现\n你觉得你是一个什么样的人？\n你有哪些优点？\n你想成为一个什么样的人？\n你觉得你的技术水平怎么样？\n如果让你给自己打标签，你会打什么标签？\n回看你的过往人生，你后悔吗？\njs 相关\nes6 基本语法 promise async / await 原型链 渲染机制 运行机制：异步同步、 宏任务微任务 vue3相关\nref / reactive 与其区别 pinia / vuex 与其区别区别 vite / webpack 与其区别区别 vue3的优缺点 传参方式 网络\n跨域请求 Http请求码 http / https 安全：CSRF、XSS 性能优化\n前端错误监控 页面性能 算法问题\n排序（快速、选择、冒泡） 递归 面试准备 面试准备根据每个人掌握的知识不同，准备的时间也不一样。现在对于前端岗位，以前也许不是很重视算法这块，但是现在很多公司也都会考。建议大家平时有空的时候多刷刷leetcode。算法的准备时间比较长，是一个长期的过程。需要在掌握了大部分前端基础知识的情况下，再有针对性的去复习算法。面试的时候算法能做出来肯定加分，但做不出来也不会一票否决，面试官也会给你提供一些思路。\n笔试题 笔试题一般考的都是基础知识，复习基础知识建议看书，高程和你不知道的JS都行，会讲的比较细。\nCSS css基本上每个公司也都会问，但是问的不会很深，都是一些常见的问题。\n· 盒模型\n· 垂直居中方法\n· 三栏布局\n· 选择器权重计算方式\n· 清除浮动的方法\n· Flex\n· 什么是BFC、可以解决哪些问题\n· position属性\n· 如何实现一个自适应的正方形\n· 如何用css实现一个三角形\n手写题 手写题每个公司都会有，范围也比较固定，如果之前好好准备的话，应该没什么问题。\n· 防抖和节流\n· 深拷贝\n· 数组去重、数组乱序\n· 手写call、apply、bind\n· 继承（ES5/ES6）\n· sleep函数\n· 实现promise\n· 实现promise.all\n· 实现promise.retry\n· 将一个同步callback包装成promise形式\n· 写一个函数，可以控制最大并发数\n· jsonp的实现\n· eventEmitter(emit,on,off,once)\n· 实现instanceof\n· 实现new\n· 实现数组flat、filter等方法\n· lazyMan\n· 函数currying\nES6 现在基本上都会使用ES6开发。ES6也成为了一个面试必考点。一般面试官都会问用过ES6的哪些新特性，再针对你所回答的进行深入的提问。\n· let、const、var区别\n· 箭头函数与普通函数的区别\n· 变量的结构赋值\n· promise、async await、Generator的区别\n· ES6的继承与ES5相比有什么不同\n· js模块化（commonjs/AMD/CMD/ES6）\n浏览器相关知识 浏览器相关知识几乎是每个公司都会问到的考点，里面涉及的东西也比较多。其中缓存、http2、跨域必问。\n· 从输入URL到呈现页面过程\n· 强缓存、协商缓存、CDN缓存\n· HTTP2\n· HTTP状态码\n· 三次握手与四次挥手\n· 跨域（JSONP/CORS）\n· 跨域时如何处理cookie\n· 垃圾回收机制\nweb安全 一般我都会从xss和csrf说起。\n· https\n· 什么是xss，如何预防\n· 什么是csrf，如何预防\n· 为什么会造成csrf攻击\n事件循环 事件循环绝对是一个必考题。其中涉及到宏任务、微任务、UI渲染等的执行顺序，浏览器端的必须要掌握，node端的有精力的最好也能掌握。\n框架（vue） 因为我一直用的都是vue框架，所以问的也都是跟vue相关的。vue中的高频题也不外乎双向绑定、虚拟dom、diff算法这些。\n· watch与computed的区别\n· vue生命周期及对应的行为\n· vue父子组件生命周期执行顺序\n· 组件间通讯方法\n· 如何实现一个指令\n· vue.nextTick实现原理\n· diff算法\n· 如何做到的双向绑定\n· 虚拟dom为什么快\n· 如何设计一个组件\nwebpack webpack也基本上成了必考的内容，一般会问是否配置过webpack、做过哪些优化之类的。\n· 用过哪些loader和plugin\n· loader的执行顺序为什么是后写的先执行\n· webpack配置优化\n· webpack打包优化（happypack、dll）\n· plugin与loader的区别\n· webpack执行的过程\n· 如何编写一个loader、plugin\n· tree-shaking作用，如何才能生效\n性能优化 · 首屏加载如何优化\n· 一个网页从请求到呈现花了很长时间，如何排查\n1.工作中使用过加密方法，简单介绍一下\nMD5 / ASC / DESC\n2. 对前端模块化的了解有多少，为什么要模块化开发\n2 提高代码复用率\n3 提高维护性\n4 依赖关系的管理\n3.将下面这个数组去重（写出3种方法即可）\nlet arr=[1,29,3,1,50,5,10,57,6,5]\n","permalink":"https://bablvsj.github.io/posts/interview/temp-question-list/","summary":"你讲一下vue双向绑定的原理 讲一下vue3相比vue2，它在diff算法上做了哪些优化？ Vue2为什么要对数组的常用方法进行重写？ Vue的n","title":"面试题列表"},{"content":"完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import os import re import sys import glob path = \u0026#39;D:/2cr/temp/hugoBlog/content/temp\u0026#39; # 指定所需处理文件的目录 # 递归遍历文件夹 for root, dirs, files in os.walk(path): for file in files: if os.path.splitext(file)[1] == \u0026#39;.md\u0026#39;: # 匹配后缀名为md的文件 filename = os.path.splitext(file)[0] # 获取文件名 dirFile = os.path.join(root, file) # 获取文件完整目录（如果文件层级过深） print(filename) def write_file(): # with open(file,\u0026#34;r+\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) as f: # f.seek(0) # content = f.read() # print(tempText) # f.write(tempText) # f.close() # 读取文件内容 f = open(dirFile, \u0026#34;r\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) #指定编码类型 content = f.read() tempText = \u0026#34;--- \\n title: \u0026#34;+filename+\u0026#34; \\n date: 2020-01-01T17:11:35+08:00 \\n draft: false \\n tags: \\n - 开发软件快捷使用 \\n---\\n \\n\u0026#34; + content f.close() # 写入文件内容 f = open(dirFile, \u0026#34;w\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) f.write(tempText) f.close() 读取文件 open(文件路径,读写方式,编码) r: 文件以只读方式打开（也是默认模式）。 w: 文件以写入方式打开，会重置文件。 x: 创建一个新文件且写入。 a: 追加写入(如果文件存在，会在末尾进行追加)。 b: 文件以二进制打开。 t: 文件以文本模式打开（也是默认模式）。 +: 打开文件进行更新（可读可写）。\n1 2 3 openFile = open(\u0026#34;xxxx.txt\u0026#34;,\u0026#34;w\u0026#34;) print(openFile) open_file.close() 写入文件 1 2 3 f = open(dirFile, \u0026#34;w\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) f.write(tempText) f.close() ","permalink":"https://bablvsj.github.io/posts/tech/python/20230802-%E6%89%B9%E9%87%8F%E8%AF%BB%E5%8F%96%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6/","summary":"完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import os import re import sys import glob path = \u0026#39;D:/2cr/temp/hugoBlog/content/temp\u0026#39; # 指定所需处理文件的目录 # 递归遍历文件夹 for root, dirs,","title":"Python 批量读取修改指定类型文件"},{"content":"https://juejin.cn/post/7262007830721757244#heading-4 https://juejin.cn/post/7213994684262891576#heading-11\nPinia 的优点 更贴合 Vue 3 的 Composition API 风格,学习成本更低 不需要区分 Mutation 和 Action,统一使用 Actions 操作状态 支持 TypeScript,可以充分利用 TS 的静态类型系统 模块化管理 States,每个模块是一个 Store 直观的 Devtools,可以看到每个 State 的变化 使用 Pinia 1.安装 1 2 yarn add pinia //或者使用 npm npm install pinia 2.引入 1 2 3 4 5 6 7 8 //main.ts import { createApp } from \u0026#39;vue\u0026#39; import { createPinia } from \u0026#39;pinia\u0026#39; const pinia = createPinia() const app = createApp(App) app.use(pinia) 3.Option Store 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // store/user.ts import { defineStore } from \u0026#39;pinia\u0026#39; export const useUserStore = defineStore(\u0026#39;user\u0026#39;, { // state 定义响应式状态 state: () =\u0026gt; { return { name: \u0026#39;lvbu\u0026#39;, age:\u0026#34;\u0026#34; } }, // getters 计算属性 getters: { getUserName(state) { return state.name } }, //定义方法修改状态 actions: { changeUserName(name) { this.name = name } } }) 4.使用 1 2 3 4 5 import { useUserStore } from \u0026#39;@/store/user\u0026#39; const store:any = useUserStore() console.log(store.name) 5. 修改数据 修改数据多种方法，可以直接修改，也可以使用 actions 修改。\n方法1：直接修改 1 2 3 import { useUserStore } from \u0026#39;@/store/user\u0026#39; const store = useUserStore() store.userInfo = obj // obj 指新值 方法2：借助 actions 修改 1 2 3 import { useUserStore } from \u0026#39;@/store/user\u0026#39; const store = useUserStore() store.changeUserName(obj) // obj 指新值 方法3：多属性修改 1 2 3 4 5 6 7 8 import { defineStore } from \u0026#39;pinia\u0026#39; export const useUserStore = defineStore(\u0026#39;user\u0026#39;, { state: () =\u0026gt; ({ name: null, age: null, sex: null, }), }) 上面的方法都是用来修改单个属性的，如果你需要一次修改多个属性，虽然你可以重复操作上面的方法，但是 pinia 提供了新的方法，我更推荐使用官方推荐的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 import { useUserStore } from \u0026#39;@/store/user\u0026#39; const store = useUserStore() // 你可以这样去修改（不建议） store.name = \u0026#39;张三\u0026#39; store.age = 24 store.sex = \u0026#39;男\u0026#39; // 推荐使用下面这种方式 √ store.$patch({ name: \u0026#39;张三\u0026#39;, age: 24, sex: \u0026#39;男\u0026#39;, }) 修改数据的场景及方法当然不止这些，有些复杂的数据修改仅靠这些是难以实现的，不过本文的目的是简单讲解 pinia 的使用方法，就不多做赘述了，想具体了解推荐去看 Pinia 官方文档。\n","permalink":"https://bablvsj.github.io/posts/interview/vue3/20230801-vue3%E6%96%B0%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-pinia/","summary":"https://juejin.cn/post/7262007830721757244#heading-4 https://juejin.cn/post/7213994684262891576#heading-11 Pinia 的优点 更贴合 Vue 3 的 Composition API 风格,学习成本更低 不需要区分 Mutation 和 Action,统一使用 Actions 操作状态 支持 TypeScript,可以充分利用 TS 的静态类","title":"Vue3 新的状态管理工具 Pinia"},{"content":"父子组件 props 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //父组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildrenVue :msg=\u0026#39;msg\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup \u0026gt; import ChildrenVue from \u0026#39;../components/Children.vue\u0026#39;; import { ref } from \u0026#39;vue\u0026#39; const msg = ref(\u0026#39;哈喽哈喽\u0026#39;) } \u0026lt;/script //子组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; {{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; export default { props: [\u0026#39;msg\u0026#39;], const msg = props.msg } \u0026lt;/script\u0026gt; defineProps 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //我是子组件 \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt; {{props.msg}}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // const props = defineProps\u0026lt;{ msg?: string, }\u0026gt;() ts写法 const props = defineProps({ // 写法一 // msg: String //写法二 msg: { type: String, default: \u0026#39;\u0026#39; } }) console.log(props.msg); \u0026lt;/script\u0026gt; emit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //父组件 \u0026lt;template\u0026gt; \u0026lt;ChildrenVue @myClick=\u0026#39;onMyClick\u0026#39; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import ChildrenVue from \u0026#39;../components/Children.vue\u0026#39;; const onMyClick = (msg) =\u0026gt; { console.log(msg); } \u0026lt;/script\u0026gt; //子组件 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { defineEmits } from \u0026#39;vue\u0026#39; const emit = defineEmits([\u0026#39;myClick\u0026#39;]) const handleClick = () =\u0026gt; { emit(\u0026#39;myClick\u0026#39;, \u0026#39;我是子组件给父组件的\u0026#39;) } \u0026lt;/script\u0026gt; ref 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //父组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Childre ref=\u0026#39;children\u0026#39; /\u0026gt; \u0026lt;button @click=\u0026#34;getChild\u0026#34;\u0026gt;获取子组件的属性和方法\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Children from \u0026#39;../components/Children.vue\u0026#39;; import { ref } from \u0026#39;vue\u0026#39; const children = ref(null) const getChild = () =\u0026gt; { console.log(children.value.title); children.value.toggle() } \u0026lt;/script\u0026gt; //子组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子组件 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const title = \u0026#39;我是子组件的属性\u0026#39; const toggle = () =\u0026gt; { console.log(\u0026#39;我是子组件的方法\u0026#39;); } \u0026lt;/script\u0026gt; 兄弟组件 路由传参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 传递 import { useRouter } from \u0026#39;vue-router\u0026#39; const router = useRouter() router.push({ path: \u0026#39;/detail\u0026#39;, query: { id: 12345 } }) // 接收 import { useRoute, computed } from \u0026#39;vue-router\u0026#39; const route = useRoute() const id = computed(() =\u0026gt; { return route.query.id }) 本地缓存 1 2 3 4 5 6 7 // 存储 sessionStorage.setItem(\u0026#34;id\u0026#34;, 12345); localStorage.setItem(\u0026#34;id\u0026#34;, 12345); // 读取 sessionStorage.getItem(\u0026#34;id\u0026#34;); localStorage.getItem(\u0026#34;id\u0026#34;); 通用 provide / inject 依赖注入 1 2 3 4 5 6 7 8 9 10 11 12 //父组件(传值组件) \u0026lt;script setup\u0026gt; import { provide } from \u0026#34;vue\u0026#34; provide(\u0026#34;name\u0026#34;, \u0026#34;lvxiaobu\u0026#34;) \u0026lt;/script\u0026gt; //子组件(接收组件) \u0026lt;script setup\u0026gt; import { inject } from \u0026#34;vue\u0026#34; const name = inject(\u0026#34;name\u0026#34;) console.log(name) // lvxiaobu \u0026lt;/script\u0026gt; pinia (推荐使用) / vuex Vuex和Pinia可以轻松实现组件通信\neventBus Vue3中移除了事件总线，但是可以借助于第三方工具来完成，Vue官方推荐mitt或tiny-emitter\n","permalink":"https://bablvsj.github.io/posts/interview/vue3/20230801-vue3-%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/","summary":"父子组件 props 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //父组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildrenVue :msg=\u0026#39;msg\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup \u0026gt; import ChildrenVue from \u0026#39;../components/Children.vue\u0026#39;; import { ref } from \u0026#39;vue\u0026#39; const msg = ref(\u0026#39;哈喽哈","title":"Vue3 常用传参方式"},{"content":"一、git 下载安装与检测是否安装成功 1、git 官网官网地址，这边提醒您官网是外网下载速度极慢。 所以我推荐阿里的下载地址，版本有特别多，那就随机抽取一个幸运的安装包吧！ 1、下载完成点击安装，一路 next 无脑操作就行。 2、安装完成后输入Win + R打开命令窗口，输入git version后如下方显示则安装成功。 1 2 C:\\Users\\lvsj\u0026gt;git version git version 2.30.1.windows.1 二、git 命令常用操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 1、git 常用命令 查看状态 git status 增加文件 git add \u0026#39;text.html\u0026#39; 提交到暂存区 git commit -m \u0026#39;测试提交\u0026#39; 查看所有分支 git branch -a 查看当前使用分支 git branch(结果列表中前面标*号的表示当前使用分支) 切换分支 git checkout 分支名 查看版本号 git log --pretty=oneline 切换版本 git reset --hard 134b(版本号) 查看每一次命令 git reflog 查看分支图 git log --graph 删除文件 git rm text.vue 删除文件夹 git rm -r text.vue 将提交推送到另一分支 git push origin master:dev 拉取代码： C:\\Users\\Administrator\u0026gt;git config --global user.name \u0026#34;lvsijun\u0026#34; C:\\Users\\Administrator\u0026gt;git config --global user.email \u0026#34;1369573083@qq.com\u0026#34; 生成ssh密匙： ssh-keygen -t rsa -C \u0026#34;1369573083@qq.com\u0026#34; 密匙文件目录：C:\\Users\\Administrator\\.ssh\\ 的id_rsa.pub文件 3、如何将代码上传到自己的git上 (1).初始化本地仓库 git init (2).查看文件状态 git status (3).添加文件 git add . (4).删除文件 git rm -r xxx文件名 (5).提交文件到本地仓库 git commit -m \u0026#34;您需要填写的备注\u0026#34; (6).推送到远端git地址 git push （如果是第一次提交代码看第7条） (7).如果是第一次提交的话看这里: I、更改路径 git remote add origin git@github.com:xxxxxxx/test.git II、推送 git push -u origin master 命令：git update-index --no-assume-unchanged 文件名 作用：上一个命令的逆操作，重新追踪文件改动。 常用操作 强拉代码 1 2 3 git fetch --all git reset --hard origin/master git pull 忽略文件改动不进行提交 git update-index \u0026ndash;assume-unchanged 文件名\n作用：忽略文件的改动，但不加入.gitignore中，可以达到仅在本地目录中忽略，不影响其他团队成员的工作。\n删除文件 删除文件 git rm text.vue 删除文件夹 git rm -r text.vue\n","permalink":"https://bablvsj.github.io/posts/blog/2023/001-gitinstall/","summary":"一、git 下载安装与检测是否安装成功 1、git 官网官网地址，这边提醒您官网是外网下载速度极慢。 所以我推荐阿里的下载地址，版本有特别多，那就随","title":"git安装/常用命令"},{"content":"1. 基础环境搭建 安装 git 从 github 拉取/推送代码 安装 hugo 在 v 站看到 子舒 的个人网站，十分简约美观，开始了解到 hugo。\n2. Hugo 网站生成 3. GitPage 部署个人网页 4. GitActions 自动化部署 ","permalink":"https://bablvsj.github.io/posts/life/20230725-%E5%BB%BA%E7%AB%99%E5%8E%86%E7%A8%8B/","summary":"1. 基础环境搭建 安装 git 从 github 拉取/推送代码 安装 hugo 在 v 站看到 子舒 的个人网站，十分简约美观，开始了解到 hugo。 2. Hugo 网站生成 3. GitPage 部署个人网页 4. GitActions 自动","title":"本站创建历程"},{"content":" 让子弹飞（申遗！）\n阿甘正传（“我妈妈经常说，生活就像巧克力，你永远不知道下一颗是什么口味。”）\n初恋这件小事（这就是初恋的感觉）\n楚门的世界（“如果再不能见到你，祝你早安、午安、晚安”）\n当幸福来敲门（“不要让别人告诉你，你不能做什么！”）\n地道战（抗日人民的脑洞真的很大）\n闻香识女人（这部电影的台词真叫一个绝！）\n肖申克的救赎（经典不解释）\n放牛班的春天（天籁之音）\n蜘蛛侠 1 （没看过漫画，比较喜欢老版电影）\n机器人总动员（瓦力超会卖萌）\n怦然心动（两个人的视角来讲述一个青春故事）\n入殓师（没有令人不适的镜头，可以放心观看，治愈系）\n三傻大闹宝莱坞（人物冲突处理到极致）\n海上钢琴师（音乐很棒）\n那些年 我们一起追过的女孩\n千与千寻（就挺奇幻的）\n夺宝奇兵系列（看敌人在耍大刀，无奈一枪放倒）\n封神三部曲 （第一部 狐狸出世纣王无道天下大乱 第二部 纣王率军伐西岐 第三部 姬发联合各诸侯反攻）\n钢铁侠 1 （个人认为漫威系列最佳）\n国王的演讲（带英国挺过二战的国王是个口吃，超长待机女王是他的长女）\n哈利波特 1 、2 （让我对魔法世界最有新鲜感的两部，后面就有点暗黑了）\n好想告诉你（电影+动画）\n黑客帝国系列（见证了两个导演从兄弟变为姐弟在变为姐妹）\n横空出世（“你愿意隐姓埋名一辈子吗？”）\n虎胆龙威系列（英文名Die hard超级贴切 喜欢布鲁斯威利斯被两头坑的无奈表情）\n歌舞青春 1 （歌挺好听的）\n环太平洋（音乐起！）\n回到未来系列（被致敬无数次的科幻经典）\n机器管家（一个想成为人类的机器人的人生）\n疾速追杀系列（“A fuxxing pencil!”）\n罗马假日(男女主颜值超高)\n玫瑰人生（ Edith Piaf 传记，喜欢她的歌可以看一看）\n七磅（片名出自威尼斯商人，主角的还“债”历程，同时也是自我的救赎）\n情书（光良的童话 MV 里面两个人看的那个电影，治愈系）\n速度与激情 3 （可能我是个异类？）\n天使爱美丽（色彩、音乐都很棒，文艺片）\n天堂电影院（一段忘年之交）\n头文字 D （“永远不要有跟人斗的心，你要赢的是你自己。”）\n我，机器人（威尔史密斯主演动作电影的入坑作，其他像黑衣人之类的也很棒）\n我是传奇 1 （有点丧尸版鲁滨逊漂流记的感觉）\n无间道（港版经典）\n西西里的美丽传说（又硬又难受，人言可畏）\n逍遥法外（又叫猫鼠游戏，小李子和汤姆汉克斯版）\n小鬼当家系列（脑洞超大，超搞笑）\n窈窕奶爸（罗宾威廉姆斯演技、口技超一流）\n云图（一旦看懂了，就挺妙）\n战争之王（点子超多的军火商的传奇故事）\n这个杀手不太冷（反差萌）\n终结者 2 （👍）\n最后的武士（挺悲壮的故事）\n宝莲灯（动画，个人认为已经逼近迪士尼水准了）\n暴力街区 Banlieue 13 （跑酷鼻祖大卫贝尔主演）\n变相怪杰（金凯瑞的脸简直就像橡皮泥）\n不能说的秘密（曲子都是精品）\n宫崎骏作品（我是有少女心？）：\n天空之城（入坑作，我一直感觉是映射侵华战争）\n龙猫（超可爱！）\n幽灵公主（又叫魔法少女，久石让作曲超美）\n魔女宅急便（我也想养一只黑猫）\n哈尔的移动城堡（全程注意力在菜头上）\n周星驰主演的经典无厘头，和猫和老鼠一样，可以电视轮播偶尔看一眼：\n喜剧之王\n唐伯虎点秋香\n百变星君\n大话西游系列\n功夫\n国产凌凌漆\n","permalink":"https://bablvsj.github.io/posts/life/20221216-%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E4%B8%80%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/","summary":"让子弹飞（申遗！） 阿甘正传（“我妈妈经常说，生活就像巧克力，你永远不知道下一颗是什么口味。”） 初恋这件小事（这就是初恋的感觉） 楚门的世界（“","title":"一些值得一看的电影"},{"content":"初始模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 title: \u0026#34;模板\u0026#34; date: 2023-07-25T13:46:19+08:00 draft: true # 是否为草稿 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 comments: true disableShare: false # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 description: \u0026#34;\u0026#34; weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; cover: image: \u0026#34;\u0026#34; caption: \u0026#34;\u0026#34; alt: \u0026#34;\u0026#34; relative: false ![[Pasted image 20230728135404.png]]\n","permalink":"https://bablvsj.github.io/posts/life/20230725-helloworld/","summary":"初始模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 title: \u0026#34;模板\u0026#34; date: 2023-07-25T13:46:19+08:00 draft: true # 是否为草稿 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 showToc: true","title":"HelloWorld"},{"content":"HTML的概述 HTML的概念 HTML 全称为 HyperText Markup Language，译为超文本标记语言。\nHTML 不是一种编程语言，是一种描述性的标记语言。\n作用：HTML是负责描述文档语义的语言。\n概念：超文本 所谓的超文本，有两层含义：\n（1）图片、音频、视频、动画、多媒体等内容，成为超文本，因为它们超出了文本的限制。\n（2）可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。\n概念：标记语言 HTML 不是一种编程语言，是一种描述性的标记语言。这主要有两层含义：\n（1）标记语言是一套标记标签。比如：标签\u0026lt;a\u0026gt;表示超链接、标签\u0026lt;img\u0026gt;表示图片、标签\u0026lt;h1\u0026gt;表示一级标题等等，它们都是属于 HTML 标签。\n（2）编程语言是有编译过程的，而标记语言没有编译过程，HTML标签是直接由浏览器解析执行。\nHTML是负责描述文档语义的语言 HTML 格式的文件是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述语义，这些标签在浏览器页面上是无法直观看到的，所以称之为“超文本标记语言”。\nHTML的历史 其中，我们专门来对XHTML做一个介绍。\nXHTML介绍： XHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。 XHTML的主要目的是为了取代HTML，也可以理解为HTML的升级版。 HTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。 XHTML与HTML4.0的标记基本上一样。 XHTML是严格的、纯净的HTML。\nHTML的专有名词 网页 ：由各种标记组成的一个页面就叫网页。 主页(首页) : 一个网站的起始页面或者导航页面。 标记： 比如\u0026lt;p\u0026gt;称为开始标记 ，\u0026lt;/p\u0026gt;称为结束标记，也叫标签。每个标签都规定好了特殊的含义。 元素：比如\u0026lt;p\u0026gt;内容\u0026lt;/p\u0026gt;称为元素. 属性：给每一个标签所做的辅助信息。 XHTML：符合XML语法标准的HTML。 DHTML：dynamic，动态的。javascript + css + html合起来的页面就是一个 DHTML。 HTTP：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，FTP：文件传输协议。 书写第一个 HTML 页面 打开 VS Code 软件，新建一个文件，名叫test.html（注意，文件名是test，后缀名是html），保存到本地。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面的内容，就是 html 页面的骨架。我们在此基础之上，新增几个标签，完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;我是三级标题\u0026lt;/h3\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://www.jd.com\u0026#34;\u0026gt;我是超链接，可以点击一下\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 标签写完之后，我们用 chrome 浏览器打开上面这个test.html文件，看看页面效果：\n到此，第一个简单的 HTML 页面就写完了。是不是很有成就感？\nHTML结构详解 HTML标签通常是成对出现的（双边标记），比如 \u0026lt;div\u0026gt; 和 \u0026lt;/div\u0026gt;；也有少部分单标签（单边标记），如：\u0026lt;br /\u0026gt;、\u0026lt;hr /\u0026gt;和\u0026lt;img src=\u0026quot;images/1.jpg\u0026quot; /\u0026gt;等。\n属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。\nhtml骨架标签分类 标签名 定义 说明 \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt; HTML标签 页面中最大的标签，我们成为根标签 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; 文档的头部 注意在head标签中我们必须要设置的标签是title \u0026lt;titile\u0026gt;\u0026lt;/title\u0026gt; 文档的标题 让页面拥有一个属于自己的网页标题 \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 文档的主体 元素包含文档的所有内容，页面内容 基本都是放到body里面的 1、文档声明头 任何一个标准的HTML页面，第一行一定是一个以\u0026lt;!DOCTYPE ……\u0026gt;开头的语句。这一行，就是文档声明头，即 DocType Declaration，简称DTD。\nDTD可告知浏览器文档使用哪种 HTML 或 XHTML 规范。\nHTML4.01有哪些规范呢？ HTML4.01这个版本是IE6开始兼容的。HTML5是IE9开始兼容的。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。\n说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。\nHTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下图）。\nHTML4.01里面规定了普通和XHTML两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？\u0026lt;H1\u0026gt;\u0026lt;/H1\u0026gt;所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。\n总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况：\nXHTML\n1 2 3 4 5 6 7 8 9 \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html;charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了。HTML5的DTD（文档声明头）如下：\n1 \u0026lt;!DOCTYPE html\u0026gt; 2、页面语言 lang 下面这行标签，用于指定页面的语言类型：\n1 \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 最常见的语言类型有两种：\nen：定义页面语言为英语。\nzh-CN：定义页面语言为中文。\n3、头标签 head html5 的比较完整的骨架： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html;charset=UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;Author\u0026#34; content=\u0026#34;\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;Keywords\u0026#34; content=\u0026#34;厉害很厉害\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;Description\u0026#34; content=\u0026#34;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 头标签内部的常见标签如下：\n\u0026lt;title\u0026gt;：指定整个网页的标题，在浏览器最上方显示。 \u0026lt;base\u0026gt;：为页面上的所有链接规定默认地址或默认目标。 \u0026lt;meta\u0026gt;：提供有关页面的基本信息 \u0026lt;body\u0026gt;：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。 \u0026lt;link\u0026gt;：定义文档与外部资源的关系。 面试题：\n问：网页的head标签里面，表示的是页面的配置，有什么配置？ 答：字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等。 meta 标签：\nmeta表示“元”。“元”配置，就是表示基本的配置项目。\n常见的几种 meta 标签如下：\n（1）字符集 charset：\n1 \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html;charset=UTF-8\u0026#34;\u0026gt; charset就是character set（即“字符集”），即网页的编码方式。 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk、gb2312等。\n（2）视口 viewport：\n1 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; width=device-width ：表示视口宽度等于屏幕宽度。\n（3）定义“关键词”：\n1 \u0026lt;meta name=\u0026#34;Keywords\u0026#34; content=\u0026#34;网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信\u0026#34; /\u0026gt; 这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。\n（4）定义“页面描述”：\nmeta除了可以设置字符集，还可以设置关键字和页面描述。\n设置Description页面描述，用于SEO（search engine optimization，搜索引擎优化）。\n设置页面描述的举例：\n1 \u0026lt;meta name=\u0026#34;Description\u0026#34; content=\u0026#34;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\u0026#34; /\u0026gt; 效果如下：\n3秒之后，自动跳转到百度页面\n1 \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;3;http://www.baidu.com\u0026#34;\u0026gt; title 标签: 用于设置网页标题：\n1 \u0026lt;title\u0026gt;网页的标题\u0026lt;/title\u0026gt; title标签也是有助于SEO搜索引擎优化的。\nbase标签：\n1 \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; base 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。\n4、\u0026lt;body\u0026gt;标签 \u0026lt;body\u0026gt;标签的属性有：\nbgcolor：设置整个网页的背景颜色。 background：设置整个网页的背景图片。 text：设置网页中的文本颜色。 leftmargin：网页的左边距。IE浏览器默认是8个像素。 topmargin：网页的上边距。 rightmargin：网页的右边距。 bottommargin：网页的下边距。 \u0026lt;body\u0026gt;标签另外还有一些属性，这里用个例子来解释：\n上方代码中，当我们对点我点我这几个字使用超链时，link属性表示默认显示的颜色、alink属性表示鼠标点击但是还没有松开时的颜色、vlink属性表示点击完成之后显示的颜色。效果如下：\nHTML的规范 HTML不区分大小写，但HTML的标签名、类名、标签属性、大部分属性值建议统一用小写。 HTML页面的后缀名是html或者htm(有一些系统不支持后缀名长度超过3个字符，比如dos系统) 1、编写XHTML的规范： （1）所有标记元素都要正确的嵌套，不能交叉嵌套。正确写法举例：\u0026lt;h1\u0026gt;\u0026lt;font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/h1\u0026gt;\n（2）所有的标记都必须小写。\n（3）所有的标签都必须闭合。\n双标签：\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\n单标签：\u0026lt;br\u0026gt; 建议写成 \u0026lt;br /\u0026gt; \u0026lt;hr\u0026gt; 建议转成 \u0026lt;hr /\u0026gt;，还有\u0026lt;img src=“URL” /\u0026gt;\n（4）所有的属性值必须加引号。\u0026lt;font color=\u0026quot;red\u0026quot;\u0026gt;\u0026lt;/font\u0026gt;\n（5）所有的属性必须有值。\u0026lt;hr noshade=\u0026quot;noshade\u0026quot;\u0026gt;、\u0026lt;input type=\u0026quot;radio\u0026quot; checked=\u0026quot;checked\u0026quot; /\u0026gt;\n（6）XHTML文档开头必须要有DTD文档类型定义。\n2、HTML的基本语法特性 （1）HTML对换行不敏感，对tab不敏感 如下图所示：\n（2）空白折叠现象 HTML中所有的文字之间，如果有空格、换行、tab都将被折叠为一个空格显示。 （3）标签要严格封闭 标签不封闭的结果是灾难性的。\n计算机编码介绍 计算机，不能直接存储文字，存储的是编码。\n计算机只能处理二进制的数据，其它数据，比如：0-9、a-z、A-Z，这些字符，我们可以定义一套规则来表示。假如：A用110表示，B用111表示等。\nASCII码： 美国发布的，用1个字节(8位二进制)来表示一个字符，共可以表示2^8=256个字符。 美国的国家语言是英语，只要能表示0-9、a-z、A-Z、特殊符号。\nANSI编码： 每个国家为了显示本国的语言，都对ASCII码进行了扩展。用2个字节(16位二进制)来表示一个汉字，共可以表示2^16＝65536个汉字。例如： 中国的ANSI编码是GB2312编码(简体)，对6763汉字进行编码，含600多特殊字符。另外还有GBK(简体)。 日本的ANSI编码是JIS编码。 台湾的ANSI编码是BIG5编码（繁体）。\nGBK： 对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了2.1万左右。并提供了1890个汉字码位。K的含义就是“扩展”。\nUnicode编码(统一编码)： 用4个字节(32位二进制)来表示一个字符，想法不错，但效率太低。例如，字母A用ASCII表示的话一个字节就够，可用Unicode编码的话，得用4个字节表示，造成了空间的极大浪费。A的Unicode编码是0000 0000 0000 0000 0000 0000 0100 0000\nUTF-8(Unicode Transform Format)编码： 根据字符的不同，选择其编码的长度。比如：一个字符A用1个字节表示，一个汉字用2个字节表示。\n毫无疑问，开发中，都用UTF-8编码吧，准没错。\n中文能够使用的字符集两种：\n第一种：UTF-8。UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、鸟语……\n第二种：GBK（对GB2312进行了扩展）。gb2312 是国标，是中国的字库，里面仅涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。\n字库规模： UTF-8（字很全） \u0026gt; gb2312（只有汉字）\n重点1：避免乱码\n我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型一样，否则乱码（重点）。\n拿 sublime编辑器举例，当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： 文件→ set File Encoding to → Chinese Simplified(GBK)。VS Code 的道理一样。\n重点2：UTF-8和gb2312的比较\n保存大小：UTF-8（更臃肿、加载更慢） \u0026gt; gb2312 （更小巧，加载更快）\n总结：\nUTF-8：字多，有各种国家的语言，但是保存尺寸大，文件臃肿； gb2312：字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。 列出2个使用情形：\n1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。 2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。\n我们亲测：\nqq网、网易、搜狐都是使用gb2312。这些公司，都追求显示速度。 新华网藏语频道，使用的是UTF-8，保证字符集的数量。 我们是怎么查看网页的编码方式的呢？在浏览器中打开网页，右键，选择“查看网页源代码”，找到meta标签中的charset属性即可。\n那么，我们为什么可以查看网页的源代码呢？因为这个打开的html网页已经存到我的临时文件夹里了，临时文件夹里的html是纯文本文件，纯文本文件自然可以查看网页的源代码。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/01-html/03-%E5%88%9D%E8%AF%86html/","summary":"HTML的概述 HTML的概念 HTML 全称为 HyperText Markup Language，译为超文本标记语言。 HTML 不是一种编程语言，是一种描述性的标记语言。 作用：HTML是负","title":"初识HTML"},{"content":"1、TypeScript + Vue 泛型，interface和type有什么区别 交叉类型(\u0026amp;)与联合类型(|) 、可索引类型（数组） 类型申明文件与配置文件配置（最基础但最难理解） 2、前端工程化 webpack / vit\n3、node\n4、react\n5、git\n6、Serverless、微前端仍会稳步发展，未来将会大规模落地\n2022 python、Devops Serverless即“无服务器”架构，他试图帮助开发者摆脱运行后端应用程序所需的服务器设备的设置和管理工作，它由第三方云计算供应商负责后端基础结构的维护，同时以服务的方式为开发者提供所需的功能，例如数据库、消息、身份验证等。目前腾讯云、阿里云、aws等都在发力Serverless，一部分公司也开始将Serverless实施落地，让前端开发更加注重业务逻辑的开发。\n微前端的概念类似于微服务，它将前端应用拆分成一个个更小的更简单的能够独立开发、测试、部署的小块，在用户看来它依旧是一个独立的产品。前端业务在发展到一定规模后，需要一种能将业务化繁为简的架构。常用的微前端解决方案有single-spa、qiankun以及阿里的icestark\n2023 AR、VR、3D建模、IoT、5G\n5G应用的普及，新的交互方式、图形化内容的需求增加。\n5G应用已逐步走入大众生活，每一G的变化都会给整个社会带来翻天覆地的变化，同样，5G的大面积应用，也会给前端开发带来新的机遇与挑战。5G高速低延时的特性将实现传统的单页面的秒开，人们开始追求新的动画效果以及新的交互方式，前端页面将实现更酷炫的动画效果，同时AR、VR、3D建模等场景将重新崛起，图形内容的展示将更加丰富，未来将会有一部分前端工程师将会投入到专门开发动画场景、3D场景的工作中去，这就要求前端工程师要具备更高的图形化开发能力。\n","permalink":"https://bablvsj.github.io/posts/thinks/20210701-half/","summary":"1、TypeScript + Vue 泛型，interface和type有什么区别 交叉类型(\u0026amp;)与联合类型(|) 、可索引类型（数组） 类型申明文","title":"2021年中"},{"content":"1、《百年孤独》 无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。\n2、《被讨厌的勇气》 我们终其一生就是要摆脱他人的期待，找到真正的自己；\n经历本身不会决定什么，我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活。。。\n3、《社会契约论》 人生而自由，却又时时处在枷锁之中。自认为主宰一切，反而更像是一切的奴隶；\n人们能够争取自由，却永远无法恢复自由。\n4、《论人类不平等的起源和基础》 教育不仅使受教育的人之间产生差异，而且也使那些受教育的人在文化成熟方面产生差异。要知道：当巨人与矮子同时行走在一条道路上时，他们每多走一步，巨人相对矮子的优势就越大。\n5、《那不勒斯四部曲》 我的整个生命，只是一场为了提升社会地位的低俗斗争；\n假如一个人想一直做庶民，那他的孩子、孙子，都会命若草芥，不值一提。\n6、《活出生命的意义》 人所拥有的任何东西，都可以被剥夺，唯独人性最后的自由，——也就是在任何境遇中选择一己态度和生活方式的自由——不能被剥夺。\n7、《财富自由》 财富不是你快乐的理由，学会从通往财富的旅途中收获幸福才是。等到哪一天，消费再也无法控制你，你成了生活的主人时，生活自此也就充满了喜悦。\n伟大的博弈\n宏观经济学原理 微观经济学原理 货币银行学\n稳定不稳定经济\n明斯基时刻\n商：《低风险创业》 心：《空谷幽兰》 文：《你永远无法叫醒一个装睡的人》 ","permalink":"https://bablvsj.github.io/posts/thinks/20210501-book/","summary":"1、《百年孤独》 无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底","title":"一些闲书"},{"content":"JavaScript JavaScript的组成\nJavaScript 由以下三部分组成： ECMAScript（核心）：JavaScript 语言基础 DOM（文档对象模型）：规定了访问HTML和XML的接口 BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法 JS的基本数据类型和引用数据类型\n基本数据类型：undefined、null、boolean、number、string、symbol 引用数据类型：object、array、function 检测浏览器版本版本有哪些方式？\n根据 navigator.userAgent // UA.toLowerCase().indexOf(\u0026lsquo;chrome\u0026rsquo;) 根据 window 对象的成员 // \u0026lsquo;ActiveXObject\u0026rsquo; in window 介绍JS有哪些内置对象？\n数据封装类对象：Object、Array、Boolean、Number、String 其他对象：Function、Arguments、Math、Date、RegExp、Error ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect 说几条写JavaScript的基本规范？\n代码缩进，建议使用“四个空格”缩进 代码段使用花括号{}包裹 语句结束使用分号; 变量和函数在使用前进行声明 以大写字母开头命名构造函数，全大写命名常量 规范定义JSON对象，补全双引号 用{}和[]声明对象和数组 如何编写高性能的JavaScript？\n遵循严格模式：\u0026ldquo;use strict\u0026rdquo;; 将js脚本放在页面底部，加快渲染页面 将js脚本将脚本成组打包，减少请求 使用非阻塞方式下载js脚本 尽量使用局部变量来保存全局变量 尽量减少使用闭包 使用 window 对象属性方法时，省略 window 尽量减少对象成员嵌套 缓存 DOM 节点的访问 通过避免使用 eval() 和 Function() 构造器 给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数 尽量使用直接量创建对象和数组 最小化重绘(repaint)和回流(reflow) 描述浏览器的渲染过程，DOM树和渲染树的区别？\n浏览器的渲染过程：\n解析HTML构建 DOM(DOM树)，并行请求 css/image/js CSS 文件下载完成，开始构建 CSSOM(CSS树) CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树) 布局(Layout)：计算出每个节点在屏幕中的位置 显示(Painting)：通过显卡把页面画到屏幕上 DOM树 和 渲染树 的区别：\nDOM树与HTML标签一一对应，包括head和隐藏元素 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性 重绘和回流（重排）的区别和关系？\n重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流 注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值 回流必将引起重绘，而重绘不一定会引起回流 如何最小化重绘(repaint)和回流(reflow)？\n需要要对元素进行复杂的操作时，可以先隐藏(display:\u0026ldquo;none\u0026rdquo;)，操作完成后再显示 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document 缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流） 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面） 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx script 的位置是否会影响首屏显示时间？\n在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。 浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则 因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间 解释JavaScript中的作用域与变量声明提升？\nJavaScript作用域：\n在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域； 而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。 JavaScript变量声明提升：\n在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。 声明语句中的赋值部分并不会被提升，只有名称被提升 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数 介绍JavaScript的原型，原型链？有什么特点？\n原型：\nJavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型 JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。 原型链：\n当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找 如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链” 原型特点：\nJavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 JavaScript有几种类型的值？，你能画一下他们的内存图吗\n原始数据类型（Undefined，Null，Boolean，Number、String）\u0026ndash; 栈 引用数据类型（对象、数组和函数）\u0026ndash; 堆 两种类型的区别是：存储位置不同： 原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据； 引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 JavaScript如何实现一个类，怎么实例化这个类？\n构造函数法（this + prototype） \u0026ndash; 用 new 关键字 生成实例对象 缺点：用到了 this 和 prototype，编写复杂，可读性差 1 2 3 4 5 6 7 8 9 function Mobile(name, price){ this.name = name; this.price = price; } Mobile.prototype.sell = function(){ alert(this.name + \u0026#34;，售价 $\u0026#34; + this.price); } var iPhone7 = new Mobile(\u0026#34;iPhone7\u0026#34;, 1000); iPhone7.sell(); Object.create 法 \u0026ndash; 用 Object.create() 生成实例对象 缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var Person = { firstname: \u0026#34;Mark\u0026#34;, lastname: \u0026#34;Yun\u0026#34;, age: 25, introduce: function(){ alert(\u0026#39;I am \u0026#39; + Person.firstname + \u0026#39; \u0026#39; + Person.lastname); } }; var person = Object.create(Person); person.introduce(); // Object.create 要求 IE9+，低版本浏览器可以自行部署： if (!Object.create) { Object.create = function (o) { function F() {} F.prototype = o; return new F(); }; } 极简主义法（消除 this 和 prototype） \u0026ndash; 调用 createNew() 得到实例对象 优点：容易理解，结构清晰优雅，符合传统的\u0026quot;面向对象编程\u0026quot;的构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var Cat = { age: 3, // 共享数据 -- 定义在类对象内，createNew() 外 createNew: function () { var cat = {}; // var cat = Animal.createNew(); // 继承 Animal 类 cat.name = \u0026#34;小咪\u0026#34;; var sound = \u0026#34;喵喵喵\u0026#34;; // 私有属性--定义在 createNew() 内，输出对象外 cat.makeSound = function () { alert(sound); // 暴露私有属性 }; cat.changeAge = function(num){ Cat.age = num; // 修改共享数据 }; return cat; // 输出对象 } }; var cat = Cat.createNew(); cat.makeSound(); ES6 语法糖 class \u0026ndash; 用 new 关键字 生成实例对象 1 2 3 4 5 6 7 8 9 10 11 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; } } var point = new Point(2, 3); Javascript如何实现继承？\n构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上 1 2 3 4 5 function Cat(name,color){ Animal.apply(this, arguments); this.name = name; this.color = color; } 实例继承：将子对象的 prototype 指向父对象的一个实例 1 2 Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象 1 2 3 4 5 6 7 8 function extend(Child, Parent) { var p = Parent.prototype; var c = Child.prototype; for (var i in p) { c[i] = p[i]; } c.uber = p; } 原型继承：将子对象的 prototype 指向父对象的 prototype 1 2 3 4 5 6 7 function extend(Child, Parent) { var F = function(){}; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype; } ES6 语法糖 extends：class ColorPoint extends Point {} 1 2 3 4 5 6 7 8 9 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + \u0026#39; \u0026#39; + super.toString(); // 调用父类的toString() } } Javascript作用链域?\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链 谈谈this对象的理解\nthis 总是指向函数的直接调用者 如果有 new 关键字，this 指向 new 出来的实例对象 在事件中，this指向触发这个事件的对象 IE下 attachEvent 中的this总是指向全局对象Window eval是做什么的？\neval的功能是把对应的字符串解析成JS代码并运行\n应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行） 由JSON字符串转换为JSON对象的时候可以用 eval(\u0026rsquo;(\u0026rsquo;+ str +\u0026rsquo;)\u0026rsquo;); 什么是 Window 对象? 什么是 Document 对象?\nWindow 对象表示当前浏览器的窗口，是JavaScript的顶级对象。 我们创建的所有对象、函数、变量都是 Window 对象的成员。 Window 对象的方法和属性是在全局范围内有效的。 Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点） Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问 Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问 介绍 DOM 的发展\nDOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关 DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[\u0026rsquo;login\u0026rsquo;] DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象 DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo) DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator 介绍DOM0，DOM2，DOM3事件处理方式区别\nDOM0级事件处理方式： btn.onclick = func; btn.onclick = null; DOM2级事件处理方式： btn.addEventListener('click', func, false); btn.removeEventListener('click', func, false); btn.attachEvent(\u0026quot;onclick\u0026quot;, func); btn.detachEvent(\u0026quot;onclick\u0026quot;, func); DOM3级事件处理方式： eventUtil.addListener(input, \u0026quot;textInput\u0026quot;, func); eventUtil 是自定义对象，textInput 是DOM3级事件 事件的三个阶段\n捕获、目标、冒泡 介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？\n按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数 注意1：前提是事件被确实触发 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖” 事件执行顺序：判断的关键是否目标元素 非目标元素：根据W3C的标准执行：捕获-\u0026gt;目标元素-\u0026gt;冒泡（不依据事件绑定顺序） 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准） 最终顺序：父元素捕获-\u0026gt;目标元素事件1-\u0026gt;目标元素事件2-\u0026gt;子元素捕获-\u0026gt;子元素冒泡-\u0026gt;父元素冒泡 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\n该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数） 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 事件的代理/委托\n事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件 优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上 缺点： 使用不当会造成事件在不应该触发时触发 示例： 1 2 3 4 5 6 ulEl.addEventListener(\u0026#39;click\u0026#39;, function(e){ var target = event.target || event.srcElement; if(!!target \u0026amp;\u0026amp; target.nodeName.toUpperCase() === \u0026#34;LI\u0026#34;){ console.log(target.innerHTML); } }, false); IE与火狐的事件机制有什么区别？ 如何阻止冒泡？\nIE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获 IE的事件处理和W3C的事件处理有哪些区别？\n绑定事件\nW3C: targetEl.addEventListener(\u0026lsquo;click\u0026rsquo;, handler, false); IE: targetEl.attachEvent(\u0026lsquo;onclick\u0026rsquo;, handler); 删除事件\nW3C: targetEl.removeEventListener(\u0026lsquo;click\u0026rsquo;, handler, false); IE: targetEl.detachEvent(event, handler); 事件对象\nW3C: var e = arguments.callee.caller.arguments[0] IE: window.event 事件目标\nW3C: e.target IE: window.event.srcElement 阻止事件默认行为\nW3C: e.preventDefault() IE: window.event.returnValue = false 阻止事件传播\nW3C: e.stopPropagation() IE: window.event.cancelBubble = true W3C事件的 target 与 currentTarget 的区别？\ntarget 只会出现在事件流的目标阶段 currentTarget 可能出现在事件流的任何阶段 当事件流处在目标阶段时，二者的指向相同 当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级) 如何派发事件(dispatchEvent)？（如何进行事件广播？）\nW3C: 使用 dispatchEvent 方法 IE: 使用 fireEvent 方法 1 2 3 4 5 6 7 8 9 10 var fireEvent = function(element, event){ if (document.createEventObject){ var mockEvent = document.createEventObject(); return element.fireEvent(\u0026#39;on\u0026#39; + event, mockEvent) }else{ var mockEvent = document.createEvent(\u0026#39;HTMLEvents\u0026#39;); mockEvent.initEvent(event, true, true); return !element.dispatchEvent(mockEvent); } } 什么是函数节流？介绍一下应用场景和原理？\n函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）\n函数节流用于 onresize, onscroll 等短时间内会多次触发的事件\n函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器， 再 setTimeout 一个新的定时器重复以上流程。\n函数节流简单实现：\n1 2 3 4 5 6 7 8 9 10 function throttle(method, context) { clearTimeout(methor.tId); method.tId = setTimeout(function(){ method.call(context); }， 100); // 两次调用至少间隔 100ms } // 调用 window.onresize = function(){ throttle(myFunc, window); } 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？\n客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY) 页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY) 屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY) 如何获得一个DOM元素的绝对位置？\nelem.offsetLeft：返回元素相对于其定位父级左侧的距离 elem.offsetTop：返回元素相对于其定位父级顶部的距离 elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素 分析 [\u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;].map(parseInt) 答案是多少？\n答案:[1, NaN, NaN] parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析 map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引 因此，map 遍历 [\u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;3\u0026rdquo;]，相应 parseInt 接收参数如下 1 2 3 parseInt(\u0026#39;1\u0026#39;, 0); // 1 parseInt(\u0026#39;2\u0026#39;, 1); // NaN parseInt(\u0026#39;3\u0026#39;, 2); // NaN 所以，parseInt 参数 radix 不合法，导致返回值为 NaN new 操作符具体干了什么？\n创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 用原生JavaScript的实现过什么功能吗？\n封装选择器、调用第三方API、设置和获取样式 解释一下这段代码的意思吗？\n1 2 3 [].forEach.call($$(\u0026#34;*\u0026#34;), function(el){ el.style.outline = \u0026#34;1px solid #\u0026#34; + (~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16); }) 解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓outline 1 2 3 4 5 6 7 1. `$$(sel)` // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel) 2. `[].forEach.call(NodeLists)` // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表 3. `el.style.outline = \u0026#34;1px solid #333\u0026#34;` // 样式 outline 位于盒模型之外，不影响元素布局位置 4. `(1\u0026lt;\u0026lt;24)` // parseInt(\u0026#34;ffffff\u0026#34;, 16) == 16777215 == 2^24 - 1 // 1\u0026lt;\u0026lt;24 == 2^24 == 16777216 5. `Math.random()*(1\u0026lt;\u0026lt;24)` // 表示一个位于 0 到 16777216 之间的随机浮点数 6. `~~Math.random()*(1\u0026lt;\u0026lt;24)` // `~~` 作用相当于 parseInt 取整 7. `(~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16)` // 转换为一个十六进制- ** JavaScript实现异步编程的方法？**\n回调函数 事件监听 发布/订阅 Promises对象 Async函数[ES7] web开发中会话跟踪的方法有哪些\ncookie session url重写 隐藏input ip地址 介绍js的基本数据类型\nUndefined、Null、Boolean、Number、String 介绍js有哪些内置对象？\nObject 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 说几条写JavaScript的基本规范？\n不要在同一行声明多个变量 请使用 ===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 函数不应该有时候有返回值，有时候没有返回值 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 JavaScript原型，原型链 ? 有什么特点？\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时\n如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念\n关系：instance.constructor.prototype = instance.__proto__\n特点：\nJavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的\n就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象\nJavaScript有几种类型的值？，你能画一下他们的内存图吗？\n栈：原始数据类型（Undefined，Null，Boolean，Number、String）\n堆：引用数据类型（对象、数组和函数）\n两种类型的区别是：存储位置不同；\n原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\n在栈中的地址，取得地址后从堆中获得实体\nJavascript如何实现继承？\n构造继承\n原型继承\n实例继承\n拷贝继承\n原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 function Parent(){ this.name = \u0026#39;wang\u0026#39;; } function Child(){ this.age = 28; } Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 } javascript创建对象的几种方式？\njavascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用\n对象字面量的方式 1 person={firstname:\u0026#34;Mark\u0026#34;,lastname:\u0026#34;Yun\u0026#34;,age:25,eyecolor:\u0026#34;black\u0026#34;}; 用function来模拟无参的构造函数 1 2 3 4 5 6 7 8 function Person(){} var person=new Person();//定义一个function，如果使用new\u0026#34;实例化\u0026#34;,该function可以看作是一个Class person.name=\u0026#34;Mark\u0026#34;; person.age=\u0026#34;25\u0026#34;; person.work=function(){ alert(person.name+\u0026#34; hello...\u0026#34;); } person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 1 2 3 4 5 6 7 8 9 10 function Pet(name,age,hobby){ this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function(){ alert(\u0026#34;我叫\u0026#34;+this.name+\u0026#34;,我喜欢\u0026#34;+this.hobby+\u0026#34;,是个程序员\u0026#34;); } } var maidou =new Pet(\u0026#34;麦兜\u0026#34;,25,\u0026#34;coding\u0026#34;);//实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） 1 2 3 4 5 6 7 var wcDog =new Object(); wcDog.name=\u0026#34;旺财\u0026#34;; wcDog.age=3; wcDog.work=function(){ alert(\u0026#34;我是\u0026#34;+wcDog.name+\u0026#34;,汪汪汪......\u0026#34;); } wcDog.work(); 用原型方式来创建 1 2 3 4 5 6 7 8 9 function Dog(){ } Dog.prototype.name=\u0026#34;旺财\u0026#34;; Dog.prototype.eat=function(){ alert(this.name+\u0026#34;是个吃货\u0026#34;); } var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建 1 2 3 4 5 6 7 8 9 function Car(name,price){ this.name=name; this.price=price; } Car.prototype.sell=function(){ alert(\u0026#34;我是\u0026#34;+this.name+\u0026#34;，我现在卖\u0026#34;+this.price+\u0026#34;万元\u0026#34;); } var camry =new Car(\u0026#34;凯美瑞\u0026#34;,27); camry.sell(); Javascript作用链域?\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找 直至全局函数，这种组织形式就是作用域链 谈谈This对象的理解\nthis总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window eval是做什么的？\n它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(\u0026rsquo;(\u0026rsquo;+ str +\u0026rsquo;)\u0026rsquo;) null，undefined 的区别？\nundefined 表示不存在这个值。\nundefined :是一个表示\u0026quot;无\u0026quot;的原始值或者说表示\u0026quot;缺少值\u0026quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined\n例如变量被声明了，但没有赋值时，就等于undefined\nnull 表示一个对象被定义了，值为“空值”\nnull : 是一个对象(空对象, 没有任何属性和方法)\n例如作为函数的参数，表示该函数的参数不是对象；\n在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined\n写一个通用的事件侦听器函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // event(事件)工具集，来源：github.com/markyun markyun.Event = { // 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != \u0026#39;function\u0026#39;) { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); }; } }, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(\u0026#39;on\u0026#39; + type, function() { handler.call(element); }); } else { element[\u0026#39;on\u0026#39; + type] = handler; } }, // 移除事件 removeEvent : function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.datachEvent) { element.detachEvent(\u0026#39;on\u0026#39; + type, handler); } else { element[\u0026#39;on\u0026#39; + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; } }, // 取消事件的默认行为 preventDefault : function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev \u0026amp;\u0026amp; Event == ev.constructor) { break; } c = c.caller; } } return ev; } }; [\u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;3\u0026rdquo;].map(parseInt) 答案是多少？\n[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。 map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？\n我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件 ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 什么是闭包（closure），为什么要用它？\n闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\n闭包的特性：\n函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 javascript 代码中的\u0026quot;use strict\u0026quot;;是什么意思 ? 使用它区别是什么？\nuse strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 如何判断一个对象是否属于某个类？\n1 2 3 4 // 使用instanceof （待完善） if(a instanceof Person){ alert(\u0026#39;yes\u0026#39;); } new操作符具体干了什么呢?\n创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 1 2 3 var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); js延迟加载的方式有哪些？\ndefer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax 是什么? 如何创建一个Ajax？\najax的全称：Asynchronous Javascript And XML\n异步传输+js+xml\n所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验\n创建XMLHttpRequest对象,也就是创建一个异步调用对象\n建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n设置响应HTTP请求状态变化的函数\n发送HTTP请求\n获取异步调用返回的数据\n用JavaScript和DOM实现局部刷新\n同步和异步的区别?\n同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 异步加载JS的方式有哪些？\ndefer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack documen.write和 innerHTML的区别\ndocument.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点?\n（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 那些操作会造成内存泄漏？\n内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 渐进增强和优雅降级\n渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容\nJavascript垃圾回收方法\n标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting)\n在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间\njs继承方式及其优缺点\n原型链继承的缺点\n一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承）\n借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承\n组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 defer和async\ndefer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 用过哪些设计模式？\n工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例 1 2 3 4 5 6 7 8 9 10 function createObject(name,age,profession){//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () { return this.name + \u0026#39; at \u0026#39; + this.age + \u0026#39; engaged in \u0026#39; + this.profession; }; return obj; } var test1 = createObject(\u0026#39;trigkit4\u0026#39;,22,\u0026#39;programmer\u0026#39;);//第一个实例var test2 = createObject(\u0026#39;mike\u0026#39;,25,\u0026#39;engineer\u0026#39;);//第二个实例 构造函数模式\n使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 构造函数方法没有显示的创建对象 (new Object());\n直接将属性和方法赋值给 this 对象;\n没有 renturn 语句\n说说你对闭包的理解\n使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念\n闭包有三个特性：\n1.函数嵌套函数\n2.函数内部可以引用外部的参数和变量\n3.参数和变量不会被垃圾回收机制回收\n请解释一下 JavaScript 的同源策略\n概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 指一段脚本只能读取来自同一来源的窗口和文档的属性 为什么要有同源限制？\n我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点 现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制\n1 2 3 4 5 6 7 8 9 10 11 12 13 Object.prototype.clone = function(){ var o = this.constructor === Array ? [] : {}; for(var e in this){ o[e] = typeof this[e] === \u0026#34;object\u0026#34; ? this[e].clone() : this[e]; } return o; } 说说严格模式的限制\n严格模式主要有以下限制：\n变量必须声明后再使用\n函数的参数不能有同名属性，否则报错\n不能使用with语句\n不能对只读属性赋值，否则报错\n不能使用前缀0表示八进制数，否则报错\n不能删除不可删除的属性，否则报错\n不能删除变量delete prop，会报错，只能删除属性delete global[prop]\neval不会在它的外层作用域引入变量\neval和arguments不能被重新赋值\narguments不会自动反映函数参数的变化\n不能使用arguments.callee\n不能使用arguments.caller\n禁止this指向全局对象\n不能使用fn.caller和fn.arguments获取函数调用的堆栈\n增加了保留字（比如protected、static和interface）\n如何删除一个cookie\n将时间设为当前时间往前一点 1 2 3 var date = new Date(); date.setDate(date.getDate() - 1);//真正的删除 setDate()方法用于设置一个月的某一天\nexpires的设置 1 document.cookie = \u0026#39;user=\u0026#39;+ encodeURIComponent(\u0026#39;name\u0026#39;) + \u0026#39;;expires = \u0026#39; + new Date(0) 编写一个方法 求一个字符串的字节长度\n假设：一个英文字符占用一个字节，一个中文字符占用两个字节 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function GetBytes(str){ var len = str.length; var bytes = len; for(var i=0; i\u0026lt;len; i++){ if (str.charCodeAt(i) \u0026gt; 255) bytes++; } return bytes; } alert(GetBytes(\u0026#34;你好,as\u0026#34;)); 请解释什么是事件代理\n事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能 attribute和property的区别是什么？\nattribute是dom元素在文档中作为html标签拥有的属性；\nproperty就是dom元素在js中作为对象拥有的属性。\n对于html的标准属性来说，attribute和property是同步的，是会自动更新的\n但是对于自定义的属性来说，他们是不同步的\n页面编码和被请求的资源编码如果不一致如何处理？\n后端响应头设置 charset 前端页面\u0026lt;meta\u0026gt;设置 charset 把\u0026lt;script\u0026gt;放在\u0026lt;/body\u0026gt;之前和之后有什么区别？浏览器会如何解析它们？\n按照HTML标准，在\u0026lt;/body\u0026gt;结束后出现\u0026lt;script\u0026gt;或任何元素的开始标签，都是解析错误 虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在\u0026lt;/body\u0026gt;之前没有区别 浏览器的容错机制会忽略script之前的\u0026lt;/body\u0026gt;，视作\u0026lt;script\u0026gt;仍在 body 体内。省略\u0026lt;/body\u0026gt;和\u0026lt;/html\u0026gt;闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容 延迟加载JS的方式有哪些？\n设置\u0026lt;script\u0026gt;属性 defer=\u0026ldquo;defer\u0026rdquo; （脚本将在页面完成解析时执行） 动态创建 script DOM：document.createElement(\u0026lsquo;script\u0026rsquo;); XmlHttpRequest 脚本注入 延迟加载工具 LazyLoad 异步加载JS的方式有哪些？\n设置\u0026lt;script\u0026gt;属性 async=\u0026ldquo;async\u0026rdquo; （一旦脚本可用，则会异步执行） 动态创建 script DOM：document.createElement(\u0026lsquo;script\u0026rsquo;); XmlHttpRequest 脚本注入 异步加载库 LABjs 模块加载器 Sea.js JavaScript 中，调用函数有哪几种方式？\n方法调用模式 Foo.foo(arg1, arg2); 函数调用模式 foo(arg1, arg2); 构造器调用模式 (new Foo())(arg1, arg2); call/applay调用模式 Foo.foo.call(that, arg1, arg2); bind调用模式 Foo.foo.bind(that)(arg1, arg2)(); 简单实现 Function.bind 函数？\n1 2 3 4 5 6 7 8 9 10 11 12 13 if (!Function.prototype.bind) { Function.prototype.bind = function(that) { var func = this, args = arguments; return function() { return func.apply(that, Array.prototype.slice.call(args, 1)); } } } // 只支持 bind 阶段的默认参数： func.bind(that, arg1, arg2)(); // 不支持以下调用阶段传入的参数： func.bind(that)(arg1, arg2); ** 列举一下JavaScript数组和对象有哪些原生方法 **\n数组：\narr.concat(arr1, arr2, arrn); arr.join(\u0026quot;,\u0026quot;); arr.sort(func); arr.pop(); arr.push(e1, e2, en); arr.shift(); unshift(e1, e2, en); arr.reverse(); arr.slice(start, end); arr.splice(index, count, e1, e2, en); arr.indexOf(el); arr.includes(el); // ES6 对象：\nobject.hasOwnProperty(prop); object.propertyIsEnumerable(prop); object.valueOf(); object.toString(); object.toLocaleString(); Class.prototype.isPropertyOf(object); Array.splice() 与 Array.splice() 的区别？\nslice \u0026ndash; “读取”数组指定的元素，不会对原数组进行修改\n语法：arr.slice(start, end) start 指定选取开始位置（含） end 指定选取结束位置（不含） splice\n“操作”数组指定的元素，会修改原数组，返回被删除的元素 语法：arr.splice(index, count, [insert Elements]) index 是操作的起始位置 count = 0 插入元素，count \u0026gt; 0 删除元素 [insert Elements] 向数组新插入的元素 JavaScript 对象生命周期的理解？\n当创建一个对象时，JavaScript 会自动为该对象分配适当的内存 垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量 如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收 哪些操作会造成内存泄漏？\nJavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收\n未使用 var 声明的全局变量\n闭包函数(Closures)\n循环引用(两个对象相互引用)\n控制台日志(console.log)\n移除存在绑定事件的DOM元素(IE)\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/javascript/","summary":"JavaScript JavaScript的组成 JavaScript 由以下三部分组成： ECMAScript（核心）：JavaScript 语言基础 DOM（文档对象模型）：规定了访问","title":"JavaScript"},{"content":"手写事件侦听器，并要求兼容浏览器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 var eventUtil = { getEvent: function(event) { return event || window.event; }, getTarget: function(event) { return event.target || event.srcElement; }, addListener: function(element, type, hander) { if (element.addEventListener) { element.addEventListener(type, hander, false); } else if (element.attachEvent) { element.attachEvent(\u0026#39;on\u0026#39; + type, hander); } else { element[\u0026#39;on\u0026#39; + type] = hander; } }, removeListener: function(element, type, hander) { if (element.removeEventListener) { element.removeEventListener(type, hander, false); } else if (element.deattachEvent) { element.detachEvent(type, hander); } else { element[\u0026#39;on\u0026#39; + type] = null; } }, preventDefault: function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, stopPropagation: function(event) { if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } } }; // 调用 (function() { var btn = document.getElementById(\u0026#34;btn\u0026#34;); var link = document.getElementsByTagName(\u0026#34;a\u0026#34;)[0]; eventUtil.addListener(btn, \u0026#34;click\u0026#34;, function(event) { var event = eventUtil.getEvent(event); var target = eventUtil.getTarget(event); alert(event.type); alert(target); eventUtil.stopPropagation(event); }); eventUtil.addListener(link, \u0026#34;click\u0026#34;, function(event) { alert(\u0026#34;prevent default event\u0026#34;); var event = eventUtil.getEvent(event); eventUtil.preventDefault(event); }); eventUtil.addListener(document.body, \u0026#34;click\u0026#34;, function() { alert(\u0026#34;click body\u0026#34;); }); })(); 手写事件模型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 var Event = (function () { var list = {}, bind, trigger, remove; bind = function (key, fn) { if (!list[key]) { list[key] = []; } list[key].push(fn); }; trigger = function () { var key = Array.prototype.shift.call(arguments); var fns = list[key]; if (!fns || fns.length === 0) { return false; } for (var i = 0, fn; fn = fns[i++];) { fn.apply(this, arguments); } }; remove = function (key, fn) { var fns = list[key]; if (!fns) { return false; } if (!fn) { fns \u0026amp; (fns.length = 0); } else { for (var i = fns.length - 1; i \u0026gt;= 0; i--) { var _fn = fns[i]; if (_fn === fn) { fns.splice(i, 1); } } } }; return { bind: bind, trigger: trigger, remove: remove } })(); // 调用 Event.bind(\u0026#39;Hit\u0026#39;, function(){ console.log(\u0026#39;bind event\u0026#39;); }); // 绑定事件 Event.trigger(\u0026#34;Hit\u0026#34;, function(){ console.log(\u0026#39;trigger event\u0026#39;); }); // 触发事件 手写事件代理，并要求兼容浏览器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function delegateEvent(parentEl, selector, type, fn) { var handler = function(e){ var e = e || window.event; var target = e.target || e.srcElement; if (matchSelector(target, selector)) { if(fn) { fn.call(target, e); } } }; if(parentEl.addEventListener){ parentEl.addEventListener(type, handler); }else{ parentEl.attachEvent(\u0026#34;on\u0026#34; + type, handler); } } /** * support #id, tagName, .className */ function matchSelector(ele, selector) { // if use id if (selector.charAt(0) === \u0026#34;#\u0026#34;) { return ele.id === selector.slice(1); } // if use class if (selector.charAt(0) === \u0026#34;.\u0026#34;) { return (\u0026#34; \u0026#34; + ele.className + \u0026#34; \u0026#34;).indexOf(\u0026#34; \u0026#34; + selector.slice(1) + \u0026#34; \u0026#34;) != -1; } // if use tagName return ele.tagName.toLowerCase() === selector.toLowerCase(); } // 调用 var box = document.getElementById(\u0026#34;box\u0026#34;); delegateEvent(box, \u0026#34;a\u0026#34;, \u0026#34;click\u0026#34;, function(){ console.log(this.href); }) 手写事件触发器，并要求兼容浏览器\n1 2 3 4 5 6 7 8 9 10 var fireEvent = function(element, event){ if (document.createEventObject){ var mockEvent = document.createEventObject(); return element.fireEvent(\u0026#39;on\u0026#39; + event, mockEvent) }else{ var mockEvent = document.createEvent(\u0026#39;HTMLEvents\u0026#39;); mockEvent.initEvent(event, true, true); return element.dispatchEvent(mockEvent); } } 手写 Function.bind 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { if (typeof this !== \u0026#34;function\u0026#34;) { throw new TypeError(\u0026#34;\u0026#39;this\u0026#39; is not function\u0026#34;); } // bind\u0026#39;s default arguments, array without first element // first part arguments for the function var aBindArgs = Array.prototype.slice.call(arguments, 1); var fToBind = this; // the function will be binding var fNOP = function () {}; var fBound = function () { // target this will be binding var oThis = this instanceof fNOP ? this : oThis || this; // last part arguments for the function var aCallArgs = Array.prototype.slice.call(arguments); // complete arguments for the function var aFuncArgs = aBindArgs.concat(aCallArgs); return fToBind.apply(oThis, aFuncArgs); }; // fBound extends fToBind fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; }; } // 调用 var add = function(a, b, c){ return a + b + c;}; var newAdd = add.bind(null, 1, 2); var result = newAdd(3); 手写数组快速排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var quickSort = function(arr) { if (arr.length \u0026lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0, len = arr.length; i \u0026lt; len; i++){ if (arr[i] \u0026lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return quickSort(left).concat([pivot], quickSort(right)); }; // 调用 quickSort([9, 4, 2, 8, 1, 5, 3, 7]); 手写数组冒泡排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var bubble = function(arr){ var maxIndex = arr.length - 1, temp, flag; for (var i = maxIndex; i \u0026gt; 0; i--) { flag = true for (var j = 0; j \u0026lt; i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; } } if(! flag){ break; } } return arr; } // 调用 var arr = bubble([13, 69, 28, 93, 55, 75, 34]); 手写数组去重\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 Array.prototype.unique = function() { return [...new Set(this)];}; // 调用 [1, 2, 3, 3, 2, 1].unique(); function unique1(arr){ var hash = {}, result = []; for(var i=0, len=arr.length; i\u0026lt;len; i++){ if(! hash[arr[i]]){ result.push(arr[i]); hash[arr[i]] = true; } } return result; } // 调用 unique1([1, 2, 3, 3, 2, 1]); Array.prototype.unique2 = function(){ this.sort(); var result = [this[0]]; var len = this.length; for(var i = 0; i \u0026lt; len; i++){ if(this[i] !== result[result.length - 1]){ result.push(this[i]); } } return result; } // 调用 [1, 2, 3, 3, 2, 1].unique2(); function unique3(arr){ var result = []; for(var i=0; i\u0026lt;arr.length; i++){ if(result.indexOf(arr[i]) == -1){ result.push(arr[i]); } } return result; } // 调用 unique3([1, 2, 3, 3, 2, 1]); 将url的查询参数解析成字典对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 function parseQuery(url) { url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(\u0026#34;?\u0026#34;) + 1); var hash = {}; var reg = /([^?\u0026amp;=]+)=([^?\u0026amp;=]*)/g; search.replace(reg, function (match, $1, $2) { var name = decodeURIComponent($1); var val = decodeURIComponent($2); hash[name] = String(val); return match; }); return hash; } 封装函数节流函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var throttle = function(fn, delay, mustRunDelay){ var timer = null; var t_start; return function(){ var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start){ t_start = t_curr; } if(t_curr - t_start \u0026gt;= mustRunDelay){ fn.apply(context, args); t_start = t_curr; } else { timer = setTimeout(function(){ fn.apply(context, args); }, delay); } }; }; // 调用（两次间隔50ms内连续触发不执行，但每累计100ms至少执行一次 window.onresize = throttle(myFunc, 50, 100); 用JS实现千位分隔符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function test1(num){ var str = (+ num) + \u0026#39;\u0026#39;; var len = str.length; if(len \u0026lt;= 3) return str; num = \u0026#39;\u0026#39;; while(len \u0026gt; 3){ len -= 3; num = \u0026#39;,\u0026#39; + str.substr(len, 3) + num; } return str.substr(0, len) + num; } function test2(num){ // ?= 正向匹配:匹配位置 // ?! 正向不匹配:排除位置 var str = (+num).toString(); var reg = /(?=(?!\\b)(\\d{3})+$)/g; return str.replace(reg, \u0026#39;,\u0026#39;); } ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/202308-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/","summary":"手写事件侦听器，并要求兼容浏览器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54","title":"手写代码"},{"content":"egg-sequelize 连接多个数据库如何配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 config.sequelize = { datasources: [ { delegate: \u0026#39;model\u0026#39;, // 加载所有的模型到 app.model and ctx.model baseDir: \u0026#39;model\u0026#39;, // 要加载的模型目录`app/model/*.js` dialect: \u0026#39;mysql\u0026#39;, host: \u0026#39;10.52.18.8\u0026#39;, port: 3306, username: \u0026#39;root\u0026#39;, // 用户名 password: \u0026#39;root\u0026#39;, // 用户密码 database: \u0026#39;crt_crland_screen\u0026#39;, // 数据库名 dateStrings: true, // 解决时间格式 pool: { max: 20, min: 0, idle: 10000, }, }, { delegate: \u0026#39;appModel\u0026#39;, // 加载所有的模型到 app.logModel and ctx.logModel baseDir: \u0026#39;model_app\u0026#39;, // 要加载的模型目录 `app/model_log/*.js` // local dialect: \u0026#39;mysql\u0026#39;, host: \u0026#39;10.52.18.8\u0026#39;, port: 3306, username: \u0026#39;root\u0026#39;, // 用户名 password: \u0026#39;root\u0026#39;, // 用户密码 database: \u0026#39;hotel_report\u0026#39;, // 数据库名 dateStrings: true, // 解决时间格式 pool: { max: 20, min: 0, idle: 10000, }, }, ], }; 注意事项：\n很多人担心 controller 、service 、 model 需要怎么编写\ncontroller \\ service 正常编写\nmodel 需要注意 后续添加的数据库指定了baseDir（新的model 目录）\n配置的delegate 属性 ==\u0026gt; app.appModel / ctx.appModel （连接表 / 服务时记得把model 换成配置的 delegate ）\n​\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/egg.js/","summary":"egg-sequelize 连接多个数据库如何配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 config.sequelize = { datasources: [ { delegate: \u0026#39;model\u0026#39;, // 加载所有的模型到 app.model and ctx.model baseDir:","title":"egg.js"},{"content":"前言 一面要讲的内容：\nHTTP协议的主要特点\nHTTP报文的组成部分\nHTTP方法\nget 和 post的区别\nHTTP状态码\n什么是持久连接\n什么是管线化\n二面要讲的内容；\n缓存\nCSRF攻击\nHTTP协议的主要特点 简单快速：每个资源（比如图片、页面）都通过 url 来定位，想访问什么资源，直接输入url即可。\n灵活 : http协议的头部有一个数据类型，通过http协议，就可以完成不同数据类型的传输。\n无连接 : 连接一次，就会断开，不会继续保持连接。\n无状态 :\n客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。\n有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。\nHTTP报文的组成部分 在回答此问题时，我们要按照顺序回答：\n先回答的是，http报文包括：请求报文和响应报文。\n再回答的是，每个报文包含什么部分。\n最后回答，每个部分的内容是什么\n请求报文包括： 请求行：包括请求方法、请求的url、http协议及版本。 请求头：一大堆的键值对。 空行指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。 请求体：数据部分。 响应报文包括： 状态行：http协议及版本、状态码及状态描述。 响应头 空行 响应体 HTTP方法 包括：\nGET：获取资源 POST：传输资源 PUT：更新资源 DELETE：删除资源 HEAD：获得报文首部 HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。 get 和 post 比较常见。 put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。\nget 和 post的区别 get是相对不隐私的，而post是相对隐私的。\n1、浏览器在回退时，get不会重新请求，但是post会重新请求。【重要】 2、get请求会被浏览器主动缓存，而post不会。【重要】 3、get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。 4、get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有限制。 5、get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。\nhttp状态码 206的应用：range指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。\n301：重定向（永久）。\n302：重定向（临时）。\n304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。\n401 请求未授权\n403 请求被拒绝\n404 请求资源不存在\n500 服务器错误\n503 请求未完成，服务器宕机/过载\n持久链接/http长连接 轮询：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。\n长连接：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。\n注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/04-http%E5%8D%8F%E8%AE%AE/","summary":"前言 一面要讲的内容： HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的区别 HTTP状态码 什么是持久连接 什么是管线化 二面要","title":"HTTP协议"},{"content":"JS的异步和单线程 题目一：异步 现有如下代码：\n1 2 3 4 5 6 7 console.log(1); setTimeout(function () { console.log(2); }, 1000); console.log(3); console.log(4); // 我们很容易知道，打印的顺序是`1，3，4，2` 可如果我把延时的时间从1000改成0：\n1 2 3 4 5 6 console.log(1); setTimeout(function () { console.log(2); }, 0); console.log(3); console.log(4); 上方代码中，打印的顺序仍然是1，3，4，2。这是为什么呢？我们来分析一下。\n总结：\njs 是单线程（同一时间只能做一件事），而且有一个任务队列：全部的同步任务执行完毕后，再来执行异步任务。第一行代码和最后一行代码是同步任务；但是 setTimeout是异步任务。\n于是，执行的顺序是：\n先执行同步任务console.log(1) 遇到异步任务setTimeout，要挂起 执行同步任务console.log(3) 全部的同步任务执行完毕后，再来执行异步任务console.log(2)。 注意上面那句话：同步任务执行完毕后，再来执行异步任务。如果同步任务没有执行完，异步任务是不会执行的。\n题目二：异步 现有如下代码：\n1 2 3 console.log(\u0026#39;A\u0026#39;); while (1) {} console.log(\u0026#39;B\u0026#39;); 我们很容易想到，上方代码的打印结果是A，因为while是同步任务，代码会陷入死循环里出不来，自然也就无法打印B。可如果我把代码改成下面的样子：\n1 2 3 4 5 6 console.log(\u0026#39;A\u0026#39;); setTimeout(function () { console.log(\u0026#39;B\u0026#39;); }) while (1) {} 上方代码的打印结果仍然是 A，因为while是同步任务，setTimeout是异步任务，如果同步任务没有执行完，队列里的异步任务是不会执行的。\n题目三：同步 1 2 3 console.log(\u0026#39;A\u0026#39;); alert(\u0026#39;haha\u0026#39;); //1秒之后点击确认 console.log(\u0026#39;B\u0026#39;); alert函数是同步任务，我只有点击了确认，才会继续打印B。\n同步和异步的对比 【重要】 因为setTimeout是异步任务，所以程序并不会卡在那里，而是继续向下执行（即使settimeout设置了倒计时一万秒）；但是alert函数是同步任务，程序会卡在那里，如果它没有执行，后面的也不会执行（卡在那里，自然也就造成了阻塞）。\n前端使用异步的场景 什么时候需要等待，就什么时候用异步。\n定时任务：setTimeout（定时炸弹）、setInterval（循环执行） 网络请求：ajax请求、动态\u0026lt;img\u0026gt;加载 事件绑定 ES6中的Promise 代码举例：\n1 2 3 4 5 6 7 console.log(\u0026#39;start\u0026#39;); var img = document.createElement(\u0026#39;img\u0026#39;); img.onload = function () { console.log(\u0026#39;loaded\u0026#39;); } img.src = \u0026#39;/xxx.png\u0026#39;; console.log(\u0026#39;end\u0026#39;); 上图中，先打印start，然后执行img.src = '/xxx.png'，然后打印end，最后打印loaded。\n任务队列和Event Loop（事件循环） 任务队列 所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。 同步任务 指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。 异步任务 指的是，不进入主线程、而进入\u0026quot;任务队列\u0026quot;（task queue）的任务，只有\u0026quot;任务队列\u0026quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n总结：只要主线程空了，就会去读取\u0026quot;任务队列\u0026quot;，这就是JavaScript的运行机制。【重要】\nEvent Loop 主线程从\u0026quot;任务队列\u0026quot;中读取事件，这个过程是循环不断的，所以整个的运行机制又称为Event Loop（事件循环）。\n在理解Event Loop时，要理解两句话：\n理解哪些语句会放入异步任务队列\n理解语句放入异步任务队列的时机\n容易答错的题目 1 2 3 4 5 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function () { console.log(i); }, 1000); } 很多人以为上面的题目，答案是0,1,2,3。其实，正确的答案是：3,3,3,3。\n分析：for 循环是同步任务，setTimeout是异步任务。for循环每次遍历的时候，遇到settimeout，就先暂留着，等同步任务全部执行完毕（此时，i已经等于3了），再执行异步任务。\n我们把上面的题目再加一行代码。最终代码如下：\n1 2 3 4 5 6 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function () { console.log(i); }, 1000); } console.log(i); //3 -\u0026gt; 3,3,3 如果我们约定，用箭头表示其前后的两次输出之间有 1 秒的时间间隔，而逗号表示其前后的两次输出之间的时间间隔可以忽略，代码实际运行的结果该如何描述？可能会有两种答案：\nA. 60% 的人会描述为：3 -\u0026gt; 3 -\u0026gt; 3 -\u0026gt; 3，即每个 3 之间都有 1 秒的时间间隔；\nB. 40% 的人会描述为：3 -\u0026gt; 3,3,3，即第 1 个 3 直接输出，1 秒之后，连续输出 3 个 3。\n循环执行过程中，几乎同时设置了 3 个定时器，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的，显而易见，正确的描述是 B。\n上面这个题目的参考链接：\n深入浅出Javascript事件循环机制(上) 深入浅出Javascript事件循环机制(下) ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/09-js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B/","summary":"JS的异步和单线程 题目一：异步 现有如下代码： 1 2 3 4 5 6 7 console.log(1); setTimeout(function () { console.log(2); }, 1000); console.log(3); console.log(4); // 我们很容易知道，打印的顺序是`1，3，4，2` 可如果我把延时的","title":"js运行机制：异步和单线程"},{"content":"征服JavaScript面试系列 | 众城翻译 征服 JavaScript 面试：什么是闭包？\n征服 JavaScript 面试：什么是函数组合\n征服JavaScript面试系列：类继承和原型继承的区别\n征服 JavaScript 面试：什么是纯函数\n征服 JavaScript 面试: 什么是函数式编程？\n征服 JavaScript 面试: 什么是 Promise？\nHTTP最强资料大全\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/z-%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/","summary":"征服JavaScript面试系列 | 众城翻译 征服 JavaScript 面试：什么是闭包？ 征服 JavaScript 面试：什么是函数组合 征服JavaScript面试系列：类继承和原型继","title":"z-推荐文章"},{"content":"CSRF 基本概念、缩写、全称 CSRF（Cross-site request forgery）：跨站请求伪造。 PS：中文名一定要记住\nCSRF的攻击原理 用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。\n从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：\n（1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）\n（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。\n我们在讲CSRF时，一定要把上面的两点说清楚。\n温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。\n举个例子，前段时间里，微博网站有个api接口有漏洞，导致很多用户的粉丝暴增。\nCSRF如何防御 方法一、Token 验证：（用的最多） （1）服务器发送给客户端一个token； （2）客户端提交的表单中带着这个token。 （3）如果这个 token 不合法，那么服务器拒绝这个请求。\n方法二：隐藏令牌： 把 token 隐藏在 http 的 head头中。\n方法三、Referer 验证： Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。\n方法四 表单统一用post\nXSS XSS的基本概念 XSS（Cross Site Scripting）：跨域脚本攻击。\nXSS的攻击原理 XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。\n最后导致的结果可能是：\n盗用Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss攻击 XSS的攻击方式 1、反射型XSS 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。\n2、存储型XSS 存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。 XSS的防范措施（encode + 过滤） Vue中的防御措施 不论使用模板还是渲染函数，Vue都会将插值的内容都会自动转义 通过转义\u0026lt;为\u0026amp;lt以及\u0026gt;为\u0026amp;gt来实现防御HTML节点内容 要在模板内避免渲染 style 标签: CSRF 和 XSS 的区别 面试官还可能喜欢问二者的区别。\n区别一：\nCSRF：需要用户先登录网站A，获取 cookie。 XSS：不需要登录。 区别二：（原理的区别）\nCSRF：是利用网站A本身的漏洞，去请求网站A的api。 XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。 XSS文章推荐 http://html5sec.org/ 里面列出了很多XSS的例子，可以长见识。如果你专门研究XSS，可以看看。\nFreeBuf网站上的专栏作者：Black-Hole 比如，他的第一篇文章就讲到了XSS的原理分析与解剖。有句话摘抄如下：弹窗只是测试xss的存在性和使用性。\n比如，这个人还有篇文章写自动化检测CSRF（第一章）。大公司做网站，一般会做嗅探服务（比如自动化工具做CSRF的检测、自动化的方式控制安全风险）。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/07-%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98csrf%E5%92%8Cxss/","summary":"CSRF 基本概念、缩写、全称 CSRF（Cross-site request forgery）：跨站请求伪造。 PS：中文名一定要记住 CSRF的攻击原理 用户是网站A的","title":"安全问题：CSRF和XSS"},{"content":"排序 上面的排序这么多，我们要记住下面这三个：\n快速排序：https://segmentfault.com/a/1190000009426421 选择排序：https://segmentfault.com/a/1190000009366805 希尔排序：https://segmentfault.com/a/1190000009461832 如果你还要学一个，那就是冒泡排序。\n堆栈、队列、链表 堆栈：先进后出。\n数组、队列、链表 递归 参考链接：\nJavaScript中的递归 递归理解起来不难，但是用的时候很难，因为你没抓住他的本质。 递归的终止条件是什么？参数是怎么传递的？一定要搞清楚。\n波兰式和逆波兰式 推荐链接：\n理论：http://www.cnblogs.com/chenying99/p/3675876.html 源码：https://github.com/Tairraos/rpn.js/blob/master/rpn.js ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/08-%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/","summary":"排序 上面的排序这么多，我们要记住下面这三个： 快速排序：https://segmentfault.com/a/1190000009426421","title":"算法问题"},{"content":"同源策略的概念和具体限制 同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）\n具体解释：\n（1）源包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则源不同，那就是跨域了。\n（2）限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）\nCookie、LocalStorage和IndexDB无法获取。\n无法获取和操作DOM。\n不能发送Ajax请求。我们要注意，Ajax只适合同源的通信。\n前后端如何通信 主要有以下几种方式：\nAjax：不支持跨域。\nWebSocket：不受同源策略的限制，支持跨域。\nCORS：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的Ajax\nAjax 的推荐链接：https://segmentfault.com/a/1190000006669043\n跨域通信的几种方式 方式如下：\n1、JSONP 2、WebSocket 3、CORS 4、Nginx 反向代理 1、WebSocket WebSocket的用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // var ws = new WebSocket(\u0026#39;wss://echo.websocket.org\u0026#39;); //创建WebSocket的对象。 //把请求发出去 ws.onopen = function (evt) { console.log(\u0026#39;Connection open ...\u0026#39;); ws.send(\u0026#39;Hello WebSockets!\u0026#39;); }; //对方发消息过来时，我接收 ws.onmessage = function (evt) { console.log(\u0026#39;Received Message: \u0026#39;, evt.data); ws.close(); }; //关闭连接 ws.onclose = function (evt) { console.log(\u0026#39;Connection closed.\u0026#39;); }; Websocket的推荐链接：http://www.ruanyifeng.com/blog/2017/05/websocket.html\n2、跨域资源共享 CORS CORS 可以理解成是既可以同步、也可以异步的Ajax。\n3、Nginx 反向代理 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/06-%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/","summary":"同源策略的概念和具体限制 同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制","title":"跨域通信类"},{"content":"基础知识主要包含以下几个方面：\n基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECMAScript、CSS、TypeScript、HTML、Node.js 等语法的了解和使用 框架：React、Vue、Egg、Koa、Express、Webpack 等原理的了解和使用 工程：编译工具、格式工具、Git、NPM、单元测试、Nginx、PM2、CI / CD 了解和使用 网络：HTTP、TCP、UDP、WebSocket、Cookie、Session、跨域、缓存、协议的了解 性能：编译性能、监控、白屏检测、SEO、Service Worker 等了解 插件：Chrome 、Vue CLI 、Webpack 等插件设计思路的理解 系统：Mac、Windows、Linux 系统配置的实践 后端：Redis 缓存、数据库、Graphql、SSR、模板引擎等了解和使用 基础 1、列举你所了解的计算机存储设备类型？ 现代计算机以存储器为中心，主要由 CPU、I / O 设备以及主存储器三大部分组成。各个部分之间通过总线进行连接通信，具体如下图所示： 上图是一种多总线结构的示意图，CPU、主存以及 I / O 设备之间的所有数据都是通过总线进行并行传输，使用局部总线是为了提高 CPU 的吞吐量（CPU 不需要直接跟 I / O 设备通信），而使用高速总线（更贴近 CPU）和 DMA 总线则是为了提升高速 I / O 设备（外设存储器、局域网以及多媒体等）的执行效率。\n主存包括随机存储器 RAM 和只读存储器 ROM，其中 ROM 又可以分为 MROM（一次性）、PROM、EPROM、EEPROM 。ROM 中存储的程序（例如启动程序、固化程序）和数据（例如常量数据）在断电后不会丢失。RAM 主要分为静态 RAM（SRAM） 和动态 RAM（DRAM） 两种类型（DRAM 种类很多，包括 SDRAM、RDRAM、CDRAM 等），断电后数据会丢失，主要用于存储临时程序或者临时变量数据。DRAM 一般访问速度相对较慢。由于现代 CPU 读取速度要求相对较高，因此在 CPU 内核中都会设计 L1、L2 以及 L3 级别的多级高速缓存，这些缓存基本是由 SRAM 构成，一般访问速度较快。\n2、一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？ 高级程序设计语言不能直接被计算机理解并执行，需要通过翻译程序将其转换成特定处理器上可执行的指令，计算机 CPU 的简单工作原理如下所示： CPU 主要由控制单元、运算单元和存储单元组成（注意忽略了中断系统），各自的作用如下：\n控制单元：在节拍脉冲的作用下，将程序计数器（Program Counter，PC）指向的主存或者多级高速缓存中的指令地址送到地址总线，接着获取指令地址所对应的指令并放入指令寄存器 （Instruction Register，IR）中，然后通过指令译码器（Instruction Decoder，ID）分析指令需要进行的操作，最后通过操作控制器（Operation Controller，OC）向其他设备发出微操作控制信号。 运算单元：如果控制单元发出的控制信号存在算术运算（加、减、乘、除、增 1、减 1、取反等）或者逻辑运算（与、或、非、异或），那么需要通过运算单元获取存储单元的计算数据进行处理。 存储单元：包括片内缓存和寄存器组，是 CPU 中临时数据的存储地方。CPU 直接访问主存数据大概需要花费数百个机器周期，而访问寄存器或者片内缓存只需要若干个或者几十个机器周期，因此会使用内部寄存器或缓存来存储和获取临时数据（即将被运算或者运算之后的数据），从而提高 CPU 的运行效率。 除此之外，计算机系统执行程序指令时需要花费时间，其中取出一条指令并执行这条指令的时间叫指令周期。指令周期可以分为若干个阶段（取指周期、间址周期、执行周期和中断周期），每个阶段主要完成一项基本操作，完成基本操作的时间叫机器周期。机器周期是时钟周期的分频，例如最经典的 8051 单片机的机器周期为 12 个时钟周期。时钟周期是 CPU 工作的基本时间单位，也可以称为节拍脉冲或 T 周期（CPU 主频的倒数） 。假设 CPU 的主频是 1 GHz（1 Hz 表示每秒运行 1 次），那么表示时钟周期为 1 / 109 s。理论上 CPU 的主频越高，程序指令执行的速度越快。\n3、什么是指令和指令集？ 上图右侧主存中的指令是 CPU 可以支持的处理命令，一般包含算术指令（加和减）、逻辑指令（与、或和非）、数据指令（移动、输入、删除、加载和存储）、流程控制指令以及程序结束指令等，由于 CPU 只能识别二进制码，因此指令是由二进制码组成。除此之外，指令的集合称为指令集（例如汇编语言就是指令集的一种表现形式），常见的指令集有精简指令集（ARM）和复杂指令集（Inter X86）。一般指令集决定了 CPU 处理器的硬件架构，规定了处理器的相应操作。\n4、复杂指令集和精简指令集有什么区别？ 5、JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？ 早期的计算机只有机器语言时，程序设计必须用二进制数（0 和 1）来编写程序，并且要求程序员对计算机硬件和指令集非常了解，编程的难度较大，操作极易出错。为了解决机器语言的编程问题，慢慢开始出现了符号式的汇编语言（采用 ADD、SUB、MUL、DIV 等符号代表加减乘除）。为了使得计算机可以识别汇编语言，需要将汇编语言翻译成机器能够识别的机器语言（处理器的指令集）： 由于每一种机器的指令系统不同，需要不同的汇编语言程序与之匹配，因此程序员往往需要针对不同的机器了解其硬件结构和指令系统。为了可以抹平不同机器的指令系统，使得程序员可以更加关注程序设计本身，先后出现了各种面向问题的高级程序设计语言，例如 BASIC 和 C，具体过程如下图所示： 高级程序语言会先翻译成汇编语言或者其他中间语言，然后再根据不同的机器翻译成机器语言进行执行。除此之外，汇编语言虚拟机和机器语言机器之间还存在一层操作系统虚拟机，主要用于控制和管理操作系统的全部硬件和软件资源（随着超大规模集成电路技术的不断发展，一些操作系统的软件功能逐步由硬件来替换，例如目前的操作系统已经实现了部分程序的固化，简称固件，将程序永久性的存储在 ROM 中）。机器语言机器还可以继续分解成微程序机器，将每一条机器指令翻译成一组微指令（微程序）进行执行。\n上述虚拟机所提供的语言转换程序被称为编译器，主要作用是将某种语言编写的源程序转换成一个等价的机器语言程序，编译器的作用如下图所示： 例如 C 语言，可以先通过 gcc 编译器生成 Linux 和 Windows 下的目标 .o 和 .obj 文件（object 文件，即目标文件），然后将目标文件与底层系统库文件、应用程序库文件以及启动文件链接成可执行文件在目标机器上执行。\n温馨提示：感兴趣的同学可以了解一下 ARM 芯片的程序运行原理，包括使用 IDE 进行程序的编译（IDE 内置编译器，主流编译器包含 ARMCC、IAR 以及 GCC FOR ARM 等，其中一些编译器仅仅随着 IDE 进行捆绑发布，不提供独立使用的能力，而一些编译器则随着 IDE 进行发布的同时，还提供命令行接口的独立使用方式）、通过串口进行程序下载（下载到芯片的代码区初始启动地址映射的存储空间地址）、启动的存储空间地址映射（包括系统存储器、闪存 FLASH、内置 SRAM 等）、芯片的程序启动模式引脚 BOOT 的设置（例如调试代码时常常选择内置 SRAM、真正程序运行的时候选择闪存 FLASH）等。\n如果某种高级语言或者应用语言（例如用于人工智能的计算机设计语言）转换的目标语言不是特定计算机的汇编语言，而是面向另一种高级程序语言（很多研究性的编译器将 C 作为目标语言），那么还需要将目标高级程序语言再进行一次额外的编译才能得到最终的目标程序，这种编译器可称为源到源的转换器。\n除此之外，有些程序设计语言将编译的过程和最终转换成目标程序进行执行的过程混合在一起，这种语言转换程序通常被称为解释器，主要作用是将某种语言编写的源程序作为输入，将该源程序执行的结果作为输出，解释器的作用如下图所示：\nimage.png\n解释器和编译器有很多相似之处，都需要对源程序进行分析，并转换成目标机器可识别的机器语言进行执行。只是解释器是在转换源程序的同时立马执行对应的机器语言（转换和执行的过程不分离），而编译器得先把源程序全部转换成机器语言并产生目标文件，然后将目标文件写入相应的程序存储器进行执行（转换和执行的过程分离）。例如 Perl、Scheme、APL 使用解释器进行转换， C、C++ 则使用编译器进行转换，而 Java 和 JavaScript 的转换既包含了编译过程，也包含了解释过程。\n6、简单描述一下 Babel 的编译过程？ 7、JavaScript 中的数组和函数在内存中是如何存储的？ JavaScript 中的数组存储大致需要分为两种情况：\n同种类型数据的数组分配连续的内存空间 存在非同种类型数据的数组使用哈希映射分配内存空间 温馨提示：可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）。\n8、浏览器和 Node.js 中的事件循环机制有什么区别？ 阅读链接：面试分享：两年工作经验成功面试阿里P6总结**[2]** - 了解 Event Loop 吗？\n9、ES6 Modules 相对于 CommonJS 的优势是什么？ 10、高级程序设计语言是如何编译成机器语言的？ 11、编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？ 12、编译过程中虚拟机的作用是什么？ 13、什么是中间代码（IR），它的作用是什么？ 14、什么是交叉编译？ 编译器的设计是一个非常庞大和复杂的软件系统设计，在真正设计的时候需要解决两个相对重要的问题：\n如何分析不同高级程序语言设计的源程序 如何将源程序的功能等价映射到不同指令系统的目标机器 为了解决上述两项问题，编译器的设计最终被分解成前端（注意这里所说的不是 Web 前端）和后端两个编译阶段，前端用于解决第一个问题，而后端用于解决第二个问题，具体如下图所示： 上图中的中间表示（Intermediate Representation，IR）是程序结构的一种表现方式，它会比 AST（后续讲解）更加接近汇编语言或者指令集，同时也会保留源程序中的一些高级信息，除此之外 ，它的种类很多，包括三地址码（Three Address Code, TAC）****[3]、**静态单赋值形式（Static Single Assignment Form, SSA）****[4]**以及基于栈的 IR 等，具体作用包括：\n靠近前端部分主要适配不同的源程序，靠近后端部分主要适配不同的指令集，更易于编译器的错误调试，容易识别是 IR 之前还是之后出问题 如下左图所示，如果没有 IR，那么源程序到指令集之间需要进行一一适配，而有了中间表示，则可以使得编译器的职责更加分离，源程序的编译更多关注如何转换成 IR，而不是去适配不同的指令集 IR 本身可以做到多趟迭代从而优化源程序，在每一趟迭代的过程中可以研究代码并记录优化的细节，方便后续的迭代查找并利用这些优化信息，最终可以高效输出更优的目标程序 由于 IR 可以进行多趟迭代进行程序优化，因此在编译器中可插入一个新的优化阶段，如下图所示： 优化器可以对 IR 处理一遍或者多遍，从而生成更快执行速度（例如找到循环中不变的计算并对其进行优化从而减少运算次数）或者更小体积的目标程序，也可能用于产生更少异常或者更低功耗的目标程序。除此之外，前端和后端内部还可以细分为多个处理步骤，具体如下图所示： 优化器中的每一遍优化处理都可以使用一个或多个优化技术来改进代码，每一趟处理最终都是读写 IR 的操作，这样不仅仅可以使得优化可以更加高效，同时也可以降低优化的复杂度，还提高了优化的灵活性，可以使得编译器配置不同的优化选项，达到组合优化的效果。\n15、发布 / 订阅模式和观察者模式的区别是什么？ 阅读链接：基于Vue实现一个简易MVVM**[5]** - 观察者模式和发布/订阅模式\n16、装饰器模式一般会在什么场合使用？ 17、谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？ 18、列举你所了解的编程范式？ 编程范式（Programming paradigm）是指计算机编程的基本风格或者典型模式，可以简单理解为编程学科中实践出来的具有哲学和理论依据的一些经典原型。常见的编程范式有：\n面向过程（Process Oriented Programming，POP） 面向对象（Object Oriented Programming，OOP） 面向接口（Interface Oriented Programming， IOP） 面向切面（Aspect Oriented Programming，AOP） 函数式（Funtional Programming，FP） 响应式（Reactive Programming，RP） 函数响应式（Functional Reactive Programming，FRP） 阅读链接：：如果你对于编程范式的定义相对模糊，可以继续阅读 What is the precise definition of programming paradigm?****[6] 了解更多。\n不同的语言可以支持多种不同的编程范式，例如 C 语言支持 POP 范式，C++ 和 Java 语言支持 OOP 范式，Swift 语言则可以支持 FP 范式，而 Web 前端中的 JavaScript 可以支持上述列出的所有编程范式。\n19、什么是面向切面（AOP）的编程？ 20、什么是函数式编程？ 顾名思义，函数式编程是使用函数来进行高效处理数据或数据流的一种编程方式。在数学中，函数的三要素是定义域、值域和**对应关系。假设 A、B 是非空数集，对于集合 A 中的任意一个数 x，在集合 B 中都有唯一确定的数 f(x) 和它对应，那么可以将 f 称为从 A 到 B 的一个函数，记作：y = f(x)。在函数式编程中函数的概念和数学函数的概念类似，主要是描述形参 x 和返回值 y 之间的对应关系，**如下图所示：\n温馨提示：图片来自于简明 JavaScript 函数式编程——入门篇****[7]。\n在实际的编程中，可以将各种明确对应关系的函数进行传递、组合从而达到处理数据的最终目的。在此过程中，我们的关注点不在于如何去实现**对应关系，**而在于如何将各种已有的对应关系进行高效联动，从而可快速进行数据转换，达到最终的数据处理目的，提供开发效率。\n简单示例\n尽管你对函数式编程的概念有所了解，但是你仍然不知道函数式编程到底有什么特点。这里我们仍然拿 OOP 编程范式来举例，假设希望通过 OOP 编程来解决数学的加减乘除问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MathObject { constructor(private value: number) {} public add(num: number): MathObject { this.value += num; return this; } public multiply(num: number): MathObject { this.value *= num; return this; } public getValue(): number { return this.value; } } const a = new MathObject(1); a.add(1).multiply(2).add(a.multiply(2).getValue()); 复制代码 我们希望通过上述程序来解决 (1 + 2) * 2 + 1 * 2 的问题，但实际上计算出来的结果是 24，因为在代码内部有一个 this.value 的状态值需要跟踪，这会使得结果不符合预期。接下来我们采用函数式编程的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function add(a: number, b: number): number { return a + b; } function multiply(a: number, b: number): number { return a * b; } const a: number = 1; const b: number = 2; add(multiply(add(a, b), b), multiply(a, b)); 复制代码 以上程序计算的结果是 8，完全符合预期。我们知道了 add 和 multiply 两个函数的实际对应关系，通过将对应关系进行有效的组合和传递，达到了最终的计算结果。除此之外，这两个函数还可以根据数学定律得出更优雅的组合方式：\n1 2 3 4 5 6 7 8 add(multiply(add(a, b), b), multiply(a, b)); // 根据数学定律分配律：a * b + a * c = a * (b + c)，得出： // (a + b) * b + a * b = (2a + b) * b // 简化上述函数的组合方式 multiply(add(add(a, a), b), b); 复制代码 我们完全不需要追踪类似于 OOP 编程范式中可能存在的内部状态数据，事实上对于数学定律中的结合律、交换律、同一律以及分配律，上述的函数式编程代码足可以胜任。\n原则\n通过上述简单的例子可以发现，要实现高可复用的函数**（对应关系）**，一定要遵循某些特定的原则，否则在使用的时候可能无法进行高效的传递和组合，例如\n高内聚低耦合 最小意外原则 单一职责原则 \u0026hellip; 如果你之前经常进行无原则性的代码设计，那么在设计过程中可能会出现各种出乎意料的问题（这是为什么新手老是出现一些稀奇古怪问题的主要原因）。函数式编程可以有效的通过一些原则性的约束使你设计出更加健壮和优雅的代码，并且在不断的实践过程中进行经验式叠加，从而提高开发效率。\n特点\n虽然我们在使用函数的过程中更多的不再关注函数如何实现（对应关系），但是真正在使用和设计函数的时候需要注意以下一些特点：\n声明式（Declarative Programming） 一等公民（First Class Function） 纯函数（Pure Function） 无状态和数据不可变（Statelessness and Immutable Data） \u0026hellip; 声明式\n我们以前设计的代码通常是命令式编程方式，这种编程方式往往注重具体的实现的过程（对应关系），而函数式编程则采用声明式的编程方式，往往注重如何去组合已有的**对应关系。**简单举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 命令式 const array = [0.8, 1.7, 2.5, 3.4]; const filterArray = []; for (let i = 0; i \u0026lt; array.length; i++) { const integer = Math.floor(array[i]); if (integer \u0026lt; 2) { continue; } filterArray.push(integer); } // 声明式 // map 和 filter 不会修改原有数组，而是产生新的数组返回 [0.8, 1.7, 2.5, 3.4].map((item) =\u0026gt; Math.floor(item)).filter((item) =\u0026gt; item \u0026gt; 1); 复制代码 命令式代码一步一步的告诉计算机需要执行哪些语句，需要关心变量的实例化情况、循环的具体过程以及跟踪变量状态的变化过程。声明式代码更多的不再关心代码的具体执行过程，而是采用表达式的组合变换去处理问题，不再强调怎么做，而是指明**做什么。**声明式编程方式可以将我们设计代码的关注点彻底从过程式解放出来，从而提高开发效率。\n一等公民\n在 JavaScript 中，函数的使用非常灵活，例如可以对函数进行以下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 interface IHello { (name: string): string; key?: string; arr?: number[]; fn?(name: string): string; } // 函数声明提升 console.log(hello instanceof Object); // true // 函数声明提升 // hello 和其他引用类型的对象一样，都有属性和方法 hello.key = \u0026#39;key\u0026#39;; hello.arr = [1, 2]; hello.fn = function (name: string) { return `hello.fn, ${name}`; }; // 函数声明提升 // 注意函数表达式不能在声明前执行，例如不能在这里使用 helloCopy(\u0026#39;world\u0026#39;) hello(\u0026#39;world\u0026#39;); // 函数 // 创建新的函数对象，将函数的引用指向变量 hello // hello 仅仅是变量的名称 function hello(name: string): string { return `hello, ${name}`; } console.log(hello.key); // key console.log(hello.arr); // [1,2] console.log(hello.name); // hello // 函数表达式 const helloCopy: IHello = hello; helloCopy(\u0026#39;world\u0026#39;); function transferHello(name: string, hello: Hello) { return hello(\u0026#39;world\u0026#39;); } // 把函数对象当作实参传递 transferHello(\u0026#39;world\u0026#39;, helloCopy); // 把匿名函数当作实参传递 transferHello(\u0026#39;world\u0026#39;, function (name: string) { return `hello, ${name}`; }); 复制代码 通过以上示例可以看出，函数继承至对象并拥有对象的特性。在 JavaScript 中可以对函数进行参数传递、变量赋值或数组操作等等，因此把函数称为一等公民。函数式编程的核心就是对函数进行组合或传递，JavaScript 中函数这种灵活的特性是满足函数式编程的重要条件。\n纯函数\n纯函数是是指在相同的参数调用下，函数的返回值唯一不变。这跟数学中函数的映射关系类似，同样的 x 不可能映射多个不同的 y。使用函数式编程会使得函数的调用非常稳定，从而降低 Bug 产生的机率。当然要实现纯函数的这种特性，需要函数不能包含以下一些副作用：\n操作 Http 请求 可变数据（包括在函数内部改变输入参数） DOM 操作 打印日志 访问系统状态 操作文件系统 操作数据库 \u0026hellip; 从以上常见的一些副作用可以看出，纯函数的实现需要遵循最小意外原则，为了确保函数的稳定唯一的输入和输出，尽量应该避免与函数外部的环境进行任何交互行为，从而防止外部环境对函数内部产生无法预料的影响。纯函数的实现应该自给自足，举几个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 如果使用 const 声明 min 变量（基本数据类型），则可以保证以下函数的纯粹性 let min: number = 1; // 非纯函数 // 依赖外部环境变量 min，一旦 min 发生变化则输入和返回不唯一 function isEqual(num: number): boolean { return num === min; } // 纯函数 function isEqual(num: number): boolean { return num === 1; } // 非纯函数 function request\u0026lt;T, S\u0026gt;(url: string, params: T): Promise\u0026lt;S\u0026gt; { // 会产生请求成功和请求失败两种结果，返回的结果可能不唯一 return $.getJson(url, params); } // 纯函数 function request\u0026lt;T, S\u0026gt;(url: string, params: T) : () =\u0026gt; Promise\u0026lt;S\u0026gt; { return function() { return $.getJson(url, params); } } 复制代码 纯函数的特性使得函数式编程具备以下特性：\n可缓存性（Cacheable） 可移植性（Portable） 可测试性（Testable） 可缓存性和可测试性基于纯函数输入输出唯一不变的特性，可移植性则主要基于纯函数不依赖外部环境的特性。这里举一个可缓存的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 interface ICache\u0026lt;T\u0026gt; { [arg: string]: T; } interface ISquare\u0026lt;T\u0026gt; { (x: T): T; } // 简单的缓存函数（忽略通用性和健壮性） function memoize\u0026lt;T\u0026gt;(fn: ISquare\u0026lt;T\u0026gt;): ISquare\u0026lt;T\u0026gt; { const cache: ICache\u0026lt;T\u0026gt; = {}; return function (x: T) { const arg: string = JSON.stringify(x); cache[arg] = cache[arg] || fn.call(fn, x); return cache[arg]; }; } // 纯函数 function square(x: number): number { return x * x; } const memoSquare = memoize\u0026lt;number\u0026gt;(square); memoSquare(4); // 不会再次调用纯函数 square，而是直接从缓存中获取值 // 由于输入和输出的唯一性，获取缓存结果可靠稳定 // 提升代码的运行效率 memoSquare(4); 复制代码 无状态和数据不可变\n在函数式编程的简单示例中已经可以清晰的感受到函数式编程绝对不能依赖内部状态，而在纯函数中则说明了函数式编程不能依赖外部的环境或状态，因为一旦依赖的状态变化，不能保证函数根据对应关系所计算的返回值因为状态的变化仍然保持不变。\n这里单独讲解一下数据不可变，在 JavaScript 中有很多数组操作的方法，举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 const arr = [1, 2, 3]; console.log(arr.slice(0, 2)); // [1, 2] console.log(arr); // [1, 2, 3] console.log(arr.slice(0, 2)); // [1, 2] console.log(arr); // [1, 2, 3] console.log(arr.splice(0, 1)); // [1] console.log(arr); // [2, 3] console.log(arr.splice(0, 1)); // [2] console.log(arr); // [3] 复制代码 这里的 slice 方法多次调用都不会改变原有数组，且会产生相同的输出。而 splice 每次调用都在修改原数组，且产生的输出也不相同。在函数式编程中，这种会改变原有数据的函数已经不再是纯函数，应该尽量避免使用。\n阅读链接：如果想要了解更深入的函数式编程知识点，可以额外阅读函数式编程指北****[8]。\n21、响应式编程的使用场景有哪些？ 响应式编程是一种基于观察者（发布 / 订阅）模式并且面向异步（Asynchronous）数据流（Data Stream）和变化传播的声明式编程范式。响应式编程主要适用的场景包含：\n用户和系统发起的连续事件处理，例如鼠标的点击、键盘的按键或者通信设备发起的信号等 非可靠的网络或者通信处理（例如 HTTP 网络的请求重试） 连续的异步 IO 处理 复杂的继发事务处理（例如一次事件涉及到多个继发的网络请求） 高并发的消息处理（例如 IM 聊天） \u0026hellip; 语法 22、如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应? 23、如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip? 24、如何让 CSS 元素左侧自动溢出（\u0026hellip; 溢出在左侧）？ The direction CSS property sets the direction of text, table columns, and horizontal overflow. Use rtl for languages written from right to left (like Hebrew or Arabic), and ltr for those written from left to right (like English and most other languages).\n具体查看：developer.mozilla.org/en-US/docs/…****[9]\n25、什么是沙箱？浏览器的沙箱有什么作用？ 26、如何处理浏览器中表单项的密码自动填充问题？ 27、Hash 和 History 路由的区别和优缺点？ 28、JavaScript 中对象的属性描述符有哪些？分别有什么作用？ 29、JavaScript 中 console 有哪些 api ? The console object provides access to the browser\u0026rsquo;s debugging console (e.g. the Web console**[10]** in Firefox). The specifics of how it works varies from browser to browser, but there is a de facto set of features that are typically provided.\n这里列出一些我常用的 API:\nconsole.log console.error console.time console.timeEnd console.group 具体查看：developer.mozilla.org/en-US/docs/…****[11]\n30、 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？ 在 JavaScript 中利用事件循环机制****[12]（Event Loop）可以在单线程中实现非阻塞式、异步的操作。例如\nNode.js 中的 Callback、EventEmitter**[13]、Stream**[14] ES6 中的 Promise**[15]、Generator**[16] ES2017 中的 Async**[17]** 三方库 RxJS、Q**[18]** 、Co、****[19]Bluebird[20] 我们重点来看一下常用的几种编程方式（Callback、Promise、Generator、Async）在语法糖上带来的优劣对比。\nCallback\nCallback（回调函数）是在 Web 前端开发中经常会使用的编程方式。这里举一个常用的定时器示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 export interface IObj { value: string; deferExec(): void; deferExecAnonymous(): void; console(): void; } export const obj: IObj = { value: \u0026#39;hello\u0026#39;, deferExecBind() { // 使用箭头函数可达到一样的效果 setTimeout(this.console.bind(this), 1000); }, deferExec() { setTimeout(this.console, 1000); }, console() { console.log(this.value); }, }; obj.deferExecBind(); // hello obj.deferExec(); // undefined 复制代码 回调函数经常会因为调用环境的变化而导致 this 的指向性变化。除此之外，使用回调函数来处理多个继发的异步任务时容易导致回调地狱（Callback Hell）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fs.readFile(fileA, \u0026#39;utf-8\u0026#39;, function (err, data) { fs.readFile(fileB, \u0026#39;utf-8\u0026#39;, function (err, data) { fs.readFile(fileC, \u0026#39;utf-8\u0026#39;, function (err, data) { fs.readFile(fileD, \u0026#39;utf-8\u0026#39;, function (err, data) { // 假设在业务中 fileD 的读写依次依赖 fileA、fileB 和 fileC // 或者经常也可以在业务中看到多个 HTTP 请求的操作有前后依赖（继发 HTTP 请求） // 这些异步任务之间纵向嵌套强耦合，无法进行横向复用 // 如果某个异步发生变化，那它的所有上层或下层回调可能都需要跟着变化（比如 fileA 和 fileB 的依赖关系倒置） // 因此称这种现象为 回调地狱 // .... }); }); }); }); 复制代码 回调函数不能通过 return 返回数据，比如我们希望调用带有回调参数的函数并返回异步执行的结果时，只能通过再次回调的方式进行参数传递：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 希望延迟 3s 后执行并拿到结果 function getAsyncResult(result: number) { setTimeout(() =\u0026gt; { return result * 3; }, 1000); } // 尽管这是常规的编程思维方式 const result = getAsyncResult(3000); // 但是打印 undefined console.log(\u0026#39;result: \u0026#39;, result); function getAsyncResultWithCb(result: number, cb: (result: number) =\u0026gt; void) { setTimeout(() =\u0026gt; { cb(result * 3); }, 1000); } // 通过回调的形式获取结果 getAsyncResultWithCb(3000, (result) =\u0026gt; { console.log(\u0026#39;result: \u0026#39;, result); // 9000 }); 复制代码 对于 JavaScript 中标准的异步 API 可能无法通过在外部进行 try...catch... 的方式进行错误捕获：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try { setTimeout(() =\u0026gt; { // 下述是异常代码 // 你可以在回调函数的内部进行 try...catch... console.log(a.b.c) }, 1000) } catch(err) { // 这里不会执行 // 进程会被终止 console.error(err) } 复制代码 上述示例讲述的都是 JavaScript 中标准的异步 API ，如果使用一些三方的异步 API 并且提供了回调能力时，这些 API 可能是非受信的，在真正使用的时候会因为执行反转（回调函数的执行权在三方库中）导致以下一些问题：\n使用者的回调函数设计没有进行错误捕获，而恰恰三方库进行了错误捕获却没有抛出错误处理信息，此时使用者很难感知到自己设计的回调函数是否有错误 使用者难以感知到三方库的回调时机和回调次数，这个回调函数执行的权利控制在三方库手中 使用者无法更改三方库提供的回调参数，回调参数可能无法满足使用者的诉求 \u0026hellip; 举个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 interface ILib\u0026lt;T\u0026gt; { params: T; emit(params: T): void; on(callback: (params: T) =\u0026gt; void): void; } // 假设以下是一个三方库，并发布成了npm 包 export const lib: ILib\u0026lt;string\u0026gt; = { params: \u0026#39;\u0026#39;, emit(params) { this.params = params; }, on(callback) { try { // callback 回调执行权在 lib 上 // lib 库可以决定回调执行多次 callback(this.params); callback(this.params); callback(this.params); // lib 库甚至可以决定回调延迟执行 // 异步执行回调函数 setTimeout(() =\u0026gt; { callback(this.params); }, 3000); } catch (err) { // 假设 lib 库的捕获没有抛出任何异常信息 } }, }; // 开发者引入 lib 库开始使用 lib.emit(\u0026#39;hello\u0026#39;); lib.on((value) =\u0026gt; { // 使用者希望 on 里的回调只执行一次 // 这里的回调函数的执行时机是由三方库 lib 决定 // 实际上打印四次，并且其中一次是异步执行 console.log(value); }); lib.on((value) =\u0026gt; { // 下述是异常代码 // 但是执行下述代码不会抛出任何异常信息 // 开发者无法感知自己的代码设计错误 console.log(value.a.b.c) }); 复制代码 Promise\nCallback 的异步操作形式除了会造成回调地狱，还会造成难以测试的问题。ES6 中的 Promise （基于 Promise A +****[21] 规范的异步编程解决方案）利用**有限状态机****[22]**的原理来解决异步的处理问题，Promise 对象提供了统一的异步编程 API，它的特点如下：\nPromise 对象的执行状态不受外界影响。Promise 对象的异步操作有三种状态： pending（进行中）、 fulfilled（已成功）和 rejected（已失败） ，只有 Promise 对象本身的异步操作结果可以决定当前的执行状态，任何其他的操作无法改变状态的结果 Promise 对象的执行状态不可变。Promise 的状态只有两种变化可能：从 pending（进行中）变为 fulfilled（已成功）或从 pending（进行中）变为 rejected（已失败） 温馨提示：有限状态机提供了一种优雅的解决方式，异步的处理本身可以通过异步状态的变化来触发相应的操作，这会比回调函数在逻辑上的处理更加合理，也可以降低代码的复杂度。\nPromise 对象的执行状态不可变示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const promise = new Promise\u0026lt;number\u0026gt;((resolve, reject) =\u0026gt; { // 状态变更为 fulfilled 并返回结果 1 后不会再变更状态 resolve(1); // 不会变更状态 reject(4); }); promise .then((result) =\u0026gt; { // 在 ES 6 中 Promise 的 then 回调执行是异步执行（微任务） // 在当前 then 被调用的那轮事件循环（Event Loop）的末尾执行 console.log(\u0026#39;result: \u0026#39;, result); }) .catch((error) =\u0026gt; { // 不执行 console.error(\u0026#39;error: \u0026#39;, error); }); 复制代码 假设要实现两个继发的 HTTP 请求，第一个请求接口返回的数据是第二个请求接口的参数，使用回调函数的实现方式如下所示（这里使用 setTimeout 来指代异步请求）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 回调地狱 const doubble = (result: number, callback: (finallResult: number) =\u0026gt; void) =\u0026gt; { // Mock 第一个异步请求 setTimeout(() =\u0026gt; { // Mock 第二个异步请求（假设第二个请求的参数依赖第一个请求的返回结果） setTimeout(() =\u0026gt; { callback(result * 2); }, 2000); }, 1000); }; doubble(1000, (result) =\u0026gt; { console.log(\u0026#39;result: \u0026#39;, result); }); 复制代码 温馨提示：继发请求的依赖关系非常常见，例如人员基本信息管理系统的开发中，经常需要先展示组织树结构，并默认加载第一个组织下的人员列表信息。\n如果采用 Promise 的处理方式则可以规避上述常见的回调地狱问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 // 将 resolve 改成 reject 会被 catch 捕获 setTimeout(() =\u0026gt; resolve(result), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 // 将 resolve 改成 reject 会被 catch 捕获 setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u0026gt; { return nextPromise(result); }) .then((result) =\u0026gt; { // 2s 后打印 2000 console.log(\u0026#39;result: \u0026#39;, result); }) // 任何一个 Promise 到达 rejected 状态都能被 catch 捕获 .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); }); 复制代码 Promise 的错误回调可以同时捕获 firstPromise 和 nextPromise 两个函数的 rejected 状态。接下来考虑以下调用场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 setTimeout(() =\u0026gt; resolve(result), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u0026gt; { nextPromise(result).then((result) =\u0026gt; { // 后打印 console.log(\u0026#39;nextPromise result: \u0026#39;, result); }); }) .then((result) =\u0026gt; { // 先打印 // 由于上一个 then 没有返回值，这里打印 undefined console.log(\u0026#39;firstPromise result: \u0026#39;, result); }) .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); }); 复制代码 首先 Promise 可以注册多个 then（放在一个执行队列里），并且这些 then 会根据上一次返回值的结果依次执行。除此之外，各个 Promise 的 then 执行互不干扰。我们将示例进行简单的变换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 setTimeout(() =\u0026gt; resolve(result), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u0026gt; { // 返回了 nextPromise 的 then 执行后的结果 return nextPromise(result).then((result) =\u0026gt; { return result; }); }) // 接着 nextPromise 的 then 执行的返回结果继续执行 .then((result) =\u0026gt; { // 2s 后打印 2000 console.log(\u0026#39;nextPromise result: \u0026#39;, result); }) .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); }); 复制代码 上述例子中的执行结果是因为 then 的执行会返回一个新的 Promise 对象，并且如果 then 执行后返回的仍然是 Promise 对象，那么下一个 then 的链式调用会等待该 Promise 对象的状态发生变化后才会调用（能得到这个 Promise 处理的结果）。接下来重点看下 Promise 的错误处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const promise = new Promise\u0026lt;string\u0026gt;((resolve, reject) =\u0026gt; { // 下述是异常代码 console.log(a.b.c); resolve(\u0026#39;hello\u0026#39;); }); promise .then((result) =\u0026gt; { console.log(\u0026#39;result: \u0026#39;, result); }) // 去掉 catch 仍然会抛出错误，但不会退出进程终止脚本执行 .catch((err) =\u0026gt; { // 执行 // ReferenceError: a is not defined console.error(err); }); setTimeout(() =\u0026gt; { // 继续执行 console.log(\u0026#39;hello world!\u0026#39;); }, 2000); 复制代码 从上述示例可以看出 Promise 的错误不会影响其他代码的执行，只会影响 Promise 内部的代码本身，因为Promise 会在内部对错误进行异常捕获，从而保证整体代码执行的稳定性。Promise 还提供了其他的一些 API 方便多任务的执行，包括\nPromise.all：适合多个异步任务并发执行但不允许其中任何一个任务失败 Promise.race ：适合多个异步任务抢占式执行 Promise.allSettled ：适合多个异步任务并发执行但允许某些任务失败 Promise 相对于 Callback 对于异步的处理更加优雅，并且能力也更加强大， 但是也存在一些自身的缺点：\n无法取消 Promise 的执行 无法在 Promise 外部通过 try...catch... 的形式进行错误捕获（Promise 内部捕获了错误） 状态单一，每次决断只能产生一种状态结果，需要不停的进行链式调用 温馨提示：手写 Promise 是面试官非常喜欢的一道笔试题，本质是希望面试者能够通过底层的设计正确了解 Promise 的使用方式，如果你对 Promise 的设计原理不熟悉，可以深入了解一下或者手动设计一个。\nGenerator\nPromise 解决了 Callback 的回调地狱问题，但也造成了代码冗余，如果一些异步任务不支持 Promise 语法，就需要进行一层 Promise 封装。Generator 将 JavaScript 的异步编程带入了一个全新的阶段，它使得异步代码的设计和执行看起来和同步代码一致。Generator 使用的简单示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; // 在 Generator 函数里执行的异步代码看起来和同步代码一致 function* gen(result: number): Generator\u0026lt;Promise\u0026lt;number\u0026gt;, Promise\u0026lt;number\u0026gt;, number\u0026gt; { // 异步代码 const firstResult = yield firstPromise(result) console.log(\u0026#39;firstResult: \u0026#39;, firstResult) // 2 // 异步代码 const nextResult = yield nextPromise(firstResult) console.log(\u0026#39;nextResult: \u0026#39;, nextResult) // 6 return nextPromise(firstResult) } const g = gen(1) // 手动执行 Generator 函数 g.next().value.then((res: number) =\u0026gt; { // 将 firstPromise 的返回值传递给第一个 yield 表单式对应的 firstResult return g.next(res).value }).then((res: number) =\u0026gt; { // 将 nextPromise 的返回值传递给第二个 yield 表单式对应的 nextResult return g.next(res).value }) 复制代码 通过上述代码，可以看出 Generator 相对于 Promise 具有以下优势：\n丰富了状态类型，Generator 通过 next 可以产生不同的状态信息，也可以通过 return 结束函数的执行状态，相对于 Promise 的 resolve 不可变状态更加丰富 Generator 函数内部的异步代码执行看起来和同步代码执行一致，非常利于代码的维护 Generator 函数内部的执行逻辑和相应的状态变化逻辑解耦，降低了代码的复杂度 next 可以不停的改变状态使得 yield 得以继续执行的代码可以变得非常有规律，例如从上述的手动执行 Generator 函数可以看出，完全可以将其封装成一个自动执行的执行器，具体如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; type Gen = Generator\u0026lt;Promise\u0026lt;number\u0026gt;, Promise\u0026lt;number\u0026gt;, number\u0026gt; function* gen(): Gen { const firstResult = yield firstPromise(1) console.log(\u0026#39;firstResult: \u0026#39;, firstResult) // 2 const nextResult = yield nextPromise(firstResult) console.log(\u0026#39;nextResult: \u0026#39;, nextResult) // 6 return nextPromise(firstResult) } // Generator 自动执行器 function co(gen: () =\u0026gt; Gen) { const g = gen() function next(data: number) { const result = g.next(data) if(result.done) { return result.value } result.value.then(data =\u0026gt; { // 通过递归的方式处理相同的逻辑 next(data) }) } // 第一次调用 next 主要用于启动 Generator 函数 // 内部指针会从函数头部开始执行，直到遇到第一个 yield 表达式 // 因此第一次 next 传递的参数没有任何含义（这里传递只是为了防止 TS 报错） next(0) } co(gen) 复制代码 温馨提示：TJ Holowaychuk**[23]** 设计了一个 Generator 自动执行器 Co**[24]，使用 Co 的前提是 yield 命令后必须是 Promise 对象或者 Thunk 函数。Co 还可以支持并发的异步处理，具体可查看官方的 API 文档**[25]。\n需要注意的是 Generator 函数的返回值是一个 Iterator 遍历器对象，具体如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; type Gen = Generator\u0026lt;Promise\u0026lt;number\u0026gt;\u0026gt;; function* gen(): Gen { yield firstPromise(1); yield nextPromise(2); } // 注意使用 next 是继发执行，而这里是并发执行 Promise.all([...gen()]).then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); }); for (const promise of gen()) { promise.then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); }); } 复制代码 Generator 函数的错误处理相对复杂一些，极端情况下需要对执行和 Generator 函数进行双重错误捕获，具体如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // 需要注意这里的reject 没有被捕获 setTimeout(() =\u0026gt; reject(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; type Gen = Generator\u0026lt;Promise\u0026lt;number\u0026gt;\u0026gt;; function* gen(): Gen { try { yield firstPromise(1); yield nextPromise(2); } catch (err) { console.error(\u0026#39;Generator 函数错误捕获: \u0026#39;, err); } } try { const g = gen(); g.next(); // 返回 Promise 后还需要通过 Promise.prototype.catch 进行错误捕获 g.next(); // Generator 函数错误捕获 g.throw(\u0026#39;err\u0026#39;); // 执行器错误捕获 g.throw(\u0026#39;err\u0026#39;); } catch (err) { console.error(\u0026#39;执行错误捕获: \u0026#39;, err); } 复制代码 在使用 g.throw 的时候还需要注意以下一些事项：\n如果 Generator 函数本身没有捕获错误，那么 Generator 函数内部抛出的错误可以在执行处进行错误捕获 如果 Generator 函数内部和执行处都没有进行错误捕获，则终止进程并抛出错误信息 如果没有执行过 g.next，则 g.throw 不会在 Gererator 函数中被捕获（因为执行指针没有启动 Generator 函数的执行），此时可以在执行处进行执行错误捕获 Async\nAsync 是 Generator 函数的语法糖，相对于 Generator 而言 Async 的特性如下：\n内置执行器：Generator 函数需要设计手动执行器或者通用执行器（例如 Co 执行器）进行执行，Async 语法则内置了自动执行器，设计代码时无须关心执行步骤 yield 命令无约束：在 Generator 中使用 Co 执行器时 yield 后必须是 Promise 对象或者 Thunk 函数，而 Async 语法中的 await 后可以是 Promise 对象或者原始数据类型对象、数字、字符串、布尔值等（此时会对其进行 Promise.resolve() 包装处理） 返回 Promise： async 函数的返回值是 Promise 对象（返回原始数据类型会被 Promise 进行封装）， 因此还可以作为 await 的命令参数，相对于 Generator 返回 Iterator 遍历器更加简洁实用 举个简单的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { const firstResult = await firstPromise(1); // 1s 后打印 2 console.log(\u0026#39;firstResult: \u0026#39;, firstResult); // 等待 firstPromise 的状态发生变化后执行 const nextResult = await nextPromise(firstResult); // 2s 后打印 6 console.log(\u0026#39;nextResult: \u0026#39;, nextResult); return nextResult; } co(); co().then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); // 6 }); 复制代码 通过上述示例可以看出，async 函数的特性如下：\n调用 async 函数后返回的是一个 Promise 对象，通过 then 回调可以拿到 async 函数内部 return 语句的返回值 调用 async 函数后返回的 Promise 对象必须等待内部所有 await 对应的 Promise 执行完（这使得 async 函数可能是阻塞式执行）后才会发生状态变化，除非中途遇到了 return 语句 await 命令后如果是 Promise 对象，则返回 Promise 对象处理后的结果，如果是原始数据类型，则直接返回原始数据类型 上述代码是阻塞式执行，nextPromise 需要等待 firstPromise 执行完成后才能继续执行，如果希望两者能够并发执行，则可以进行下述设计：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { return await Promise.all([firstPromise(1), nextPromise(1)]); } co().then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); // [2,3] }); 复制代码 除了使用 Promise 自带的并发执行 API，也可以通过让所有的 Promise 提前并发执行来处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;firstPromise\u0026#39;); setTimeout(() =\u0026gt; resolve(result * 2), 10000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;nextPromise\u0026#39;); setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { // 执行 firstPromise const first = firstPromise(1); // 和 firstPromise 同时执行 nextPromise const next = nextPromise(1); // 等待 firstPromise 结果回来 const firstResult = await first; console.log(\u0026#39;firstResult: \u0026#39;, firstResult); // 等待 nextPromise 结果回来 const nextResult = await next; console.log(\u0026#39;nextResult: \u0026#39;, nextResult); return nextResult; } co().then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); // 3 }); 复制代码 Async 的错误处理相对于 Generator 会更加简单，具体示例如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Promise 决断错误 setTimeout(() =\u0026gt; reject(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { const firstResult = await firstPromise(1); console.log(\u0026#39;firstResult: \u0026#39;, firstResult); const nextResult = await nextPromise(1); console.log(\u0026#39;nextResult: \u0026#39;, nextResult); return nextResult; } co() .then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); }) .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); // err: 2 }); 复制代码 async 函数内部抛出的错误，会导致函数返回的 Promise 对象变为 rejected 状态，从而可以通过 catch 捕获， 上述代码只是一个粗粒度的容错处理，如果希望 firstPromise 错误后可以继续执行 nextPromise，则可以通过 try...catch... 在 async 函数里进行局部错误捕获：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Promise 决断错误 setTimeout(() =\u0026gt; reject(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { try { await firstPromise(1); } catch (err) { console.error(\u0026#39;err: \u0026#39;, err); // err: 2 } // nextPromise 继续执行 const nextResult = await nextPromise(1); return nextResult; } co() .then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); // res: 3 }) .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); }); 复制代码 温馨提示：Callback 是 Node.js 中经常使用的编程方式，Node.js 中很多原生的 API 都是采用 Callback 的形式进行异步设计，早期的 Node.js 经常会有 Callback 和 Promise 混用的情况，并且在很长一段时间里都没有很好的支持 Async 语法。如果你对 Node.js 和它的替代品 Deno 感兴趣，可以观看 Ryan Dahl 在 TS Conf 2019 中的经典演讲 Deno is a New Way to JavaScript**[26]**。\n31、 Object.defineProperty 有哪几个参数？各自都有什么作用？ 32、 Object.defineProperty 和 ES6 的 Proxy 有什么区别？ 33、 ES6 中 Symbol、Map、Decorator 的使用场景有哪些？或者你在哪些库的源码里见过这些 API 的使用？ 34、 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？ 35、 TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？ 36、 TypeScript 中 any 类型的作用是什么？ 37、 TypeScript 中 any、never、unknown 和 void 有什么区别？ 38、 TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？ 39、 TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？ 40、 TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？ 41、 TypeScript 中使用 Unions 时有哪些注意事项？ 42、 TypeScript 如何设计 Class 的声明？ 43、 TypeScript 中如何联合枚举类型的 Key? 44、 TypeScript 中 ?.、??、!.、_、** 等符号的含义？ 45、 TypeScript 中预定义的有条件类型有哪些？ 46、 简单介绍一下 TypeScript 模块的加载机制？ 47、 简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？ 48、 TypeScript 中对象展开会有什么副作用吗？ 49、 TypeScript 中 interface、type、enum 声明有作用域的功能吗？ 50、 TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？ 51、 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？ 52、 TypeScript 的 tsconfig.json 中有哪些配置项信息？ 53、 TypeScript 中如何设置模块导入的路径别名？ 框架 54、 React Class 组件有哪些周期函数？分别有什么作用？ 55、 React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？ 56、 React Class 组件和 React Hook 的区别有哪些？ 57、 React 中高阶函数和自定义 Hook 的优缺点？ 58、 简要说明 React Hook 中 useState 和 useEffect 的运行原理？ 59、 React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？ 60、 React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？ 61、 React 的 useEffect 是如何监听数组依赖项的变化的？ 62、 React Hook 和闭包有什么关联关系？ 63、 React 中 useState 是如何做数据初始化的？ 64、 列举你常用的 React 性能优化技巧？ 65、 Vue 2.x 模板中的指令是如何解析实现的？ 66、 简要说明 Vue 2.x 的全链路运作机制？ 67、 简单介绍一下 Element UI 的框架设计？ 68、 如何理解 Vue 是一个渐进式框架？ 69、 Vue 里实现跨组件通信的方式有哪些？ 70、 Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？ 71、 MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、 72、 什么是 MVVM 框架？ 工程 73、Vue CLI 3.x 有哪些功能？Vue CLI 3.x 的插件系统了解？ 74、Vue CLI 3.x 中的 Webpack 是如何组装处理的？ 75、Vue 2.x 如何支持 TypeScript 语法？ 76、如何配置环境使得 JavaScript 项目可以支持 TypeScript 语法？ 77、如何对 TypeScript 进行 Lint 校验？ESLint 和 TSLint 有什么区别？ 78、Node.js 如何支持 TypeScript 语法？ 79、TypeScript 如何自动生成库包的声明文件？ 80、Babel 对于 TypeScript 的支持有哪些限制？ 81、Webpack 中 Loader 和 Plugin 的区别是什么？ 82、在 Webpack 中是如何做到支持类似于 JSX 语法的 Sourcemap 定位？ 83、发布 Npm 包如何指定引入地址？ 84、如何发布开发项目的特定文件夹为 Npm 包的根目录？ 85、如何发布一个支持 Tree Shaking 机制的 Npm 包？ 86、Npm 包中 peerDependencies 的作用是什么？ 87、如何优雅的调试需要发布的 Npm 包？ 88、在设计一些库包时如何生成版本日志？ 89、了解 Git （Submodule）子模块吗？简单介绍一下 Git 子模块的作用？ 90、Git 如何修改已经提交的 Commit 信息？ 91、Git 如何撤销 Commit 并保存之前的修改？ 92、Git 如何 ignore 被 commit 过的文件？ 93、在使用 Git 的时候如何规范 Git 的提交说明（Commit 信息）？ 94、简述符合 Angular 规范的提交说明的结构组成？ 95、Commit 信息如何和 Github Issues 关联？ 96、Git Hook 在项目中哪些作用？ 97、Git Hook 中客户端和服务端钩子各自用于什么作用？ 98、Git Hook 中常用的钩子有哪些？ 99、pre-commit 和 commit-msg 钩子的区别是什么？各自可用于做什么？ 100、husky 以及 ghook 等工具制作 Git Hook 的原理是什么？ 101、如何设计一个通用的 Git Hook ？ 102、Git Hook 可以采用 Node 脚本进行设计吗？如何做到？ 103、如何确保别人上传的代码没有 Lint 错误？如何确保代码构建没有 Lint 错误？ 104、如何在 Vs Code 中进行 Lint 校验提示？如何在 Vs Code 中进行 Lint 保存格式化？ 105、ESLint 和 Prettier 的区别是什么？两者在一起工作时会产生问题吗？ 106、如何有效的识别 ESLint 和 Prettier 可能产生冲突的格式规则？如何解决此类规则冲突问题？ 107、在通常的脚手架项目中进行热更新（hot module replacement）时如何做到 ESLint 实时打印校验错误信息？ 108、谈谈你对 SourceMap 的了解？ 109、如何调试 Node.js 代码？如何调试 Node.js TypeScript 代码？在浏览器中如何调试 Node.js 代码？ 110、列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？ 111、VS Code 配置中的用户和工作区有什么区别？ 112、VS Code 的插件可以只对当前项目生效吗？ 113、你所知道的测试有哪些测试类型？ 114、你所知道的测试框架有哪些？ 115、什么是 e2e 测试？有哪些 e2e 的测试框架？ 116、假设现在有一个插入排序算法，如何对该算法进行单元测试？ 网络 117、CDN 服务如何实现网络加速？ 118、WebSocket 使用的是 TCP 还是 UDP 协议？ 119、什么是单工、半双工和全双工通信？ 120、简单描述 HTTP 协议发送一个带域名的 URL 请求的协议传输过程？（DNS、TCP、IP、链路） 121、什么是正向代理？什么是反向代理？ 122、Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？ 123、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？ 124、设置 Cookie 时候如何防止 XSS 攻击？ 125、简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？ 126、HTTP 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？ 127、传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？ 128、什么是代理？什么是网关？代理和网关的作用是什么？ 129、HTTPS 相比 HTTP 为什么更加安全可靠？ 130、什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？ 131、你觉得 HTTP 协议目前存在哪些缺点？ 性能 133、在 React 中如何识别一个表单项里的表单做到了最小粒度 / 代价的渲染？ 134、在 React 的开发的过程中你能想到哪些控制渲染成本的方法？ 插件 135、Vue CLI 3.x 的插件系统是如何设计的？ 136、Webpack 中的插件机制是如何设计的？ 系统 137、\\r\\n（CRLF） 和 \\n （LF）的区别是什么？(Vs Code 的右下角可以切换) 138、/dev/null 的作用是啥？ 139、如何在 Mac 的终端中设置一个命令的别名？ 140、如何在 Windows 中设置环境变量？ 141、Mac 的文件操作系统默认区分文件路径的大小写吗？ 142、编写 Shell 脚本时如何设置文件的绝对路径？ 后端 143、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？ 144、如何部署 Node.js 应用？如何处理负载均衡中 Session 的一致性问题？ 145、如何提升 Node.js 代码的运行稳定性？ 146、GraphQL 与 Restful 的区别，它有什么优点？ 147、Vue SSR 的工作原理？Vuex 的数据如何同构渲染？ 148、SSR 技术和 SPA 技术的各自的优缺点是什么？ 149、如何处理 Node.js 渲染 HTML 压力过大问题？ 业务思考 业务思考更多的是结合基础知识的广度和深度进行的具体业务实践，主要包含以下几个方面：\n工程化：代码部署、CI / CD 流程设计、Jenkins、Gitlab、Docker 等 通用性：脚手架、SDK、组件库等框架设计 应用框架：Hybrid 混合、微前端、BFF、Monorepo 可视化： 低代码：通用表单设计、通用布局设计、通用页面设计、JSON Schema 协议设计等 测试：E2E 测试、单元测试、测试覆盖率、测试报告等 业务：数据、体验、复杂度、监控 工程化 150、你所知道的 CI / CD 工具有哪些？在项目中有接触过类似的流程吗？ 151、如果让你实现一个 Web 前端的 CI / CD 工程研发平台，你会如何设计？ 152、如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？ 153、如何使用 Vue CLI 3.x 定制一个脚手架？比如内部自动集成了 i18n、 axios、Element UI、路由守卫等？ 154、Jenkins 如何配合 Node.js 脚本进行 CI / CD 设计？ 通用性 155、如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？ 156、如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？ 157、假设你自己实现的 React 或 Vue 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？ 158、在设计工具库包的时候你是如何设计 API 文档的？ 应用框架 159、谈谈 Electron、Nw.js、CEF、Flutter 和原生开发的理解？ 160、谈谈桌面端应用中 HotFix 的理解？ 161、你觉得什么样的场景需要使用微前端框架？ 业务 162、什么是单点登录？如何做单点登录？ 163、如何做一个项目的国际化方案？ 164、如何做一个项目的监控和埋点方案？ 165、如何建设项目的稳定性（监控、灰度、错误降级、回滚\u0026hellip;）？ 166、一般管理后台型的应用需要考虑哪些性能方面的优化？ 167、简述一些提升项目体验的案例和技术方案（骨架屏、Loading 处理、缓存、错误降级、请求重试\u0026hellip;）？ 168、假设需要对页面设计一个水印方案，你会如何设计？ 低代码 169、如何设计一个通用的 JSON Schema 协议使其可以动态渲染一个通用的联动表单？ 170、一般的低代码平台需要具备哪些能力？ 笔试实践 笔试更多的是考验应聘者的逻辑思维能力和代码书写风格，主要包含以下几个方面：\n正则表达式 算法 数据结构 设计模式 框架的部分原理实现 TypeScript 语法 模板解析 数据结构 171、使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 扁平数据 [{ name: \u0026#39;文本1\u0026#39;, parent: null, id: 1, }, { name: \u0026#39;文本2\u0026#39;, id: 2, parent: 1 }, { name: \u0026#39;文本3\u0026#39;, parent: 2, id: 3, }] // 树状数据 [{ name: \u0026#39;文本1\u0026#39;, id: 1, children: [{ name: \u0026#39;文本2\u0026#39;, id: 2, children: [{ name: \u0026#39;文本3\u0026#39;, id: 3 }] }] }] 复制代码 模板解析 172、实现一个简易的模板引擎 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const template = \u0026#39;嗨，{{ info.name.value }}您好，今天是星期 {{ day.value }}\u0026#39;; const data = { info: { name: { value: \u0026#39;张三\u0026#39; } }, day: { value: \u0026#39;三\u0026#39; } }; render(template, data); // 嗨，张三您好，今天是星期三 复制代码 设计模式 173、简单实现一个发布 / 订阅模式 正则表达式 174、匹配出字符串中 const a = require(\u0026lsquo;xxx\u0026rsquo;) 中的 xxx ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%92%89%E9%92%89%E9%9D%A2%E8%AF%95/","summary":"基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECM","title":"钉钉面试"},{"content":"前言 类与实例：\n类的声明\n生成实例\n类与继承：\n如何实现继承：继承的本质就是原型链\n继承的几种方式\n类的定义、实例化 类的定义/类的声明 方式一：用构造函数模拟类（传统写法）\n1 2 3 function Animal1() { this.name = \u0026#39;smyhvae\u0026#39;; //通过this，表明这是一个构造函数 } 方式二：用 class 声明（ES6的写法）\n1 2 3 4 5 class Animal2 { constructor() { //可以在构造函数里写属性 this.name = name; } } 控制台的效果：\n实例化 类的实例化很简单，直接 new 出来即可。\n1 console.log(new Animal1(),new Animal2()); //实例化。如果括号里没有参数，则括号可以省略 继承的几种方式 继承的本质就是原型链。\n继承的方式有几种？每种形式的优缺点是？这些问题必问的。其实就是考察你对原型链的掌握程度。\n方式一：借助构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function Parent1() { this.name = \u0026#39;parent1 的属性\u0026#39;; } function Child1() { Parent1.apply(this) this.type = \u0026#39;child1 的属性\u0026#39;; } function Boss() { Child1.call(this) this.title = \u0026#39;我是boss\u0026#39;; } console.log(new Child1) // Child1 {name: \u0026#39;parent1 的属性\u0026#39;, type: \u0026#39;child1 的属性\u0026#39;} console.log(new Boss); //Boss {name: \u0026#39;parent1 的属性\u0026#39;, type: \u0026#39;child1 的属性\u0026#39;, title: \u0026#39;我是boss\u0026#39;} 【重要】Parent1.call(this) :让Parent的构造函数在child的构造函数中执行。改变this的指向，parent的实例 \u0026ndash;\u0026gt; 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。\n分析：\n这种方式虽然改变了 this 的指向，但是Child1 无法继承 Parent1 的原型。也就是说，如果我给 Parent1 的原型增加一个方法，这个方法是无法被 Child1 继承的，如下：\n1 2 Parent1.prototype.say = function () { }; 方法二：通过原型链实现继承 1 2 3 4 5 6 7 8 function Parent() { this.name = \u0026#39;Parent 的属性\u0026#39;; } function Child() { this.type = \u0026#39;Child 的属性\u0026#39;; } Child.prototype = new Parent(); //【重要】 console.log(new Child()); // 打印结果：\n【重要】每个函数都有prototype属性，我们把Parent的实例赋值给了Child的prototype，从而实现继承。此时，Child构造函数、Parent的实例、Child的实例构成一个三角关系。于是：\nnew Child.__proto__ === new Parent()的结果为true 分析：\n这种继承方式，Child 可以继承 Parent 的原型 缺点是：如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变。 如下：\n上面的代码中， child1修改了arr属性，却发现，child2的arr属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。\n造成这种缺点的原因是：child1和child2共用原型。即：chi1d1.__proto__ === child2__proto__是严格相同。而 arr方法是在 Parent 的实例上（即 Child实例的原型）的。\n方式三：组合的方式：构造函数 + 原型链 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 组合方式实现继承：构造函数、原型链 */ function Parent3() { this.name = \u0026#39;Parent 的属性\u0026#39;; this.arr = [1, 2, 3]; } function Child3() { Parent3.call(this); //【重要1】执行 parent方法 this.type = \u0026#39;Child 的属性\u0026#39;; } Child3.prototype = new Parent3(); //【重要2】第二次执行parent方法 var child = new Child3(); 优点：既可以继承父类原型的内容，也不会造成原型里属性的修改。 缺点：让Parent的构造方法执行了两次。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/05-02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","summary":"前言 类与实例： 类的声明 生成实例 类与继承： 如何实现继承：继承的本质就是原型链 继承的几种方式 类的定义、实例化 类的定义/类的声明 方式一：用构造函数","title":"面向对象：类的定义和继承的几种方式"},{"content":" 有时在面试时，我都替候选人着急——候选人完全可以在面试前准备\n转眼人到中年：前端老程序员无法忘怀的一次百度电话面试\n八年前的面经，咋记得这么清楚？\n16年毕业的前端er在杭州求职ing\n2018秋招前端总结\n前端开发面试题(CSS)\n超过20家的前端面试题\n来聊聊前端工程师的面试套路\n我的前端进阶之路（面试题）\n这几个链接里讲到了 less。听说面试爱问 less 和 Sass的区别。\n记录前端的面试日常(持续更新)\n我遇到的前端面试题2017\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E7%BB%8F%E9%93%BE%E6%8E%A5%E6%8E%A8%E8%8D%90/","summary":"有时在面试时，我都替候选人着急——候选人完全可以在面试前准备 转眼人到中年：前端老程序员无法忘怀的一次百度电话面试 八年前的面经，咋记得这么清楚","title":"面经链接推荐"},{"content":"写简历的注意事项 最多可以写“深入了解”，但不要写“精通”。 遇到不知道的问题，该怎么回答 这块儿我没了解过，准备回去看一下。\n这块儿我没研究过，您有没有好的资料，我可以补充一下细节。\n写不出详细的代码，但是知道思路。\n项目经历 面试要体现项目的设计思路、方案设计等 模块化思维 （1）模块化设计的关键词：封装、继承；把通用的模块先抽象，后具体，达到复用。【面试记住】\n比如，panel、按钮、轮播图、列表等等，都可以提取为抽象的组件，复用。\n（2）页面有哪几个模块\n（3）每个模块分成不同的文件，然后在index页面中import。\nES6新特性 let、const\n函数扩展：参数默认值、箭头函数、扩展运算符...\nfor of 循环\nmap\n模块化\n薪资 面试官；\u0026ldquo;你要求多少薪资？\u0026rdquo;\n我：“能给个范围吗？”\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/","summary":"写简历的注意事项 最多可以写“深入了解”，但不要写“精通”。 遇到不知道的问题，该怎么回答 这块儿我没了解过，准备回去看一下。 这块儿我没研究过，您","title":"面试技巧"},{"content":"1、http 和 https 的基本概念 http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。\nhttps:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。\nhttp 明文传输，数据未加密，安全性较差，https（http+ssl）数据传输过程是加密的，安全性较好。 http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 https 缓存不如 http 高效，会增加数据开销。 Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。 2、http 请求跨域问题 同源：如果两个页面的域名、协议、端口都相同，则两个页面具有相同的源。 同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能。也就是说浏览器只允许访问同一个源下的服务器资源，限制访问不同源下的资源，以防止潜在的恶意文件。\n如果非同源，共有三种行为受到限制： 1）Cookie、LocalStorage 和 IndexDB 无法读取。 2）DOM 无法获得。 3）Ajax请求不能发送\n解决方案：\nnginx反向代理 CORS CORS(Cross-origin resource sharing)跨域资源共享，服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。 JSONP 3、TCP和UDP的区别 TCP 是面向连接的、可靠的流协议，UDP是面向无连接、不稳定的流协议。流就是指不间断的数据结构 TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能（一对多，多对多，多对一）。 TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。 UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。 区别 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持单播、多播、广播的功能（一对一、一对多、多对一、多对多）交互通信 只能是单播通信，全双工 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅8字节 首部最小20字节，最大60字节 适用场景 无连接 面向连接 是否连接 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 4、TCP连接需要三次握手 第一次握手，客户端向服务端发送连接请求报文段 SYN，客户端便进入 SYN-SENT 状态。 第二次握手，服务器端接收后，如同意连接，返回报文SYN + ACK，发送完成后进入 SYN-RECEIVED 状态。 第三次握手，当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e31a7d17a013430faf01a4830bd7fda3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\n为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 5、TCP断开链接需要四次握手 第一次握手，客户端A认为数据发送完成，向服务器端B发送连接释放请求。 第二次握手，B收到连接释放请求后，会告诉应用层释放TCP链接，然后发送ACK包，并进入CLOSE_WAIT状态，此时A到B的连接已经释放，不再接受A发的数据。因为TCP连接是双向的，所以B仍旧可以发送数据给A 第三次握手，B此时如有未发完数据会继续发送，完毕后会向A发送连接释放请求，并进入LAST_ACK状态。 第四次握手，A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间 ，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 6、cookie、sessionStorage、localStorage的区别 cookie 可以设置过期时间，sessionStorage 当前浏览器窗口关闭后自动删除，localStorage 永久存储本地（需主动清除） cookie大小4k，sessionStorage和localStorage大小5M cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地 7、从输入URL到页面加载的全过程 首先在浏览器输入URL 查找缓存：浏览器查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如有则显示页面内容，反之则进行下一步。 浏览器缓存：浏览器会记录DNS一段时间，因此，这是第一个地方解析DNS请求； 操作系统缓存 路由器缓存 ISP缓存 DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接。 发起HTTP请求：将TCP三次握手的第三次请求报文作为的发送给服务器 服务器响应请求并返回结果：把对应的html文件发送给浏览器 关闭TCP连接：通过四次挥手释放TCP连接 浏览器渲染：客户端解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为： 构建DOM树 构建CSS规则树 构建render树 布局 绘制 JS引擎解析过程 创建window对象 加载文件 预编译 解释执行 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/1.%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/","summary":"1、http 和 https 的基本概念 http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。 http","title":"面试题库"},{"content":"JavaScript 存储相关：请描述以下cookie、localStorage、sessionStorage的区别 在H5之前，cookie一直都是本地存储的一个重要的方法。直到后面的两个出现了， 就开始用后面的两个做本地存储。\n1、cookie：\n本身用于客户端和服务器端的通信。\n但是它有本地存储的功能，于是就被“借用”。\n我们可以通过document.cookie获取和修改cookie，获取到的其实就是一个字符串。\ncookie用于存储时的缺点：\n存储量太小，只有4kb\n所有http请求都带着，会影响获取资源的效率\napi简单，需要封装才能用。document.cookie = ...\nfor each、for in、for of的区别 foreach用于遍历数组，是数组的一个方法。不支持 return。\nfor in获取对象里属性的键。\nfor of获取对象里属性的值。\n网络相关 浏览器输入url到显示内容，有哪些过程 （1）浏览器解析url。包括：协议、域名、端口号、资源路径、参数查询\n（2）DNS解析\n（3）TCP握手\n（4）HTTP请求\n（5）服务器处理请求\n（6）浏览器渲染：DOM tree、CSS rule tree、render tree。\n（7）display\n参考链接：\n笔记：阿里、网易、滴滴共十次前端面试碰到的问题\nwhat-happens-when-zh_CN\n码农翻身 | 小白科普：从输入网址到最后浏览器呈现页面内容，中间发生了什么？\n从输入URL到页面加载发生了什么：https://segmentfault.com/a/1190000006879700\nGitHub [荐]面试题和答案：https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers\n面试题和答案：https://github.com/qiu-deqing/FE-interview\n有个题是，浏览器输入url，有哪些过程\n讲到了Cookie和session\n这个也很全：https://github.com/gnipbao/Front-end-Interview-questions\nhttps://github.com/giscafer/front-end-manual/issues/3\nweb前端面试题汇总：https://www.jianshu.com/p/2f7eb1ad7174\n2017前端面试题及答案总结：https://yeaseonzhang.github.io/2017/09/17/2017%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%80%BB%E7%BB%93/\n今日头条一面笔试面试题！！！！！完整\nCommonJS、RequireJS(AMD) SeaJS（CMD）区别 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/","summary":"JavaScript 存储相关：请描述以下cookie、localStorage、sessionStorage的区别 在H5之前，cookie一直都是本地存储的一","title":"面试题整理"},{"content":"sass sass变量 $variablename: value;\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $myFont: Helvetica, sans-serif; $myColor: red; $myFontSize: 18px; $myWidth: 680px; body { font-family: $myFont; font-size: $myFontSize; color: $myColor; } #container { width: $myWidth; } sass作用域 Sass 变量的作用域只能在当前的层级上有效果\n1 2 3 4 5 6 7 8 9 10 $myColor: red; h1 { $myColor: green; // 只在 h1 里头有用，局部作用域 color: $myColor; //green } p { color: $myColor; //red } sass !global !global 关键词来设置变量是全局的\n1 2 3 4 5 6 7 8 9 10 $myColor: red; h1 { $myColor: green !global; // 全局作用域 color: $myColor; // green } p { color: $myColor; // green } sass嵌套规则 1 2 3 4 5 6 7 8 9 10 nav { ul {} li {} a {} } //类似于 nav ul{} nav li{} nav a{} sass嵌套属性 1 2 3 4 5 6 7 8 9 10 font:{ family: Helvetica, sans-serif; size:16px; weight:bold; } //类似于 font-family: Helvetica, sans-serif; font-size: 18px; font-weight: bold; @import Sass @import 指令语法如下： @import filename;\n在 standard.scss 文件中使用 @import 指令导入 reset.scss 文件：\n1 @import \u0026#34;reset\u0026#34;; //将会合并两个文件的css sass Partials 如不希望将一个 Sass 的代码文件编译到一个 CSS 文件，将sass文件名开头加上下划线 _filename;\n创建一个 _colors.scss 的文件，但是不会编译成 _colors.css 文件\n1 2 3 4 // colors.scss $myPink: #EE82EE; $myBlue: #4169E1; $myGreen: #8FBC8F; 要导入该文件，则不需要使用下划线\n1 @import \u0026#34;colors\u0026#34;; **注意：请不要将带下划线与不带下划线的同名文件放置在同一个目录下，否则带下划线的文件将会被忽略。比如，_colors.scss 和 colors.scss 不能同时存在于同一个目录下，_colors.css文件会被忽略。\n@minxin和 @include @mixin 指令允许我们定义一个可以在整个样式表中重复使用的样式。 @include 指令可以将混入（mixin）引入到文档中。\n控制指令 条件语句（ @if ） 当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码：\n1 2 3 4 5 p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 \u0026lt; 3 { border: 2px dotted; } @if null { border: 3px double; } } 编译为\n1 2 3 p { border: 1px solid; } @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。 如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @mixin txt($weight) { color: white; @if $weight == bold { font-weight: bold; } @else if $weight == light { font-weight: 100; } @else { font-weight: normal; } } .txt1 { @include txt(bold); } 编译为\n1 2 3 4 .txt1 { color: white; font-weight: bold; } 4.2 循环语句 @for @for 指令可在限制的范围内重复输出格式，每次按要求输出结果做出变动。 包含两种格式：@for $var from \u0026lt;start\u0026gt; through \u0026lt;end\u0026gt;，或 @for $var from\u0026lt;start\u0026gt; to \u0026lt;end\u0026gt;； 区别： through 与 to 的含义：当使用 through 时，条件范围包含 \u0026lt;start\u0026gt; 与 \u0026lt;end\u0026gt; 的值， 而使用 to 时条件范围只包含 \u0026lt;start\u0026gt; 的值不包含 \u0026lt;end\u0026gt; 的值。 另外，$var 可以是任何变量，如 $i；\u0026lt;start\u0026gt; 和 \u0026lt;end\u0026gt; 必须是整数值。\n1 2 3 @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } 编译为\n1 2 3 4 5 6 7 8 9 .item-1 { width: 2em; } .item-2 { width: 4em; } .item-3 { width: 6em; } @while @while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。\n1 2 3 4 5 $i: 6; @while $i \u0026gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } 编译为\n1 2 3 4 5 6 7 8 9 .item-6 { width: 12em; } .item-4 { width: 8em; } .item-2 { width: 4em; } @each @each 指令的格式是 $var in \u0026lt;list\u0026gt;, $var 可以是任何变量名。如 $length 或 $name，而 \u0026lt;list\u0026gt; 是一连串的值，也就是值列表。 @each 将变量 $var 作用于值列表中的每一个项目，然后输出结果。\n1 2 3 4 5 @each $animal in puma, sea-slug, egret, salamander { .#{$animal}-icon { background-image: url(\u0026#39;/images/#{$animal}.png\u0026#39;); } } 编译为\n1 2 3 4 5 6 7 8 9 10 11 12 .puma-icon { background-image: url(\u0026#39;/images/puma.png\u0026#39;); } .sea-slug-icon { background-image: url(\u0026#39;/images/sea-slug.png\u0026#39;); } .egret-icon { background-image: url(\u0026#39;/images/egret.png\u0026#39;); } .salamander-icon { background-image: url(\u0026#39;/images/salamander.png\u0026#39;); } ","permalink":"https://bablvsj.github.io/posts/interview/css/css---sasslessscss/","summary":"sass sass变量 $variablename: value; 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $myFont: Helvetica, sans-serif; $myColor: red; $myFontSize: 18px; $myWidth: 680px; body { font-family: $myFont; font-size: $myFontSize; color: $myColor; } #container { width: $myWidth; } sass作用域 Sass 变量的作用域只能在当前的","title":"css---sass、less、scss"},{"content":"lazyload 用的最多的场景是：\n图片lazyload\n组件lazyload\n现在一般都单独做css的lazyload或者js的lazyload，因为这种方式，其实还是要加载图片和组件。\n图片lazyload 图片一般是页面最大的资源，所以非首屏延迟加载很重要（让首屏尽快显示）。\n防抖动（Debouncing）和节流阀（Throtting） 参考链接：\n实例解析防抖动（Debouncing）和节流阀（Throttling） ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/lazyload%E9%98%B2%E6%8A%96%E5%8A%A8%E5%92%8C%E8%8A%82%E6%B5%81%E9%98%80/","summary":"lazyload 用的最多的场景是： 图片lazyload 组件lazyload 现在一般都单独做css的lazyload或者js的lazyload，因为这种方式","title":"lazyload\u0026防抖动和节流阀"},{"content":"前端性能优化认知 什么是前端性能优化 通常来讲，前端性能优化是指：从用户开始访问网站到整个页面完整地展现出来的过程中，通过各种优化策略和优化方法，让页面加载得更快，让用户的操作相应更及时，给用户更好的使用体验。\n优化是在做什么：\n如上图所示，优化工作是围绕前端的基本工作原理展开的，包括：客户端和服务器端建立连接、加载资源、解析资源并渲染。\n上方图片的来源：\nThe Cost Of JavaScript [译]JavaScript 的时间消耗 性能优化的重要性（程序员角度） 当领导问：“为什么网页访问这么慢？”我们不能只是回答“网络不好”这么简单，网络不可能一直都不好。\n每个程序员如果想要成长，就不能回避“性能优化”这个话题。很多人写了多年的代码，一直在构建样式、写业务逻辑。但是平凡的程序员之路，何时才是尽头？前端职业发展的瓶颈在哪儿？怎么才能从团队中脱颖而出？如何区分出平凡程序员/大牛程序员/架构师的分水岭？\n职场晋升时，我们也要想一想：大部分人都在写业务代码，和别人相比，我的核心竞争力在哪里？除了技术深度、前端工程化、综合素质之外，还有其他的吗？性能优化，绝对是不能忽视的一方面。而且它是贯穿于开发和维护的的全过程。\n前端工程化是侧重于提效，具体包括编译打包发布流程、物料中心、组件化等；而前端性能优化是侧重于体验。\n公司评价一个程序员的价值，不是加班越多越好，也不是代码量越多越好，而是看他是否能解决其他人解决不了的一些技术难题或者瓶颈。\n大家都知道性能优化很重要，但是落实到具体，怎么去优化？这就需要我们深入去了解前端技术背后的原理，学习一些主流的前端性能优化技术方案，掌握性能优化技术，提升Web性能，才能总结出相应的优化方案，而且需要多年的经验积累；进而到达前端技术圈的上游，提高自己的核心竞争力。\n前端性能优化面试 性能优化是前端面试的必考问题，面试者在回答这个问题时，大致情况如下：\n70% 的人上来就说减少合并资源、减少请求、数据缓存这些优化手段。\n15% 的人会提到需要在 DevTools 下先看看首屏时间，可以先围绕首屏来做优化。\n10%的人会提到需要接入一个性能平台来看看现状，诊断一下。\n而只有 5% 的人会从前端性能体系来系统考虑性能优化。\n面试官期待的是你在什么场景下，遇到了什么性能问题，围绕什么样的性能指标，采取了哪些性能优化手段，最后取得了什么样的结果，而不仅仅是直接说采取了哪些优化手段。\n比如说，“为什么首页打开慢？”\t面试官期待的是，前端能和后端一样，通过查日志和数据就能定位问题，而不是停留在猜测层面。但在实际当中，能做到这点的前端同学并不多。\n那么，前端有没有这样的工具呢？有，那就是性能监控平台。平台上面有各个业务的性能指标及其对应场景下的性能标准，一旦遇到性能问题，就能直接判断当前性能数据有没有问题，然后提示问题是出在前端、后端，还是网络层。\n性能优化的意义 1、随着互联网的发展，网页的内容越来越丰富，功能越来越强大，页面也越做越漂亮；带来的问题是，访问速度和体验会收到影响。只有对网站进行持续不断的优化，才能保证网页的访问速度可以跟得上用户体验的需求。\n2、高性能可以带来更高的用户参与度、用户留存，进而带来更高的转化率和SEO排名，更好的用户体验，最终带来更高的业务收益。\n随着时间的推移，如果一个网站由于各种原因导致心梗越来越差，以至于用户每打开一个页面都要等待很长时间，甚至出现加载失败的情况，那么，不仅新用户不会沉淀下来，老用户也会纷纷离去，最终导致产品的加速衰败。\n而且网站的加载快慢，最产品收入有着直接的影响。有数据表明：网页加载时间在5秒内的网站比加载时间为19秒的网站，广告收入会增加近一倍。也就是说，网站或者App的性能直接关系到产品的用户增长和收入增长。\n正因为如此，我们才需要通过性能优化的技巧，并结合其他的技术手段来不断提高网站和App的用户体验，从而助力公司的业务增长；同时，我们也可以借此提升自己的技术实力，这对个人的职业成长也会以后很大的帮助。\n3、只要产品上线了，随着业务规模量和用户访问量的扩大，性能优化就是不可回避的话题。在遇到性能问题时，有些人的解决办法是：用一些粗糙的手段把问题绕过去，但却给后面的人埋下了坑。这些人常说的依据口头禅是：\n相关案例 Amazon发现每100ms延迟导致1%的销量损失。\n歌地图首页文件从100KB减少到70KB，流量在第一周涨了10%，在接下来的三周涨了25%。\n腾讯根据长期数据监控发现，页面一秒钟延迟会造成页面访问量下降9.4%，跳出率增加8.3%，转化率下降3.5%。\n如何学习性能优化 学习难点 我们在网上找到的文章，有很多都只是对CSS、JS技术本身的优化，一旦涉及到App、后端、网络等不是很熟悉的领域，学习起来就比较困难了。结合具体业务开发的应用场景时，却不知从何下手。因此，我们需要要由点及面，学习全链路前端性能优化的知识体系和解决方案。\n在实际工作当中，前端性能优化往往比较繁杂，学习难点主要体现在以下几个方面：todo\n优化标准 我们在做优化时，需要有一个量化标准，比如：\nloading 要做到什么效果、动画要达到什么效果才是好的？\n所有的事件处理，要在什么时间内完成，才能给用户良好的体验？\n技术储备前提 掌握前端基础知识。\n具备Web开发实战经验。\n寻找性能瓶颈 了解性能指标，多快才算快。\n利用测量工具和API\n优化问题，重新测量。持续迭代。\n移动端挑战多 移动端的硬件不如PC端，且网络不稳定。\n屏幕尺寸和交互方式都是挑战。\n移动端用户更佳缺乏耐心。而且，很多用户是利用碎片化时间访问网页。数据参考： \u0026gt;3秒的加载时间，导致 53%的跳出率（bounce rate）。\n持续增长的移动端用户和电商业务。现在很多事情都是在移动端做的。\n收获 由浅入深：解读优化技术内幕。\n流行+经典：了解技术背后的设计思想。\n了解性能优化的关键环节，升级知识储备。\n理论+实践：掌握前端业界的流行且成熟的多种性能优化技术，脱颖而出。\n了解大厂正在用的生产环境级别的高性能解决方案。\n前端性能优化全过程 1、静态资源优化 静态资源优化包括html、css、js、图片等资源的性能优化。包括：\n图片的应用场景和使用\nhtml、css、js的具体优化策略\n资源文件的优化：比如文件压缩合并策略、打包方案、版本号更新方案\n前端工程化工具等。\n2、页面渲染架构设计及相关的技术方案选型 按照技术方案的分类，包括：\n前后端分离技术\nSPA单页应用\nBigPipe\n同构直出\nPWA\n页面加载策略\n接口服务调优、接口缓存策略\n大型网站背后的实际性能优化案例\n前端组件化、模块化，加速业务开发\n3、原生App优化、混合开发优化 浏览器的整体优化方案。比如导航条、登录态、滚动条优化等。\n前端缓存策略和优化\nH5静态资源请求代理的技术原理\nH5离线技术，达到页面秒开的目标\n混合式开发解决方案\nRN、小程序、flutter等\n4、服务端与网络优化 CDN 和 DNS 优化\n如何减少 http 请求数、减少cookie大小\nnginx缓存配置和优化\n开启和配置 gzip 压缩\n如何开启全站 https\n升级 Http2.0 的好处和方法\n5、研发流程优化 技术调用的方法\n前后端接口约定、加快前后端接口联调\n前端自动化测试\n自动化部署和上线\n从研发的整体流程层面梳理出提升研发效率的方式和方法。\n6、全链路质量监控体系建设 主要是对性能优化的结果进行衡量、打分、考核：\n上线前，页面质量及时检测\n上线后，页面性能和错误监控\n线上运行时，页面的可用性监控\n愿生App的性能和错误监控\n前端性能优化包括哪些方面 1、性能优化指标与测量工具 行业标准\n优化模型\n性能测量工具：了解性能情况，并对比\n性能相关APIs\n2、渲染优化 现代浏览器的渲染原理\n可优化的渲染环节和方法\n3、代码优化 JS优化：了解JS的开销、解析、优化方案，以及如何配合V8引擎做更有效的优化。\nhtml优化\ncss优化\n4、资源优化 压缩合并\n图片格式\n图片加载\n字体优化\n5、构建优化 webpack 优化配置\n代码拆分\n代码压缩\n持久化缓存\n监测与分析\n按需加载\n6、传输和加载优化 gZip\nKeepAlive\nHTTP缓存\nService Worker\nHTTP/2\nSSR 服务端渲染\nNginx\n7、更多主流优化方案 SVG 优化图标\nFlexBox 布局\n预加载\n预渲染\n窗口化提高列表性能\n骨架屏\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/00-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%AE%A4%E7%9F%A5/","summary":"前端性能优化认知 什么是前端性能优化 通常来讲，前端性能优化是指：从用户开始访问网站到整个页面完整地展现出来的过程中，通过各种优化策略和优化方法","title":"前端性能优化认知"},{"content":"性能指标和优化目标之：加载 性能指标：我们在性能优化过程中可以参考的标准。这些标准都是业界或者前人总结出来的指导性经验。我们可以参考这些指标，去指导我们自己的优化。\n打开网站的初体验 我们以淘宝网站为例，按下F12打开浏览器的调试模式。\n上图中，鼠标右键点击“刷新”图标（或者鼠标长按刷新图标，松开鼠标后），会弹出三个选项，我们选择最后一个选项“清空缓存并硬性重新加载”。\n补充：这三个选项都是在调试模式下（按下F12弹出调试面板）才会出现的。\n浏览器的DevTools初印象：\n上图中，打开 chrome 调试工具，点开「设置」icon，下面的四个选项中，除了“Group by frame”之外，其他的三个选项都可以勾选上。\n我们可以看到淘宝网站的一些指标：\n总资源量是 1.3M。 DOM加载完成时间（DOMContentLoaded）：511ms。这是一个很关键的指标。 其他资源的总加载时间是 1.05秒。 我们再来对比一下京东的：\n保存快照 network里的信息挺多，我们可以将其保存下来，留着以后做分析、做对照。\n如上图所示，我们可以在 network 的空白处右键，选择“Save all as HAR with content”，将 network 信息保存为 HAR文件格式。\nHAR是一种标准的Web格式，用户保存性能测试的结果。里面的数据是json格式。\n我们可以使用第三方的 HAR 分析软件来打开 HAR 文件，比如：\nGoogle 提供的 HAR 分析器\nFiddler 抓包工具\n注意，HAR 文件包含了一些敏感信息：\n瀑布图 Waterfall 瀑布图可以非常直观地把网站的加载过程，用自上而下的方式表达出来，就像瀑布一样。\n瀑布图有两中解读方式：一种是横向看，一种是纵向看。\n1、横向看：\n横向看的是具体的资源，每一行代表某个资源的加载信息。里面有一些色块来表达加载的过程，每个块的颜色不同。也就是说资源的下载不是单一的过程，而是经历了很多环节。\n为了了解资源的具体加载过程，我们把鼠标悬浮在第一个资源的色块上，可以看见一个详情列表：\n（1）等待：\nQueueing：排队。浏览器会对资源的请求做优先级排序。 （2）连接：\nDNS Lookup：DNS域名解析。每个资源都有域名，对域名做DNS解析，然后找到对应服务器的IP地址。\ninitial connection：客户端和服务器之间建立TCP连接。\nSSL证书：该网站为了保证安全性，使用了 https 协议，启用了SSL证书。启用之后，需要做安全认证（SSL协商），这个过程也会耗时。到这里位置，我们可以看到，在请求资源之前，有很多的前置步骤。\n（3）请求和响应：\nRequest sent：到这一步，真正开始请求资源。\nWaiting（TTFB）：资源从请求到响应，有一个等待的时间。\nContent Download：收到响应后，资源的下载时间。如果值越大，表明下载时间越长。有些同步加载的资源会造成阻塞，导致网页的整体加载时间过长，让用户等待太久。\nTTFB 是一个很重要的指标，它表示的是：请求发出到响应，到底要经历多久。TTFB 可以给我们一个很直观的感受，我们网站的请求和响应到底是快还是慢，很大程度上是由 TTFB 决定。\n影响 TTFB 的因素是什么呢？比如：\n后台的处理能力的响应速度。\n网络状况：是否有网络延迟。\n2、纵向看：（主要看两点）\n（1）看资源与资源之间的联系：如果发生阻塞，说明资源可能是串行地按顺序加载。可以按需要适当调整为并行。\n（2）看关键的时间节点。Waterfall 中有两根时间线：蓝色的线是 DOM 加载完成的时间，红色的线是所有资源加载完成的时间。\n性能指标和优化目标之：交互 上面的内容讲的是加载的性能，还有一个需要关注的性能指标是交互。也就是网站加载完成后，用户真正开始使用这个网站过程中的的交互体验。\n关于交互体验的性能，我们需要关注的是：\n交互动作的响应时间要短：比如点击按钮后的弹窗、在搜索框里输入关键字后的搜索结果。\n页面滚动要流畅：可以查看 FPS 帧率。\n异步请求接口的完成时间要短：比如关注/取关主播的响应、领取红包的操作。\nFPS帧率、FRS 这里首先科普两个概念：\n刷新率：显示器每秒有多少帧画面。大多数显示器的刷新率是60帧/秒（即60hz）。 帧率（FPS：frames per second）：视频或者动画的内容本身，每秒有多少帧。由显卡输出帧率。 上面的两个参数中，不要把「刷新率」和「帧率」弄混了。「刷新率」是屏幕的参数，「帧率」是图像、视频等内容的参数。人眼最终看到的效果，是以最低的参数为准的。\n目前，市场主流手机和电脑屏幕的刷新率基本都是60Hz，即每秒显示60帧画面。也就是说，当我们在使用手机的时候，本质上是手机在连续播放一张张静态图片，每秒播放60张，让肉眼误认为眼前的画面在动。\n持续滑动的过程中，如果页面输出到显示器的帧率低于60帧/秒，则人眼会感觉卡顿。\n那么，在浏览器中如何实时显示内容的 FPS 参数呢？打开浏览器的控制台后，按住快捷键「Cmd + Shift + P」，然后输入 frame，选择Show frames per second（FPS） meter。如下：\n温馨提示： 从 2020年7月起，chrome 官方已经取消了 fps参数的显示，改为了 FRS：\nFRS参数观察的是丢帧率： Chrome官方给我们提供了下面这个网站，用于观察 FPS 效果：\nhttp://googlesamples.github.io/web-fundamentals/tools/chrome-devtools/rendering-tools/forcedsync.html 如果实在想要看fps，我们可以借助第三方的 chrome 插件来查看 fps参数。\n用 RAIL 模型测量性能 RAIL 模型是Google提出的可以量化性能的测量标准。我们做性能优化时，要尽可能到这个标准。\n在做性能优化的时候，我们需要有人告诉我们：做到多好才算好？有没有一些通用的标准？而 RAIL 模型 可以给我们带来量化的指标。\nRAIL 模型包括四个方面：\nResponse：响应\nAnimation：动画\nIdle：空闲时间\nload：加载\n参考链接：\n[Web翻译]用RAIL模型测量性能\nhttps://web.dev/rail/\nRAIL 的目标：\n让良好的用户体验成为性能优化的目标 接下来，我们再看看看 RAIL 的评估标准。\n1、响应 目标：处理用户发起的响应，应该在 50ms 内完成。\n准则：\n在50毫秒内处理用户输入事件。这适用于大多数输入，如点击按钮、切换表单控件或启动动画。这不适用于触摸拖动或滚动。\n对于需要超过50毫秒才能完成的操作，需要提供反馈。\n如上图所示，Google经过大量研究发现，用户能够接受的最高延时是100ms。所以，从用户发起交互请求（输入任务）后，前端最好能在100ms内给出反馈。\n但是我们的预算只有50毫秒。因为应用程序在接收到输入任务的时候，不一定会马上着手处理，它可能还有其他工作正在进行，这意味着当前的输入任务可能需要排队50ms左右。所以我们真正能处理这个请求的时间，并没有100ms。\n2、动画 目标：在10毫秒或更短的时间内制作出动画中的每一帧。（即：100帧/秒。）\n我们知道，当动画的帧率是 \u0026gt;= 60帧/秒 的时候，人眼才不会觉得卡顿。此时的理论值为 1000毫秒/60帧 = 16.6 毫秒/帧。\n10毫秒和16毫秒之间，隔了6秒。这6秒是什么呢？因为浏览器需要大约6毫秒的时间来渲染每一帧，所以，每一帧的准则建议是10毫秒，而不是 16.6毫秒。\n假设动画本身是60帧/秒，那么，最终渲染出来的效果可能只有 45帧/秒。\n广义的动画：\n动画不仅仅是花哨的UI效果。每一种交互都被认为是动画。比如：\n视觉动画\n滚动\n拖动、平移元素、放大图片等。\n3、空闲时间 目标：最大化闲置时间，增加页面在50毫秒内响应用户输入的几率。\n这个空闲时间，是和上面的第一点“响应”是结合在一起的。只有空闲足够多，当用户的交互来的时候，我们才能有足够的时间进行处理。\n准则：\n利用空闲时间做延迟加载。例如，页面在初始化的时候，尽可能少的加载数据，然后利用空闲时间加载其余部分。\n在空闲时间内处理任务，时间不能超过50毫秒。否则，就阻塞了用户做其他的输入请求，导致卡顿。\n如果用户在闲置时间工作期间与页面进行交互，那么这个交互应始终处于最高优先级，并中断闲置时间工作。\n4、加载 目标：在5秒或更短的时间内加载页面并可以交互。\n准则：\n这里的5秒包括：加载、解析、渲染，并确保用户可以交互。\n加载的过程中，可以使用loading框、进度条、骨架屏等方式缓解用户焦虑。\n使用Chrome DevTools 分析性能 现在主流的性能测量工具：\nChrome DevTools：开发调试、分析性能。\nLighthouse 网站整体质量评估。\nWebPageTest：给网站提供多个地点的测试，以及全面的性能报告。\n这一段，我们先来讲一讲 Chrome DevTools 。\n大家平时在用 Chrome DevTools 的时候，一般使用来开发调试、查看 DOM、css、接口请求等，但其实，这个工具非常强大。\nsize：文件大小分析 可以把size从到小排序，看看哪个资源的文件较大。\n另外，上图中的横线处说明：该文件在网络传输的时候会做压缩（125kb），拿到资源之后再解压还原（526kb）。\nperformance：性能表现 preformance的两个作用：\nRecord button：记录页面加载、用户交互等全过程，直到我们手动点击停止按钮。 Reload button：记录页面从刷新到资源加载完成的过程。会自动停止记录。 参数解读：\nTiming：关键的时间节点。\nMain：主线程做了哪些任务，以及调用关系。\nTiming参数中，尤其注意看DCL（DOMContentLoaded），即DOM加载完成的时间节点。我们可以通过Main参数看看DOM在加载完成之前，都做了些什么事情。很有可能就是这些事情导致 DCL的时间过晚。\n我们可以翻到Main里的最后一行（即最终调用的位置），往往这个位置就是我们自己写的代码。\nDiable cache 上图中的Diable cache是一个很重要的设置选项。\n勾选Diable cache：\n不走缓存，相当于页面初次访问。 如果你希望改的代码立即生效，就一定要勾选上。 不勾选Diable cache：\n走缓存，相当于页面二次、三次访问。 很多时候，我们需要关心用户在第二次、第三次访问时候，他的访问速度如何、性能如何、我们设置的缓存有没有生效。此时就不要勾选上。 模拟网络情况 模拟网络状况（自定义参数）：\nPerformance monitor 快捷键ESC 按住快捷键ESC，会列出其他常用的功能菜单：\n使用LightHouse分析性能 我们之所以使用不同的性能测量工具，是因为他们都有不同的特点。这一段要讲的 lighthouse 既可以帮我们生成简易的测试报告，还可以给出一些针对性的优化建议。后面要讲的 WebPageTest 可以帮我们生成详细的性能测试报告。\n我们先来看看 Lighthouse。\nLighthouse 介绍 lighthouse 是 chrome 浏览器的一个性能测量工具。我们先来看看它的性能指标，至于它具体使用，后续的内容再详细介绍。\n淘宝跑分举例：\n京东跑分举例：\nLighthouse 跑分里，最重要的两个指标如下：\nFirst Contentful Paint（白屏时间）：**从白屏到第一次出现内容的时间。**我们可以看到，上面提供了一些加载过程的截图，10屏里如果只有1到2屏是白屏，说明体验还是可以的。\nSpeed Index：速度指数。\n我们不需要关心这个指数是怎么来的，因为背后涉及一套很复杂的公式，我们暂时只需关注这个数值。\nSpeed Index 标准为4秒（超过4秒算比较慢的），我们测的淘宝的 speed index 是0.5s，很快了。但我们要结合网站本身的业务来权衡。并不是分数越高性能越高，比如百度这样的网站，页面上的内容很少，测出来的分数肯定很完美。而淘宝需要展示很多内容给用户看。所以，这个指标只是一个指导作用，并不一定能够达到最优的数值。\nLighthouse 的分析结果里，也给出了颜色标注：\n红色：比较严重的性能问题 黄色：需要做适当优化 绿色：说明性能表现很好。 另外，Lighthouse 还会给出一些优化建议：\nOpportunities:优化建议。\nDiagnostics：问题诊断。\nPassed audits：表示这部分没有问题。\n举例：确认某个JS 是否必须在首屏加载 就拿B站来举例，来看看它的lighthouse报告：\n上图中给出了一个优化建议：有些JS文件不是首屏加载必须的。\n我们随便拿一个JS文件来测试（比如上图中，Header标签里的JS文件）。做法如下：\n如上图所示，在 chrome 控制台输入快捷键「Cmd + Shift + P」，然后输入文本block，选择Show Network request blocking：\n按照上面的步骤添加规则，点击add后，效果如下：\n然后，我们切换到控制台的 network面板，并刷新页面：\n然后观察这个js资源是不是首屏加载所必须的。但我们也不能就此定论说这个资源一定可以延迟加载，也许它就是想让页面在一开始loading的时候就捕获日志。\n对于我们自己的网站，这个资源是首屏加载必须的吗？一定要在第一时间加载吗？需要根据特定的业务做衡量。\n通过npm运行 Lighthouse工具 1 2 3 4 5 6 7 8 9 # 安装 npm install -g lighthouse # 执行 lighthouse https://www.jd.com # 输出性能检测报告 Generating results... html output witten to /Users/smyh/Documents/wpt-mac-agent/www.jd.com._2021-01-16_09-00-00.html 使用 WebPageTest 评估网站性能 程序员经常说的有句话是：“我这儿能打开啊。我这儿不报错呀。”大家应该都懂这个梗，这就是为什么，我们要借助第三方的测试工具，而不仅仅只是自己电脑上访问正常就ok了。\n我们需要借助 WebPageTest 这样的第三方测试工具，去模拟各种用户的真实场景。\nWebPageTest 使用 网址：https://www.webpagetest.org\nWebPageTest 在世界各地提供了非常多的服务器，在每个服务器上部署了不同的浏览器，可以让我们有针对性的做测试。如果你做的是一款国际化网站，那更有必要使用一下了。\n我们以JD网站举例：\n按照上面的选项配置完成后，点击右侧的「Start Test」即可开始测试。然后等待：\nWebPageTest 报告分析 淘宝网站性能测试报告：\n2020年6月：https://webpagetest.org/result/200616_JK_78eebda338285ffe0c2e154ca5032839/\n2021年1月：https://www.webpagetest.org/result/210115_DiCB_f1344d732760365151755e89765b2d37/\nJD网站性能测试报告：\n2021年1月：https://www.webpagetest.org/result/210115_DiGT_8d7370e91230b7d077e40b7aafb485a5/ 拿到 WebPageTest 报告之后，我们来看看报告里的几个重点指标。\n1、摘要里的参数：（如上图）\nFirst Byte：第一个请求的响应时间。可以反映后台的处理能力，以及网络回路的情况。 Start Render：从白屏到首次渲染的时间。 Speed Index：速度指数。 Total Blocking Time：页面被阻塞，导致用户不能交互的累计时间。 2、详情里的参数：First View。\nFirst View展示的是：首次访问时，总的加载时间。这里面提供的瀑布图，比 chrome DevTools里提供的更为详细。\n点击进入 First View 的详情之后，可以看到：所有的资源请求，都会在这里列出来。如下：\npage is Interactive：页面在加载的过程中，大部分时间段，用户都是可以交互的。这是非常有用的一个指标。 Brower Main thread：浏览器主线程的占用情况。可以看看空闲的时间多不多。 CPU Utilization：CPU的使用情况。 多张图片的资源请求。 上图中，我们可以看到：多张图片的开始请求时间都是相同的。也就是说，如果让资源做并行加载，我们就可以加大地减少加载时间，最终所消耗的时间就由最大的图片来决定。这是一个很好的优化技巧，至于具体是怎么实现的，可以自行了解。\n另外，我们看到，有一部分的请求，被高亮出来了：\n上面这张图的意思是：302表示重定向，也就是说，这个资源已经不在原来请求的位置了，需要重定向才能找到真实的位置。这个地方其实可以做一个优化：\n不需要去访问之前的无效的资源，可以直接去访问重定向后的那个资源。\n局域网部署 WebPageTest 工具 如果我们开发的页面，还没有上线，公网则无法访问。这个时候我们也想通过WebPageTest看看网站的性能，那要怎么办呢？\n我们可以在局域网部署 WebPageTest 工具，具体方法可自行研究。\nchrome插件：PageSpeed Insights 另外，google官方也有一个网址：https://developers.google.com/speed/pagespeed/insights/?hl=zh-cn\n但是这个网站在使用时，经常挂掉。\n这个插件是2018年的，已经好几年没更新了。大家参考即可。\n实时动态测量性能的API Chrome DevTools能够检测各种性能参数，其实也是调用了一些性能相关的标准API。我们自己也可以直接在代码里调用这些api。\n通过 performance对象提供的API，我们可以实时的、精细化、自定义测量性能，获取相应的参数。也可以把这些性能参数，打印到控制台，或者实时上报给后台监控系统。\nperformance：获取常见性能参数 常见性能参数，计算公式如下：\n时间戳1减去时间戳2，得到的差值，就是我们想要看到的耗时。\nDNS 解析耗时: domainLookupEnd - domainLookupStart\nTCP 连接耗时: connectEnd - connectStart\nSSL 安全连接耗时: connectEnd - secureConnectionStart\n网络请求耗时 (TTFB): responseStart - requestStart\n数据传输耗时: responseEnd - responseStart\nDOM 解析耗时: domInteractive - responseEnd\n资源加载耗时: loadEventStart - domContentLoadedEventEnd\nFirst Byte时间: responseStart - domainLookupStart\n白屏时间: responseEnd - fetchStart\n首次可交互时间（TTI）: domInteractive - fetchStart\nDOM Ready 时间: domContentLoadEventEnd - fetchStart\n页面完全加载时间: loadEventStart - fetchStart\nhttp 头部大小： transferSize - encodedBodySize\n重定向次数：performance.navigation.redirectCount\n重定向耗时: redirectEnd - redirectStart\n比如说，如果我们想要获取 TTI参数，代码可以这样写：\n1 2 3 4 5 6 7 8 9 10 // 计算一些关键的性能指标 window.addEventListener(\u0026#39;load\u0026#39;, (event) =\u0026gt; { // Time to Interactive let timing = performance.getEntriesByType(\u0026#39;navigation\u0026#39;)[0]; console.log(timing.domInteractive); console.log(timing.fetchStart); let diff = timing.domInteractive - timing.fetchStart; console.log(\u0026#34;TTI: \u0026#34; + diff); // 打印 TTI 参数 }) 观察长任务 1 2 3 4 5 6 7 const observer = new PerformanceObserver((list) =\u0026gt; { for (const entry of list.getEntries()) { console.log(entry) } }) observer.observe({entryTypes: [\u0026#39;longtask\u0026#39;]}) 页面可见性的状态监听 使用场景举例：\n比如说，我们正在做一个视频网站（或者游戏页面）。如果用户当前没有在看这个视频，而是切换别的页面了。此时，我们可以对视频做节流等处理，避免造成性能的浪费。等用户再回到当前页面之后，再恢复之前的状态。 当设备进入待机模式时（用户按下电源键关闭屏幕），网站想要关闭设备声音。 针对这种场景，我们可以使用visibilitychange进行监听：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 见面可见性的状态监听 let vEvent = \u0026#39;visibilitychange\u0026#39;; if (document.webkitHidden != undefined) { // webkit prefix detected vEvent = \u0026#39;webkitvisibilitychange\u0026#39;; } function visibilityChanged() { if (document.hidden || document.webkitHidden) { console.log(\u0026#34;Web page is hidden.\u0026#34;) } else { console.log(\u0026#34;Web page is visible.\u0026#34;) } } document.addEventListener(vEvent, visibilityChanged, false); 网络状况监听 使用场景举例：\n高清图片按需加载：如果用户的网络条件较好，就加载高清图片资源；如果网络条件不好，就加载文件较小的图片资源。 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection; var type = connection.effectiveType; function updateConnectionStatus() { // type是之前的网络状态，connection.effectiveType是当前最新的网络状态 console.log(\u0026#34;Connection type changed from \u0026#34; + type + \u0026#34; to \u0026#34; + connection.effectiveType); type = connection.effectiveType; } connection.addEventListener(\u0026#39;change\u0026#39;, updateConnectionStatus); 打印结果举例：\n1 Connection type changed from 4g to 3g 检测元素的可见状态，做曝光埋点 我们可以通过IntersectionObserver：这个API来检测元素的可见状态：\n做曝光上报的埋点：判断某个DOM（或者某个楼层）是否出现在视窗中，出现了就收集数据上报给服务端。\n本质就是要计算某一元素和另一元素（视窗）的相对位置/相对可视状态，然后进行一些操作（一般是上报给服务端）。\n参考：\n前端埋点之曝光实现 点击埋点和曝光卖点的封装 ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8C%87%E6%A0%87/","summary":"性能指标和优化目标之：加载 性能指标：我们在性能优化过程中可以参考的标准。这些标准都是业界或者前人总结出来的指导性经验。我们可以参考这些指标，","title":"前端性能分析工具和指标"},{"content":"前言 渲染机制包括的内容：\n什么是DOCTYPE及作用\n浏览器渲染过程。面试经常会问：在浏览器中输入url，发生了哪些事情。其中有一部就是浏览器的渲染过程。\nReflow：重排。面试官问完了渲染机制，一般会紧接着问重排Reflow，你可千万别说你没听过。\nRepaint：重绘\nLayout：布局。这里的Layout指的是浏览器的Layout。\n什么是DOCTYPE及作用 定义 DTD（Document Type Definition）：文档类型定义。\n是一系列的语法规则，用来定义XML或者(X)HTML文件类型。浏览器会使用DTD来判断文本类型，决定使用何种协议来解析，以及切换浏览器模式。（说白了就是：DTD就是告诉浏览器，我是什么文档类型，你要用什么协议来解析我）\nDOCTYPE：用来声明DTD规范。\n一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出现一些差错。（说白了，DOCTYPE就是用来声明DTD的）\n常见的DOCTYPE声明有几种 面试官紧接着会问，常见的 DOCTYPE 有哪些，以及 HTML5 的 DOCTYPE 怎么写。\n1、HTML 4.01 Strict：（严格的）\n1 \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 4.01//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/strict.dtd\u0026#34;\u0026gt; PS：该DTD包含所有的HTML元素和属性，但不包括展示性的和弃用的元素（比如 font、u下划线等，这些是被废弃了的）。\n2、HTML 4.01 Transitional：（传统的）\n1 \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/loose.dtd\u0026#34;\u0026gt; PS：该DTD包含所有的HTML元素和属性，但包括展示性的和弃用的元素（比如 font、u下划线等）。\n3、HTML 5：\n1 \u0026lt;!DOCTYPE html\u0026gt; 总结：\n面试时，不会让你写出 HTML 4.01的写法，因为大家都记不住。但是要记住 HTML 5 的写法，别看它简单，知道的人还真不多。\n面试时，可以这样回答： HTML 4.01 中有两种写法，一种是严格的，一种是传统的；并且答出二者的区别。 HTML 5的写法是\u0026lt;!DOCTYPE html\u0026gt;。\n浏览器的渲染过程 渲染树 上方图片的来源：Google 官方 | 渲染树构建、布局及绘制\n渲染树包含了网页中有哪些节点、节点的从属关系、以及节点的CSS样式（大小、颜色等）。\n浏览器下载完html文档之后，第一步是先将其解析成文本。而html标签是由一对一对的尖括号表述的，可以被浏览器解析为有含义的标记。这些标记被翻译成节点对象，存放到链型数据结构中。这些节点被称之为DOM对象，这个链型数据结构就是渲染树。\n渲染过程（重要） 浏览器的渲染过程非常复杂，面试时找重点说就行，不然太耗时间。如何快速简洁地描述清楚，是关键。来看看下面这张图。\n渲染过程中，涉及到以下几个概念：\nDOM树（DOM Tree）：浏览器将HTML标签解析成树形的数据结构。DOM树包含了有哪些节点，以及节点之间的从属关系（嵌套关系）。\nCSSOM（CSS Rule Tree）：浏览器将CSS解析成树形的数据结构。CSSOM包含了节点的CSS样式（大小、颜色等）。\n渲染树（Render Tree）: DOM 树与 CSSOM 树合并后形成渲染树。渲染树只包含渲染网页所需的节点（但并不知道位置）。\n布局（Layout）: 计算出每个节点在屏幕中的位置和大小。\n绘制（Painting）：按照算出来的规则，通过显卡，把内容画出来。\ncomposite：合成。浏览器在绘制的时候，一开始不会把所有的内容都画在同一层上。需要把这些内容画在不同的曾上，最终合并到一起，并显示在屏幕上。\n参考链接：\n浏览器渲染原理及流程 关键渲染路径 说到渲染，就不得不提到“关键渲染路径”，它描述的是渲染从触发到绘制的过程。浏览器渲染经历了五个阶段：\nJavaScript/CSS \u0026ndash;\u0026gt; Style \u0026ndash;\u0026gt; Layout \u0026ndash;\u0026gt; Paint \u0026ndash;\u0026gt; Composite\n上方图片的来源：https://developers.google.com/web/fundamentals/performance/rendering\n关键渲染路径描述的是渲染从触发到绘制的全过程，一共经历了五个阶段：\n（1）触发视觉的变化：通过JS、CSS代码来触发页面上的视觉变化。比如通过 jQuery添加节点、通过CSS添加动画，都可以触发视觉上的变化。\n（2）Style：浏览器对样式进行计算。匹配选择器，计算哪些CSS受到了影响。\n（3）layout：同上一段。\n（4）painting：同上一段。\n（5）conmposite：同上一段。\n理论上，上面的五个步骤都是必须要经历的。布局和绘制是关键渲染路径中，最重要、开销最高的两个步骤。\n但是，有些样式并不会影响布局，也不会影响绘制。所以，浏览器对这方面的性能进行了优化，并不一定要经历布局和绘制这两个过程。这就需要我们先了解一下「重排」和「重绘」这两个概念。详见下一段。\n布局/回流/重排 定义 布局 layout：\n渲染对象在创建完成并添加到渲染树时，是将DOM节点和它对应的样式结合起来，并不包含位置和大小信息。\n我们还需要通过 Layout 布局阶段，来计算它们在设备视口(viewport)内的确切位置和大小，计算这些值的过程称为回流、布局或重排（Reflow）。\n参考链接：\n从浏览器渲染原理，浅谈回流重绘与性能优化\n你真的了解回流和重绘吗\n什么时候会触发布局 DOM元素的大小和位置发生变化的时候，会触发布局。\n增加、删除DOM元素\ndisplay: none\n移动元素位置，或是增加动画\n修改CSS样式时（宽高、display 为none等，都是通过css样式来修改的）\noffsetLeft、scrollTop、clientWidth\n修改浏览器窗口大小时（即Resize窗口，移动端没有这个问题），或是滚动的时候，有可能会触发（具体要看浏览器的规则）。\n修改网页的默认字体时（这个很消耗性能）。\n面试总结：\n首先要答出 Reflow 定义；其次，什么时候触发，至少要答出两条。更进一步，面试官可能还会问你怎么避免reflow，这个可以自己去查查。\n绘制/重绘 定义 绘制 paint：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程也称之为 Repaint（重绘制）。\n说白了，页面要呈现的内容，统统画在屏幕上，这就叫 Repaint。\n什么时候触发绘制 DOM改动\nCSS改动\n其实，就是判断当视觉上是否发生变化（无论这个变化是通过DOM改动还是CSS改动）。只要页面显示的内容不一样了，肯定要 Repaint。\n面试总结：\n面试官经常会问：“如何尽量减少Repaint的频率？”\n注意， reflow是问“怎么避免”，repaint是问“怎么减少”。Repaint是无法避免的，否则就成了静态页面了。\n答案：\n（1）如果需要创建多个DOM节点，可以使用DocumentFragment创建完，然后一次性地加入document。（加一个节点，就repaint一次，不太好）\n（2）将元素的display设置为”none”，完成修改后再把display修改为原来的值。\n参考链接：如何减少浏览器repaint和reflow ?\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/02-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/","summary":"前言 渲染机制包括的内容： 什么是DOCTYPE及作用 浏览器渲染过程。面试经常会问：在浏览器中输入url，发生了哪些事情。其中有一部就是浏览器的","title":"浏览器渲染机制"},{"content":"浏览器的渲染机制 我们需要先理解浏览器的渲染经历了哪些过程，才能有针对性的进行相关优化。\n掌握浏览器的渲染优化，可以说是前端工程师的一个分水岭。如果想要具备架构师的思维，需要达到什么样的能力？不光是要解决当下的问题，还需要掌握基本的原理，将来在遇到新问题时也能解决，即“预测问题”。\n有一个经典的面试题是：“在浏览器的地址栏输入url，回车后，经历了哪些过程？”这个问题并不简单，根据你回答的详细程度，可以看出你对前后端知识的掌握程度。你能否答出“浏览器的渲染机制”？如果不能，说明你对浏览器渲染的性能优化，不够了解。\n关于浏览器的渲染机制，可以看本教程的另外一篇文章：\n《前端面试/面试必看/浏览器渲染机制.md》\n关键渲染路径举例：\n避免布局抖动（layout thrashing） 1、尽量避免 重排：\n比如说，如果想改变一个元素的位置，很多人可能会使用相对布局的left、top属性，但是这个属性会引起重排。我们可以使用 transfrom:translate让元素做位移，这个属性既不会触发重排，也不会触发 重绘，只会触发 conmposite。\n再比如说，vue、react这样的框架，采用了虚拟DOM，它会把涉及到DOM修改的操作积攒起来，然后统一计算，批量处理，最后应用到真正的DOM上。\n2、读写分离。建议先批量读（获取位置等信息），然后再批量做写操作（修改位置）。\n补充：\n如果你的页面经常需要做重排、重绘，就很容易导致“页面抖动”。\n很多时候，我们知道原理和解决方案。但是在工程化实践的时候，往往时间很紧，没有时间去做这些事情。我们希望有一些拿来就可以用的、而且经过测试没有问题的工具，来帮我们解决问题。\nFastDom是用于做防抖的一个比较流行的解决方案。\n减少重绘（repaint） 防抖（Debounce）：降低事件的触发频率 我们可以针对高频事件做防抖。\n高频事件处理函数：有很多事件的触发频率非常高，甚至超过了屏幕的刷新率（60帧/秒）。比如页面滚动、鼠标移动、移动端的touch事件。\n如果我们不对这些事件做处理，就会频繁导致浏览器做重排、重绘，影响性能，导致页面卡顿，也就是“抖动”。因此需要对这些高频事件处理函数做防抖处理，降低它们的触发频率。\n比如说滚动事件：我其实并不关心滚动中间的过程，我只关心最终滚动到了哪里。\nrequestAnimationFrame 这个api可以做防抖。\n参考文章：\n防抖与节流：https://juejin.cn/post/6885250789825052679 代码优化 JS的开销 静态资源有很多种：js、图片、css、字体等。这些资源都有可能会很大，但是JS的开销仍然是最昂贵的，因为JS除了加载资源之外，还需要经历解析\u0026amp;编译、执行的过程。\n如何缩短JS的解析事件 Web loading is a Journey V8引擎 补充 首屏尽快打开，剩下的内容延迟加载，减少初次加载的资源量。首屏的内容是可以确定的。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03-%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/","summary":"浏览器的渲染机制 我们需要先理解浏览器的渲染经历了哪些过程，才能有针对性的进行相关优化。 掌握浏览器的渲染优化，可以说是前端工程师的一个分水岭。","title":"渲染优化"},{"content":"图片格式和应用场景 JPEG 格式 JPEG（Joint Photographic Experts Group）是一种针对彩色照片而广泛使用的有损压缩图形格式，属于位图。\n常用文件扩展名为.jpg，也有 .jpeg和.jpe。JPEG 在互联网上常被应用于存储和传输照片。\n适合：颜色丰富的照片、彩色图大焦点图、通栏 banner 图；结构不规则的图形。\n不适合：线条图形和文字、图标图形，因为它的压缩算法不太这些类型的图形；并且不支持透明度。\nPNG 格式 PNG（Portable Network Graphics）是一种无损压缩的位图图形格式，支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性。\nPNG 最初是作为替代 GIF 来设计的，能够显示 256 色，文件比 JPEG 或者 GIF 大，但是 PNG 非常好的保留了图像质量。支持 Alpha 通道的半透明和透明特性。最高支持 24 位彩色图像（PNG-24）和 8 位灰度图像（PNG-8）。\n适合：纯色、透明、线条绘图，图标；边缘清晰、有大块相同颜色区域；需要带半透明的图片。\n适合：由于是无损存储，所以不太适合体积太大的彩色图像\n比如说，如果你需要带透明背景的图片，此时就可以用 png 格式的图。\nGIF 格式 GIF（Graphics Interchange Format）是一种位图图形格式，以 8 位色（即 256 种颜色）重现真彩色的图像，采用 LZW 压缩算法进行编码。\n支持 256 色；仅支持完全透明和完全不透明；如果需要带动画效果的图片，GIF 是比较通用的选择。\n适合：动画，图标。\n不适合：每个像素只有 8 比特，不适合存储彩色图片。\nWebp 格式 Webp 是一种现代图像格式，可为图像提供无损压缩和有损压缩，这使得它非常灵活。由 Google 在购买 On2 Technologies 后发展出来，以 BSD 授权条款发布。\nWebp的优秀算法能同时保证图像质量和较小体积；可以插入多帧，实现动画效果；可以设置透明度；采用 8 位压缩算法。\n无损的 Webp 比 PNG 小 26%，有损的 Webp 比 JPEG 小 25-34％，比 GIF 有更好的动画。\n适合：适用于图形和半透明图像。 总结 banner图、大图，可以用 jpg、webp格式。\n图标、带透明背景的图，可以用 png 格式。\n带动画效果的图，可以用 gif 格式。\n图片优化的常见方法 1、用工具压缩图片 压缩 PNG 图片：\n工具：node-pngquant-native\n介绍：跨平台、压缩比特别高，压缩png24非常好。\n安装方法：\n1 npm install node-pngquant-native 压缩 JPEG 图片：\n工具：jpegtran\n官网：https://www.npmjs.com/package/jpegtran\n介绍：跨平台，但压缩的比率只有80-90%。\n安装方法：\n1 npm install –g jpegtran 使用方法：\n1 jpegtran -copy none -optimize -outfile output_file.jpg input_file.jpg 压缩 GIF 图：\n工具：Gifsicle\n官网（含安装方法）：https://www.lcdf.org/gifsicle/\n介绍：Gifsicle 通过改变每帧比例，减小 gif文件大小，同时可以使用透明来达到更小的文件大小，是目前公认的最好的解决方案。\n使用方法：\n1 2 3 4 5 # 压缩命令。注意，这里是将压缩级别设置为3。如果将压缩级别设置为1或者2，则基本不压缩。 gifsicle --optimize=3 -o out_file.gif in_file.gif # 裁掉透明部分 gifsicle --optimize=3 --crop-transparency -o out_file.gif in_file.gif 2、将图片尺寸跟随网络环境进行变化 具体方案：不同网络环境（Wifi/4G/3G）下，加载不同尺寸和像素的图片，通过在图片 URL 中添加参数来改变。\n图片 url 举例1：（图片的原始url链接）\n1 https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg 图片 url 举例2：（通过图片的url参数，将这张图的尺寸设置为200px）\n1 https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg 3、响应式图片 方法1：通过 JavaScript 绑定事件，检测窗口大小，以此设置图片大小。\n方法2：CSS媒体查询。\n代码举例：（在 640px的窗口大小里，设置图片的尺寸为640px）\n1 2 3 4 5 @media screen and (max-width:640px) { my_image{ width:640px; } } 方法3：img标签的 srcset 属性。这个是 H5的新特性。\n代码举例：\n1 2 \u0026lt;img srcset=\u0026#34;img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x\u0026#34; src=“img-960w.jpg” alt=“img”\u0026gt; （x 描述符：表示图像的设备像素） 4、逐步加载图像：lazyload、LQIP、LQIP 方法1、使用统一占位符。俗称图片的懒加载（lazyload）。\n方法2、使用 LQIP 的图片加载方式。也就是说，在大图没有完全加载出来的情况下，先这张图对应的的低质量图片进行占位。\nLQIP（Low Quality Image Placeholders）：低质量图像占位符。这种技术背后的想法是，在网络环境较差的情况下，你可以尽快向用户展示完全可用的网页，为他们提供更好的体验。即使在更好的网络连接上，这仍然为用户提供了更快的可用页面，并且改善了体验。\n安装 LQIP 工具：npm install lqip\nGitHub源码：https://github.com/zouhir/lqip-loader\n代码举例：（将目标图片转换为 LQIP 形式的图）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const lqip = require(\u0026#39;lqip\u0026#39;); //文件路径 const file = \u0026#39;./in.png\u0026#39;; //将输入的图片转为base64 lqip.base64(file).then(res =\u0026gt; { // 色值 console.log(res); }); lqip.palette(file).then(res =\u0026gt; { //这里输出的是base64的图片地址 console.log(res); }); 另外，我们还可以使用 SQIP 的图片加载方式。\nSQIP（SVG Quality Image Placeholders）： SVG 格式的图像占位符。\n安装 SQIP 工具：npm install sqip\nGitHub 源码：https://github.com/axe312ger/sqip\n代码举例：（将目标图片转换为 SQIP 形式的图）\n1 2 3 4 5 6 7 8 const sqip = require(\u0026#39;sqip\u0026#39;); const result = sqip({ filename: \u0026#39;./input_file.png\u0026#39;, numberOfPrimitives: 10 //可根据不同应用场景设置大小 }); console.log(result.final_svg); 5、雪碧图（Image spriting） 雪碧图是比较常见的图片优化方式，也就是把多张小图合并成一张大图。这样的话，就只需做一次网络请求，减少图片的 http 请求次数。\n读者们可以自行查阅。\n6、有些场景下，并不需要图片文件 有些场景下，并不需要图片，我们可以用其他的方式来代替图片。\n举例：\nWeb Font 代替图片\n使用 Data URI 代替图片。base64就是属于 Data URI的方式。\n7、在服务器端进行图片自动优化 图片服务器自动化优化是可以在图片 URL 链接上增加不同特殊参数，服务器自动化生成。通过这些参数，可以设置图片的不同格式、大小、质量。\n常见处理方式：\n图片裁剪：按长边、短边、填充、拉伸等缩放。\n图片格式转换：支持 JPG，GIF，PNG，WebP 等，支持不同的图片压缩率。\n图片处理：添加图片水印、高斯模糊、重心处理、裁剪边框等。\nAI 能力：鉴黄、涉政、智能抠图、智能排版、智能配色、智能合成等 AI 功能。\n图片举例：\n比如JD公司的图片链接，就会在服务器端做优化处理。通过修改图片链接中的参数，就能自动达到相应的优化效果。\n原始图片链接：\n1 https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg 将图片压缩为 200*150：\n1 https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg 将图片转换为 webp 格式：\n1 https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.webp 将图片质量压缩至10%：\n1 https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg.q10 HTML优化 1、精简 HTML 代码 减少 HTML 的嵌套。\n减少 DOM 节点数。\n减少无语义代码（比如: 消除浮动，其实可以用css来处理）。\n删除 http 或者 https：如果URL的协议头和当前页面的协议头一致的，或者此 URL 在多个协议头都是可用的，则可以考虑删除协议头。\n删除多余的空格、换行符、缩进和不必要的注释。\n省略冗余标签和属性。\n使用相对路径的 URL。\n2、文件放在合适位置 CSS 样式文件链接尽量放在页面头部。 CSS 加载不会阻塞 DOM tree 解析，但是会阻塞 DOM Tree 渲染，也会阻塞后面 JS 执行。\n任何 body 元素之前，可以确保在文档部分中解析了所有 CSS 样式（内联和外联），从而减少了浏览器必须重排文档的次数。\n如果放置页面底部，就要等待最后一个 CSS 文件下载完成，此时会出现\u0026quot;白屏\u0026quot;，影响用户体验。\nJS 引用放在 HTML 底部 防止 JS 在加载、解析、执行时，阻塞了页面后续元素的正常渲染。\n4、增强用户体验 设置 favicon.ico 网站如果不设置 favicon.ico，控制台会报错。另外页面加载过程中如果没有图标，则会出现 loading 过程，也不利于记忆网站品牌，建议统一添加。\n增加首屏必要的 CSS 和 JS 页面如果需要等待所的依赖的 JS 和 CSS 加载完成才显示，则在渲染过程中页面会一直显示空白，影响用户体验，建议在首屏增加必要的 CSS 和 JS，比如页面框架背景图片或者loading 图标，内联在 HTML 页面中。这样做，首屏能快速显示出来，缓解用户焦虑。现在很多网页在初始化的时候，流行做骨架屏，小伙伴们也可以研究下。\nCSS优化 1、提升 CSS 渲染性能 谨慎使用 expensive 属性，这类属性比较耗浏览器的性能。比如：nth-child 伪类；position: fixed 定位。\n尽量减少样式的层级数。\n比如：div ul li span i {color: blue;}这样的层级就太深了。建议给 i 标签设置 class属性，然后通过class直接设置样式属性，可以提升浏览器的查询效率。\n尽量避免使用占用过多 CPU 和内存的属性。比如：text-indnt:-99999px。\n尽量少使用耗电量大的属性。比如：CSS3 3D transforms、CSS3 transitions、Opacity 这样的属性会消耗GPU。\n2、合适使用 CSS 选择器 尽量避免使用 CSS 表达式。 比如 background-color: expression( (new Date()).getHours()%2 ? \u0026quot;#FFF\u0026quot; : \u0026quot;#000\u0026quot; );这个属性的意思是，每间隔两小时，改变白景色。\n尽量避免使用通配选择器。 比如 body \u0026gt; a {font-weight:blod;}这样的属性，可能会把 body 里所有的标签遍历一遍，才找到 a 标签，比较耗时。\n尽量避免类正则的属性选择器：*=， |=， ^=， $= 3、提升 CSS 文件加载性能 使用外链的 CSS。 我们知道，内联的 css 是在html 内部写的。相比之下，外链的 CSS文件是放在CDN上的，可以缓存，既能减少 html 页面的体积大小，也能利用缓存减少资源的请求。\n尽量避免使用 @import 方法 整个CSS加载完成后，浏览器会把 import 中所有依赖的文件全部加载完成后，浏览器才会接着往下渲染。这个过程会阻塞CSS文件的加载过程。\n4、精简 CSS 代码 使用缩写语句 删除不必要的零。比如 0.2 可以写成 .2 删除不必要的单位，比如 0px 可以写成 0 删除过多的空格；注释言简意赅 尽量减少样式表的大小 5、合理使用 Web Fonts 将字体文件部署在 CDN 上。 或者将字体以 base64 形式保存在 CSS 中并通过 localStorage 进行缓存 Google 字体库因为某些不可抗拒原因，应该使用国内托管服务 6、CSS 动画优化 尽量避免同时出现过多动画。 延迟动画初始化：让其他的重要的CSS样式优先渲染。 结合 SVG。 JavaScript 总体优化 JavaScript 变量和函数优化 尽量使用 id 选择器 尽量避免使用 eval 使用事件节流函数 使用事件委托 JavaScript 动画优化 避免添加大量 JavaScript 动画\n尽量使用 CSS3 动画\n尽量使用 Canvas 动画\n合理使用 requestAnimationFrame 动画代替 setTimeout、setInterval\nrequestAnimationFrame可以在正确的时间进行渲染，setTimeout（callback）和setInterval（callback）无法保证 callback 回调函数的执行时机。\n合理使用缓存 合理缓存 DOM 对象\n缓存列表长度\n使用可缓存的 Ajax\nJavaScript 缓存优化 Cookie 通常由浏览器存储，然后将 Cookie 与每个后续请求一起发送到同一服务器。收到HTTP 请求时，服务器可以发送带有 Cookie 的 header 头。可以给 Cookie 设置有效时间。\n应用：\n会话管理：登录名，购物车商品，游戏得分或服务器应要记录的其他任何内容\n个性化：用户首选项，主题或其他设置\n跟踪：记录和分析用户行为，比如visitkey\nsessionStorage 创建一个本地存储的键/值对。\n应用：\n缓存。\n页面应用页面之间传值。\nLocalStorage 本地存储。\n应用于：\n缓存静态文件内容 JavaScript /CSS（比如百度M站首页） 缓存不常变更的 API 接口数据 储存地理位置信息 浏览在页面的具体位置 JavaScript 模块化加载方案和选型 CommonJS 旨在 Web 浏览器之外为 JavaScript 建立模块生态系统。Node.js 模块化方案受 CommonJS。\nAMD (Asynchronous Module Definition)（异步模块定义）规范。 RequireJS 模块化加载器：基于 AMD API 实现。\nCMD（ Common Module Definition）（通用模块定义）规范。 SeaJS 模块化加载器：遵循 CMD API 编写。\nES6 import。 减少回流和重绘重要举措 CSS 避免过多样式嵌套\n避免使用 CSS 表达式\n使用绝对定位，可以让动画元素脱离文档流\n避免使用 table 布局\n尽量不使用 float 布局\n图片最好设置好 width 和 height\n尽量简化浏览器不必要的任务，减少页面重新布局\n使用 Viewport 设置屏幕缩放级别\n避免频繁设置样式，最好把新 style 属性设置完成后，进行一次性更改\n避免使用引起回流/重绘的属性，最好把相应变量缓存起来\nJavaScript 最小化回流和重排：为了减少回流发生次数，避免频繁或操作 DOM，可以合并多次对 DOM 修改，然后一次性批量处理。\n控制绘制过程和绘制区域：绘制过程开销比较大的属性设置应该尽量避免减少使用；同时，减少绘制区域范围。\nDOM 编程优化的⽅式方法 控制 DOM 大小 众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量 DOM 元素。想象一下，从一个上万节点的 DOM 树上，使用 querySelectorAll 或 getElementByTagName 方法查找某一个节点，是非常耗时的。另外元素绑定事件，事件冒泡和事件捕获的执行也会相对耗时。\n通常控制 DOM 大小的技巧包括：\n合理的业务逻辑\n延迟加载即将呈现的内容\n简化 DOM 操作 对DOM节点的操作统一处理后，再统一插入到 DOM Tree中。\n可以使用 fragment，尽量不在页面 DOM Tree 里直接操作。\n现在流行的框架 Angular、React、Vue 都在使用虚拟 DOM 技术，通过 diff 算法简化和减少 DOM 操作。\n静态文件压缩工具介绍 HTML 压缩工具：\nhtml-minifier：https://www.npmjs.com/package/html-minifier CSS 压缩工具：\nclean-css：https://www.npmjs.com/package/clean-css JavaScript 压缩工具：\nuglify-js：https://www.npmjs.com/package/uglify-js\n使用方法：uglifyjs in.js -o out.js\n静态⽂文件打包⽅方案 公共组件拆分\n压缩： JavaScript /CSS/图片\n合并： JavaScript /CSS 文件合并，CSS Sprite\nCombo： JavaScript /CSS 文件\n静态⽂文件版本号更新策略 缓存更新：CDN 或 ng 后台刷新文件路径，更新文件header头。\n文件 name.v1-v100.js：\n大功能迭代每次新增一个大版本，比如由 v1 到 v2\n小功能迭代新增加 0.0.1 或者 0.1.0，比如从 v1.0.0 至 v1.0.1\n年末 ng 统一配置所有版本 302 至最新版\n时间戳.文件 name.js：以每次上线时间点做差异。\nhash.文件。以文件内容 hash 值做 key。\n前端构建工具介绍和选型建议 常用构建工具 Gulp：通过流（Stream）来简化多个任务间的配置和输出，配置代码相对较少。\nWebpack：预编译，中间文件在内存中处理，支持多种模块化，配置相对很简单。\nFIS\nwebpack 打包优化 定位体积大的模块\n删除没有使用的依赖\n生产模式进行公共依赖包抽离\n开发模式进行 DLL \u0026amp; DllReference 方式优化\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/","summary":"图片格式和应用场景 JPEG 格式 JPEG（Joint Photographic Experts Group）是一种针对彩色照片而广泛使用的有损压缩图形格式，属于位图。 常用文件扩展名为.jp","title":"静态资源优化"},{"content":"浏览器渲染过程 浏览器解析 HTML，生成 DOM Tree（Parse HTML）。\n浏览器解析 CSS，生成 CSSOM（CSS Object Model）Tree。\nJavaScript 会通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree，浏览器将 DOM Tree 和 CSSOM Tree 合成渲染树（Render Tree）。\n布局（Layout）：根据生成的 Render Tree，进行回流，以计算每个节点的几何信息（位置、大小、字体样式等等）。\n绘制（Painting）：根据渲染树和回流得到的几何信息，得到每个节点的绝对像素。\n展示（Display）：将像素发送给图形处理器（GPU），展示在页面上。\n页面渲染技术方案总览 服务端渲染：\n后端同步渲染、同构直出、BigPipe。 客户端渲染：\nJavaScript 渲染：静态化、前后端分离、单页面应用\nWeb App：React、Vue、PWA\nHybrid App：PhoneGap 、AppCan 等\n跨平台开发：RN 、Flutter 、小程序等。\n原生 App：iOS 、Android\n建议：\n依赖业务形式、依赖团队规模、依赖技术水平。 静态化技术方案 静态化是使动态化的网站生成静态 HTML 页面以供用户更好访问的技术，一般分为纯动态化和伪动态化。\n技术优势：\n提高了页面访问速度，降低了服务器的负担，因为访问页面时不需要每次去访问数据库。\n提高网站内容被搜索引擎搜索到的几率，因为搜索引擎更喜欢静态页面。\n网站更稳定，如果后端程序、数据库出现问题，会直接影响网站的正常访问，而静态化页面有缓存，更不容易出现问题。\n技术不足：\n服务器存储占用问题，因为页面量级在增加，要占用大量硬盘空间。\n静态页面中的链接更新问题会有死链或者错误链接问题。\n技术实现：\n跑定时任务，将已有的动态内容进行重定，生成静态的 HTML 页面。\n利用模板技术，将模板引擎中模板字符替换为从数据库字段中取出来的值， 同时生成 HTML 文件。\n协作方式：\n前端统一写好带有交互的完整静态页面。\n后端拆分出静态页面文件，并嵌套在后端模板文件中。\n选型建议：后端研发人员充分，又需要考虑用户体验、服务器负载的业务。\n前后端分离技术与实现 前后端分离是指研发人员分离、业务代码分离、后端实现业务接口，前端渲染页面。\n技术实现：\n后端只负责功能接口实现，提供按照约定的数据格式并封装好的 API 接口。\n前端负责业务具体实现，获取到 API 接口数据后，进行页面模板拼接和渲染，独立上线。\n协作方式：\n前端负责实现页面前端交互，根据后端 API 接口拼装前端模板。\n后端专注于业务功能实现和 API 接口封装。\n技术优势：\n团队更加专注\n提升了开发效率\n增加代码可维护性\n技术架构：\n后端架构：Java、C++、PHP、 + Nginx，使用微服务（比如 Dubbo 等）等实现业务的解耦，所有的服务使用某种协议提供不同的服务（比如 JSF 等） 。\n前端架构：使用 Angular、React、Vue 前端框架并部署页面至 CDN。\n前端架构 2：使用 Angular、React、Vue 前端框架并部署在 Node Server。\n技术不足：\n因为前端需要负责一大部分业务逻辑实现，和服务端同步、静态化，需要前端人力非常多。\n页面数据异步渲染，不利于 SEO，搜索引擎更喜欢纯静态页面。\n选型建议：\n这是大型互联网公司正在采用的开发模式，一句话，如果考虑用户体验，以及前端人力够用，就可以积极采用。 单页面应用技术方案 单页应用（single-page application，缩写 SPA），通过动态重写当前页面，来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法在使用过程中不需要重新加载页面，避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。\n技术优点：\n不错的加载速度：用户往往感觉页面加载非常快，因为一进入页面就能看到页面元素；\n良好的交互体验：进行局部渲染，避免不必要的页面间跳转和重复渲染；\n前后端职责分离：前端进行页面交互逻辑，后端负责业务逻辑；\n减轻服务器负载：服务器只处理数据接口输出，不用考虑页面模板渲染和 HTML 展示。\n技术缺点：\n开发成本相对较高\n首次页面加载时间过多\nSEO 难度比较大\n技术实现：\n使用 React、Vue 框架可以很好的。 BigPipe 简介和工作模式 BigPipe 通过将页面加载到称为 Pagelet 的小部件中，来加快页面渲染速度，并允许浏览器在 PHB 服务器呈现页面的同时，一直请求页面不同区块的结构，类似一个“流”传输管道。\n技术实现：\n浏览器从服务器请求页面。\nServer 迅速呈现一个包含 标记的页面框架，以及一个包含空 div 元素的主体，这些元素充当 Pagelet 的容器。由于该页面尚未完成，因此与浏览器的 HTTP 连接保持打开状态。\n浏览器将开始下载 bigpipe.js 文件，然后它将开始呈现页面。\nPHP 服务器进程仍在执行，并且一次构建每个 Pagelet 。Pagelet 完成后，其结果将在\u0026lt;script\u0026gt; BigPipe.onArrive（…）\u0026lt;/ script\u0026gt; 标记内发送到浏览器。\n浏览器将收到的 html 代码注入正确的位置。如果小页面需要任何 CSS 资源，则也将下载这些 CSS 资源。\n接收完所有的页面集之后，浏览器将开始加载那些页面集所需的所有外部 JavaScript 文件。\n下载 JavaScript 后，浏览器将执行所有内联 JavaScript。\n同构直出技术方案 一套代码既可以在服务端运行又可以在客户端运行，这就是同构（Universal）。\n技术优势：\n性能: 降低首屏渲染时间\nSEO: 服务端渲染对搜索引擎的爬取有着天然的优势\n兼容性: 有效规避客户端兼容性问题，比如白屏\n代码同构：直接上线两个版本，利于灾备。\n技术实现：\nnext.js：服务器端渲染 React 组件框架（参考查看：https://nextjs.org/）, React 采用 ReactDOMServer 调用 renderToString() 方法。\ngatsbyjs：服务端 React 渲染框架（参考查看： https://www.gatsbyjs.org/）。\nnuxt.js：服务器端渲染 Vue 组件框架（参考查看：https://nuxtjs.org/）, Vue 采用 vue-server-renderer 调用 renderToString() 方法。\n协作方式：\n后端专注于业务功能实现和 API 接口封装。\n前端负责实现页面前端交互，根据后端 API 接口拼装前端模板，页面渲染，以及服务器维护。\n选型建议：\n前端要处理 Node server 的机器环境、代码部署、日志、容灾、监控等以往后端人员需要具备运维知识，前端人员的综合能力要求会比以往要高。\n前端项目开发周期变长了，需要事先和产品、运营沟通排期问题。\nPWA 技术方案和实现思路 Progressive Web App，简称 PWA，PWA 应用是使用特定技术和标准模式来开发的 Web 应用，这将同时赋予它们 Web 应用和原生应用的特性。\n技术优势：\n用户可以用手机屏幕启动应用，即使在离线状态或者弱网下，通过事先缓存的资源，也可正常加载运行当前应用，可以完全消除对网络的依赖，从而给用户非常可靠的体验。\n因为预先缓存了资源，部分资源无须经过网络，即秒开页面。\n和移动设备上的原生应用一样，具有沉浸式的用户体验。\n可以给用户发送离线推送消息。\n技术实现：\n全站改造成 HTTPS，没有 HTTPS 就没有 Service Worker。\n应用 Service Worker 技术提升性能，离线提供静态资源文件，提升首屏用户体验。\n使用 App Manifest。\n最后可以考虑离线消息推送等功能。\n浏览器兼容性：\nServiceWorkerGlobalScope API：88%\nWeb App Manifest 83%\n页面加载策略优化 懒加载\n预加载\n预渲染\n按需加载\n下面具体展开讲讲。\n懒加载 懒加载也叫延迟加载，指的是长网页中延迟加载特定元素（可以是图片，也可以是 JS/CSS 文件，当然也可以是 JavaScript 的特定函数和方法，以下简称“懒加载元素”）。\n好处：可以减少当前屏无效资源的加载。\n技术实现举例：把页面上“懒加载元素”src 属性设置为空字符，把真实的 src 属性写在 data-lazy 属性中，当页面滚动的时候监听 scroll 事件，如果“懒加载元素”在可视区域内，就把图片的 src 属性或者文件 URL 路径设置成 data-lazy 属性值。\n预加载 可以使用预加载让浏览器来预先加载某些资源（比如图片、JS/CSS/模板），而这些资源是在将来才会被使用到的。简单来说，就是将所需资源提前加载到浏览器本地，这样后面在需要使用的时候就可以直接从浏览器缓存中取了，而不用再重新开始加载。\n使用场景：如果你希望这个资源能尽快显示给用户，就可以使用预加载。\n好处：减少用户后续加载资源等待的时间。\n技术实现举例：\nHTML 标签： 1 \u0026lt;img src=\u0026#34;https://xxx.jpg\u0026#34; style=\u0026#34;display: none\u0026#34; /\u0026gt; 2、使用 Image 对象：\n1 2 3 const image = new Image(); image.src = \u0026#39;https://xxx.jpg\u0026#39;; 3、使用 preload、prefetch 和 preconnect：\n1 2 3 4 5 6 7 \u0026lt;link rel=“preload” href=“src/style.css” as=“style”\u0026gt; \u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;scr/image.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;https://my.com\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://my.com\u0026#34; crossorigin /\u0026gt; 预渲染 有一种预加载组件的方式就是提前渲染它。在页面中渲染组件，但是并不在页面中展示。也就是渲染完成后，先隐藏起来，用的时候再展示。\n实现举例：\n1 \u0026lt;link rel=\u0026#34;prerender\u0026#34; href=\u0026#34;https://my.com\u0026#34; /\u0026gt; 按需加载 常规按需加载（如 JS 原生、jQuery）\n不同 App 按需加载（如 JS-SDK 脚本文件）\n不同设备按需加载（如 PC 端和 HTML5 端样式文件）\n不同分辨率按需加载（CSS Media Query）\nReact 异步加载举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const componentA = (location, callback) =\u0026gt; { require.ensure( [], (require) =\u0026gt; { callback(null, require(\u0026#39;modules/componentA\u0026#39;)); }, \u0026#39;componentA\u0026#39; ); }; const componentB = (location, callback) =\u0026gt; { require.ensure( [], (require) =\u0026gt; { callback(null, require(\u0026#39;modules/componentB\u0026#39;)); }, \u0026#39;componentB\u0026#39; ); }; \u0026lt;Router history={history}\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; component={App}\u0026gt; \u0026lt;Route path=\u0026#34;componentA\u0026#34; getComponent={componentA}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;componentB\u0026#34; getComponent={componentB}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Router\u0026gt;; Vue 异步加载举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import Vue from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import VueRouter from \u0026#39;vue-router\u0026#39;; Vue.use(VueRouter); const componentA = resolve =\u0026gt; require([\u0026#39;src/a.vue\u0026#39; ], resolve); const componentB = resolve =\u0026gt; require([\u0026#39;src/b.vue\u0026#39; ], resolve); const router = new VueRouter({ routes: [{path:\u0026#34;a”,name:\u0026#34;/a”,component:componentA}, {path:\u0026#34;b”,name:\u0026#34;/b”,component:componentB}] }) new Vue({ el: \u0026#39;#app\u0026#39;, router: router, render: h =\u0026gt; h(App) }) 接口服务调用优化 1、接口合并：一个页面的众多业务接口和依赖的第三方接口，合并为一个部署在集群的接口统一调用，以减少页面接口请求数。\n2、接口上 CDN：主要基于接口性能考虑，我们可以把不需要实时更新的接口同步至 CDN，等此接口内容变更之后自动同步至 CDN 集群上。如果一定时间内未请求到数据，会用源站接口再次请求。\n3、接口域名上 CDN：增强可用性、稳定性。\n4、接口降级：核心接口进行降级用基础接口进行业务实现，比如千人千面的推荐接口，在大促时间点可以直接运营编辑的数据。另外如果接口无访问，建议使用兜底数据。\n5、接口监控：监控接口成功率，不只是常说的 TP99，也包括弱网、超时、网络异常、网络切换等一段情况的监控情况。排查出来问题后，需要联合后端、运维、网络岗位人员一并解决。\n接口缓存策略优化 1、Ajax/fetch 缓存：前端请求时候带上 cache，依赖浏览器本身缓存机制。\n2、本地缓存：异步接口数据优先使用本地 localStorage 中的缓存数据。\n3、多次请求：接口数据本地无 localStorage 缓存数据，重新再次发出 ajax 请求。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","summary":"浏览器渲染过程 浏览器解析 HTML，生成 DOM Tree（Parse HTML）。 浏览器解析 CSS，生成 CSSOM（CSS Object Model）Tree。 JavaScript 会","title":"页面渲染性能优化"},{"content":"ES6 模块与 CommonJS 模块有什么异同？\nES6 Module 和 CommonJS 模块的区别：\nCommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变，类似 const； import 的接⼝是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。\nES6 Module 和 CommonJS 模块的共同点：\nCommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。\n四、ES6 Module ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 /** 定义模块 math.js **/ var basicNum = 0; var add = function (a, b) { return a + b; }; export { basicNum, add }; /** 引用模块 **/ import { basicNum, add } from \u0026#39;./math\u0026#39;; function test(ele) { ele.textContent = add(99 + basicNum); } 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。\n1 2 3 4 5 6 7 8 /** export default **/ //定义输出 export default { basicNum, add }; //引入 import math from \u0026#39;./math\u0026#39;; function test(ele) { ele.textContent = math.add(99 + math.basicNum); } ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\nAMD\nexport.defaults={} require(\u0026lsquo;xxxx\u0026rsquo;)\nES6\nexport default { aaaa， bbbb }\nimport xxxx form \u0026ldquo;xxxx文件\u0026rdquo;\nxxxx.aaaa() xxxx.bbbb()\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/common.js-%E4%B8%8E-es6-module/","summary":"ES6 模块与 CommonJS 模块有什么异同？ ES6 Module 和 CommonJS 模块的区别： CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变","title":"Common.js 与 ES6 Module"},{"content":"js执行机制 说出结果并说出why 这道题考察的是，js的任务执行流程，对宏任务和微任务的理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 console.log(\u0026#34;start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;setTimeout1\u0026#34;); //入宏任务1 }, 0); (async function foo() { console.log(\u0026#34;async 1\u0026#34;); await asyncFunction(); console.log(\u0026#34;async2\u0026#34;); // 入微任务2 })().then(console.log(\u0026#34;foo.then\u0026#34;)); async function asyncFunction() { console.log(\u0026#34;asyncFunction\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;setTimeout2\u0026#34;); // 入宏任务2 }, 0); new Promise((res) =\u0026gt; { console.log(\u0026#34;promise1\u0026#34;); res(\u0026#34;promise2\u0026#34;); }).then(console.log); //// 入微任务1 } console.log(\u0026#34;end\u0026#34;); start =\u0026gt; async 1 =\u0026gt; asyncFunction =\u0026gt; promise1 =\u0026gt; foo.then =\u0026gt; end =\u0026gt; promise2 =\u0026gt; async2 =\u0026gt; setTimeout1 =\u0026gt; setTimeout2 提示：\nscript标签算一个宏任务所以最开始就执行了 async await 在await之后的代码都会被放到微任务队列中去 开始执行：\n最开始碰到 console.log(\u0026ldquo;start\u0026rdquo;); 直接执行并打印出 start 往下走，遇到一个 setTimeout1 就放到宏任务队列 碰到立即执行函数 foo， 打印出 async 1 遇到 await 堵塞队列，先 执行await的函数 执行 asyncFunction 函数， 打印出 asyncFunction 遇到第二个 setTimeout2， 放到宏任务队列 new Promise 立即执行，打印出 promise1 执行到 res(\u0026ldquo;promise2\u0026rdquo;) 函数调用，就是Promise.then。放到微任务队列 asyncFunction函数就执行完毕， 把后面的打印 async2 会放到微任务队列 然后打印出立即执行函数的then方法 foo.then 最后执行打印 end 开始执行微任务的队列 打印出第一个 promise2 然后打印第二个 async2 微任务执行完毕，执行宏任务 打印第一个 setTimeout1 执行第二个宏任务 打印 setTimeout2、 就此，函数执行完毕 ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/js-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1/","summary":"js执行机制 说出结果并说出why 这道题考察的是，js的任务执行流程，对宏任务和微任务的理解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25","title":"js 执行机制 宏任务微任务"},{"content":"1. this指向问题 1.1 this永远指向最后调用它的那个对象 1 2 3 4 5 6 7 8 9 10 严格模式下 var name = \u0026#34;windowsName\u0026#34;; function a() { var name = \u0026#34;Cherry\u0026#34;; console.log(this.name); // windowsName console.log(\u0026#34;inner:\u0026#34; + this); // inner: Window } a(); //类似于 window.a() console.log(\u0026#34;outer:\u0026#34; + this) // outer: Window 1.2 匿名函数this永远指向window对象 2. 如何改变 this 指向 2.1 箭头函数 箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var name = \u0026#34;windowsName\u0026#34;; var a = { name : \u0026#34;Cherry\u0026#34;, func1: function () { console.log(this.name) }, func2: function () { setTimeout( () =\u0026gt; { //这里使用箭头函数 this.func1() },100); } }; a.func2() // Cherry 2.2 that / _this 先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var name = \u0026#34;windowsName\u0026#34;; var a = { name : \u0026#34;Cherry\u0026#34;, func1: function () { console.log(this.name) }, func2: function () { var _this = this; //通过_this替换 this指向 setTimeout( function() { _this.func1() },100); } }; a.func2() // Cherry 2.3 call、apply、bind apply 和 call 的区别 其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。\n1 2 3 4 5 fun.call(thisArg[, arg1[, arg2[, ...]]]) fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 var a ={ name : \u0026#34;Cherry\u0026#34;, fn : function (a,b) { console.log( a + b) } } var b = a.fn; b.call(a,1,2) // 3 b.apply(a,[1,2]) // 3 bind bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。\n1 2 3 4 5 6 7 8 9 10 var a ={ name : \u0026#34;Cherry\u0026#34;, fn : function (a,b) { console.log( a + b) } } var b = a.fn; b.bind(a,1,2) //没有输出 b.bind(a,2,3)() //3 //因为bind创建一个新的函数，需要手动调用 拓展： 没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的\n1 2 3 4 5 6 7 8 9 10 11 var name = \u0026#34;windowsName\u0026#34;; function fn() { var name = \u0026#39;Cherry\u0026#39;; innerFunction(); function innerFunction() { console.log(this.name); // windowsName } } fn() //this 指向 window 匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。 其次虽然匿名函数不能被其他对象调用，但是可以被其他函数调用，比如例 7 中的 setTimeout。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var name = \u0026#34;windowsName\u0026#34;; var a = { name : \u0026#34;Cherry\u0026#34;, func1: function () { console.log(this.name) }, func2: function () { setTimeout( function () { this.func1() },100 ); } }; a.func2() // this.func1 is not a function ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/4-this%E6%8C%87%E5%90%91applycallbind/","summary":"1. this指向问题 1.1 this永远指向最后调用它的那个对象 1 2 3 4 5 6 7 8 9 10 严格模式下 var name = \u0026#34;windowsName\u0026#34;; function a() { var name = \u0026#34;Cherry\u0026#34;; console.log(this.name); // windowsName console.log(\u0026#34;inner:\u0026#34; + this); // inner: Window } a(); //类似于","title":"this指向、apply、call、bind"},{"content":"什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。\n广义的跨域：\n1 2 3 1.) 资源跳转： A链接、重定向、表单提交 2.) 资源嵌入： \u0026lt;link\u0026gt;、\u0026lt;script\u0026gt;、\u0026lt;img\u0026gt;、\u0026lt;frame\u0026gt;等dom标签，还有样式中background:url()、@font-face()等文件外链 3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 什么是同源策略？ 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指\u0026quot;协议+域名+端口\u0026quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n1 2 3 Cookie、LocalStorage 和 IndexDB 无法读取 2.) DOM 和 Js对象无法获得 3.) AJAX 请求不能发送 常见跨域场景 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 URL 说明 是否允许通信 http://www.domain.com/a.js http://www.domain.com/b.js 同一域名，不同文件或路径 允许 http://www.domain.com/lab/c.js http://www.domain.com:8000/a.js http://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.js https://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.js http://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.js http://x.domain.com/b.js 主域相同，子域不同 不允许 http://domain.com/c.js http://www.domain1.com/a.js http://www.domain2.com/b.js 不同域名 不允许 各跨域方案区别 1 2 3 4 5 jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源； CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求； Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，适合前后端分离的前端项目调后端接口。 document.domain+iframe适合主域名相同，子域名不同的跨域请求。 postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+。 1、jsonp （ 缺点：只能实现get一种请求） 1.）jquery ajax：\n1 2 3 4 5 6 7 $.ajax({ url: \u0026#39;http://www.domain2.com:8080/login\u0026#39;, type: \u0026#39;get\u0026#39;, dataType: \u0026#39;jsonp\u0026#39;, // 请求方式为jsonp jsonpCallback: \u0026#34;handleCallback\u0026#34;, // 自定义回调函数名 data: {} }); 2.）vue.js：\n1 2 3 4 5 6 this.$http.jsonp(\u0026#39;http://www.domain2.com:8080/login\u0026#39;, { params: {}, jsonp: \u0026#39;handleCallback\u0026#39; }).then((res) =\u0026gt; { console.log(res); }) 2、跨域资源共享（CORS） 设置Access-Control-Allow-Origin 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。\n需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。\n1）、 前端设置： 原生ajax\n1 2 // 前端设置是否带cookie xhr.withCredentials = true; 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookie xhr.withCredentials = true; xhr.open(\u0026#39;post\u0026#39;, \u0026#39;http://www.domain2.com:8080/login\u0026#39;, true); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); xhr.send(\u0026#39;user=admin\u0026#39;); xhr.onreadystatechange = function() { if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { alert(xhr.responseText); } }; 2）、 服务端设置： 若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。\n1.）Java后台：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */ // 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加\u0026#39;/\u0026#39; response.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;http://www.domain1.com\u0026#34;); // 允许前端带认证cookie：启用此项后，上面的域名不能为\u0026#39;*\u0026#39;，必须指定具体的域名，否则浏览器会提示 response.setHeader(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头 response.setHeader(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;Content-Type,X-Requested-With\u0026#34;); 2.）Nodejs后台示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var http = require(\u0026#39;http\u0026#39;); var server = http.createServer(); var qs = require(\u0026#39;querystring\u0026#39;); server.on(\u0026#39;request\u0026#39;, function(req, res) { var postData = \u0026#39;\u0026#39;; // 数据块接收中 req.addListener(\u0026#39;data\u0026#39;, function(chunk) { postData += chunk; }); // 数据接收完毕 req.addListener(\u0026#39;end\u0026#39;, function() { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { \u0026#39;Access-Control-Allow-Credentials\u0026#39;: \u0026#39;true\u0026#39;, // 后端允许发送Cookie \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;http://www.domain1.com\u0026#39;, // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ \u0026#39;Set-Cookie\u0026#39;: \u0026#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly\u0026#39; // HttpOnly的 3、nginx反向代理接口跨域 1）、 nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\n1 2 3 location / { add_header Access-Control-Allow-Origin *; } 2）、nginx反向代理接口跨域 跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。\n实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server { listen\t80 #监听80端口，访问域名为www.123.com，不加端口号时默认为80端口 listen *:80 | *:8080 #监听所有80端口和8080端口 listen IP_address\t#监听指定ip地址所有端口 listen port #监听该端口的所有IP连接 server_name www.123.com www.baidu.com; #多个用空格隔开 #访问该域名时会跳转到127.0.0.1:8080路径 #通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端 server_name *.123.com www.123.* #正则表达式，用“~”作为正则表达式字符串的开始标记 #server_name ~^www\\d+\\.123\\.com$; #“~”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个0~9之间的数字，再紧跟“.123.co”，最后跟着“m”($表示结尾) #基于 IP 地址的虚拟主机配置 == 域名匹配 （不考虑通配符和正则表达式） server_name 192.168.1.1 匹配顺序： ①、准确匹配 server_name ②、通配符在开始时匹配 server_name 成功 ③、通配符在结尾时匹配 server_name 成功 ④、正则表达式匹配 server_name 成功 location / { #用于匹配 URL proxy_pass http:127.0.0.1:8080; #用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式 index index.html index.htm index.jsp; #用于设置网站的默认首页 可有多个用空格隔开 index.html index.jsp } } 4、 vue框架的跨域（vue.config.js文件配置） 利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: \u0026#39;/login\u0026#39;, target: \u0026#39;http://www.domain2.com:8080\u0026#39;, // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: \u0026#39;www.domain1.com\u0026#39; // 可以为false，表示不修改 }], noInfo: true } } 扩展知识： nginx 正向代理 代理客户端，反向代理 代理服务器。 1、nginx 正向代理 2、nginx反向代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server { listen\t80 #监听80端口，访问域名为www.123.com，不加端口号时默认为80端口 listen *:80 | *:8080 #监听所有80端口和8080端口 listen IP_address\t#监听指定ip地址所有端口 listen port #监听该端口的所有IP连接 server_name www.123.com www.baidu.com; #多个用空格隔开 #访问该域名时会跳转到127.0.0.1:8080路径 #通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端 server_name *.123.com www.123.* #正则表达式，用“~”作为正则表达式字符串的开始标记 #server_name ~^www\\d+\\.123\\.com$; #“~”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个0~9之间的数字，再紧跟“.123.co”，最后跟着“m”($表示结尾) #基于 IP 地址的虚拟主机配置 == 域名匹配 （不考虑通配符和正则表达式） server_name 192.168.1.1 匹配顺序： ①、准确匹配 server_name ②、通配符在开始时匹配 server_name 成功 ③、通配符在结尾时匹配 server_name 成功 ④、正则表达式匹配 server_name 成功 location / { #用于匹配 URL proxy_pass http:127.0.0.1:8080; #用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式 index index.html index.htm index.jsp; #用于设置网站的默认首页 可有多个用空格隔开 index.html index.jsp } } Nginx完整配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; # include /etc/nginx/conf.d/*.conf; # 引入default.conf配置文件 server { listen 80; server_name www.zhengqing520.com;# 服务器地址或绑定域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; # start ------------------------------------------------------------------------------------ location / { root /usr/share/nginx/html; try_files $uri $uri/ @router; index index.html index.htm; # proxy_pass http://zhengqingya.gitee.io; # 代理的ip地址和端口号 # proxy_connect_timeout 600; #代理的连接超时时间（单位：毫秒） # proxy_read_timeout 600; #代理的读取资源超时时间（单位：毫秒） } location @router { rewrite ^.*$ /index.html last; } location ^~ /api { # ^~/api/表示匹配前缀为api的请求 proxy_pass http://www.zhengqing520.com:9528/api/; # 注：proxy_pass的结尾有/， -\u0026gt; 效果：会在请求时将/api/*后面的路径直接拼接到后面 # proxy_set_header作用：设置发送到后端服务器(上面proxy_pass)的请求头值 # 【当Host设置为 $http_host 时，则不改变请求头的值; # 当Host设置为 $proxy_host 时，则会重新设置请求头中的Host信息; # 当为$host变量时，它的值在请求包含Host请求头时为Host字段的值，在请求未携带Host请求头时为虚拟主机的主域名; # 当为$host:$proxy_port时，即携带端口发送 ex: $host:8080 】 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; # 在web服务器端获得用户的真实ip 需配置条件\t① 【 $remote_addr值 = 用户ip 】 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 在web服务器端获得用户的真实ip 需配置条件② proxy_set_header REMOTE-HOST $remote_addr; # proxy_set_header X-Forwarded-For $http_x_forwarded_for; # $http_x_forwarded_for变量 = X-Forwarded-For变量 } location ^~ /blog/ { # ^~/blog/ 表示匹配前缀为blog/后的请求 proxy_pass http://zhengqingya.gitee.io/blog/; proxy_set_header Host $proxy_host; # 改变请求头值 -\u0026gt; 转发到码云才会成功 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-NginX-Proxy true; } # end --------------------------------------------------------------------------------------------- #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } } ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/2-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9Fnginxcors/","summary":"什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1 2 3 1.) 资源跳转： A链接、重定向、表单提交","title":"前端跨域Nginx、CORS"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 任何一个对象都有 _proto_ 属性 ,#这个属性会指向该对象的原型 构造函数 _proto_ 属性下 有contructor 属性 per.__proto__.constructor === per.constructor per.constructor.__proto__ __proto__和constructor ，属性值是当前实例所属类的原型(prototype)。原型对象中有一个属性constructor, 它指向函数对象。 function Person() {} var person = new Person() console.log(person.__proto__ === Person.prototype)//true console.log(Person.prototype.constructor===Person)//true //顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 一、原型 proto 每一个对象数据类型(普通的对象、实例、prototype\u0026hellip;\u0026hellip;)也天生自带一个属性____proto__，除非未赋值\n1、对象的属性__proto__ === 当前实例所属类的原型prototype 对象的属性__proto__ === 当前实例所属类的原型对象（prototype）\nperson.proto === Person.prototype\n2、原型对象中constructor属性 指向函数对象 Person.prototype.constructor === Person\n二、原型链 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。\n原型、构造函数、实例，以及原型链 PS：任何一个函数，如果在前面加了new，那就是构造函数。\n原型、构造函数、实例三者之间的关系 1、构造函数通过 new 生成实例\n2、构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性）\n3、原型对象中有 constructor，指向该原型的构造函数。\n上面的三行，代码演示：\n1 2 3 4 5 var Foo = function (name) { this.name = name; } var foo = new Foo(\u0026#39;smyhvae\u0026#39;); 上面的代码中，Foo.prototype.constructor === Foo的结果是true：\n4、实例的__proto__指向原型。也就是说，foo.__proto__ === Foo.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。\nFoo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。\n原型链 原型链的基本原理：任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。\nObject是原型链的顶端。\n原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：\n1 2 3 4 //给Foo的原型添加 say 函数 Foo.prototype.say = function () { console.log(\u0026#39;\u0026#39;); } 原型链的关键：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。\ninstanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。\ninstanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。\n注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。\n注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。\n比如说：\nfoo instance of Foo的结果为true，因为foo.__proto__ === Foo.prototype为true。\nfoo instance of Objecet的结果也为true，因为Foo.prototype.__proto__ === Object.prototype为true。\n但我们不能轻易的说：foo 一定是 由Object创建的实例。这句话是错误的。我们来看下一个问题就明白了。\n分析一个问题 问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？\n分析：这就要用到原型的constructor属性了。\nfoo.__proto__.constructor === Foo的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 任何一个对象都有 _proto_ 属性 ,#这个属性会指向该对象的原型 构造函数 _proto_ 属性下 有contructor 属性 per.__proto__.constructor === per.constructor per.constructor.__proto__ __pr","title":"原型、原型链"},{"content":"同源和跨域 同源 同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。\n跨域问题的解决方案 从我自己的网站访问别人网站的内容，就叫跨域。\n出于安全性考虑，浏览器不允许ajax跨域获取数据。\niframe：处于安全性考虑，浏览器的开发厂商已经禁止了这种方式。\nJSONP：script 标签的 src 属性传递数据。\nJSONP JSONP(JSON with Padding)：带补丁的 json，本质是利用了 \u0026lt;script src=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。\n我们知道， html标签的 src 属性是支持跨域的：\n1 \u0026lt;img src=\u0026#34;http://img.smyhvae.com/2016040101.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; jsonp 就是利用这个特性实现的跨域，但用的是 script 标签。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- jsonp 就是 利用 src，实现的跨域 用的是 script标签 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#39;http://192.168.141.137/2018-02-28/myData.php\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方那一行的代码，意思是：刷新A服务器上的index页面后，会去请求 B 服务器上的 myData.php 这个页面。而且请求的方式是 get 请求。\n但是 B 服务器上的页面不是你想请求就可以请求的，大家一起配合才可以。\n具体实现步骤：\n需要首先声明的是，jsonp 只能通过 GET 方式进行请求。\n（1）A客户端的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 定义 eatFood()方法 function fn(data) { console.log(\u0026#39;我被调用了哦\u0026#39;); console.log(data); } \u0026lt;/script\u0026gt; \u0026lt;!-- 使用 script标签 发送了 get请求 去到了一个 php页面 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#39;http://192.168.141.137/01.php?callback1=fn\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; 我们来分析上方代码中的最后一行的那个url：A 客户端请求的是 B服务器上的 01.php页面。url里有个callback1=fn，意思是：callback1是A和B 之间的约定，约定后，将执行方法 fn。\n其实，fn方法已经在最后一行代码中执行了。只不过，fn方法里的data数据，是从 B 服务器中获取的。\n（2）B服务器端的代码：\n1 2 3 4 5 6 7 \u0026lt;?php $mycallBack = $_GET[\u0026#39;callback1\u0026#39;]; $arr = array(\u0026#34;zhangsan\u0026#34;,\u0026#34;lisi\u0026#34;,\u0026#34;zhaoliu\u0026#34;); echo $mycallBack.`(`.json_encode($arr).`)`; //字符串拼接 ?\u0026gt; 代码解释：\n第一行的callback1 是A和B之间的约定，二者必须一致。\necho语句中输出的内容，即使要返回给A客户端的内容，此内容会保存在 A 客户端的fn方法的data里。 data[0]指的是 zhangsan。\njson_encode指的是，将php对象转化为 json。\n刷新A页面，输出结果为：\n1 mycallBack([\u0026#34;zhangsan\u0026#34;,\u0026#34;lisi\u0026#34;,\u0026#34;zhaoliu\u0026#34;]) jQuery 中的 JSONP 我们知道，jQuery 中发送 Ajax 请求，格式是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $(\u0026#34;#btn\u0026#34;).click(function(){ $.ajax({ url:\u0026#34;./data.php?callback1=fn\u0026#34;, dataType:\u0026#34;jsonp\u0026#34;, type:\u0026#34;get\u0026#34;, //jsonp:\u0026#34;callback1\u0026#34;, //传递给B服务器的回调函数的名字（默认为 callback） //jsonCallBack:\u0026#34;fn\u0026#34; //自定义的函数名称。默认为 jQuery 自动生成的随机函数名 success:function(data){ alert(data); //$(\u0026#34;#showInfo\u0026#34;).html(data); }, error:function(e){ console.log(e); } }); }); 那如果数据是 JSONP，上方代码则改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $(\u0026#34;#btn\u0026#34;).click(function(){ $.ajax({ url:\u0026#34;./data.php?fn\u0026#34;, dataType:\u0026#34;text\u0026#34;, type:\u0026#34;get\u0026#34;, success:function(data){ alert(data); //$(\u0026#34;#showInfo\u0026#34;).html(data); }, error:function(e){ console.log(e); } }); }); 参考链接 参考链接：https://www.cnblogs.com/2050/p/3191744.html\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/04-%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/","summary":"同源和跨域 同源 同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。 跨域问题的解决方案 从我自己的网站访问别人网站的内容，就","title":"同源和跨域"},{"content":"解决方案： 1、媒体查询 百度分辨率统计 ：https://tongji.baidu.com/research/site?source=index#screen\npc端：1920 * 1080\t| 1366 * 768 | 1440 * 900 | 1536 * 864 | 1280 * 720 |\t1600 * 900\n移动端： 360 * 640 414 * 736 375 * 667\n从大到小\n1 2 3 4 5 6 7 8 /*分辨率1400-1600*/ @media screen and (max-width: 1600px){} /*分辨率在1200-1400之间*/ @media screen and (max-width: 1400px){} /*分辨率在900-1200之间*/ @media screen and (max-width: 1200px){} /*分辨率小于900*/ @media screen and (max-width: 900px){} 从小到大\n1 2 3 4 5 6 7 8 9 10 11 12 /*分辨率在300-720之间*/ @media screen and (min-width: 300px){} /*分辨率在720-960之间*/ @media screen and (min-width: 720px){} /*分辨率在960-1024之间*/ @media screen and (min-width: 960px){} /*分辨率在1024-1280之间*/ @media screen and (min-width: 1024px){} /*分辨率在1280-1366之间*/ @media screen and (min-width: 1280px) {} /*分辨率大于1366*/ @media screen and (min-width: 1366px) {} 2、栅格布局 3、配合 vw / % / rem 4、移动端 meta viewport viewport可以优化移动端浏览器的显示。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no\u0026#34;/\u0026gt; width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素） height：高度（数值 / device-height）（范围从223 到10,000） initial-scale：初始的缩放比例 （范围从\u0026gt;0 到10） minimum-scale：允许用户缩放到的最小比例 maximum-scale：允许用户缩放到的最大比例 user-scalable：用户是否可以手动缩 (no,yes) minimal-ui：可以在页面加载时最小化上下状态栏。（已弃用） 注意，很多人使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果和initial-scale=1同时使用user-scalable=no或maximum-scale=1，则用户将不能放大/缩小网页来看到全部的内容。 补充知识 px、rpx、em、rem 、vw/vh、百分比的区别 1、px 也常被称为 CSS 像素 一个像素表示了计算机屏幕所能显示的最小区域，像素分为两种类型：\n​\tCSS 像素：为 Web 开发者提供，在 CSS 中使用的一个抽象单位，根据屏幕分辨率动态变化\n​\t物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的\n​\t转换公式： css像素 = 物理像素 / 分辨率\n1 2 pc端 :1920 * 1080\t设计稿 :1920 * 1080px = 1920 / 1920 =1\t1个css像素（px）= 1个物理像素 ios :375 * 667\t设计稿 :750 * 1334px = 750 / 375 = 2 1个css像素（px）= 2个物理像素 不同的移动设备分辨率不同，1个CSS像素可以表示的物理像素是也不同的。\n2、rpx是微信小程序独有的、解决屏幕自适应的尺寸单位 ​\t可以根据屏幕宽度进行自适应，不论大小屏幕，规定屏幕宽为 750rpx\n3、em 是相对于当前元素的父元素的 font-size 进行计算 相对长度单位，em 是相对于当前元素的父元素的 font-size 进行计算,如果当前元素未设置则相对于浏览器的默认字体尺寸。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div class=\u0026#34;a\u0026#34;\u0026gt;A \u0026lt;div class=\u0026#34;b\u0026#34;\u0026gt;B \u0026lt;div class=\u0026#34;c\u0026#34;\u0026gt;C\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .a{ font-size:16px;} .b{ font-size:2em;} /* 相当于32px */ .c{ font-size:1em;} /* 相当于32px */ \u0026lt;/style\u0026gt; 4、rem 是相对于根元素（html）的 font-size 进行计算 ​\tCSS3 新增的一个相对单位，rem 是相对于根元素（html）的 font-size 进行计算，rem 不仅可设置字体大小，也可以设置元素宽高属性。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;div class=\u0026#34;a\u0026#34;\u0026gt;A \u0026lt;div class=\u0026#34;b\u0026#34;\u0026gt;B \u0026lt;div class=\u0026#34;c\u0026#34;\u0026gt;C\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; html{ font-size:16px;} .a{ font-size:3rem;} /* 相当于48px */ .b{ font-size:2rem;} /* 相当于32px */ .c{ font-size:1rem;} /* 相当于16px */ \u0026lt;/style\u0026gt; 5、vw / vh 相对于视窗的宽度/高度的百分比，视窗是指浏览器内部的可视区域大小 ​\tCSS3 特性 vh 和 vw：\nvh 相对于视窗的高度，视窗高度是100vh vw 相对于视窗的宽度，视窗宽度是100vw 视窗指的是浏览器内部的可视区域大小，即 window.innerWidth/window.innerHeight 大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n6、% 相对于直接父元素高度宽度百分比 1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;a\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;b\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .a{ width:200px; height:100px; background-color: aqua; } .b{ width:50%; height:50%; background-color: blueviolet; } \u0026lt;/style\u0026gt; 需要注意的是，如果设置了top、margin、padding等：\n子元素的 top 和 bottom 如果设置百分比，则相对于直接非 static 定位(默认定位)的父元素的高度 子元素的 left 和 right 如果设置百分比，则相对于直接非 static 定位(默认定位的)父元素的宽度 子元素的 padding/margin 如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的 padding/margin ，而与父元素的 height 无关。 总结 px、rpx、em、rem 、vw/vh、百分比的区别？ px：绝对长度单位，来描述一个元素的宽高以及定位信息 rpx：微信小程序独有的、解决屏幕自适应的尺寸单位 em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认16px）em作为字体单位，相对于父元素字体大小；em作为行高单位时，相对于自身字体大小，整个页面内 1em 不是一个固定的值。 rem：相对单位，可理解为”root em”，相对根节点html的字体大小来计算，CSS3新加属性，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小。rem布局的本质是等比缩放，一般是基于宽度，试想一下如果UE图能够等比缩放，那该多么美好啊 vw/vh：viewpoint width / viewpoint height，vw 相对于视窗的宽度，vh 相对于视窗的高度，1vw等于视窗宽度的1% 百分比：1% 对不同属性有不同的含义。font-size: 200% 和font-size: 2em 一样，表示字体大小是默认（继承自父亲）字体大小的2倍。line-height: 200% 表示行高是自己字体大小的 2 倍。width: 100%表示自己 content 的宽度等于父亲 content 宽度的1倍 ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/","summary":"解决方案： 1、媒体查询 百度分辨率统计 ：https://tongji.baidu.com/research/site?source=index","title":"浏览器兼容适配"},{"content":"浅拷贝（复制数据内存地址，赋值会改变原数据） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var p = { \u0026#34;id\u0026#34;:\u0026#34;007\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;刘德华\u0026#34;, \u0026#34;books\u0026#34;:new Array(\u0026#34;三国演义\u0026#34;,\u0026#34;红楼梦\u0026#34;,\u0026#34;水浒传\u0026#34;)//这是引用类型 } var p2 = {}; for(let key in p){ p2[key] = p[key];\t} p2.books[0] =\u0026#34;四国\u0026#34;; console.log(p2); //books: (3) [\u0026#34;四国\u0026#34;, \u0026#34;红楼梦\u0026#34;, \u0026#34;水浒传\u0026#34;] //id: \u0026#34;007\u0026#34; //name: \u0026#34;刘德华\u0026#34; console.log(p);\t//books: (3) [\u0026#34;四国\u0026#34;, \u0026#34;红楼梦\u0026#34;, \u0026#34;水浒传\u0026#34;] //id: \u0026#34;007\u0026#34; //name: \u0026#34;刘德华\u0026#34; 深拷贝 （复制数据，生成新的内存地址，改变新数据不改变原数据） 1 2 3 4 5 6 7 8 9 10 11 var p3 ={}; for(let key in p){ if(typeof p[key] == \u0026#34;Object\u0026#34;){ p3[key=[]] for(ket q in p[key]){ p3[key][q] = p[key][q] } }else{ p3[key] = p[key] } } 深拷贝封装函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function copy(data){ let tempData = {} for(let key in data){ if(typeof data[key] == \u0026#34;Object\u0026#34;){ tempData[key] = copy(data[key]) }else{ tempData[key] = data[key] } } return tempData } const isObj = (val) =\u0026gt; typeof val === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; val !== null; // 写法1 function deepClone(obj) { // 通过 instanceof 去判断你要拷贝的变量它是否是数组（如果不是数组则对象）。 // 1. 准备你想返回的变量（新地址）。 const newObj = obj instanceof Array ? [] : {}; // 核心代码。 // 2. 做拷贝；简单数据类型只需要赋值，复杂数据类型就再次进入进行深拷贝，直到所找到的数据为简单数据类型为止。 for (const key in obj) { const item = obj[key]; newObj[key] = isObj(item) ? deepClone(item) : item; } // 3. 返回拷贝的变量。 return newObj; } ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/3-%E8%B5%8B%E5%80%BC%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/","summary":"浅拷贝（复制数据内存地址，赋值会改变原数据） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var p = { \u0026#34;id\u0026#34;:\u0026#34;007\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;刘德华\u0026#34","title":"赋值、深拷贝、浅拷贝"},{"content":"MVVM模式 Model：负责数据存储\nView：负责页面展示\nView Model：负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示\n关于框架 为什么要学习流行框架 1、企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；企业中，使用框架，能够提高开发的效率。\n提高开发效率的发展历程：\n原生JS -\u0026gt; Jquery之类的类库 -\u0026gt; 前端模板引擎 -\u0026gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念）\n2、在Vue中，一个核心的概念就是：数据驱动，避免手动操作DOM元素。这样的话，可以让前端程序员可以更多的时间去关注数据的业务逻辑，而不是关心 DOM 是如何渲染的了。\n框架和库的区别 框架：\n框架是一套完整的解决方案。\n对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。但是优点也很明显：功能完善、提供了一整套的解决方案。\n库（插件）：\n只是提供某一个小功能。\n对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。\n举例：\n从Jquery 切换到 Zepto\n从 EJS 切换到 art-template\n前端的各种框架 Vue 和 React 的相同点 利用虚拟DOM实现快速渲染\n轻量级\n响应式组件\n支持服务器端渲染\n易于集成路由工具、打包工具以及状态管理工具\nPS：Vue 在国内很受欢迎；React 在国内和国外都很受欢迎，适合做大型网站。\n什么是虚拟 DOM 传统的web开发，是利用 jQuery操作DOM，这是非常耗资源的。\n我们可以在 JS 的内存里构建类似于DOM的对象，去拼装数据，拼装完整后，把数据整体解析，一次性插入到html里去。这就形成了虚拟 DOM。\nVue1.0没有虚拟DOM，Vue2.0改成了基于虚拟DOM。\n前端框架回顾 Vue框架中，没有控制器。\nVue 框架 发展历史 2013年底作为尤雨溪个人实验项目开始开发\n2014年2月公开发布。\n2014年11月发布0.11版本\n2016年10月发布2.0版本。\n相关网址 中文官网\nvuejs官方论坛\nGitHub地址：https://github.com/vuejs/vue\nVue1.0 在线文档：http://v1-cn.vuejs.org/guide/\nVue2.x 在线文档：https://cn.vuejs.org/v2/guide/\nVue1下载地址：http://v1-cn.vuejs.org/js/vue.js\nVue2下载地址：https://cdn.jsdelivr.net/npm/vue/\n上方截图的时间：2018-03-02。\n介绍 Vue 本身并不是一个框架，Vue结合周边生态构成一个灵活的、渐进式的框架。\nVue 以及大型 Vue 项目所需的周边技术，构成了生态。\n渐进式框架图：\nVue框架的特点 模板渲染：基于 html 的模板语法，学习成本低。\n响应式的更新机制：数据改变之后，视图会自动刷新。【重要】\n渐进式框架\n组件化/模块化\n轻量：开启 gzip压缩后，可以达到 20kb 大小。（React 达到 35kb，AngularJS 达到60kb）。\nVue 的环境搭建 我们首先要安装好 NVM、Node.js环境，然后再来做下面的操作。\n常见的插件 Webpack：代码模块化构建打包工具。\nGulp：基于流的自动化构建工具。\nBabel：使用最新的 规范来编写 js。\nVue：构建数据驱动的Web界面的渐进式框架\nExpress：基于 Node.js 平台，快速、开放、极简的 Web 开发框架。\n以上这些包，都可以通过 NPM 这个包管理工具来安装。\n引用 Vue.js 文件 1、方式一：（CDN的方式进行引用）\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2、方式二：（下载 vue.js 文件）\n去网站 https://cdn.jsdelivr.net/npm/vue/ 下载 vue.js 文件，直接放到工程文件里，然后引用。\n3、方式三：（NPM的方式安装vue）\n1 2 # 最新稳定版 $ npm install vue 如果网络不稳定，可以采用下面的方式安装：\n1 cnpm i vue --save 然后在代码中通过下面这种方式进行引用：\n1 import Vue from \u0026#39;vue\u0026#39; 利用 vue-cli 新建一个空的项目 Vue 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目。\n官方代码参考 1 2 3 4 5 6 7 npm install -g @vue/cli vue create my-app cd my-app npm run serve 我们根据上方的参考代码，来看看“利用 vue-cli 新建一个空的项目”的步骤。\n安装 vue-cli（命令行工具） 安装命令如下：\n1 2 # 全局安装 vue-cli $ npm install -g @vue/cli 初始化一个 simple 项目 （1）首先执行：\n1 vue create my-app 输入上方命令后，会弹出一个选项：\n如果是初学者，直接选default就行。之后会自动生成一个空的初始化项目，包含了项目目录、以及项目依赖的脚本。\n这个空项目的工程文件如下：（请务必仔细研究这个项目的写法和目录结构）\n2019-06-21-vue-my-app.zip 我们可以看到这个项目的结构：\nsrc：项目源码\n.babelrc：ES6编译插件的配置\nindex.html：单页面的入口\n上方截图中，npm install指的是下载各种依赖包，npm run dev指的是打开发包，npm run build指的是打生产包。\n（2）本地运行项目：\n1 2 3 cd my-app npm run serve 浏览器输入http://localhost:8080/，就可以让这个空的项目在本地跑起来：\n备注：我们在 GitHub上下载的任何Vue有关的项目，第一步都是要首先执行 npm install，安装依赖的 mode_modules，然后再运行。我们发给同事的工程文件，建议不要包含 node_modules。\n构建一个 非 simple 项目 构建一个空的项目，首先执行：\n1 vue create vuedemo2 上图中，选择 Manually select features，然后根据提示依次输入：\nproject name：要求小写。\ndescription：默认即可。\nvue-router：需要。\nESlint：语法检查，初学者可以暂时不需要。\n单元测试：暂时也不需要。\ne2e test：不需要。\n选择 eslint 的配置：\n然后让这个空的项目就可以在浏览器上跑起来。\nvue 项目结构分析 buid：打包配置的文件夹\nconfig：webpack对应的配置\nsrc：开发项目的源码\nApp.vue：入口组件。.vue文件都是组件。 main.js：项目入口文件。 static：存放静态资源\n.babelrc：解析ES6的配置文件\n.editorcofnig：编辑器的配置\n.postcssrc.js：html添加前缀的配置\nindex.html：单页面的入口。通过 webpack打包后，会把 src 源码进行编译，插入到这个 html 里面来。\npackage.json：项目的基础配置，包含版本号、脚本命令、项目依赖库、开发依赖库、引擎等。\n图片的base64编码 默认是10k以下，建议都通过 base64编码。在配置文件webpack.base.conf.js中进行修改：\n1 2 3 4 5 6 7 { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: \u0026#39;url-loader\u0026#39;, options: { limit: 10000, name: utils.assetsPath(\u0026#39;img/[name].[hash:7].[ext]\u0026#39;) } ","permalink":"https://bablvsj.github.io/posts/tech/wait/11-vue%E5%9F%BA%E7%A1%80/00-vue%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8Cvue-cli/","summary":"MVVM模式 Model：负责数据存储 View：负责页面展示 View Model：负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示","title":"00-Vue的介绍和vue-cli"},{"content":"v-on的按键修饰符 Vue 内置的按键修饰符 通俗一点讲，指的是：监听键盘输入的事件。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符。如下：\nVue内置的按键修饰符：\n1 2 3 4 5 6 7 8 9 10 .enter .tab .delete (捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right 1.0.8+版本：支持单字母的按键别名。 比如说，keyup指的是：键盘（任何键位）抬起时的监听事件。.enter指的是：按enter键的按键修饰符。我们把这两个结合起来看看。\n@keyup.enter举例：按enter键后的监听事件\n@keyup.enter=\u0026quot;addData\u0026quot;表示：按住enter键后，执行addData()方法。全称是v-on:key.enter=\u0026quot;addData\u0026quot;。\n我们还是拿01-04这篇文章中的列表功能来举例。之前是点击“添加”按钮后，列表中会添加一个item。现在要求：在输入框中按enter键后，也能添加一个item。\n核心代码如下：\n1 \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;formData.name\u0026#34; @keyup.enter=\u0026#34;addData\u0026#34;\u0026gt; 注意，如果写成@keyup=\u0026quot;addData\u0026quot;，效果却是：只要键盘的任何键位打了字（还没来得及按enter键），就会执行addData()方法，这种效果显然不是我们想要的。所以要加上修饰符.enter，表示只针对enter键。\n自定义的按键修饰符 如果我们直接在代码的\u0026lt;input\u0026gt;标签里写@keyup.f2=\u0026quot;addData\u0026quot;，那么，按住「F2键」后，是没有效果的，因为「F2键」不是内置的按键修饰符（如果F2不能验证，你可以试一下F7）。\n我们知道，每个按键都有一个键盘码。参考链接：\njs 里面的键盘事件对应的键码 通过查阅，我们知道了「F2键」的键盘码为113，那代码可以这样写：（按住F2键后，执行 addData 方法）\n1 \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;formData.name\u0026#34; @keyup.113=\u0026#34;addData\u0026#34;\u0026gt; 虽然键盘码很全，但是不好记呀。于是，接下来，我们给键盘码定义别名。\n自定义全局按键修饰符：\n1 2 //自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113; 上方代码的书写位置，与自定义全局过滤器的位置，是并列的。\n然后，我们就可以使用键盘码的别名了。\n自定义全局指令 自定义全局指令的举例1 举例1：让指定文本框自动获取焦点\n如果我们想实现这个例子，原生js的写法是：\n1 2 //原生js写法：网页一打开，就让指定的输入框自动获取焦点 document.getElementById(\u0026#39;search\u0026#39;).focus() 代码的位置：\n但我们不建议这样做。我们可以通过Vue中的自定义指令来实现这个例子。步骤如下。\n（1）使用Vue.directive()自定义全局指令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //自定义全局指令 v-focus：让文本框自动获取焦点 //参数1：指令的名称。注意，在定义的时候，指令的名称前面，不需要加 v- 前缀；但是：在`调用`的时候，必须在指令名称前 加上 v- 前缀 //参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive(\u0026#39;focus\u0026#39;, { //在每个函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象（DOM对象） bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 } }) 上方的代码中，如果我们把el.focus()这行代码写在bind方法里，是没有效果的（但不会报错）。没有效果是因为，在执行到bind方法的时候，元素还没有插入到dom中去。\n由此可以看看出：bind、inserted、updated这三个钩子函数的执行时机不同，且执行的次数有区别。\n（2）在指定的文本框上加``：\n1 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search\u0026#34; v-model=\u0026#34;keywords\u0026#34; v-focus\u0026gt; 完整版代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;vue2.5.16.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 搜索框： \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search\u0026#34; v-model=\u0026#34;name\u0026#34; v-focus\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //自定义全局指令 v-focus，让文本框自动获取焦点 //参数1：指令的名称。注意，在定义的时候，指令的名称前面，不需要加 v- 前缀；但是：在`调用`的时候，必须在指令名称前 加上 v- 前缀 //参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive(\u0026#39;focus\u0026#39;, { //在每个函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象（DOM对象） bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 } }) new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;smyhvae\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 自定义全局指令：使用钩子函数的第二个binding参数拿到传递的值 举例2：设置DOM元素的color样式\n参考举例1中的写法，我们可能会这样给DOM元素设置样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;vue2.5.16.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 搜索框： \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search\u0026#34; v-model=\u0026#34;name\u0026#34; v-color\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //自定义全局指令 v-color：设置DOM元素的color属性 Vue.directive(\u0026#39;color\u0026#39;, { bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 el.style.color = \u0026#39;red\u0026#39;; }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 //el.focus() }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 } }) new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如上方代码所示，我们自定义了一个指令v-color，然后在input标签中用上了这个指令，就给元素设置了color属性。但是这个代码有个弊端是：color的属性值在定义指令的时候，被写死了。如何完善呢？我们可以在DOM元素中传参。一起来看看。\n代码如下：【荐】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;vue2.5.16.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 搜索框1： \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search\u0026#34; v-model=\u0026#34;name\u0026#34; v-color=\u0026#34;\u0026#39;green\u0026#39;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //自定义全局指令 v-color：设置DOM元素的color属性 Vue.directive(\u0026#39;color\u0026#39;, { // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 // 意思是说，我们可以把样式的代码写到bind中去（即使这个时候，dom元素还没有被创建） bind: function (el, binding) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 console.log(binding.name); //打印结果：color console.log(binding.value); //打印结果：green console.log(binding.expression); //\u0026#39;green\u0026#39; el.style.color = binding.value// 通过bining拿到v-color中传递过来的值 }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 //el.focus() }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 } }) new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;smyhvae\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中,bind方法里传递的第二个参数binding，可以拿到DOM元素中v-color里填的值。注意，v-color=\u0026quot;'green'\u0026quot;，这里面写的是字符串常量；如果去掉单引号，就成了变量，不是我们想要的。\n效果：\n自定义全局指令的简写形式：\n在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如上面的代码中，我们可以写成简写形式：\n1 2 3 Vue.directive(\u0026#39;color\u0026#39;, function (el, binding) { //注意，这个function等同于把代码写到了 bind 和 update 中去 el.style.color = binding.value }) 自定义私有指令 自定义私有指令：在某一个 vue 对象内部自定义的指令称之为私有指令。这种指令只有在当前vue对象的el指定的监管区域有用。\n代码举例：（设置文字的font-weight属性）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;vue2.5.16.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;span v-fontweight=\u0026#34;600\u0026#34;\u0026gt;生命壹号\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;smyhvae\u0026#39; }, //自定义私有指令 directives: { \u0026#39;fontweight\u0026#39;: { bind: function (el, binding) { el.style.fontWeight = binding.value; } } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n注意， el.style.fontWeight设置属性值，至少要600，否则看不到加粗的效果。\n自定义私有指令的简写形式：\n在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如上面的代码中，我们可以写成简写形式：\n1 2 3 4 5 6 //自定义私有指令（简写形式） directives: { \u0026#39;fontweight\u0026#39;: function (el, binding) { //注意，这个function等同于把代码写到了 bind 和 update 中去 el.style.fontWeight = binding.value; } } ","permalink":"https://bablvsj.github.io/posts/tech/wait/11-vue%E5%9F%BA%E7%A1%80/01-06.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","summary":"v-on的按键修饰符 Vue 内置的按键修饰符 通俗一点讲，指的是：监听键盘输入的事件。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符。如下： Vue内置","title":"01-06.自定义按键修饰符\u0026自定义指令"},{"content":"GitHub 排名统计 GitHub 中文排行榜、高分优秀中文项目：https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts\nGitHub 全球排名：https://gitstar-ranking.com/\n这个排名很权威。如果你的项目超过 10k star，就能上榜，跻身全球 GitHub 项目前1000名。\nGitHub trending（官网推荐）：https://github.com/trending 你的项目要是能上 GitHub trending，绝对火得一塌糊涂。\nGitHub 中国区排名：https://githuber.cn/search?language=JavaScript 这个网站虽然比较小众，但排名还是相对比较准的。\nGitHub 中国区排名：http://githubrank.com/ 这个排名很久没更新了，早就不准了；而且还经常打不开。\n资讯 36氪：https://36kr.com/\n虎嗅网：https://www.huxiu.com/\n利器：https://liqi.io/\n采访优秀的创造者，邀请他们来分享工作时所使用的工具。\n湾区日报：https://wanqu.co/ 每天推送 5 篇优质英文文章。\nSolidot：https://www.solidot.org/\n品玩：https://www.pingwest.com/\n极客公园：http://www.geekpark.net/\n框架 Vue.js：https://cn.vuejs.org/\nReact：https://reactjs.org/\nAngular：https://angular.cn/\nAngularJS：https://angularjs.org/\nKoa：https://koa.bootcss.com/\n基于 Node.js 平台的下一代 Web 开发框架。\nExpress：http://www.expressjs.com.cn/ 基于 Node.js 平台，快速、开放、极简的 Web 开发框架。\nEgg：https://eggjs.org/zh-cn/ Egg 继承于 Koa。\nKoa 是一个非常优秀的框架，然而对于企业级应用来说，它还比较基础。而 Egg 选择了 Koa 作为其基础框架，在它的模型基础上，进一步对它进行了一些增强。\nElectron：https://www.electronjs.cn/ Electron（原名为Atom Shell）是GitHub开发的一个开源js框架。 它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。\n也就是说，我们可以用 js 语言开发客户端软件了。其实呢，VS Code 这个客户端软件就是用 js 语言写的。\nRedux：https://www.redux.org.cn/ Redux 是 JavaScript 状态容器，提供可预测化的状态管理。\nReactNative：https://reactnative.cn/ 使用JavaScript编写原生移动应用。\nmpvue：http://mpvue.com/ 基于 Vue.js 的小程序开发框架。\nUI框架 ElementUI：http://element-cn.eleme.io/ 基于 Vue.js 的组件库。\niView：https://www.iviewui.com/ 一套基于 Vue.js 的高质量 UI 组件库。\nAnt Design：https://ant.design 基于 React 的 UI 组件库，主要用于研发企业级中后台产品。官网推出了 Ant Design pro 作为示例，可以看看。\nAnt Design Mobile：https://mobile.ant.design/ 一个基于 Preact / React / React Native 的 移动端 UI 组件库。\nAnt Design of Vue：https://vue.ant.design/docs/vue/introduce-cn/ Ant Design 的 Vue 实现，开发和服务于企业级后台产品。\n类库 jQuery：http://jquery.com/\nZepto.js：https://zeptojs.com/\n可以理解成是移动端的 jQuery。\nECharts：https://echarts.baidu.com/ 使用 JavaScript 实现的开源可视化库。\nCSS Sass：https://sass-lang.com/ Sass 是成熟、稳定、强大的 CSS 扩展语言。入门文档可以看：http://sass.bootcss.com/\nLess：http://lesscss.org/ 给 CSS 加点料。入门文档可以看：https://less.bootcss.com/\nStylus：http://stylus-lang.com/ 构建 NPM：https://www.npmjs.com/\nYarn：https://yarnpkg.com/zh-Hans/\nWebpack：https://webpack.js.org/\nGulp：https://www.gulpjs.com.cn/\nBabel：https://babeljs.io/\nESLint：https://cn.eslint.org/\n可组装的JavaScript和JSX检查工具。\nPostCSS：https://www.postcss.com.cn/ 用 JavaScript 工具和插件转换 CSS 代码的工具\n调试抓包 whistle：https://wproxy.org/whistle/ 代理抓包工具，很好很强大。\nFiddler：https://www.telerik.com/fiddler 代理抓包工具。\nMock数据 Easy Mock：https://www.easy-mock.com 编辑器 \u0026amp;\u0026amp; IDE VS Code：https://code.visualstudio.com/\nSublime Text：https://www.sublimetext.com/\nWebStorm：https://www.jetbrains.com/webstorm/\nAtom：https://atom.io/\n编码规范 Bootstrap编码规范：https://codeguide.bootcss.com/\nes6编程风格：http://es6.ruanyifeng.com/#docs/style\nAirbnb Javascript Style Guide：https://github.com/airbnb/javascript\n静态站点搭建工具 Hexo：https://hexo.io/zh-cn/\nVuePress：https://www.vuepress.cn/\nGitBook：https://www.gitbook.com/\n设计工具 墨刀：原型设计工具。网址：https://modao.cc/\n蓝湖：一款产品文档和设计图的在线协作平台。网址：https://lanhuapp.com\nPxCook（像素大厨）：高效易用的自动标注工具。软件下载链接：https://www.fancynode.com.cn/pxcook\n图标 Font Awesome：http://www.fontawesome.com.cn/\nIconfont：https://www.iconfont.cn/\nicomoon：https://icomoon.io/\nEasyIcon：https://www.easyicon.net/\nicons8：https://icons8.cn/\nIconStore：https://iconstore.co/\niconninja：http://www.iconninja.com/\n设计素材 设优 SHEUI：http://www.sheui.com/Contact/ 工具 综合类 CanIUse：https://caniuse.com/ 浏览器兼容性查询。前端同学必须要知道。\n国家企业信用信息公示系统：http://www.gsxt.gov.cn 通过这个网站，我们可以查到任何一家公司的基本信息（成立时间、法定代表人等）。如果你在这个网站上没有找到某公司的信息，放心吧，这个公司一定是个骗子。\nProcessOn：https://www.processon.com/ 在线制作流程图。推荐。\n幕布：https://mubu.com 极简大纲笔记、一键生成思维导图。非常好用。\nJSON格式化：http://www.bejson.com/\n草料二维码：https://cli.im/\n短链生成：http://www.sina.lt\nGitHub短网址：https://git.io/\n图片压缩：https://tinypng.com/\n熊猫压缩。压缩后图片清晰度不会有太大变化。\n图片压缩：https://www.yasuotu.com/\n在线PS：https://www.photopea.com/\n图片在线裁剪：https://www.asqql.com/gifc/\n多数据源IP地址查询：https://haoip.cn/\nGif添加字幕：http://www.yingjingtu.com/\nPhotoshop的投影参数转换为 CSS代码：https://psd2css.mezw.com/\n将Photoshop设计文件图层中的混合选项参数快速转换为CSS3代码，以节省前端开发人员的时间和精力。\nGet Emoji：https://emoji.svend.cc/\n图片转Ascii：http://picascii.com/\n视频转GIF：https://github.com/vvo/gifify\nOCR文字识别：https://app.xunjiepdf.com/ocr\n图片类 图片转base64：http://imgbase64.duoshitong.com/ 前端周刊 WecTeam 前端周刊：https://github.com/wecteam/weekly\nJs中文网周刊：https://www.javascriptc.com/category/javascript-weekly\n政采云 前端周刊：https://weekly.zoo.team/\n团队 腾讯AlloyTeam：http://www.alloyteam.com/\n腾讯社交用户体验ISUX：https://isux.tencent.com/\n淘宝FED | 淘宝前端团队：http://taobaofed.org/\n阿里巴巴国际UED：http://www.aliued.com/\n京东 | 凹凸实验室：https://aotu.io/\n饿了么前端:https://zhuanlan.zhihu.com/ElemeFE\n百度前端研发部FEX：http://fex.baidu.com/\n360 | 奇舞团：https://75team.com/\n知道创宇FED：https://knownsec-fed.com/\n前端大牛 阮一峰（蚂蚁金服） GitHub：https://github.com/ruanyf\n博客：http://www.ruanyifeng.com/blog/\n尤雨溪 GitHub：https://github.com/yyx990803\n博客：http://blog.evanyou.me/\n知乎：https://www.zhihu.com/people/evanyou\n玉伯 GitHub：https://github.com/lifesinger\n博客：https://github.com/lifesinger/blog\n知乎：https://www.zhihu.com/people/lifesinger\n司徒正美（去哪儿） GitHub：https://github.com/RubyLouvre\n博客：http://www.cnblogs.com/rubylouvre/\n知乎：https://www.zhihu.com/people/si-tu-zheng-mei\n张鑫旭（腾讯） GitHub：https://github.com/zhangxinxu\n博客：https://www.zhangxinxu.com/\n知乎：https://www.zhihu.com/people/iamzhangxinxu\n迷渡 GitHub：https://github.com/justjavac\n知乎：https://www.zhihu.com/people/justjavac.com\n羡辙 | Ovilia GitHub：https://github.com/Ovilia\n知乎：https://www.zhihu.com/people/ovilia\n云谦（陈成） GitHub：https://github.com/sorrycc\n博客：https://sorrycc.com/\n云谦装了啥：https://github.com/sorrycc/awesome-tools\n偏右 GitHub：https://github.com/afc163\n知乎：https://www.zhihu.com/people/afc163\n黄峰达/Phodal Huang（ThoughtWorks） GitHub：https://github.com/phodal\n博客：https://www.phodal.com/\n知乎：https://www.zhihu.com/people/phodal\n贺师俊/Hax（百姓网） GitHub：https://github.com/hax\n博客：http://johnhax.net/\n知乎：https://www.zhihu.com/people/he-shi-jun\n大漠 链接：\nGitHub：https://github.com/airen 大漠的GitHub上没啥东西。\n博客：https://www.w3cplus.com\n知乎：https://www.zhihu.com/people/w3cplus\n介绍：\n常用昵称“大漠”，W3CPlus创始人，目前就职于淘宝。对HTML5、CSS3和CSS处理器等前端脚本语言有非常深入的认识和丰富的实践经验，尤其专注对CSS3和动画的研究，是国内最早研究和使用CSS3和CSS处理器技术的一批人。现在主要在探讨学习JavaScript、React和Vue相关技术知识。CSS、CSS处理器和Web动画中国布道者。2014年出版《图解CSS3：核心技术与案例实战》。\nEGOIST 博客：https://egoist.sh/\nGitHub：https://github.com/egoist\n冴羽 链接：\nGitHub：https://github.com/mqyqingfeng\n博客：https://github.com/mqyqingfeng/Blog\n知乎：https://www.zhihu.com/people/qing-feng-yi-yang\n李靖/小胡子哥（淘宝网） GitHub：https://github.com/barretlee\n博客：https://www.barretlee.com/\n知乎：https://www.zhihu.com/people/barretlee/\ncangdu GitHub：https://github.com/bailicangdu Jackson Tian GitHub：https://github.com/JacksonTian\n博客：http://jacksontian.org/\n题叶（饿了么、前 Teambition） GitHub：https://github.com/jiyinyiyong\n博客：http://tiye.me/\n杨健（今日头条） GitHub：https://github.com/hardfist\n知乎：https://www.zhihu.com/people/hardfist\n流形 （阿里巴巴数据技术与产品部前端团队负责人）\n知乎：https://www.zhihu.com/people/arcthur/ GitHub 作者推荐 晴小篆 GitHub：https://github.com/yanlele MuYunyun GitHub：https://github.com/MuYunyun ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/01-2020%E5%B9%B4web%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E5%AF%BC%E8%88%AA/","summary":"GitHub 排名统计 GitHub 中文排行榜、高分优秀中文项目：https://github.com/kon9chunkit/GitHub-Chinese-Top","title":"01-2020年Web前端最新导航"},{"content":"todo rpc 和 Node.js 的关系\n《吊打面试官》系列 Node.js 全栈秒杀系统\n前言 Node 的重要性已经不言而喻，很多互联网公司都已经有大量的高性能系统运行在 Node 之上。Node 凭借其单线程、异步等举措实现了极高的性能基准。此外，目前最为流行的 Web 开发模式是前后端分离的形式，即前端开发者与后端开发者在自己喜欢的 IDE 上独立进行开发，然后通过 HTTP 或是 RPC 等方式实现数据与流程的交互。这种开发模式在 Node 的强大功能的引领下变得越来越高效，也越来越受到各个互联网公司的青睐。\n前端同学为什么要学习后端/后端同学为什么要学习前端 了解前后端交互流程。\n前端同学能够和后台开发的程序员更佳紧密地结合、更顺畅地沟通。\n当网站的业务逻辑需要前置时，前端人员需要学习一些后台开发的技术，以完成相应的任务；；反过来也一样。\n拓宽知识视野和技术栈，能够站在全局的角度审视整个项目。\n前端同学为什么要学 Node.js 1、Node.js 使用 JavaScript 语言开发服务器端应用，便于前端同学上手（一些公司甚至要求前端工程师掌握 Node.js 开发）。\n2、实现了前后端的语法统一，有利于和前端代码整合，甚至共用部分代码。\n比如说，针对接口返回的各种字段，前后端都必须要做校验。此时，如果用 Node.js 来做后台开发的话，前后端可以共用校验的代码。\n3、Node.js 性能高、生态系统活跃，提供了大量的开源库。\n4、Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。 Jeff Atwood 是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n后端同学为什么要学 Node.js 因为前端同学在学 Node.js。\n什么是 Node.js 官方定义 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O的模型，使其轻量又高效。Node.js 的包管理工具 npm 是全球最大的开源库生态系统。\nNode.js 不是一门语言，也不是 JavaScript 的框架，也不是像Nginx一样的Web服务器 ，Node.js 是 JavaScript 在服务器端的运行环境（平台）。\nNode.js 的组成 在 Node.js 里运行 JavaScript，跟在 Chrome 里运行 JavaScript 有什么不同？\n二者采用的是同样的 JS 引擎。在 Node.js 里写 JS，和在前端写 JS，几乎没有不同。在写法上的区别在于：Node.js 没有浏览器、页面标签相关的 API，但是新增了一些 Node.js 相关的 API。通俗来说，对于开发者而言，在前端写 JS 是用于控制浏览器；而 Node.js 环境写 JS 可以控制整个计算机。\n我们知道，JavaScript 的组成分为三个部分：\nECMAScript\nDOM：标签元素相关的API\nBOM：浏览器相关的API\nECMAScript 是 JS 的语法；DOM 和 BOM 浏览器端为 JS 提供的 API。\n而 Node.js 的组成分为：\nECMAScript。ECMAScript 的所有语法在 Node 环境中都可以使用。\nNode 环境提供的一些附加 API(包括文件、网络等相关的 API)。\n如下图所示：\n补充 与 PHP、JSP、Python、Perl、Ruby 的“既是语言，也是平台”不同，Node.js 的使用 JavaScript 进行编程，运行在 Chrome 的 V8 引擎上。\n与 PHP、JSP 等相比（PHP、JSP、.net 都需要运行在服务器程序上，Apache、Nginx、Tomcat、IIS。 ），Node.js 跳过了 Apache、Naginx、IIS 等 HTTP 服务器，它自己不用建设在任何服务器软件之上。Node.js 的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js 没有 web 容器。\nJS 语言非常灵活，使得它在严谨性方面不如 Java 等传统的静态语言。JS 是一门动态语言，而且融合了面向对象和函数式编程这两种编程范式。\n随着 ES6、ES7 等 JS 语法规范的出现，以及浏览器对这些规范的支持，使得我们可以用更为现代化的 JS 语言特性，来编写现代化的应用。\nNode.js 的架构和依赖 Node.js 的架构如下：\nNode.js 内部采用 Google Chrome 的 V8 引擎，作为 JavaScript 语言解释器；同时结合自行开发的 libuv 库，扩展了 JS 在后端的能力（比如 I/O 操作、文件读写、数据库操作等）。使得 JS 既可以在前端进行 DOM 操作（浏览器前端），又可以在后端调用操作系统资源，是目前最简单的全栈式语言。\n其次，Node 生态系统活跃，提供了大量的开源库，使得 JavaScript 语言能与操作系统进行更多的交互。\nNode.js 运行环境的核心：V8 引擎 和 libuv 库 Node.js 是 JavaScript 在服务器端的运行环境，在这个意义上，Node.js 的地位其实就是 JavaScript 在服务器端的虚拟机，类似于 Java 语言中的 Java 虚拟机。\nV8 引擎 ：编译和执行 JS 代码、管理内存、垃圾回收。V8 给 JS 提供了运行环境，可以说是 JS 的虚拟机。V8 引擎本身是用 C++ 写的。\nlibuv： libuv 是一个专注于异步 I/O 的跨平台类库，目前主要在 Node.js 上使用。它是 Node.js 最初的作者 Ryan Dahl 为 Node.js 写的底层类库，也可以称之为虚拟机。libuv 本身是用 C 写的。\nJava 虚拟机和 V8 引擎，是由同一人开发 Chrome 浏览器成功的背后，离不开 JS 的 V8 引擎。作为虚拟机，V8 的性能表现优异，它的开发者是 Lars Bak。在 Lars 的工作履历里，绝大部分都是与虚拟机相关的工作。在开发 V8 之前，他曾经在 Sun 公司工作，担任 HotSpot 团队的技术领导，主要致力于开发高性能的 Java 虚拟机。在这之前，他也曾为 Self、Smalltalk 语言开发过高性能虚拟机。这些无与伦比的经历让 V8 一出世就超越了当时所有的 JS 虚拟机。\nV8 的性能优势使得用 JavaScript 写高性能后台服务程序成为可能。在这样的契机下，Ryan Dahl 选择了 JavaScript，选择了 V8，在事件驱动、非阻塞 I/O 模型的设计下实现了 Node。\nV8 的内存限制 在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4GB，32 位系统下约为 0.7GB）。在这样的限制下，将会导致 Node 无法直接操作大内存对象。\n造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。V8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在 Node 中，这却限制了开发者随心所欲使用大内存的想法。\nNode 的发展历史 2008 年左右，随着 Ajax 的逐渐普及，Web 开发逐渐走向复杂化，系统化；\nNode.js 诞生于 2009 年，由 Joyent 的员工 Ryan Dahl 开发而成。2009 年 5 月，Ryan Dahl 在 GitHub 中开源了 Node 的最初版本，同年 11 月，在 JSConf 大会上展示了 Node 项目；\n2010 年 1 月，NPM 包管理工具诞生，使得程序员能够更方便地发布和分享 Node.js 的第三方库。\nNode.js 最初只支持 Linux 和 Mac OS 操作系统。2011 年 7 月，微软参与合作，Node.js 终于支持了 Windows 平台。PS：不过，node 的生产环境基本是在 Linux 下。\n目前官网最新版本已经更新到 14.x.x 版本，最新稳定的是 12.18.0。\n据 Node.js 创始人 Ryan Dahl 回忆，他最初希望采用 Ruby，但是 Ruby 的虚拟机效率不行。\n注意：是 Node 选择了 JavaScript，不是 JavaScript 发展出来了一个 Node。\nNode.js 的应用 Node.js 拥有强大的开发者社区，现在已经发展出比较成熟的技术体系，以及庞大的生态。它被广泛地应用在 Web 服务、开发工作流、客户端应用等诸多领域。其中，在 Web 服务领域，业界对 Node.js 的接受程度最高。\n1、BFF 中间层 BFF，即 Backend For Frontend（服务于前端的后端）。玉伯在《从前端技术进化到体验科技》这篇文章中点出了 BFF 层的概念：\nBFF 模式下，整体分工很清晰，后端通过 Java/C++ 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。\n在 Web 服务里，搭建一个中间层，前端访问中间层的接口，中间层再访问后台的 Java/C++ 服务。这类服务的特点是不需要太强的服务器运算能力，但对程序的灵活性有较高的要求。这两个特点，正好和 Node.js 的优势相吻合。Node.js 非常适合用来做 BFF 层，优势如下：\n对于前端来说：让前端有能力自由组装后台数据，这样可以减少大量的业务沟通成本，加快业务的迭代速度；并且，前端同学能够自主决定与后台的通讯方式。\n对于后台和运维来说，好处是：安全性（不会把主服务器暴露在外面）、降低主服务器的复杂度等。\n2、服务端渲染 客户端渲染（CSR / Client side render）：前端通过一大堆接口请求数据，然后通过 JS 动态处理和生成页面结构和展示。优点是前后端分离、减小服务器压力、局部刷新。缺点是不利于 SEO（如果你的页面然后通过 Ajax 异步获取内容，抓取工具并不会等待异步完成后再行抓取页面内容）、首屏渲染慢。\n服务端渲染（SSR / Server Side Render）：服务器返回的不是接口数据，而是一整个页面（或整个楼层）的 HTML 字符串，浏览器直接显示即可。也就是说，在服务器端直接就渲染好了，然后一次性打包返回给前端。优点是有利于 SEO、首屏渲染很快。\n总结： 搜索引擎优化 + 首屏速度优化 = 服务端渲染。\n备注：这里的「服务端渲染」只是让 Node.js 做中间层，不会替代后端的，后台同学请放心。\n参考链接：\nVue 服务端渲染的概念\nhttps://blog.csdn.net/u012036171/article/details/88833200\nhttps://juejin.im/post/5c068fd8f265da61524d2abc\n方应杭\n历史回顾：\n（1）一开始，页面很简单，html 是后端渲染的（比如PHP、ASP、JSP等方式）。后端发现页面中的 js 好麻烦（虽然简单，但是坑多），于是让公司招聘专门写 js 的人，简称「前端切图仔」。\n（2）随着 Node.js 和前端 MVC 的兴起，以及前端越来越复杂，慢慢演变成了「前后端分离」。\n（3）前端的 SPA 应用流行之后，发现 SEO 问题很大，而且首屏渲染速度很慢，但是自己选的路再难走也要走下去，于是用 Node.js 在服务端渲染被看成是一条出路。\n（4）以前在一起的时候，是后端做部分前端的工作；现在在一起的时候，是前端做部分后端的工作。\n3、做小型服务、小型网站的后端（基于 Express、Koa 框架） 现在很多公司的后台管理系统，都是用 Node.js 来开发接口，毕竟，后台管理系统对性能和并发的要求不是太高。有了 Node.js 之后，通过 JS 直接操作 DB，做增删改查，生成接口，极大降低了前端同学的学习门槛。\n当然，有时候做 Node.js 开发，是因为：后台人力不够，所以把后台开发的一部分工作量，转移给前端同学。\n4、做项目构建工具 前端正在广泛使用的构建工具 gulp、Webpack，就是基于 Node.js 来实现的。\n5、 做 PC 端的软件（基于 Electron 框架） Electron 框架就是基于 Node.js 的。也可以说：Electron 是 Node.js 在PC客户端的技术。\n有一点你可能会感到惊讶：程序员们都在用的代码编辑器 VS Code 软件， 就是用 JS 语言实现的。\n还有一个例子是：电子游戏直播网站 Twitch，号称是国外游戏直播的鼻祖，它在 PC 端的客户端软件，就是用 Electron 框架的。你会发现，Twitch 的网站视觉，和 PC 端的视觉，几乎是一样的。如果两端都采用 JS 语言，就可以极大的复用现有的工程。\n知名度较高的 Node.js 开源项目 express：Node.js 中著名的 web 服务框架。\nKoa：下一代的 Node.js 的 Web 服务框架。所谓的“下一代”是相对于 Express 而言的。\nEgg：2016 年，阿里巴巴研发了知名的 Egg.js 开源项目，号称企业级 Web 服务框架。Egg.js 是基于 Koa 开发的。\nmocha：是现在最流行的 JavaScript 测试框架，在浏览器和 Node 环境都可以使用。\nPM2：node 多进程管理。\njade：非常优秀的模板引擎，不仅限于 js 语言。\nCoffeeScript：用简洁的方式展示 JavaScript 优秀的部分。\nAtom：编辑器。\nVS Code：最酷炫的编辑器。\nsocket.io：实时通信框架。\n总结 或许，能用 Node.js 做的后台应用，Java/C++ 也能做；但是 Node.js 可以让我们多一种选择。\n短期来看，Node.js 很难像 Java/C++ 那样，成为后台的主力开发语言。这并非是因为 Node.js 的性能问题，主要是因为，Node.js 还比较年轻，经验积累太少，框架的支持度不够。搞企业级服务，Node.js 敌不过 Java/C++，所以目前只能搞「轻量级」；但未来可期。\n限制语言能力的不是语言本身，而是生态。\n最后一段：前端同学会 Node.js 就真的全栈了吗？ 一个人的精力是有限的，既擅长前端、又精通后端的人，毕竟是极少数。\n林肯说过：“你可以在所有的时间欺骗一部分人，也可以在一段时间欺骗所有的人，但你不可能在所有的时间欺骗所有的人”。\n同样的，我也说过：“你可以在这一段时间擅长前端技术，也可以在另一段时间擅长后台技术，但你不可能在同一段时间同时擅长前端和后台，更不可能在所有的时间同时擅长前端和后台。”\n所谓的全栈，只是一个伪命题。个人不一定需要全栈，企业和项目也不强制要求全栈，分工协作，才最高效。\n对于个人而言，虽然全栈很难，但是 Node.js 的出现，让 JS 语言实现了前后端语法的统一，让 JS 语言的技术栈更佳全面。\n涉及到后台开发相关的技术，无论如何，也绕不开框架设计、开发调试、数据库操作、高并发处理、大规模存储、性能优化、容灾方案、RPC 调用、进程管理、操作系统调度、网络安全、系统运维、日常维护、甚至是 Linux 内核、驱动开发等过硬的知识技能和经验积累。等你亲身经历过这些，才算明白：语言只是一种工具。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/01-node.js%E4%BB%8B%E7%BB%8D/","summary":"todo rpc 和 Node.js 的关系 《吊打面试官》系列 Node.js 全栈秒杀系统 前言 Node 的重要性已经不言而喻，很多互联网公司都已经有大量的高性能系统运行在 Node 之上。Node 凭借其","title":"01-Node.js介绍"},{"content":"虚拟DOM和diff算法 在学习 React 之前，我们需要先了解两个概念：虚拟DOM、diff算法。\n虚拟DOM 问题描述：\n假设我们的数据发生一点点的变化，也会被强制重建整颗DOM树，这么做，会涉及到很多元素的重绘和重排，导致性能浪费严重。\n解决上述问题的思路：\n实现按需更新页面上的元素即可。也就是说，把 需要修改的元素，所对应的 DOM 元素重新构建；其他没有变化的数据，所对应的 DOM 节点不需要被强制更新。\n具体实现方案：（如何按需更新页面上的元素）\n只需要拿到 页面更新前的 内存中的DOM树，同时再拿到 页面更新前的 新渲染出来的 内存DOM树；然后，对比这两颗新旧DOM树，找到那些需要被重新创建和修改的元素即可。这样就能实现 DOM 的按需更新。\n如何拿到这两棵DOM树：（即：如何从浏览器的内存住哪个获取到 浏览器私有的那两颗DOM树？）\n如果要拿到浏览器私有的DOM树，那我们必须调用浏览器提供的相关JS的API才行。但是问题来了，浏览器并没有提供这样的API。既然如此，那我们可以自己模拟这两颗 新旧DOM树。\n如何自己模拟这两颗 新旧DOM树：（即：如何自己模拟一个DOM节点？）\n这里涉及到手动模拟DOM树的原理：使用 JS 创建一个对象，用和这个对象来模拟每一个DOM节点；然后在每个DOM节点中，又提供了类似于 children 这样的属性来描述当前DOM的子节点。这样的话，当DOM节点形成了嵌套关系，就模拟出了一颗 DOM 树。\n总结：\n虚拟DOM的本质：使用 JS 对象模拟DOM树。\n虚拟DOM的目的：为了实现 DOM 节点的高效更新。\nReact内部已经帮我们实现了虚拟DOM，初学者掌握如何调用即可。\ndiff算法 怎么实现 两颗新旧DOM树的对比 呢？这里就涉及到了 diff算法。常见的 diff算法如下：\ntree diff：新旧DOM树，逐层对比的方式，就叫做 tree diff。每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素。\ncomponent diff：在对比每一层的时候，组件之间的对比，叫做 component diff。当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置。\nelement diff：在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff。\nkey：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系。\nReact 介绍 React 是什么 Facebook 开源的一个JS库。\n一个用于动态构建用户界面的JS库。\nReact 的特点 Declarative（声明式编码）\nComponent-Based（组件化编码）\nLearn Once, Write Anywhere（支持客户端、服务器端渲染）\n高效的DOM Diff算法，最小化页面重绘\n单向数据流\nReact高效的原因 虚拟(virtual)DOM，不总是直接操作DOM\n高效的DOM Diff算法，最小化页面重绘（即“局部渲染”）。\n虚拟DOM指的是：在真实DOM的上一层映射一层虚拟DOM。我们操作的是映射关系，而不是真实的DOM。假设页面的样式做了修改（比如新增了一个标签），此时修改的是虚拟DOM的样式，真实的DOM并未发生变化。那什么时候，真实的DOM会发生变化呢？ 当我把所有的内容操作完之后，转化为真实的DOM，此时要打包统一的渲染页面，于是真实的DOM发生变化，然后渲染一次。 这样做的话，可以减少页面的渲染次数。\n相关网址 官网：https://reactjs.org/\nGitHub 地址：https://github.com/facebook/react 截至2019-02-08，React项目已经有 121k 的star。\n官网截图：\n20190208_1057.png\n上方截图中，有一个特性是“Learn Once, Write Anywhere”。这里的 “Anywhere” 其实指的是两个地方：一个是浏览器端，一个是服务器端。后者指的是，React支持在服务器端渲染页面。\n生态介绍 Vue生态：Vue + Vue-Router + Vuex + Axios + Babel + Webpack\nReact生态：React + React-Router + Redux + Axios + Babel + Webpack\nReact 模块化、组件化 模块 理解：向外提供特定功能的js程序, 一般就是一个js文件\n理由：js代码更多更复杂\n作用：简化js的编写，阅读，提高运行效率\n组件 理解：用来实现特定功能效果的代码集合(html/css/js)\n理由：一个界面的功能更复杂\n作用：复用，简化项目编码，提高运行效率\n模块化与组件化 模块化：当应用的js都以模块来编写的, 这个应用就是一个模块化的应用\n组件化：当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用\n面相对象与面向过程的区别 面向对象编程：\n重点是对象\n更加关心的是干活的人\n面向过程编程：\n更加关心的是干活的过程\n谁去干活儿不关心\nReact 环境搭建：写第一个Hello World react.js 和 react-dom.js 为了通过 React 写一个Hello World程序，我们需要先安装几个包：\nreact.js: React的核心库。这个包，是专门用来创建React组件、组件生命周期等。\nreact-dom.js: 操作DOM的扩展库。这个包，主要封装了和 DOM 操作相关的包（比如，把组件渲染到页面上）。\nbabel.min.js: 将 JSX语法 解析为 纯JS语法代码。\n方式一：本地引入相关的js库 入门的时候，我们建议采取方式一。\n如果是本地引入的话，可以这样写：\n1 2 3 4 \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 如果是通过CDN的方式引入的话，可以使用网站 https://www.bootcdn.cn/ 提供的CDN链接。\n完整代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;myContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; //页面中的真实容器元素 var containDiv = document.getElementById(\u0026#34;myContainer\u0026#34;); //1、创建虚拟DOM对象 var vDom = \u0026lt;div\u0026gt;Hello, React!\u0026lt;/div\u0026gt;; // 不是字符串, 不能加引号 //2、渲染虚拟DOM对象（将虚拟DOM对象渲染到页面元素中） ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 代码运行后，页面上的DOM结构如下：\n1 2 3 \u0026lt;div id=\u0026#34;myContainer\u0026#34;\u0026gt; \u0026lt;div\u0026gt;Hello, React!\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 代码解释：\nrender的中文含义是“渲染”。render 方法的语法如下：\n1 ReactDOM.render(要渲染的虚拟DOM对象, 容器 container：要渲染到页面上的哪个位置); 【工程文件下载】\n2019-02-08-ReactDemo.zip 方式二：npm install 实际开发中，我们一般都是通过 npm install 的方式来安装 react 相关的包。\n首先，新建一个空的文件夹2019-02-08-ReactDemo，作为项目的根目录。然后在根目录下执行如下命令，进行项目初始化：\n1 npm init --yes 上方命令执行完成后，会生成package.json文件。\n然后继续执行如下命令，安装 react.js 和 react-dom.js 这两个包：\n1 npm i react react-dom 完整代码举例：\nindex.html:\nmain.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // JS打包入口文件 import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // 在 react 中，如要要创建 DOM 元素，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素 // React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数 // 参数1： 是个字符串类型的参数，表示要创建的元素类型 // 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性 // 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点 // \u0026lt;div title=\u0026#34;this is a div\u0026#34; id=\u0026#34;mydiv\u0026#34;\u0026gt;这是一个div\u0026lt;/div\u0026gt; var myDiv = React.createElement(\u0026#39;div\u0026#39;, { title: \u0026#39;this is a div\u0026#39;, id: \u0026#39;mydiv\u0026#39; }, \u0026#39;这是一个div\u0026#39;); // ReactDOM.render(\u0026#39;要渲染的虚拟DOM元素\u0026#39;, \u0026#39;要渲染到页面上的哪个位置\u0026#39;); ReactDOM.render(myDiv, document.getElementById(\u0026#39;app\u0026#39;)); 上方代码中，createElement()方法介绍如下：\n1 React.createElement(需要创建的元素类型, 有哪些属性, 子节点) 【工程文件下载】\n2019-02-09-ReactDemo.zip ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/01-react%E4%BB%8B%E7%BB%8D/","summary":"虚拟DOM和diff算法 在学习 React 之前，我们需要先了解两个概念：虚拟DOM、diff算法。 虚拟DOM 问题描述： 假设我们的数据发生一点点的变化，","title":"01-React介绍"},{"content":"WebStorm的简单设置 1、主题修改： 可能大家会觉得软件的界面不太好看，我们可以换一下主题。选择菜单栏“File\u0026ndash;settings\u0026ndash;appearance\u0026ndash;theme”，主题选择 Dracula：\n2、导入第三方主题： 系统提供的两种主题可能都不太好看，我们可以进入网站http://color-themes.com/来获取第三方主题，这里推荐两个主题，大家二选一即可：\nSublime\nMaterial\n上图中，在网站http://color-themes.com/中将主题下载之后，是一个jar包。那怎么导入到WebStorm呢？\n别着急，回到WebStorm，选择菜单栏“ File-Import Settings”，将下载好的jar包导入即可。\n3、代码字体修改： 选择菜单栏“File\u0026ndash;settings\u0026ndash;Editor\u0026ndash;Font”：\n上图中，点击红框部分，然后弹出如下界面：\n我们在上图中修改代码的字体。\n修改完之后发现 WebStorm 的一些默认字体（比如侧边栏的工程目录的字体）并没有发生变化，如果想改的话，也可以改（我个人一般是不改的）。\n4、关闭更新： 如下图所示：\n5、快捷键习惯的修改： 7、配置代码的自动提示： 14、修改文件编码为UTF-8： WebStorm 2017.3.3版本的默认编码方式是 GBK，我们还是统一设置为UTF-8吧，不要坑队友哦：\n新建一个空的项目 配置完成后，可以开始新建一个项目文件夹（站点），项目通常包含如下内容：\n首页：index.html\n样式：css文件夹\nindex.css 相同样式：全局样式、公共样式。起名为：base.css（基本样式）或者 global.css (全局样式) 图片：images文件夹、文件\n特效：js文件夹、js文件\n步骤如下：\n（1）新建一个空的项目： （2）然后新建一个html文件：\n（3）新建一个空的文件夹，命名为css：\n然后在这个css文件夹中，新建样式表：（比如index.css\\base.css）\n（4）最后新建一个images文件夹，用于存放土片。这样的话，一个基本的项目结构就搭建好了：\n接下来，开始运用起你们的前端知识吧。\n（5）如果要新建JS文件的话，操作如下：\n使用技巧 多光标编辑 我们可以按住鼠标不松手，选中多个光标，然后同时编辑：\n随时在浏览器中看代码效果 20180118_1658.png\n如上图所示，我们可以点击右上角的浏览器图标，在各个浏览器中看效果。\n实时查看颜色 写代码时如果想输入颜色，会自动提示颜色的预览。\n点击最左侧的颜色预览，还能弹出调色板：\n代码的自动补齐 （1）在html文档中，输入div*10，按tab键后，弹出的效果如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; （2）在html文档中，输入如下部分：\n1 .search-logo+.search-input+.search-car+.search-moreA 按tab键后，弹出的效果如下：\n1 2 3 4 \u0026lt;div class=\u0026#34;search-logo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;search-input\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;search-car\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;search-moreA\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 你看，京东的搜索框就包含了这几个div：\n20180122_1045.png\n（3）方法的注释：\n方法写完之后（注意，一定要先写完整），我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。\n比如：\n1 2 3 4 5 6 7 8 9 /** * 功能：给定元素查找他的第一个元素子节点，并返回 * @param ele * @returns {Element|*|Node} */ function getFirstNode(ele){ var node = ele.firstElementChild || ele.firstChild; return node; } 常用快捷键 标签环绕 输入一段字符后，按住Ctrl + Alt + T，可以用标签将这段字符环绕：\n选中正行中的文本 比如下面这行：\n1 text-align: center; /*让 li 里面的文本水平方向居中*/ 如果直接按 【ctrl+C】的话，复制的是整行的内容，把前面的空格也包含进去了。如果不想复制空格，有另外一个办法：将光标放在行尾，然后按住【shift+home】，就能选中你想要的内容了。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/01-webstorm%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"WebStorm的简单设置 1、主题修改： 可能大家会觉得软件的界面不太好看，我们可以换一下主题。选择菜单栏“File\u0026ndash;settin","title":"01-WebStorm的使用"},{"content":"数据库的概念 数据库：database（DB），是一种存储数据的仓库。具有如下特性：\n数据库是根据数据结构组织、存储和管理数据。 数据库能够长期、高效的管理和存储数据。 数据库的目的就是能够存储（写）和提供（读）数据。 数据库分类 数据库分为两类：\n关系型数据库：把复杂的数据结构归结为简单的二元关系，即二维表格形式（二维表）。注重数据存储的持久性。\n非关系型数据库：没有具体模型的数据结构。英文简称 NoSQL（Not Only SQL )，意为\u0026quot;不仅仅是SQL\u0026quot;。注重数据读取的效率。\n我们具体来看看。\n1、关系型数据库 关系型数据库：把复杂的数据结构归结为简单的二元关系，即二维表格形式（二维表）。\n关系型数据库有四层结构：\n数据库管理系统（DBMS）：DataBase Management System。\n数据库（DB）：数据存储的管理者。\n数据表（Table）：数据关系管理者。\n数据字段（Field）：实际数据存储者。\n常见的关系型数据库产品：\n大型：Oracle\n中型：MySQL、SQL Server\n小型：Sybase、Access\n2、非关系型数据库 非关系型数据库：没有具体模型的数据结构。英文简称 NoSQL（Not Only SQL )，意为\u0026quot;不仅仅是SQL\u0026quot;。\n常见的非关系型数据库产品：MongoDB、Redis、Memcached。\nSQL 的介绍 SQL：全称 Structured Query Language，译为结构化查询语言。\nSQL：是一种针对关系型数据库的标准化编程语言，能够实现用户数据库的查询和程序设计。\n通俗来讲，SQL 是关系型数据库的操作指令。\n根据操作类型不同，SQL 可分为几类：\nDQL：Data Query Language，数据查询语言，用于查询和检索数据 DML：Data Manipulation Language，数据操作语言，用于数据的写操作（增删改） DDL：Data Definition Language，数据定义语言，用于创建数据结构 DCL：Data Control Language，数据控制语言，用于用户权限管理 TPL：Transaction Process Language，事务处理语言，辅助DML进行事务操作（因此也归属于DML） 补充：\nSQL 虽然是编程语言，但通常只用来进行数据管理，逻辑部分交给其他编程语言。\nSQL 是针对关系型数据库的通用语言，所有关系型数据库都是基于SQL进行数据操作；而不同的数据库产品，在 SQL 操作指令上略有差异。\nMySQL 的介绍 MySQL 数据库介绍 MySQL 是很有名的 关系型数据库产品，由瑞典MySQL AB 公司开发，现在属于 Oracle 旗下产品。\nMySQL 在 2008 年被 Sun 公司以10亿美金所收购，而 Sun 公司在2009年被 Oracle 甲骨文公司收购。\nMySQL 开源免费。\nMySQL 访问原理 MySQL是一种C/S结构的软件，因此我们需要安装 MySQL 的客户端来访问远程的服务端。也就是说，数据是存放在服务器上的，客户端通过执行 sql 指令来操作服务端的数据。\n具体步骤是：\n（1）客户端通过 主机（host） + 端口号（port） 服务端。\n（2）输入 username 和 password 验证身份。\n（3）客户端和服务端连接成功，通过 sql 指令开始操作数据库。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"数据库的概念 数据库：database（DB），是一种存储数据的仓库。具有如下特性： 数据库是根据数据结构组织、存储和管理数据。 数据库能够长期、","title":"01-数据库的基础知识"},{"content":"ES的几个重要版本 ES5 : 09年发布。\nES6(ES2015) : 2015年发布，也称为ECMA2015。\nES7(ES2016) : 2016年发布，也称为ECMA2016 (变化不大)。\n严格模式的理解 概念 理解：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：\u0026ldquo;严格模式\u0026rdquo;（strict mode）。\n顾名思义，这种模式使得Javascript在更严格的语法条件下运行。\n目的：\n消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为\n消除代码运行的一些不安全之处，为代码的安全运行保驾护航\n为未来新版本的Javascript做好铺垫\n使用 针对整个脚本文件：将use strict放在脚本文件的第一行，则整个脚本文件将以严格模式运行。\n针对单个函数：将use strict放在函数体的第一行，则整个函数以严格模式运行。\nPS：如果浏览器不支持，则这句话只解析为一条简单的语句, 没有任何副作用。\n脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。\n语法和行为改变 必须用var声明变量\n禁止自定义的函数中的this指向window\n创建eval作用域\n对象不能有重名的属性\n严格模式和普通模式的区别 下面列举几条严格模式的内容。\n全局变量显式声明 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n禁止this关键字指向全局对象： 1 2 3 4 5 var foo = function () { console.log(this); } foo(); 上方代码中，普通模式打印的是window。严格模式下打印的是undefined。\n创设eval作用域 禁止使用with语句 因为with语句无法在编译时就确定，属性到底归属哪个对象。\n构造函数必须通过new实例化对象 构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。\n比如说：\n1 2 3 4 5 var Cat = function (name) { this.name = name; } Cat(\u0026#39;haha\u0026#39;); 上方代码中，如果在严格模式下，则会报错。\n为了让代码更安全，禁止函数内部遍历调用栈 严格模式下无法删除变量 属性相关 普通模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。\n比如下面这样的代码：\n1 2 3 4 var obj = { username: \u0026#39;smyh\u0026#39;; username: \u0026#39;vae\u0026#39; } 上面的代码，在严格模式下属于语法错误，因为有重名的属性。\n函数必须声明在顶层 将来Javascript的新版本会引入\u0026quot;块级作用域\u0026quot;。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n新增关键字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n总结 至少要能答出四五条。\n参考链接：\n阮一峰 | Javascript 严格模式详解 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/02-es5%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","summary":"ES的几个重要版本 ES5 : 09年发布。 ES6(ES2015) : 2015年发布，也称为ECMA2015。 ES7(ES2016) : 2016年发布，也称为ECMA2016 (变化不大)。 严格模","title":"02-ES5中的严格模式"},{"content":"CSS CSS Inspiration，在这里找到写 CSS 的灵感：https://github.com/chokcoco/CSS-Inspiration\nCSS 常用样式：https://github.com/QiShaoXuan/css_tricks\nJavaScript 优秀的JS代码规范：https://github.com/ryanmcdermott/clean-code-javascript\n据说这个项目，是宝藏：https://github.com/dexteryy/spellbook-of-modern-webdev\nTS TypeScript 教程：https://github.com/xcatliu/typescript-tutorial Node.js Node.js学习：https://blog.poetries.top/node-learning-notes/\n算法类 数据结构和算法：https://github.com/trekhleb/javascript-algorithms\nleetcode解题之路：https://github.com/azl397985856/leetcode\n五分钟学算法：https://github.com/MisterBooo/LeetCodeAnimation\nLeetCode 攻略 - 2019 年 8 月上半月汇总（109 题攻略）：https://juejin.im/post/5d522f7cf265da03c926ede5\n极客时间 App 的《数据结构与算法之美》\nVue 教程 你也许不知道的 Vuejs：https://github.com/yugasun/You-May-Not-Know-Vuejs 综合类 前端精读周刊 其他 单元测试：https://github.com/goldbergyoni/javascript-testing-best-practices 前端面试 前端面试常考问题整理，按模块知识点分类：https://blog.poetries.top/FE-Interview-Questions/\n前端开发面试题: https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions\nweb前端面试宝典：https://github.com/h5bp/Front-end-Developer-Interview-Questions/\n掘金前端面试题合集：https://github.com/shfshanyue/blog/blob/master/post/juejin-interview.md\n综合面试 反向面试（反问面试官的问题）：https://github.com/yifeikong/reverse-interview-zh 博客 收集优质的中文前端博客：https://github.com/FrankFang/best-chinese-front-end-blogs\n前端博客：https://github.com/laizimo/zimo-article\n讲得比较详细。比如说这篇：CSS布局说——可能是最全的\n文档类 中文博客排版指南：https://github.com/qianguyihao/document-guide\n中国程序员容易发音错误的单词：https://github.com/shimohq/chinese-programmer-wrong-pronunciation\n学会提问 https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/02-github%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/","summary":"CSS CSS Inspiration，在这里找到写 CSS 的灵感：https://github.com/chokcoco/CSS-Inspiration CSS 常","title":"02-GitHub项目推荐"},{"content":"JSX介绍 JSX的引入 如果直接让用户通过 JS 代码手动创建DOM元素，肯定是非常麻烦的。\n于是，React 官方就提出了一套 JSX 语法规范，能够让我们在 JS 文件中，书写类似于 HTML 那样的代码，快速定义虚拟DOM结构。\nJSX的全称 JSX：JavaScript XML，一种类似于XML的JS扩展语法。也可以理解成：符合 XML 规范的 JS 语法。\n需要注意的是，哪怕你在 JS 中写的是 JSX 语法（即JSX这样的标签），但是，JSX内部在运行的时候，并不是直接把 我们的 HTML 标签渲染到页面上；而是先把 类似于HTML 这样的标签代码，转换成 React.createElement 这样的JS代码，再渲染到页面中。\n从这一点我们可以看出，JSX是一个对程序员友好的语法糖。\nJSX语法的本质：以 React.createElement 的形式来实现的，并没有直接把 用户写的 HTML代码，渲染到页面上。\nbabel转换工具 如果要直接使用 JSX 语法，需要先安装相关的 语法转换工具：\n1 运行 cnpm i babel-preset-react -D 这个babel包的作用是：将 JSX语法 转换为 JS语法。\n安装完成后，就可以开始使用JSX语法了。\n完整代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; //页面中的真实容器元素 var containDiv = document.getElementById(\u0026#34;app\u0026#34;); //1、使用JSX语法 创建虚拟DOM对象 var vDom = ( \u0026lt;div\u0026gt; Hello, React! \u0026lt;h2\u0026gt;这是标题\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); //2、渲染虚拟DOM对象（将虚拟DOM对象渲染到页面元素中） ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSX的基本语法 （1）在 JSX内部 写 JS代码：如果要在 JSX 语法内部，书写 JS 代码，那么，所有的JS代码必须写到 {} 的内部。在{}内部，可以写任何符合JS规范的代码。\n例如：\n1 2 3 4 5 6 7 8 9 var myTitle = \u0026#39;这是使用变量定义的 tilte 值\u0026#39; // 使用JSX语法 创建虚拟DOM对象 var vDom = ( \u0026lt;div\u0026gt; Hello, React! \u0026lt;h2 title={myTitle + \u0026#39;vae\u0026#39;}\u0026gt;这是标题\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); （2）当编译引擎在编译JSX代码的时候，如果遇到了\u0026lt;，会把它当作 HTML代码 去编译；如果遇到了 {}， 会把方括号里面的代码当作 普通JS代码 去编译。\n（3）在JSX中，如果要为元素添加class属性，则必须写成className，因为 class在ES6中是一个关键字；和class类似，label标签的 for 属性需要替换为 htmlFor。\n代码举例：\n1 2 3 4 5 6 7 8 // 使用JSX语法 创建虚拟DOM对象 var vDom = ( \u0026lt;div\u0026gt; Hello, React! \u0026lt;p className=\u0026#34;qianguyihao\u0026#34;\u0026gt;lvbu\u0026lt;/p\u0026gt; \u0026lt;label htmlFor=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); （4）在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹。\n（5）如果要写注释，注释必须放到 {} 内部。例如：\n1 2 3 4 5 6 7 8 9 // 使用JSX语法 创建虚拟DOM对象 var vDom = ( // 这一行是注释 \u0026lt;div\u0026gt; Hello, React! \u0026lt;p className=\u0026#34;qianguyihao\u0026#34;\u0026gt;lvbu\u0026lt;/p\u0026gt; {/*这一行也是注释 */} \u0026lt;/div\u0026gt; ); 最后，再举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; //页面中的真实容器元素 var containDiv = document.getElementById(\u0026#34;app\u0026#34;); var arr = [] for (var i = 0; i \u0026lt; 6; i++) { var p = \u0026lt;p className=\u0026#34;myp\u0026#34; key={i}\u0026gt;这个是p标签\u0026lt;/p\u0026gt; // 注意这个地方的写法： key = {i} arr.push(p) } //1、使用JSX语法 创建虚拟DOM对象 var vDom = ( \u0026lt;div\u0026gt; Hello, React! {arr} \u0026lt;/div\u0026gt; ); //2、渲染虚拟DOM对象 ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行结果：\n20190210_1501.png\n创建组件的第一种方式 创建组件 在React中，构造函数就是一个最基本的组件。\n如果想要把组件放到页面中，可以把构造函数的名称当作组件的名称，以 HTML标签形式引入页面中即可。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; // 这个构造函数，就相当于一个 组件 function Hello() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Hello组件 中定义的元素\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;Hello\u0026gt; \u0026lt;/Hello\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行结果：\n20190210_1510.png\n需要注意的是：\nReact在解析所有标签的时候，是以标签的首字母来区分的：如果标签的首字母是小写，就按照普通的 HTML 标签来解析；如果首字母是大写，则按照 组件的形式来解析。\n比如上方代码中，如果把大写的 Hello 改成小写的 hello，运行会报错，无法看到预期的结果。\n结论：组件的首字母必须大写。\n父组件传值给子组件 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; // 父组件中的数据 var person = { name: \u0026#34;qianguyihao\u0026#34;, age: 27, gender: \u0026#34;男\u0026#34;, address: \u0026#34;深圳\u0026#34; }; // 在子组件中，如果想要使用外部传递过来的数据，必须显示的在 构造函数参数列表中，定义 props 属性来接收 // 通过 props 得到的任何数据都是只读的，不能重新赋值 function Hello(props) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Hello子组件 中定义的元素： {props.name}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } ReactDOM.render( \u0026lt;!-- 注意：这里的 ...Obj 语法，是 ES6中的属性扩散，表示：把这个对象上的所有属性，展开了，放到这个位置 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Hello {...person}\u0026gt; \u0026lt;/Hello\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中，我们是想把整个person对象传递给子组件，所以采用了...Obj 语法语法。传递给子组件后，子组件获取的数据仅仅只是可读的。\nclass 关键字的介绍 面向对象语言的三个特性：封装、继承、多态。多态 和 接口、虚拟方法有关。\nclass的基本用法：使用class创建对象 myclass.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 以前学习的：使用构造函数创建对象 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.say = function() { console.log(\u0026#34;呵呵哒\u0026#34;); }; Person.info = 123; var p1 = new Person(\u0026#34;zs\u0026#34;, 20); // 本次需要学习的：class 后面跟上类名，类名后面，不需要加 () ，直接上 {} class Per { // 在每个class类内部，都有一个 constructor 构造器， 如果没有显示定义 构造器，那么类内部默认都有个看不见的 constructor // constructor 的作用，就好比 咱们之前的 function Person(){ } // 每当，使用 new 关键字创建 class 类实例的时候，必然会优先调用 constructor 构造器 // constructor(){} constructor(name, age) { this.name = name; this.age = age; } // 这是实例方法，必须通过 new 出来的对象调用 say() { console.log(\u0026#34;ok a \u0026#34;); } static info = 123; static sayHello() { console.log(\u0026#34;这是静态方法\u0026#34;); } } var p2 = new Per(\u0026#34;壹号\u0026#34;, 26); console.log(p2); console.log(Per.info); console.log(Per.sayHello()); 使用 class 实现 JS 中的继承 myclass2.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Person { constructor(name, age) { console.log(3); this.name = name; this.age = age; } say() { console.log(\u0026#34;这是 Person中的 say 方法\u0026#34;); } static info = 123; } // 使用 extends 实现继承，extends的前面的是子类，后面的是父类 class Chinese extends Person { constructor(name, age, color, language) { console.log(1); // 注意： 当使用 extends 关键字实现了继承， 子类的 constructor 构造函数中，必须显示调用 super() 方法，这个 super 表示父类中 constructor 的引用 super(name, age); this.color = color; this.language = language; console.log(2); } } var c1 = new Chinese(\u0026#34;张三\u0026#34;, 22, \u0026#34;yellow\u0026#34;, \u0026#34;汉语\u0026#34;); console.log(c1); // 父类中任何东西，子类都能继承到 c1.say(); 注意上方 constructor处的注释：当使用 extends 关键字实现了继承， 子类的 constructor 构造函数中，必须显示调用 super() 方法，这个 super 表示父类中 constructor 的引用。也就是说，在子类当中，要么不写 constructor，如果写了 constructor，就一定要把 super()也加上。\n为啥我们要引入 class这个功能？就是因为， class里，永远都存在着一个 constructor。我们可以利用 constructor做很多事情。\n创建组件的第二种方式：使用 class 关键字 使用 class 创建的类，通过 extends 关键字，继承 React.Component 之后，这个类，就是一个组件的模板了。如果想要引用这个组件，可以把类的名称以标签的形式，导入到 JSX 中使用。\n在 class 实现的组件内部，必须定义一个 render 函数。在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null。\n代码举例：\nindex.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; // 使用 class 创建的类，通过 extends 关键字，继承 `React.Component` 之后，这个类，就是一个组件的模板了。 // 如果想要引用这个组件，可以把类的名称以**标签的形式**，导入到 JSX 中使用。 class Hello2 extends React.Component { // 在 class 实现的组件内部，必须定义一个 render 函数 render() { // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是使用 class 类创建的组件 \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } } ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;Hello2\u0026gt; \u0026lt;/Hello2\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 父组件传值给子组件 代码举例：\nindex.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; // 使用 class 创建的类，通过 extends 关键字，继承 `React.Component` 之后，这个类，就是一个组件的模板了。 // 如果想要引用这个组件，可以把类的名称以**标签的形式**，导入到 JSX 中使用。 class Hello2 extends React.Component { constructor(props) { super(props); console.log(props.name); // 注意：`this.state` 是固定写法，表示当前组件实例的私有数据对象，就好比 vue 中，组件实例身上的 data(){ return {} } 函数 // 如果想要使用 组件中 state 上的数据，直接通过 this.state.*** 来访问即可 this.state = { msg: \u0026#34;这是 Hello2 组件的私有msg数据\u0026#34;, info: \u0026#34;永不止步\u0026#34; }; } // 在 class 实现的组件内部，必须定义一个 render 函数 render() { // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是使用 class 类创建的组件 \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } } ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;Hello2 name=\u0026#34;qianguyihao\u0026#34;\u0026gt; \u0026lt;/Hello2\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 方式一和方式二的对比 上面的内容里，我们使用了两种方式创建组件。这两种方式，有着本质的区别，我们来对比一下。\n对比：\n方式一：通过 function构造函数 创建组件。内部没有 state 私有数据，只有 一个 props 来接收外界传递过来的数据。\n方式二：通过 class 创建子组件。内部除了有 this.props 这个只读属性之外，还有一个专门用于 存放自己私有数据的 this.state 属性，这个 state 是可读可写的。\n基于上面的区别，我们可以为这两种创建组件的方式下定义： 使用 function 创建的组件，叫做【无状态组件】；使用 class 创建的组件，叫做【有状态组件】。\n本质区别：\n有状态组件和无状态组件，最本质的区别，就是有无 state 属性。同时， class 创建的组件，有自己的生命周期函数，但是，function 创建的 组件，没有自己的生命周期函数。\n什么时候使用 有状态组件，什么时候使用无状态组件：\n（1）如果一个组件需要存放自己的私有数据，或者需要在组件的不同阶段执行不同的业务逻辑，此时，非常适合用 class 创建出来的有状态组件。\n（2）如果一个组件，只需要根据外界传递过来的 props，渲染固定的页面结构即可的话，此时，非常适合使用 function 创建出来的无状态组件。（使用无状态组件的小小好处： 由于剔除了组件的生命周期，所以，运行速度会相对快一点点）。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/02-jsx%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"JSX介绍 JSX的引入 如果直接让用户通过 JS 代码手动创建DOM元素，肯定是非常麻烦的。 于是，React 官方就提出了一套 JSX 语法规范，能够让我们在","title":"02-JSX语法介绍"},{"content":"MySQL 安装 MySQL（Mac版） 步骤1、下载安装包并安装： MySQL 下载地址：https://dev.mysql.com/downloads/mysql/\n步骤2、配置环境变量 打开 ~/.bash_profile 文件，在文件的末尾，添加如下内容，即可配置环境变量：\n1 2 3 4 5 # mysql export PATH=${PATH}:/usr/local/mysql/bin #快速启动、结束MySQL服务, 可以使用alias命令 alias mysqlstart=\u0026#39;sudo /usr/local/mysql/support-files/mysql.server start\u0026#39; alias mysqlstop=\u0026#39;sudo /usr/local/mysql/support-files/mysql.server stop\u0026#39; 配置好环境变量后，在终端输入 source ~/.bash_profile 命令，让配置生效。\n在终端的任何位置，输入如下命令，即可进入 mysql 命令的执行窗口：\n1 mysql -u root -p 参考链接：\nMySQL安装（Mac版） 步骤3、继续配置环境变量 在 ~/.bash_profile 中配置好环境变量后，发现每次重启终端后，配置都会失效，需要重新执行 source ~/.bash_profile 命令。\n原因是，zsh加载的是 ~/.zshrc文件，而 .zshrc 文件中并没有定义任务环境变量。\n解决办法：打开 ~/.zshrc 文件，在文件的末尾，添加如下内容即可：\n1 source ~/.bash_profile 参考链接：https://blog.csdn.net/science_Lee/article/details/79214127\nNavicat Premium 软件初体验 Navicat Premium 软件是一种数据库管理的GUI软件，采用可视化的方式来查看和操作数据库，非常方便。支持的数据库有： MySQL、MongoDB、SQL Server、SQLite、Oracle 及 PostgreSQL等。\n安装好 Navicat Premium 软件之后，我们来看看这个软件是怎么用的。\n新建表和数据 1、新建连接：\n打开 Navicat Premium 软件，选择菜单栏「文件-新建连接-mysql」，然后选择如下配置，即可在本地新建一个数据库连接：\n2、选中连接后，右键新建数据库：\n3、选中数据库之后，新建表 qiangu_student_table：\n4、在表中添加字段：\n5、字段建好后，开始在表中插入数据：\n导入外部 sql 文件 在 Navicat中，选中当前 database 之后，右键选择“运行sql文件”，即可导入外部sql文件。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/02-mysql%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8Cnavicat%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/","summary":"MySQL 安装 MySQL（Mac版） 步骤1、下载安装包并安装： MySQL 下载地址：https://dev.mysql.com/downloads/mysql","title":"02-MySQL的安装和Navicat软件使用"},{"content":"Node.js 的特点 异步、非阻塞 IO 模型\n事件循环\n单线程\n总结：轻量和高效\nNode.js 的性能和效率非常高。\n传统的 Java 语言是一个请求开启一个线程，当请求处理完毕后就关闭这个线程。而 Node.js 则完全没有采用这种模型，它本质上就是一个单线程。\n你可能会疑问：一个线程如何服务于大量的请求、如何处理高并发的呢？这是因为，Node.js 采用的是异步的、非阻塞的模型。\n这里所谓的“单线程”，指的是 Node 的主线程只有一个。为了确保主线程不被阻塞，主线程是用于接收客户端请求。但不会处理具体的任务。而 Node 的背后还有一个线程池，线程池会处理长时间运行的任务（比如 IO 操作、网络操作）。线程池里的任务是通过队列和事件循环的机制来执行。\n使用 Node.js 时的劣势 程序运行不稳定，可能会出现服务不可用的情况\n程序运行效率较低，每秒的请求数维持在一个较低的水平\n前端同学对服务器端的技术不太熟悉。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/02-node.js%E7%9A%84%E7%89%B9%E7%82%B9/","summary":"Node.js 的特点 异步、非阻塞 IO 模型 事件循环 单线程 总结：轻量和高效 Node.js 的性能和效率非常高。 传统的 Java 语言是一个请求开启一个线程，当请求处理完毕后就关闭这个","title":"02-Node.js的特点"},{"content":"对象赋值 用 Object.assgin() 实现浅拷贝 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, desc: \u0026#39;hello world\u0026#39;, }; const obj2 = { name: \u0026#39;许嵩\u0026#39;, sex: \u0026#39;男\u0026#39;, }; // 【关键代码】浅拷贝：把 obj1 赋值给 obj2。这行代码的返回值也是 obj2 Object.assign(obj2, obj1); console.log(JSON.stringify(obj2)); 打印结果：\n1 {\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;sex\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;desc\u0026#34;:\u0026#34;hello world\u0026#34;} 注意，上面这行代码在实际开发中，会经常遇到，一定要掌握。它的作用是：将 obj1 的值追加到 obj2 中。如果两个对象里的属性名相同，则 obj12 中的值会被 obj2 中的值覆盖。\n数组赋值 扩展运算符 1 arr2 = arr1; 上方代码中，其实是让 arr2 指向 arr1 的地址。也就是说，二者指向的是同一个内存地址。\n如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做：\n1 let arr2 = [...arr1]; //arr2 会开辟新的内存地址 参考链接：\njavaScript中浅拷贝和深拷贝的实现 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/02-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%B5%8B%E5%80%BC/","summary":"对象赋值 用 Object.assgin() 实现浅拷贝 代码举例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, desc: \u0026#39;hello world\u0026#39;, }; const obj2 = { name: \u0026#39;许嵩\u0026#39;, sex: \u0026#39;男\u0026#","title":"02-数据的赋值"},{"content":"JSON 对象 1、js对象(数组) \u0026ndash;\u0026gt; json对象(数组)：\n1 JSON.stringify(obj/arr) 2、json对象(数组) \u0026ndash;\u0026gt; js对象(数组)：\n1 JSON.parse(json) 上面这两个方法是ES5中提供的。\n我们要记住，我们通常说的“json字符串”，只有两种：json对象、json数组。\ntypeof json字符串的返回结果是string。\nObject的扩展 ES5给Object扩展了一些静态方法，常用的有2个，我们接下来讲解。\n方法一 1 Object.create(prototype, [descriptors]) 作用: 以指定对象为原型，创建新的对象。同时，第二个参数可以为为新的对象添加新的属性，并对此属性进行描述。\n举例1：（没有第二个参数时）\n1 2 3 4 5 var obj1 = {username: \u0026#39;smyhvae\u0026#39;, age: 26}; var obj2 = {address:\u0026#39;shenzhen\u0026#39;}; obj2 = Object.create(obj1); console.log(obj2); 打印结果：\n1 2 3 4 5 {} [[Prototype]]: Object age: 26 username: \u0026#34;smyhvae\u0026#34; [[Prototype]]: Object 我们发现，obj1成为了obj2的原型。\n举例2：（有第二个参数时）\n第二个参数可以给新的对象添加新的属性。我们修改上面的代码，尝试给obj2添加新属性sex：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var obj1 = {username: \u0026#39;smyhvae\u0026#39;, age: 26}; var obj2 = {address: \u0026#39;shenzhen\u0026#39;}; obj2 = Object.create(obj1, { sex: {//给obj2添加新的属性`sex`。注意，这一行的冒号不要漏掉 value: \u0026#39;男\u0026#39;, //通过value关键字设置sex的属性值 writable: false, configurable: true, enumerable: true } }); console.log(obj2); 上方代码中，我们通过第5行的sex给obj2设置了一个新的属性sex，但是要通过value来设置属性值（第6行）。\n设置完属性值后，这个属性值默认是不可修改的，要通过writable来设置。总而言之，这几个关键字的解释如下：\nvalue：设置属性值。\nwritable：标识当前属性值是否可修改。如果不写的话，默认为false，不可修改。\nconfigurable：标识当前属性是否可以被删除。默认为false，不可删除。\nenumerable：标识当前属性是否能用 for in 枚举。 默认为false，不可。\n方法二 1 Object.defineProperties(object, descriptors) 作用：为指定对象定义扩展多个属性。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var obj2 = { firstName : \u0026#39;smyh\u0026#39;, lastName : \u0026#39;vae\u0026#39; }; Object.defineProperties(obj2, { fullName : { get : function () { return this.firstName + \u0026#39;-\u0026#39; + this.lastName }, set : function (data) { //监听扩展属性，当扩展属性发生变化的时候自动调用，自动调用后将变化的值作为实参注入到set函数 var names = data.split(\u0026#39;-\u0026#39;); this.firstName = names[0]; this.lastName = names[1]; } } }); console.log(obj2.fullName); obj2.firstName = \u0026#39;tim\u0026#39;; obj2.lastName = \u0026#39;duncan\u0026#39;; console.log(obj2.fullName); obj2.fullName = \u0026#39;kobe-bryant\u0026#39;; console.log(obj2.fullName); get ：用来获取当前属性值的回调函数 set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值 存取器属性：setter,getter一个用来存值，一个用来取值。\n数组的扩展 方法1：\n1 Array.prototype.indexOf(value) 作用：获取 value 在数组中的第一个下标。\n方法2：\n1 Array.prototype.lastIndexOf(value) 作用：获取 value 在数组中的最后一个下标。\n方法3：遍历数组\n1 Array.prototype.forEach(function(item, index){}) 方法4：\n1 Array.prototype.map(function(item, index){}) 作用：遍历数组返回一个新的数组，返回的是加工之后的新数组。\n方法5：\n1 Array.prototype.filter(function(item, index){}) 作用：遍历过滤出一个新的子数组，返回条件为true的值。\n函数function的扩展：bind() ES5中新增了bind()函数来改变this的指向。\n1 Function.prototype.bind(obj) 作用：将函数内的this绑定为obj, 并将函数返回。\n面试题: call()、apply()和bind()的区别：\n都能改变this的指向 call()/apply()是立即调用函数 bind()：绑定完this后，不会立即调用当前函数，而是将函数返回，因此后面还需要再加()才能调用。 PS：bind()传参的方式和call()一样。\n分析：\n为什么ES5中要加入bind()方法来改变this的指向呢？因为bind()不会立即调用当前函数。\nbind()通常使用在回调函数中，因为回调函数并不会立即调用。如果你希望在回调函数中改变this，不妨使用bind()。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/03-es5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%89%A9%E5%B1%95/","summary":"JSON 对象 1、js对象(数组) \u0026ndash;\u0026gt; json对象(数组)： 1 JSON.stringify(obj/arr) 2、json对象(数组) \u0026ndash;\u0026gt; js对象(数组)： 1 JSON.parse(json) 上面这两个方法是ES5中提供的。 我们要","title":"03-ES5中的一些扩展"},{"content":"常见操作 全局配置用户信息 1 2 git config --global user.name \u0026#34;lvsijun\u0026#34; git config --global user.email \u0026#34;lvsijun@163.com\u0026#34; 分支的合并 场景：基于master分支的代码，开发一个新的特性，给每个特性都单独建一个的新的分支。 比如说，我专门给特性1建一个分支branch_one。具体做法如下：\n（1）基于master分支，创建一个新的分支，起名为branch_one：\n1 2 $ git checkout -b branch_one Switched to a new branch \u0026#39;branch_one\u0026#39; 上面这行命令，相当于：\n1 2 $ git branch feature_item_recommend // 创建新的分支 $ git checkout feature_item_recommend //切换到新的分支 （2）在新的分支branch_one上，完成开发工作，并 commit 、push。\n（3）将分支branch_one上的开发进度合并到master分支：\n1 2 $ git checkout master //切换到master分支 $ git merge branch_one //将分支 branch_one 的开发进度合并到 master 分支 合并之后，master分支和branch_one分支会指向同一个位置。\n（3）删除分支branch_one：\n既然 特性1 开发完了，也放心地提交到master了，那我们就可以将这个分支删除了。\n1 git branch -d branch_one 注意，我们当前是处于master分支的位置，来删除branch_one分支。如果当前是处于branch_one分支，是没办法删除它自己的。\n同理，当我转身去开发特性2的时候，也是采用同样的步骤。\n合并分支时，如果存在分叉 比如说上面这张图中，最早的时候，master分支是位于C2节点。我基于C2节点，new出一个新的分支iss53，我在iss53上提交了好几个commit。\n现在，我准备把iss53上的几个commit合并到master上，此时发现，master分支已经前进到C4了。那该怎么合并呢？\n合并的命令仍然是：\n1 2 $ git checkout master $ git merge iss53 日常操作积累 修改密码（曲线救国） 1 2 # 设置当前仓库的用户名为空 git config user.name \u0026#34;\u0026#34; 我们还要输入如下命令，还原当前仓库的用户名：\n1 git config user.name \u0026#34;smyhvae\u0026#34; 修改已经push的某次commit的作者信息 已经push的记录，如果要修改作者信息的话，只能通过\u0026ndash;force命令。\n参考链接：\ngit 修改已提交的某一次的邮箱和用户信息\n修改 git repo 历史提交的 author\n将 branch1的某个commit1合并到branch2当中 切换到branch2中，然后执行如下命令：\n1 git cherry-pick commit1 将Git 项目迁移到另一个仓库 我们假设旧仓库的项目名称叫old-repository，新仓库的项目名称叫new-repository。操作如下：\n（1）创建旧仓库的裸克隆：\n1 git clone --bare https://github.com/exampleuser/old-repository.git 执行上述命令后，会在本地生成一个名叫 old-repository.git的文件夹。\n（2）迁移到新仓库：\n1 2 3 cd old-repository.git git push --mirror https://github.com/exampleuser/new-repository.git 注意，我们不需要手动新建一个空的新仓库，当我们执行上述命令之后，新仓库就已经自动创建好了。\n参考链接：\n复制仓库\nGit 本地仓库和裸仓库\ngit客户端推荐 Sourcetree\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/03-git%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"常见操作 全局配置用户信息 1 2 git config --global user.name \u0026#34;lvsijun\u0026#34; git config --global user.email \u0026#34;lvsijun@163.com\u0026#34; 分支的合并 场景：基于master分支的代码，开发一个新的特性，给每个特性都单独建一个的新的分","title":"03-Git的使用"},{"content":"SQL 的一些简单语法规则 结束符 SQL 指令需要语句结束符，默认是英文分号;。\n当然，还有另外两个结束符：\n\\g 与英文分号;等效。\n\\G：将查到的结构旋转90度变成纵向。\n反引号`` SQL语句中如果用到了关键字或者保留字，需要使用反引号``（Tab键上面的符号）来包裹，让系统忽略。\nMySQL 数据库的操作分类 根据数据库的对象层级，可以将SQL的基础操作分为四类：\n数据库（DB）操作。\n数据表（Table）操作。\n数据字段（Field）操作。\n数据操作。\n下面来详细讲一讲。\n一、数据库（DB）的基本操作 在终端的任何位置，输入如下命令，即可进入 mysql 命令的执行窗口：\n1 mysql -u root -p 1、创建数据库 语法格式：\n1 create database 数据库名称 [数据库选项]; 数据库名称的命名规范：\n由数字、字母和下划线组成。 不区分大小写。 不能以数字开头。 建议使用下划线法创建复杂的数据库名字。比如 db_qianguyihao。 举例：\n创建一个名为 db_qianguyihao1 的数据库：\n1 create database db_qianguyihao1; 创建一个指定字符集的数据库：\n1 create database db_qianguyihao2 charset utf8MB4; 创建一个指定校对集的数据库：\n1 create database db_qianguyihao3 charset utf8MB4 collate utf8mb4_general_ci 2、查看数据库 查看有哪些数据库：(显示所有的数据库列表)\n1 show databases; 查看 db_qianguyihao1 这个数据库的具体创建指令是怎样的：\n1 show create database db_qianguyihao1; 备注：由于系统会加工，所以看到的结果不一定是真实的创建指令。\n3、使用指定的数据库 使用指定的数据库：（也可以理解成：进入指定的数据库）\n1 2 3 4 5 # 语法格式 use database_xxx; # 举例 use db_qianguyihao; 假设当前服务器连接中有很多个数据库（db_qianguyihao1、db_qianguyihao2），此时，我输入 use db_qianguyihao2则代表我想使用 db_qianguyihao2 这个数据库。\n4、修改数据库的参数 我们一般很少修改数据库的名称，一般是去修改数据库的一些选项，比如：\n修改字符集\n修改校对集\n语法格式：\n1 alter database 数据库名称 [库选项] 举例1、修改数据库的字符集为gbk：\n1 alter database db_qianguyihao1 charset gbk; 举例2、修改数据库的校对集：\n1 alter database db_qianguyihao2 charset gbk collate gbk_chinese_ci; 备注：因为校对集是和字符集有关的，所以上方指令是在修改字符集的同时，修改校对集。\n5、删除指定的数据库 语法格式：\n1 drop database 数据库名称; 备注：删除数据库时，会清空当前数据库里的所有数据表，所以删除数据库的操作一定要谨慎。\n二、数据表（Table）的基本操作 注意，我们最好先通过 use xxx_database 命令进入指定的数据库（DB），然后在当前数据库下，进行数据表（Table）的操作。\n1、创建数据表 语法格式：\n1 2 3 4 5 6 create table [数据库名].[表名] ( 字段名1 字段类型, ... ... 字段名2 字段类型 ) 表选项; 举例：\n1、在当前数据库中创建数据表 table_qiangu1，并新增主键 id 字段：\n1 2 3 CREATE TABLE table_qiangu1 ( id int NOT NULL AUTO_INCREMENT PRIMARY KEY ); 2、在当前数据库中创建数据表 t_student1，并新增 name、age这连个字段：\n1 2 3 4 create table t_student1( name varchar(255), age int ); 3、在指定的数据库 db_2 中创建数据表 t_student2：\n1 2 3 4 create table db_2.t_student2( name varchar(255), age int ); 4、在当前数据库中创建数据表 t_student3（含表选项）：\n1 2 3 4 create table t_student3( name varchar(255), age int )engine Innodb charset utf8MB4; 举例4中的代码涉及到存储引擎，这里解释一下：\n存储引擎是指数据存储和管理的方式，MySQL中提供了多种存储引擎，一般使用默认存储引擎 InnoDB。\nInnoDB：默认存储引擎；支持事务处理和外键；数据统一管理。\nMyIsam：不支持事务和外键；数据、表结构、索引独立管理；MySQL5.6以后不再维护。\n6、扩展：如果想创建一个与已有表一样的数据表，MySQL提供了一种便捷的复制模式\n2、复制数据表 如果想创建一个与已有表一样的数据表，MySQL提供了一种便捷的复制模式。\n语法格式：（复制现有的表 table_xx1 到 table_xx2）\n1 create table table_xx1 like 数据库名.table_xx2; 注意，这种复制模式，table_xx2 只会复制表 table_xx1 中的字段，不会复制表table_xx1中的数据。\n举例：\n1 2 3 4 5 # 在当前数据库下，复制现有的表`t_qianguyihao1` 到表 `t_qianguyihao2` create table t_qianguyihao1 like t_qianguyihao2; # 复制现有的表`t_qianguyihao1` 到表 `t_qianguyihao2`，是复制到 `db2`这个数据库中 create table t_qianguyihao1 like db2.t_qianguyihao2; 3、显示数据表的名称 在当前数据库下，显示所有的数据表：\n1 show tables; 在指定的数据库中，显示所有的数据表：\n1 show tables from db_qianguyihao1; 显示数据表的创建指令：(查看 t_qianguyihao1 这个数据表的具体创建指令是怎样的)\n1 show create table t_qianguyihao1; # 备注：由于系统会加工，所以看到的结果不一定是真实的创建指令。 4、查询（查找）数据表的名称 根据 表名称 查询数据表，也可以理解成：按条件显示部分数据表。\n根据数据表的表名称查找数据表时，需要用到关键词like，而且还要涉及到两个符号：\n% 表示匹配任意多个字符。\n_ 表示匹配任意一个字符（固定位置）。\n上面这两个模糊查询的符号，大家要牢记。我们来看看具体的例子。\n语法举例：\n1 show tables like \u0026#39;%like_\u0026#39;;\t# _表示匹配一个字符（固定位置），%表示匹配N个字符 % 符号举例：\n1 2 3 4 5 # 查询表名称中，包含 “qiangu” 这个关键字的表（“qiangu”这个关键字的前后可能都有内容） show tables like \u0026#39;%qiangu%\u0026#39;; # 查询表名称以“qiangu”开头的表（这个命令应该很实用） show tables like \u0026#39;qiangu%\u0026#39;; _符号举例：\n1 2 # 根据 表名称 来查询表，查询条件是：表名称以“qiangu”开头，而且要确保 qiangu 的后面有三个字符（因为我在 qiangu 的后面写了三个下划线）。 show tables like \u0026#39;qiangu___\u0026#39;; 5、desc：查看数据表的表结构 查看数据表的表结构，就是查看这张表中定义了哪些字段，以及这些字段是如何定义的。通过这种方式，我们可以清晰地了解数据的存储形式。\n项目开发中，领导在检查我们的工作时，首先看的就是我们的表中定义了哪些字段。所以说，这种方式，还是很实用的。\n语法格式：\n1 2 3 4 5 6 7 8 # 方式1 desc 表名称; # 方式2 describe 表名称; # 方式3 show columns from 表名称; 上面的三种方式，效果都一样，三选一即可。\n6、修改数据表的表名称和表选项 修改数据表的表名称：\n在当前数据库下，修改数据表的表名称：\n1 rename table 原表名 to 新表名; 指定某个数据库，然后修改数据表的表名称：\n1 rename table 数据库名.原表名 to 数据库名.新表名; 修改数据表的表名称：\n1 alter table table1 charset gbk; 7、删除数据表 语法格式：\n1 drop table 数据表名称; 三、字段（Field）的基本操作 数据表 table 创建好了之后，我们就可以开始在这张表中新增字段了。\n1、新增字段 语法格式：\n1 alter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置]; 注意事项：\n新增字段时，必须制指定字段类型。\n[column]、 [字段属性]、[字段位置] 这几个都是选填，其他是必填。\n追加字段时，这个字段的顺序默认排在最后。\n举例：\n新增字段 name:\n1 alter table table_qiangu1 add name varchar(255); 新增字段 age：\n1 alter table table_qiangu1 add age int; 2、新增字段时，设置字段的位置（顺序） 在新增字段时，它的顺序是默认放在最后面的，当然，我们也可以人工指定它的顺序。\n在修改字段的位置时，我们可以用到下面这两个关键字：\nfirst 放到最前面\nafter 放到某个字段的后面\n语法格式：\n1 alter table 表名 add 新字段名 字段类型 字段位置; 举例1：\n在 name字段的后面，新增一个 sex 字段：\n1 alter table t_qiangu1 add sex varchar(255) default null comment \u0026#39;性别\u0026#39; after name; 注意，上方举例中，如果是新建 varchar 类型的字段，一定要指定 varchar 的长度（比如255），否则报错。\n举例2：\n新增一个 id 字段，放到最前面：\n1 alter table t_qiangu1 add id int first; 3、change：修改现有字段的字段名 修改现有字段的字段名，是通过 change 关键字，不是通过 modify 关键字（后者会报错，执行失败）。\n语法格式：\n1 2 3 4 5 # 格式1（精简版） alter table 表名 change 原字段名 新字段名 字段类型; # 格式2（完整版） alter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [位置]; 注意：\n修改字段名时，一定要设置新字段的字段类型。\n虽然 change 关键字也可以修改现有字段的字段属性、字段位置，但我们一般是通过 modify 关键字来做（下面会讲）。\n举例：\n修改字段名 sex 为 sexy：\n1 alter table t_qiangu2 change sex sexy varchar(255); 4、modify：修改现有字段的的字段类型、字段位置、字段属性 语法格式：\n1 alter table 表名 modify 现有字段的字段名 现有字段的字段类型 [字段属性] [位置]； 举例1、针对现有的字段 name 和 age，更换这两个字段的顺序：\n1 2 # 注意，这里的 age 后面一定要跟上它的字段类型，否则执行失败 alter table t_qiangu1 modify age int after name; 修改字段的默认值 1 2 3 4 5 # 若本身存在默认值，则先删除 alter table 表名 alter column 字段名 drop default; # 若本身不存在则可以直接设定 alter table 表名 alter column 字段名 set default 默认值; 5、删除字段 删除字段的同时，会删除字段对应的数据。删除字段的操作不可逆，请谨慎操作。\n语法格式：\n1 alter table 表名 drop 字段名; 举例：（删除 t_qiangu1 表中的 age 这个字段）\n1 alter table t_qiangu1 drop age; 四、数据的基本操作 1、新增数据 方式1、全字段插入：\n语法格式：\n1 insert into 表名 values(值1, 值2, ... 最后一个值); 解释：\n值的顺序必须与所有字段的顺序一致。 值的数据类型也必须与字段定义的数据类型一致。 举例（给 t_qiangu1 这个表中插入一条完整的数据）：\n1 insert into t_qiangu1 values(3, \u0026#39;qianguyihao\u0026#39;, 28); 方式1、部分字段插入：\n语法格式：\n1 insert into 表名 (字段1, 字段2, 字段3) values(值1, 值2, 值3); 解释：\n-字段的顺序可以随意，但值的顺序必须要与前面的字段顺序一一对应，数据类型也要一致。\n举例（给 t_qiangu1 这个表中的指定字段插入数据）：\n1 insert into t_qiangu1 (id, name) values(4, \u0026#39;xusong\u0026#39;); 2、查询数据 查询数据的操作，占sql日常操作的95%以上。\n语法格式：\n1 select xxx from 表名; 举例：\n查询表中的所有数据：\n1 select * from t_qiangu1; 查询表中 name、age 这两个字段的数据：\n1 select name, age from t_qiangu2; 查询表中 id=2 的数据：\n1 select * from t_qiangu3 where id = 2; 3、修改数据 语法格式：\n1 update 表名 set (字段1 = 新值1, 字段2 = 新值2) [where 条件筛选]; 解释：\n我们通常是结合 where 条件语句来修改数据。\n修改数据之前，要先保证表里面有数据。如果这张表是空表，那么，执行这个命令后，等于没执行。\n举例：\n将表中，name 这个字段的值全部修改为lvbu：\n1 update t_qiangu1 set name = \u0026#39;lvbu\u0026#39;; id = 3 的这条记录中，修改 name 和 age 这两个字段的值：\n1 update t_qiangu1 set name = \u0026#39;许嵩\u0026#39;, age = \u0026#39;34\u0026#39; where id = 3; 4、删除数据 删除字段的操作不可逆，请谨慎操作。\n语法格式：\n1 delete from 表名 [where 条件]; 解释：\n执行删除操作之后，匹配到的整条记录，都会删除。\n删除数据之前，要先保证表里面有数据。如果这张表是空表，那么，执行这个命令后，等于没执行。\n举例：\n删除表中id = 2的记录：\n1 delete from t_qiangu1 where id = 2; ","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/03-mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"SQL 的一些简单语法规则 结束符 SQL 指令需要语句结束符，默认是英文分号;。 当然，还有另外两个结束符： \\g 与英文分号;等效。 \\G：将查到的结构旋转90度","title":"03-MySQL的基本操作"},{"content":"Node.js 运行环境配置：通过 Node.js 安装包（不推荐） 去 Node.js 的官网下载安装包：\n我们也可以在https://nodejs.org/en/download/releases/ 里下载历史版本。\n注意，我们以一定要用偶数版（V4、V6 等)，不要用奇数版（比如 V5），因为奇数版不稳定。\n后续如果需要安装其他版本，可以这样做：重新下载最新的安装包，覆盖安装即可。\n但我们并不推荐直接采用 Node.js.msi（windows）或者 Node.js.pkg（Mac） 安装包进行安装，因为会产生如下问题。\n通过 Node.js 安装包产生的问题：\n安装新版本时，需要覆盖就版本；而且以前版本安装的很多全局工具包，需要重新安装。\n无法回滚到之前的旧版本。\n无法在多个版本之间切换（很多时候，不同的项目需要使用特定版本。或者，我想临时尝鲜一下新版本的特性）\n因此，我们暂时先不用安装 Node.js，稍后用 NVM 的方式来安装 Node.js。通过 NVM 的方式，可以让多个版本的 Node.js 共存，并灵活切换。\nNode.js 版本常识 偶数版本为稳定版（0.6.x ，0.8.x ，8.10.x）\n奇数版本为非稳定版（0.7.x ，0.9.x ，9.11.x）\nLTS（Long Term Support）\n参考链接：node.js 中 LTS 和 Current 的区别\nNode.js 运行环境安装：通过 NVM（推荐） NVM：node.js version manager，用来管理 node 的版本。\n我们可以先安装 NVM，然后通过 NVM 安装 Node.js。这是官方推荐的做法。\nWindows 和 Mac 下安装的 Node.js 的步骤如下。\nWindows 系统安装 Node.js 1、安装 NVM：\n（1）我们去 https://github.com/coreybutler/nvm-windows/releases 下载 NVM 的安装包：\n下载下来后，直接解压到 D:\\web目录下：\n（2）在上面的目录中，新建一个settings.txt文件，里面的内容填充如下：\n1 2 3 4 root: D:\\web\\nvm path: D:\\web\\nodejs arch: 64 proxy 上方内容的解释：\nroot 配置为：当前 nvm.exe 所在的目录\npath 配置为：node 快捷方式所在的目录\narch 配置为：当前操作系统的位数（32/64）\nproxy 不用配置\n（3）配置环境变量：\nNVM_HOME = D:\\web\\nvm（当前 nvm.exe 所在目录）\nNVM_SYMLINK = D:\\web\\nodejs （node 快捷方式所在的目录）\nPATH += ;%NVM_HOME%;%NVM_SYMLINK%\n配置成功后，重启资源管理器。\n2、验证：(在 cmd 命令行中输入命令)\n（1）输入nvm命令查看环境变量是否配置成功：\n（2）输入 nvm ls，查看已安装的所有 node 版本。\n（3）输入 nvm -v，查看 已安装的 nvm 版本。\n（4）输入 node -v，查看正在使用的 node 版本。\n如果 Node 安装失败，可以参考上面这个链接。\n3、安装指定版本的 Node.js：\n1 2 3 4 nvm install 版本号 # 举例 nvm install 8.10.0 输入 node -v，查看当前使用的 node 版本。\n关于 NVM 的常用命令，详见下一段。\n补充：\n如果 Node 安装失败，可以在上方的 settings.txt文件中，新增如下两行，修改镜像源：\n1 2 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 参考链接：安装 npm，nvm，node Mac 系统安装 Node.js 1、安装 NVM：\n（1）打开 终端.app，输入：\n1 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 安装成功的界面：\n完成后，nvm 就被安装在了~/.nvm下。\n如果发现安装失败：\n原因：Xcode 软件进行过更新。\n解决办法：打开 Xcode 软件，同意相关内容即可。\n（2）配置环境变量：\n编辑器打开~/.bash_profile文件，如果不会就输入open ~/.bash_profile。\n（补充：如果你的 Mac 电脑里找不到~/.bash_profile文件，那就找找有没有~/.profile文件，或者~/.bashrc文件，或者~/.zshrc文件。如果还是没有，那你就手动创建一个~/.bash_profile文件）。\n在最后一行输入：\n1 2 export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; . \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm 如果你发现文件中已经存在了上面这行代码，就不用往里面加了。这一步的作用是每次新打开一个 bash，nvm 都会被自动添加到环境变量中。\n最后，输入 source ~/.bash_profile重启环境变量的配置。\nPS：NVM 现在已经不支持 Homebrew 的方式来安装了。\n参考链接：https://www.jianshu.com/p/a3f8778bc0a1\n2、验证：(在 终端命令行中输入命令)\n（1）输入 nvm 命令查看环境变量是否配置成功：\n（2）输入 nvm ls，查看已安装的所有 node 版本。\n（3）输入 nvm -v，查看 已安装的 nvm 版本。\n（4）输入 node -v，查看正在使用的 node 版本。\n3、安装指定版本的 Node.js：\n和 Windows 下一样，也是执行如下命令：\n1 2 3 4 nvm install 版本号 # 举例 nvm install 8.10.0 网速有点慢，要稍等。\n输入 node -v，查看当前使用的 node 版本。\n安装好 Node 之后，npm 也会自动安装的，输入 npm -v，查看 npm 的版本。\n关于 NVM 的常用命令，详见下一段。\nNVM 的常用命令 注意，这一段说的是 NVM 的常用命令，不是 Node 的常用命令。\n查看当前使用的 nvm 版本：\n1 nvm --version 查看本地安装的所有的 Node.js 版本：\n1 2 3 4 5 # 方式1 nvm ls # 方式2 nvm list 安装指定版本的 Node.js：\n1 2 3 4 nvm install 版本号 # 举例 nvm install 8.10.0 卸载指定版本 Node.js：\n1 nvm uninstall 版本号 切换使用指定版本的 node：\n1 nvm use 版本号 设置node的默认版本：\n1 nvm alias default 版本号 查看全局npm包的安装路径：\n1 npm root -g 查看远程服务器端的所有 Node 版本：\n1 nvm ls-remote 执行上面的命令后，在列出的版本清单中，凡是用 Latest LTS标注的版本，则表明是长期维护的版本。我们在安装时，建议安装这些版本。当然，我们也可以在网址 https://nodejs.org/en/download/releases/ 查看 LTS 的历史版本。\nNode.js 的常用命令 查看 node 的版本：\n1 $ node -v 执行脚本字符串：\n1 $ node -e \u0026#39;console.log(\u0026#34;Hello World\u0026#34;)\u0026#39; 运行脚本文件：\n1 2 3 4 5 $ node index.js $ node path/index.js $ node path/index 查看帮助：\n1 $ node --help 进入 REPL 环境：\n1 $ node REPL 的全称：Read、Eval、 Print、Loop。类似于浏览器的控制台。\n如果要退出 REPL 环境，可以输入.exit 或 process.exit()。\n在 VS Code 里，我们可以在菜单栏选择“帮助-\u0026gt;切换开发人员工具”，打开 console 控制台。\n包和 NPM 什么是包 由于 Node 是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（package）的概念： 与核心模块类似，就是将一些预先设计好的功能或者说 API 封装到一个文件夹，提供给开发者使用。\nNode 本身并没有太多的功能性 API，所以市面上涌现出大量的第三方人员开发出来的 Package。\n包的加载机制 如果 Node 中自带的包和第三方的包名冲突了，该怎么处理呢？原则是：\n先在系统核心（优先级最高）的模块中找；\n然后到当前项目中 node_modules 目录中找。\n比如说：\n1 requiere(`fs`); 那加载的肯定是系统的包。所以，我们尽量不要创建一些和现有的包重名的包。\nNPM 的概念 NPM：Node Package Manager。官方链接： https://www.npmjs.com/\nNode.js 发展到现在，已经形成了一个非常庞大的生态圈。包的生态圈一旦繁荣起来，就必须有工具去来管理这些包。NPM 应运而生。\n举个例子，当我们在使用 Java 语言做开发时，需要用到 JDK 提供的内置库，以及第三方库。同样，在使用 JS 做开发时，我们可以使用 NPM 包管理器，方便地使用成熟的、优秀的第三方框架，融合到我们自己的项目中，极大地加速日常开发的构建过程。\n随着时间的发展，NPM 出现了两层概念：\n一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区。\n另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。\nNPM 的安装（不需要单独安装） NPM 不需要单独安装。默认在安装 Node 的时候，会连带一起安装 NPM：\nNVM、Node、NPM 安装之后，目录分布如下：\n输入 npm -v，查看 npm 的版本：\n如果上方命令无效，可能是之前的 node 并没有完全安装成功。解决办法：https://segmentfault.com/a/1190000011114680\n另外，Node 附带的 NPM 可能不是最新版本，可以用下面的命令，更新到最新版本：\n1 $ npm install npm -g 配置 NPM 的全局目录（暂略） NPM 默认安装到当前正在使用 Node 版本所在目录下。我们建议重新配置 NPM 的全局目录。\n输入npm config ls，查看：\nNPM 的常用命令 查看 npm 当前版本：\n1 npm -v 更新 npm：\n1 npm install npm@latest -g 项目初始化：（执行完成后，会生成package.json文件）\n1 2 3 4 npm init # 快速跳过问答式界面，选择默认配置 npm init --yes 只在当前工程下安装指定的包：\n1 npm install [package] 在全局安装指定的包：\n1 npm install -g [package] 安装的包只用于开发环境，不用于生产环境：（会出现在 package.json 文件中的 devDependencies 属性中）\n1 2 3 4 npm install [package] --save-dev # 或者 npm install [package] -D 安装的包需要发布到生产环境：（会出现在 package.json 文件中的 dependencies 属性中）\n1 2 3 4 npm install [package] --save # 或者 npm install [package] -S 查看当前目录下已安装的 node 包：\n1 npm list 查看全局已经安装的 node 包：\n1 npm list -g 查看 npm 帮助命令：\n1 npm --help 查看指定命令的帮助：\n1 npm [指定命令] --help 更新指定的包：\n1 npm update [package] 卸载指定的包：\n1 npm uninstall [package] 查看配置信息：\n1 npm config list 查看本地安装的指定包的信息，没有则显示 empty：\n1 npm ls [package] 查看全局安装的指定包的信息，没有则显示 empty：\n1 npm ls [package] -g 查看远程 npm 上指定包的所有版本信息：\n1 npm info [package] 查看当前包的安装路径：\n1 npm root 查看全局包的安装路径：\n1 npm root -g 配置 npm 镜像源 由于 npm 默认的下载地址在国外（npmjs.com），有时候会被墙，导致无法下载或者下载很慢。因此，我们可以尝试切换成，从其他的镜像源下载 npm 包。\n切换镜像源，有下面这几种方式：\n方式 1：临时切换镜像源。\n方式 2：切换镜像源\n方式 3：通过 NRM 切换镜像源（最为推荐的方式）。\n方式 4：cnpm。\n下面来分别讲一下。\n方式 1：临时切换镜像源 安装指定包的时候，通过追加 --registry参数即可。格式如下：\n1 2 3 4 5 # 格式 npm install [package] --registry [https://xxx] # 举例：在下载安装 express 这个包的时候，临时指定镜像源为 https://registry.npm.taobao.org npm install express --registry https://registry.npm.taobao.org 方式 2：切换镜像源 1 npm config set registry https://registry.npm.taobao.org 执行上述命令后，以后下载所有 npm 包的时候，都会改为使用淘宝的镜像源。\n方式 3：通过 NRM 切换镜像源（推荐） NRM：Node Registry Manager。作用是：切换和管理 npm 包的镜像源。\n项目地址：https://www.npmjs.com/package/nrm\nGitHub 地址： https://github.com/Pana/nrm\n安装 NRM：\n1 npm install -g nrm NRM 的常用命令：\n1 2 3 4 5 # 显示全部的镜像 nrm ls # 使用淘宝的镜像 nrm use taobao 效果如下：\n推荐的国内加速镜像淘宝：https://npm.taobao.org/\n方式 4：安装 cnpm 项目地址：https://npm.taobao.org/ 安装cnpm替换 npm（npm 由于源服务器在国外，下载包的速度较慢，cnpm 会使用国内镜像）：\n1 npm install -g cnpm --registry=https://registry.npm.taobao.org 以后我们就可以通过 cnpm 命令去安装一个包。举例如下：\n1 2 # 安装 vue 这个包 cnpm install vue 这里的单词 install 可以简写成 i。\nNode.js 的简单使用 我们可以输入node命令，然后在里面写 js 的代码。\n或者，也可以 通过 node 运行 指定的 js 文件。比如，编写好一个 js 文件01.js，然后在命令行输入：\n1 node 01.js 就可以执行这个 js 程序，直接在命令行查看运行结果。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/03-node.js%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","summary":"Node.js 运行环境配置：通过 Node.js 安装包（不推荐） 去 Node.js 的官网下载安装包： 我们也可以在https://nodejs.org/en/download/rel","title":"03-Node.js开发环境安装"},{"content":"组件的生命周期 在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件统称为组件的生命周期。\n生命周期的阶段 组件生命周期分为三个阶段，下面分别来讲解。\n1、组件创建阶段 组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次。\ngetDefaultProps 初始化 props 属性默认值。\ngetInitialState 初始化组件的私有数据。因为 state 是定义在组件的 constructor 构造器当中的，只要new 了 class类，必然会调用 constructor构造器。\ncomponentWillMount() 组件将要被挂载。此时还没有开始渲染虚拟DOM。\n在这个阶段，不能去操作DOM元素，但可以操作属性、状态、function。相当于 Vue 中的Create()函数。\nrender() 第一次开始渲染真正的虚拟DOM。当render执行完，内存中就有了完整的虚拟DOM了。\n意思是，此时，虚拟DOM在内存中创建好了，但是还没有挂在到页面上。\n在这个函数内部，不能去操作DOM元素，因为还没return之前，虚拟DOM还没有创建；当return执行完毕后，虚拟DOM就创建好了，但是还没有挂在到页面上。\ncomponentDidMount() 当组件（虚拟DOM）挂载到页面之后，会进入这个生命周期函数。\n只要进入到这个生命周期函数，则必然说明，页面上已经有可见的DOM元素了。此时，组件已经显示到了页面上，state上的数据、内存中的虚拟DOM、以及浏览器中的页面，已经完全保持一致了。\n当这个方法执行完，组件就进入都了 运行中 的状态。所以说，componentDidMount 是创建阶段的最后一个函数。\n在这个函数中，我们可以放心的去 操作 页面上你需要使用的 DOM 元素了。如果我们想操作DOM元素，最早只能在 componentDidMount 中进行。相当于 Vue 中的 mounted() 函数\n2、组件运行阶段 有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次。\ncomponentWillReceiveProps() 组件将要接收新属性。只有当父组件中，通过某些事件，重新修改了 传递给 子组件的 props 数据之后，才会触发这个钩子函数。\nshouldComponentUpdate() 判断组件是否需要被更新。此时，组件尚未被更新，但是，state 和 props 肯定是最新的。\ncomponentWillUpdate() 组件将要被更新。此时，组件还没有被更新，在进入到这个生命周期函数的时候，内存中的虚拟DOM还是旧的，页面上的 DOM 元素也是旧的。（也就是说，此时操作的是旧的 DOM元素）\nrender 此时，又要根据最新的 state 和 props，重新渲染一棵内存中的 虚拟DOM树。当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时，虚拟DOM树已经和组件的 state 保持一致了，都是最新的；但是页面还是旧的。\ncomponentDidUpdate 此时，组件完成更新，页面被重新渲染。此时，state、虚拟DOM 和 页面已经完全保持同步。\n3、组件销毁阶段 一辈子只执行一次。\ncomponentWillUnmount: 组件将要被卸载。此时组件还可以正常使用。 React 生命周期的截图如下：\n20190212_1745.jpg\n生命周期对比：\nvue中的生命周期图\nReact Native 中组件的生命周期\n组件生命周期的执行顺序 1、Mounting：\nconstructor()\ncomponentWillMount()\nrender()\ncomponentDidMount()\n2、Updating：\ncomponentWillReceiveProps(nextProps)：接收父组件传递过来的属性\nshouldComponentUpdate(nextProps, nextState)：一旦调用 setState，就会触发这个方法。方法默认 return true；如果 return false，后续的方法就不会走了。\ncomponentWillUpdate(nextProps, nextState)\nrender()\ncomponentDidUpdate(prevProps, prevState)\n3、Unmounting：\ncomponentWillUnmount() ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/03-react%E7%BB%84%E4%BB%B6%E4%B8%80%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"组件的生命周期 在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件统称为组件的生","title":"03-React组件（一）：生命周期"},{"content":"变量的数据类型 为什么需要数据类型 在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数据类型，寓意也不同。\n我们都知道，无论这个变量是字符串类型，还是数字类型，我们都可以直接用 var 去定义它。比如：\n1 2 3 var a = \u0026#39;hello word\u0026#39;; var b = 123; 为什么可以这样做呢？这是因为：JavaScript 是一种「弱类型语言」，或者说是一种「动态语言」，这意味着不需要提前声明变量的类型，在程序运行过程中，类型会自动被确定。\nJS 的变量数据类型，是在程序运行的过程中，根据等号右边的值来确定的。而且，变量的数据类型是可以变化的。比如说：\n1 2 3 var name = \u0026#39;qianguyihao\u0026#39;; name = 123; // 强制将变量 name 修改为 数字类型 JS中一共有六种数据类型 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。\n引用数据类型（引用类型）：Object 对象。\n注意：内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。\n面试问：引用数据类型有几种？\n面试答：只有一种，即 Object 类型。\n数据类型之间最大的区别：\n基本数据类型：参数赋值的时候，传数值。\n引用数据类型：参数赋值的时候，传地址（修改的同一片内存空间）。\n一个经典的例子 基本数据类型举例：\n1 2 3 4 5 6 7 var a = 23; var b = a; a++; console.log(a); // 打印结果：24 console.log(b); // 打印结果：23 上面的代码中：a 和 b 都是基本数据类型，让 b 等于 a，然后改变 a 的值之后，发现 b 的值并没有被改变。\n但是在引用数据类型中，就不同了，我们来看一看。\n引用数据类型举例：\n1 2 3 4 5 6 7 8 9 10 11 var obj1 = new Object(); obj1.name = \u0026#39;smyh\u0026#39;; // 让 obj2 等于 obj1 var obj2 = obj1; // 修改 obj1 的 name 属性 obj1.name = \u0026#39;vae\u0026#39;; console.log(obj1.name); // 打印结果：vae console.log(obj2.name); // 打印结果：vae 上面的代码中：obj1 和 obj2 都是引用数据类型，让 obj2 等于 obj1，然后修改 obj1.name 的值之后，发现 obj2.name 的值也发生了改变。\n从上面的例子中，可以反映出，基本数据类型和引用数据类型是有区别的。\n那到底有什么区别呢？我们进一步往下看。\n栈内存和堆内存 我们首先记住一句话：JS中，所有的变量都是保存在栈内存中的。\n然后来看看下面的区别。\n基本数据类型：\n基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。\n引用数据类型：\n对象是保存到堆内存中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；而变量保存了对象的内存地址（对象的引用），保存在栈内存当中。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/03-%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"变量的数据类型 为什么需要数据类型 在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数","title":"03-变量的数据类型：基本数据类型和引用数据类型"},{"content":"ES6 的变量声明 ES5 中，使用 var 定义全局变量（ var 是 variable 的简写）。\nES6 中，新增了 let 和 const 来定义变量：\nlet：定义局部变量，替代 var。\nconst：定义常量（定义后，不可修改）。\n1、var：定义全局变量 看下面的代码：\n1 2 3 4 5 { var a = 1; } console.log(a); //这里的 a，指的是 区块 里的 a 上方代码是可以输出结果的，输出结果为 1。因为 var 是全局声明的，所以，即使是在区块里声明，但仍然在全局起作用。\n也就是说：使用 var 声明的变量不具备块级作用域特性。\n再来看下面这段代码：\n1 2 3 4 5 6 var a = 1; { var a = 2; } console.log(a); //这里的 a，指的是 区块 里的 a 上方代码的输出结果为 2 ，因为 var 是全局声明的。\n总结：\n用 var 定义的全部变量，有时候会污染整个 js 的作用域。我们在如今的实战中，基本都是用的 ES6 语法，所以请尽量避免使用 var 定义变量。\n2、let：定义局部变量 举例 1：\n1 2 3 4 { let a = \u0026#39;hello\u0026#39;; } console.log(a); // 打印结果报错：Uncaught ReferenceError: a is not defined 上方代码，打印报错。\n举例 2：\n1 2 3 4 5 6 var a = 2; { let a = 3; } console.log(a); // 打印结果：2 通过上面两个例子可以看出，用 let 声明的变量，只在局部（块级作用域内）起作用。\n经典面试题：\nlet 可以防止数据污染，我们来看下面这个 for 循环的经典面试题。\n1、用 var 声明变量：\n1 2 3 4 5 for (var i = 0; i \u0026lt; 10; i++) { console.log(\u0026#39;循环体中:\u0026#39; + i); } console.log(\u0026#39;循环体外:\u0026#39; + i); 上方代码可以正常打印结果，且最后一行的打印结果是 10。说明循环体外定义的变量 i，是全局作用域下的 i。\n2、用 let 声明变量：\n1 2 3 4 5 for (let i = 0; i \u0026lt; 10; i++) { console.log(\u0026#39;循环体中:\u0026#39; + i); // // 每循环一次，就会在 { } 所在的块级作用域中，重新定义一个新的变量 i } console.log(\u0026#39;循环体外:\u0026#39; + i); 上方代码的关键在于：每次循环都会产生一个块级作用域，每个块级作用域中会重新定义一个新的变量 i。\n另外，上方代码的最后一行无法打印结果，也就是说打印会报错。因为用 let 定义的变量 i，只在{ }这个块级作用域里生效。\n总结：我们要习惯用 let 声明，减少 var 声明带来的污染全局空间。\n为了进一步说明 let 不会带来污染，需要说明的是：当我们定义了let a = 1时，如果我们在同一个作用域内继续定义let a = 2，是会报错的。\n3、const：定义常量 在程序开发中，有些变量是希望声明后，在业务层就不再发生变化，此时可以用 const 来定义常量。常量就是值（内存地址）不能变化的量。\n举例：\n1 const name = \u0026#39;smyhvae\u0026#39;; //定义常量 用 const 声明的常量，只在局部（块级作用域内）起作用；而且，用 const 声明常量时，必须赋值，否则报错。\nlet 和 const 的特点【重要】 不存在变量提升\n禁止重复声明\n支持块级作用域\n暂时性死区\n相反， 用var声明的变量：存在变量提升、可以重复声明、没有块级作用域。\nvar/let/const 的共同点 全局作用域中定义的变量，可以在函数中使用。\n函数中声明的变量，只能在函数及其子函数中使用，外部无法使用。\n总结 关于 let、const、var 更详细的介绍和区别，可以看本项目的另一篇文章《JavaScript 进阶/var、let、const 的区别.md》。\nfor 循环举例（经典案例） 代码 1、我们先来看看如下代码：（用 var 定义变量 i）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;aa\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;bb\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;cc\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;dd\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; var myBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;); for (var i = 0; i \u0026lt; myBtn.length; i++) { myBtn[i].onclick = function () { alert(i); }; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中的运行效果如下：\n你可能会感到诧异，为何点击任何一个按钮，弹出的内容都是 4 呢？这是因为，我们用 var 定义的变量 i，是在全局作用域声明的。整个代码中，自始至终只有一个变量。\nfor 循环是同步代码，而 onclick 点击事件是异步代码。当我们还没点击按钮之前，同步代码已经执行完了，变量 i 已经循环到 4 了。\n也就是说，上面的 for 循环，相当于如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var i = 0; myBtn[0].onclick = function () { alert(i); }; i++; myBtn[1].onclick = function () { alert(i); }; i++; myBtn[2].onclick = function () { alert(i); }; i++; myBtn[3].onclick = function () { alert(i); }; i++; // 到这里，i 的值已经是4了。因此，当我们点击按钮时，i的值一直都是4 代码 2、上面的代码中，如果我们改为用 let 定义变量 i：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;aa\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;bb\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;cc\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;dd\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; var myBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;); for (let i = 0; i \u0026lt; myBtn.length; i++) { myBtn[i].onclick = function () { alert(i); }; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中的运行效果如下：\n上面这个运行结果，才是我们预期的效果。我们用 let 定义变量 i，在循环的过程中，每执行一次循环体，就会诞生一个新的 i。循环体执行 4 次，就会有四个 i。\n暂时性死区 DTC ES6 规定：使用 let/const 声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。\n也就是说，在使用 let/const 声明变量时，变量需要先声明，再使用（声明语句必须放在使用之前）。这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）。\nDTC 其实是一种保护机制，可以让我们养成良好的编程习惯。\n代码举例：\n1 2 3 4 5 6 7 8 const name = \u0026#39;qianguyihao\u0026#39;; function foo() { console.log(name); const name = \u0026#39;hello\u0026#39;; } foo(); // 执行函数后，控制台报错：Uncaught ReferenceError: Cannot access \u0026#39;name\u0026#39; before initialization 参考链接： 阮一峰 | ECMAScript 6 入门 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/04-es6%E5%8F%98%E9%87%8F-letconst-%E5%92%8C%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/","summary":"ES6 的变量声明 ES5 中，使用 var 定义全局变量（ var 是 variable 的简写）。 ES6 中，新增了 let 和 const 来定义变量： let：定义局部变量，替代 var。 const：定义常量（","title":"04-ES6：变量 let、const 和块级作用域"},{"content":"前言 MySQL 中的字段，主要有四种数据类型：\n整型（整数）\n小数\n字符串类型\n时间日期类型\n下面来详细讲一讲。\n整数类型 整数类型的分类 MySQL中，整型有五种：\n迷你整型：tinyint，使用1个字节存储整数，最多存储256个整数（-128~127）。\n短整型：smallint，使用2个字节存储整数。\n中整型：mediumint，使用3个字节存储整数。\n标准整型：int，使用4个字节存储整数。\n大整型：bigint，使用8个字节存储。\n强调：\n（1）如果你不知道用哪一种，或者懒得计算，那就用标准整型 int吧，这个用的最多。\n（2）整型在 MySQL 中默认是有符号的，即有正负；无符号需要使用 unsigned 修饰整型，代表正整数。\n举例：\n在指定的表中新增 age 字段，要求 age 是正整数：\n1 alter table table_qiangu1 add age int unsigned; 设计思路 如果需要新建整型的字段，设计思路如下：\n（1）确定需要存储的数据是整数。\n（2）预估整数的范围，选择合适的整数类型。\n（3）确定这个整数是否需要包含负数。\n整数类型的取值范围 todo。参考链接：https://blog.csdn.net/slyjit/article/details/54290486\n整数类型的显示宽度、零填充 我们在很多设计表中，可能会看到比如 int(11)这种数据类型，这里面的 11代表的就是显示宽度。\n所谓的显示宽度，其实就是显示的时候，看到的最少数字个数。\n比如 int(2) ，表示不管你的数值是多少，最少可以看到两个数字。假如你存的数值是9，没有满两位，就会在前面补零，显示为09；假如你的数值是120，超过了显示宽度，则直接显示原始值，不会做零填充。\n显示宽度的注意事项：\n显示宽度只适用于 MySQL 的整数类型。\n显示宽度只是指明 MySQL 整数类型最少显示的数字个数（可以通过desc查看表字段显示）。\n显示宽度只是在显示的时候改变数值的样式，不会对原本的值进行更改。\n显示宽度和数值类型的取值范围无关。例如int(10) 他的取值范围依然是(-2 147 483 648，2 147 483 647)。\n零填充的注意事项：\n要想让显示宽度自动进行零填充，必须要配合 ZEROFILL这个关键字一起使用。\n零填充只能针对正整数，也就是说，ZEROFILL 要求整型为无符号型。\n举例：\n1、新建一张表，然后在这张表中新增 num1 字段，要求 num1 显示3位，不够3位的自动进行零填充：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 新建一张表 CREATE TABLE table_qiangu1 ( id int NOT NULL AUTO_INCREMENT PRIMARY KEY ); # 显示宽度有效（正确写法） alter table table_qiangu1 add num1 int(3) zerofill; # 对比：普通写法，显示宽度无效 alter table table_qiangu1 add num2 int(3); # 对比：普通写法 alter table table_qiangu1 add num3 int; 上述命令中，如果把 zerofill 这个关键字去掉，是达不到显示宽度的效果的。执行完上述命令后，我们执行 desc table_qiangu1 命令，对比一下 num1、num2、num3 的字段结构就知道了：\n上方截图可以看到，只有 num1 才有显示宽度，它可以进行零填充，num2、num3不行。我们往表中插入整数 6，然后看看显示结果，就一目了然：\n参考链接：MySql数据库 数值类型的显示宽度\n小数 MySQL 中的小数分为两大类：\n浮点型的数据分为两种：\n单精度：float，使用4个字节存储，精度范围为6-7位有效数字。\n双精度：double，使用8个字节存储，精度范围为14-15位有效数字。\n注意：\n浮点数超过精度范围会自动进行四舍五入。\n精度可以指定整数和小数部分。比如\n","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/04-mysql%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"前言 MySQL 中的字段，主要有四种数据类型： 整型（整数） 小数 字符串类型 时间日期类型 下面来详细讲一讲。 整数类型 整数类型的分类 MySQL中，整型有五种：","title":"04-MySQL字段的数据类型"},{"content":"前言 网站越来越复杂，js代码、js文件也越来越多，会遇到一些问题：\n文件依赖\n全局污染、命名冲突\n程序模块化包括：\n日期模块\n数学计算模块\n日志模块\n登陆认证模块\n报表展示模块等。\n所有这些模块共同组成了程序软件系统。\n一次编写，多次使用，才是提高效率的核心。\n模块化的理解 什么是模块化 概念：将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起。\n模块的内部数据、实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。\n最早的时候，我们会把所有的代码都写在一个js文件里，那么，耦合性会很高（关联性强），不利于维护；而且会造成全局污染，很容易命名冲突。\n模块化的好处 避免命名冲突，减少命名空间污染\n降低耦合性；更好地分离、按需加载\n高复用性：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能。\n高可维护性：软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁。使用模块化的开发，方式更容易维护。\n部署方便\n模块化规范 模块化规范的引入 假设我们引入模块化，首先可能会想到的思路是：在一个文件中引入多个js文件。如下：\n1 2 3 4 5 6 7 \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;zepto.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;fastClick.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;util/login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;util/base.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;util/city.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 但是这样做会带来很多问题：\n请求过多：引入十个js文件，就有十次http请求。\n依赖模糊：不同的js文件可能会相互依赖，如果改其中的一个文件，另外一个文件可能会报错。\n以上两点，最终导致：难以维护。\n于是，这就引入了模块化规范。\n模块化的概念解读 模块化起源于 Node.js。Node.js 中把很多 js 打包成 package，需要的时候直接通过 require 的方式进行调用（CommonJS），这就是模块化的方式。\n那如何把这种模块化思维应用到前端来呢？这就产生了两种伟大的 js：RequireJS 和 SeaJS。\n模块化规范 服务器端规范：\nCommonJS规范：是 Node.js 使用的模块化规范。 CommonJS 就是一套约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。\n浏览器端规范：\nAMD规范：是 RequireJS 在推广过程中对模块化定义的规范化产出。 1 2 3 4 5 - 异步加载模块； - 依赖前置、提前执行：require([`foo`,`bar`],function(foo,bar){}); //也就是说把所有的包都 require 成功，再继续执行代码。 - define 定义模块：define([`require`,`foo`],function(){return}); CMD规范：是 SeaJS 在推广过程中对模块化定义的规范化产出。淘宝团队开发。 1 2 3 4 5 6 同步加载模块； 依赖就近，延迟执行：require(./a) 直接引入。或者Require.async 异步引入。 //依赖就近：执行到这一部分的时候，再去加载对应的文件。 define 定义模块， export 导出：define(function(require, export, module){}); PS：面试时，经常会问AMD 和 CMD 的区别。\n另外，还有ES6规范：import \u0026amp; export。\n这篇文章，我们来讲一下CommonJS，它是 Node.js 使用的模块化规范。\nCommonJS 的基本语法 CommonJS 的介绍 CommonJS：是 Node.js 使用的模块化规范。也就是说，Node.js 就是基于 CommonJS 这种模块化规范来编写的。\nCommonJS 规范规定：每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的 module.exports 对象。\n在 CommonJS 中，每个文件都可以当作一个模块：\n在服务器端：模块的加载是运行时同步加载的。\n在浏览器端: 模块需要提前编译打包处理。首先，既然同步的，很容易引起阻塞；其次，浏览器不认识require语法，因此，需要提前编译打包。\n模块的暴露和引入 Node.js 中只有模块级作用域，两个模块之间的变量、方法，默认是互不冲突，互不影响，这样就导致一个问题：模块 A 要怎样使用模块B中的变量\u0026amp;方法呢？这就需要通过 exports 关键字来实现。\nNode.js中，每个模块都有一个 exports 接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他的模块才可以使用。\n接下来详细讲一讲模块的暴露、模块的引入。\n暴露模块的方式一： exports exports对象用来导出当前模块的公共方法或属性。别的模块通过 require 函数调用当前模块时，得到的就是当前模块的 exports 对象。\n语法格式：\n1 2 // 相当于是：给 exports 对象添加属性 exports.xxx = value 这个 value 可以是任意的数据类型。\n注意：暴露的关键词是exports，不是export。其实，这里的 exports 类似于 ES6 中的 export 的用法，都是用来导出一个指定名字的对象。\n代码举例：\n1 2 3 4 5 6 7 8 const name = \u0026#39;qianguyihao\u0026#39;; const foo = function (value) { return value * 2; }; exports.name = name; exports.foo = foo; 暴露模块的方式二： module.exports module.exports用来导出一个默认对象，没有指定对象名。\n语法格式：\n1 2 3 4 5 // 方式一：导出整个 exports 对象 module.exports = value; // 方式二：给 exports 对象添加属性 module.exports.xxx = value; 这个 value 可以是任意的数据类型。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 方式1 module.exports = { name: \u0026#39;我是 module1\u0026#39;, foo(){ console.log(this.name); } } // 我们不能再继续写 module.exports = value2。因为重新赋值，会把 exports 对象 之前的赋值覆盖掉。 // 方式2 const age = 28; module.exports.age = age; module.exports 还可以修改模块的原始导出对象。比如当前模块原本导出的是一个对象，我们可以通过 module.exports 修改为导出一个函数。如下：\n1 2 3 module.exports = function () { console.log(\u0026#39;hello world\u0026#39;) } exports 和 module.exports 的区别 最重要的区别：\n使用exports时，只能单个设置属性 exports.a = a;\n使用module.exports时，既单个设置属性 module.exports.a，也可以整个赋值 module.exports = obj。\n其他要点：\nNode中每个模块的最后，都会执行 return: module.exports。\nNode中每个模块都会把 module.exports指向的对象赋值给一个变量 exports，也就是说 exports = module.exports。\nmodule.exports = XXX，表示当前模块导出一个单一成员，结果就是XXX。\n如果需要导出多个成员，则必须使用 exports.add = XXX; exports.foo = XXX。或者使用 module.exports.add = XXX; module.export.foo = XXX。\n问题: 暴露的模块到底是谁？ 答案：暴露的本质是exports对象。【重要】\n比如，方式一的 exports.a = a 可以理解成是，给 exports 对象添加属性。方式二的 module.exports = a可以理解成是给整个 exports 对象赋值。方式二的 module.exports.c = c可以理解成是给 exports 对象添加属性。\nNode.js 中每个模块都有一个 module 对象，module 对象中的有一个 exports 属性称之为接口对象。我们需要把模块之间公共的方法或属性挂载在这个接口对象中，方便其他的模块使用。\n引入模块的方式：require require函数用来在一个模块中引入另外一个模块。传入模块名，返回模块导出对象。\n语法格式：\n1 const module1 = require(\u0026#39;模块名\u0026#39;); 解释：\n内置模块：require的是包名。\n下载的第三方模块：require的是包名。\n自定义模块：require的是文件路径。文件路径既可以用绝对路径，也可以用相对路径。后缀名.js可以省略。\n代码举例：\n1 2 3 4 5 const module1 = require(\u0026#39;./main.js\u0026#39;); const module2 = require(\u0026#39;./main\u0026#39;); const module3 = require(\u0026#39;Demo/src/main.js\u0026#39;); require()函数的两个作用：\n执行导入的模块中的代码。\n返回导入模块中的接口对象。\n主模块 主模块是整个程序执行的入口，可以调度其他模块。\n1 2 # 运行main.js启动程序。此时，main.js就是主模块 $ node main.js 模块的初始化 一个模块中的 JS 代码仅在模块第一次被使用时执行一次，并且在使用的过程中进行初始化，然后会被缓存起来，便于后续继续使用。\n代码举例：\n（1）calModule.js:\n1 2 3 4 5 6 7 var a = 1; ​ function add () { return ++a; } ​ exports.add = add; （2）main.js：（在 main.js 中引入 hello.js 模块）\n1 2 3 4 5 var addModule1 = require(\u0026#39;./calModule\u0026#39;) var addModule2 = require(\u0026#39;./calModule\u0026#39;) ​ console.log(addModule1.add()); console.log(addModule2.add()); 在命令行执行 node main.js 运行程序，打印结果：\n1 2 2 3 从打印结果中可以看出，calModule.js这个模块虽然被引用了两次，但只初始化了一次。\nCommonJS 在服务器端的实现举例 1、初始化项目 在工程文件中新建如下目录和文件：\n1 2 3 4 5 6 modules | module1.js | module2.js | module3.js app.js 然后在根目录下新建如下命令：\n1 npm init 然后根据提示，依次输入如下内容：\n包名：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。\n版本：可以用默认的版本 1.0.0，也可以自己修改包名。\n其他的参数，一路回车即可。效果如下：\n于是，根目录下会自动生成package.json这个文件。点进去看一下：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;name\u0026#34;: \u0026#34;commonjs_node\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;app.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;smyhvae\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 2、导入第三方包 uniq这个第三方包的作用是保证唯一性（我们拿它来举例）。我们在当前工程目录下，输入如下命令进行安装：\n1 npm install uniq 安装成功后，根目录下会自动生成相应的文件：\n需要说明的是，我的node版本是 v8.10.0（v8以上），对应的 npm 版本是 v5.6.0，版本比较高，因此，当我输入完npm install uniq之后，package.json中就会自动添加uniq包的依赖：\n如果有些童鞋的npm版本较低，就需要手动去添加依赖；另一种方式是，可以使用npm install uniq --save命令，这个多出来的--save就可以自动添加依赖。\n我们去官网看一下uniq的用法：\n1 2 3 4 5 let uniq = require(\u0026#39;uniq\u0026#39;); let arr = [1, 1, 2, 2, 3, 5]; uniq(arr); console.log(arr); //输出结果：[ 1, 2, 3, 5 ] 可以看出，这个包可以起到数组去重的作用。\n3、自定义模块 （1）module1.js：\n1 2 3 4 5 6 7 8 9 10 11 //暴露方式一：module.exports = value //暴露一个对象出去 module.exports = { name: \u0026#39;我是 module1\u0026#39;, foo(){ console.log(this.name); } } //我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。 （2）module2.js：\n1 2 3 4 5 6 //暴露方式一：module.exports = value //暴露一个函数出去 module.exports = function(){ console.log(\u0026#39;我是 module2\u0026#39;); } 注意，此时暴露出去的 exports 对象 等价于整个函数。\n（3）module3.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //暴露方式二：exports.xxx = value //可以往 export 对象中不断地添加属性，进行暴露 exports.foo1 = function(){ console.log(\u0026#39;module3 中的 foo1 方法\u0026#39;); } exports.foo2 = function(){ console.log(\u0026#39;module3 中的 foo2 方法\u0026#39;); } exports.arr = [1,1,2,2,3,5,11]; （4）app.js：（将其他模块汇集到主模块）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //将其他模块汇集到主模块 let uniq = require(\u0026#39;uniq\u0026#39;); //引入时，第三方模块要放在自定义模块的上面 let module1 = require(\u0026#39;./modules/module1\u0026#39;); let module2 = require(\u0026#39;./modules/module2\u0026#39;); let module3 = require(\u0026#39;./modules/module3\u0026#39;); //调用module1对象的方法 module1.foo(); //调用module2的函数 module2(); //注意，在定义时，module2对象等价于整个函数function。所以，module2()的意思是，直接调用了函数。 //调用module3中的属性 module3.foo1(); module3.foo2(); uniq(module3.arr); //将module3中的数组进行去重操作 console.log(module3.arr); //打印数组去重后的结果 这样的话，我们的代码就写完了。\n我们在命令行中输入node app.js，就可以把代码跑起来了。打印结果如下：\n1 2 3 4 5 我是 module1 我是 module2 module3 中的 foo1 方法 module3 中的 foo2 方法 [ 1, 11, 2, 3, 5 ] CommonJS 基于浏览器端的实现举例 1、初始化项目 在工程文件中新建如下目录和文件：\n1 2 3 4 5 6 7 8 js dist //打包生成文件的目录 src //源码所在的目录 | module1.js | module2.js | module3.js | app.js //应用主源文件 index.html //因为CommonJS是基于浏览器端，js文件要跑在浏览器的页面上，所以要有这个html页面 然后在根目录下新建如下命令：\n1 npm init 然后根据提示，依次输入如下内容：\n包名：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。\n版本：可以用默认的版本 1.0.0，也可以自己修改包名。\n其他的参数，一路回车即可。\n于是，根目录下会自动生成package.json这个文件。点进去看一下：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;name\u0026#34;: \u0026#34;commonjs_browser\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 2、下载第三方包：Browserify 这里需要用到Browserify这个工具进行编译打包。Browserify 称为 CommonJS 的浏览器端的打包工具。\n输入如下命令进行安装：（两个命令都要输入）\n1 2 npm install browserify -g //全局 npm install browserify --save-dev //局部。 上面的代码中，-dev表示开发依赖。这里解释一下相关概念：\n开发依赖：当前这个包，只在开发环境下使用。\n运行依赖：当前这个包，是在生产环境下使用。\n3、自定义模块 \u0026amp; 代码运行 （1）module1.js：\n1 2 3 4 5 6 7 8 9 10 11 //暴露方式一：module.exports = value //暴露一个对象出去 module.exports = { name: \u0026#39;我是 module1\u0026#39;, foo(){ console.log(this.name); } } //我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。 （2）module2.js：\n1 2 3 4 5 6 //暴露方式一：module.exports = value //暴露一个函数出去 module.exports = function(){ console.log(\u0026#39;我是 module2\u0026#39;); } 注意，此时暴露出去的 exports 对象 等价于整个函数。\n（3）module3.js：\n1 2 3 4 5 6 7 8 9 10 11 //暴露方式二：exports.xxx = value //可以往export对象中不断地添加属性，进行暴露 exports.foo1 = function(){ console.log(\u0026#39;module3 中的 foo1 方法\u0026#39;); } exports.foo2 = function(){ console.log(\u0026#39;module3 中的 foo2 方法\u0026#39;); } （4）app.js：（将其他模块汇集到主模块）\n1 2 3 4 5 6 7 8 let module1 = require(\u0026#39;./module1\u0026#39;); // ./ 指的是当前路径 let module2 = require(\u0026#39;./module2\u0026#39;); let module3 = require(\u0026#39;./module3\u0026#39;); module1.foo(); module2(); module3.foo1(); module3.foo2(); 引入的路径解释：\n./是相对路径，指的是当前路径（app.js的当前路径是src） 到此，我们的主要代码就写完了。\n但是，如果我们直接在index.html中，像下面这样写，是不行的：（因为浏览器不认识 require 关键字）\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;./js/src/app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 为了能够让index.html引入app.js，我们需要输入如下命令：\n打包处理js:\n1 browserify js/src/app.js -o js/dist/bundle.js 然后在index.html中引入打包后的文件：\n1 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/dist/bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/04-node.js%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83commonjs/","summary":"前言 网站越来越复杂，js代码、js文件也越来越多，会遇到一些问题： 文件依赖 全局污染、命名冲突 程序模块化包括： 日期模块 数学计算模块 日志模块 登陆","title":"04-Node.js模块化规范：CommonJS"},{"content":"defaultProps 和 prop-types 使用 defaultProps 设置组件的默认值 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值。\n格式举例：\n1 2 3 4 // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） }; 使用prop-types进行props数据类型的校验 在组件中，可以通过 prop-types 把外界传递过来的属性，做类型校验。如果类型不匹配，控制台会弹出告警。\n注意：如果要为 传递过来的属性做类型校验，必须安装 React 提供的 第三方包，叫做 prop-types。\n格式举例：\n1 2 3 static propTypes = { initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 }; 下方代码中，在引用组件的时候，如果类型不匹配：\n1 2 3 4 5 6 7 8 // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; {/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */} \u0026lt;Counter initcount=\u0026#34;我是string类型\u0026#34;\u0026gt;\u0026lt;/Counter\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); 控制台告警如下：\n20190212_2130.png\n代码举例 我们把 defaultProps 和 prop-types 来举个例子。\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; // 导入计数器组件 import Counter from \u0026#34;./components/Counter.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; {/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */} \u0026lt;Counter initcount={0}\u0026gt;\u0026lt;/Counter\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); （3）/components/Counter.jsx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import React from \u0026#34;react\u0026#34;; // 注意： prop-types 包中职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验 import ReactTypes from \u0026#34;prop-types\u0026#34;; export default class Counter extends React.Component { constructor(props) { super(props); // 初始化组件，保存的是组件的私有数据 this.state = { msg: \u0026#34;ok\u0026#34;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 }; } // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个 数值，为0 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Counter 计数器组件 \u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;当前的计数是：{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 } } 运行效果：\n20190212_2100.png\n事件绑定 案例：点击按钮后，计数器 +1。\n原生js做事件绑定 代码举例：\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; // 导入计数器组件 import Counter from \u0026#34;./components/Counter.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; {/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */} \u0026lt;Counter initcount={0}\u0026gt;\u0026lt;/Counter\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); （3）/components/Counter.jsx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import React from \u0026#34;react\u0026#34;; // 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验 import ReactTypes from \u0026#34;prop-types\u0026#34;; export default class Counter extends React.Component { constructor(props) { super(props); // 初始化组件，保存的是组件的私有数据 this.state = { msg: \u0026#34;ok\u0026#34;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 }; } // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） }; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = { initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Counter 计数器组件 \u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;+1\u0026#34; id=\u0026#34;btn\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;当前的计数是：{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 } // 当组件挂载到页面上之后，会进入这个生命周期函数，只要进入这个生命周期函数了，必然说明，页面上，已经有可见的DOM元素了 componentDidMount() { // 在这个函数中，我们可以放心的去 操作 页面上你需要使用的 DOM 元素了。 // 也就是说，如果我们想操作DOM元素，最早，只能在 componentDidMount 中进行。 document.getElementById(\u0026#34;btn\u0026#34;).onclick = () =\u0026gt; { this.setState({ count: this.state.count + 1 }); }; } } 使用 React 提供的方法，做事件绑定 代码举例：\n（1）index.html和 （2）main.js 的代码不变，和上一小段中的代码一致。\n（3）/components/Counter.jsx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import React from \u0026#34;react\u0026#34;; // 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验 import ReactTypes from \u0026#34;prop-types\u0026#34;; export default class Counter extends React.Component { constructor(props) { super(props); // 初始化组件，保存的是组件的私有数据 this.state = { msg: \u0026#34;ok\u0026#34;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 }; } // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） }; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = { initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Counter 计数器组件 \u0026lt;/h3\u0026gt; {/* 这里的 this 指向的是 Counter 组件的实例 */} \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;+1\u0026#34; id=\u0026#34;btn\u0026#34; onClick={this.myMethod} /\u0026gt; \u0026lt;p\u0026gt;当前的计数是：{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 } // 点击事件的方法定义 myMethod = () =\u0026gt; { // 修改组件的state里面的值 this.setState({ count: this.state.count + 1 }); }; } 生命周期函数：shouldComponentUpdate() 在 shouldComponentUpdate() 函数中，必须要求返回一个布尔值。\n需要注意的是：如果返回的值是 false，则不会继续执行后续的生命周期函数，而是直接退回到了 运行中 的状态。因为此时，后续的 render 函数并没有被调用，因此页面不会被更新，但是组件的 state 状态，却被修改了。这种情况，我们也可以这样理解：如果返回值为 false，此时只是更新了 state 里面的数值，但是并没有渲染到 DOM节点上。\n利用上面这个特性，我们可以来举个例子。\n举例：实现 Counter 计数器只在偶数情况下更新。\n实现思路：在 shouldComponentUpdate() 函数中，如果 state 中 的count 的值为奇数，就 return false；否则就 return true。\n代码实现：（我们在上面的Counter.jsx代码基础之上，做添加）\n1 2 3 4 5 6 7 8 9 10 11 12 // 判断组件是否需要更新 shouldComponentUpdate(nextProps, nextState) { // 经过打印测试发现：在 shouldComponentUpdate 中，通过 this.state.count 拿到的值，是上一次的旧数据，并不是当前最新的； // 解决办法：通过 shouldComponentUpdate 函数的第二个参数 nextState，可以拿到 最新的 state 数据。 console.log(this.state.count + \u0026#34; ---- \u0026#34; + nextState.count); // 需求： 如果 state 中的 count 值是偶数，则 更新页面；如果 count 值 是奇数，则不更新页面。最终实现的的页面效果：2，4，6，8，10，12.... // return this.state.count % 2 === 0 ? true : false return nextState.count % 2 === 0 ? true : false; } 上面这部分的代码，和 render() 方法是并列的。我们需要注意里面的注释，关注 nextState 参数的用法。\n在js代码中获取html标签的属性 比如说，如果想获取 html标签的 innerHTML 属性，做法如下：\n通过原生 js 获取：\n1 document.getElementById(\u0026#39;myh3\u0026#39;).innerHTML 也可以通过 React 提供的 refs 获取：\n1 this.refs.h3.innerHTML 代码举例：\n（3）/components/Counter.jsx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 import React from \u0026#34;react\u0026#34;; // 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验 import ReactTypes from \u0026#34;prop-types\u0026#34;; export default class Counter extends React.Component { constructor(props) { super(props); // 初始化组件，保存的是组件的私有数据 this.state = { msg: \u0026#34;ok\u0026#34;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 }; } // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） }; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = { initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Counter 计数器组件 \u0026lt;/h3\u0026gt; {/* 这里的 this 指向的是 Counter 组件的实例 */} \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;+1\u0026#34; id=\u0026#34;btn\u0026#34; onClick={this.myMethod} /\u0026gt; \u0026lt;h3 id=\u0026#34;myh3\u0026#34; ref=\u0026#34;mymyh3\u0026#34;\u0026gt; 当前的计数是：{this.state.count} \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 } // 点击事件的方法定义 myMethod = () =\u0026gt; { // 修改组件的state里面的值 this.setState({ count: this.state.count + 1 }); }; // 判断组件是否需要更新 shouldComponentUpdate(nextProps, nextState) { // 需求： 如果 state 中的 count 值是偶数，则 更新页面；如果 count 值 是奇数，则不更新页面。最终实现的的页面效果：2，4，6，8，10，12.... // 经过打印测试发现：在 shouldComponentUpdate 中，通过 this.state.count 拿到的值，是上一次的旧数据，并不是当前最新的； // 解决办法：通过 shouldComponentUpdate 函数的第二个参数 nextState，可以拿到 最新的 state 数据。 console.log(this.state.count + \u0026#34; ---- \u0026#34; + nextState.count); // return this.state.count % 2 === 0 ? true : false // return nextState.count % 2 === 0 ? true : false; return true; } // 组件将要更新。此时尚未更新，在进入这个 生命周期函数的时候，内存中的虚拟DOM是旧的，页面上的 DOM 元素 也是旧的 componentWillUpdate() { // 经过打印分析发现：此时页面上的 DOM 节点，都是旧的，应该慎重操作，因为你可能操作的是旧DOM // console.log(document.getElementById(\u0026#39;myh3\u0026#39;).innerHTML) console.log(this.refs.mymyh3.innerHTML); } // 组件完成了更新。此时，state 中的数据、虚拟DOM、页面上的DOM，都是最新的，此时，你可以放心大胆的去操作页面了 componentDidUpdate() { console.log(this.refs.mymyh3.innerHTML); } } 上方代码中，componentWillUpdate() 和 componentDidUpdate() 方法里的代码，就是我们这一段要举的例子。\n需要注意的是，\u0026lt;h3 id=\u0026quot;myh3\u0026quot; ref=\u0026quot;mymyh3\u0026quot;\u0026gt;这部分代码中，属性名只能小写，不能大写。\n工程文件：\n2019-02-12-ReactDemo.zip 生命周期函数：componentWillReceiveProps() 当子组件第一次被渲染到页面上的时候，不会触发这个 函数。\n只有当父组件中，通过 某些 事件，重新修改了 传递给 子组件的 props 数据之后，才会触发 componentWillReceiveProps。\n代码举例：\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:（引入组件）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import MyParent from \u0026#34;./components/TestReceiveProps.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;MyParent\u0026gt;\u0026lt;/MyParent\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); （3）TestReceiveProps.jsx：（组件的定义）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import React from \u0026#34;react\u0026#34;; // 父组件 export default class Parent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是父组件中的 msg 消息\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;这是父组件\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点击修改父组件的 MSG\u0026#34; onClick={this.changeMsg} /\u0026gt; \u0026lt;hr /\u0026gt; {/* 在父组件 Parent 中引用子组件 Son */} \u0026lt;Son pmsg={this.state.msg} /\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg = () =\u0026gt; { this.setState({ msg: \u0026#34;修改组件的msg为新的值\u0026#34; }); }; } // 子组件 class Son extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是子组件 --- {this.props.pmsg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } // 组件将要接收外界传递过来的新的 props 属性值 // 当子组件第一次被渲染到页面上的时候，不会触发这个 函数； // 只有当 父组件中，通过 某些 事件，重新修改了 传递给 子组件的 props 数据之后，才会触发 componentWillReceiveProps componentWillReceiveProps(nextProps) { // console.log(\u0026#39;被触发了！\u0026#39;); // 注意： 在 componentWillReceiveProps 被触发的时候，如果我们使用 this.props 来获取属性值，这个属性值，不是最新的，是上一次的旧属性值 // 如果想要获取最新的属性值，需要通过 componentWillReceiveProps 的参数列表来获取 console.log(this.props.pmsg + \u0026#34; ---- \u0026#34; + nextProps.pmsg); } } 上方代码中，我们在组件 Parent 中引入了子组件 Son。重点注意 componentWillReceiveProps()函数 的注释部分。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/04-react%E7%BB%84%E4%BB%B6%E4%BA%8C%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%87%BD%E6%95%B0/","summary":"defaultProps 和 prop-types 使用 defaultProps 设置组件的默认值 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值。 格式举例： 1 2 3 4 // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属","title":"04-React组件（二）：常见属性和函数"},{"content":"Node.js 的官方API文档 Node.js 的API文档（英文）： https://nodejs.org/docs/latest-v8.x/api/index.html\nNode.js 的API文档（中文）：http://nodejs.cn/api/\n关于 Node.js 的内置模块和常见API，可以看官方文档。\n查阅文档时，稳定指数如下：\n红色：废弃。\n橙色：实验。表示当前版本可用，其他版本不确定。也许不向下兼容，建议不要在生产环境中使用该特性。\n绿色：稳定。与 npm 生态系统的兼容性是最高的优先级。\nNode.js 中模块的分类 Node.js 应用由模块组成，采用 CommonJS 模块规范。Node.js中的模块分为三种：\n内置模块\n第三方模块\n自定义模块\n下面简单介绍一下。\n1、内置模块 1 2 3 4 5 const process = require(\u0026#39;process\u0026#39;); const path = require(\u0026#39;path\u0026#39;); console.log(process.version); console.log(path.resolve(\u0026#39;../\u0026#39;)); require方法用于加载模块。\n常见的内置模块包括：\nFS：文件系统模块\npath：路径模块\nOS：操作系统相关\nnet：网络相关\nhttp\n\u0026hellip;\n你可能会有疑问：Node.js 这么牛吗？还能直接和操作系统做交互？\n带着这个疑问，我们不妨简单看看 Node.js 的源码，以 os 模块举例：\n打开os模块的源码：https://github.com/nodejs/node/blob/master/lib/os.js，翻到最底部，找到 cpus这个方法\n进而找到 getCPUs()\ninternalBinding(\u0026lsquo;os\u0026rsquo;)：通过 internalBinding 可以调用系统底层的方法。internalBinding 主要是 JS 虚拟机在做的事情。\ninternalBinding('os') 的实现，在 https://github.com/nodejs/node/blob/master/src/node_os.cc 里，里面都是 C++ 的代码。比如有一个getCPUs方法。\n现在你知道了，JS本身是没有能力获取底层系统资源的，这一切都是 JS虚拟机在和底层做交互，然后通过 JS 的表现形式，暴露给应用层。\n另外，还有很多库，是直接使用C/++编写的，通过编译之后，再提供给 JS 应用层调用，或者直接提供给 Node.js层使用。\n所有的编程语言底层都会回归C/C++，甚至是汇编语言。\n2、require 加载第三方包的机制 1 const express = require(\u0026#39;express\u0026#39;); require 加载第三方包的机制：\n（1）第三方包安装好后，这个包一般会存放在当前项目的 node_modules 文件夹中。我们找到这个包的 package.json 文件，并且找到里面的main属性对应的入口模块，这个入口模块就是这个包的入口文件。\n（2）如果第三方包中没有找到package.json文件，或者package.json文件中没有main属性，则默认加载第三方包中的index.js文件。\n（3）如果在 node_modules 文件夹中没有找到这个包，或者以上所有情况都没有找到，则会向上一级父级目录下查找node_modules文件夹，查找规则如上一致。\n（4）如果一直找到该模块的磁盘根路径都没有找到，则会报错：can not find module xxx。\n3、自定义模块（module）： 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。\n举例：\n1 2 3 var example = require(\u0026#39;./example.js\u0026#39;); console.log(example.x); // 5 console.log(example.addX(1)); // 6 读取文件 今天这篇文章，重点讲一下 Node 内置模块中的 fs（文件处理模块）。\n在使用文件模块之前，记得先导入：\n1 2 // 导入文件模块 const fs = require(\u0026#39;fs\u0026#39;); fs 的英文全称是 File System。fs 模块提供了很多 api 方法，我们首先应该学习的方法是文件读取。\nNode中文件读取的方式主要有以下几种。\n异步读取文件 fs.readFile() 语法格式：\n1 fs.readFile(file[, options], callback(error, data)) 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 const fs = require(\u0026#39;fs\u0026#39;); fs.readFile(\u0026#39;hello.txt\u0026#39;, \u0026#39;utf8\u0026#39;, (err, data) =\u0026gt; { if (err) { // 失败 console.log(err) } else { // 成功 console.log(\u0026#39;异步读取数据：\u0026#39; + data2) } }); 如果需要嵌套读取多个文件，可以用 promise 或者 async \u0026hellip; await 进行封装。代码举例如下。\npromise 封装 fs.readFile() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const fs = require(\u0026#39;fs\u0026#39;); function fsRead(path) { return new Promise((resolve, reject) =\u0026gt; { fs.readFile(path, { flag: \u0026#39;r\u0026#39;, encoding: \u0026#34;utf-8\u0026#34; }, (err, data) =\u0026gt; { if (err) { //失败执行的内容 reject(err) } else { //成功执行的内容 resolve(data) } }) }) } var promise1 = fsRead(\u0026#39;hello1.txt\u0026#39;) promise1.then(res1 =\u0026gt; { console.log(res1); return fsRead(\u0026#39;hello2.txt\u0026#39;); }).then(res2 =\u0026gt; { console.log(res2); return fsRead(\u0026#39;hello3.txt\u0026#39;); }).then(res3 =\u0026gt; { console.log(res); }) async \u0026hellip; await 封装 fs.readFile() 这个写法更为简洁，推荐。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var fs = require(\u0026#39;fs\u0026#39;); function fsRead(path) { return new Promise((resolve, reject) =\u0026gt; { fs.readFile(path, { flag: \u0026#39;r\u0026#39;, encoding: \u0026#34;utf-8\u0026#34; }, (err, data) =\u0026gt; { if (err) { //失败执行的内容 reject(err) } else { //成功执行的内容 resolve(data) } }) }) } async function ReadList() { var res1 = await fsRead(\u0026#39;hello1.txt\u0026#39;); var res2 = await fsRead(\u0026#39;hello2.txt\u0026#39;); var res3 = await fsRead(\u0026#39;hello3.txt\u0026#39;); } // 执行方法 ReadList(); 同步读取文件 fs.readFileSync() 语法格式：\n1 fs.readFileSync(file[, options]) 代码举例：\n1 2 3 4 5 6 7 8 9 const fs = require(\u0026#39;fs\u0026#39;); try { const data = fs.readFileSync(\u0026#39;hello.txt\u0026#39;, \u0026#39;utf8\u0026#39;); console.log(data); } catch(e) { // 文件不存在，或者权限错误 throw e; } Node.js 中的同步和异步的区别 fs模块对文件的几乎所有操作都有同步和异步两种形式。例如：readFile() 和 readFileSync()。\n区别：\n同步调用会阻塞代码的执行，异步则不会。\n异步调用会将 读取任务 下达到任务队列，直到任务执行完成才会回调。\n异常处理方面：同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数。【重要】\n写入文件 语法格式：\n1 fs.write(fd, string[, position[, encoding]], callback) async \u0026hellip; await 封装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 let fs = require(\u0026#39;fs\u0026#39;) function writeFs(path, content) { return new Promise(function (resolve, reject) { fs.writeFile(path, content, { flag: \u0026#34;a\u0026#34;, encoding: \u0026#34;utf-8\u0026#34; }, function (err) { if (err) { //console.log(\u0026#34;写入内容出错\u0026#34;) reject(err) } else { resolve(err) //console.log(\u0026#34;写入内容成功\u0026#34;) } }) }) } async function writeList() { await writeFs(\u0026#39;1.html\u0026#39;, \u0026#34;\u0026lt;h1\u0026gt;qianguyihao\u0026lt;/h1\u0026gt;\u0026#34;); await writeFs(\u0026#39;2.html\u0026#39;, \u0026#34;\u0026lt;h1\u0026gt;hello world\u0026lt;/h1\u0026gt;\u0026#34;); await writeFs(\u0026#39;3.html\u0026#39;, \u0026#34;\u0026lt;h1\u0026gt;永不止步\u0026lt;/h1\u0026gt;\u0026#34;); } writeList() 删除文件 语法格式：\n1 fs.unlink(path, callback) 参数说明：\npath：文件路径。 callback：回调函数。 代码举例：\n1 2 3 4 fs.unlink(\u0026#39;path/file.txt\u0026#39;, (err) =\u0026gt; { if (err) throw err; console.log(\u0026#39;文件删除成功\u0026#39;); }); 备注：fs.unlink() 不能用于删除目录。 如果要删除目录，可以使用 fs.rmdir()。\nBuffer 通过 Buffer 开辟的内存空间，都是连续的内存空间，所以效率比较高。\n代码举例1：\n1 2 3 4 5 6 7 // 将字符串转成 buffer 对象 const str = \u0026#39;qianguyihao\u0026#39;; let buffer = Buffer.from(str); console.log(buffer); // 输出16进制编码 console.log(buffer.toString()); // 输出字符串：qianguyihao 代码举例2：\n1 2 3 4 5 // 从内存中开辟一个新的缓冲区 let buffer = Buffer.alloc(20); buffer[0] = \u0026#39;a\u0026#39;; console.log(buffer); 读取目录 语法格式：\n1 fs.mkdir(path[, options], callback) 参数说明：\npath：文件路径。\noptions参数可以是：\nrecursive：是否以递归的方式创建目录，默认为 false。 mode：设置目录权限，默认为 0777。 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 var fs = require(\u0026#34;fs\u0026#34;); ​ console.log(\u0026#34;查看 /tmp 目录\u0026#34;); fs.readdir(\u0026#34;/tmp/\u0026#34;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); 其他的还有：（暂略）\n删除目录\n输入输出\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/05-node.js%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97fs%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97/","summary":"Node.js 的官方API文档 Node.js 的API文档（英文）： https://nodejs.org/docs/latest-v8.x/api/index.html Node.js 的API文档（中文）：http://nodejs.cn/api/ 关于 Node.js 的内置模块和常见API，","title":"05-Node.js内置模块：fs文件模块"},{"content":"前言 我们先来看下面这段代码：\ncomponents/MyComponent.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={this.changeMsg} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg() { // 注意：这里的changeMsg()只是一个普通方法。因此，在触发的时候，这里的 this 是 undefined console.log(this); // 打印结果：undefined this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; }); } } 上面的代码中，点击按钮，执行 changeMsg() 方法，尝试修改 this.state.msg 的值。但是，这个方法执行的时候，是会报错的：\n1 Uncaught TypeError: Cannot read property \u0026#39;setState\u0026#39; of null 而且，打印this的结果也是 undefined。这是为啥呢？因为这里的 this 并不是指向 MyComponent 组件本身。\n那如何让 changeMsg() 方法里面的 this，指向MyComponent 组件呢？办法总是有的，比如说，将changeMsg() 修改为箭头函数：\n1 2 3 4 5 6 changeMsg = () =\u0026gt; { console.log(this); // 打印结果：MyComponent 组件 this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; }); }; 那么，除了箭头函数可以 绑定 this，还有没有其他的方式呢？我们接下来讲一讲。\n绑定 this 的方式一：bind() 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; {/* bind 的作用：为前面的函数，修改函数内部的 this 指向。让 函数内部的this，指向 bind 参数列表中的 第一个参数 */} \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={this.changeMsg1.bind(this)} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg1() { this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; }); } } 上方代码中，我们为什么用 bind()，而不是用 call/apply 呢？因为 bind() 并不会立即调用，正是我们需要的。\n注意：bind 中的第一个参数，是用来修改 this 指向的。第一个参数后面的所有参数，都将作为函数的参数传递进去。\n我们来看看通过 bind() 是怎么传参的。\n通过 bind() 绑定this，并给函数传参：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; {/* bind 的作用：为前面的函数，修改函数内部的 this 指向。让 函数内部的this，指向 bind 参数列表中的 第一个参数 */} \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={this.changeMsg1.bind(this, \u0026#34;千古啊\u0026#34;, \u0026#34;壹号啊\u0026#34;)} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg1(arg1, arg2) { this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; + arg1 + arg2 }); } } 绑定 this 并给函数传参 的方式二：构造函数里设置 bind() 我们知道，构造函数中的 this 本身就是指向组件的实例的，所以，我们可以在这里做一些事情。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; // 绑定 this 并给函数传参的方式2: 在构造函数中绑定并传参 // 注意：当一个函数调用 bind 改变了this指向后，bind 函数调用的结果，有一个【返回值】，这个值，就是被改变this指向后的函数的引用。 // 也就是说： bind 不会修改 原函数的 this 指向，而是改变了 “函数拷贝”的this指向。 this.changeMsg2 = this.changeMsg2.bind(this, \u0026#34;千古恩\u0026#34;, \u0026#34;壹号恩\u0026#34;); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={this.changeMsg2} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg2(arg1, arg2) { this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; + arg1 + arg2 }); } } 上方代码中，需要注意的是：当一个函数调用 bind 改变了this指向后，bind 函数调用的结果，有一个【返回值】，这个值，就是被改变this指向后的函数的引用。也就是说： bind 不会修改 原函数的 this 指向，而是改变了 “函数拷贝”的this指向。\n绑定 this 并给函数传参 的方式三：箭头函数【荐】 第三种方式用得最多。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={() =\u0026gt; { this.changeMsg3(\u0026#34;千古3\u0026#34;, \u0026#34;壹号3\u0026#34;); }} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg3 = (arg1, arg2) =\u0026gt; { // console.log(this); // 注意：这里的方式，是一个普通方法，因此，在触发的时候，这里的 this 是 undefined this.setState({ msg: \u0026#34;绑定this并传参的方式3：\u0026#34; + arg1 + arg2 }); }; } ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/05-react%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E7%BB%99%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","summary":"前言 我们先来看下面这段代码： components/MyComponent.jsx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent","title":"05-React中绑定this并给函数传参的几种方式"},{"content":"箭头函数 定义箭头函数的语法 语法：\n1 (参数1, 参数2 ...) =\u0026gt; { 函数体 } 解释：\n如果有且仅有 1 个形参，则()可以省略 如果函数体内有且仅有 1 条语句，则{}可以省略，但前提是，这条语句必须是 return 语句。 需要强调的是，箭头函数是没有函数名的，既然如此，那要怎么调用箭头函数呢？ 你可以将箭头函数赋值给一个变量，通过变量名调用函数；也可以直接使用箭头函数。\n举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 定义和调用函数：（传统写法） function fn1(a, b) { console.log(\u0026#39;haha\u0026#39;); return a + b; } console.log(fn1(1, 2)); //输出结果：3 //定义和调用函数：（ES6 中的写法） const fn2 = (a, b) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + b; }; console.log(fn2(1, 2)); //输出结果：3 在箭头函数中，如果方法体内只有一句话，且这句话是 return 语句，那就可以把 {}省略。写法如下：\n1 2 const fn2 = (a, b) =\u0026gt; a + b; console.log(fn2(1, 2)); //输出结果：3 在箭头函数中，如果形参只有一个参数，则可以把()省略。写法如下：\n1 2 3 4 5 const fn2 = (a) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + 1; }; console.log(fn2(1)); //输出结果：2 箭头函数的 this 的指向 箭头函数不只是为了让函数写起来更简洁优雅，还有一个很大的作用是与 this 的指向有关。\nES6 之前的普通函数中：this 指向的是函数被调用的对象（也就是说，谁调用了函数，this 就指向谁）。\n而 ES6 的箭头函数中：箭头函数本身不绑定 this，this 指向的是箭头函数定义位置的 this（也就是说，箭头函数在哪个位置定义的，this 就跟这个位置的 this 指向相同）。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 const obj = { name: \u0026#39;lvbu\u0026#39; }; function fn1() { console.log(this); // 第一个 this return () =\u0026gt; { console.log(this); // 第二个 this }; } const fn2 = fn1.call(obj); fn2(); 打印结果：\n1 2 obj obj 代码解释：（一定要好好理解下面这句话）\n上面的代码中，箭头函数是在 fn1()函数里面定义的，所以第二个 this 跟 第一个 this 指向的是同一个位置。又因为，在执行 fn1.call(obj)之后，第一个 this 就指向了 obj，所以第二个 this 也是指向 了 obj。\n面试题：箭头函数的 this 指向 代码举例：\n1 2 3 4 5 6 7 8 9 const name = \u0026#39;许嵩\u0026#39;; const obj = { name: \u0026#39;lvbu\u0026#39;, sayHello: () =\u0026gt; { console.log(this.name); }, }; obj.sayHello(); 上方代码的打印结果是什么？你可能很难想到。\n正确答案的打印结果是许嵩。因为 obj 这个对象并不产生作用域， sayHello() 这个箭头函数实际仍然是定义在 window 当中的，所以 这里的 this 指向是 window。\n参数默认值 传统写法：\n1 2 3 4 function fn(param) { let p = param || \u0026#39;hello\u0026#39;; console.log(p); } 上方代码中，函数体内的写法是：如果 param 不存在，就用 hello字符串做兜底。这样写比较啰嗦。\nES6 写法：（参数默认值的写法，很简洁）\n1 2 3 function fn(param = \u0026#39;hello\u0026#39;) { console.log(param); } 在 ES6 中定义方法时，我们可以给方法里的参数加一个默认值（缺省值）：\n方法被调用时，如果没有给参数赋值，那就是用默认值；\n方法被调用时，如果给参数赋值了新的值，那就用新的值。\n如下：\n1 2 3 4 5 6 7 var fn2 = (a, b = 5) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + b; }; console.log(fn2(1)); //第二个参数使用默认值 5。输出结果：6 console.log(fn2(1, 8)); //输出结果：9 提醒 1：默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。\n提醒 2：\n我们来看下面这段代码：\n1 2 3 4 5 let x = \u0026#39;smyh\u0026#39;; function fn(x, y = x) { console.log(x, y); } fn(\u0026#39;vae\u0026#39;); 注意第二行代码，我们给 y 赋值为x，这里的x是括号里的第一个参数，并不是第一行代码里定义的x。打印结果：vae vae。\n如果我把第一个参数改一下，改成：\n1 2 3 4 5 let x = \u0026#39;smyh\u0026#39;; function fn(z, y = x) { console.log(z, y); } fn(\u0026#39;vae\u0026#39;); 此时打印结果是：vae smyh。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/06-es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","summary":"箭头函数 定义箭头函数的语法 语法： 1 (参数1, 参数2 ...) =\u0026gt; { 函数体 } 解释： 如果有且仅有 1 个形参，则()可以省略 如果函数体内有且仅有 1 条语句，则{","title":"06-ES6：箭头函数"},{"content":"path 路径模块 Node.js 通过path这个内置模块，提供了一些路径操作的API，具体可以参考官方的api文档。这里列举一些常用的API。\npath.extname() 获取文件/路径的扩展名 语法格式：\n1 path.extname(myPath); 代码解释：\n获取 myPath 这个文件或者路径的扩展名。\nmyPath 这个参数要求是字符串。如果 myPath 不是字符串，则抛出 TypeError。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const path = require(\u0026#39;path\u0026#39;); path.extname(\u0026#39;hello.txt\u0026#39;); // 返回 \u0026#39;.txt\u0026#39; path.extname(\u0026#39;www.qianguyihao.com\u0026#39;); // 返回 \u0026#39;.com\u0026#39; path.extname(\u0026#39;index.coffee.md\u0026#39;); // 返回 \u0026#39;.md\u0026#39; path.extname(\u0026#39;index.\u0026#39;); // 返回 \u0026#39;.\u0026#39; path.extname(\u0026#39;index\u0026#39;); // 返回 \u0026#39;\u0026#39; path.extname(\u0026#39;.index\u0026#39;); // 返回 \u0026#39;\u0026#39; path.extname(\u0026#39;.index.md\u0026#39;); // 返回 \u0026#39;.md\u0026#39; path.resolve() 生成完成的绝对路径 语法格式：\n1 path.resolve([...myPaths]) 解释：\n将路径或路径片段的序列解析为绝对路径。\n返回的路径是从右往左处理，后面的每个 myPath 被依次解析，直到构造出一个完整的绝对路径。\n代码举例：\n1 2 3 4 5 6 7 8 9 const path = require(\u0026#39;path\u0026#39;); let arr1 = [\u0026#39;/foo1/foo2\u0026#39;, \u0026#39;qianguyihao\u0026#39;, \u0026#39;foo3\u0026#39;]; let result1 = path.resolve(...arr1); console.log(result1); // 打印结果：/foo1/foo2/qianguyihao/foo3 let arr2 = [\u0026#39;/foo1/foo2\u0026#39;, \u0026#39;/qianguyihao\u0026#39;, \u0026#39;foo3\u0026#39;]; let result2 = path.resolve(...arr2); console.log(result2); // 打印结果：/qianguyihao/foo3 几个常见路径 __dirname：这是一个常量，表示：当前执行文件所在完整目录。\n__filename：这是一个常量。表示：当前执行文件的完整目录 + 文件名。\nprocess.cwd：获取当前执行 Node命令 时的目录名。\n代码举例：\n1 2 3 4 5 console.log(__dirname); console.log(__filename); console.log(process.cwd()); 运行结果：\n1 2 3 4 5 $ node app.js /Users/smyhvae/qianguyihao /Users/smyhvae/qianguyihao/app.js /Users/smyhvae/qianguyihao path.join() 将多个路径进行拼接 如果是我们手动拼接路径，容易出错。这个时候，可以利用 path.join() 方法将路径进行拼接。\n语法格式：\n1 path.join([...paths]); 解释：使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 const path = require(\u0026#39;path\u0026#39;); const result1 = path.join(__dirname, \u0026#39;./app.js\u0026#39;); console.log(result1); // 返回：/Users/smyhvae/qianguyihao/app.js const result2 = path.join(\u0026#39;/foo1\u0026#39;, \u0026#39;foo2\u0026#39;, \u0026#39;./foo3\u0026#39;); console.log(result2); // 返回：/foo1/foo2/foo3 const result3 = path.join(\u0026#39;/foo1\u0026#39;, \u0026#39;foo2\u0026#39;, \u0026#39;/foo3\u0026#39;); console.log(result3); // 返回：/foo1/foo2/foo3 OS 系统模块 os.networkInterfaces() 查看网络地址 ","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/06-node.js%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/","summary":"path 路径模块 Node.js 通过path这个内置模块，提供了一些路径操作的API，具体可以参考官方的api文档。这里列举一些常用的API。 path.extname() 获取文件/路径的","title":"06-Node.js内置模块：path路径模块"},{"content":"单项数据绑定 在 Vue 中，可以通过 v-model 指令来实现双向数据绑定。但是，在 React 中并没有指令的概念，而且 React 默认不支持 双向数据绑定。\nReact 只支持，把数据从 state 上传输到 页面，但是，无法自动实现数据从 页面 传输到 state 中 进行保存。\nReact中，只支持单项数据绑定，不支持双向数据绑定。不信的话，我们来看下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;呵呵哒\u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={this.state.msg} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 上方代码中，我们尝试在 input文本框中读取 state.msg 的值，运行结果中，却弹出了警告：\n20190213_2000.png\n1 Warning: Failed prop type: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`. 通过onChange方法，实现双向数据绑定 如果针对 表单元素做 value 属性绑定，那么，必须同时为 表单元素 绑定 readOnly, 或者提供 onChange 事件：\n如果是绑定readOnly，表示这个元素只读，不能被修改。此时，控制台就不会弹出警告了。\n如果是绑定onChange，表示这个元素的值可以被修改，但是，要自己定义修改的逻辑。\n绑定readOnly的举例如下：（表示value中的数据是只读的）\n1 \u0026lt;input type=\u0026#34;text\u0026#34; value={this.state.msg} readOnly /\u0026gt; 绑定 onChange 的举例如下：（通过onChange方法，实现双向数据绑定）\n(1)index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; // 导入组件 import MyComponent from \u0026#34;./components/MyComponent.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;MyComponent\u0026gt;\u0026lt;/MyComponent\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); （3）components/MyComponent.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;呵呵哒\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={this.state.msg} onChange={this.txtChanged} ref=\u0026#34;txt\u0026#34; /\u0026gt; \u0026lt;h3\u0026gt;{\u0026#34;实时显示msg中的内容：\u0026#34; + this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } // 为 文本框 绑定 txtChanged 事件 txtChanged = (e) =\u0026gt; { // 获取 \u0026lt;input\u0026gt; 文本框中 文本的3种方式： // 方式一：使用 document.getElementById // 方式二：使用 ref // console.log(this.refs.txt.value); // 方式三：使用 事件对象的 参数 e 来拿 // 此时，e.target 就表示触发 这个事件的 事件源对象，得到的是一个原生的JS DOM 对象。在这个案例里，e.target就是指文本框 // console.log(e.target.value); this.setState({ msg: e.target.value }); }; } 工程文件：\n2019-02-13-ReactDemo.zip ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/06-react%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","summary":"单项数据绑定 在 Vue 中，可以通过 v-model 指令来实现双向数据绑定。但是，在 React 中并没有指令的概念，而且 React 默认不支持 双向数据绑定。 React 只支持，把数据从 state 上传输","title":"06-React的单向数据绑定"},{"content":"Node.js 连接 MySQL （1）安装 mysql 包：\n1 $ npm install mysql （2）引入 mysql 包：\n1 const mysql = require(\u0026#34;mysql\u0026#34;); （3）建立连接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let mysql = require(\u0026#34;mysql\u0026#34;); let options = { host: \u0026#34;localhost\u0026#34;, //port:\u0026#34;3306\u0026#34;, //可选，默认3306 user: \u0026#34;root\u0026#34;, password: \u0026#39;xxx\u0026#39;, // 这里改成你自己的数据库连接密码 database: \u0026#34;qiangu_database\u0026#34;, }; //创建与数据库进行连接的连接对象 let connection = mysql.createConnection(options); //建立连接 connection.connect((err) =\u0026gt; { if (err) { // 数据库连接成功 console.log(err); } else { // 数据库连接失败 console.log(\u0026#34;数据库连接成功\u0026#34;); } }); 正常来说，运行程序后，应该会提示数据库连接成功。\n如果在运行时提示错误Client does not support authentication protocol requested by server，解决办法如下：(在终端进入 sql 之后，输入如下命令)\n1 2 3 4 5 # 注意，这里的 \u0026#39;root\u0026#39; 请填你的user账号， \u0026#39;localhost\u0026#39; 请填 你的 host， \u0026#39;password\u0026#39; 请填你的密码 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;password\u0026#39;; # 然后执行如下命令 flush privileges; Node.js 增删改查 MySQL 针对下面这张表：\n通过 Node.js可以对其进行一些增删改查操作。代码举例如下。\n1、查询表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 let mysql = require(\u0026#39;mysql\u0026#39;); let options = { host: \u0026#39;localhost\u0026#39;, //port:\u0026#34;3306\u0026#34;,//可选，默认3306 user: \u0026#39;root\u0026#39;, password: \u0026#39;xxx\u0026#39;, // 这里改成你自己的数据库密码 database: \u0026#39;qiangu_database\u0026#39; } //创建与数据库进行连接的连接对象 let connection = mysql.createConnection(options); //建立连接 connection.connect((err) =\u0026gt; { if (err) { // 数据库连接成功 console.log(err) } else { // 数据库连接失败 console.log(\u0026#39;数据库连接成功\u0026#39;) } }); // 1、查询表 let strSql1 = \u0026#39;select * from qiangu_student_table\u0026#39;; connection.query(strSql1, (err, result, fields) =\u0026gt; { if (err) { // 表查询失败 console.log(err); } else { // 表查询成功 console.log(\u0026#39;qiangu_student_table 表查询结果：\u0026#39; + JSON.stringify(result)); console.log(\u0026#39;fields:\u0026#39; + JSON.stringify(fields)); } }) 打印结果如下：\n1 2 3 4 5 6 7 8 qiangu_student_table 表查询结果： [{\u0026#34;id\u0026#34;:1,\u0026#34;name\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;age\u0026#34;:28},{\u0026#34;id\u0026#34;:2,\u0026#34;name\u0026#34;:\u0026#34;许嵩\u0026#34;,\u0026#34;age\u0026#34;:34},{\u0026#34;id\u0026#34;:3,\u0026#34;name\u0026#34;:\u0026#34;邓紫棋\u0026#34;,\u0026#34;age\u0026#34;:28}] fields:[ {\u0026#34;catalog\u0026#34;:\u0026#34;def\u0026#34;,\u0026#34;db\u0026#34;:\u0026#34;qiangu_database\u0026#34;,\u0026#34;table\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;orgTable\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;id\u0026#34;,\u0026#34;orgName\u0026#34;:\u0026#34;id\u0026#34;,\u0026#34;charsetNr\u0026#34;:63,\u0026#34;length\u0026#34;:11,\u0026#34;type\u0026#34;:3,\u0026#34;flags\u0026#34;:0,\u0026#34;decimals\u0026#34;:0,\u0026#34;zeroFill\u0026#34;:false,\u0026#34;protocol41\u0026#34;:true}, {\u0026#34;catalog\u0026#34;:\u0026#34;def\u0026#34;,\u0026#34;db\u0026#34;:\u0026#34;qiangu_database\u0026#34;,\u0026#34;table\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;orgTable\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;orgName\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;charsetNr\u0026#34;:33,\u0026#34;length\u0026#34;:765,\u0026#34;type\u0026#34;:253,\u0026#34;flags\u0026#34;:0,\u0026#34;decimals\u0026#34;:0,\u0026#34;zeroFill\u0026#34;:false,\u0026#34;protocol41\u0026#34;:true}, {\u0026#34;catalog\u0026#34;:\u0026#34;def\u0026#34;,\u0026#34;db\u0026#34;:\u0026#34;qiangu_database\u0026#34;,\u0026#34;table\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;orgTable\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;age\u0026#34;,\u0026#34;orgName\u0026#34;:\u0026#34;age\u0026#34;,\u0026#34;charsetNr\u0026#34;:63,\u0026#34;length\u0026#34;:11,\u0026#34;type\u0026#34;:3,\u0026#34;flags\u0026#34;:0,\u0026#34;decimals\u0026#34;:0,\u0026#34;zeroFill\u0026#34;:false,\u0026#34;protocol41\u0026#34;:true} ] 删除表 1 2 3 4 5 6 7 8 9 10 11 // 2、删除表 let strSql2 = \u0026#39;drop table test2_table\u0026#39;; connection.query(strSql2, (err, result) =\u0026gt; { if (err) { // 表删除失败 console.log(err); } else { // 表删除成功 console.log(\u0026#39;表删除成功：\u0026#39; + result); } }); 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 表删除成功： OkPacket { fieldCount: 0, affectedRows: 0, insertId: 0, serverStatus: 2, warningCount: 0, message: \u0026#39;\u0026#39;, protocol41: true, changedRows: 0 } 删除数据库 将上方的sql语句换一下即可：\n1 let strSql3 = \u0026#39;drop database qiangu_database\u0026#39;; 2、新建数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 let mysql = require(\u0026#39;mysql\u0026#39;); let options = { host: \u0026#39;localhost\u0026#39;, //port:\u0026#34;3306\u0026#34;,//可选，默认3306 user: \u0026#39;root\u0026#39;, password: \u0026#39;smyhvae001\u0026#39;, // database: \u0026#39;qiangu_database\u0026#39; // 注意，因为代码里是创建新的数据库，所以这里不需要填其他的数据库名 } //创建与数据库进行连接的连接对象 let connection = mysql.createConnection(options); //建立连接 connection.connect((err) =\u0026gt; { if (err) { // 数据库连接成功 console.log(err); } else { // 数据库连接失败 console.log(\u0026#39;数据库连接成功\u0026#39;) } }); // 创建新的数据库 const strSql4 = \u0026#39;create database qiangu_database3\u0026#39;; connection.query(strSql4, (err, result) =\u0026gt; { if (err) { console.log(err); } else { console.log(\u0026#39;新建数据库成功：\u0026#39; + JSON.stringify(result)); } }); 打印结果：\n1 2 3 4 数据库连接成功 新建数据库成功：{ \u0026#34;fieldCount\u0026#34;:0,\u0026#34;affectedRows\u0026#34;:1,\u0026#34;insertId\u0026#34;:0,\u0026#34;serverStatus\u0026#34;:2,\u0026#34;warningCount\u0026#34;:0,\u0026#34;message\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;protocol41\u0026#34;:true,\u0026#34;changedRows\u0026#34;:0 } 3、新建表 新建表的sql语句举例：\n1 2 3 4 5 6 CREATE TABLE `qiangu_table5` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `age` int DEFAULT NULL, PRIMARY KEY (`id`) ); 如果是在 js 代码中执行上面这样命令的话，要记得把 sql 语句存放在字符串里的同一行。\n代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 let mysql = require(\u0026#39;mysql\u0026#39;); let options = { host: \u0026#39;localhost\u0026#39;, //port:\u0026#34;3306\u0026#34;,//可选，默认3306 user: \u0026#39;root\u0026#39;, password: \u0026#39;smyhvae001\u0026#39;, database: \u0026#39;qiangu_database\u0026#39; } //创建与数据库进行连接的连接对象 let connection = mysql.createConnection(options); //建立连接 connection.connect((err) =\u0026gt; { if (err) { // 数据库连接成功 console.log(err); } else { // 数据库连接失败 console.log(\u0026#39;数据库连接成功\u0026#39;) } }); // 新建表 // 注意，在 js 代码中，sql 语句要存放在字符串里的同一行。 const strSql5 = \u0026#39;CREATE TABLE `qianguyihao_table5` (`id` int NOT NULL AUTO_INCREMENT,`name` varchar(255) DEFAULT NULL,`age` int DEFAULT NULL,PRIMARY KEY (`id`));\u0026#39;; connection.query(strSql5, (err, result) =\u0026gt; { if (err) { // 新建表失败 console.log(err); } else { // 新建表成功 console.log(\u0026#39;qianguyihao 新建表成功：\u0026#39; + JSON.stringify(result)); } }) 打印结果：\n1 2 3 4 5 数据库连接成功 qianguyihao 新建表成功： { \u0026#34;fieldCount\u0026#34;:0,\u0026#34;affectedRows\u0026#34;:0,\u0026#34;insertId\u0026#34;:0,\u0026#34;serverStatus\u0026#34;:2,\u0026#34;warningCount\u0026#34;:0,\u0026#34;message\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;protocol41\u0026#34;:true,\u0026#34;changedRows\u0026#34;:0 } 在指定的表中插入数据 在指定的表中插入数据：\n1 2 3 4 5 6 7 8 9 10 11 12 // 在指定的表中插入数据 const strSql6 = \u0026#34;insert into qianguyihao_table5 (name, age) values (\u0026#39;lvbu\u0026#39;, \u0026#39;28\u0026#39;)\u0026#34;; connection.query(strSql6, (err, result) =\u0026gt; { if (err) { // 插入数据失败 console.log(err); } else { // 在指定的表中插入数据成功 console.log(\u0026#39;qianguyihao 在指定的表中插入数据成功：\u0026#39; + JSON.stringify(result)); } }); 打印结果：\n1 2 3 4 qianguyihao 在指定的表中插入数据成功： { \u0026#34;fieldCount\u0026#34;:0,\u0026#34;affectedRows\u0026#34;:1,\u0026#34;insertId\u0026#34;:1,\u0026#34;serverStatus\u0026#34;:2,\u0026#34;warningCount\u0026#34;:0,\u0026#34;message\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;protocol41\u0026#34;:true,\u0026#34;changedRows\u0026#34;:0 } 如果插入的数据是变量（比如是用户提交上来的数据），那么，sql 语句可以这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 // 在指定的表中插入数据（数据作为变量） const strSql7 = \u0026#34;insert into qianguyihao_table5 (name, age) values (?, ?)\u0026#34;; connection.query(strSql7, [\u0026#39;许嵩\u0026#39;, \u0026#39;34\u0026#39;], (err, result) =\u0026gt; { if (err) { // 插入数据失败 console.log(err); } else { // 在指定的表中插入数据成功 console.log(\u0026#39;qiangauyihao 在指定的表中插入数据成功：\u0026#39; + JSON.stringify(result)); } }); ","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/07-node.js%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"Node.js 连接 MySQL （1）安装 mysql 包： 1 $ npm install mysql （2）引入 mysql 包： 1 const mysql = require(\u0026#34;mysql\u0026#34;); （3）建立连接： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let mysql = require(\u0026#34;mysql\u0026#34;); let options = { host: \u0026#34;localhost\u0026#34;, //port:\u0026#34;3306\u0026#34;,","title":"07-Node.js操作MySQL数据库"},{"content":"React路由的使用 使用React路由之前，我们需要先安装 react-router-dom这个包。比如：\n1 yarn add react-router-dom 代码举例：\n（1）index.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js：\n1 2 3 4 5 6 7 8 9 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;)); （3）app.jsx:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import React from \u0026#34;react\u0026#34;; // 如果要使用 路由模块，第一步，运行 yarn add react-router-dom // 第二步，导入 路由模块 // HashRouter 表示一个路由的跟容器，将来，所有的路由相关的东西，都要包裹在 HashRouter 里面，而且，一个网站中，只需要使用一次 HashRouter 就好了； // Route 表示一个路由规则， 在 Route 上，有两个比较重要的属性， path component // Link 表示一个路由的链接 ，就好比 vue 中的 \u0026lt;router-link to=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; import { HashRouter, Route, Link } from \u0026#34;react-router-dom\u0026#34;; import Home from \u0026#34;./components/Home.jsx\u0026#34;; import Movie from \u0026#34;./components/Movie.jsx\u0026#34;; import About from \u0026#34;./components/About.jsx\u0026#34;; export default class App extends React.Component { constructor(props) { super(props); this.state = {}; } render() { // 当 使用 HashRouter 把 App 根组件的元素包裹起来之后，网站就已经启用路由了 // 在一个 HashRouter 中，只能有唯一的一个根元素 // 在一个网站中，只需要使用 唯一的一次 \u0026lt;HashRouter\u0026gt;\u0026lt;/HashRouter\u0026gt; 即可 return ( \u0026lt;HashRouter\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;这是网站的APP根组件\u0026lt;/h1\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;Link to=\u0026#34;/home\u0026#34;\u0026gt;首页\u0026lt;/Link\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;Link to=\u0026#34;/movie\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;Link to=\u0026#34;/about\u0026#34;\u0026gt;关于\u0026lt;/Link\u0026gt; \u0026lt;hr /\u0026gt; {/* Route 创建的标签，就是路由规则，其中 path 表示要匹配的路由，component 表示要展示的组件 */} {/* 在 vue 中有个 router-view 的路由标签，专门用来放置，匹配到的路由组件的，但是，在 react-router 中，并没有类似于这样的标签，而是 ，直接把 Route 标签，当作的 坑（占位符） */} {/* Route 具有两种身份：1. 它是一个路由匹配规则； 2. 它是 一个占位符，表示将来匹配到的组件都放到这个位置 */} \u0026lt;Route path=\u0026#34;/home\u0026#34; component={Home} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;Route path=\u0026#34;/movie\u0026#34; component={Movie} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;Route path=\u0026#34;/about\u0026#34; component={About} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/HashRouter\u0026gt; ); } } （4）ReactDemo/src/components/Home.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#34;react\u0026#34;; export default class Home extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return \u0026lt;div\u0026gt;Home组件\u0026lt;/div\u0026gt;; } } （5）ReactDemo/src/components/Movie.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 13 import React from \u0026#34;react\u0026#34;; export default class Movie extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return \u0026lt;div\u0026gt;Movie组件\u0026lt;/div\u0026gt;; } } （6）ReactDemo/src/components/About.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#34;react\u0026#34;; export default class About extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return \u0026lt;div\u0026gt;About组件\u0026lt;/div\u0026gt;; } } 运行结果：\n20190214_1000.png\n匹配路由参数 模糊匹配与精准匹配 我们在上面的代码中，进一步修改。假设 Movie 这个组件修改成这种路由匹配方式：\n1 2 3 \u0026lt;Link to=\u0026#34;/movie/top250\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt; \u0026lt;Route path=\u0026#34;/movie\u0026#34; component={Movie} /\u0026gt; 上面这种匹配方式，也是可以成功匹配到的。这是为啥呢？\n这是因为：默认情况下，路由中的匹配规则，是模糊匹配的。如果 路由可以部分匹配成功，就会展示这个路由对应的组件。\n如果想让路由规则，进行精确匹配，可以为Route添加 exact 属性。比如下面这种写法，因为是开启了精准匹配，所以是匹配不到的：（无法匹配）\n1 2 3 \u0026lt;Link to=\u0026#34;/movie/top250/20\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt; \u0026lt;Route path=\u0026#34;/movie/\u0026#34; component={Movie} exact/\u0026gt; 另外，如果要匹配参数，可以在匹配规则中，使用 : 修饰符，表示这个位置匹配到的是参数。举例如下：（匹配正常）\n1 2 3 \u0026lt;Link to=\u0026#34;/movie/top250/20\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;Route path=\u0026#34;/movie/:type/:id\u0026#34; component={Movie} exact/\u0026gt; 获取路由参数 继续修改上面的代码。如果我想在 Movie 组件中显示路由中的参数，怎么做呢？\n我们可以通过 props.match.params获取路由中的参数。举例做法如下：\napp.jsx中的匹配规则如下：\n1 2 3 \u0026lt;Link to=\u0026#34;/movie/top100/5\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;Route path=\u0026#34;/movie/:type/:id\u0026#34; component={Movie} exact/\u0026gt; Moivie 组件的写法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React from \u0026#34;react\u0026#34;; export default class Movie extends React.Component { constructor(props) { super(props); this.state = { routeParams: props.match.params // 把路由中的参数保存到 state 中 }; } render() { console.log(this); // 如果想要从路由规则中，提取匹配到的参数，进行使用，可以使用 this.props.match.params.*** 来访问 return ( \u0026lt;div\u0026gt; {/* Movie --- {this.props.match.params.type} --- {this.props.match.params.id} */} Movie --- {this.state.routeParams.type} --- {this.state.routeParams.id} \u0026lt;/div\u0026gt; ); } } 打印结果如下：\n20190214_1030.png\n工程文件：\n2019-02-14-ReactDemo.zip\n参考链接 ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/07-react%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"React路由的使用 使用React路由之前，我们需要先安装 react-router-dom这个包。比如： 1 yarn add react-router-dom 代码举例： （1）index.","title":"07-React路由的使用"},{"content":"前言 变量的数据类型转换：将一种数据类型转换为另外一种数据类型。\n通常有三种形式的类型转换：\n转换为字符串类型\n转换为数字型\n转换为布尔型\n你会专门把某个数据类型转换成 null 或者 undefined 吗？不会，因为这样做，没有意义。\ntypeof 运算符 我们先来讲一下 typeof，再讲类型转换。\ntypeof()表示“获取变量的数据类型”，返回的是小写，语法为：（两种写法都可以）\n1 2 3 4 5 // 写法1 typeof 变量; // 写法2 typeof(变量); typeof 这个运算符的返回结果就是变量的类型。那返回结果的类型是什么呢？是字符串。\n返回结果：\ntypeof 的代码写法 返回结果 typeof 数字 number typeof 字符串 string typeof 布尔型 boolean typeof 对象 object typeof 方法 function typeof null object typeof undefined undefined 备注 1：为啥 typeof null的返回值也是 object 呢？因为 null 代表的是空对象。\n备注 2：typeof NaN的返回值是 number，上一篇文章中讲过，NaN 是一个特殊的数字。\n返回结果举例：\n1 2 3 console.log(typeof []); // 空数组的打印结果：object console.log(typeof {}); // 空对象的打印结果：object 代码解释：这里的空数组[]、空对象{} ，为啥他们在使用 typeof 时，返回值也是 object呢？因为这里的 返回结果object指的是引用数据类型。空数组、空对象都是引用数据类型 Object。\ntypeof 无法区分数组，但 instanceof 可以。比如：\n1 2 3 console.log([] instanceof Array); // 打印结果：true console.log({} instanceof Array); // 打印结果：false 关于 instanceof 的详细内容，以后讲对象的时候，会详细介绍。\n变量的类型转换的分类 类型转换分为两种：显示类型转换、隐式类型转换。\n显示类型转换 toString()\nString()\nNumber()\nparseInt(string)\nparseFloat(string)\nBoolean()\n隐式类型转换 isNaN ()\n自增/自减运算符：++、—-\n正号/负号：+a、-a\n加号：+\n运算符：-、*、/\n隐式类型转换（特殊） 逻辑运算符：\u0026amp;\u0026amp;、||、！ 。非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，但运算结果是原值。具体可以看下一篇文章《运算符》。\n关系运算符：\u0026lt;、\u0026gt; \u0026lt;= \u0026gt;=等。关系运算符，得到的运算结果都是布尔值：要么是true，要么是false。具体可以看下一篇文章《运算符》。\n针对上面这两种类型转换，这篇文章来详细介绍。\n其他的简单类型 \u0026ndash;\u0026gt; String 方法一（隐式类型转换）：字符串拼接 格式：变量+\u0026quot;\u0026quot; 或者 变量+\u0026ldquo;abc\u0026rdquo;\n举例：\n1 2 3 var a = 123; // Number 类型 console.log(a + \u0026#39;\u0026#39;); // 转换成 String 类型 console.log(a + \u0026#39;haha\u0026#39;); // 转换成 String 类型 上面的例子中，打印的结果，都是字符串类型的数据。实际上内部是调用的 String() 函数。也就是说，c = c + \u0026quot;\u0026quot; 等价于 c = String(c)。\n方法二：调用 toString()方法 语法：\n1 变量.toString() 【重要】该方法不会影响到原变量，它会将转换的结果返回。当然我们还可以直接写成a = a.toString()，这样的话，就是直接修改原变量。\n注意：null 和 undefined 这两个值没有 toString()方法，所以它们不能用方法二。如果调用，会报错。\n另外，Number 类型的变量，在调用 toString()时，可以在方法中传递一个整数作为参数。此时它将会把数字转换为指定的进制，如果不指定则默认转换为 10 进制。例如：\n1 2 3 4 5 6 7 8 var a = 255; //对于Number调用toString()时可以在方法中传递一个整数作为参数 //此时它将会把数字转换为指定的进制,如果不指定则默认转换为10进制 a = a.toString(2); // 转换为二进制 console.log(a); // 11111111 console.log(typeof a); // string 方法三（强制转换）：使用 String()函数 语法：\n1 String(变量) 使用 String()函数做强制类型转换时：\n对于 Number 和 Boolean 而言，本质上就是调用 toString()方法。\n但是对于 null 和 undefined，则不会调用 toString()方法。它会将 null 直接转换为 \u0026ldquo;null\u0026rdquo;。将 undefined 直接转换为 \u0026ldquo;undefined\u0026rdquo;。\nprompt()：用户的输入 我们在 JS 基础的第 01 篇里，就讲过，prompt()就是专门用来弹出能够让用户输入的对话框。重要的是：用户不管输入什么，都当字符串处理。\n其他的数据类型 \u0026ndash;\u0026gt; Number 【重要】 使用 Number() 函数 情况一：字符串 \u0026ndash;\u0026gt; 数字\n1.如果字符串中是纯数字，则直接将其转换为数字。\n2.如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0。\n3.只要字符串中包含了其他非数字的内容（小数点按数字来算），则转换为 NaN。\n情况二：布尔 \u0026ndash;\u0026gt; 数字\ntrue 转成 1\nfalse 转成 0\n情况三：null \u0026ndash;\u0026gt; 数字\n结果为：0 情况四：undefined \u0026ndash;\u0026gt; 数字\n结果为：NaN 补充：怎么理解这里的 NaN 呢？可以这样理解，使用 Number() 函数之后，如果无法转换为数字，就会转换为 NaN。\n使用 parseInt()函数：字符串 -\u0026gt; 整数 parseInt()的作用是将字符串中的有效的整数内容转为数字。parse 表示“转换”，Int 表示“整数”（注意Int的拼写）。例如：\n1 parseInt(\u0026#34;5\u0026#34;); 得到的结果是数字 5。\nparseInt()的转换情况如下。\n情况一：字符串 \u0026ndash;\u0026gt; 数字\n1.只保留字符串最开头的数字，后面的中文自动消失。\n2.如果字符串不是以数字开头，则转换为 NaN。\n3.如果字符串是一个空串或者是一个全是空格的字符串，转换时会报错。\n情况二：Boolean \u0026ndash;\u0026gt; 数字\n结果为：NaN 情况三：Null \u0026ndash;\u0026gt; 数字\n结果为：NaN 情况四：Undefined \u0026ndash;\u0026gt; 数字\n结果为：NaN Number() 函数和 parseInt() 函数的区别：\n就拿Number(true) 和 parseInt(true)/parseFloat(true)来举例，二者在使用时，是有区别的：\nNumber(true) ：千方百计地想转换为数字。\nparseInt(true)/parseFloat(true) ：先转为字符串，再提取出最前面的数字部分；没提取出来，那就返回 NaN。\nparseInt()具有以下特性：\n（1）只保留字符串最开头的数字，后面的中文自动消失。例如：\n1 2 3 4 5 console.log(parseInt(\u0026#34;2017在公众号上写了6篇文章\u0026#34;)); //打印结果：2017 console.log(parseInt(\u0026#34;2017.01在公众号上写了6篇文章\u0026#34;)); //打印结果仍是：2017 （说明只会取整数） console.log(parseInt(\u0026#34;aaa2017.01在公众号上写了6篇文章\u0026#34;)); //打印结果：NaN （因为不是以数字开头） （2）如果对非 String使用 parseInt()或 parseFloat()，它会先将其转换为 String 然后再操作。【重要】\n比如：\n1 2 3 4 5 6 7 8 9 10 11 var a = 168.23; console.log(parseInt(a)); //打印结果：168 （因为是先将 a 转为字符串\u0026#34;168.23\u0026#34;，然后然后再操作） var b = true; console.log(parseInt(b)); //打印结果：NaN （因为是先将 b 转为字符串\u0026#34;true\u0026#34;，然后然后再操作） var c = null; console.log(parseInt(c)); //打印结果：NaN （因为是先将 c 转为字符串\u0026#34;null\u0026#34;，然后然后再操作） var d = undefined; console.log(parseInt(d)); //打印结果：NaN （因为是先将 d 转为字符串\u0026#34;undefined\u0026#34;，然后然后再操作） （3）自动带有截断小数的功能：取整，不四舍五入。\n例 1：\n1 2 var a = parseInt(5.8) + parseInt(4.7); console.log(a); 打印结果：\n1 9 例 2：\n1 2 var a = parseInt(5.8 + 4.7); console.log(a); 打印结果：\n1 10; （4）带两个参数时，表示在转换时，包含了进制转换。\n代码举例：\n1 2 3 4 5 var a = \u0026#39;110\u0026#39;; var num = parseInt(a, 16); // 【重要】将 a 当成 十六进制 来看待，转换成 十进制 的 num console.log(num); 打印结果：\n1 272 如果你对打印结果感到震惊，请仔细看上面的代码注释。就是说，无论 parseInt() 里面的进制参数是多少，最终的转换结果是十进制。\n我们继续来看下面的代码，打印结果是多少。\n1 2 3 4 5 var a = \u0026#39;5\u0026#39;; var num = parseInt(a, 2); // 将 a 当成 二进制 来看待，转换成 十进制 的 num console.log(num); // 打印结果：NaN。因为 二进制中没有 5 这个数，转换失败。 parseFloat()函数：字符串 \u0026ndash;\u0026gt; 浮点数（小数） parseFloat()的作用是：将字符串转换为浮点数。\nparseFloat()和 parseInt()的作用类似，不同的是，parseFloat()可以获得有效的小数部分。\n代码举例：\n1 2 var a = \u0026#39;123.456.789px\u0026#39;; console.log(parseFloat(a)); // 打印结果：123.456 parseFloat() 的几个特性，可以参照 parseInt()。\n转换为 Boolean 其他的数据类型都可以转换为 Boolean类型。情况如下：\n情况一：数字 \u0026ndash;\u0026gt; 布尔。除了 0 和 NaN，其余的都是 true。也就是说，Boolean(NaN)的结果是 false。\n情况二：字符串 \u0026mdash;\u0026gt; 布尔。除了空串，其余的都是 true。全是空格的字符串，转换结果也是 true。字符串'0'的转换结果也是 true。\n情况三：null 和 undefined 都会转换为 false。\n情况四：引用数据类型会转换为 true。注意，空数组[]和空对象{}，转换结果也是 true，这一点，很多人都不知道。\n1、隐式转换为 Boolean 类型：\n当非 Boolean 类型的数值和 Boolean类型的数值做比较时，会先把前者进行隐式转换为 Boolean类型，然后再做比较；且不会改变前者的数据类型。举例如下：\n1 2 3 4 5 6 const a = 1; console.log(a == true); // 打印结果：true console.log(typeof a); // 打印结果：number。可见，上面一行代码里，a 做了隐式类型转换，但是 a 的数据类型并没有发生变化，仍然是 Number 类型 console.log(0 == true); // 打印结果：false 2、显式转换为 Boolean 类型：\n方法1：使用 !!可以显式转换为 Boolean 类型。比如 !!3的结果是true。\n方法2：使用 Boolean()函数可以显式转换为 Boolean 类型。\n总结：\n转换为 Boolean 的这几种情况，很重要，开发中会经常用到。比如说，我们在项目开发中，经常需要对一些非布尔值做逻辑判断，符合条件后，才做进一步的事情。下面来看个例子。\n举例：（接口返回的内容不为空，前端才做进一步的事情）\n1 2 3 4 5 6 7 8 9 10 11 const result1 = \u0026#39;\u0026#39;; const result2 = {a:\u0026#39;data1\u0026#39;, b: \u0026#39;data2\u0026#39;}; if (result1) { console.log(\u0026#39;因为 result1的内容为空，所以代码进不了这里\u0026#39;); } if (result2 \u0026amp;\u0026amp; result2.a) { // 接口返回了 result2，且 result2.a 里面有值，前端才做进一步的事情 console.log(\u0026#39;代码能进来，前端继续在这里干活儿\u0026#39;); } 这里再次强调一下，空数组[]和空对象{}转换为 Boolean 值时，转换结果为 true。\n知识补充：其他进制的数字 16 进制的数字，以0x开头\n8 进制的数字，以0开头\n2 进制的数字，0b开头（不是所有的浏览器都支持：chrome 和火狐支持，IE 不支持）\n比如070这个字符串，如果我调用 parseInt()转成数字时，有些浏览器会当成 8 进制解析，有些会当成 10 进制解析。\n所以，比较建议的做法是：可以在 parseInt()中传递第二个参数，来指定当前数字的进制。例如：\n1 2 3 4 var a = \u0026#34;070\u0026#34;; a = parseInt(a, 8); //将 070 当成八进制来看待，转换结果为十进制。 console.log(a); // 打印结果：56。这个地方要好好理解。 隐式类型转换 重点：隐式类型转换，内部调用的都是显式类型的方法。下面来详细介绍。\nisNaN() 函数 语法：\n1 isNaN(参数); 解释：判断指定的参数是否为 NaN（非数字类型），返回结果为 Boolean 类型。也就是说：任何不能被转换为数值的参数，都会让这个函数返回 true。\n执行过程：\n（1）先调用Number(参数)函数；\n（2）然后将Number(参数)的返回结果和NaN进行比较。\n代码举例：\n1 2 3 4 5 6 7 8 9 console.log(isNaN(\u0026#39;123\u0026#39;)); // 返回结果：false。 console.log(isNaN(\u0026#39;abc\u0026#39;)); // 返回结果：true。因为 Number(\u0026#39;abc\u0026#39;) 的返回结果是 NaN console.log(isNaN(null)); // 返回结果：false console.log(isNaN(undefined)); // 返回结果：true console.log(isNaN(NaN)); // 返回结果：true 自增/自减运算符：++、—- 举例 1：\n1 2 3 4 5 var a = \u0026#34;666\u0026#34;; a++; console.log(typeof a); // 打印结果： number console.log(a); // 打印结果：667 执行过程：\n（1）先调用Number(参数)函数；\n（2）然后将Number(参数)的返回结果进行 加 1 操作。\n举例 2：\n1 2 3 4 var a = \u0026#39;abc\u0026#39;; a++; console.log(typeof a); // 打印结果：number console.log(a); // 打印结果：NaN。因为 Number(\u0026#39;abc\u0026#39;)的结果为 NaN，再自增后，结果依然是 NaN 正号/负号：+a、-a 注意，这里说的是正号/负号，不是加号/减号。\n任何值做+a、-a、/a运算时，运算结果都会自动转换为 Number 类型。 内部调用的是 Number() 函数。\n举例：\n1 2 3 4 5 6 7 8 var a = \u0026#39;666\u0026#39;; var b = +a; console.log(typeof a); // 打印结果：string。说明 a 的数据类型保持不变。 console.log(a); // 打印结果：666 console.log(typeof b); // 打印结果：number。说明 b 的数据类型发生了变化。 console.log(b); // 打印结果：666 加号：+ 情况一：字符串 + 数字\n当加号的两边，只要有一个是字符串的时候，就会调用 String() 函数将数字转为字符串，然后再计算。导致最终的运算结果是字符串。 情况二：Boolean + 数字\nBoolean 型和数字型相加时， true 按 1 来算 ，false 按 0 来算。这里其实是先调 Number() 函数，将 Boolean 类型转换为 Number类型，然后再和 数字相加。 情况三： null + 数字\n等价于：0 + 数字 情况四： undefined + 数字\n计算结果：NaN 运算符：-、*、/ 1、任何非 Number 类型的值做-、*、/运算时，会将这些值转换为Number然后再运算(内部调用的是 Number() 函数），运算结果是 Number 类型。（注：任何值 + 字符串是特例，运算结果是字符串）\n比如：\n1 2 3 4 5 6 7 result1 = true + 1; // 2 = 1+ 1 result2 = true + false; // 1 = 1+ 0 result3 = 1 + null; // 1 = 1+ 0 result4 = 100 - \u0026#39;1\u0026#39; // 99 2、任何的值和字符串做加法运算，都会先转换为字符串，然后再做拼串操作。\n比如：\n1 2 3 result1 = 1 + 2 + \u0026#39;3\u0026#39; // 33 result2 = \u0026#39;1\u0026#39; + 2 + 3; // 123 3、任何值和NaN做运算的结果都是NaN。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/07-typeof%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","summary":"前言 变量的数据类型转换：将一种数据类型转换为另外一种数据类型。 通常有三种形式的类型转换： 转换为字符串类型 转换为数字型 转换为布尔型 你会专门把某","title":"07-typeof和数据类型转换"},{"content":"剩余参数 剩余参数允许我们将不确定数量的剩余的元素放到一个数组中。\n比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。\n传统写法：\nES5 中，在定义方法时，参数要确定个数，如下：（程序会报错）\n1 2 3 4 5 6 7 8 function fn(a, b, c) { console.log(a); console.log(b); console.log(c); console.log(d); } fn(1, 2, 3); 上方代码中，因为方法的参数是三个，但使用时是用到了四个参数，所以会报错：\nES6 写法：\nES6 中，我们有了剩余参数，就不用担心报错的问题了。代码可以这样写：\n1 2 3 4 5 6 7 8 9 10 const fn = (...args) =\u0026gt; { //当不确定方法的参数时，可以使用剩余参数 console.log(args[0]); console.log(args[1]); console.log(args[2]); console.log(args[3]); }; fn(1, 2); fn(1, 2, 3); //方法的定义中了四个参数，但调用函数时只使用了三个参数，ES6 中并不会报错。 打印结果：\n1 2 3 4 5 6 7 8 9 10 1 2 undefined undefined 1 2 3 undefined 上方代码中注意，args 参数之后，不能再加别的参数，否则编译报错。\n下面这段代码，也是利用到了剩余参数：\n1 2 3 4 5 6 function fn1(first, ...args) { console.log(first); // 10 console.log(args); // 数组：[20, 30] } fn1(10, 20, 30); 剩余参数的举例：参数求和 代码举例：\n1 2 3 4 5 6 const sum = (...args) =\u0026gt; { let total = 0; args.forEach(item =\u0026gt; total += item); // 注意 forEach里面的代码，写得 很精简 return total; }; console.log(sum(10, 20, 30)); 打印结果：60\n剩余参数和解构赋值配合使用 代码举例：\n1 2 3 4 5 const students = [\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;]; let [s1, ...s2] = students; console.log(s1); // \u0026#39;张三\u0026#39; console.log(s2); // [\u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;] 扩展运算符（展开语法） 扩展运算符和剩余参数是相反的。\n剩余参数是将剩余的元素放到一个数组中；而扩展运算符是将数组或者对象拆分成逗号分隔的参数序列。\n代码举例：\n1 2 3 4 5 const arr = [10, 20, 30]; ...arr // 10, 20, 30 注意，这一行是伪代码，这里用到了扩展运算符 console.log(...arr); // 10 20 30 console.log(10, 20, 30); // 10 20 30 上面的代码要仔细看：\narr是一个数组，而...arr则表示10, 20, 30这样的序列。\n我们把...arr 打印出来，发现打印结果竟然是 10 20 30，为啥逗号不见了呢？因为逗号被当作了 console.log 的参数分隔符。如果你不信，可以直接打印 console.log(10, 20, 30) 看看。\n接下来，我们看一下扩展运算符的应用。\n举例1：数组赋值 数组赋值的代码举例：\n1 let arr2 = [...arr1]; // 将 arr1 赋值给 arr2 为了理解上面这行代码，我们先来分析一段代码：（将数组 arr1 赋值给 arr2）\n1 2 3 4 5 6 7 8 9 let arr1 = [\u0026#39;www\u0026#39;, \u0026#39;smyhvae\u0026#39;, \u0026#39;com\u0026#39;]; let arr2 = arr1; // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); console.log(\u0026#39;---------------------\u0026#39;); arr2.push(\u0026#39;你懂得\u0026#39;); //往 arr2 里添加一部分内容 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); 运行结果：\n上方代码中，我们往往 arr2 里添加了你懂的，却发现，arr1 里也有这个内容。原因是：let arr2 = arr1;其实是让 arr2 指向 arr1 的地址。也就是说，二者指向的是同一个内存地址。\n如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做：\n1 2 3 4 5 6 7 8 9 let arr1 = [\u0026#39;www\u0026#39;, \u0026#39;smyhvae\u0026#39;, \u0026#39;com\u0026#39;]; let arr2 = [...arr1]; //【重要代码】arr2 会重新开辟内存地址 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); console.log(\u0026#39;---------------------\u0026#39;); arr2.push(\u0026#39;你懂得\u0026#39;); //往arr2 里添加一部分内容 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); 运行结果：\n1 2 3 4 5 arr1:www,smyhvae,com arr2:www,smyhvae,com --------------------- arr1:www,smyhvae,com arr2:www,smyhvae,com,你懂得 我们明白了这个例子，就可以避免开发中的很多业务逻辑上的 bug。\n举例2：合并数组 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 let arr1 = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; let arr2 = [\u0026#39;王四\u0026#39;, \u0026#39;王五\u0026#39;, \u0026#39;王六\u0026#39;]; // ...arr1 // \u0026#39;王一\u0026#39;,\u0026#39;王二\u0026#39;,\u0026#39;王三\u0026#39; // ...arr2 // \u0026#39;王四\u0026#39;,\u0026#39;王五\u0026#39;,\u0026#39;王六\u0026#39; // 方法1 let arr3 = [...arr1, ...arr2]; console.log(arr3); // [\u0026#34;王一\u0026#34;, \u0026#34;王二\u0026#34;, \u0026#34;王三\u0026#34;, \u0026#34;王四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;王六\u0026#34;] // 方法2 arr1.push(...arr2); console.log(arr1); // [\u0026#34;王一\u0026#34;, \u0026#34;王二\u0026#34;, \u0026#34;王三\u0026#34;, \u0026#34;王四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;王六\u0026#34;] 举例3：将伪数组或者可遍历对象转换为真正的数组 代码举例：\n1 2 const myDivs = document.getElementsByClassName(\u0026#39;div\u0026#39;); const divArr = [...myDivs]; // 利用扩展运算符，将伪数组转为真正的数组 补充：\n我们在《JavaScript基础/数组的常见方法》中也学过，还有一种方式，可以将伪数组（或者可遍历对象）转换为真正的数组。语法格式如下：\n1 let arr2 = Array.from(arrayLike); ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/07-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E5%92%8C%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"剩余参数 剩余参数允许我们将不确定数量的剩余的元素放到一个数组中。 比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。","title":"07-剩余参数和扩展运算符"},{"content":"andt 的介绍 Ant Design 是基于 React 实现，开发和服务于企业级后台产品。\n支持环境 现代浏览器和 IE9 及以上（需要 polyfills）。\n支持服务端渲染。\nElectron\nElectron（原名为Atom Shell）是GitHub开发的一个开源框架。 它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。\n很多客户端软件都是基于 Electron 开发的。比如 VS Code。我们打开 VS Code 菜单栏的 “帮助 \u0026ndash;\u0026gt; 切换开发人员工具”，就会看到类似于 chrome的调试工具。\n相关链接 官方文档：https://ant.design/docs/react/introduce-cn andt 的使用 环境安装 1 npm install antd --save 代码示例 我们需要什么组件，就导入该组件即可。\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:\n1 2 3 4 5 6 7 8 9 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import MyComponent from \u0026#34;./components/MyComponent.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render(\u0026lt;MyComponent\u0026gt;\u0026lt;/MyComponent\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;)); (3)MyComponent.jsx:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React from \u0026#34;react\u0026#34;; // 导入 日期选择组件 import { DatePicker } from \u0026#34;antd\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;在组件中引入 andt\u0026lt;/h3\u0026gt; \u0026lt;DatePicker /\u0026gt; \u0026lt;/div\u0026gt; ); } } 代码运行效果：\n20190217_1500.png\nAntD组件 表格 pagination属性可以用来分页。\nloading框 需求：在数据显示之前，展示 loading；在数据显示之后，关闭loading。\n相关问题的链接 AntD pro，跳转到详情页，携带参数 ant design列表页，转跳到详情页，携带参数\nant design pro商品页带参数转到详情页\nAntD pro ，必填项前面，显示星号 表单必填项label上的红色*号是怎么出现的 其他问题 面包屑层级显示问题：https://github.com/ant-design/ant-design-pro/issues/1584\nfrom验证input框只能输入数字：https://blog.csdn.net/zr15829039341/article/details/82745239\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/08-ant-design%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"andt 的介绍 Ant Design 是基于 React 实现，开发和服务于企业级后台产品。 支持环境 现代浏览器和 IE9 及以上（需要 polyfills）。 支持服务端渲染。 Electron Electr","title":"08-Ant Design的基本使用"},{"content":"state / mutations / getters / actions =\u0026gt; 公共数据库 / 直接改变数据方法 / state的计算属性 / 异步( 调用mutations方法 )间接改变数据\n1、store.js文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 let store = new Vuex.Store({ state: { tableHeight:0, tableSHeight:0, tableTHeight:0, }, getters: { getCommonHeight: (state) =\u0026gt; (typeKey) =\u0026gt; { return state.tableHeight + \u0026#34;px\u0026#34; }, }, mutations: { changeTableHeight(state,payload){ state.tableHeight = payload.height; state.tableSHeight = payload.secondH; state.tableTHeight = payload.thirdH; } }, actions: { changeTableHeightSetTime(ctx){ setTimeout(()=\u0026gt;{ ctx.commit(\u0026#39;changeTableHeight\u0026#39;, {height:100,secondH:200,thirdH:300}); },2000) }, } }) export default store 2、实际应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 this.$store.state.tableHeight; this.$store.commit(\u0026#39;changeTableHeight\u0026#39;, { height:460, secondH:390, thirdH:490 }) this.$store.dispatch(\u0026#39;changeTableHeightSetTime\u0026#39;); this.$store.getters.getCommonHeight; // 从vuex中按需导入mapState\\mapMutations\\mapActions\\mapGetters函数 import { mapState,mapMutations,mapActions,mapGetters } from \u0026#39;vuex\u0026#39; // 通过刚才导入的函数,将当前组件需要的全局数据,映射为当前组件的computed计算属性 computed: { ...mapState({\u0026#39;tableHeight\u0026#39;}) ...mapMutations([\u0026#39;changeTableHeight\u0026#39;]) //this.changeTableHeight() ...mapActions([\u0026#39;changeTableHeightSetTime\u0026#39;]) //this.changeTableHeightSetTime() ...mapGetters([\u0026#39;getCommonHeight\u0026#39;]) } ","permalink":"https://bablvsj.github.io/posts/tech/wait/11-vue%E5%9F%BA%E7%A1%80/08-vuex/","summary":"state / mutations / getters / actions =\u0026gt; 公共数据库 / 直接改变数据方法 / state的计算属性 / 异步( 调用mutations方法 )间接改变数据 1、store.js文件 1","title":"08-Vuex"},{"content":"字符串的扩展 下面提到的字符串的几个方法，更详细的内容，可以看《04-JavaScript 基础/内置对象 String：字符串的常见方法.md》。\nES6 中的字符串扩展如下：\nincludes(str)：判断是否包含指定的字符串\nstartsWith(str)：判断是否以指定字符串开头\nendsWith(str)：判断是否以指定字符串结尾\nrepeat(count)：重复指定次数\n举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let str = \u0026#39;abcdefg\u0026#39;; console.log(str.includes(\u0026#39;a\u0026#39;)); //true console.log(str.includes(\u0026#39;h\u0026#39;)); //false //startsWith(str) : 判断是否以指定字符串开头 console.log(str.startsWith(\u0026#39;a\u0026#39;)); //true console.log(str.startsWith(\u0026#39;d\u0026#39;)); //false //endsWith(str) : 判断是否以指定字符串结尾 console.log(str.endsWith(\u0026#39;g\u0026#39;)); //true console.log(str.endsWith(\u0026#39;d\u0026#39;)); //false //repeat(count) : 重复指定次数a console.log(str.repeat(5)); 打印结果：\nNumber 的扩展 二进制与八进制数值表示法: 二进制用0b, 八进制用0o。 举例：\n1 2 console.log(0b1010); //10 console.log(0o56); //46 Number.isFinite(i)：判断是否为有限大的数。比如Infinity这种无穷大的数，返回的就是 false。\nNumber.isNaN(i)：判断是否为 NaN。\nNumber.isInteger(i)：判断是否为整数。\nNumber.parseInt(str)：将字符串转换为对应的数值。\nMath.trunc(i)：去除小数部分。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //Number.isFinite(i) : 判断是否是有限大的数 console.log(Number.isFinite(NaN)); //false console.log(Number.isFinite(5)); //true console.log(Number.isFinite(Infinity)); //false //Number.isNaN(i) : 判断是否是NaN console.log(Number.isNaN(NaN)); //true console.log(Number.isNaN(5)); //falsse //Number.isInteger(i) : 判断是否是整数 console.log(Number.isInteger(5.23)); //false console.log(Number.isInteger(5.0)); //true console.log(Number.isInteger(5)); //true //Number.parseInt(str) : 将字符串转换为对应的数值 console.log(Number.parseInt(\u0026#39;123abc\u0026#39;)); //123 console.log(Number.parseInt(\u0026#39;a123abc\u0026#39;)); //NaN // Math.trunc(i) : 直接去除小数部分 console.log(Math.trunc(13.123)); //13 数组的扩展 下面提到的数组的几个方法，更详细的内容，可以看《04-JavaScript 基础/数组的常见方法.md》。\nArray.from()\nfind()\nfindIndex()\n对象的扩展 扩展 1 1 Object.is(v1, v2); 作用：判断两个数据是否完全相等。底层是通过字符串来判断的。\n我们先来看下面这两行代码的打印结果：\n1 2 console.log(0 == -0); console.log(NaN == NaN); 打印结果：\n1 2 true false 上方代码中，第一行代码的打印结果为 true，这个很好理解。第二行代码的打印结果为 false，因为 NaN 和任何值都不相等。\n但是，如果换成下面这种方式来比较：\n1 2 console.log(Object.is(0, -0)); console.log(Object.is(NaN, NaN)); 打印结果却是：\n1 2 false true 代码解释：还是刚刚说的那样，Object.is(v1, v2)比较的是字符串是否相等。\nObject.assign() Object.assign() 在实战开发中，使用到的频率非常高，一定要重视。关于它的内容，详见《04-JavaScript 基础/浅拷贝和深拷贝.md》。\n扩展 3：__proto__属性 举例：\n1 2 3 4 5 6 7 8 let obj1 = { name: \u0026#39;smyhvae\u0026#39; }; let obj2 = {}; obj2.__proto__ = obj1; console.log(obj1); console.log(obj2); console.log(obj2.name); 打印结果：\n上方代码中，obj2 本身是没有属性的，但是通过__proto__属性和 obj1 产生关联，于是就可以获得 obj1 里的属性。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/","summary":"字符串的扩展 下面提到的字符串的几个方法，更详细的内容，可以看《04-JavaScript 基础/内置对象 String：字符串的常见方法.md》","title":"08-字符串、数组、对象的扩展"},{"content":"我们在本文件夹的第 02 篇里讲到了JS中变量的概念，本篇文章讲一下运算符和表达式。\n运算符的定义和分类 运算符的定义 运算符：也叫操作符，是一种符号。通过运算符可以对一个或多个值进行运算，并获取运算结果。\n表达式：由数字、运算符、变量的组合（组成的式子）。\n表达式最终都会有一个运算结果，我们将这个结果称为表达式的返回值。\n比如：+、*、/、( 都是运算符，而（3+5）/2则是表达式。\n比如：typeof 就是运算符，可以来获得一个值的类型。它会将该值的类型以字符串的形式返回，返回值可以是 number、string、boolean、undefined、object。\n运算符的分类 JS 中的运算符，分类如下：\n算数运算符\n自增/自减运算符\n一元运算符\n逻辑运算符\n赋值运算符\n比较运算符\n三元运算符（条件运算符）\n下面来逐一讲解。\n算数运算符 算术运算符：用于执行两个变量或值的算术运算。\n常见的算数运算符有以下几种：\n运算符 描述 + 加、字符串连接 - 减 * 乘 / 除 % 获取余数（取余、取模） 求余的举例：\n假设用户输入345，怎么分别得到3、4、5这三个数呢？\n答案：\n1 2 3 4 5 得到3的方法：345 除以100，得到3.45然后取整，得到3。即：parseInt(345/100) 得到4的方法：345 除以100，余数是45，除以10，得到4.5，取整。即：parseInt(345 % 100 / 10) 得到5的方法：345 除以10，余数就是5。即：345 % 10 算数运算符的运算规则 （1）先算乘除、后算加减。\n（2）小括号( )：能够影响计算顺序，且可以嵌套。没有中括号、没有大括号，只有小括号。\n（3）百分号：取余。只关心余数。\n举例1：(取余)\n1 console.log(3 % 5); 输出结果为3。\n举例2：（注意运算符的优先级）\n1 var a = 1 + 2 * 3 % 4 / 3; 结果分析：\n原式 = 1 + 6 % 4 / 3 = 1 + 2 / 3 = 1.66666666666666\n补充：关于算数运算符的注意事项，详见上一篇文章里的“数据类型转换”的知识点。\n浮点数运算的精度问题 浮点数值的最高精度是 17 位小数，但在进行算术计算时，会丢失精度，导致计算不够准确。比如：\n1 2 3 console.log(0.1 + 0.2); // 运算结果不是 0.3，而是 0.30000000000000004 console.log(0.07 * 100); // 运算结果不是 7，而是 7.000000000000001 因此，不要直接判断两个浮点数是否相等。\n自增和自减 自增 ++ 自增分成两种：a++和++a。\n（1）一个变量自增以后，原变量的值会立即自增1。也就是说，无论是 a++ 还是++a，都会立即使原变量的值自增1。\n（2）我们要注意的是：a是变量，而a++和++a是表达式。\n那这两种自增，有啥区别呢？区别是：a++ 和 ++a的值不同：（也就是说，表达式的值不同）\na++这个表达式的值等于原变量的值（a自增前的值）。你可以这样理解：先把 a 的值赋值给表达式，然后 a 再自增。\n++a这个表达式的值等于新值 （a自增后的值）。 你可以这样理解：a 先自增，然后再把自增后的值赋值给表达式。\n自减 -- 原理同上。\n开发时，大多使用后置的自增/自减，并且代码独占一行，例如：num++，或者 num--。\n代码举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var n1 = 10; var n2 = 20; var result1 = n1++; console.log(n1); // 11 console.log(result1); // 10 result = ++n1; console.log(n1); //12 console.log(result); //12 var result2 = n2--; console.log(n2); // 19 console.log(result2); // 20 result2 = --n2; console.log(n2); // 18 console.log(result2); // 18 一元运算符 一元运算符，只需要一个操作数。\n常见的一元运算符如下。\ntypeof typeof就是典型的一元运算符，因为后面只跟一个操作数。\n举例如下：\n1 2 var a = \u0026#39;123\u0026#39;; console.log(typeof a); // 打印结果：string 正号 + （1）正号不会对数字产生任何影响。比如说，2和+2是一样的。\n（2）我们可以对一个其他的数据类型使用+，来将其转换为number【重要的小技巧】。比如：\n1 2 3 4 5 6 7 8 9 10 11 var a = true; a = +a; // 注意这行代码的一元运算符操作 console.log(\u0026#39;a：\u0026#39; + a); console.log(typeof a); console.log(\u0026#39;-----------------\u0026#39;); var b = \u0026#39;18\u0026#39;; b = +b; // 注意这行代码的一元运算符操作 console.log(\u0026#39;b：\u0026#39; + b); console.log(typeof b); 打印结果：\n1 2 3 4 5 6 7 a：1 number ----------------- b：18 number 负号 - 负号可以对数字进行取反。\n逻辑运算符 逻辑运算符有三个：\n\u0026amp;\u0026amp; 与（且）：两个都为真，结果才为真。\n||\t或：只要有一个是真，结果就是真。\n!\t非：对一个布尔值进行取反。\n注意：能参与逻辑运算的，都是布尔值。\n连比的写法：\n来看看逻辑运算符连比的写法。\n举例1：\n1 console.log(3 \u0026lt; 2 \u0026amp;\u0026amp; 2 \u0026lt; 4); 输出结果为false。\n举例2：（判断一个人的年龄是否在18~65岁之间）\n1 2 3 4 5 6 7 const a = prompt(\u0026#39;请输入您的年龄\u0026#39;); if (a \u0026gt;= 18 \u0026amp;\u0026amp; a \u0026lt; 65) { alert(\u0026#39;可以上班\u0026#39;); } else { alert(\u0026#39;准备退休\u0026#39;); } PS：上面的a\u0026gt;=18 \u0026amp;\u0026amp; a\u0026lt;= 65千万别想当然地写成 18\u0026lt;= a \u0026lt;= 65，没有这种语法。\n非布尔值的与或运算【重要】 之所以重要，是因为在实际开发中，我们经常用这种代码做容错处理或者兜底处理。\n非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，但返回结果是原值。比如说：\n1 2 var result = 5 \u0026amp;\u0026amp; 6; // 运算过程：true \u0026amp;\u0026amp; true; console.log(\u0026#39;result：\u0026#39; + result); // 打印结果：6（也就是说最后面的那个值。） 上方代码可以看到，虽然运算过程为布尔值的运算，但返回结果是原值。\n那么，返回结果是哪个原值呢？我们来看一下。\n与运算的返回结果：（以多个非布尔值的运算为例）\n如果第一个值为false，则执行第一条语句，并直接返回第一个值；不会再往后执行。\n如果第一个值为true，则继续执行第二条语句，并返回第二个值（如果所有的值都为true，则返回的是最后一个值）。\n或运算的返回结果：（以多个非布尔值的运算为例）\n如果第一个值为true，则执行第一条语句，并直接返回第一个值；不会再往后执行。\n如果第一个值为false，则继续执行第二条语句，并返回第二个值（（如果所有的值都为false，则返回的是最后一个值）。\n实际开发中，我们经常是这样来做「容错处理」的：\n当前端成功调用一个接口后，返回的数据为 result 对象。这个时候，我们用变量 a 来接收 result 里的图片资源。通常的写法是这样的：\n1 2 3 if (result.resultCode == 0) { var a = result \u0026amp;\u0026amp; result.data \u0026amp;\u0026amp; result.data.imgUrl || \u0026#39;http://img.smyhvae.com/20160401_01.jpg\u0026#39;; } 上方代码的意思是，获取返回结果中的result.data.imgUrl这个图片资源；如果返回结果中没有 result.data.imgUrl 这个字段，就用 http://img.smyhvae.com/20160401_01.jpg 作为兜底图片。这种写法，在实际开发中经常用到。\n非布尔值的 ! 运算 非布尔值进行非运算时，会先将其转换为布尔值，然后再运算，但返回结果是布尔值。\n举例：\n1 2 3 4 5 let a = 10; a = !a console.log(a); // false console.log(typeof a); // boolean 短路运算的妙用【重要】 下方举例中的写法技巧，在实际开发中，经常用到。这种写法，是一种很好的「容错、容灾、降级」方案，需要多看几遍。\n1、JS中的\u0026amp;\u0026amp;属于短路的与：\n如果第一个值为false，则不会执行后面的内容。\n如果第一个值为 true，则继续执行第二条语句，并返回第二个值。\n举例：\n1 2 3 4 5 6 7 const a1 = \u0026#39;qianguyihao\u0026#39;; //第一个值为true，会继续执行后面的内容 a1 \u0026amp;\u0026amp; alert(\u0026#39;看 a1 出不出来\u0026#39;); // 可以弹出 alert 框 const a2 = undefined; //第一个值为false，不会继续执行后面的内容 a2 \u0026amp;\u0026amp; alert(\u0026#39;看 a2 出不出来\u0026#39;); // 不会弹出 alert 框 2、JS中的||属于短路的或：\n如果第一个值为true，则不会执行后面的内容。\n如果第一个值为 false，则继续执行第二条语句，并返回第二个值。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 const result; // 请求接口时，后台返回的内容 let errorMsg = \u0026#39;\u0026#39;; // 前端的文案提示 if (result \u0026amp;\u0026amp; result.retCode != 0) { // 接口返回异常码时 errorMsg = result.msg || \u0026#39;活动太火爆，请稍后再试\u0026#39;; // 文案提示信息，优先用 接口返回的msg字段，其次用 \u0026#39;活动太火爆，请稍后再试\u0026#39; 这个文案兜底。 } if (!result) { // 接口挂掉时 errorMsg = \u0026#39;网络异常，请稍后再试\u0026#39;; } 赋值运算符 可以将符号右侧的值赋值给符号左侧的变量。\n举例：\n= 直接赋值。比如 var a = 5\n+=。a += 5 等价于 a = a + 5\n-=。a -= 5 等价于 a = a - 5\n*=。a *= 5 等价于 a = a * 5\n/=。a /= 5 等价于 a = a / 5\n%=。a %= 5 等价于 a = a % 5\n比较运算符 比较运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false。\n比较运算符有很多种，比如：\n1 2 3 4 5 6 7 8 \u0026gt;\t大于号 \u0026lt;\t小于号 \u0026gt;= 大于或等于 \u0026lt;= 小于或等于 == 等于 === 全等于 !=\t不等于 !== 不全等于 比较运算符，得到的结果都是布尔值：要么是true，要么是false。\n举例如下：\n1 var result = 5 \u0026gt; 10; // false 非数值的比较 （1）对于非数值进行比较时，会将其转换为数字然后再比较。\n举例如下：\n1 2 3 4 5 6 7 8 9 10 console.log(1 \u0026gt; true); //false console.log(1 \u0026gt;= true); //true console.log(1 \u0026gt; \u0026#34;0\u0026#34;); //true //console.log(10 \u0026gt; null); //true //任何值和NaN做任何比较都是false console.log(10 \u0026lt;= \u0026#34;hello\u0026#34;); //false console.log(true \u0026gt; false); //true （2）特殊情况：如果符号两侧的值都是字符串时，不会将其转换为数字进行比较。比较两个字符串时，比较的是字符串的Unicode编码。【非常重要，这里是个大坑，很容易踩到】\n比较字符编码时，是一位一位进行比较。如果两位一样，则比较下一位。\n比如说，当你尝试去比较\u0026quot;123\u0026quot;和\u0026quot;56\u0026quot;这两个字符串时，你会发现，字符串\u0026quot;56\u0026quot;竟然比字符串\u0026quot;123\u0026quot;要大（因为 5 比 1 大）。也就是说，下面这样代码的打印结果，其实是true:（这个我们一定要注意，在日常开发中，很容易忽视）\n1 2 // 比较两个字符串时，比较的是字符串的字符编码，所以可能会得到不可预期的结果 console.log(\u0026#34;56\u0026#34; \u0026gt; \u0026#34;123\u0026#34;); // true 因此：当我们在比较两个字符串型的数字时，一定一定要先转型再比较大小，比如 parseInt()。\n（3）任何值和NaN做任何比较都是false。\n==符号的强调 注意==这个符号，它是判断是否等于，而不是赋值。\n（1）== 这个符号，还可以验证字符串是否相同。例如：\n1 console.log(\u0026#34;我爱你中国\u0026#34; == \u0026#34;我爱你中国\u0026#34;);\t// 输出结果为true （2）== 这个符号并不严谨，会做隐式转换，将不同的数据类型，转为相同类型进行比较（大部分情况下，都是转换为数字）。例如：\n1 2 3 4 5 console.log(\u0026#34;6\u0026#34; == 6);\t// 打印结果：true。这里的字符串\u0026#34;6\u0026#34;会先转换为数字6，然后再进行比较 console.log(true == \u0026#34;1\u0026#34;); // 打印结果：true console.log(0 == -0); // 打印结果：true console.log(null == 0); // 打印结果：false （3）undefined 衍生自 null，所以这两个值做相等判断时，会返回true。\n1 console.log(undefined == null); //打印结果：true。 （4）NaN不和任何值相等，包括他本身。\n1 2 console.log(NaN == NaN); //false console.log(NaN === NaN); //false 问题：那如果我想判断 b的值是否为NaN，该怎么办呢？\n答案：可以通过isNaN()函数来判断一个值是否是NaN。举例：\n1 console.log(isNaN(b)); 如上方代码所示，如果 b 为 NaN，则返回true；否则返回false。\n===全等符号的强调 全等在比较时，不会做类型转换。如果要保证绝对等于（完全等于），我们就要用三个等号===。例如：\n1 2 console.log(\u0026#34;6\u0026#34; === 6);\t//false console.log(6 === 6);\t//true 上述内容分析出：\n==两个等号，不严谨，\u0026ldquo;6\u0026quot;和6是true。\n===三个等号，严谨，\u0026ldquo;6\u0026quot;和6是false。\n另外还有：==的反面是!=，===的反面是!==。例如：\n1 2 3 console.log(3 != 8);\t//true console.log(3 != \u0026#34;3\u0026#34;);\t//false，因为3==\u0026#34;3\u0026#34;是true，所以反过来就是false。 console.log(3 !== \u0026#34;3\u0026#34;);\t//true，应为3===\u0026#34;3\u0026#34;是false，所以反过来是true。 三元运算符 三元运算符也叫条件运算符。\n语法：\n1 条件表达式 ? 语句1 : 语句2; 执行的流程：\n条件运算符在执行时，首先对条件表达式进行求值：\n如果该值为true，则执行语句1，并返回执行结果\n如果该值为false，则执行语句2，并返回执行结果\n如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算。\n运算符的优先级 运算符的优先级如下：（优先级从高到低）\n.、[]、new\n()\n++、--\n!、~、+（单目）、-（单目）、typeof、void、delete\n%、*、/\n+（双目）、-（双目）\n\u0026lt;\u0026lt;、\u0026gt;\u0026gt;、\u0026gt;\u0026gt;\u0026gt;\n关系运算符：\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=\n==、!==、===、!==\n\u0026amp;\n^\n|\n\u0026amp;\u0026amp;\n||\n?:\n=、+=、-=、*=、/=、%=、\u0026lt;\u0026lt;=、\u0026gt;\u0026gt;=、\u0026gt;\u0026gt;\u0026gt;=、\u0026amp;=、^=、|=\n,\n注意：逻辑与 \u0026amp;\u0026amp; 比逻辑或 || 的优先级更高。\n备注：你在实际写代码的时候，如果不清楚哪个优先级更高，可以把括号运用上。\nUnicode 编码 这一段中，我们来讲引申的内容：Unicode编码的使用。\n各位同学可以先在网上查一下“Unicode 编码表”。\n1、在字符串中可以使用转义字符输入Unicode编码。格式如下：\n1 \\u四位编码 举例如下：\n1 2 console.log(\u0026#34;\\u2600\u0026#34;); // 这里的 2600 采用的是16进制 console.log(\u0026#34;\\u2602\u0026#34;); // 这里的 2602 采用的是16进制。 打印结果：\n2、我们还可以在 HTML 网页中使用Unicode编码。格式如下：\n1 \u0026amp;#四位编码; PS：我们知道，Unicode编码采用的是16进制，但是，这里的编码需要使用10进制。\n举例如下：\n1 \u0026lt;h1 style=\u0026#34;font-size: 100px;\u0026#34;\u0026gt;\u0026amp;#9860;\u0026lt;/h1\u0026gt; 打印结果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/08-%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"我们在本文件夹的第 02 篇里讲到了JS中变量的概念，本篇文章讲一下运算符和表达式。 运算符的定义和分类 运算符的定义 运算符：也叫操作符，是一种符号。","title":"08-运算符"},{"content":"前言 本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。\n前端做文件上传这个功能，是很有技术难度的。既然框架给我们提供好了，那就直接用呗。结果用的时候，发现 upload 组件的很多bug。下面来列举几个。\n备注：本文写于2019-03-02，使用的 antd 版本是 3.13.6。\n使用 AntD 的 upload 组件做图片的上传 因为需要上传多张图片，所以采用的是照片墙的形式。上传成功后的界面如下：\n（1）上传中：\n（2）上传成功：\n（3）图片预览：\n按照官方提供的实例，特此整理出项目开发中的完整写法，亲测有效。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 /* eslint-disable */ import { Upload, Icon, Modal, Form } from \u0026#39;antd\u0026#39;; const FormItem = Form.Item; class PicturesWall extends PureComponent { state = { previewVisible: false, previewImage: \u0026#39;\u0026#39;, imgList: [], }; handleChange = ({ file, fileList }) =\u0026gt; { console.log(JSON.stringify(file)); // file 是当前正在上传的 单个 img console.log(JSON.stringify(fileList)); // fileList 是已上传的全部 img 列表 this.setState({ imgList: fileList, }); }; handleCancel = () =\u0026gt; this.setState({ previewVisible: false }); handlePreview = file =\u0026gt; { this.setState({ previewImage: file.url || file.thumbUrl, previewVisible: true, }); }; // 参考链接：https://www.jianshu.com/p/f356f050b3c9 handleBeforeUpload = file =\u0026gt; { //限制图片 格式、size、分辨率 const isJPG = file.type === \u0026#39;image/jpeg\u0026#39;; const isJPEG = file.type === \u0026#39;image/jpeg\u0026#39;; const isGIF = file.type === \u0026#39;image/gif\u0026#39;; const isPNG = file.type === \u0026#39;image/png\u0026#39;; if (!(isJPG || isJPEG || isGIF || isPNG)) { Modal.error({ title: \u0026#39;只能上传JPG 、JPEG 、GIF、 PNG格式的图片~\u0026#39;, }); return; } const isLt2M = file.size / 1024 / 1024 \u0026lt; 2; if (!isLt2M) { Modal.error({ title: \u0026#39;超过2M限制，不允许上传~\u0026#39;, }); return; } return (isJPG || isJPEG || isGIF || isPNG) \u0026amp;\u0026amp; isLt2M \u0026amp;\u0026amp; this.checkImageWH(file); }; //返回一个 promise：检测通过则返回resolve；失败则返回reject，并阻止图片上传 checkImageWH(file) { let self = this; return new Promise(function(resolve, reject) { let filereader = new FileReader(); filereader.onload = e =\u0026gt; { let src = e.target.result; const image = new Image(); image.onload = function() { // 获取图片的宽高，并存放到file对象中 console.log(\u0026#39;file width :\u0026#39; + this.width); console.log(\u0026#39;file height :\u0026#39; + this.height); file.width = this.width; file.height = this.height; resolve(); }; image.onerror = reject; image.src = src; }; filereader.readAsDataURL(file); }); } handleSubmit = e =\u0026gt; { const { dispatch, form } = this.props; e.preventDefault(); form.validateFieldsAndScroll((err, values) =\u0026gt; {// values 是form表单里的参数 // 点击按钮后，将表单提交给后台 dispatch({ type: \u0026#39;mymodel/submitFormData\u0026#39;, payload: values, }); }); }; render() { const { previewVisible, previewImage, imgList } = this.state; // 从 state 中拿数据 const uploadButton = ( \u0026lt;div\u0026gt; \u0026lt;Icon type=\u0026#34;plus\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;ant-upload-text\u0026#34;\u0026gt;Upload\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); return ( \u0026lt;div className=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;Form onSubmit={this.handleSubmit} hideRequiredMark style={{ marginTop: 8 }}\u0026gt; \u0026lt;FormItem label=\u0026#34;图片图片\u0026#34; {...formItemLayout}\u0026gt; {getFieldDecorator(\u0026#39;myImg\u0026#39;)( \u0026lt;Upload action=\u0026#34;//jsonplaceholder.typicode.com/posts/\u0026#34; // 这个是图片上传的接口请求，实际开发中，要替换成你自己的业务接口 data={file =\u0026gt; ({ // data里存放的是接口的请求参数 param1: myParam1, param2: myParam2, photoCotent: file, // file 是当前正在上传的图片 photoWidth: file.height, // 通过 handleBeforeUpload 获取 图片的宽高 photoHeight: file.width, })} listType=\u0026#34;picture-card\u0026#34; fileList={this.state.imgList} onPreview={this.handlePreview} // 点击图片缩略图，进行预览 beforeUpload={this.handleBeforeUpload} // 上传之前，对图片的格式做校验，并获取图片的宽高 onChange={this.handleChange} // 每次上传图片时，都会触发这个方法 \u0026gt; {this.state.imgList.length \u0026gt;= 9 ? null : uploadButton} \u0026lt;/Upload\u0026gt; )} \u0026lt;/FormItem\u0026gt; \u0026lt;/Form\u0026gt; \u0026lt;Modal visible={previewVisible} footer={null} onCancel={this.handleCancel}\u0026gt; \u0026lt;img alt=\u0026#34;example\u0026#34; style={{ width: \u0026#39;100%\u0026#39; }} src={previewImage} /\u0026gt; \u0026lt;/Modal\u0026gt; \u0026lt;/div\u0026gt; ); } } export default PicturesWall; 上传后，点击图片预览，浏览器卡死的问题 依据上方的代码，通过 Antd 的 upload 组件将图片上传成功后，点击图片的缩略图，理应可以在当前页面弹出 Modal，预览图片。但实际的结果是，浏览器一定会卡死。\n定位问题发现，原因竟然是：图片上传成功后， upload 会将其转为 base64编码。base64这个字符串太大了，点击图片预览的时候，浏览器在解析一大串字符串，然后就卡死了。详细过程描述如下。\n上方代码中，我们可以把 handleChange(file, fileList)方法中的 file、以及 fileList打印出来看看。 file指的是当前正在上传的 单个 img，fileList是已上传的全部 img 列表。 当我上传完 两张图片后， 打印结果如下：\nfile的打印的结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-5\u0026#34;, \u0026#34;width\u0026#34;: 600, \u0026#34;height\u0026#34;: 354, \u0026#34;lastModified\u0026#34;: 1546701318000, \u0026#34;lastModifiedDate\u0026#34;: \u0026#34;2019-01-05T15:15:18.000Z\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;e30e7b9680634b2c888c8bb513cc595d.jpg\u0026#34;, \u0026#34;size\u0026#34;: 31731, \u0026#34;type\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;percent\u0026#34;: 100, \u0026#34;originFileObj\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-5\u0026#34;, \u0026#34;width\u0026#34;: 600, \u0026#34;height\u0026#34;: 354 }, \u0026#34;status\u0026#34;: \u0026#34;done\u0026#34;, \u0026#34;thumbUrl\u0026#34;: \u0026#34;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAHQ9qKKlbimcXrIH9o2vH/AC2T+ddPj98v+9RRWsuhnHdk0ar9qb5R0Pb6VPB/qh9aKKiRr0Irnt/vUDr+NFFJCRqWxJik5Pb+dLJ938aKK06mYSdKKKKBH//Z\u0026#34;, \u0026#34;response\u0026#34;: { \u0026#34;retCode\u0026#34;: 0, \u0026#34;imgUrl\u0026#34;: \u0026#34;http://qianguyihao.com/opfewfwj098902kpkpkkj976fe.jpg\u0026#34;, \u0026#34;photoid\u0026#34;: 271850 } } fileList 的打印结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 [ { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-3\u0026#34;, \u0026#34;width\u0026#34;: 1000, \u0026#34;height\u0026#34;: 667, \u0026#34;lastModified\u0026#34;: 1501414799000, \u0026#34;lastModifiedDate\u0026#34;: \u0026#34;2017-07-30T11:39:59.000Z\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;29381f30e924b89914e91b33.jpg\u0026#34;, \u0026#34;size\u0026#34;: 135204, \u0026#34;type\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;percent\u0026#34;: 100, \u0026#34;originFileObj\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-3\u0026#34;, \u0026#34;width\u0026#34;: 1000, \u0026#34;height\u0026#34;: 667 }, \u0026#34;status\u0026#34;: \u0026#34;done\u0026#34;, \u0026#34;thumbUrl\u0026#34;: \u0026#34;data:image/jpeg;base64,/E3ju1tlaK1fzJOnHQU3LsLV7HO6Zrk11MZJ7luT0A4FZuRagi9quvzQQ4iuEJ7ZpqTG4djDsPFl2Lg733f8C4q+YhQ8zoYfGSqoMmfwo5huLL0HjiyPDSYPvxRdC1XQvxeLrB8fvl/OnoLmL9vrdvvYS3NGFVe2YsASOh71JfQyrqV2mXLHOcccVSIYEnDyZO9XXB9KYH//Z\u0026#34;, \u0026#34;response\u0026#34;: { \u0026#34;retCode\u0026#34;: 0, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;imgUrl\u0026#34;: \u0026#34;http://qianguyihao.com/hfwpjouiurewnmbhepr689.jpg\u0026#34;, } }, { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-5\u0026#34;, \u0026#34;width\u0026#34;: 600, \u0026#34;height\u0026#34;: 354, \u0026#34;lastModified\u0026#34;: 1546701318000, \u0026#34;lastModifiedDate\u0026#34;: \u0026#34;2019-01-05T15:15:18.000Z\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;e30e7b9680634b2c888c8bb513cc595d.jpg\u0026#34;, \u0026#34;size\u0026#34;: 31731, \u0026#34;type\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;percent\u0026#34;: 100, \u0026#34;originFileObj\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-5\u0026#34;, \u0026#34;width\u0026#34;: 600, \u0026#34;height\u0026#34;: 354 }, \u0026#34;status\u0026#34;: \u0026#34;done\u0026#34;, \u0026#34;thumbUrl\u0026#34;: \u0026#34;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAHQ9qKKlbimcXrIH9o2vH/AC2T+ddPj98v+9RRWsuhnHdk0ar9qb5R0Pb6VPB/qh9aKKiRr0Irnt/vUDr+NFFJCRqWxJik5Pb+dLJ938aKK06mYSdKKKKBH//Z\u0026#34;, \u0026#34;response\u0026#34;: { \u0026#34;retCode\u0026#34;: 0, \u0026#34;imgUrl\u0026#34;: \u0026#34;http://qianguyihao.com/opfewfwj098902kpkpkkj976fe.jpg\u0026#34;, \u0026#34;photoid\u0026#34;: 271850 } } ] 上方的json数据中，需要做几点解释：\n（1）response 字段里面的数据，就是请求接口后，后台返回给前端的数据，里面包含了图片的url链接。\n（2）status 字段里存放的是图片上传的实时状态，包括上传中、上传完成、上传失败。\n（3）thumbUrl字段里面存放的是图片的base64编码。\n这个base64编码非常非常长。当点击图片预览的时候，其实就是加载的 thumbUrl 这个字段里的资源，难怪浏览器会卡死。\n解决办法：在 handleChange方法里，图片上传成功后，将 thumbUrl 字段里面的 base64 编码改为真实的图片url。代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 handleChange = ({ file, fileList }) =\u0026gt; { console.log(JSON.stringify(file)); // file 是当前正在上传的 单个 img console.log(JSON.stringify(fileList)); // fileList 是已上传的全部 img 列表 // 【重要】将 图片的base64替换为图片的url。 这一行一定不会能少。 // 图片上传成功后，fileList数组中的 thumbUrl 中保存的是图片的base64字符串，这种情况，导致的问题是：图片上传成功后，点击图片缩略图，浏览器会会卡死。而下面这行代码，可以解决该bug。 fileList.forEach(imgItem =\u0026gt; { if (imgItem \u0026amp;\u0026amp; imgItem.status == \u0026#39;done\u0026#39; \u0026amp;\u0026amp; imgItem.response \u0026amp;\u0026amp; imgItem.response.imgUrl) { imgItem.thumbUrl = imgItem.response.imgUrl; } }); this.setState({ imgList: fileList, }); }; 新需求：编辑现有页面 上面一段的代码中，我们是在新建的页面中，从零开始上传图片。\n现在有个新的需求：如何编辑现有的页面呢？也就是说，现有的页面在初始化时，是默认有几张图片的。当我编辑这个页面时，可以对现有的图片做增删，也能增加新的图片。而且要保证：新建页面和编辑现有页面，是共用一套代码。\n我看到upload 组件有提供 defaultFileList 的属性。我试了下，这个defaultFileList 的属性根本没法儿用。\n那就只有手动实现了。我的model层代码，是用 redux 写的。整体的实现思路如下：（这个也是在真正在实战中用到的代码）\n（1）PicturesWall.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 /* eslint-disable */ import { Upload, Icon, Modal, Form } from \u0026#39;antd\u0026#39;; const FormItem = Form.Item; class PicturesWall extends PureComponent { state = { previewVisible: false, previewImage: \u0026#39;\u0026#39;, }; // 页面初始化的时候，从接口拉取默认的图片数据 componentDidMount() { const { dispatch } = this.props; dispatch({ type: \u0026#39;mymodel/getAllInfo\u0026#39;, payload: { params: xxx }, }); } handleChange = ({ file, fileList }) =\u0026gt; { const { dispatch } = this.props; // 【重要】将 图片的base64替换为图片的url。 这一行一定不会能少。 // 图片上传成功后，fileList数组中的 thumbUrl 中保存的是图片的base64字符串，这种情况，导致的问题是：图片上传成功后，点击图片缩略图，浏览器会会卡死。而下面这行代码，可以解决该bug。 fileList.forEach(imgItem =\u0026gt; { if (imgItem \u0026amp;\u0026amp; imgItem.status == \u0026#39;done\u0026#39; \u0026amp;\u0026amp; imgItem.response \u0026amp;\u0026amp; imgItem.response.imgUrl) { imgItem.thumbUrl = imgItem.response.imgUrl; } }); dispatch({ type: \u0026#39;mymodel/setImgList\u0026#39;, payload: fileList, }); }; handleCancel = () =\u0026gt; this.setState({ previewVisible: false }); handlePreview = file =\u0026gt; { this.setState({ previewImage: file.url || file.thumbUrl, previewVisible: true, }); }; // 参考链接：https://www.jianshu.com/p/f356f050b3c9 handleBeforeUpload = file =\u0026gt; { //限制图片 格式、size、分辨率 const isJPG = file.type === \u0026#39;image/jpeg\u0026#39;; const isJPEG = file.type === \u0026#39;image/jpeg\u0026#39;; const isGIF = file.type === \u0026#39;image/gif\u0026#39;; const isPNG = file.type === \u0026#39;image/png\u0026#39;; const isLt2M = file.size / 1024 / 1024 \u0026lt; 2; if (!(isJPG || isJPEG || isGIF || isPNG)) { Modal.error({ title: \u0026#39;只能上传JPG 、JPEG 、GIF、 PNG格式的图片~\u0026#39;, }); } else if (!isLt2M) { Modal.error({ title: \u0026#39;超过2M限制，不允许上传~\u0026#39;, }); } } // 参考链接：https://github.com/ant-design/ant-design/issues/8779 return new Promise((resolve, reject) =\u0026gt; { if (!(isJPG || isJPEG || isGIF || isPNG)) { reject(file); } else { resolve(file \u0026amp;\u0026amp; this.checkImageWH(file)); } }); }; //返回一个 promise：检测通过则返回resolve；失败则返回reject，并阻止图片上传 checkImageWH(file) { let self = this; return new Promise(function(resolve, reject) { let filereader = new FileReader(); filereader.onload = e =\u0026gt; { let src = e.target.result; const image = new Image(); image.onload = function() { // 获取图片的宽高，并存放到file对象中 console.log(\u0026#39;file width :\u0026#39; + this.width); console.log(\u0026#39;file height :\u0026#39; + this.height); file.width = this.width; file.height = this.height; resolve(); }; image.onerror = reject; image.src = src; }; filereader.readAsDataURL(file); }); } handleSubmit = e =\u0026gt; { const { dispatch, form } = this.props; e.preventDefault(); const { mymodel: { imgList }, // 从props中拿默认的图片数据 } = this.props; form.validateFieldsAndScroll((err, values) =\u0026gt; { // values 是form表单里的参数 // 点击按钮后，将表单提交给后台 // start 问题描述：当编辑现有页面时，如果针对已经存在的默认图片不做修改，则不会触发 upload 的 onChange方法。此时提交表单，表单里的 myImg 字段是空的。 // 解决办法：如果发现存在默认图片，则追加到表单中 if (!values.myImg) { values.myImg = { fileList: [] }; values.myImg.fileList = imgList; } // end dispatch({ type: \u0026#39;mymodel/submitFormData\u0026#39;, payload: values, }); }); }; render() { const { previewVisible, previewImage } = this.state; // 从 state 中拿数据 const { mymodel: { imgList }, // 从props中拿到的图片数据 } = this.props; const uploadButton = ( \u0026lt;div\u0026gt; \u0026lt;Icon type=\u0026#34;plus\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;ant-upload-text\u0026#34;\u0026gt;Upload\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); return ( \u0026lt;div className=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;Form onSubmit={this.handleSubmit} hideRequiredMark style={{ marginTop: 8 }}\u0026gt; \u0026lt;FormItem label=\u0026#34;图片上传\u0026#34; {...formItemLayout}\u0026gt; {getFieldDecorator(\u0026#39;myImg\u0026#39;)( \u0026lt;Upload action=\u0026#34;//jsonplaceholder.typicode.com/posts/\u0026#34; // 这个是图片上传的接口请求，实际开发中，要替换成你自己的业务接口 data={file =\u0026gt; ({ // data里存放的是接口的请求参数 param1: myParam1, param2: myParam2, photoCotent: file, // file 是当前正在上传的图片 photoWidth: file.height, // 通过 handleBeforeUpload 获取 图片的宽高 photoHeight: file.width, })} listType=\u0026#34;picture-card\u0026#34; fileList={imgList} // 改为从 props 里拿图片数据，而不是从 state onPreview={this.handlePreview} // 点击图片缩略图，进行预览 beforeUpload={this.handleBeforeUpload} // 上传之前，对图片的格式做校验，并获取图片的宽高 onChange={this.handleChange} // 每次上传图片时，都会触发这个方法 \u0026gt; {this.state.imgList.length \u0026gt;= 9 ? null : uploadButton} \u0026lt;/Upload\u0026gt; )} \u0026lt;/FormItem\u0026gt; \u0026lt;/Form\u0026gt; \u0026lt;Modal visible={previewVisible} footer={null} onCancel={this.handleCancel}\u0026gt; \u0026lt;img alt=\u0026#34;example\u0026#34; style={{ width: \u0026#39;100%\u0026#39; }} src={previewImage} /\u0026gt; \u0026lt;/Modal\u0026gt; \u0026lt;/div\u0026gt; ); } } export default PicturesWall; （2）mymodel.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 /* eslint-disable */ import { routerRedux } from \u0026#39;dva/router\u0026#39;; import { message, Modal } from \u0026#39;antd\u0026#39;; import { getGoodsInfo, getAllGoods, } from \u0026#39;../services/api\u0026#39;; import { trim, getCookie } from \u0026#39;../utils/utils\u0026#39;; export default { namespace: \u0026#39;mymodel\u0026#39;, state: { form: {}, list: [], listDetail: [], goodsList: [], goodsListDetail: [], pagination: { pageSize: 10, total: 0, current: 1, }, imgList: [], //图片 }, subscriptions: { setup({ dispatch, history }) { history.listen(location =\u0026gt; { if (location.pathname !== \u0026#39;/xx/xxx\u0026#39;) return; if (!location.state || !location.state.xxxId) return; dispatch({ type: \u0026#39;fetch\u0026#39;, payload: location.state, }); }); }, }, effects: { // 接口。获取所有工厂店的列表 (步骤02) *getAllInfo({ payload }, { select, call, put }) { yield put({ type: \u0026#39;form\u0026#39;, payload, }); console.log(\u0026#39;params:\u0026#39; + JSON.stringify(payload)); let params = {}; params = payload; const response = yield call(getGoodsInfo, params); console.log(\u0026#39;smyhvae response:\u0026#39; + JSON.stringify(response)); if (response.error) return; yield put({ type: \u0026#39;allInfo\u0026#39;, payload: (response.data \u0026amp;\u0026amp; response.data.map(item =\u0026gt; ({ xx1: item.yy1, xx2: item.yy2, }))) || [], }); // response 里包含了接口返回给前端的默认图片数据 if (response \u0026amp;\u0026amp; response.data \u0026amp;\u0026amp; response.data[0] \u0026amp;\u0026amp; response.data[0].my_jpg) { let tempImgList = response.data[0].my_jpg.split(\u0026#39;,\u0026#39;); let imgList = []; if (tempImgList.length \u0026gt; 0) { tempImgList.forEach(item =\u0026gt; { imgList.push({ uid: item, name: \u0026#39;xxx.png\u0026#39;, status: \u0026#39;done\u0026#39;, thumbUrl: item, }); }); } // 通过 redux的方式 将 默认图片 传给 imgList console.log(\u0026#39;smyhvae payload imgList:\u0026#39; + JSON.stringify(imgList)); yield put({ type: \u0026#39;setImgList\u0026#39;, payload: imgList, }); } }, *setImgList({ payload }, { call, put }) { console.log(\u0026#39;model setImgList\u0026#39;); yield put({ type: \u0026#39;getImgList\u0026#39;, payload, }); }, }, reducers: { allInfo(state, action) { return { ...state, list: action.payload, }; }, getImgList(state, action) { return { ...state, imgList: action.payload, }; }, }, }; 上面的代码，可以规避 upload 组件的一些bug；而且可以在上传前，通过校验图片的尺寸、大小等，如果不满足条件，则弹出modal弹窗，阻止上传。\n大功告成。本文感谢 ld 同学的支持。\n更多内容，可以看本人的另外一篇文章：\nAntD框架的upload组件上传图片时使用customRequest方法自定义上传行为 其他问题 beforeUpload返回false后，文件仍然为上传中的状态 最后一段 有人说，前端开发，连卖菜的都会。可如果真的遇到技术难题，还是得找个靠谱的前端同学才行。这不，来看看前端码农日常：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/09-antd%E6%A1%86%E6%9E%B6%E7%9A%84upload%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","summary":"前言 本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。 前端做文件上传这个功能，是很有技术难度的。既然框架给我们提","title":"09-AntD框架的upload组件上传图片时遇到的一些坑"},{"content":"Set 数据结构 Set 数据结构的介绍 ES6 提供了 新的数据结构 Set。Set 类似于数组，但成员的值都是唯一的，没有重复的值。\nSet 的应用有很多。比如，在 H5 页面的搜索功能里，用户可能会多次搜索重复的关键字；但是在数据存储上，不需要存储重复的关键字。此时，我们就可以用 Set 来存储用户的搜索记录，Set 内部会自动判断值是否重复，如果重复，则不会进行存储，十分方便。\n生成 Set 数据结构 Set 本身就是一个构造函数，可通过 new Set() 生成一个 Set 的实例。\n举例 1：\n1 2 const set1 = new Set(); console.log(set1.size); // 打印结果：0 举例 2、可以接收一个数组作为参数，实现数组去重：\n1 2 3 4 5 6 7 8 9 10 const set2 = new Set([\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;, \u0026#39;张三\u0026#39;]); // 注意，这个数组里有重复的值 // 注意，这里的 set2 并不是数组，而是一个单纯的 Set 数据结构 console.log(set2); // {\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;} // 通过扩展运算符，拿到 set 中的元素（用逗号分隔的序列） // ...set2 // \u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34; // 注意，到这一步，才获取到了真正的数组 console.log([...set2]); // [\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;] 注意上方的第一行代码，虽然参数里传递的是数组结构，但拿到的 set2 不是数组结构，而是 Set 结构，而且里面元素是去重了的。通过 [...set2]就可以拿到set2对应的数组。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/09-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"Set 数据结构 Set 数据结构的介绍 ES6 提供了 新的数据结构 Set。Set 类似于数组，但成员的值都是唯一的，没有重复的值。 Set 的应用有很多。比如，在 H5 页面的","title":"09-内置对象扩展：Set数据结构"},{"content":"代码块 用{}包围起来的代码，就是代码块。\n在 ES5 语法中，代码块，只具有分组的作用，没有其他的用途。代码块中的内容，在外部是完全可见的。举例：\n1 2 3 4 5 6 7 { var a = 2; alert(\u0026#39;qianguyihao\u0026#39;); console.log(\u0026#39;永不止步\u0026#39;); } console.log(\u0026#39;a = \u0026#39; + a); 打印结果：（可以看出，虽然变量 a 是定义在代码块中的，但是在外部依然可以访问）\n1 2 永不止步 a = 2 流程控制语句 在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。\n流程控制语句分类 顺序结构\n选择结构：if 语句、switch 语句\n循环结构：while 语句、for 语句\n顺序结构 按照代码的先后顺序，依次执行。结构图如下：\nif 语句 if 语句有以下三种。\n1、条件判断语句 条件成立才执行。如果条件不成立，那就什么都不做。\n格式：\n1 2 3 if (条件表达式) { // 条件为真时，做的事情 } 2、条件分支语句 格式 1：\n1 2 3 4 5 6 7 if (条件表达式) { // 条件为真时，做的事情 } else { // 条件为假时，做的事情 } 格式 2：（多分支的 if 语句）\n1 2 3 4 5 6 7 8 9 10 11 12 if (条件表达式1) { // 条件1为真时，做的事情 } else if (条件表达式2) { // 条件1不满足，条件2满足时，做的事情 } else if (条件表达式3) { // 条件1、2不满足，条件3满足时，做的事情 } else { // 条件1、2、3都不满足时，做的事情 } 以上所有的语句体中，只执行其中一个。\n做个题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 根据BMI（身体质量指数）显示一个人的体型。 BMI指数，就是体重、身高的一个计算公式。公式是： BMI =体重÷身高的平方 比如，老师的体重是81.6公斤，身高是1.71米。 那么老师的BMI就是 81.6 ÷ 1.712 等于 27.906022365856163 过轻：低于18.5 正常：18.5-24.99999999 过重：25-27.9999999 肥胖：28-32 非常肥胖, 高于32 用JavaScript开发一个程序，让用户先输入自己的体重，然后输入自己的身高（弹出两次prompt框）。 计算它的BMI，根据上表，弹出用户的身体情况。比如“过轻” 、 “正常” 、“过重” 、 “肥胖” 、“非常肥胖”。 答案：\n写法 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //第一步，输入身高和体重 var height = parseFloat(prompt(\u0026#39;请输入身高，单位是米\u0026#39;)); var weight = parseFloat(prompt(\u0026#39;请输入体重，单位是公斤\u0026#39;)); //第二步，计算BMI指数 var BMI = weight / Math.pow(height, 2); //第三步，if语句来判断。注意跳楼现象 if (BMI \u0026lt; 18.5) { alert(\u0026#39;偏瘦\u0026#39;); } else if (BMI \u0026lt; 25) { alert(\u0026#39;正常\u0026#39;); } else if (BMI \u0026lt; 28) { alert(\u0026#39;过重\u0026#39;); } else if (BMI \u0026lt;= 32) { alert(\u0026#39;肥胖\u0026#39;); } else { alert(\u0026#39;非常肥胖\u0026#39;); } 写法 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //第一步，输入身高和体重 var height = parseFloat(prompt(\u0026#39;请输入身高，单位是米\u0026#39;)); var weight = parseFloat(prompt(\u0026#39;请输入体重，单位是公斤\u0026#39;)); //第二步，计算BMI指数 var BMI = weight / Math.pow(height, 2); //第三步，if语句来判断。注意跳楼现象 if (BMI \u0026gt; 32) { alert(\u0026#39;非常肥胖\u0026#39;); } else if (BMI \u0026gt;= 28) { alert(\u0026#39;肥胖\u0026#39;); } else if (BMI \u0026gt;= 25) { alert(\u0026#39;过重\u0026#39;); } else if (BMI \u0026gt;= 18.5) { alert(\u0026#39;正常\u0026#39;); } else { alert(\u0026#39;偏瘦\u0026#39;); } if 语句的嵌套 我们通过下面这个例子来引出 if 语句的嵌套。\n1 2 3 4 一个加油站为了鼓励车主多加油，所以加的多有优惠。 92号汽油，每升6元；如果大于等于20升，那么每升5.9； 97号汽油，每升7元；如果大于等于30升，那么每升6.95 编写JS程序，用户输入自己的汽油编号，然后输入自己加多少升，弹出价格。 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //第一步，输入 var bianhao = parseInt(prompt(\u0026#39;您想加什么油？填写92或者97\u0026#39;)); var sheng = parseFloat(prompt(\u0026#39;您想加多少升？\u0026#39;)); //第二步，判断 if (bianhao == 92) { //编号是92的时候做的事情 if (sheng \u0026gt;= 20) { var price = sheng * 5.9; } else { var price = sheng * 6; } } else if (bianhao == 97) { //编号是97的时候做的事情 if (sheng \u0026gt;= 30) { var price = sheng * 6.95; } else { var price = sheng * 7; } } else { alert(\u0026#39;不好意思，没有这个编号的汽油！\u0026#39;); } alert(\u0026#39;价格是\u0026#39; + price); switch 语句（条件分支语句） switch 语句也叫条件分支语句。\n语法格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 switch(表达式) { case 值1： 语句体1; break; case 值2： 语句体2; break; ... ... default： 语句体 n+1; break; } 解释：switch 可以理解为“开关、转换” 。case 可以理解为“案例、选项”。\nswitch 语句的执行流程 流程图如下：\n执行流程如下：\n（1）首先，计算出表达式的值，和 case 依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到 break 就会结束。\n（2）然后，如果所有的 case 都和表达式的值不匹配，就会执行 default 语句体部分。\nswitch 和 case 后面的值（含代码举例） switch 后面的括号里可以是表达式或者值， 通常是一个变量（通常做法是：先把表达式或者值存放到变量中）。\nJS 是属于弱类型语言，case 后面的值1、值2可以是 'a'、6、true 等任意数据类型的值，也可以是表达式。注意，在这里，字符串'6'和 数字 6 是不一样的。\n举例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let msg = \u0026#39;notice\u0026#39;; switch (msg) { case \u0026#39;notice\u0026#39;: console.log(\u0026#39;提示\u0026#39;); break; case \u0026#39;warning\u0026#39;: console.log(\u0026#39;警告\u0026#39;); break; case \u0026#39;error\u0026#39;: console.log(\u0026#39;错误\u0026#39;); break; default: console.log(\u0026#39;默认文案\u0026#39;); break; } 举例2：（case 后面的是表达式）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let age = 28; switch (true) { case age \u0026lt; 18: console.log(\u0026#39;未成年人\u0026#39;); break; case age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt;= 65: console.log(\u0026#39;还能干活儿\u0026#39;); break; case age \u0026gt; 65: console.log(\u0026#39;该退休了\u0026#39;); break; default: console.log(\u0026#39;默认文案\u0026#39;); break; } 代码解释：由于 switch 里的值是 true，所以，在众多的 case 语句中，会去匹配第一个符合 case true的语句，然后命中这条语句。\nswitch 语句的结束条件【非常重要】 情况 a：遇到 break 就结束，而不是遇到 default 就结束。（因为 break 在此处的作用就是退出 switch 语句）\n情况 b：执行到程序的末尾就结束。\n我们来看下面的两个例子就明白了。\ncase 穿透 switch 语句中的break可以省略，但一般不建议（对于新手而言）。否则结果可能不是你想要的，会出现一个现象：case 穿透。\n当然，如果你能利用好 case 穿透，会让代码写得十分优雅。\n举例 1：（case 穿透的情况）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 var num = 4; //switch判断语句 switch (num) { case 1: console.log(\u0026#39;星期一\u0026#39;); break; case 2: console.log(\u0026#39;星期二\u0026#39;); break; case 3: console.log(\u0026#39;星期三\u0026#39;); break; case 4: console.log(\u0026#39;星期四\u0026#39;); //break; case 5: console.log(\u0026#39;星期五\u0026#39;); //break; case 6: console.log(\u0026#39;星期六\u0026#39;); break; case 7: console.log(\u0026#39;星期日\u0026#39;); break; default: console.log(\u0026#39;你输入的数据有误\u0026#39;); break; } 上方代码的运行结果，可能会令你感到意外：\n1 2 3 星期四 星期五 星期六 上方代码的解释：因为在 case 4 和 case 5 中都没有 break，那语句走到 case 6 的 break 才会停止。\n举例 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //switch判断语句 var number = 5; switch (number) { default: console.log(\u0026#39;我是defaul语句\u0026#39;); // break; case 2: console.log(\u0026#39;第二个呵呵:\u0026#39; + number); //break; case 3: console.log(\u0026#39;第三个呵呵:\u0026#39; + number); break; case 4: console.log(\u0026#39;第四个呵呵:\u0026#39; + number); break; } 上方代码的运行结果，你也许会意外：\n1 2 3 我是defaul语句 第二个呵呵:5 第三个呵呵:5 上方代码的解释：代码走到 default 时，因为没有遇到 break，所以会继续往下走，直到遇见 break 或者走到程序的末尾。 从这个例子可以看出：switch 语句的结束与 default 的顺序无关。\nswitch 语句的实战举例：替换 if 语句 我们实战开发中，经常需要根据接口的返回码 retCode ，来让前端做不同的展示。\n这种场景是业务开发中经常出现的，请一定要掌握。然而，很多人估计会这么写：\n写法 1（不推荐。这种写法太挫了） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let retCode = 1003; // 返回码 retCode 的值可能有很多种情况 if (retCode == 0) { alert(\u0026#39;接口联调成功\u0026#39;); } else if (retCode == 101) { alert(\u0026#39;活动不存在\u0026#39;); } else if (retCode == 103) { alert(\u0026#39;活动未开始\u0026#39;); } else if (retCode == 104) { alert(\u0026#39;活动已结束\u0026#39;); } else if (retCode == 1001) { alert(\u0026#39;参数错误\u0026#39;); } else if (retCode == 1002) { alert(\u0026#39;接口频率限制\u0026#39;); } else if (retCode == 1003) { alert(\u0026#39;未登录\u0026#39;); } else if (retCode == 1004) { alert(\u0026#39;（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试\u0026#39;); } else { // 其他异常返回码 alert(\u0026#39;系统君失联了，请稍候再试\u0026#39;); } 如果你是按照上面的 if else的方式来写各种条件判断，说明你的代码水平太初级了，会被人喷的，千万不要这么写。这种写法，容易导致嵌套太深，可读性很差。\n那要怎么改进呢？继续往下看。\n写法 2（推荐。通过 return 的方式，将上面的写法进行改进） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 let retCode = 1003; // 返回码 retCode 的值可能有很多种情况 handleRetCode(retCode); // 方法：根据接口不同的返回码，处理前端不同的显示状态 function handleRetCode(retCode) { if (retCode == 0) { alert(\u0026#39;接口联调成功\u0026#39;); return; } if (retCode == 101) { alert(\u0026#39;活动不存在\u0026#39;); return; } if (retCode == 103) { alert(\u0026#39;活动未开始\u0026#39;); return; } if (retCode == 104) { alert(\u0026#39;活动已结束\u0026#39;); return; } if (retCode == 1001) { alert(\u0026#39;参数错误\u0026#39;); return; } if (retCode == 1002) { alert(\u0026#39;接口频率限制\u0026#39;); return; } if (retCode == 1003) { alert(\u0026#39;未登录\u0026#39;); return; } if (retCode == 1004) { alert(\u0026#39;（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试\u0026#39;); return; } // 其他异常返回码 alert(\u0026#39;系统君失联了，请稍候再试\u0026#39;); return; } 上面的写法 2，是比较推荐的写法：直接通过 return 的方式，让 function 里的代码不再继续往下走，这就达到目的了。对了，因为要用到 return ，所以整段代码是封装到一个 function 里的。\n如果你以后看到有前端小白采用的是写法 1，请一定要把写法 2传授给他：不需要那么多的 if else，直接用 return 返回就行了。\n写法 3（推荐。将 if else 改为 switch） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 let retCode = 1003; // 返回码 retCode 的值可能有很多种情况 switch (retCode) { case 0: alert(\u0026#39;接口联调成功\u0026#39;); break; case 101: alert(\u0026#39;活动不存在\u0026#39;); break; case 103: alert(\u0026#39;活动未开始\u0026#39;); break; case 104: alert(\u0026#39;活动已结束\u0026#39;); break; case 1001: alert(\u0026#39;参数错误\u0026#39;); break; case 1002: alert(\u0026#39;接口频率限制\u0026#39;); break; case 1003: alert(\u0026#39;未登录\u0026#39;); break; case 1004: alert(\u0026#39;（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试\u0026#39;); break; // 其他异常返回码 default: alert(\u0026#39;系统君失联了，请稍候再试\u0026#39;); break; } 在实战开发中，方式 3 是非常推荐的写法，甚至比方式 2 还要好。我们尽量不要写太多的 if 语句，避免代码嵌套过深。\nswitch 语句的优雅写法：适时地去掉 break 我们先来看看下面这段代码：（不推荐）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 let day = 2; switch (day) { case 1: console.log(\u0026#39;work\u0026#39;); break; case 2: console.log(\u0026#39;work\u0026#39;); break; case 3: console.log(\u0026#39;work\u0026#39;); break; case 4: console.log(\u0026#39;work\u0026#39;); break; case 5: console.log(\u0026#39;work\u0026#39;); break; case 6: console.log(\u0026#39;relax\u0026#39;); break; case 7: console.log(\u0026#39;relax\u0026#39;); break; default: break; } 上面的代码，咋一看，好像没啥毛病。但你有没有发现，重复代码太多了？\n实战开发中，凡是有重复的地方，我们都必须要想办法简化。写代码就是在不断重构的过程。\n上面的代码，可以改进如下：（推荐，非常优雅）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 let day = 2; switch (day) { case 1: case 2: case 3: case 4: case 5: console.log(\u0026#39;work\u0026#39;); break; // 在这里放一个 break case 6: case 7: console.log(\u0026#39;relax\u0026#39;); break; // 在这里放一个 break default: break; } } 你没看错，就是上面的这种写法，能达到同样的效果，非常优雅。\n小白可能认为这样的写法可读性不强，所以说他是小白。我可以明确告诉你，改进后的这种写法，才是最优雅的、最简洁、可读性最好的。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/09-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84if%E5%92%8Cswitch/","summary":"代码块 用{}包围起来的代码，就是代码块。 在 ES5 语法中，代码块，只具有分组的作用，没有其他的用途。代码块中的内容，在外部是完全可见的。举例： 1 2","title":"09-流程控制语句：选择结构（if和switch）"},{"content":"本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。\n我在上一篇文章《前端AntD框架的upload组件上传图片时遇到的一些坑》中讲到：AntD 的 upload 组件有很多坑，引起了很多人的关注。折腾过的人，自然明白其中的苦楚。\n今天这篇文章，我们继续来研究 AntD 的 upload 组件的另一个坑。\n备注：本文写于2020-06-11，使用的 antd 版本是 3.13.6。\n使用 AntD 的 upload 组件做图片的上传，效果演示 因为需要上传多张图片，所以采用的是照片墙的形式。上传成功后的界面如下：\n（1）上传中：\n（2）上传成功：\n（3）图片预览：\n代码实现 首先，你需要让后台同学提供好图片上传的接口。上一篇文章中，我们是把接口调用直接写在了 \u0026lt;Upload\u0026gt; 标签的 action 属性当中。但如果你在调接口的时候，动作很复杂（比如根据业务要求，需要连续调两个接口才能上传图片，或者在调接口时还要做其他的事情），这个 action 方法就无法满足需求了。那该怎么做呢？\n好在 AntD 的 upload 组件给我们提供了 customRequest这个方法：\n关于customRequest 这个方法， AntD 官方并没有给出示例，他们只是在 GitHub 上给出了这样一个简短的介绍：\n但这个方法怎么用呢？用的时候，会遇到什么问题呢？AntD 官方没有说。我在网上搜了半天，也没看到比较完整的、切实可行的 Demo。我天朝地大物博，网络资料浩如烟海，AntD 可是口口声声被人们号称是天朝最好用的管理后台的样式框架。可如今，却面临这样的局面。我看着你们，满怀羡慕。\n既然如此，那我就自己研究吧。折腾了一天，总算是把 customRequest 的坑踩得差不多了。\n啥也不说了，直接上代码。\n采用 AntD框架的 upload 组件的 customRequest 方法，自定义上传行为。核心代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 import React, { PureComponent } from \u0026#39;react\u0026#39;; import { Button, Card, Form, message, Upload, Icon, Modal, Row, Col } from \u0026#39;antd\u0026#39;; import { connect } from \u0026#39;dva\u0026#39;; import { queryMyData, submitData } from \u0026#39;../api\u0026#39;; import { uploadImage } from \u0026#39;../../utils/wq.img.upload\u0026#39;; import styles from \u0026#39;../../utils/form.less\u0026#39;; const FormItem = Form.Item; @Form.create() export default class PicturesWall extends PureComponent { constructor(props) { super(props); const { id } = this.props.match.params; this.state = { id, img: undefined, // 从接口拿到的图片字段 imgList: [], // 展示在 antd图片组件上的数据 previewVisible: false, previewImage: \u0026#39;\u0026#39;, }; } componentDidMount() { const { id } = this.state; id \u0026amp;\u0026amp; this.queryData(); } // 调接口，查询已有的数据 queryData() { const { id } = this.state; queryMyData({ id, }) .then(({ ret, data }) =\u0026gt; { if (ret == 0 \u0026amp;\u0026amp; data \u0026amp;\u0026amp; data.list \u0026amp;\u0026amp; data.list.length) { const item = data.list[0]; const img = data.img; const imgList = item.img ? [ { uid: \u0026#39;1\u0026#39;, // 注意，这个uid一定不能少，否则展示失败 name: \u0026#39;hehe.png\u0026#39;, status: \u0026#39;done\u0026#39;, url: img, }, ] : []; this.setState({ img, imgList, }); } else { return Promise.reject(); } }) .catch(() =\u0026gt; { message.error(\u0026#39;查询出错，请重试\u0026#39;); }); } handleCancel = () =\u0026gt; this.setState({ previewVisible: false }); // 方法：图片预览 handlePreview = (file) =\u0026gt; { console.log(\u0026#39;smyhvae handlePreview:\u0026#39; + JSON.stringify(file)); this.setState({ previewImage: file.url || file.thumbUrl, previewVisible: true, }); }; // 参考链接：https://www.jianshu.com/p/f356f050b3c9 handleBeforeUpload = (file) =\u0026gt; { console.log(\u0026#39;smyhvae handleBeforeUpload file:\u0026#39; + JSON.stringify(file)); console.log(\u0026#39;smyhvae handleBeforeUpload file.file:\u0026#39; + JSON.stringify(file.file)); console.log(\u0026#39;smyhvae handleBeforeUpload file type:\u0026#39; + JSON.stringify(file.type)); //限制图片 格式、size、分辨率 const isJPG = file.type === \u0026#39;image/jpeg\u0026#39;; const isJPEG = file.type === \u0026#39;image/jpeg\u0026#39;; const isGIF = file.type === \u0026#39;image/gif\u0026#39;; const isPNG = file.type === \u0026#39;image/png\u0026#39;; const isLt2M = file.size / 1024 / 1024 \u0026lt; 1; if (!(isJPG || isJPEG || isPNG)) { Modal.error({ title: \u0026#39;只能上传JPG、JPEG、PNG格式的图片~\u0026#39;, }); } else if (!isLt2M) { Modal.error({ title: \u0026#39;图片超过1M限制，不允许上传~\u0026#39;, }); } return (isJPG || isJPEG || isPNG) \u0026amp;\u0026amp; isLt2M; }; // checkImageWH 返回一个promise 检测通过返回resolve 失败返回reject阻止图片上传 checkImageWH(file) { return new Promise(function (resolve, reject) { let filereader = new FileReader(); filereader.onload = (e) =\u0026gt; { let src = e.target.result; const image = new Image(); image.onload = function () { // 获取图片的宽高 file.width = this.width; file.height = this.height; resolve(); }; image.onerror = reject; image.src = src; }; filereader.readAsDataURL(file); }); } // 图片上传 doImgUpload = (options) =\u0026gt; { const { onSuccess, onError, file, onProgress } = options; // start：进度条相关 // 伪装成 handleChange里面的图片上传状态 const imgItem = { uid: \u0026#39;1\u0026#39;, // 注意，这个uid一定不能少，否则上传失败 name: \u0026#39;hehe.png\u0026#39;, status: \u0026#39;uploading\u0026#39;, url: \u0026#39;\u0026#39;, percent: 99, // 注意不要写100。100表示上传完成 }; this.setState({ imgList: [imgItem], }); // 更新 imgList // end：进度条相关 const reader = new FileReader(); reader.readAsDataURL(file); // 读取图片文件 reader.onload = (file) =\u0026gt; { const params = { myBase64: file.target.result, // 把 本地图片的base64编码传给后台，调接口，生成图片的url }; // 上传图片的base64编码，调接口后，返回 imageId uploadImage(params) .then((res) =\u0026gt; { console.log(\u0026#39;smyhvae doImgUpload:\u0026#39; + JSON.stringify(res)); console.log(\u0026#39;smyhvae 图片上传成功：\u0026#39; + res.imageUrl); const imgItem = { uid: \u0026#39;1\u0026#39;, // 注意，这个uid一定不能少，否则上传失败 name: \u0026#39;hehe.png\u0026#39;, status: \u0026#39;done\u0026#39;, url: res.imageUrl, // url 是展示在页面上的绝对链接 imgUrl: res.imageUrl, // imgUrl 是存到 db 里的相对链接 // response: \u0026#39;{\u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;}\u0026#39;, }; this.setState({ imgList: [imgItem], }); // 更新 imgList }) .catch((e) =\u0026gt; { console.log(\u0026#39;smyhvae 图片上传失败:\u0026#39; + JSON.stringify(e || \u0026#39;\u0026#39;)); message.error(\u0026#39;图片上传失败，请重试\u0026#39;); }); }; }; handleChange = ({ file, fileList }) =\u0026gt; { console.log(\u0026#39;smyhvae handleChange file:\u0026#39; + JSON.stringify(file)); console.log(\u0026#39;smyhvae handleChange fileList:\u0026#39; + JSON.stringify(fileList)); if (file.status == \u0026#39;removed\u0026#39;) { this.setState({ imgList: [], }); } }; submit = (e) =\u0026gt; { e.preventDefault(); this.props.form.validateFields((err, fieldsValue) =\u0026gt; { if (err) { return; } const { id, imgList } = this.state; const tempImgList = imgList.filter((item) =\u0026gt; item.status == \u0026#39;done\u0026#39;); // 筛选出 status = done 的图片 const imgArr = []; tempImgList.forEach((item) =\u0026gt; { imgArr.push(item.imgUrl); // imgArr.push(item.url); }); submitData({ id, img: imgArr[0] || \u0026#39;\u0026#39;, // 1、暂时只传一张图片给后台。如果传多张图片，那么，upload组件需要进一步完善，比较麻烦，以后有需求再优化。2、如果图片字段是选填，那就用空字符串兜底 }) .then((res) =\u0026gt; { if (res.ret == 0) { message.success(`${id ? \u0026#39;修改\u0026#39; : \u0026#39;新增\u0026#39;}成功，自动跳转中...`); } else if (res.ret == 201 || res.ret == 202 || res.ret == 203 || res.ret == 6) { return Promise.reject(res.msg); } else { return Promise.reject(); } }) .catch((e) =\u0026gt; { message.error(e || \u0026#39;提交失败，请重试\u0026#39;); }); }); }; render() { const { id, imgList } = this.state; console.log(\u0026#39;smyhvae render imgList:\u0026#39; + JSON.stringify(imgList)); const { getFieldDecorator } = this.props.form; const formItemLayout = { labelCol: { span: 3 }, wrapperCol: { span: 10 }, }; const buttonItemLayout = { wrapperCol: { span: 10, offset: 3 }, }; const uploadButton = ( \u0026lt;div\u0026gt; \u0026lt;Icon type=\u0026#34;plus\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;ant-upload-text\u0026#34;\u0026gt;Upload\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); return ( \u0026lt;Card title={id ? \u0026#39;修改信息\u0026#39; : \u0026#39;新增信息\u0026#39;}\u0026gt; \u0026lt;Form onSubmit={this.submit} layout=\u0026#34;horizontal\u0026#34;\u0026gt; {/* 新建图片、编辑图片 */} \u0026lt;FormItem label=\u0026#34;图片\u0026#34; {...formItemLayout}\u0026gt; {getFieldDecorator(\u0026#39;img\u0026#39;, { rules: [{ required: false, message: \u0026#39;请上传图片\u0026#39; }], })( \u0026lt;Upload action=\u0026#34;2\u0026#34; customRequest={this.doImgUpload} listType=\u0026#34;picture-card\u0026#34; fileList={imgList} onPreview={this.handlePreview} beforeUpload={this.handleBeforeUpload} onChange={this.handleChange} \u0026gt; {imgList.length \u0026gt;= 1 ? null : uploadButton} \u0026lt;/Upload\u0026gt; )} \u0026lt;/FormItem\u0026gt; \u0026lt;Row\u0026gt; \u0026lt;Col span={3} /\u0026gt; \u0026lt;Col span={18} className={styles.graytext}\u0026gt; 注：图片支持JPG、JPEG、PNG格式，小于1M，最多上传1张 \u0026lt;/Col\u0026gt; \u0026lt;/Row\u0026gt; \u0026lt;FormItem {...buttonItemLayout}\u0026gt; \u0026lt;Button type=\u0026#34;primary\u0026#34; htmlType=\u0026#34;submit\u0026#34;\u0026gt; 提交 \u0026lt;/Button\u0026gt; \u0026lt;/FormItem\u0026gt; \u0026lt;/Form\u0026gt; {/* 图片点开预览 */} \u0026lt;Modal visible={this.state.previewVisible} footer={null} onCancel={this.handleCancel}\u0026gt; \u0026lt;img alt=\u0026#34;example\u0026#34; style={{ width: \u0026#39;100%\u0026#39; }} src={this.state.previewImage} /\u0026gt; \u0026lt;/Modal\u0026gt; \u0026lt;/Card\u0026gt; ); } } 参考链接 注意file的格式：https://www.lmonkey.com/t/oREQA5XE1\nDemo在线演示：\nhttps://stackoverflow.com/questions/58128062/using-customrequest-in-ant-design-file-upload\nhttps://stackblitz.com/edit/so-58128062-upload-progress\nfileList 格式在线演示：\nhttps://stackoverflow.com/questions/51514757/action-function-is-required-with-antd-upload-control-but-i-dont-need-it\nhttps://codesandbox.io/s/rl7ooo544q\nant design Upload组件的使用总结：https://www.jianshu.com/p/0aa4612af987\nantd上传功能的CustomRequest：https://mlog.club/article/3832743\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/10-antd%E6%A1%86%E6%9E%B6%E7%9A%84upload%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%B6%E4%BD%BF%E7%94%A8customrequest%E6%96%B9%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%BC%A0%E8%A1%8C%E4%B8%BA/","summary":"本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。 我在上一篇文章《前端AntD框架的upload组件上传图片时遇","title":"10-AntD框架的upload组件上传图片时使用customRequest方法自定义上传行为"},{"content":"前言：异步和回调 异步 JavaScript 的执行环境是单线程。\n所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。\n异步模式可以一起执行多个任务。常见的异步模式有以下几种：\n定时器\n接口调用\n事件函数\n今天这篇文章，我们重点讲一下接口调用。接口调用里，重点讲一下Promise。\n接口调用的方式 js 中常见的接口调用方式，有以下几种：\n原生 ajax、基于 jQuery 的 ajax Promise Fetch axios 多次异步调用的顺序 多次异步调用的结果，顺序可能不同步。\n异步调用的结果如果存在依赖，则需要通过回调函数进行嵌套。\n回调地狱的举例 假设买菜、做饭、洗碗、倒厨余垃圾都是异步的。\n但真实的场景中，实际的操作流程是：买菜成功之后，才能开始做饭。做饭成功后，才能开始洗碗。洗碗结束后， 再倒厨余垃圾。这里的一系列动作就涉及到了多层嵌套调用，也就是回调地狱。\n在 ES5 中，当进行多层嵌套回调时，会导致代码层次过多，很难进行后续维护和二次开发；而且会导致回调地狱的问题。ES6 中的 Promise 就可以解决这两个问题。\nPromise 概述 为什么需要 Promise？ 如上一段所述，Javascript 是⼀⻔单线程语⾔。早期我们解决异步场景时，⼤部分情况都是通过回调函数来进⾏。\n例如在浏览器中发送 ajax 请求，就是常⻅的⼀个异步场景，发送请求后，需要等待一段时间，等服务端响应之后我们才能拿到结果。如果我们希望在异步结束之后执⾏某个操作，就只能通过回调函数这样的⽅式进⾏操作。\n1 2 3 4 5 6 7 8 9 var dynamicFunc = function (callback) { setTimeout(function () { callback(); }, 1000); }; dynamicFunc(function () { console.log(\u0026#39;qian gu\u0026#39;); }); 例如上⾯这个例⼦，dynamicFunc 就是⼀个异步函数，⾥⾯ setTimeout 会在 1s 之后调⽤传⼊的 callback 函数。按照上⾯的调⽤⽅式，最终 1s 之后，会打印 qian gu 这个结果。\n同样的，如果后续还有内容需要在异步函数结束时输出，就需要多个异步函数进⾏嵌套，⾮常不利于后续的维护，而且会导致回调地狱的问题：\n1 2 3 4 5 6 setTimeout(function () { console.log(\u0026#39;qiangu1\u0026#39;); setTimeout(function () { console.log(\u0026#39;qiangu2\u0026#39;); }, 2000); }, 1000); 为了能使回调函数以更优雅的⽅式进⾏调⽤，在 ES6 语法中，新增了⼀个名为 Promise 的新规范。\nPromise 的介绍和优点 ES6 中的 Promise 是异步编程的一种方案。从语法上讲，Promise 是一个对象，它可以获取异步操作的消息。\nPromise 对象, 可以用同步的表现形式来书写异步代码（也就是说，代码看起来是同步的，但本质上的运行过程是异步的）。使用 Promise 主要有以下好处：\n可以很好地解决回调地狱的问题（避免了层层嵌套的回调函数）。\n语法非常简洁、可读性强，便于后期维护。Promise 对象提供了简洁的 API，使得控制异步操作更加容易。\nPromise 基础 Promise 的基本用法 （1）通过 new Promise() 构造出一个 Promise 实例。Promise 的构造函数中传入一个参数，这个参数是一个函数，该函数用于处理异步任务。\n（2）函数中传入两个参数：resolve 和 reject，分别表示异步执行成功后的回调函数和异步执行失败后的回调函数。代表着我们需要改变当前实例的状态到已完成或是已拒绝。\n（3）通过 promise.then() 处理返回结果（这里的 promise 指的是 Promise 实例）。\n接下来，我们来具体看看， promise 的代码是怎么写的。\nPromise 处理异步任务的过程 通过 Promise 处理异步任务的典型写法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 第一步：model层的接口封装 function promiseA() { return new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如 ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } // 第二步：业务层的接口调用。这里的 data 就是 从 resolve 和 reject 传过来的，也就是从接口拿到的数据 promiseA() .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(data); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 上方代码中，当从接口返回的数据data.retCode的值（接口返回码）不同时，可能会走 resolve，也可能会走 reject，这个由你自己的业务决定。\n上面的写法中，是将 promise 实例定义成了一个函数 PromiseA。我们也可以将 promise 实例定义成一个变量 promiseB，达到的效果是一模一样的。写法如下：（写法上略有区别）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 第一步：model层的接口封装 const promiseB = new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); // 第二步：业务层的接口调用。这里的 data 就是 从 resolve 和 reject 传过来的，也就是从接口拿到的数据 promiseB .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(data); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 捕获 reject 异常状态的两种写法 我们有两种写法可以捕获并处理 reject 异常状态。上一小段中，用的就是其中一种写法。\n这两种写法的代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 第一步：model层的接口封装 function promiseA() { return new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如 ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } const onResolve = function (value) { console.log(value); }; const onReject = function (e) { console.log(e); }; // 写法1：通过 catch 方法捕获 状态变为已拒绝时的 promise promiseA().then(onResolve).catch(onReject); // 写法2：then 可以传两个参数，第⼀个参数为 resolve 后执⾏，第⼆个参数为 reject 后执⾏ promiseA().then(onResolve, onReject); // 【错误写法】写法3：通过 try catch 捕获 状态变为已拒绝时的 promise // 这种写法是错误的，因为 try catch只能捕获同步代码里的异常，而 promise.reject() 是异步代码。 try { promiseA().then(onResolve); } catch (e) { // 语法上，catch必须要传入一个参数，否则报错 onReject(e); } 需要注意的是：\n（1）上面的写法 3 是错误的。运行之后，控制台会报如下错误：\n解释如下：\ntry-catch 主要用于捕获异常，注意，这里的异常是指同步函数的异常。如果 try 里面的异步方法出现了异常，此时 catch 是无法捕获到异常的。\n原因是：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言（比如 promise）promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。\n（2）写法1中，promiseA().then().catch()和promiseA().catch().then()区别在于：前者可以捕获到 then 里面的异常，后者不可以。\n小结 1、promise 有三种状态：等待中、成功、失败。等待中状态可以更改为成功或失败，已经更改过状态后⽆法继续更改（例如从失败改为成功）。\n2、promise 实例中需要传⼊⼀个函数，他接受两个函数参数，执⾏第⼀个参数之后就会改变当前 promise 为「成功」状态，执⾏第⼆个参数之后就会变为「失败」状态。\n3、通过 .then ⽅法，即可在上⼀个 promise 达到成功时继续执⾏下⼀个函数或 promise。同时通过 resolve 或 reject 时传⼊参数，即可给下⼀个函数或 promise 传⼊初始值。\n4、失败的 promise，后续可以通过 promise 自带的 .catch ⽅法或是 .then ⽅法的第⼆个参数进⾏捕获。\nPromise 规范 Promise 规范解读 Promise 是⼀个拥有 then ⽅法的对象或函数。任何符合 promise 规范的对象或函数都可以成为 Promise。\n关于promise 规范的详细解读，可以看下面这个链接：\nPromises/A+ 规范：https://promisesaplus.com/ promise 对象的 3 个状态 初始化（等待中）：pending\n成功：fulfilled\n失败：rejected\n（1）当 new Promise()执行之后，promise 对象的状态会被初始化为pending，这个状态是初始化状态。new Promise()这行代码，括号里的内容是同步执行的。括号里定义一个 function，function 有两个参数：resolve 和 reject。如下：\n如果请求成功了，则执行 resolve()，此时，promise 的状态会被自动修改为 fulfilled。\n如果请求失败了，则执行 reject()，此时，promise 的状态会被自动修改为 rejected\n（2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2：\n如果 promise 的状态为 fulfilled（意思是：如果请求成功），则执行 function1 里的内容\n如果 promise 的状态为 rejected（意思是，如果请求失败），则执行 function2 里的内容\n另外，resolve()和 reject()这两个方法，是可以给 promise.then()传递参数的。\n完整代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 let promise = new Promise((resolve, reject) =\u0026gt; { //进来之后，状态为pending console.log(\u0026#39;111\u0026#39;); //这行代码是同步的 //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器） if (异步的ajax请求成功) { console.log(\u0026#39;333\u0026#39;); resolve(\u0026#39;haha\u0026#39;); //如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fulfilled } else { reject(\u0026#39;555\u0026#39;); //如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected } }); console.log(\u0026#39;222\u0026#39;); //调用promise的then() promise.then( (successMsg) =\u0026gt; { //如果promise的状态为fulfilled，则执行这里的代码 console.log(successMsg, \u0026#39;成功了\u0026#39;); }, (errorMsg) =\u0026gt; { //如果promise的状态为rejected，则执行这里的代码 console.log(errorMsg, \u0026#39;失败了\u0026#39;); } ); 如何封装异步操作为 promise Promise 封装异步任务 传统写法：\n写法 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 定义一个异步的延迟函数：异步函数结束1秒之后，再执行cb回调函数 function fun1(cb) { setTimeout(function () { console.log(\u0026#39;即将执行cb回调函数\u0026#39;); cb(); }, 1000); } // 先执行异步函数 fun1，再执行回调函数 myCallback fun1(myCallback); // 定义回调函数 function myCallback() { console.log(\u0026#39;我是延迟执行的cb回调函数\u0026#39;); } 写法 2：（精简版，更常见）\n1 2 3 4 5 6 7 8 9 // 定义一个异步的延迟函数：异步函数结束1秒之后，再执行cb回调函数 function fun1(cb) { setTimeout(cb, 1000); } // 先执行异步函数fun1，再执行回调函数 fun1(function () { console.log(\u0026#39;我是延迟执行的cb回调函数\u0026#39;); }); 上⾯的例⼦就是最传统的写法，在异步结束后通过传入回调函数的方式执⾏函数。\n学习 Promise 之后，我们可以将这个异步函数封装为 Promise，如下。\nPromise 写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function fun2() { return new Promise((resolve) =\u0026gt; { setTimeout(resolve, 1000); }); } /* 【重要】上面的 fun2 也可以写成： function fun2() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(); }, 1000); }); } */ // 先执行异步函数fun1，再执行回调函数 fun2().then(() =\u0026gt; { console.log(\u0026#39;我是延迟执行的回调函数\u0026#39;); }); Promise 封装 Ajax 请求 传统写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 定义 ajax 请求：传入回调函数 success 和 fail function ajax(url, success, fail) { var client = new XMLHttpRequest(); client.open(\u0026#39;GET\u0026#39;, url); client.onreadystatechange = function () { if (this.readyState !== 4) { return; } if (this.status === 200) { success(this.response); } else { fail(new Error(this.statusText)); } }; client.send(); } // 执行 ajax 请求 ajax( \u0026#39;/ajax.json\u0026#39;, function () { console.log(\u0026#39;qianguyihao 成功\u0026#39;); }, function () { console.log(\u0026#39;失败\u0026#39;); } ); 上面的传统写法里，定义和执行 ajax 时需要传⼊ success 和 fail 这两个回调函数，进而执行回调函数。\n有了 Promise 之后，我们不需要传入回调函数，而是：\n先将 promise 实例化；\n然后在原来执行回调函数的地方，改为执行对应的改变 promise 状态的函数；\n并通过 then \u0026hellip; catch 或者 then \u0026hellip;then 等写法，实现链式调用，提高代码可读性。\n和传统写法相比，promise 在写法上的大致区别是：定义异步函数的时候，将 callback 改为 resolve 和 reject，待状态改变之后，我们在外面控制具体执行哪些函数。\nPromise 写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const request = require(\u0026#39;request\u0026#39;); // Promise 定义接口 function request1() { return new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, (response) =\u0026gt; { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); } request1() .then((res1) =\u0026gt; { // 接口1请求成功后，打印接口1的返回结果 console.log(res1); return request2(); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 总结 了解这些内容之后， 你已经对 Promise 有了基本了解。下一篇文章，我们来讲一讲 Promise在实战开发的常见用法。\n参考链接 当面试官问你 Promise 的时候，他究竟想听到什么？\n手写一个 Promise/A+,完美通过官方 872 个测试用例\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/10-promise%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/","summary":"前言：异步和回调 异步 JavaScript 的执行环境是单线程。 所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，也就是一次只能完成一项任务，这个任务执","title":"10-Promise入门详解"},{"content":"搭建开发环境 官方文档：https://reactnative.cn/docs/getting-started.html\n安装Node、homebrew、Watchman 安装 homebrew：\n安装 watchman：\n1 brew install watchman Watchman则是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager 可以快速捕捉文件的变化从而实现实时刷新）。\n安装 React Native 的命令行工具（react-native-cli） 安装 react-native-cli：\n1 npm install -g react-native-cli React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。\n创建新项目 1 react-native init MyApp --version 0.44.3 编译并运行 React Native 应用 在 ios 模拟器上运行：\n1 react-native run-ios 调试 官网文档：https://reactnative.cn/docs/debugging.html\n访问 App 内的开发菜单 如果是在 iOS 模拟器中运行，还可以按下Command + D快捷键，Android 模拟器对应的则是Command⌘ + M（windows 上可能是 F1 或者 F2），或是直接在命令行中运行adb shell input keyevent 82来发送菜单键命令。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/10-react-navive%E5%88%9D%E8%AF%86/","summary":"搭建开发环境 官方文档：https://reactnative.cn/docs/getting-started.html 安装Node、home","title":"10-React Navive初识"},{"content":"前言 循环语句：通过循环语句可以反复的执行一段代码多次。\nfor 循环 for 循环的语法 语法：\n1 2 3 for(①初始化表达式; ②条件表达式; ④更新表达式){ ③语句... } 执行流程：\n1 2 3 4 5 6 7 ①执行初始化表达式，初始化变量（初始化表达式只会执行一次） ②执行条件表达式，判断是否执行循环： 如果为true，则执行循环③ 如果为false，终止循环 ④执行更新表达式，更新表达式执行完毕继续重复② for 循环举例：\n1 2 3 for (var i = 1; i \u0026lt;= 100; i++) { console.log(i); } 上方代码的解释：\nfor 循环举例 1 2 3 for (var i = 1; i \u0026lt; 13; i = i + 4) { console.log(i); } 上方代码的遍历步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 程序一运行，将执行var i = 1;这条语句， 所以i的值是1。 然后程序会验证一下i \u0026lt; 13是否满足，1\u0026lt;13是真，所以执行一次循环体（就是大括号里面的语句）。 执行完循环体之后，会执行i=i+4这条语句，所以i的值，是5。 程序会会验证一下i \u0026lt; 13是否满足，5\u0026lt;13是真，所以执行一次循环体（就是大括号里面的语句）。 执行完循环体之后，会执行i=i+4这条语句，所以i的值，是9。 程序会会验证一下i \u0026lt; 13是否满足，9\u0026lt;13是真，所以执行一次循环体（就是大括号里面的语句）。 执行完循环体之后，会执行i=i+4这条语句，所以i的值，是13。 程序会会验证一下i \u0026lt; 13是否满足，13\u0026lt;13是假，所以不执行循环体了，将退出循环。 最终输出输出结果为：1、5、9 接下来做几个题目。\n题目 1：\n1 2 3 4 for (var i = 1; i \u0026lt; 10; i = i + 3) { i = i + 1; console.log(i); } 输出结果：2、6、10\n题目 2：\n1 2 for (var i = 1; i \u0026lt;= 10; i++) {} console.log(i); 输出结果：11\n题目 3：\n1 2 for (var i = 1; i \u0026lt; 7; i = i + 3) {} console.log(i); 输出结果：7\n题目 4：\n1 2 3 for (var i = 1; i \u0026gt; 0; i++) { console.log(i); } 死循环。\nwhile 循环语句 while 循环 语法：\n1 2 3 while(条件表达式){ 语句... } 执行流程：\n1 2 3 4 5 6 7 while语句在执行时，先对条件表达式进行求值判断： 如果值为true，则执行循环体： 循环体执行完毕以后，继续对表达式进行判断 如果为true，则继续执行循环体，以此类推 如果值为false，则终止循环 如果有必要的话，我们可以使用 break 来终止循环。\ndo\u0026hellip;while 循环 语法：\n1 2 3 do{ 语句... }while(条件表达式) 执行流程：\n1 2 3 4 5 do...while语句在执行时，会先执行循环体： 循环体执行完毕以后，在对while后的条件表达式进行判断： 如果结果为true，则继续执行循环体，执行完毕继续判断以此类推 如果结果为false，则终止循环 while 循环和 do\u0026hellip;while 循环的区别 这两个语句的功能类似，不同的是：\nwhile 是先判断后执行，而 do\u0026hellip;while 是先执行后判断。 也就是说，do\u0026hellip;while 可以保证循环体至少执行一次，而 while 不能。\nwhile 循环举例 题目：假如投资的年利率为 5%，试求从 1000 块增长到 5000 块，需要花费多少年？\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; /* * 假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年 * * 1000 1000*1.05 * 1050 1050*1.05 */ //定义一个变量，表示当前的钱数 var money = 1000; //定义一个计数器 var count = 0; //定义一个while循环来计算每年的钱数 while (money \u0026lt; 5000) { money *= 1.05; //使count自增 count++; } console.log(money); console.log(\u0026#39;一共需要\u0026#39; + count + \u0026#39;年\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n1 2 3 5003.18854203379 一共需要33年 另外，你也可以自己算一下，假如投资的年利率为 5%，从 1000 块增长到 1 万块，需要花费 48 年：\n1 2 10401.269646942128 一共需要48年 break 和 continue 这个知识点非常重要。\nbreak break 可以用来退出 switch 语句或退出整个循环语句（循环语句包括 for 循环、while 循环。不包括 if。if 里不能用 break 和 continue，否则会报错）。\nbreak 会立即终止离它最近的那个循环语句。\n可以为循环语句创建一个 label，来标识当前的循环（格式：label:循环语句）。使用 break 语句时，可以在 break 后跟着一个 label，这样 break 将会结束指定的循环，而不是最近的。\n举例 1：通过 break 终止循环语句\n1 2 3 4 5 6 for (var i = 0; i \u0026lt; 5; i++) { console.log(\u0026#39;i的值:\u0026#39; + i); if (i == 2) { break; // 注意，虽然在 if 里 使用了 break，但这里的 break 是服务于外面的 for 循环。 } } 打印结果：\n1 2 3 i的值:0 i的值:1 i的值:2 举例 2：label 的使用\n1 2 3 4 5 6 7 outer: for (var i = 0; i \u0026lt; 5; i++) { console.log(\u0026#39;外层循环 i 的值：\u0026#39; + i); for (var j = 0; j \u0026lt; 5; j++) { break outer; // 直接跳出outer所在的外层循环（这个outer是我自定义的label） console.log(\u0026#39;内层循环 j 的值:\u0026#39; + j); } } 打印结果：\n1 外层循环 i 的值：0 continue continue 可以用来跳过当次循环，继续下一次循环。\n同样，continue 默认只会离他最近的循环起作用。\n同样，如果需要跳过指定的当次循环，可以使用 label 标签。\n举例：\n1 2 3 4 5 6 for (var i = 0; i \u0026lt; 10; i++) { if (i % 2 == 0) { continue; } console.log(\u0026#39;i的值:\u0026#39; + i); } 打印结果：\n1 2 3 4 5 6 7 8 9 i的值:1 i的值:3 i的值:5 i的值:7 i的值:9 各种练习 练习一：质数相关 题目：在页面中接收一个用户输入的数字，并判断该数是否是质数。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 质数：只能被1和它自身整除的数，1不是质数也不是合数，质数必须是大于1的自然数。 */ var num = prompt(\u0026#39;请输入一个大于1的整数:\u0026#39;); //判断这个值是否合法 if (num \u0026lt;= 1) { alert(\u0026#39;该值不合法！\u0026#39;); } else { //先用flag标志位，来保存当前的数的状态 //默认当前num是质数 var flag = true; //判断num是否是质数 //获取2-num之间的数 for (var i = 2; i \u0026lt; num; i++) { //console.log(i); //判断num是否能被i整除 if (num % i == 0) { //一旦发现：如果num能被i整除，则说明num一定不是质数， //此时：设置flag为false，然后跳出 for 循环 flag = false; break; } } //如果num是质数则输出 if (flag) { alert(num + \u0026#39;是质数！！！\u0026#39;); } else { alert(\u0026#39;这个不是质数\u0026#39;); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 练习二：质数相关 题目：打印 1~100 之间的所有质数\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* * 打印出1-100之间所有的质数 */ //打印2-100之间所有的数 for (var i = 2; i \u0026lt;= 100; i++) { //创建一个布尔值，用来保存结果，默认i是质数 var flag = true; //判断i是否是质数 //获取到2-i之间的所有的数 for (var j = 2; j \u0026lt; i; j++) { //判断i是否能被j整除 if (i % j == 0) { //如果进入判断则证明i不是质数,修改flag值为false flag = false; } } //如果是质数，则打印i的值 if (flag) { console.log(i); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n练习三：99 乘法表 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body { width: 2000px; } span { display: inline-block; width: 80px; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* * 1.打印99乘法表 * 1*1=1 * 1*2=2 2*2=4 * 1*3=3 2*3=6 3*3=9 * 1*4=4 2*4=8 3*4=12 4*4=16 * ....9*9=81 * * 2.打印出1-100之间所有的质数 */ //创建外层循环，用来控制乘法表的高度 for (var i = 1; i \u0026lt;= 9; i++) { //创建一个内层循环来控制图形的宽度 for (var j = 1; j \u0026lt;= i; j++) { document.write(\u0026#39;\u0026lt;span\u0026gt;\u0026#39; + j + \u0026#39;*\u0026#39; + i + \u0026#39;=\u0026#39; + i * j + \u0026#39;\u0026lt;/span\u0026gt;\u0026#39;); } //输出一个换行 document.write(\u0026#39;\u0026lt;br /\u0026gt;\u0026#39;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 页面效果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/10-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84for%E5%92%8Cwhile/","summary":"前言 循环语句：通过循环语句可以反复的执行一段代码多次。 for 循环 for 循环的语法 语法： 1 2 3 for(①初始化表达式; ②条件表达式; ④更新表达式){ ③","title":"10-流程控制语句：循环结构（for和while）"},{"content":"链式调用：基于 Promise 处理多次 Ajax 请求【重要】 实际开发中，我们经常需要同时请求多个接口。比如说：在请求完接口1的数据data1之后，需要根据data1的数据，继续请求接口 2，获取data2；然后根据data2的数据，继续请求接口 3。\n换而言之，现在有三个网络请求，请求 2 必须依赖请求 1 的结果，请求 3 必须依赖请求 2 的结果，如果按照往常的写法，会有三层回调，会陷入“回调地狱”。\n这种场景其实就是接口的多层嵌套调用。有了 Promise 之后，我们可以把多层嵌套调用按照线性的方式进行书写，非常优雅。也就是说：Promise 可以把原本的多层嵌套调用改进为链式调用。\n代码举例：（多次 Ajax 请求，链式调用）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const request = require(\u0026#39;request\u0026#39;); // Promise 封装接口1 const request1 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // Promise 封装接口2 const request2 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.jd.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口2的返回结果 resolve(\u0026#39;request2 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // Promise 封装接口3 const request3 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.taobao.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口3的返回结果 resolve(\u0026#39;request3 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // 先发起request1，等resolve后再发起request2；紧接着，等 request2有了 resolve之后，再发起 request3 request1() .then((res1) =\u0026gt; { // 接口1请求成功后，打印接口1的返回结果 console.log(res1); return request2(); }) .then((res2) =\u0026gt; { // 接口2请求成功后，打印接口2的返回结果 console.log(res2); return request3(); }) .then((res3) =\u0026gt; { // 接口3请求成功后，打印接口3的返回结果 console.log(res3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面代码中，then 是可以链式调用的，后面的 then 可以拿到前面 resolve 出来的数据。\n这个举例很经典，需要多看几遍。\nreturn 的函数返回值 return 后面的返回值，有两种情况：\n情况 1：返回 Promise 实例对象。返回的该实例对象会调用下一个 then。\n情况 2：返回普通值。返回的普通值会直接传递给下一个 then，通过 then 参数中函数的参数接收该值。\n我们针对上面这两种情况，详细解释一下。\n情况 1：返回 Promise 实例对象 举例如下：（这个例子，跟上一段 Ajax 链式调用 的例子差不多）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 基于Promise发送Ajax请求 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常情况 resolve(xhr.responseText); } else { // 处理异常情况 reject(\u0026#39;接口请求失败\u0026#39;); } }; xhr.responseType = \u0026#39;json\u0026#39;; // 设置返回的数据类型 xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); // 请求接口 }); } // 发送多个ajax请求并且保证顺序 queryData(\u0026#39;http://localhost:3000/api1\u0026#39;) .then( (data1) =\u0026gt; { console.log(JSON.stringify(data1)); return queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); }, (error1) =\u0026gt; { console.log(error1); } ) .then( (data2) =\u0026gt; { console.log(JSON.stringify(data2)); // 这里的 return，返回的是 Promise 实例对象 return new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;qianguyihao\u0026#39;); }); }, (error2) =\u0026gt; { console.log(error2); } ) .then((data3) =\u0026gt; { console.log(data3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 情况 2：返回 普通值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 基于Promise发送Ajax请求 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常情况 resolve(xhr.responseText); } else { // 处理异常情况 reject(\u0026#39;接口请求失败\u0026#39;); } }; xhr.responseType = \u0026#39;json\u0026#39;; // 设置返回的数据类型 xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); // 请求接口 }); } // 发送多个ajax请求并且保证顺序 queryData(\u0026#39;http://localhost:3000/api1\u0026#39;) .then( (data1) =\u0026gt; { console.log(JSON.stringify(data1)); return queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); }, (error1) =\u0026gt; { console.log(error1); } ) .then( (data2) =\u0026gt; { console.log(JSON.stringify(data2)); // 返回普通值 return \u0026#39;qianguyihao\u0026#39;; }, (error2) =\u0026gt; { console.log(error2); } ) /* 既然上方返回的是 普通值，那么，这里的 then 是谁来调用呢？ 答案是：这里会产生一个新的 默认的 promise实例，来调用这里的then，确保可以继续进行链式操作。 */ .then((data3) =\u0026gt; { // 这里的 data3 接收的是 普通值 \u0026#39;qianguyihao\u0026#39; console.log(data3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Promise 的常用 API：实例方法【重要】 Promise 自带的 API 提供了如下实例方法：\npromise.then()：获取异步任务的正常结果。\npromise.catch()：获取异步任务的异常结果。\npromise.finaly()：异步任务无论成功与否，都会执行。\n代码举例如下。\n写法 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function queryData() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(function () { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } queryData() .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(\u0026#39;接口请求成功时，走这里\u0026#39;); console.log(data); }) .catch((data) =\u0026gt; { // 从 reject 获取异常结果 console.log(\u0026#39;接口请求失败时，走这里\u0026#39;); console.log(data); }) .finally(() =\u0026gt; { console.log(\u0026#39;无论接口请求成功与否，都会走这里\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 写法 2：（和上面的写法 1 等价）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function queryData() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(function () { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } queryData() .then( (data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(\u0026#39;接口请求成功时，走这里\u0026#39;); console.log(data); }, (data) =\u0026gt; { // 从 reject 获取异常结果 console.log(\u0026#39;接口请求失败时，走这里\u0026#39;); console.log(data); } ) .finally(() =\u0026gt; { console.log(\u0026#39;无论接口请求成功与否，都会走这里\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意：写法 1 和写法 2 的作用是完全等价的。只不过，写法 2 是把 catch 里面的代码作为 then 里面的第二个参数而已。\nPromise 的常用 API：对象方法【重要】 Promise 自带的 API 提供了如下对象方法：\nPromise.all()：并发处理多个异步任务，所有任务都执行成功，才能得到结果。\nPromise.race(): 并发处理多个异步任务，只要有一个任务执行成功，就能得到结果。\n下面来详细介绍。\nPromise.all() 代码举例 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 封装 Promise 接口调用 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常结果 resolve(xhr.responseText); } else { // 处理异常结果 reject(\u0026#39;服务器错误\u0026#39;); } }; xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); }); } var promise1 = queryData(\u0026#39;http://localhost:3000/api1\u0026#39;); var promise2 = queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); var promise3 = queryData(\u0026#39;http://localhost:3000/api3\u0026#39;); Promise.all([promise1, promise2, promise3]).then((result) =\u0026gt; { console.log(result); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Promise.race() 代码举例 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 封装 Promise 接口调用 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常结果 resolve(xhr.responseText); } else { // 处理异常结果 reject(\u0026#39;服务器错误\u0026#39;); } }; xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); }); } var promise1 = queryData(\u0026#39;http://localhost:3000/api1\u0026#39;); var promise2 = queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); var promise3 = queryData(\u0026#39;http://localhost:3000/api3\u0026#39;); Promise.race([promise1, promise2, promise3]).then((result) =\u0026gt; { console.log(result); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/11-promise%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E5%92%8Capi/","summary":"链式调用：基于 Promise 处理多次 Ajax 请求【重要】 实际开发中，我们经常需要同时请求多个接口。比如说：在请求完接口1的数据data1之后，需要根据data","title":"11-Promise的常见用法和API"},{"content":"对象简介 面向对象简介 面向对象：可以创建自定义的类型，很好的支持继承和多态。\n面向对象的特征：封装、继承、多态。\n对象的概念 在 JavaScript 中，对象是一组无序的相关属性和方法的集合。\n对象的作用是：封装信息。比如Student类里可以封装学生的姓名、年龄、成绩等。\n对象具有特征（属性）和行为（方法）。\n为什么需要对象 保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。\n比如，如果要保存一个人的信息，通过数组的方式可以这样保存：\n1 var arr = [\u0026#39;王二\u0026#39;, 35, \u0026#39;男\u0026#39;, \u0026#39;180\u0026#39;]; 上面这种表达方式比较乱。而如果用JS中的对象来表达，结构会更清晰。如下：\n1 2 3 4 5 6 var person = {}; person.name = \u0026#39;王二\u0026#39;; person.age = 35; person.sex = \u0026#39;男\u0026#39;; person.height = \u0026#39;180\u0026#39;; 由此可见，对象里面的属性均是键值对：\n键：相当于属性名。\n值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）。\n两条补充 补充1：对象的属性值可以是任何的数据类型，也可以是个函数：（也称之为方法）\n1 2 3 4 5 6 7 8 var obj = new Object(); obj.sayName = function () { console.log(\u0026#39;smyhvae\u0026#39;); }; console.log(obj.sayName); //没加括号，就是获取方法 console.log(\u0026#39;-----------\u0026#39;); console.log(obj.sayName()); //加了括号，就是调用方法。即：执行函数内容，并执行函数体的内容 打印结果：\n补充2：对象中的属性值，也可以是一个对象。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 //创建对象 obj1 var obj1 = new Object(); obj1.test = undefined; //创建对象 obj2 var obj2 = new Object(); obj2.name = \u0026#34;smyhvae\u0026#34;; //将整个 obj2 对象，设置为 obj1 的属性 obj1.test = obj2; console.log(obj1.test.name); 打印结果为：smyhvae\n对象和数据类型之间的关系 数据类型分类 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。\n引用数据类型（引用类型）：Object 对象。\n基本数据类型：\n基本数据类型的值直接保存在栈内存中，值与值之间是独立存在，修改一个变量不会影响其他的变量。\n对象：\n只要不是那五种基本数据类型，就全都是对象。\n如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体。\n对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。\n对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间。变量保存的是对象的内存地址（对象的引用）。\n换而言之，对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。\n如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。\n上面这句话很重要，我们来看看下面的例子。\n传值和传址的区别 传值 代码举例：\n1 2 3 4 5 let a = 1; let b = a;// 将 a 赋值给 b b = 2; // 修改 b 的值 上方代码中，当我修改 b 的值之后，a 的值并不会发生改变。这个大家都知道。我们继续往下看。\n传址（一个经典的例子） 代码举例：\n1 2 3 4 5 6 7 var obj1 = new Object(); obj1.name = \u0026#34;孙悟空\u0026#34;; var obj2 = obj1; // 将 obj1 的地址赋值给 obj2。从此， obj1 和 obj2 指向了同一个堆内存空间 //修改obj2的name属性 obj2.name = \u0026#34;猪八戒\u0026#34;; 上面的代码中，当我修改 obj2 的name属性后，会发现，obj1 的 name 属性也会被修改。因为obj1和obj2指向的是堆内存中的同一个地址。\n这个例子要尤其注意，实战开发中，很容易忽略。\n对于引用类型的数据，赋值相当于地址拷贝，a、b指向了同一个堆内存地址。所以改了b，a也会变；本质上a、b就是一个东西。\n如果你打算把引用类型 A 的值赋值给 B，让A和B相互不受影响的话，可以通过 Object.assign() 来复制对象。效果如下：\n1 2 3 4 var obj1 = {name: \u0026#39;孙悟空\u0026#39;}; // 复制对象：把 obj1 赋值给 obj3。两者之间互不影响 var obj3 = Object.assign({}, obj1); 对象的分类 1.内置对象：\n由ES标准中定义的对象，在任何的ES的实现中都可以使用\n比如：Object、Math、Date、String、Array、Number、Boolean、Function等。\n2.宿主对象：\n由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。\n比如 BOM DOM。比如console、document。\n3.自定义对象：\n由开发人员自己创建的对象 通过 new 关键字创建出来的对象实例，都是属于对象类型，比如Object、Array、Date等。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/11-%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/","summary":"对象简介 面向对象简介 面向对象：可以创建自定义的类型，很好的支持继承和多态。 面向对象的特征：封装、继承、多态。 对象的概念 在 JavaScript 中，对象是一组无序","title":"11-对象简介"},{"content":" 备注： async/await 的内容还有待完善。\nasync/await （异步函数）概述 async/await 是在 ES7 中引入的新语法，可以更加方便地进行异步操作。\n本质： Generator 的语法糖。\nasync 的返回值是 Promise 实例对象。\nawait 可以得到异步结果。\n我们在普通的函数前面加上 async 关键字，就成了 async 函数。\nasync/await 的基本用法 async 后面可以跟一个 Promise 实例对象。代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const request1 = function() { const promise = new Promise(resolve =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, function(response) { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39;+ response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; async function queryData() { const response = await request1(); }); return response; } queryData().then(data =\u0026gt; { console.log(data); }); 基于 async/await 处理多次 Ajax 请求【重要】 实际开发中，现在有三个网络请求，请求2必须依赖请求1的结果，请求3必须依赖请求2的结果，如果按照往常的写法，会有三层回调，会陷入“回调地狱”。\n这种场景其实就是接口的多层嵌套调用。之前学过 Promise，它可以把原本的多层嵌套调用改进为链式调用。\n而今天要学习的 async/await ，可以把原本的“多层嵌套调用”改成类似于同步的写法，非常优雅。\n代码举例：\n暂略。\nPromise、async\u0026hellip;await、Generator的对比 我们在使用 Promise、async\u0026hellip;await、Generator 的时候，返回的都是 Promise 的实例。\n如果直接使用 Promise，则需要通过 then 来进行链式调用；如果使用 async\u0026hellip;await、Generator，写起来更像同步的代码。\n参考链接 js async await 终极异步解决方案\n理解 JavaScript 的 async/await\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/12-es7async%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","summary":"备注： async/await 的内容还有待完善。 async/await （异步函数）概述 async/await 是在 ES7 中引入的新语法，可以更加方便地进行异步操作。 本质： Generator 的语法糖。 async 的返回值是 Promise 实例对象。 await","title":"12-ES7：async函数详解"},{"content":"基本数据类型不能绑定属性和方法 属性和方法只能添加给对象，不能添加给基本数据类型。\n1、基本数据类型：\n注意，基本数据类型string是无法绑定属性和方法的。比如说：\n1 2 3 4 5 var str = \u0026#39;qianguyihao\u0026#39;; str.aaa = 12; console.log(typeof str); //打印结果为：string console.log(str.aaa); //打印结果为：undefined 上方代码中，当我们尝试打印str.aaa的时候，会发现打印结果为：undefined。也就是说，不能给 string 绑定属性和方法。\n当然，我们可以打印 str.length、str.indexOf(\u0026ldquo;m\u0026rdquo;)等等。因为这两个方法的底层做了数据类型转换（临时将 string 字符串转换为 String 对象，然后再调用内置方法），也就是我们在上一段中讲到的包装类。\n2、引用数据类型：\n引用数据类型String是可以绑定属性和方法的。如下：\n1 2 3 4 5 var strObj = new String(\u0026#39;smyhvae\u0026#39;); strObj.aaa = 123; console.log(strObj); console.log(typeof strObj); //打印结果：Object console.log(strObj.aaa); 打印结果：\n内置对象 Number 也有一些自带的方法，比如：\nNumber.MAX_VALUE;\nNumber.MIN_VALUE;\n内置对象 Boolean 也有一些自带的方法，但是用的不多。\n基本包装类型 介绍 我们都知道，js 中的数据类型包括以下几种。\n基本数据类型：String、Number、Boolean、Null、Undefined\n引用数据类型：Object\nJS 为我们提供了三个基本包装类：\nString()：将基本数据类型字符串，转换为 String 对象。\nNumber()：将基本数据类型的数字，转换为 Number 对象。\nBoolean()：将基本数据类型的布尔值，转换为 Boolean 对象。\n通过上面这这三个包装类，我们可以将基本数据类型的数据转换为对象。\n代码举例：\n1 2 3 4 5 6 7 8 9 let str1 = \u0026#39;qianguyihao\u0026#39;; let str2 = new String(\u0026#39;qianguyihao\u0026#39;); let num = new Number(3); let bool = new Boolean(true); console.log(typeof str1); // 打印结果：string console.log(typeof str2); // 注意，打印结果：object 需要注意的是：我们在实际应用中一般不会使用基本数据类型的对象。如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果。\n比如说：\n1 2 3 4 var boo1 = new Boolean(true); var boo2 = new Boolean(true); console.log(boo1 === boo2); // 打印结果竟然是：false 再比如说：\n1 2 3 4 5 var boo3 = new Boolean(false); if (boo3) { console.log(\u0026#39;qianguyihao\u0026#39;); // 这行代码竟然执行了 } 基本包装类型的作用 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将基本数据类型转换为引用数据类型，这样的话，基本数据类型就有了属性和方法，然后再调用对象的属性和方法；调用完以后，再将其转换为基本数据类型。\n举例：\n1 2 var str = \u0026#39;qianguyihao\u0026#39;; console.log(str.length); // 打印结果：11 比如，上面的代码，执行顺序是这样的：\n1 2 3 4 5 6 7 8 // 步骤（1）：把简单数据类型 string 转换为 引用数据类型 String，保存到临时变量中 var temp = new String(\u0026#39;qianguyihao\u0026#39;); // 步骤（2）：把临时变量的值 赋值给 str str = temp; // 步骤（3）：销毁临时变量 temp = null; 在底层，字符串以字符数组的形式保存 在底层，字符串是以字符数组的形式保存的。代码举例：\n1 2 3 var str = \u0026#39;smyhvae\u0026#39;; console.log(str.length); // 获取字符串的长度 console.log(str[2]); // 获取字符串中的第2个字符 上方代码中，smyhvae这个字符串在底层是以[\u0026quot;s\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;v\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;e\u0026quot;]的形式保存的。因此，我们既可以获取字符串的长度，也可以获取指定索引 index 位置的单个字符。这很像数组中的操作。\n再比如，String 对象的很多内置方法，也可以直接给字符串用。此时，也是临时将字符串转换为 String 对象，然后再调用内置方法。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/12-%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/","summary":"基本数据类型不能绑定属性和方法 属性和方法只能添加给对象，不能添加给基本数据类型。 1、基本数据类型： 注意，基本数据类型string是无法绑定属","title":"12-基本包装类型"},{"content":"内置对象简介 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象。\n前面两种对象：是JS的基础内容，属于 ECMAScript； 第三个浏览器对象：属于JS独有，即 JS 内置的API。\n内置对象：就是指这个语言自带的一些对象，供开发者使用，这些对象提供了一些常用或者最基本而必要的功能（属性和方法）。\n内置对象最大的优点就是帮助我们快速开发。\nJavaScript的内置对象：\n内置对象 对象说明 Arguments 函数参数集合 Array 数组 Boolean 布尔对象 Math 数学对象 Date 日期时间 Error 异常对象 Function 函数构造器 Number 数值对象 Object 基础对象 RegExp 正则表达式对象 String 字符串对象 前面的几篇文章中，我们专门讲到了数组 Array。今天这篇文章，我们先来讲一下内置对象 Math。\n字符串前言 在日常开发中，String 对象（字符串对象）的使用频率是非常高的。所以有必要详细介绍。\n需要注意的是：字符串的所有方法，都不会改变原字符串（字符串的不可变性），操作完成后会返回一个新的值。\n字符串的常见方法如下。\n查找字符串 1、indexOf()/lastIndexOf()：获取字符串中指定内容的索引 这个方法，是使用频率最高的一个方法。\n语法 1：\n1 索引值 = str.indexOf(想要查询的字符串); 备注：indexOf() 是从前向后查找字符串的位置。同理，lastIndexOf()是从后向前寻找。\n解释：可以检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其第一次出现的索引；如果没有找到指定的内容，则返回 -1。\n因此可以得出一个重要技巧：\n如果获取的索引值为 0，说明字符串是以查询的参数为开头的。\n如果获取的索引值为-1，说明这个字符串中没有指定的内容。\n举例 1：(查找单个字符)\n1 2 3 4 5 6 7 8 const str = \u0026#39;abcdea\u0026#39;; //给字符查索引(索引值为0,说明字符串以查询的参数为开头) console.log(str.indexOf(\u0026#39;c\u0026#39;)); console.log(str.lastIndexOf(\u0026#39;c\u0026#39;)); console.log(str.indexOf(\u0026#39;a\u0026#39;)); console.log(str.lastIndexOf(\u0026#39;a\u0026#39;)); 打印结果：\n举例 2：（查找字符串）\n1 2 3 const name = \u0026#39;qianguyihao\u0026#39;; console.log(name.indexOf(\u0026#39;yi\u0026#39;)); // 打印结果：6 语法 2：\n这个方法还可以指定第二个参数，用来指定查找的起始位置。语法如下：\n1 索引值 = str.indexOf(想要查询的字符串, [起始位置]); 举例 3：（两个参数时，需要特别注意）\n1 2 3 4 var str = \u0026#39;qianguyihao\u0026#39;; result = str.indexOf(\u0026#39;a\u0026#39;, 3); // 从第三个位置开始查找 \u0026#39;a\u0026#39;这个字符 【重要】 console.log(result); // 打印结果：9 上方代码中，indexOf()方法中携带了两个参数，具体解释请看注释。\nindexOf 举例 案例：查找字符串\u0026quot;qianguyihao\u0026quot;中，所有 a 出现的位置以及次数。\n思路：\n（1）先查找第一个 a 出现的位置。\n（2）只要 indexOf 返回的结果不是 -1 就继续往后查找。\n（3）因为 indexOf 只能查找到第一个，所以后面的查找，可以利用第二个参数，在当前索引加 1，从而继续查找。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 var str = \u0026#39;qianguyihao\u0026#39;; var index = str.indexOf(\u0026#39;a\u0026#39;); var num = 0; while (index !== -1) { console.log(index); num++; // 每打印一次，就计数一次 index = str.indexOf(\u0026#39;o\u0026#39;, index + 1); } console.log(\u0026#39;a 出现的次数是: \u0026#39; + num); 2、search()：获取字符串中指定内容的索引（参数里一般是正则） 语法：\n1 2 索引值 = str.search(想要查找的字符串); 索引值 = str.search(正则表达式); 备注：search() 方法里的参数，既可以传字符串，也可以传正则表达式。\n解释：可以检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其第一次出现的索引；如果没有找到指定的内容，则返回 -1。\n举例：\n1 2 3 4 const name = \u0026#39;qianguyihao\u0026#39;; console.log(name.search(\u0026#39;yi\u0026#39;)); // 打印结果：6 console.log(name.search(/yi/i)); // 打印结果：6 备注：上方的/yi/i采用的是正则表达式的写法，意思是，让 name去匹配字符yi，忽略大小写。我们在后面会专门介绍正则表达式。\n3、includes()：字符串中是否包含指定的内容 语法：\n1 布尔值 = str.includes(想要查找的字符串, [position]); 解释：判断一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回 true；否则返回 false。\n参数中的 position：如果不指定，则默认为0；如果指定，则规定了检索的起始位置。\n1 2 3 4 5 6 const name = \u0026#39;qianguyihao\u0026#39;; console.log(name.includes(\u0026#39;yi\u0026#39;)); // 打印结果：true console.log(name.includes(\u0026#39;haha\u0026#39;)); // 打印结果：false console.log(name.includes(\u0026#39;yi\u0026#39;,7)); // 打印结果：false 4、startsWith()：字符串是否以指定的内容开头 语法：\n1 布尔值 = str.startsWith(想要查找的内容, [position]); 解释：判断一个字符串是否以指定的子字符串开头。如果是，则返回 true；否则返回 false。\n参数中的position：\n如果不指定，则默认为0。\n如果指定，则规定了检索的起始位置。检索的范围包括：这个指定位置开始，直到字符串的末尾。即：[position, str.length)\n举例：\n1 2 3 4 5 6 7 8 const name = \u0026#39;abcdefg\u0026#39;; console.log(name.startsWith(\u0026#39;a\u0026#39;)); // 打印结果：true console.log(name.startsWith(\u0026#39;b\u0026#39;)); // 打印结果：false // 因为指定了起始位置为3，所以是在 defg 这个字符串中检索。 console.log(name.startsWith(\u0026#39;d\u0026#39;,3)); // 打印结果：true console.log(name.startsWith(\u0026#39;c\u0026#39;,3)); // 打印结果：false 5、endsWith()：字符串是否以指定的内容结尾 语法：\n1 布尔值 = str.endsWith(想要查找的内容, [position]); 解释：判断一个字符串是否以指定的子字符串结尾。如果是，则返回 true；否则返回 false。\n参数中的position：\n如果不指定，则默认为 str.length。\n如果指定，则规定了检索的结束位置。检索的范围包括：从第一个字符串开始，直到这个指定的位置。即：[0, position)\n或者你可以这样简单理解：endsWith() 方法里的position，表示检索的长度。\n注意：startsWith() 和 endsWith()这两个方法，他们的 position 的含义是不同的，请仔细区分。\n举例：\n1 2 3 4 5 6 7 8 const name = \u0026#39;abcdefg\u0026#39;; console.log(name.endsWith(\u0026#39;g\u0026#39;)); // 打印结果：true console.log(name.endsWith(\u0026#39;f\u0026#39;)); // 打印结果：false // 因为指定了截止位置为3，所以是在 abc 这个长度为3字符串中检索 console.log(name.endsWith(\u0026#39;c\u0026#39;, 3)); // 打印结果：true console.log(name.endsWith(\u0026#39;d\u0026#39;, 3)); // 打印结果：false 注意看上方的注释。\n参考链接：JavaScript endsWith()介绍\n获取指定位置的字符 1、charAt(index) 语法：\n1 字符 = str.charAt(index); 解释：返回字符串指定位置的字符。这里的 str.charAt(index)和str[index]的效果是一样的。\n注意：字符串中第一个字符的下标是 0。如果参数 index 不在 [0, string.length) 之间，该方法将返回一个空字符串。\n代码举例：\n1 2 3 4 5 var str = new String(\u0026#39;smyhvae\u0026#39;); for (var i = 0; i \u0026lt; str.length; i++) { console.log(str.charAt(i)); } 打印结果：\n上面这个例子一般不用。一般打印数组和 json 的时候用索引，打印 String 不建议用索引。\n2、str[index] str.charAt(index)和str[index]的效果是一样的，不再赘述。区别在于：str[index]是 H5 标准里新增的特性。\n3、charCodeAt(index) 语法：\n1 字符 = str.charCodeAt(index); 解释：返回字符串指定位置的字符的 Unicode 编码。不会修改原字符串。\n在实际应用中，通过这个方法，我们可以判断用户按下了哪个按键。\n代码举例：打印字符串的占位长度。\n提示：一个英文占一个位置，一个中文占两个位置。\n思路：判断该字符是否在 0-127 之间（在的话是英文，不在是非英文）。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script\u0026gt; // sort(); 底层用到了charCodeAt(); var str = \u0026#39;I love my country!我你爱中国！\u0026#39;; //需求：求一个字符串占有几个字符位。 //思路；如果是英文，站一个字符位，如果不是英文占两个字符位。 //技术点：判断该字符是否在0-127之间。（在的话是英文，不在是非英文） alert(getZFWlength(str)); alert(str.length); //定义方法：字符位 function getZFWlength(string) { //定义一个计数器 var count = 0; for (var i = 0; i \u0026lt; string.length; i++) { //对每一位字符串进行判断，如果Unicode编码在0-127，计数器+1；否则+2 if (string.charCodeAt(i) \u0026lt; 128 \u0026amp;\u0026amp; string.charCodeAt(i) \u0026gt;= 0) { count++; } else { count += 2; } } return count; } \u0026lt;/script\u0026gt; 打印结果：\n1 2 30 24 从打印结果可以看出：字符串的长度是 24，但是却占了 30 个字符位（一个中文占两个字符位）。\n另外，sort()方法其实底层也是用到了 charCodeAt()，因为用到了 Unicode 编码。\n字符串截取 1、slice() slice() 方法用的最多。\n语法：\n1 新字符串 = str.slice(开始索引, 结束索引); //两个参数都是索引值。包左不包右。 解释：从字符串中截取指定的内容。不会修改原字符串，而是将截取到的内容返回。\n注意：上面的参数，包左不包右。参数举例如下：\n(2, 5) 截取时，包左不包右。\n(2) 表示从指定的索引位置开始，截取到最后。\n(-3) 表示从倒数第三个开始，截取到最后。\n(1, -1) 表示从第一个截取到倒数第一个。\n(5, 2) 表示前面的大，后面的小，返回值为空。\n2、substring() 语法：\n1 新字符串 = str.substring(开始索引, 结束索引); //两个参数都是索引值。包左不包右。 解释：从字符串中截取指定的内容。和slice()类似。\nsubstring()和slice()是类似的。但不同之处在于：\nsubstring()不能接受负值作为参数。如果传递了一个负值，则默认使用 0。\nsubstring()还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换。比如说， substring(1, 0)相当于截取的是第一个字符。\n3、substr() 语法：\n1 字符串 = str.substr(开始索引, 截取的长度); 解释：从字符串中截取指定的内容。不会修改原字符串，而是将截取到的内容返回。\n注意，这个方法的第二个参数截取的长度，不是结束索引。\n参数举例：\n(2,4) 从索引值为 2 的字符开始，截取 4 个字符。\n(1) 从指定位置开始，截取到最后。\n(-3) 从倒数第几个开始，截取到最后。\n备注：ECMAscript 没有对 substr() 方法进行标准化，因此不建议使用它。\nString.fromCharCode() String.fromCharCode()：根据字符的 Unicode 编码获取字符。\n代码举例：\n1 2 3 4 5 var result1 = String.fromCharCode(72); var result2 = String.fromCharCode(20013); console.log(result1); // 打印结果：H console.log(result2); // 打印结果：中 concat() 语法：\n1 新字符串 = str1.concat(str2)； //连接两个字符串 解释：字符串的连接。\n这种方法基本不用，直接把两个字符串相加就好。\n是的，你会发现，数组中也有concat()方法，用于数组的连接。这个方法在数组中用得挺多的。\n代码举例：\n1 2 3 4 5 var str1 = \u0026#39;qiangu\u0026#39;; var str2 = \u0026#39;yihao\u0026#39;; var result = str1.concat(str2); console.log(result); // 打印结果：qianguyihao split()：字符串转换为数组 【重要】 语法：\n1 新的数组 = str.split(分隔符); 解释：通过指定的分隔符，将一个字符串拆分成一个数组。不会改变原字符串。\n备注：split()这个方法在实际开发中用得非常多。一般来说，从接口拿到的 json 数据中，经常会收到类似于\u0026quot;q, i, a, n\u0026quot;这样的字符串，前端需要将这个字符串拆分成['q', 'i', 'a', 'n']数组，这个时候split()方法就派上用场了。\n代码举例 1：\n1 2 3 4 var str = \u0026#39;qian, gu, yi, hao\u0026#39;; // 用逗号隔开的字符串 var array = str.split(\u0026#39;,\u0026#39;); // 将字符串 str 拆分成数组，通过逗号来拆分 console.log(array); // 打印结果是数组：[\u0026#34;qian\u0026#34;, \u0026#34; gu\u0026#34;, \u0026#34; yi\u0026#34;, \u0026#34; hao\u0026#34;] 代码举例 2：\n1 2 3 4 5 6 7 8 9 10 //split()方法：字符串变数组 var str3 = \u0026#39;lvbu|qianguyihao|许嵩\u0026#39;; console.log(\u0026#39;结果1：\u0026#39; +str3.split()); // 无参数，表示：把整个字符串作为一个元素添加到数组中。 console.log(str3.split(\u0026#39;\u0026#39;)); // 参数为空字符串，则表示：分隔字符串中每一个字符，分别添加到数组中 console.log(str3.split(\u0026#39;|\u0026#39;)); // 参数为指定字符，表示：用 \u0026#39;|\u0026#39; 分隔字符串。此分隔符将不会出现在数组的任意一个元素中 console.log(str3.split(\u0026#39;许\u0026#39;)); // 同上 打印结果：（都是数组）\nreplace() 语法：\n1 新的字符串 = str.replace(被替换的字符，新的字符); 解释：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。\n注意：这个方法，默认只会替换第一个被匹配到的字符。如果要全局替换，需要使用正则。\n代码举例：\n1 2 3 4 5 6 //replace()方法：替换 var str2 = \u0026#39;Today is fine day,today is fine day !\u0026#39;; console.log(str2); console.log(str2.replace(\u0026#39;today\u0026#39;, \u0026#39;tomorrow\u0026#39;)); //只能替换第一个today console.log(str2.replace(/today/gi, \u0026#39;tomorrow\u0026#39;)); //这里用到了正则，才能替换所有的today repeat()：重复字符串 语法：\n1 newStr = str.repeat(重复的次数); 解释：将字符串重复指定的次数。会返回新的值，不会修改原字符串。\n举例1：\n1 2 3 const name = \u0026#39;qianguyihao\u0026#39;; console.log(name.repeat(2)); // 打印内容：qianguyihaoqianguyihao 举例2：（模糊字符串的后四位）\n1 2 3 4 5 const telephone = \u0026#39;13088889999\u0026#39;; const mix_telephone = telephone.slice(0, -4) + \u0026#39;*\u0026#39;.repeat(4); // 模糊电话号码的后四位 console.log(telephone); // 打印结果：13088889999 console.log(mix_telephone); // 打印结果：1308888**** trim() trim()：去除字符串前后的空白。\n代码举例：\n1 2 3 4 5 6 7 //去除字符串前后的空格，trim(); let str = \u0026#39; a b c \u0026#39;; console.log(str); console.log(str.length); console.log(str.trim()); console.log(str.trim().length); 打印结果：\n大小写转换 举例：\n1 2 3 4 5 6 7 var str = \u0026#39;abcdEFG\u0026#39;; //转换成小写 console.log(str.toLowerCase()); //转换成大写 console.log(str.toUpperCase()); html 方法 anchor() 创建 a 链接\nbig()\nsub()\nsup()\nlink()\nbold()\n注意，str.link() 返回值是字符串。\n举例：\n1 2 3 4 5 6 7 8 var str = \u0026#39;你好\u0026#39;; console.log(str.anchor()); console.log(str.big()); console.log(str.sub()); console.log(str.sup()); console.log(str.link(\u0026#39;http://www.baidu.com\u0026#39;)); console.log(str.bold()); 字符串练习 练习 1：\u0026ldquo;smyhvaevaesmyh\u0026quot;查找字符串中所有 m 出现的位置。\n代码实现：\n1 2 3 4 5 6 7 8 var str2 = \u0026#39;smyhvaevaesmyh\u0026#39;; for (var i = 0; i \u0026lt; str2.length; i++) { //如果指定位置的符号=== \u0026#34;o\u0026#34; //str2[i] if (str2.charAt(i) === \u0026#39;m\u0026#39;) { console.log(i); } } 练习 2：判断一个字符串中出现次数最多的字符，统计这个次数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;script\u0026gt; var str2 = \u0026#39;smyhvaevaesmyhvae\u0026#39;; //定义一个json，然后判断json中是够有该属性，如果有该属性，那么值+1;否则创建一个该属性，并赋值为1； var json = {}; for (var i = 0; i \u0026lt; str2.length; i++) { //判断：如果有该属性，那么值+1;否则创建一个该属性，并赋值为1； var key = str2.charAt(i); if (json[key] === undefined) { json[key] = 1; } else { json[key] += 1; } } console.log(json); console.log(\u0026#39;----------------\u0026#39;); //获取json中属性值最大的选项 var maxKey = \u0026#39;\u0026#39;; var maxValue = 0; for (var k in json) { // if(maxKey == \u0026#34;\u0026#34;){ // maxKey = k; // maxValue = json[k]; // }else{ if (json[k] \u0026gt; maxValue) { maxKey = k; maxValue = json[k]; } // } } console.log(maxKey); console.log(maxValue); \u0026lt;/script\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/13-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-string%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/","summary":"内置对象简介 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象。 前面两种对象：是JS的基础内容，属于 ECMAScript； 第三个浏览器对象","title":"13-内置对象 String：字符串的常见方法"},{"content":"内置对象 Number 的常见方法 Number.isInteger() 判断是否为整数 语法：\n1 布尔值 = Number.isInteger(数字); toFixed() 小数点后面保留多少位 语法：\n1 字符串 = myNum.toFixed(num); 解释：将数字 myNum 的小数点后面保留 num 位小数（四舍五入），并返回。不会改变原数字。注意，返回结果是字符串。\n参数 num：指定了小数点后面的位数。\n举例：\n1 2 3 4 5 6 7 8 let num = 3.456; let num2 = num.toFixed(2); console.log(num); // 打印结果：3.456 console.log(num2); // 打印结果：3.46 console.log(typeof num); // number console.log(typeof num2); // string 上方代码中，num2的结果是3.46，但是请注意，num的类型Number型，而num2的类型却是String型。\n内置对象 Math 的常见方法 Math 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是直接使用里面的属性和方法即可。\nMath属于一个工具类，里面封装了数学运算相关的属性和方法。如下：\n方法 描述 备注 Math.PI 圆周率 Math对象的属性 Math.abs() 返回绝对值 Math.random() 生成0-1之间的随机浮点数 取值范围是 [0，1) Math.floor() 向下取整（往小取值） Math.ceil() 向上取整（往大取值） Math.round() 四舍五入取整（正数四舍五入，负数五舍六入） Math.max(x, y, z) 返回多个数中的最大值 Math.min(x, y, z) 返回多个数中的最小值 Math.pow(x,y) 乘方：返回 x 的 y 次幂 Math.sqrt() 开方：对一个数进行开方运算 举例：\n1 2 3 4 5 6 7 8 9 10 11 var num = -0.6; console.log(Math.abs(num)); //取绝对值 console.log(Math.floor(num)); //向下取整，向小取 console.log(Math.ceil(num)); //向上取整，向大取 console.log(Math.round(num)); //四舍五入取整（正数四舍五入，负数五舍六入） console.log(Math.random()); //生成0-1之间的随机数 运行结果：\n1 2 3 4 5 6 7 8 9 0.6 -1 -0 -1 0.6453756205275165 Math.abs()：获绝对值 方法定义：返回绝对值。\n注意：\n参数中可以接收字符串类型的数字，此时会将字符串做隐式类型转换，然后再调用 Math.abs() 方法。 代码举例：\n1 2 3 4 5 6 7 console.log(Math.abs(2)); // 2 console.log(Math.abs(-2)); // 2 // 先做隐式类型转换，将 \u0026#39;-2\u0026#39;转换为数字类型 -2，然后再调用 Math.abs() console.log(Math.abs(\u0026#39;-2\u0026#39;)); console.log(Math.abs(\u0026#39;hello\u0026#39;)); // NaN Math.random() 方法：生成随机数 方法定义：生成 [0, 1) 之间的随机浮点数。\n我们来看几个例子。\n生成 [0, x) 之间的随机数 1 Math.round(Math.random()*x) 生成 [x, y) 之间的随机数 1 Math.round(Math.random()*(y-x)+x) 【重要】生成 [x, y]之间的随机整数 也就是说：生成两个整数之间的随机整数，并且要包含这两个整数。\n这个功能很常用，我们可以将其封装成一个方法，代码实现如下：\n1 2 3 4 5 6 7 8 /* * 生成两个整数之间的随机整数，并且要包含这两个整数 */ function getRandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } console.log(getRandom(1, 10)); 举例：随机点名 根据上面的例子，我们还可以再延伸一下，来看看随机点名的例子。\n1 2 3 4 5 6 7 8 9 10 /* * 生成两个整数之间的随机整数，并且要包含这两个整数 */ function getRandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } const arr = [\u0026#39;许嵩\u0026#39;, \u0026#39;邓紫棋\u0026#39;, \u0026#39;毛不易\u0026#39;, \u0026#39;解忧邵帅\u0026#39;]; const index = getRandom(0, arr.length - 1); // 生成随机的index console.log(arr[index]); // 随机点名 pow()：乘方 如果想计算 a 的 b 次方，可以使用如下函数：\n1 Math.pow(a, b); Math的中文是“数学”，pow是“幂”。\n举例1：\n代码实现：\n1 2 var a = Math.pow(3, Math.pow(2, 2)); console.log(a); 举例2：\n代码实现：\n1 2 var a = Math.pow(Math.pow(3, 2), 4); console.log(a); sqrt()：开方 如果想计算数值a的开二次方，可以使用如下函数：\n1 Math.sqrt(a); sqrt即“square 开方”。比如：\n1 var a = Math.sqrt(36); url 编码和解码 URI (Uniform ResourceIdentifiers,通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。\n1 2 encodeURIComponent(); //把字符串作为 URI 组件进行编码 decodeURIComponent(); //把字符串作为 URI 组件进行解码 举例：\n1 2 3 4 5 var url = \u0026#34;http://www.cnblogs.com/smyhvae/\u0026#34;; var str = encodeURIComponent(url); console.log(str); //打印url的编码 console.log(decodeURIComponent(str)); //对url进行编码后，再解码，还原为url 打印结果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/14-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1number%E5%92%8Cmath/","summary":"内置对象 Number 的常见方法 Number.isInteger() 判断是否为整数 语法： 1 布尔值 = Number.isInteger(数字); toFixed() 小数点后面保留多少位 语法： 1 字符串 = myNum.toFixed(num); 解释：","title":"14-内置对象：Number和Math"},{"content":"内置对象：Date Date 对象在实际开发中，使用得很频繁，且容易在细节地方出错，需要引起重视。\n内置对象 Date 用来处理日期和时间。\n需要注意的是：与 Math 对象不同，Date 对象是一个构造函数 ，需要先实例化后才能使用。\n创建Date对象 创建Date对象有两种写法：\n写法一：如果Date()不写参数，就返回当前时间对象\n写法二：如果Date()里面写参数，就返回括号里输入的时间对象\n针对这两种写法，我们来具体讲一讲。\n写法一：不传递参数时，则获取系统的当前时间对象 代码举例：\n1 2 3 var date1 = new Date(); console.log(date1); console.log(typeof date1); 代码解释：不传递参数时，表示的是获取系统的当前时间对象。也可以理解成是：获取当前代码执行的时间。\n打印结果：\n1 2 Mon Feb 17 2020 21:57:22 GMT+0800 (中国标准时间) object 写法二：传递参数 传递参数时，表示获取指定时间的时间对象。参数中既可以传递字符串，也可以传递数字，也可以传递时间戳。\n通过传参的这种写法，我们可以把时间字符串/时间数字/时间戳，按照指定的格式，转换为时间对象。\n举例1：（参数是字符串）\n1 2 3 4 5 6 7 8 9 10 11 const date11 = new Date(\u0026#39;2020/02/17 21:00:00\u0026#39;); console.log(date11); // Mon Feb 17 2020 21:00:00 GMT+0800 (中国标准时间) const date12 = new Date(\u0026#39;2020/04/19\u0026#39;); // 返回的就是四月 console.log(date12); // Sun Apr 19 2020 00:00:00 GMT+0800 (中国标准时间) const date13 = new Date(\u0026#39;2020-05-20\u0026#39;); console.log(date13); // Wed May 20 2020 08:00:00 GMT+0800 (中国标准时间) const date14 = new Date(\u0026#39;Wed Jan 27 2017 12:00:00 GMT+0800 (中国标准时间)\u0026#39;); console.log(date14); // Fri Jan 27 2017 12:00:00 GMT+0800 (中国标准时间) 举例2：（参数是多个数字）\n1 2 3 4 5 6 7 8 9 const date21 = new Date(2020, 2, 18); // 注意，第二个参数返回的是三月，不是二月 console.log(date21); // Wed Mar 18 2020 00:00:00 GMT+0800 (中国标准时间) const date22 = new Date(2020, 3, 18, 22, 59, 58); console.log(date22); // Sat Apr 18 2020 22:59:58 GMT+0800 (中国标准时间) const params = [2020, 06, 12, 16, 20, 59]; const date23 = new Date(...params); console.log(date23); // Sun Jul 12 2020 16:20:59 GMT+0800 (中国标准时间) 举例3：（参数是时间戳）\n1 2 3 4 5 6 7 const date31 = new Date(1591950413388); console.log(date31); // Fri Jun 12 2020 16:26:53 GMT+0800 (中国标准时间) // 先把时间对象转换成时间戳，然后把时间戳转换成时间对象 const timestamp = new Date().getTime(); const date32 = new Date(timestamp); console.log(date32); // Fri Jun 12 2020 16:28:21 GMT+0800 (中国标准时间) 日期的格式化 上一段内容里，我们获取到了 Date 对象，但这个对象，打印出来的结果并不是特别直观。\n如果我们需要获取日期的指定部分，就需要用到 Date对象自带的方法。\n获取了日期指定的部分之后，我们就可以让日期按照指定的格式，进行展示（即日期的格式化）。比如说，我期望能以 2020-02-02 19:30:59 这种格式进行展示。\n在这之前，我们先来看看 Date 对象有哪些方法。\nDate对象的方法 Date对象 有如下方法，可以获取日期和时间的指定部分：\n方法名 含义 备注 getFullYear() 获取年份 getMonth() 获取月： 0-11 0代表一月 getDate() 获取日：1-31 获取的是几号 getDay() 获取星期：0-6 0代表周日，1代表周一 getHours() 获取小时：0-23 getMinutes() 获取分钟：0-59 getSeconds() 获取秒：0-59 getMilliseconds() 获取毫秒 1s = 1000ms 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 我在执行这行代码时，当前时间为 2019年2月4日，周一，13:23:52 var myDate = new Date(); console.log(myDate); // 打印结果：Mon Feb 04 2019 13:23:52 GMT+0800 (中国标准时间) console.log(myDate.getFullYear()); // 打印结果：2019 console.log(myDate.getMonth() + 1); // 打印结果：2 console.log(myDate.getDate()); // 打印结果：4 var dayArr = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;,\u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; console.log(myDate.getDay()); // 打印结果：1 console.log(dayArr[myDate.getDay()]); // 打印结果：星期一 console.log(myDate.getHours()); // 打印结果：13 console.log(myDate.getMinutes()); // 打印结果：23 console.log(myDate.getSeconds()); // 打印结果：52 console.log(myDate.getMilliseconds()); // 打印结果：393 console.log(myDate.getTime()); // 获取时间戳。打印结果：1549257832393 获取了日期和时间的指定部分之后，我们把它们用字符串拼接起来，就可以按照自己想要的格式，来展示日期。\n举例：年月日的格式化 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 console.log(formatDate()); /* 方法：日期格式化。 格式要求：今年是：2020年02月02日 08:57:09 星期日 */ function formatDate() { var date = new Date(); var year = date.getFullYear(); // 年 var month = date.getMonth() + 1; // 月 var day = date.getDate(); // 日 var week = date.getDay(); // 星期几 var weekArr = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;, \u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; var hour = date.getHours(); // 时 hour = hour \u0026lt; 10 ? \u0026#39;0\u0026#39; + hour : hour; // 如果只有一位，则前面补零 var minute = date.getMinutes(); // 分 minute = minute \u0026lt; 10 ? \u0026#39;0\u0026#39; + minute : minute; // 如果只有一位，则前面补零 var second = date.getSeconds(); // 秒 second = second \u0026lt; 10 ? \u0026#39;0\u0026#39; + second : second; // 如果只有一位，则前面补零 var result = \u0026#39;今天是：\u0026#39; + year + \u0026#39;年\u0026#39; + month + \u0026#39;月\u0026#39; + day + \u0026#39;日 \u0026#39; + hour + \u0026#39;:\u0026#39; + minute + \u0026#39;:\u0026#39; + second + \u0026#39; \u0026#39; + weekArr[week]; return result; } 获取时间戳 时间戳的定义和作用 时间戳：指的是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 = 1000毫秒）。\n计算机底层在保存时间时，使用的都是时间戳。时间戳的存在，就是为了统一时间的单位。\n我们经常会利用时间戳来计算时间，因为它更精确。而且，在实战开发中，接口返回给前端的日期数据，都是以时间戳的形式。\n我们再来看下面这样的代码：\n1 2 3 var myDate = new Date(\u0026#34;1970/01/01 0:0:0\u0026#34;); console.log(myDate.getTime()); // 获取时间戳 打印结果（可能会让你感到惊讶）\n1 -28800000 为啥打印结果是-28800000，而不是0呢？这是因为，我们的当前代码，是在中文环境下运行的，与英文时间会存在8个小时的时差（中文时间比英文时间早了八个小时）。如果代码是在英文环境下运行，打印结果就是0。\ngetTime()：获取时间戳 getTime() 获取日期对象的时间戳（单位：毫秒）。这个方法在实战开发中，用得比较多。但还有比它更常用的写法，我们往下看。\n获取 Date 对象的时间戳 代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 方式一：获取 Date 对象的时间戳（最常用的写法） const timestamp1 = +new Date(); console.log(timestamp1); // 打印结果举例：1589448165370 // 方式二：获取 Date 对象的时间戳（较常用的写法） const timestamp2 = new Date().getTime(); console.log(timestamp2); // 打印结果举例：1589448165370 // 方式三：获取 Date 对象的时间戳 const timestamp3 = new Date().valueOf(); console.log(timestamp3); // 打印结果举例：1589448165370 // 方式4：获取 Date 对象的时间戳 const timestamp4 = new Date() * 1; console.log(timestamp4); // 打印结果举例：1589448165370 // 方式5：获取 Date 对象的时间戳 const timestamp5 = Number(new Date()); console.log(timestamp5); // 打印结果举例：1589448165370 上面这五种写法都可以获取任意 Date 对象的时间戳，最常见的写法是方式一，其次是方式二。\n根据前面所讲的关于「时间戳」的概念，上方代码获取到的时间戳指的是：从 1970年1月1日，0时0分0秒 到现在所花费的总毫秒数。\n获取当前时间的时间戳 如果我们要获取当前时间的时间戳，除了上面的几种方式之外，还有另一种方式。代码如下：\n1 2 // 方式六：获取当前时间的时间戳（很常用的写法） console.log(Date.now()); // 打印结果举例：1589448165370 上面这种方式六，用得也很多。只不过，Date.now()是H5标准中新增的特性，如果你的项目需要兼容低版本的IE浏览器，就不要用了。这年头，谁还用IE呢？\n利用时间戳检测代码的执行时间 我们可以在业务代码的前面定义 时间戳1，在业务代码的后面定义 时间戳2。把这两个时间戳相减，就能得出业务代码的执行时间。\nformat() 将时间对象转换为指定格式。\n参考链接：https://www.cnblogs.com/tugenhua0707/p/3776808.html\n练习 举例1：模拟日历 要求每天打开这个页面，都能定时显示当前的日期。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 800px; margin: 200px auto; color: red; text-align: center; font: 600 30px/30px \u0026#39;simsun\u0026#39;; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //模拟日历 //需求：每天打开这个页面都能定时显示年月日和星期几 function getCurrentDate() { //1.创建一个当前日期的日期对象 const date = new Date(); //2.然后获取其中的年、月、日和星期 const year = date.getFullYear(); const month = date.getMonth(); const hao = date.getDate(); const week = date.getDay(); // console.log(year+\u0026#34; \u0026#34;+month+\u0026#34; \u0026#34;+hao+\u0026#34; \u0026#34;+week); //3.赋值给div const arr = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;, \u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; const div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; return \u0026#39;今天是：\u0026#39; + year + \u0026#39;年\u0026#39; + (month + 1) + \u0026#39;月\u0026#39; + hao + \u0026#39;日 \u0026#39; + arr[week]; } const div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; div.innerText = getCurrentDate(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\n举例2：发布会倒计时 实现思路：\n设置一个定时器，每间隔1毫秒就自动刷新一次div的内容。\n核心算法：输入的时间戳减去当前的时间戳，就是剩余时间（即倒计时），然后转换成时分秒。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 1210px; margin: 200px auto; color: red; text-align: center; font: 600 30px/30px \u0026#39;simsun\u0026#39;; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; var timer = setInterval(() =\u0026gt; { countDown(\u0026#39;2022/02/03 11:20:00\u0026#39;); }, 1); function countDown(myTime) { var nowTime = new Date(); var future = new Date(myTime); var timeSum = future.getTime() - nowTime.getTime(); //获取时间差：发布会时间减去此刻的毫秒值 var day = parseInt(timeSum / 1000 / 60 / 60 / 24); // 天 var hour = parseInt((timeSum / 1000 / 60 / 60) % 24); // 时 var minu = parseInt((timeSum / 1000 / 60) % 60); // 分 var sec = parseInt((timeSum / 1000) % 60); // 秒 var millsec = parseInt(timeSum % 1000); // 毫秒 //细节处理：所有的时间小于10的时候，在前面自动补0，毫秒值要补双0（比如如，把 8 秒改成 08 秒） day = day \u0026lt; 10 ? \u0026#39;0\u0026#39; + day : day; //day小于10吗？如果小于，就补0；如果不小于，就是day本身 hour = hour \u0026lt; 10 ? \u0026#39;0\u0026#39; + hour : hour; minu = minu \u0026lt; 10 ? \u0026#39;0\u0026#39; + minu : minu; sec = sec \u0026lt; 10 ? \u0026#39;0\u0026#39; + sec : sec; if (millsec \u0026lt; 10) { millsec = \u0026#39;00\u0026#39; + millsec; } else if (millsec \u0026lt; 100) { millsec = \u0026#39;0\u0026#39; + millsec; } // 兜底处理 if (timeSum \u0026lt; 0) { div.innerHTML = \u0026#39;距离苹果发布会还有00天00小时00分00秒000毫秒\u0026#39;; clearInterval(timer); return; } // 前端要显示的文案 div.innerHTML = \u0026#39;距离苹果发布会还有\u0026#39; + day + \u0026#39;天\u0026#39; + hour + \u0026#39;小时\u0026#39; + minu + \u0026#39;分\u0026#39; + sec + \u0026#39;秒\u0026#39; + millsec + \u0026#39;毫秒\u0026#39;; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\nMoment.js Moment.js 是一个轻量级的JavaScript时间库，我们可以利用它很方便地进行时间操作，提升开发效率。\n中文官网：http://momentjs.cn/ 使用举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/moment.js/2.26.0/moment.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 按照指定的格式，格式化当前时间 console.log(moment().format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;)); // 打印结果举例：2020-06-12 16:38:38 console.log(typeof moment().format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;)); // 打印结果：string // 按照指定的格式，格式化指定的时间 console.log(moment(\u0026#39;2020/06/12 18:01:59\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;)); // 打印结果：2020-06-12 18:01:59 // 按照指定的格式，获取七天后的时间 console.log(moment().add(7, \u0026#39;days\u0026#39;).format(\u0026#39;YYYY-MM-DD hh:mm:ss\u0026#39;)); // 打印结果举例：2020-06-19 04:43:56 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/15-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1date/","summary":"内置对象：Date Date 对象在实际开发中，使用得很频繁，且容易在细节地方出错，需要引起重视。 内置对象 Date 用来处理日期和时间。 需要注意的是：与 Math 对象","title":"15-内置对象：Date"},{"content":" 之前学习的数据类型，只能存储一个值（字符串也为一个值）。如果我们想存储多个值，就可以使用数组。\n数组简介 数组（Array）是属于内置对象，我们可以在MDN网站上查询它的各种方法。\n数组和普通对象的功能类似，也是用来存储一些值的。不同的是：\n普通对象是使用字符串作为属性名的，而数组是使用数字作为索引来操作元素。索引：从 0 开始的整数就是索引。 数组的存储性能比普通对象要好。在实际开发中我们经常使用数组来存储一些数据（尤其是列表数据），使用频率非常高。\n比如说，上面这个页面的列表数据，它的结构就是一个大数组。\n数组中的元素可以是任意的数据类型，也可以是对象，也可以是函数，也可以是数组。数组的元素中，如果存放的是数组，我们就称这种数组为二维数组。\n接下来，我们讲一讲数组的基本操作。\n创建数组对象 方式一：使用字面量创建数组 举例：\n1 2 3 var arr1 = []; // 创建一个空的数组 var arr2 = [1, 2, 3]; // 创建带初始值的数组 方式一最简单，也用得最多。\n方式二：使用构造函数创建数组 语法：\n1 2 3 let arr = new Array(参数); let arr = Array(参数); 如果参数为空，则表示创建一个空数组；如果参数是一个数值时，表示数组的长度；如果有多个参数时，表示数组中的元素。\n来举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 方式一 var arr1 = [11, 12, 13]; // 方式二 var arr2 = new Array(); // 参数为空 var arr3 = new Array(4); // 参数为一个数值 var arr4 = new Array(15, 16, 17); // 参数为多个数值 console.log(typeof arr1); // 打印结果：object console.log(\u0026#39;arr1 = \u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;arr2 = \u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;arr3 = \u0026#39; + JSON.stringify(arr3)); console.log(\u0026#39;arr4 = \u0026#39; + JSON.stringify(arr4)); 打印结果：\n1 2 3 4 5 6 object; arr1 = [11, 12, 13]; arr2 = []; arr3 = [null, null, null, null]; arr4 = [15, 16, 17]; 从上方打印结果的第一行里，可以看出，数组的类型其实也是属于对象。\n数组中的元素的类型 数组中可以存放任意类型的数据，例如字符串、数字、布尔值、对象等。\n比如：\n1 const arr = [\u0026#39;qianguyihao\u0026#39;, 28, true, { name: \u0026#39;qianguyihao\u0026#39; }]; 我们甚至还可以存放多维数组（数组里面放数组）。比如：\n1 2 3 4 const arr2 = [ [11, 12, 13], [21, 22, 23], ]; 数组的基本操作 数组的索引 索引 (下标) ：用来访问数组元素的序号，代表的是数组中的元素在数组中的位置（下标从 0 开始算起）。\n数组可以通过索引来访问、设置、修改对应的数组元素。我们继续看看。\n向数组中添加元素 语法：\n1 数组[索引] = 值; 代码举例：\n1 2 3 4 5 6 7 8 9 10 var arr = []; // 向数组中添加元素 arr[0] = 10; arr[1] = 20; arr[2] = 30; arr[3] = 40; arr[5] = 50; console.log(JSON.stringify(arr)); 打印结果：\n1 [10,20,30,40,null,50] 获取数组中的元素 语法：\n1 数组[索引]; 如果读取不存在的索引（比如元素没那么多），系统不会报错，而是返回 undefined。\n代码举例：\n1 2 3 4 var arr = [21, 22, 23]; console.log(arr[0]); // 打印结果：21 console.log(arr[5]); // 打印结果：undefined 获取数组的长度 可以使用length属性来获取数组的长度(即“元素的个数”)。\n数组的长度是元素个数，不要跟索引号混淆。\n语法：\n1 数组的长度 = 数组名.length； 代码举例：\n1 2 3 var arr = [21, 22, 23]; console.log(arr.length); // 打印结果：3 补充：\n对于连续的数组，使用 length 可以获取到数组的长度（元素的个数）；对于非连续的数组，使用 length 会获取到数组的最大的索引+1。因此，尽量不要创建非连续的数组。\n修改数组的长度（修改 length） 如果修改的 length 大于原长度，则多出部分会空出来，置为 null。\n如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。\n（特例：伪数组 arguments 的长度可以修改，但是不能修改里面的元素，后面单独讲。）\n代码举例：\n1 2 3 4 5 6 7 8 9 10 var arr1 = [11, 12, 13]; var arr2 = [21, 22, 23]; // 修改数组 arr1 的 length arr1.length = 1; console.log(JSON.stringify(arr1)); // 修改数组 arr2 的 length arr2.length = 5; console.log(JSON.stringify(arr2)); 打印结果：\n1 [11][(21, 22, 23, null, null)]; 遍历数组 遍历: 就是把数组中的每个元素从头到尾都访问一次。\n最简单的做法是通过 for 循环，遍历数组中的每一项。举例：\n1 2 3 4 5 var arr = [10, 20, 30, 40, 50]; for (var i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); // 打印出数组中的每一项 } 下一篇文章，会学习数组的各种方法，到时候，会有更多的做法去遍历数组。\n案例 例 1：翻转数组 代码实现：\n1 2 3 4 5 6 var arr = [10, 20, 30, 40, 50]; // 原始数组 var newArr = []; // 翻转后的数组 for (var i = 0; i \u0026lt; arr.length; i++) { newArr[i] = arr[arr.length - i - 1]; } console.log(JSON.stringify(newArr)); 打印结果：\n1 [50,40,30,20,10] 例 2：冒泡排序 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 var arr = [20, 10, 50, 30, 40]; for (var i = 0; i \u0026lt; arr.length - 1; i++) { for (var j = 0; j \u0026lt; arr.length - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } console.log(JSON.stringify(arr)); 打印结果：\n1 [10,20,30,40,50] ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/16-%E6%95%B0%E7%BB%84%E7%AE%80%E4%BB%8B/","summary":"之前学习的数据类型，只能存储一个值（字符串也为一个值）。如果我们想存储多个值，就可以使用数组。 数组简介 数组（Array）是属于内置对象，我们","title":"16-数组简介"},{"content":"数组的方法清单 数组的类型相关 方法 描述 备注 Array.isArray() 判断是否为数组 toString() 将数组转换为字符串 Array.from(arrayLike) 将伪数组转化为真数组 Array.of(value1, value2, value3) 创建数组：将一系列值转换成数组 注意，获取数组的长度是用length属性，不是方法。关于 length属性，详见上一篇文章。\n数组元素的添加和删除 方法 描述 备注 push() 向数组的最后面插入一个或多个元素，返回结果为新数组的长度 会改变原数组 pop() 删除数组中的最后一个元素，返回结果为被删除的元素 会改变原数组 unshift() 在数组最前面插入一个或多个元素，返回结果为新数组的长度 会改变原数组 shift() 删除数组中的第一个元素，返回结果为被删除的元素 会改变原数组 slice() 从数组中提取指定的一个或多个元素，返回结果为新的数组 不会改变原数组 splice() 从数组中删除指定的一个或多个元素，返回结果为被删除元素组成的新数组 会改变原数组 fill() 填充数组：用固定的值填充数组，返回结果为新的数组 不会改变原数组 数组的合并和拆分 方法 描述 备注 concat() 合并数组：连接两个或多个数组，返回结果为新的数组 不会改变原数组 join() 将数组转换为字符串，返回结果为转换后的字符串 不会改变原数组 split() 将字符串按照指定的分隔符，组装为数组 不会改变原字符串 注意，split()是字符串的方法，不是数组的方法。\n数组排序 方法 描述 备注 reverse() 反转数组，返回结果为反转后的数组 会改变原数组 sort() 对数组的元素,默认按照Unicode 编码，从小到大进行排序 会改变原数组 查找数组的元素 方法 描述 备注 indexOf(value) 从前往后索引，检索一个数组中是否含有指定的元素 lastIndexOf(value) 从后往前索引，检索一个数组中是否含有指定的元素 includes(item) 数组中是否包含指定的内容 find(function()) 找出第一个满足「指定条件返回 true」的元素 findIndex(function()) 找出第一个满足「指定条件返回 true」的元素的 index every() 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true 全真才为真。要求每一项都返回 true，最终的结果才返回 true some() 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true 一真即真。只要有一项返回 true，最终的结果就返回 true 遍历数组 方法 描述 备注 for 循环 这个大家都懂 forEach() 和 for 循环类似，但需要兼容 IE8 以上 forEach() 没有返回值。也就是说，它的返回值是 undefined map() 对原数组中的每一项进行加工，将组成新的数组 不会改变原数组 filter() 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为新的数组 不会改变原数组 reduce 接收一个函数作为累加器，返回值是回调函数累计处理的结果 isArray()：判断是否为数组 语法：\n1 布尔值 = Array.isArray(被检测的数组); 以前，我们会通过 A instanceof B来判断 A 是否属于 B 类型。但是在数组里，这种 instanceof 方法已经用的不多了，因为有 isArray()方法。\ntoString()：数组转换为字符串 1 字符串 = 数组.toString(); 解释：把数组转换成字符串，每一项用,分割。\n备注：大多数的数据类型都可以使用.toString()方法，将其转换为字符串。\n知识点补充：将数组转换为字符串，有哪些方式 方式 1：\n1 字符串 = 数组.toString(); 方式 2：\n1 字符串 = String(数组); 方式 3：\n1 字符串 = 数组.join(\u0026#39;,\u0026#39;); // 将数组转为字符串，每一项用 英文逗号 分隔 Array.from()：将伪数组转换为真数组 语法：\n1 array = Array.from(arrayLike); 作用：将伪数组或可遍历对象转换为真数组。\n代码举例：\n1 2 const name = \u0026#39;qianguyihao\u0026#39;; console.log(Array.from(name)); // 打印结果是数组：[\u0026#34;q\u0026#34;,\u0026#34;i\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;g\u0026#34;,\u0026#34;u\u0026#34;,\u0026#34;y\u0026#34;,\u0026#34;i\u0026#34;,\u0026#34;h\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;o\u0026#34;] 伪数组与真数组的区别 伪数组：包含 length 属性的对象或可迭代的对象。\n另外，伪数组的原型链中没有 Array.prototype，而真数组的原型链中有 Array.prototype。因此伪数组没有数组的一般方法，比如 pop()、join() 等方法。\n伪数组举例 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;按钮3\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; let btnArray = document.getElementsByTagName(\u0026#39;button\u0026#39;); console.log(btnArray); console.log(btnArray[0]); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 上面的布局中，有三个 button 标签，我们通过getElementsByTagName获取到的btnArray实际上是伪数组，并不是真实的数组：\n既然btnArray是伪数组，它就不能使用数组的一般方法，否则会报错：\n解决办法：采用Array.from方法将btnArray这个伪数组转换为真数组即可：\n1 Array.from(btnArray); 然后就可以使用数组的一般方法了：\nArray.of()：创建数组 语法：\n1 Array.of(value1, value2, value3); 作用：根据参数里的内容，创建数组。\n举例：\n1 2 const arr = Array.of(1, \u0026#39;abc\u0026#39;, true); console.log(arr); // 打印结果是数组：[1, \u0026#34;abc\u0026#34;, true] 补充：new Array()和 Array.of()的区别在于：当参数只有一个时，前者表示数组的长度，后者表示数组中的内容。\n数组元素的添加和删除 push() push()：向数组的最后面插入一个或多个元素，返回结果为新数组的长度。会改变原数组，因为原数组变成了新数组。\n语法：\n1 新数组的长度 = 数组.push(元素); 代码举例：\n1 2 3 4 5 6 7 8 var arr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; var result1 = arr.push(\u0026#39;王四\u0026#39;); // 末尾插入一个元素 var result2 = arr.push(\u0026#39;王五\u0026#39;, \u0026#39;王六\u0026#39;); // 末尾插入多个元素 console.log(result1); // 打印结果：4 console.log(result2); // 打印结果：6 console.log(JSON.stringify(arr)); // 打印结果：[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;,\u0026#34;王四\u0026#34;,\u0026#34;王五\u0026#34;,\u0026#34;王六\u0026#34;] pop() pop()：删除数组中的最后一个元素，返回结果为被删除的元素。\n语法：\n1 被删除的元素 = 数组.pop(); 代码举例：\n1 2 3 4 5 6 var arr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; var result1 = arr.pop(); console.log(result1); // 打印结果：王三 console.log(JSON.stringify(arr)); // 打印结果：[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;] unshift() unshift()：在数组最前面插入一个或多个元素，返回结果为新数组的长度。会改变原数组，因为原数组变成了新数组。插入元素后，其他元素的索引会依次调整。\n语法：\n1 新数组的长度 = 数组.unshift(元素); 代码举例：\n1 2 3 4 5 6 7 8 var arr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; var result1 = arr.unshift(\u0026#39;王四\u0026#39;); // 最前面插入一个元素 var result2 = arr.unshift(\u0026#39;王五\u0026#39;, \u0026#39;王六\u0026#39;); // 最前面插入多个元素 console.log(result1); // 打印结果：4 console.log(result2); // 打印结果：6 console.log(JSON.stringify(arr)); // 打印结果：[\u0026#34;王五\u0026#34;,\u0026#34;王六\u0026#34;,\u0026#34;王四\u0026#34;,\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] shift() shift()：删除数组中的第一个元素，返回结果为被删除的元素。\n语法：\n1 被删除的元素 = 数组.shift(); 代码举例：\n1 2 3 4 5 6 var arr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; var result1 = arr.shift(); console.log(result1); // 打印结果：王一 console.log(JSON.stringify(arr)); // 打印结果：[\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] slice() slice()：从数组中提取指定的一个或者多个元素，返回结果为新的数组（不会改变原来的数组）。\n备注：该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。\n语法：\n1 新数组 = 原数组.slice(开始位置的索引, 结束位置的索引); //注意：包含开始索引，不包含结束索引 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; const result1 = arr.slice(); // 不加参数时，则获取所有的元素。相当于数组的整体赋值 const result2 = arr.slice(2); // 从第二个值开始提取，直到末尾 const result3 = arr.slice(-2); // 提取最后两个元素 const result4 = arr.slice(2, 4); // 提取从第二个到第四个之间的元素（不包括第四个元素） const result5 = arr.slice(4, 2); // 空 console.log(\u0026#39;arr:\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result1:\u0026#39; + JSON.stringify(result1)); console.log(\u0026#39;result2:\u0026#39; + JSON.stringify(result2)); console.log(\u0026#39;result3:\u0026#39; + JSON.stringify(result3)); console.log(\u0026#39;result4:\u0026#39; + JSON.stringify(result4)); console.log(\u0026#39;result5:\u0026#39; + JSON.stringify(result5)); 打印结果：\n1 2 3 4 5 6 arr: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; result1: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; result2: [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; result3: [\u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; result4: [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; result5: []; 补充：\n很多前端开发人员会用 slice()将伪数组，转化为真数组。写法如下：\n1 2 3 4 5 // 方式1 array = Array.prototype.slice.call(arrayLike); // 方式2 array = [].slice.call(arrayLike); ES6 看不下去这种蹩脚的转化方法，于是出了一个新的 API：（专门用来将伪数组转化成真数组）\n1 array = Array.from(arrayLike); 关于这个 API 的详细介绍，上面的内容已经讲了，请往前翻。\nsplice() splice()：从数组中删除指定的一个或多个元素，返回结果为被删除元素组成的新数组（会改变原来的数组）。\n备注：该方法会改变原数组，会将指定元素从原数组中删除；被删除的元素会封装到一个新的数组中返回。\n语法：\n1 2 3 4 新数组 = 原数组.splice(起始索引index, 需要删除的个数); 新数组 = 原数组.splice(起始索引index, 需要删除的个数, 新的元素1, 新的元素2...); 上方语法中，第三个及之后的参数，表示：删除元素之后，向原数组中添加新的元素，这些元素将会自动插入到起始位置索引的前面。也可以理解成：删除了哪些元素，就在那些元素的所在位置补充新的内容。\nslice()方法和splice()方法很容易搞混，请一定要注意区分。\n举例 1：\n1 2 3 4 5 var arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; var result1 = arr1.splice(1); //从第index为1的位置开始，删除元素 console.log(\u0026#39;arr1：\u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;result1：\u0026#39; + JSON.stringify(result1)); 打印结果：\n1 2 arr1：[\u0026#34;a\u0026#34;] result1：[\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] 举例 2：\n1 2 3 4 5 var arr2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; var result2 = arr2.splice(-2); //删除最后两个元素 console.log(\u0026#39;arr2：\u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;result2：\u0026#39; + JSON.stringify(result2)); 打印结果：\n1 2 arr2：[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;] result2：[\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] 举例 3：\n1 2 3 4 5 var arr3 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; var result3 = arr3.splice(1, 3); //从第index为1的位置开始删除元素,一共删除三个元素 console.log(\u0026#39;arr3：\u0026#39; + JSON.stringify(arr3)); console.log(\u0026#39;result3：\u0026#39; + JSON.stringify(result3)); 打印结果：\n1 2 arr3：[\u0026#34;a\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] result3：[\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;] 举例 4：（我们来看看第三个参数的用法）\n1 2 3 4 5 6 7 var arr4 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; //从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素 var result4 = arr4.splice(1, 3, \u0026#39;lvbu\u0026#39;, \u0026#39;vae\u0026#39;); console.log(\u0026#39;arr4：\u0026#39; + JSON.stringify(arr4)); console.log(\u0026#39;result4：\u0026#39; + JSON.stringify(result4)); 打印结果：\n1 2 arr4：[\u0026#34;a\u0026#34;,\u0026#34;lvbu\u0026#34;,\u0026#34;vae\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] result4：[\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;] fill() fill()：用一个固定值填充数组，返回结果为新的数组。不会改变原数组。\n语法：\n1 2 3 4 5 6 7 8 // 用一个固定值填充数组。数组里的每个元素都会被这个固定值填充 新数组 = 数组.fill(固定值); // 从 startIndex 开始的数组元素，用固定值填充 新数组 = 数组.fill(固定值, startIndex); // 从 startIndex 到 endIndex 之间的元素（包左不包右），用固定值填充 新数组 = 数组.fill(固定值, startIndex, endIndex); 举例：\n1 2 3 4 5 6 7 8 // 创建一个长度为4的空数组，然后用 \u0026#39;f\u0026#39; 来填充这个空数组 console.log(Array(4).fill(\u0026#39;f\u0026#39;)); // [\u0026#39;f\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;f,\u0026#39; \u0026#39;f\u0026#39;] // 将现有数组的每一个元素都进行填充 console.log([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;].fill(\u0026#39;f\u0026#39;)); // [\u0026#39;f\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;f,\u0026#39; \u0026#39;f\u0026#39;] // 指定位置进行填充 console.log([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;].fill(\u0026#39;f\u0026#39;, 1, 3)); // [\u0026#34;a\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;d\u0026#34;] 数组的合并和拆分 concat() concat()：连接两个或多个数组，返回结果为新的数组。不会改变原数组。concat()方法的作用是数组合并。\n语法：\n1 新数组 = 数组1.concat(数组2, 数组3 ...); 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const arr1 = [1, 2, 3]; const arr2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; const arr3 = [\u0026#39;lvbu\u0026#39;, \u0026#39;vae\u0026#39;]; const result1 = arr1.concat(arr2); const result2 = arr2.concat(arr1, arr3); console.log(\u0026#39;arr1 =\u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;arr2 =\u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;arr3 =\u0026#39; + JSON.stringify(arr3)); console.log(\u0026#39;result1 =\u0026#39; + JSON.stringify(result1)); console.log(\u0026#39;result2 =\u0026#39; + JSON.stringify(result2)); 打印结果：\n1 2 3 4 5 6 arr1 = [1, 2, 3]; arr2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; arr3 = [\u0026#39;lvbu\u0026#39;, \u0026#39;vae\u0026#39;]; result1 = [1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; result2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, 1, 2, 3, \u0026#39;lvbu\u0026#39;, \u0026#39;vae\u0026#39;]; 从打印结果中可以看到，原数组并没有被修改。\n数组合并的另一种方式：\n我们可以使用...这种展开语法，将两个数组进行合并。举例如下：\n1 2 3 4 const arr1 = [1, 2, 3]; const result = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, ...arr1]; console.log(JSON.stringify(result)); // 打印结果：[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,1,2,3] join() join()：将数组转换为字符串，返回结果为转换后的字符串（不会改变原来的数组）。\n补充：join()方法可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符；如果不指定连接符，则默认使用 , 作为连接符，此时和 toString()的效果是一致的。\n语法：\n1 新的字符串 = 原数组.join(参数); // 参数选填 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 var arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; var result1 = arr.join(); // 这里没有指定连接符，所以默认使用 , 作为连接符 var result2 = arr.join(\u0026#39;-\u0026#39;); // 使用指定的字符串作为连接符 console.log(typeof arr); // 打印结果：object console.log(typeof result1); // 打印结果：string console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result1 =\u0026#39; + JSON.stringify(result1)); console.log(\u0026#39;result2 =\u0026#39; + JSON.stringify(result2)); 上方代码中，最后三行的打印结果是：\n1 2 3 arr =[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;] result1 =a,b,c result2 =a-b-c split() 注意，split()是字符串的方法，不是数组的方法。\n语法：\n1 新的数组 = str.split(分隔符); 解释：通过指定的分隔符，将一个字符串拆分成一个数组。不会改变原字符串。\n备注：split()这个方法在实际开发中用得非常多。一般来说，从接口拿到的 json 数据中，经常会收到类似于\u0026quot;q, i, a, n\u0026quot;这样的字符串，前端需要将这个字符串拆分成['q', 'i', 'a', 'n']数组，这个时候split()方法就派上用场了。\nreverse() reverse()：反转数组，返回结果为反转后的数组（会改变原来的数组）。\n语法：\n1 反转后的数组 = 数组.reverse(); 举例：\n1 2 3 4 5 6 var arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; var result = arr.reverse(); // 将数组 arr 进行反转 console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果：\n1 2 arr =[\u0026#34;f\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;] result =[\u0026#34;f\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;] 从打印结果可以看出，原来的数组已经被改变了。\nsort()方法 sort()方法需要好好理解。\nsort()：对数组的元素进行从小到大来排序（会改变原来的数组）。\nsort()方法：无参时 如果在使用 sort() 方法时不带参，则默认按照Unicode 编码，从小到大进行排序。\n举例 1：（当数组中的元素为字符串时）\n1 2 3 4 5 6 let arr1 = [\u0026#39;e\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;c\u0026#39;]; let result = arr1.sort(); // 将数组 arr1 进行排序 console.log(\u0026#39;arr1 =\u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果：\n1 2 arr1 =[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] result =[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] 从上方的打印结果中，我们可以看到，sort 方法会改变原数组，而且方法的返回值也是同样的结果。\n举例 2：（当数组中的元素为数字时）\n1 2 3 4 5 6 let arr2 = [5, 2, 11, 3, 4, 1]; let result = arr2.sort(); // 将数组 arr2 进行排序 console.log(\u0026#39;arr2 =\u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果：\n1 2 arr2 =[1,11,2,3,4,5] result =[1,11,2,3,4,5] 上方的打印结果中，你会发现，使用 sort() 排序后，数字11竟然在数字2的前面。这是为啥呢？因为上面讲到了，sort()方法是按照Unicode 编码进行排序的。\n那如果我想让 arr2 里的数字，完全按照从小到大排序，怎么操作呢？继续往下看。\nsort()方法：带参时，自定义排序规则 如果在 sort()方法中带参，我们就可以自定义排序规则。具体做法如下：\n我们可以在 sort()添加一个回调函数，来指定排序规则。回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数。\n浏览器根据回调函数的返回值来决定元素的排序：（重要）\n如果返回一个大于 0 的值，则元素会交换位置\n如果返回一个小于 0 的值，则元素位置不变\n如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置\n如果只是看上面的文字，可能不太好理解，我们来看看下面的例子，你肯定就能明白。\n举例：将数组中的数字按照从小到大排序 写法 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var arr = [5, 2, 11, 3, 4, 1]; // 自定义排序规则 var result = arr.sort(function (a, b) { if (a \u0026gt; b) { // 如果 a 大于 b，则交换 a 和 b 的位置 return 1; } else if (a \u0026lt; b) { // 如果 a 小于 b，则位置不变 return -1; } else { // 如果 a 等于 b，则位置不变 return 0; } }); console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果：\n1 2 arr = [1, 2, 3, 4, 5, 11]; result = [1, 2, 3, 4, 5, 11]; 上方代码的写法太啰嗦了，其实也可以简化为如下写法：\n写法 2：（冒泡排序）\n1 2 3 4 5 6 7 8 9 10 let arr = [5, 2, 11, 3, 4, 1]; // 自定义排序规则 let result = arr.sort(function (a, b) { return a - b; // 升序排列 // return b - a; // 降序排列 }); console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果不变。\n上方代码还可以写成 ES6 的形式，也就是将 function 改为箭头函数，其写法如下。\n写法 3：（箭头函数）\n1 2 3 4 5 6 7 8 9 let arr = [5, 2, 11, 3, 4, 1]; // 自定义排序规则 let result = arr.sort((a, b) =\u0026gt; { return a - b; // 升序排列 }); console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 上方代码，因为函数体内只有一句话，所以可以去掉 return 语句，继续简化为如下写法。\n写法 4：（推荐）\n1 2 3 4 5 6 7 let arr = [5, 2, 11, 3, 4, 1]; // 自定义排序规则：升序排列 let result = arr.sort((a, b) =\u0026gt; a - b); console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 上面的各种写法中，写法 4 是我们在实战开发中用得最多的。\n为了确保代码的简洁优雅，接下来的代码中，凡是涉及到函数，我们将尽量采用 ES6 中的箭头函数来写。\nsort 方法举例：将数组从小到大排序 将数组从小到大排序，这个例子很常见。但在实际开发中，总会有一些花样。\n下面这段代码，在实际开发中，经常用到，一定要掌握。完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let dataList = [ { title: \u0026#39;品牌鞋子，高品质低价入手\u0026#39;, publishTime: 200, }, { title: \u0026#39;不是很贵，但是很暖\u0026#39;, publishTime: 100, }, { title: \u0026#39;无法拒绝的美食，跟我一起吃吃\u0026#39;, publishTime: 300, }, ]; console.log(\u0026#39;qianguyihao 排序前的数组：\u0026#39; + JSON.stringify(dataList)); // 将dataList 数组，按照 publishTime 字段，从小到大排序。（会改变原数组） dataList.sort((a, b) =\u0026gt; parseInt(a.publishTime) - parseInt(b.publishTime)); console.log(\u0026#39;qianguyihao 排序后的数组：\u0026#39; + JSON.stringify(dataList)); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 qianguyihao 排序前的数组：[ {\u0026#34;title\u0026#34;:\u0026#34;品牌鞋子，高品质低价入手\u0026#34;,\u0026#34;publishTime\u0026#34;:200}, {\u0026#34;title\u0026#34;:\u0026#34;不是很贵，但是很暖\u0026#34;,\u0026#34;publishTime\u0026#34;:100}, {\u0026#34;title\u0026#34;:\u0026#34;无法拒绝的美食，跟我一起吃吃\u0026#34;,\u0026#34;publishTime\u0026#34;:300} ] qianguyihao 排序后的数组：[ {\u0026#34;title\u0026#34;:\u0026#34;不是很贵，但是很暖\u0026#34;,\u0026#34;publishTime\u0026#34;:100}, {\u0026#34;title\u0026#34;:\u0026#34;品牌鞋子，高品质低价入手\u0026#34;,\u0026#34;publishTime\u0026#34;:200}, {\u0026#34;title\u0026#34;:\u0026#34;无法拒绝的美食，跟我一起吃吃\u0026#34;,\u0026#34;publishTime\u0026#34;:300} ] 上方代码中，有人可能会问： publishTime 字段已经是 int 类型了，为啥在排序前还要做一次 parseInt() 转换？这是因为，这种数据，一般是后台接口返回给前端的，数据可能是 int 类型、也可能是字符串类型，所以还是统一先做一次 partInt() 比较保险。这是一种良好的工作习惯。\nindexOf() 和 lastIndexOf()：获取数据的索引 语法 1：\n1 2 3 索引值 = 数组.indexOf(想要查询的元素); 索引值 = 数组.lastIndexOf(想要查询的元素); 备注：indexOf() 是从前向后查找元素的位置。同理，lastIndexOf()是从后向前寻找。\n解释：可以检索一个数组中是否含有指定的元素。如果数组中含有该元素，则会返回其第一次出现的索引；如果没有找到指定的内容，则返回 -1。\n这个方法的作用：\n如果获取的索引值为 0，说明数组是以查询的元素为开头的。\n如果获取的索引值为-1，说明这个数组中没有指定的元素。\n注意：indexOf()在检索时，是严格类型约束，类似于===。\n举例 1：\n1 2 3 4 var arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;c\u0026#39;]; console.log(arr.indexOf(\u0026#39;c\u0026#39;)); //从前往后，找第一个\u0026#34;c\u0026#34;在哪个位置 console.log(arr.lastIndexOf(\u0026#39;d\u0026#39;)); //从后往前，找第一个\u0026#34;d\u0026#34;在哪个位置 打印结果：\n1 2 2 5 举例 2：\n1 2 let arr = [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;]; console.log(arr.indexOf(2)); 打印结果：\n1 -1 语法 2：\n这个方法还可以指定第二个参数，用来指定查找的起始位置。语法如下：\n1 索引值 = 数组.indexOf(想要查询的元素, [起始位置]); 举例 3：（两个参数时，需要特别注意）\n1 2 3 4 let arr = [\u0026#39;q\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;o\u0026#39;]; result = str.indexOf(\u0026#39;a\u0026#39;, 3); // 从第三个位置开始查找 \u0026#39;a\u0026#39;这个元素 【重要】 console.log(result); // 打印结果：9 上方代码中，indexOf()方法中携带了两个参数，具体解释请看注释。\nincludes() 语法：\n1 布尔值 = arr.includes(想要查找的元素, [position]); 解释：判断一个数组中是否包含指定的元素。如果是，则会返回 true；否则返回 false。\n参数中的 position：如果不指定，则默认为0；如果指定，则规定了检索的起始位置。\n1 2 3 4 5 const arr = [11, 12, 13, 14, 15]; console.log(arr.includes(12)); // 打印结果：true console.log(name.includes(20)); // 打印结果：false console.log(name.includes(11, 1)); // 打印结果：false find() 语法：\n1 2 3 find((item, index, arr) =\u0026gt; { return true; }); 作用：找出第一个满足「指定条件返回 true」的元素；如果没找到，则返回 undefined。\n备注：一旦找到符合条件的第一个元素，将不再继续往下遍历。\n举例：\n1 2 3 4 5 6 7 let arr = [2, 3, 2, 5, 7, 6]; let result = arr.find((item, index) =\u0026gt; { return item \u0026gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素返回 }); console.log(result); //打印结果：5 findIndex() 语法：\n1 2 3 findIndex((item, index, arr) =\u0026gt; { return true; }); 作用：找出第一个满足「指定条件返回 true」的元素的 index。\n举例：\n我们直接把上面的代码中的 find 方法改成 findIndex，来看看效果。\n1 2 3 4 5 6 7 let arr = [2, 3, 2, 5, 7, 6]; let result = arr.findIndex((item, index) =\u0026gt; { return item \u0026gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素的index返回 }); console.log(result); //打印结果：3 every() every()：对数组中每一项运行回调函数，如果都返回 true，every 就返回 true；如果有一项返回 false，则停止遍历，此方法返回 false。\n注意：every()方法的返回值是 boolean 值，参数是回调函数。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var arr1 = [\u0026#39;千古\u0026#39;, \u0026#39;宿敌\u0026#39;, \u0026#39;南山忆\u0026#39;, \u0026#39;素颜\u0026#39;]; var bool1 = arr1.every(function (element, index, array) { if (element.length \u0026gt; 2) { return false; } return true; }); console.log(bool1); //输出结果：false。只要有一个元素的长度是超过两个字符的，就返回false var arr2 = [\u0026#39;千古\u0026#39;, \u0026#39;宿敌\u0026#39;, \u0026#39;南山\u0026#39;, \u0026#39;素颜\u0026#39;]; var bool2 = arr2.every(function (element, index, array) { if (element.length \u0026gt; 2) { return false; } return true; }); console.log(bool2); //输出结果：true。因为每个元素的长度都是两个字符。 some() some()：对数组中每一个元素运行回调函数，只要有一个元素返回 true，则停止遍历，此方法返回 true。\n注意：some()方法的返回值是 boolean 值。\nevery() 和 some() 的使用场景 every() 和 some() 这两个方法，初学者很容易搞混。要怎么区分呢？你可以这样记：\nevery()：全部真，才为真。当你需要让数组中的每一个元素都满足指定条件时，那就使用 every()。\nsome()：一个真，则为真，点到为止。数组中只要有一个元素满足指定条件时，就停止遍历。那就使用 some()。\nvalueOf()：返回数组本身 1 数组本身 = 数组.valueOf(); 这个方法的意义不大。因为我们直接写数组对象的名字，就已经是数组本身了。\n概念：数组的遍历 遍历数组即：获取并操作数组中的每一个元素，然后得到想要的返回结果。在我们的实战开发中，使用得非常频繁。\n遍历数组的方法包括：every()、filter()、forEach()、map()等。\nPS：这几个方法不会修改原数组。\n语法格式：\n1 2 3 4 数组/boolean/无 = 数组.every/filter/forEach/map/some( function(item, index, arr){ 程序和返回值； }) 有了这几种方法，就可以替代一些 for 循环了。下面依次来介绍。\nfor 循环遍历 举例：\n1 2 3 4 5 6 const arr = [\u0026#39;生命壹号\u0026#39;, \u0026#39;许嵩\u0026#39;, \u0026#39;永不止步\u0026#39;]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); // arr[i]代表的是数组中的每一个元素i } console.log(JSON.stringify(arr)); 打印结果：\n1 2 3 4 5 生命壹号 许嵩 永不止步 [\u0026#34;生命壹号\u0026#34;,\u0026#34;许嵩\u0026#34;,\u0026#34;永不止步\u0026#34;] forEach() 遍历 forEach() 这种遍历方法只支持 IE8 以上的浏览器。IE8 及以下的浏览器均不支持该方法。所以如果需要兼容 IE8，则不要使用 forEach，改为使用 for 循环来遍历即可。\nforEach()方法需要一个函数作为参数。这种函数，是由我们创建但是不由我们调用的，我们称为回调函数。\n数组中有几个元素，该回调函数就会执行几次。\n回调函数中传递三个参数：\n第一个参数，就是当前正在遍历的元素\n第二个参数，就是当前正在遍历的元素的索引\n第三个参数，就是正在遍历的数组\n代码举例：\n1 2 3 4 5 6 7 8 let myArr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; myArr.forEach((item, index, arr) =\u0026gt; { console.log(\u0026#39;item:\u0026#39; + item); console.log(\u0026#39;index:\u0026#39; + index); console.log(\u0026#39;arr:\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;----------\u0026#39;); }); 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 12 item:王一 index:0 arr:[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] ---------- item:王二 index:1 arr:[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] ---------- item:王三 index:2 arr:[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] ---------- 注意，forEach() 没有返回值。也可以理解成：forEach() 的返回值是 undefined。如果你尝试 tempArry = myArr.forEach()这种方式来接收，是达不到效果的。\nforEach() 能不能改变原数组？ forEach() 能不能改变原数组？关于这个问题，大部分人会搞错。我们来看看下面的代码。\n1、数组的元素是基本数据类型：（无法改变原数组）\n1 2 3 4 5 6 let numArr = [1, 2, 3]; numArr.forEach((item) =\u0026gt; { item = item * 2; }); console.log(JSON.stringify(numArr)); // 打印结果：[1, 2, 3] 上面这段代码，你可要看仔细了，打印结果是 [1, 2, 3]，不是 [2, 4, 6]。\n2、数组的元素是引用数据类型：（直接修改整个元素对象时，无法改变原数组）\n1 2 3 4 5 6 7 8 9 10 11 12 let objArr = [ { name: \u0026#39;lvbu\u0026#39;, age: 20 }, { name: \u0026#39;许嵩\u0026#39;, age: 30 }, ]; objArr.forEach((item) =\u0026gt; { item = { name: \u0026#39;邓紫棋\u0026#39;, age: \u0026#39;29\u0026#39;, }; }); console.log(JSON.stringify(objArr)); // 打印结果：[{\u0026#34;name\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;age\u0026#34;:20},{\u0026#34;name\u0026#34;:\u0026#34;许嵩\u0026#34;,\u0026#34;age\u0026#34;:30}] 3、数组的元素是引用数据类型：（修改元素对象里的某个属性时，可以改变原数组）\n1 2 3 4 5 6 7 8 9 let objArr = [ { name: \u0026#39;lvbu\u0026#39;, age: 28 }, { name: \u0026#39;许嵩\u0026#39;, age: 30 }, ]; objArr.forEach((item) =\u0026gt; { item.name = \u0026#39;邓紫棋\u0026#39;; }); console.log(JSON.stringify(objArr)); // 打印结果：[{\u0026#34;name\u0026#34;:\u0026#34;邓紫棋\u0026#34;,\u0026#34;age\u0026#34;:28},{\u0026#34;name\u0026#34;:\u0026#34;邓紫棋\u0026#34;,\u0026#34;age\u0026#34;:30}] 如果你需要通过 forEach 修改原数组，建议用 forEach 里面的参数 2 和参数 3 来做，具体请看下面的标准做法。\n4、forEach() 通过参数 2、参数 3 修改原数组：（标准做法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 1、数组的元素是基本数据类型 let numArr = [1, 2, 3]; numArr.forEach((item, index, arr) =\u0026gt; { arr[index] = arr[index] * 2; }); console.log(JSON.stringify(numArr)); // 打印结果：[2,4,6] // 2、数组的元素是引用数据类型时，直接修改对象 let objArr = [ { name: \u0026#39;lvbu\u0026#39;, age: 28 }, { name: \u0026#39;许嵩\u0026#39;, age: 34 }, ]; objArr.forEach((item, index, arr) =\u0026gt; { arr[index] = { name: \u0026#39;小明\u0026#39;, age: \u0026#39;10\u0026#39;, }; }); console.log(JSON.stringify(objArr)); // 打印结果：[{\u0026#34;name\u0026#34;:\u0026#34;小明\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;10\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;小明\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;10\u0026#34;}] // 3、数组的元素是引用数据类型时，修改对象的某个属性 let objArr2 = [ { name: \u0026#39;lvbu\u0026#39;, age: 28 }, { name: \u0026#39;许嵩\u0026#39;, age: 34 }, ]; objArr2.forEach((item, index, arr) =\u0026gt; { arr[index].name = \u0026#39;小明\u0026#39;; }); console.log(JSON.stringify(objArr2)); // 打印结果：[{\u0026#34;name\u0026#34;:\u0026#34;小明\u0026#34;,\u0026#34;age\u0026#34;:28},{\u0026#34;name\u0026#34;:\u0026#34;小明\u0026#34;,\u0026#34;age\u0026#34;:34}] 总结：\n如果纯粹只是遍历数组，那么，可以用 forEach() 方法。但是，如果你想在遍历数组的同时，去改变数组里的元素内容，那么，最好是用 map() 方法来做，不要用 forEach()方法，避免出现一些低级错误。\n参考链接：\nforEach 到底可以改变原数组吗？\nforEach 会改变原数组值吗\nmap()方法 语法：\n1 2 3 arr.map(function (item, index, arr) { return newItem; }); 解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是加工之后的新数组）。不会改变原数组。\n作用：对数组中的每一项进行加工。\n举例 1：（拷贝的过程中改变数组元素的值）\n有一个已知的数组 arr1，我要求让 arr1 中的每个元素的值都加 10，这里就可以用到 map 方法。代码举例：\n1 2 3 4 5 6 var arr1 = [1, 3, 6, 2, 5, 6]; var arr2 = arr1.map(function (item, index) { return item + 10; //让arr1中的每个元素加10 }); console.log(arr2); 打印结果：\n举例 2：【重要案例，实际开发中经常用到】\n将 A 数组中某个属性的值，存储到 B 数组中。代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const arr1 = [ { name: \u0026#39;lvbu\u0026#39;, age: \u0026#39;28\u0026#39; }, { name: \u0026#39;许嵩\u0026#39;, age: \u0026#39;32\u0026#39; }, ]; // 将数组 arr1 中的 name 属性，存储到 数组 arr2 中 const arr2 = arr1.map((item) =\u0026gt; item.name); // 将数组 arr1 中的 name、age这两个属性，改一下“键”的名字，存储到 arr3中 const arr3 = arr1.map((item) =\u0026gt; ({ myName: item.name, myAge: item.age, })); // 将数组 arr1 中的 name 属性，存储到 数组 arr2 中 console.log(\u0026#39;arr1:\u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;arr2:\u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;arr3:\u0026#39; + JSON.stringify(arr3)); 打印结果：\n1 2 3 4 5 arr1:[{\u0026#34;name\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;28\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;许嵩\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;32\u0026#34;}] arr2:[\u0026#34;lvbu\u0026#34;,\u0026#34;许嵩\u0026#34;] arr3:[{\u0026#34;myName\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;myAge\u0026#34;:\u0026#34;28\u0026#34;},{\u0026#34;myName\u0026#34;:\u0026#34;许嵩\u0026#34;,\u0026#34;myAge\u0026#34;:\u0026#34;32\u0026#34;}] map 的应用场景，主要就是以上两种。\n注意：map() 方法真的不会改变原数组吗？ 答案：不一定。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const arr = [ { name: \u0026#34;qianguyihao1\u0026#34;, age: 22, }, { name: \u0026#34;qianguyihao2\u0026#34;, age: 23, }, ]; arr.map((item) =\u0026gt; { item.name = \u0026#34;haha\u0026#34;; // 修改 item 里的某个属性 return item; }); console.log(JSON.stringify(arr)); 打印结果：\n1 [{\u0026#34;name\u0026#34;:\u0026#34;haha\u0026#34;,\u0026#34;age\u0026#34;:22},{\u0026#34;name\u0026#34;:\u0026#34;haha\u0026#34;,\u0026#34;age\u0026#34;:23}] 总结：map方法如果是修改整个item的值，则不会改变原数组。但如果是修改 item 里面的某个属性，那就会改变原数组。\nfilter() 语法：\n1 2 3 arr.filter(function (item, index, arr) { return true; }); 解释：对数组中的每一项运行回调函数，该函数返回结果是 true 的项，将组成新的数组（返回值就是这个新的数组）。不会改变原数组。\n作用：对数组进行过滤。\n举例 1：找出数组 arr1 中大于 4 的元素，返回一个新的数组。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 let arr1 = [1, 3, 6, 2, 5, 6]; let arr2 = arr1.filter((item) =\u0026gt; { if (item \u0026gt; 4) { return true; // 将arr1中大于4的元素返回，组成新的数组 } return false; }); console.log(JSON.stringify(arr1)); // 打印结果：[1,3,6,2,5,6] console.log(JSON.stringify(arr2)); // 打印结果：[6,5,6] 上方代码更简洁的写法如下：\n1 2 3 4 5 6 let arr1 = [1, 3, 6, 2, 5, 6]; let arr2 = arr1.filter((item) =\u0026gt; item \u0026gt; 4); // 将arr1中大于4的元素返回，组成新的数组 console.log(JSON.stringify(arr1)); // 打印结果：[1,3,6,2,5,6] console.log(JSON.stringify(arr2)); // 打印结果：[6,5,6] 举例 2：\n获取数组 A 中指定类型的对象，放到数组 B 中。代码举例如下：\n1 2 3 4 5 6 7 8 9 const arr1 = [ { name: \u0026#39;许嵩\u0026#39;, type: \u0026#39;一线\u0026#39; }, { name: \u0026#39;周杰伦\u0026#39;, type: \u0026#39;过气\u0026#39; }, { name: \u0026#39;邓紫棋\u0026#39;, type: \u0026#39;一线\u0026#39; }, ]; const arr2 = arr1.filter((item) =\u0026gt; item.type == \u0026#39;一线\u0026#39;); // 筛选出一线歌手 console.log(JSON.stringify(arr2)); 打印结果：\n1 2 3 4 [ { name: \u0026#39;许嵩\u0026#39;, type: \u0026#39;一线\u0026#39; }, { name: \u0026#39;邓紫棋\u0026#39;, type: \u0026#39;一线\u0026#39; }, ]; reduce()方法 reduce() 语法 reduce 的发音：[rɪ\u0026rsquo;djuːs]。中文含义是减少，但这个方法跟“减少”没有任何关系。\nreduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。返回值是回调函数累计处理的结果。\n语法：\n1 arr.reduce(function (previousValue, currentValue, currentIndex, arr) {}, initialValue); 参数解释：\npreviousValue：必填，上一次调用回调函数时的返回值\ncurrentValue：必填，当前正在处理的数组元素\ncurrentIndex：选填，当前正在处理的数组元素下标\narr：选填，调用 reduce()方法的数组\ninitialValue：选填，可选的初始值（作为第一次调用回调函数时传给 previousValue 的值）\n在以往的数组方法中，匿名的回调函数里是传三个参数：item、index、arr。但是在 reduce() 方法中，前面多传了一个参数previousValue，这个参数的意思是上一次调用回调函数时的返回值。第一次执行回调函数时，previousValue 没有值怎么办？可以用 initialValue 参数传给它。\n备注：绝大多数人在一开始接触 reduce() 的时候会很懵逼，但是没关系，有事没事多看几遍，自然就掌握了。如果能熟练使用 reduce() 的用法，将能替代很多其他的数组方法，并逐渐走上进阶之路，领先于他人。\n为了方便理解 reduce()，我们先来看看下面的简单代码，过渡一下：\n1 2 3 4 5 6 7 8 let arr1 = [1, 2, 3, 4, 5, 6]; arr1.reduce((prev, item) =\u0026gt; { console.log(prev); console.log(item); console.log(\u0026#39;------\u0026#39;); return 88; }, 0); 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 0 1 ------ 88 2 ------ 88 3 ------ 88 4 ------ 88 5 ------ 88 6 ------ 上面的代码中，由于return的是固定值，所以 prev 打印的也是固定值（只有初始值是 0，剩下的遍历中，都是打印 88）。\n现在来升级一下，实际开发中，prev 的值往往是动态变化的，这便是 reduce()的精妙之处。我们来看几个例子就明白了。\nreduce() 的常见应用 举例 1、求和：\n计算数组中所有元素项的总和。代码实现：\n1 2 3 4 5 6 7 const arr = [2, 0, 1, 9, 6]; // 数组求和 const total = arr.reduce((prev, item) =\u0026gt; { return prev + item; }); console.log(\u0026#39;total:\u0026#39; + total); // 打印结果：18 举例 2、统计某个元素出现的次数：\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 定义方法：统一 value 这个元素在数组 arr 中出现的次数 function repeatCount(arr, value) { if (!arr || arr.length == 0) return 0; return arr.reduce((totalCount, item) =\u0026gt; { totalCount += item == value ? 1 : 0; return totalCount; }, 0); } let arr1 = [1, 2, 6, 5, 6, 1, 6]; console.log(repeatCount(arr1, 6)); // 打印结果：3 举例 3、求元素的最大值：\n代码实现：\n1 2 3 4 5 6 7 const arr = [2, 0, 1, 9, 6]; // 数组求最大值 const maxValue = arr.reduce((prev, item) =\u0026gt; { return prev \u0026gt; item ? prev : item; }); console.log(maxValue); // 打印结果：9 参考链接：\nJS reduce 函数 数组练习 splice()练习：数组去重 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //创建一个数组 var arr = [1, 2, 3, 2, 2, 1, 3, 4, 2, 5]; //去除数组中重复的数字 //获取数组中的每一个元素 for (var i = 0; i \u0026lt; arr.length; i++) { //console.log(arr[i]); /*获取当前元素后的所有元素*/ for (var j = i + 1; j \u0026lt; arr.length; j++) { //console.log(\u0026#34;----\u0026gt;\u0026#34;+arr[j]); //判断两个元素的值是否相等 if (arr[i] == arr[j]) { //如果相等则证明出现了重复的元素，则删除j对应的元素 arr.splice(j, 1); //当删除了当前j所在的元素以后，后边的元素会自动补位 //此时将不会在比较这个元素，我需要再比较一次j所在位置的元素 //使j自减 j--; } } } console.log(arr); 清空数组 清空数组，有以下几种方式：\n1 2 3 4 5 var array = [1, 2, 3, 4, 5, 6]; array.splice(0); //方式1：删除数组中所有项目 array.length = 0; //方式2：length属性可以赋值，在其它语言中length是只读 array = []; //方式3：推荐 join() 练习 问题：将一个字符串数组输出为|分割的形式，比如“千古|宿敌|素颜”。使用两种方式实现。\n答案：\n方式 1：（不推荐）\n1 2 3 4 5 6 7 8 var arr = [\u0026#39;千古\u0026#39;, \u0026#39;宿敌\u0026#39;, \u0026#39;素颜\u0026#39;]; var str = arr[0]; var separator = \u0026#39;|\u0026#39;; for (var i = 1; i \u0026lt; arr.length; i++) { str += separator + arr[i]; //从第1个数组元素开始，每个元素前面加上符号\u0026#34;|\u0026#34; } console.log(str); 输出结果：\n不推荐这种方式，因为：由于字符串的不变性，str 拼接过多的话，容易导致内存溢出（很多个 str 都堆放在栈里）。\n方式 2：（推荐。通过 array 数组自带的 api 来实现）\n1 2 3 var arr = [\u0026#39;千古\u0026#39;, \u0026#39;宿敌\u0026#39;, \u0026#39;素颜\u0026#39;]; console.log(arr.join(\u0026#39;|\u0026#39;)); 结果：\nreverse() 练习 题目：将一个字符串数组的元素的顺序进行反转，使用两种种方式实现。提示：第 i 个和第 length-i-1 个进行交换。\n答案：\n方式 1：\n1 2 3 4 5 6 7 function reverse(array) { var newArr = []; for (var i = array.length - 1; i \u0026gt;= 0; i--) { newArr[newArr.length] = array[i]; } return newArr; } 方式 2：（算法里比较常见的方式）\n1 2 3 4 5 6 7 8 function reverse(array) { for (var i = 0; i \u0026lt; array.length / 2; i++) { var temp = array[i]; array[i] = array[array.length - 1 - i]; array[array.length - 1 - i] = temp; } return array; } 方式 3：（数组自带的 reverse 方法）\n现在我们学习了数组自带的 api，我们就可以直接使用 reverse()方法。\n练习 问题：找到数组[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;z\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;x\u0026rdquo;,\u0026ldquo;a\u0026rdquo;]中每一个元素出现的次数。\n分析：这道题建议用 json 数据来做，因为我们想知道 a 出现了几次，c 出现了几次，x 出现了几次。恰好k:v .. k:v这种键值对的形式就比数组方便很多了。\n键值对的形式：用 key 代表数组中的元素，用 value 代表元素出现的次数。\n略难，答案暂略。\n练习：数组去重 问题：编写一个方法去掉一个数组中的重复元素。\n分析：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。\n答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 编写一个方法 去掉一个数组的重复元素 var arr = [1, 2, 3, 4, 5, 2, 3, 4]; console.log(arr); var aaa = fn(arr); console.log(aaa); //思路：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。 function fn(array) { var newArr = []; for (var i = 0; i \u0026lt; array.length; i++) { //开闭原则 var bool = true; //每次都要判断新数组中是否有旧数组中的值。 for (var j = 0; j \u0026lt; newArr.length; j++) { if (array[i] === newArr[j]) { bool = false; } } if (bool) { newArr[newArr.length] = array[i]; } } return newArr; } ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/17-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/","summary":"数组的方法清单 数组的类型相关 方法 描述 备注 Array.isArray() 判断是否为数组 toString() 将数组转换为字符串 Array.from(arrayLike) 将伪数组转化为真数组 Array.of(value1, value2, value3) 创建数组：将一系列值转换成数组 注意，","title":"17-数组的常见方法"},{"content":"前言 关于函数的核心内容：\n函数有哪几种定义和调用方式\nthis：函数内部的 this 指向、如何改变 this 的指向。\n函数的严格模式\n高阶函数：函数作为参数传递、函数作为返回值传递\n闭包：闭包的作用\n递归：递归的两个条件\n深拷贝和浅拷贝的区别\n函数的介绍 函数：就是将一些功能或语句进行封装，在需要的时候，通过调用的形式，执行这些语句。\n函数也是一个对象\n使用typeof检查一个函数对象时，会返回function\n函数的作用：\n将大量重复的语句抽取出来，写在函数里，以后需要这些语句的时候，可以直接调用函数，避免重复劳动。\n简化编程，让编程模块化。高内聚、低耦合。\n来看个例子：\n1 2 3 4 5 6 7 8 console.log(\u0026#34;你好\u0026#34;); sayHello();\t// 调用函数 // 定义函数 function sayHello(){ console.log(\u0026#34;欢迎\u0026#34;); console.log(\u0026#34;welcome\u0026#34;); } 函数的定义/声明 方式一：利用函数关键字自定义函数（命名函数） 使用函数声明来创建一个函数（也就是 function 关键字）。语法：\n1 2 3 function 函数名([形参1,形参2...形参N]){ // 备注：语法中的中括号，表示“可选” 语句... } 举例：\n1 2 3 function fun1(a, b){ return a+b; } 解释如下：\nfunction：是一个关键字。中文是“函数”、“功能”。\n函数名字：命名规定和变量的命名规定一样。只能是字母、数字、下划线、美元符号，不能以数字开头。\n参数：可选。\n大括号里面，是这个函数的语句。\nPS：在有些编辑器中，方法写完之后，我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。\n方式二：函数表达式（匿名函数） 使用函数表达式来创建一个函数。语法：\n1 2 3 var 变量名 = function([形参1,形参2...形参N]){ 语句.... } 举例：\n1 2 3 var fun2 = function() { console.log(\u0026#34;我是匿名函数中封装的代码\u0026#34;); }; 解释如下：\n上面的 fun2 是变量名，不是函数名。\n函数表达式的声明方式跟声明变量类似，只不过变量里面存的是值，而函数表达式里面存的是函数。\n函数表达式也可以传递参数。\n从方式二的举例中可以看出：所谓的“函数表达式”，其实就是将匿名函数赋值给一个变量。\n方式三：使用构造函数 new Function() 使用构造函数new Function()来创建一个对象。这种方式，用的少。\n语法：\n1 var 变量名/函数名 = new Function(\u0026#39;形参1\u0026#39;, \u0026#39;形参2\u0026#39;, \u0026#39;函数体\u0026#39;); 注意，Function 里面的参数都必须是字符串格式。也就是说，形参也必须放在字符串里；函数体也是放在字符串里包裹起来，放在 Function 的最后一个参数的位置。\n代码举例：\n1 2 3 var fun3 = new Function(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;console.log(\u0026#34;我是函数内部的内容\u0026#34;); console.log(a + b);\u0026#39;); fun3(1, 2); // 调用函数 打印结果：\n1 2 我是函数内部的内容 3 分析：\n方式3的写法很少用，原因如下：\n不方便书写：写法过于啰嗦和麻烦。\n执行效率较低：首先需要把字符串转换为 js 代码，然后再执行。\n总结 1、所有的函数，都是 Fuction 的“实例”（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。\n2、函数既然是实例对象，那么，函数也属于“对象”。还可以通过如下特征，来佐证函数属于对象：\n（1）我们直接打印某一个函数，比如 console.log(fun2)，发现它的里面有__proto__。（这个是属于原型的知识，后续再讲）\n（2）我们还可以打印 console.log(fun2 instanceof Object)，发现打印结果为 true。这说明 fun2 函数就是属于 Object。\n函数的调用 方式1：普通函数的调用 函数调用的语法：\n1 函数名(); 或者：\n1 函数名.call(); 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 function fn1() { console.log(\u0026#39;我是函数体里面的内容1\u0026#39;); } function fn2() { console.log(\u0026#39;我是函数体里面的内容2\u0026#39;); } fn1(); // 调用函数 fn2.call(); // 调用函数 方式2：通过对象的方法来调用 1 2 3 4 5 6 7 8 var obj = { a: \u0026#39;qianguyihao\u0026#39;, fn2: function() { console.log(\u0026#39;lvbu，永不止步!\u0026#39;); }, }; obj.fn2(); // 调用函数 如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。\nPS：关于函数和方法的区别，本文的后续内容里有讲到，可以往下面翻。\n方式3：立即执行函数 代码举例：\n1 2 3 (function() { console.log(\u0026#39;我是立即执行函数\u0026#39;); })(); 立即执行函数在定义后，会自动调用。\nPS：关于立即执行函数，本文的后续内容里有讲到，可以往下面翻。\n上面讲到的这三种方式，是用得最多的。接下来讲到的三种方式，暂时看不懂也没关系，可以等学完其他的知识点，再回过头来看。\n方式4：通过构造函数来调用 代码举例：\n1 2 3 4 5 function Fun3() { console.log(\u0026#39;lvbu，永不止步~\u0026#39;); } new Fun3(); 这种方式用得不多。\n方式5：绑定事件函数 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;btn\u0026#34;\u0026gt;我是按钮，请点击我\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementById(\u0026#39;btn\u0026#39;); //2.绑定事件 btn.onclick = function() { console.log(\u0026#39;点击按钮后，要做的事情\u0026#39;); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里涉及到DOM操作和事件的知识点，后续再讲。\n方式6：定时器函数 代码举例：（每间隔一秒，将 数字 加1）\n1 2 3 4 5 let num = 1; setInterval(function () { num ++; console.log(num); }, 1000); 这里涉及到定时器的知识点。\n函数的参数：形参和实参 函数的参数包括形参和实参。先来看下面的图就很好懂了：\n形参：\n概念：形式上的参数。定义函数时传递的参数，当时并不知道是什么值。\n定义函数时，可以在函数的()中来指定一个或多个形参。\n多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。\n实参：\n概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。\n在调用函数时，可以在函数的 ()中指定实参。\n注意：实际参数和形式参数的个数，一般要相同。\n举例：\n1 2 3 4 5 6 7 8 9 // 调用函数 sum(3,4); sum(\u0026#34;3\u0026#34;,4); sum(\u0026#34;Hello\u0026#34;,\u0026#34;World\u0026#34;); // 定义函数：求和 function sum(a, b) { console.log(a + b); } 控制台输出结果：\n1 2 3 7 34 helloworld 实参的类型 函数的实参可以是任意的数据类型。\n调用函数时，解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。\n实参的数量（实参和形参的个数不匹配时） 调用函数时，解析器也不会检查实参的数量。\n如果实参的数量多余形参的数量，多余实参不会被赋值。\n如果实参的数量少于形参的数量，多余的形参会被定义为 undefined。表达式的运行结果为 NaN。\n代码举例：\n1 2 3 4 5 6 7 function sum(a, b) { console.log(a + b); } sum(1, 2); sum(1, 2, 3); sum(1); 打印结果：\n1 2 3 4 5 3 3 NaN 注意：在 JS 中，形参的默认值是 undefined。\n函数的返回值 举例：\n1 2 3 4 5 6 console.log(sum(3, 4)); // 将函数的返回值打印出来 //函数：求和 function sum(a, b) { return a + b; } return 的作用是结束方法（终止函数）。\n注意：\nreturn 的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果。\n在函数中，return后的语句都不会执行（函数在执行完 return 语句之后停止并立即退出函数）\n如果return语句后不跟任何值，就相当于返回一个undefined\n如果函数中不写return，则也会返回undefined\n返回值可以是任意的数据类型，可以是对象，也可以是函数。\nreturn 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准。\n函数名、函数体和函数加载问题（重要，请记住） 我们要记住：函数名 == 整个函数。举例：\n1 2 3 4 5 6 console.log(fn) == console.log(function fn(){alert(1)}); //定义fn方法 function fn(){ alert(1) }; 我们知道，当我们在调用一个函数时，通常使用函数()这种格式；可如果，我们是直接使用函数这种格式，它的作用相当于整个函数。\n函数的加载问题：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。\nfn() 和 fn 的区别【重要】 fn()：调用函数。调用之后，还获取了函数的返回值。\nfn：函数对象。相当于直接获取了整个函数对象。\nbreak、continue、return 的区别 break ：结束当前的循环体（如 for、while）\ncontinue ：跳出本次循环，继续执行下次循环（如 for、while）\nreturn ：1、退出循环。2、返回 return 语句中的值，同时结束当前的函数体内的代码，退出当前函数。\n立即执行函数 现有匿名函数如下：\n1 2 3 4 function(a, b) { console.log(\u0026#34;a = \u0026#34; + a); console.log(\u0026#34;b = \u0026#34; + b); }; 立即执行函数如下：\n1 2 3 4 (function(a, b) { console.log(\u0026#34;a = \u0026#34; + a); console.log(\u0026#34;b = \u0026#34; + b); })(123, 456); 立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数。\n立即执行函数往往只会执行一次。为什么呢？因为没有变量保存它，执行完了之后，就找不到它了。\n方法 函数也可以成为对象的属性。如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。\n调用这个函数就说调用对象的方法（method）。函数和方法，有什么本质的区别吗？它只是名称上的区别，并没有其他的区别。\n函数举例：\n1 2 // 调用函数 fn(); 方法举例：\n1 2 // 调用方法 obj.fn(); 我们可以这样说，如果直接是fn()，那就说明是函数调用。如果是XX.fn()的这种形式，那就说明是方法调用。\n类数组 arguments 这部分，小白可能看不懂。所以，这一段，暂时可以忽略。\n在调用函数时，浏览器每次都会传递进两个隐含的参数：\n1.函数的上下文对象 this\n2.封装实参的对象 arguments\n例如：\n1 2 3 4 5 6 function foo() { console.log(arguments); console.log(typeof arguments); } foo(); arguments 是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。\narguments 代表的是实参。在调用函数时，我们所传递的实参都会在 arguments 中保存。有个讲究的地方是：arguments只在函数中使用。\n1、返回函数实参的个数：arguments.length arguments.length 可以用来获取实参的长度。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 fn(2, 4); fn(2, 4, 6); fn(2, 4, 6, 8); function fn(a, b) { console.log(arguments); console.log(fn.length); //获取形参的个数 console.log(arguments.length); //获取实参的个数 console.log(\u0026#39;----------------\u0026#39;); } 打印结果：\n我们即使不定义形参，也可以通过 arguments 来使用实参（只不过比较麻烦）：arguments[0] 表示第一个实参、arguments[1] 表示第二个实参\u0026hellip;\n2、返回正在执行的函数：arguments.callee arguments 里边有一个属性叫做 callee，这个属性对应一个函数对象，就是当前正在指向的函数对象。\n1 2 3 4 5 function fun() { console.log(arguments.callee == fun); //打印结果为true } fun(\u0026#39;hello\u0026#39;); 在使用函数递归调用时，推荐使用 arguments.callee 代替函数名本身。\n3、arguments 可以修改元素 之所以说 arguments 是伪数组，是因为：arguments 可以修改元素，但不能改变数组的长短。举例：\n1 2 3 4 5 6 7 8 fn(2, 4); fn(2, 4, 6); fn(2, 4, 6, 8); function fn(a, b) { arguments[0] = 99; //将实参的第一个数改为99 arguments.push(8); //此方法不通过，因为无法增加元素 } arguments 的使用 当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象（只有函数才有 arguments 对象），arguments 对象中存储了传递的所有实参.\narguments的展示形式是一个伪数组。伪数组具有以下特点：\n可以进行遍历；具有数组的 length 属性。\n按索引方式存储数据。\n不具有数组的 push()、pop() 等方法。\n代码举例：利用 arguments 求函数实参中的最大值\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 function getMaxValue() { var max = arguments[0]; // 通过 arguments 遍历实参 for (var i = 0; i \u0026lt; arguments.length; i++) { if (max \u0026lt; arguments[i]) { max = arguments[i]; } } return max; } console.log(getMaxValue(1, 3, 7, 5)); ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/18-%E5%87%BD%E6%95%B0/","summary":"前言 关于函数的核心内容： 函数有哪几种定义和调用方式 this：函数内部的 this 指向、如何改变 this 的指向。 函数的严格模式 高阶函数：函数作为参数传递、函","title":"18-函数"},{"content":" 作用域、变量提升的知识点，面试时会经常遇到。\n作用域（Scope）的概念 概念：通俗来讲，作用域是一个变量或函数的作用范围。作用域在函数定义时，就已经确定了。\n目的：为了提高程序的可靠性，同时减少命名冲突。\n作用域的分类 在 JS 中，一共有两种作用域：（ES6 之前）\n全局作用域：作用于整个 script 标签内部，或者作用域一个独立的 JS 文件。\n函数作用域（局部作用域）：作用于函数内的代码环境。\n作用域的访问关系 在内部作用域中可以访问到外部作用域的变量，在外部作用域中无法访问到内部作用域的变量。\n代码举例：\n1 2 3 4 5 6 7 8 var a = \u0026#39;aaa\u0026#39;; function foo() { var b = \u0026#39;bbb\u0026#39;; console.log(a); // 打印结果：aaa。说明 内层作用域 可以访问 外层作用域 里的变量 } foo(); console.log(b); // 报错：Uncaught ReferenceError: b is not defined。说明 外层作用域 无法访问 内层作用域 里的变量 变量的作用域 根据作用域的不同，变量可以分为两类：全局变量、布局变量。\n全局变量：\n在全局作用域下声明的变量，叫「全局变量」。在全局作用域的任何一地方，都可以访问这个变量。\n在全局作用域下，使用 var 声明的变量是全局变量。\n特殊情况：在函数内不使用 var 声明的变量也是全局变量（不建议这么用）。\n局部变量：\n定义在函数作用域的变量，叫「局部变量」。\n在函数内部，使用 var 声明的变量是局部变量。\n函数的形参也是属于局部变量。\n从执行效率来看全局变量和局部变量：\n全局变量：只有浏览器关闭时才会被销毁，比较占内存。\n局部变量：当其所在的代码块运行结束后，就会被销毁，比较节约内存空间。\n作用域的上下级关系 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错 ReferenceError。\n在函数中要访问全局变量可以使用window对象。（比如说，全局作用域和函数作用域都定义了变量a，如果想访问全局变量，可以使用window.a）\n全局作用域 直接编写在script标签中的JS代码，都在全局作用域。\n全局作用域在页面打开时创建，在页面关闭时销毁。\n在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，由浏览器创建，我们可以直接使用。\n在全局作用域中：\n创建的变量都会作为window对象的属性保存。比如在全局作用域内写 var a = 100，这里的 a 等价于 window.a。\n创建的函数都会作为window对象的方法保存。\n变量的声明提前（变量提升） 使用var关键字声明的变量（ 比如 var a = 1），会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写a = 1），则变量不会被声明提前。\n举例1：\n1 2 console.log(a); var a = 123; 打印结果：undefined。注意，打印结果并没有报错，而是 undefined，说明变量 a 被提前声明了，只是尚未被赋值。\n举例2：\n1 2 console.log(a); a = 123; //此时a相当于window.a 程序会报错：Uncaught ReferenceError: a is not defined。\n举例3：\n1 2 a = 123; //此时a相当于window.a console.log(a); 打印结果：123。\n举例4：\n1 2 3 4 5 6 7 8 foo(); function foo() { if (false) { var i = 123; } console.log(i); } 打印结果：undefined。注意，打印结果并没有报错，而是 undefined。这个例子，再次说明了：变量 i 在函数执行前，就被提前声明了，只是尚未被赋值。\n例4中， if(false)里面的代码虽然不会被执行，但是整个代码有解析的环节，解析的时候就已经把 变量 i 给提前声明了。\n总结：\n既然JS中存在变量提升的现象，那么，在实战开发中，为了避免出错，建议先声明一个变量，然后再使用这个变量。\n函数的声明提前 函数声明：\n使用函数声明的形式创建的函数function foo(){}，会被声明提前。\n也就是说，整个函数会在所有的代码执行之前就被创建完成。所以，在代码顺序里，我们可以先调用函数，再定义函数。\n代码举例：\n1 2 3 4 5 fn1(); // 虽然 函数 fn1 的定义是在后面，但是因为被提前声明了， 所以此处可以调用函数 function fn1() { console.log(\u0026#39;我是函数 fn1\u0026#39;); } 函数表达式：\n使用函数表达式创建的函数var foo = function(){}，不会被声明提前，所以不能在声明前调用。\n很好理解，因为此时foo被声明了（这里只是变量声明），且为undefined，并没有把 function(){} 赋值给 foo。\n所以说，下面的例子，会报错：\n函数作用域 提醒1：在函数作用域中，也有声明提前的特性：\n函数中，使用var关键字声明的变量，会在函数中所有的代码执行之前被声明。\n函数中，没有var声明的变量都是全局变量，而且并不会提前声明。\n举例：\n1 2 3 4 5 6 7 8 9 var a = 1; function foo() { console.log(a); a = 2; // 此处的a相当于window.a } foo(); console.log(a); //打印结果是2 上方代码中，执行foo()后，函数里面的打印结果是1。如果去掉第一行代码，执行foo()后，函数里面的打印结果是Uncaught ReferenceError: a is not defined。\n提醒2：定义形参就相当于在函数作用域中声明了变量。\n1 2 3 4 5 6 function fun6(e) { // 这个函数中，因为有了形参 e，此时就相当于在函数内部的第一行代码里，写了 var e; console.log(e); } fun6(); //打印结果为 undefined fun6(123);//打印结果为123 JavaScript 没有块级作用域（ES6之前） 在其他编程语言中（如 Java、C#等），存在块级作用域，由{}包括起来。比如在 Java 语言中，if 语句里创建的变量，只能在if语句内部使用：\n1 2 3 4 5 if(true){ int num = 123; system.out.print(num); // 123 } system.out.print(num); // 报错 但是，在 JS 中没有块级作用域（ES6之前）。举例如下：\n1 2 3 4 5 6 if(true){ var num = 123; console.log(123); //123 } console.log(123); //123（可以正常打印） 作用域链 引入：\n只要是代码，就至少有一个作用域\n写在函数内部的局部作用域\n如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域\n基于上面几条内容，我们可以得出作用域链的概念。\n作用域链：内部函数访问外部函数的变量，采用的是链式查找的方式来决定取哪个值，这种结构称之为作用域链。查找时，采用的是就近原则。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var num = 10; function fn() { // 外部函数 var num = 20; function fun() { // 内部函数 console.log(num); } fun(); } fn(); 打印结果：20。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/19-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","summary":"作用域、变量提升的知识点，面试时会经常遇到。 作用域（Scope）的概念 概念：通俗来讲，作用域是一个变量或函数的作用范围。作用域在函数定义时，","title":"19-作用域和变量提升"},{"content":" 我们在上一篇文章《作用域》中简单讲过“变量提升”，今天来讲一下预编译，这对我们深入理解变量提升会有帮助。\nJavaScript 运行三部曲 语法分析\n预编译\n解释执行\n预编译前奏 在讲预编译前，我们先来普及下面两个规律。\n两个规律 规律1：任何变量，如果未经声明就赋值，此变量是属于 window 的属性，而且不会做变量提升。（注意，无论在哪个作用域内赋值）\n比如说，如果我们直接在代码里写 console.log(a)，这肯定会报错的，提示找不到 a。但如果我直接写 a = 100，这就不会报错，此时，这个 a 就是 window.a。\n规律2：一切声明的全局变量，全是window的属性。（注意，我说的是在全局作用域内声明的全局变量，不是说局部变量）\n比如说，当我定义 var a = 200 时，这此时这个 a 就是 window.a。\n由此，我们可以看出：window 代表了全局作用域（是说「代表」，没说「等于」）。\n举例 掌握了上面两句话之后，我们再来看看下面的例子。\n1 2 3 4 5 6 7 8 9 10 11 function foo() { var a = b = 100; // 连续赋值 } foo(); console.log(window.b); // 在全局范围内访问 b console.log(b); // 在全局范围内访问 b，但是前面没有加 window 这个关键字 console.log(window.a); // 在全局范围内访问 a console.log(a); // 在全局范围内访问 a，但是前面没有加 window 这个关键字 上方代码的打印结果：\n1 2 3 4 5 6 7 100 100 undefined （会报错，提示 Uncaught ReferenceError: a is not defined） 解释：\n当执行了foo()函数之后， var a = b = 100 这行连续赋值的代码等价于 var a = (b = 100)，其执行顺序是：\n（1）先把 100 赋值给 b；\n（2）再声明变量 a；\n（3）再把 b 的值赋值给 a。\n我们可以看到，b 是未经声明的变量就被赋值了，此时，根据规律1，这个 b 是属于 window.b；而 a 的作用域仅限于 foo() 函数内部，不属于 window。所以也就有了这样的打印结果。\n预编译 函数预编译的步骤 函数预编译，发生在函数执行的前一刻。\n（1）创建AO对象。AO即 Activation Object 活跃对象，其实就是「执行期上下文」。\n（2）找形参和变量声明，将形参名和变量作为 AO 的属性名，值为undefined。\n（3）将实参值和形参统一，实参的值赋给形参。\n（4）查找函数声明，函数名作为 AO 对象的属性名，值为整个函数体。\n这个地方比较难理解。但只有了解了函数的预编译，才能理解明白函数的执行顺序。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function fn(a) { console.log(a); var a = 666; console.log(a); function a() {} console.log(a); var b = function() {}; console.log(b); function c() {} } fn(1); 打印结果：\n1 2 3 4 ƒ a() {} 666 666 ƒ () {} 参考链接 JavaScript预编译原理分析：https://blog.csdn.net/q1056843325/article/details/52951114\nhttps://segmentfault.com/a/1190000018001871\n预编译及变量提升：https://juejin.im/post/5aa6693df265da23884cb571\nhttps://juejin.im/post/5adaf8215188256712781830\nhttps://www.qqzmly.com/archives/1521\n宏任务\u0026amp;微任务相关：https://segmentfault.com/a/1190000018134157\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/20-%E9%A2%84%E7%BC%96%E8%AF%91/","summary":"我们在上一篇文章《作用域》中简单讲过“变量提升”，今天来讲一下预编译，这对我们深入理解变量提升会有帮助。 JavaScript 运行三部曲 语法分析 预编译 解释执行 预","title":"20-预编译"},{"content":"执行期上下文 当函数执行时（准确来说，是在函数发生预编译的前一刻），会创建一个执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境。\n每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立且独一无二的。当函数执行完毕，它所产生的执行期上下文会被销毁。\n参考链接：https://www.cnblogs.com/chenyingjie1207/p/9966036.html\nthis 解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是 this，this 指向的是一个对象，这个对象我们称为函数执行的 上下文对象。\n函数内 this 的指向【非常重要】 我们在《JavaScript 基础/函数.md》这篇文章讲过，函数的调用有六种形式。\n根据函数的调用方式的不同，this 会指向不同的对象：\n1.以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如fun();相当于window.fun();\n2.以方法的形式调用时，this 指向调用方法的那个对象\n3.以构造函数的形式调用时，this 指向实例对象\n4.以事件绑定函数的形式调用时，this 指向绑定事件的对象\n5.使用 call 和 apply 调用时，this 指向指定的那个对象\n针对第 1 条的举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function fun() { console.log(this); console.log(this.name); } var obj1 = { name: \u0026#39;smyh\u0026#39;, sayName: fun, }; var obj2 = { name: \u0026#39;vae\u0026#39;, sayName: fun, }; var name = \u0026#39;全局的name属性\u0026#39;; //以函数形式调用，this是window fun(); //可以理解成 window.fun() 打印结果：\n1 2 Window 全局的name属性 上面的举例可以看出，this 指向的是 window 对象，所以 this.name 指的是全局的 name。\n第 2 条的举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function fun() { console.log(this); console.log(this.name); } var obj1 = { name: \u0026#39;smyh\u0026#39;, sayName: fun, }; var obj2 = { name: \u0026#39;vae\u0026#39;, sayName: fun, }; var name = \u0026#39;全局的name属性\u0026#39;; //以方法的形式调用，this是调用方法的对象 obj2.sayName(); 打印结果：\n1 2 Object vae 上面的举例可以看出，this 指向的是 对象 obj2 ，所以 this.name 指的是 obj2.name。\n箭头函数中 this 的指向 ES6 中的箭头函数并不会使用上面的准则，而是会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。\n改变函数内部的 this 指向 JS 专门为我们提供了一些方法来改变函数内部的 this 指向。详见下一篇文章中的 call()、apply()、bind() 方法。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/21-this%E6%8C%87%E5%90%91/","summary":"执行期上下文 当函数执行时（准确来说，是在函数发生预编译的前一刻），会创建一个执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环","title":"21-this指向"},{"content":"前言 JS 专门为我们提供了一些方法来改变函数内部的 this 指向。常见的方法有 call()、apply()、bind() 方法。\ncall() 方法 call() 方法的作用 call() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。\ncall() 方法的另一个应用：可以实现继承。之所以能实现继承，其实是利用了上面的作用。\n语法：\n1 fn1.call(想要将this指向哪里, 函数实参1, 函数实参2); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。\ncall() 方法举例 举例 1、通过 call() 调用函数：\n1 2 3 4 5 6 7 8 9 const obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1() { console.log(this); console.log(this.nickName); } fn1.call(this); // this的指向并没有被改变，此时相当于 fn1(); 上方代码的打印结果：\n1 2 window undefined 上面的代码，跟普通的函数调用 fn1() 没有区别。\n举例 2、通过 call() 改变 this 指向：\n1 2 3 4 5 6 7 8 9 10 11 12 var obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1(a, b) { console.log(this); console.log(this.nickName); console.log(a + b); } fn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数 上方代码的打印结果：\n1 2 3 obj1 qianguyihao 6 举例 3、通过 call() 实现继承：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 给 Father 增加 name 和 age 属性 function Father(myName, myAge) { this.name = myName; this.age = myAge; } function Son(myName, myAge) { // 【下面这一行，重要代码】 // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承 Father.call(this, myName, myAge); } const son1 = new Son(\u0026#39;lvbu\u0026#39;, 28); console.log(JSON.stringify(son1)); 上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。\n打印结果：\n1 {\u0026#34;myName\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;myAge\u0026#34;:28} apply() 方法 apply() 方法的作用 apply() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。\napply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。\n语法：\n1 fn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n到这里可以看出， call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。\napply() 方法举例 举例、通过 apply() 改变 this 指向：\n1 2 3 4 5 6 7 8 9 10 11 12 var obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1(a) { console.log(this); console.log(this.nickName); console.log(a); } fn1.apply(obj1, [\u0026#39;hello\u0026#39;]); // 先将 this 指向 obj1，然后执行 fn1() 函数 注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。\n打印结果：\n1 2 3 obj1 qianguyihao hello apply() 方法的巧妙应用：求数组的最大值 我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？\n虽然数组里没有获取最大值的方法，但是数值里面有 Math.max(数字1，数字2，数字3) 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n举例：求数组中多个元素的最大值：\n1 2 3 4 5 6 7 8 const arr1 = [3, 7, 10, 8]; // 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。 const maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值 console.log(maxValue); const minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值 console.log(minValue); 打印结果：\n1 2 3 10 3 bind() 方法 bind() 方法的作用 bind() 方法不会调用函数，但是可以改变函数内部的 this 指向。\n把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。\n语法：\n1 新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2); 参数：\n第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。\n其他参数：fn1 函数的实参。\n解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。\ncall() 方法举例 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/22-callapply-%E5%92%8C-bind/","summary":"前言 JS 专门为我们提供了一些方法来改变函数内部的 this 指向。常见的方法有 call()、apply()、bind() 方法。 call() 方法 call() 方法的作用 call() 方法的","title":"22-call、apply 和 bind"},{"content":"高阶函数 高阶函数的概念 当 函数 A 接收函数 B 作为参数，或者把函数 C 作为返回值输出时，我们称 函数 A 为高阶函数。\n通俗来说，高阶函数是 对其他函数进行操作 的函数。\n高阶函数举例1：把其他函数作为参数 1 2 3 4 5 6 7 8 9 function fn1(a, b, callback) { console.log(a + b); // 执行完上面的 console.log() 语句之后，再执行下面这个 callback 函数。也就是说，这个 callback 函数是最后执行的。 callback \u0026amp;\u0026amp; callback(); } fn1(10, 20, function () { console.log(\u0026#39;我是最后执行的函数\u0026#39;); }); 打印结果：\n1 2 30 我是最后执行的函数 高阶函数举例2：把其他区函数作为返回值 1 2 3 4 5 6 7 8 9 10 function fn1() { let a = 20; return function () { console.log(a); }; } const foo = fn1(); // 执行 fn1() 之后，会得到一个返回值。这个返回值是函数 foo(); 上面的代码，产生了闭包现象。关于闭包，详见下一篇文章《JavaScript基础/闭包.md》。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/23-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","summary":"高阶函数 高阶函数的概念 当 函数 A 接收函数 B 作为参数，或者把函数 C 作为返回值输出时，我们称 函数 A 为高阶函数。 通俗来说，高阶函数是 对其他函数进行操","title":"23-高阶函数"},{"content":"闭包的引入 我们知道，变量根据作用域的不同分为两种：全局变量和局部变量。\n函数内部可以访问全局变量和局部变量。\n函数外部只能访问全局变量，不能访问局部变量。\n当函数执行完毕，本作用域内的局部变量会销毁。\n比如下面这样的代码：\n1 2 3 4 5 6 function foo() { let a = 1; } foo(); console.log(a); // 打印报错：Uncaught ReferenceError: a is not defined 上方代码中，由于变量 a 是函数内的局部变量，所以外部无法访问。\n但是，在有些场景下，我们就是想要在函数外部访问函数内的局部变量，那要怎么办呢？这就需要引入闭包的概念。\n闭包的概念和代码举例 闭包的概念 闭包（closure）：指有权访问另一个函数作用域中变量的函数。\n上面这个概念，出自《JavaScript 高级程序设计（第 3 版）》这本书。上面的概念中指出，闭包是一种函数；当然，你可以把闭包理解成是一种现象。具体解释如下。\n简单理解就是：如果这个作用域可以访问另外一个函数内部的局部变量，那就产生了闭包（此时，你可以把闭包理解成是一种现象）；而另外那个作用域所在的函数称之为闭包函数。注意，这里强调的是访问局部变量哦。\n闭包代码举例 代码举例：\n1 2 3 4 5 6 7 8 9 10 function fn1() { let a = 10; function fn2() { console.log(a); } fn2(); } fn1(); 打印结果：\n1 10 上方代码中，函数 fn2 的作用域 访问了 fn1 中的局部变量，那么，此时在 fn1 中就产生了闭包，fn1 称之为闭包函数。\n在 chrome 浏览器控制台中，调试闭包 上面的代码中，要怎么验证，确实产生了闭包呢？我们可以在 chrome 浏览器的控制台中设置断点，当代码执行到 console.log(a)这一行的时候，如下图所示：\n上图中， Local 指的是局部作用域，Global 指的是 全局作用域；而 Closure 则是闭包，fn1 是一个闭包函数。\n闭包的作用：延伸变量的作用范围 我们来看看下面这段闭包的代码：\n1 2 3 4 5 6 7 8 9 10 11 function fn1() { let a = 20; function fn2() { console.log(a); } return fn2; } const foo = fn1(); // 执行 fn1() 之后，会得到一个返回值。foo 代表的就是 fn2 函数 foo(); 上方代码中，foo 代表的就是整个 fn2 函数。当执行了 foo() 语句之后（相当于执行了 ），fn1 函数内就产生了闭包。\n一般来说，在 fn1 函数执行完毕后，它里面的变量 a 会立即销毁。但此时由于产生了闭包，所以 fn1 函数中的变量 a 不会立即销毁，因为 fn2 函数还要继续调用变量 a。只有等所有函数把变量 a 调用完了，变量 a 才会销毁。\n而且，可以看出， 在执行 foo()语句之后，竟然能够打印出 20，这就完美通过闭包实现了：全局作用局成功访问到了局部作用域中的变量 a。\n因此，我们可以看出，闭包的主要作用就是：延伸了变量的作用范围。\n上面的代码也可以简写成：\n1 2 3 4 5 6 7 8 9 10 function fn1() { let a = 20; return function () { console.log(a); }; } const foo = fn1(); // 执行 fn1() 之后，会得到一个返回值。这个返回值是函数 foo(); ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/24-%E9%97%AD%E5%8C%85/","summary":"闭包的引入 我们知道，变量根据作用域的不同分为两种：全局变量和局部变量。 函数内部可以访问全局变量和局部变量。 函数外部只能访问全局变量，不能访问","title":"24-闭包"},{"content":"面向过程和面向对象 面向过程 面向过程：先分析好的具体步骤，然后按照步骤，一步步解决问题。\n优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。\n缺点：没有面向对象易维护、易复用、易扩展。\n面向对象 面向对象（OOP，Object Oriented Programming）：以对象功能来划分问题，而不是步骤。\n优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。\n缺点：性能比面向过程低。\n面向对象的编程思想 面向对象的编程思想：对代码和数据进行封装，并以对象调用的方式，对外提供统一的调用接口。\n比如说，当我们在开车的时候，无需关心汽车的内部构造有多复杂，对于大多数人而言，只需要会开、知道汽车有哪些功能就行了。\n面向对象的特性 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。面向对象编程具有灵活、代码可复用、容易维护和开发的优点，适合多人合作的大型软件项目，更符合我们认识事物的规律。\n面向对象的特性如下：\n封装性\n继承性\n多态性\nJS 中的面向对象 JS 中的面向对象，是基于原型的面向对象。\n另外，在ES6中，新引入了 类（Class）和继承（Extends）来实现面向对象。\n基于原型的面向对象 JS 中的对象（Object）是依靠构造器（constructor）和原型（prototype）构造出来的。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/25-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/","summary":"面向过程和面向对象 面向过程 面向过程：先分析好的具体步骤，然后按照步骤，一步步解决问题。 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例","title":"25-面向对象概述"},{"content":" 在看本文之前，可以先复习前面的一篇文章：《04-JavaScript 基础/11-对象简介.md》\n创建自定义对象的几种方法 方式一：对象字面量 对象的字面量就是一个{}。里面的属性和方法均是键值对：\n键：相当于属性名。\n值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）。\n使用对象字面量来创建一个对象，非常简洁，举例如下：：\n1 var obj = {}; 使用对象字面量，可以在创建对象时，直接指定对象中的属性。语法：{属性名:属性值,属性名:属性值\u0026hellip;.}\n例 1：（一个简单的对象）\n1 2 3 4 const obj1 = { name: \u0026#39;lvbu\u0026#39;, age: 28, }; 例 2：（一个较复杂的对象）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const obj2 = { name: \u0026#34;lvbu\u0026#34;, age: 26, isBoy: true, // 还可以存放一个嵌套的对象 test: { id: 123, tel: 180 } //我们还可以在对象中增加一个方法。以后可以通过obj.sayName()的方式调用这个方法 sayName: function() { console.log(this.name); } }; console.log(JSON.stringify(obj)); 对象字面量的属性名可以加引号也可以不加，建议不加。如果要使用一些特殊的名字，则必须加引号。\n属性名和属性值是一组一组的键值对结构，键和值之间使用:连接，多个值对之间使用,隔开。\n方式二：工厂模式 new Object() 通过该方法可以大批量的创建对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* * 使用工厂方法创建对象 * 通过该方法可以大批量的创建对象 */ function createPerson(name, age, gender) { //创建一个新的对象 var obj = new Object(); //向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function () { alert(this.name); }; //将新的对象返回 return obj; } var obj2 = createPerson(\u0026#39;猪八戒\u0026#39;, 28, \u0026#39;男\u0026#39;); var obj3 = createPerson(\u0026#39;白骨精\u0026#39;, 16, \u0026#39;女\u0026#39;); var obj4 = createPerson(\u0026#39;蜘蛛精\u0026#39;, 18, \u0026#39;女\u0026#39;); 第一次看到这种工厂模式时，你可能会觉得陌生。如果简化一下，可以写成下面这种形式，更容易理解：（也就是，利用 new Object 创建对象）\n1 2 3 4 5 6 7 var obj = new Obect(); obj.name = \u0026#39;猪八戒\u0026#39;; obj.age = 28; obj.gender = \u0026#39;男\u0026#39;; obj.sayHi = function () { alert(\u0026#39;hello world\u0026#39;); }; 弊端：\n使用工厂方法创建的对象，使用的构造函数都是 Object。所以创建的对象都是 Object 这个类型，就导致我们无法区分出多种不同类型的对象。\n方式三：利用构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //利用构造函数自定义对象 var stu1 = new Student(\u0026#39;smyh\u0026#39;); console.log(stu1); stu1.sayHi(); var stu2 = new Student(\u0026#39;vae\u0026#39;); console.log(stu2); stu2.sayHi(); // 创建一个构造函数 function Student(name) { this.name = name; //this指的是当前对象实例【重要】 this.sayHi = function () { console.log(this.name + \u0026#39;厉害了\u0026#39;); }; } 打印结果：\n接下来，我们专门来讲一下构造函数。\n构造函数 代码引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 创建一个构造函数，专门用来创建Person对象 function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; this.sayName = function () { alert(this.name); }; } var per = new Person(\u0026#39;孙悟空\u0026#39;, 18, \u0026#39;男\u0026#39;); var per2 = new Person(\u0026#39;玉兔精\u0026#39;, 16, \u0026#39;女\u0026#39;); var per3 = new Person(\u0026#39;奔波霸\u0026#39;, 38, \u0026#39;男\u0026#39;); // 创建一个构造函数，专门用来创建 Dog 对象 function Dog() {} var dog = new Dog(); 构造函数的概念 构造函数：是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。它与 new 一起使用才有意义。\n我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个构造函数里面。\n构造函数和普通函数的区别 构造函数的创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。\n构造函数和普通函数的区别就是调用方式的不同：普通函数是直接调用，而构造函数需要使用 new 关键字来调用。\nthis 的指向也有所不同：\n1.以函数的形式调用时，this 永远都是 window。比如fun();相当于window.fun();\n2.以方法的形式调用时，this 是调用方法的那个对象\n3.以构造函数的形式调用时，this 是新创建的实例对象\nnew 一个构造函数的执行流程 new 在执行时，会做下面这四件事：\n（1）开辟内存空间，在内存中创建一个新的空对象。\n（2）让 this 指向这个新的对象。\n（3）执行构造函数里面的代码，给这个新对象添加属性和方法。\n（4）返回这个新对象（所以构造函数里面不需要 return）。\n因为 this 指的是 new 一个 Object 之后的对象实例。于是，下面这段代码：\n1 2 3 4 5 // 创建一个函数 function createStudent(name) { var student = new Object(); student.name = name; //第一个name指的是student对象定义的变量。第二个name指的是createStudent函数的参数。二者不一样 } 可以改进为：\n1 2 3 4 // 创建一个函数 function Student(name) { this.name = name; //this指的是构造函数中的对象实例 } 注意上方代码中的注释。\n静态成员和实例成员 JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。\n静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。\n实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。\n类、实例 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。\n通过一个构造函数创建的对象，称为该类的实例。\ninstanceof 使用 instanceof 可以检查一个对象是否为一个类的实例。\n语法如下：\n1 对象 instanceof 构造函数; 如果是，则返回 true；否则返回 false。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 function Person() {} function Dog() {} var person1 = new Person(); var dog1 = new Dog(); console.log(person1 instanceof Person); // 打印结果： true console.log(dog1 instanceof Person); // 打印结果：false console.log(dog1 instanceof Object); // 所有的对象都是Object的后代。因此，打印结果为：true 根据上方代码中的最后一行，需要补充一点：所有的对象都是 Object 的后代，因此 任何对象 instanceof Object 的返回结果都是 true。\nothers json 的介绍 对象字面量和 json 比较像，这里我们对 json 做一个简单介绍。\nJSON：JavaScript Object Notation（JavaScript 对象表示形式）。\nJSON 和对象字面量的区别：JSON 的属性必须用双引号引号引起来，对象字面量可以省略。\njson 举例：\n1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34; : \u0026#34;zs\u0026#34;, \u0026#34;age\u0026#34; : 18, \u0026#34;sex\u0026#34; : true, \u0026#34;sayHi\u0026#34; : function() { console.log(this.name); } }; 注：json 里一般放常量、数组、对象等，但很少放 function。\n另外，对象和 json 没有长度，json.length 的打印结果是 undefined。于是乎，自然也就不能用 for 循环遍历（因为遍历时需要获取长度 length）。\njson 遍历的方法：\njson 采用 for...in...进行遍历，和数组的遍历方式不同。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; var myJson = { name: \u0026#39;smyhvae\u0026#39;, aaa: 111, bbb: 222, }; //json遍历的方法：for...in... for (var key in myJson) { console.log(key); //获取 键 console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法） console.log(\u0026#39;------\u0026#39;); } \u0026lt;/script\u0026gt; 打印结果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/26-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","summary":"在看本文之前，可以先复习前面的一篇文章：《04-JavaScript 基础/11-对象简介.md》 创建自定义对象的几种方法 方式一：对象字面量 对","title":"26-对象的创建\u0026构造函数"},{"content":"对象的基本操作 创建对象 使用 new 关键字调用的函数，是构造函数 constructor。构造函数是专门用来创建对象的函数。\n例如：\n1 var obj = new Object(); 记住，使用typeof检查一个对象时，会返回object。\n关于常见对象的更多方式，可以看上一篇文章《对象的创建\u0026amp;构造函数》。\n向对象中添加属性 在对象中保存的值称为属性。\n向对象添加属性的语法：\n1 对象.属性名 = 属性值; 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 var obj = new Object(); //向obj中添加一个name属性 obj.name = \u0026#39;孙悟空\u0026#39;; //向obj中添加一个gender属性 obj.gender = \u0026#39;男\u0026#39;; //向obj中添加一个age属性 obj.age = 18; console.log(JSON.stringify(obj)); // 将 obj 以字符串的形式打印出来 打印结果：\n1 2 3 4 5 { \u0026#34;name\u0026#34;:\u0026#34;孙悟空\u0026#34;, \u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;, \u0026#34;age\u0026#34;:18 } 获取对象中的属性 方式 1：\n语法：\n1 对象.属性名; 如果获取对象中没有的属性，不会报错而是返回undefined。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var obj = new Object(); //向obj中添加一个name属性 obj.name = \u0026#39;孙悟空\u0026#39;; //向obj中添加一个gender属性 obj.gender = \u0026#39;男\u0026#39;; //向obj中添加一个age属性 obj.age = 18; // 获取对象中的属性，并打印出来 console.log(obj.gender); // 打印结果：男 console.log(obj.color); // 打印结果：undefined 方式 2：可以使用[]这种形式去操作属性\n对象的属性名不强制要求遵守标识符的规范，不过我们尽量要按照标识符的规范去做。\n但如果确实要使用特殊的属性名，就不能采用.的方式来操作对象的属性。比如说，123这种属性名，如果我们直接写成obj.123 = 789来操作属性，是会报错的。那怎么办呢？办法如下：\n语法格式如下：（读取时，也是采用这种方式）\n1 2 // 注意，括号里的属性名，必须要加引号 对象[\u0026#39;属性名\u0026#39;] = 属性值; 上面这种语法格式，举例如下：\n1 obj[\u0026#39;123\u0026#39;] = 789; 重要：使用[]这种形式去操作属性，更加的灵活，因为，我们可以在[]中直接传递一个变量。\n修改对象的属性值 语法：\n1 对象.属性名 = 新值; 1 obj.name = \u0026#39;tom\u0026#39;; 删除对象的属性 语法：\n1 delete obj.name; in 运算符 通过该运算符可以检查一个对象中是否含有指定的属性。如果有则返回 true，没有则返回 false。\n语法：\n1 \u0026#39;属性名\u0026#39; in 对象; 举例：\n1 2 //检查对象 obj 中是否含有name属性 console.log(\u0026#39;name\u0026#39; in obj); 我们平时使用的对象不一定是自己创建的，可能是从接口获取的，这个时候，in 运算符可以派上用场。\n当然，还有一种写法可以达到上述目的：\n1 2 3 if (obj.name) { // 如果对象 obj 中有name属性，我就继续做某某事情。 } for of：遍历数组 ES6 中，如果我们要遍历一个数组，可以这样做：\n1 2 3 4 5 let arr1 = [2, 6, 8, 5]; for (let value of arr1) { console.log(value); } 打印结果：\n1 2 3 4 2 6 8 5 for \u0026hellip; of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用 for…of 遍历数组。\n注意，上面的数组中，for ... of获取的是数组里的值；如果采用for ... in遍历数组，则获取的是 index 索引值。\nMap 对象的遍历 for ... of既可以遍历数组，也可以遍历 Map 对象。\nfor in：遍历对象的属性 for ... in主要用于遍历对象，不建议用来遍历数组。\n语法：\n1 2 3 for (const 变量 in 对象) { } 解释：对象中有几个属性，循环体就会执行几次。每次执行时，会将对象中的每个属性的 属性名 赋值给变量。\n语法举例：\n1 2 3 4 for (var key in obj) { console.log(key); // 这里的 key 是：对象属性的键（也就是属性名） console.log(obj[key]); // 这里的 obj[key] 是：对象属性的值（也就是属性值） } 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const obj = { name: \u0026#39;smyhvae\u0026#39;, age: 28, gender: \u0026#39;男\u0026#39;, address: \u0026#39;shenzhen\u0026#39;, sayHi: function () { console.log(this.name); }, }; // 遍历对象中的属性 for (const key in obj) { console.log(\u0026#39;属性名:\u0026#39; + key); console.log(\u0026#39;属性值:\u0026#39; + obj[key]); // 注意，因为这里的属性名 key 是变量，所以，如果想获取属性值，不能写成 obj.key，而是要写成 obj[key] } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 属性名:name 属性值:smyhvae 属性名:age 属性值:26 属性名:gender 属性值:男 属性名:address 属性值:shenzhen 属性名:sayHi 属性值:function() { console.log(this.name); } for in 遍历数组（不建议） 另外，for in 当然也可以用来遍历数组（只是不建议），此时的 key 是数组的索引。举例如下：\n1 2 3 4 5 6 const arr = [\u0026#39;hello1\u0026#39;, \u0026#39;hello2\u0026#39;, \u0026#39;hello3\u0026#39;]; for (const key in arr) { console.log(\u0026#39;属性名：\u0026#39; + key); console.log(\u0026#39;属性值：\u0026#39; + arr[key]); } 打印结果：\n1 2 3 4 5 6 7 8 属性名：0 属性值：hello1 属性名：1 属性值：hello2 属性名：2 属性值：hello3 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/27-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"对象的基本操作 创建对象 使用 new 关键字调用的函数，是构造函数 constructor。构造函数是专门用来创建对象的函数。 例如： 1 var obj = new Object(); 记住，使","title":"27-对象的基本操作"},{"content":"概念 浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用。\n深拷贝：拷贝多层数据；每一层级别的数据都会拷贝。\n总结：\n拷贝引用的时候，是属于传址，而非传值。关于传值和传址的区别，是很基础的内容，详见《JavaScript 基础/对象简介.md》这篇文章。\n深拷贝会把对象里所有的数据重新复制到新的内存空间，是最彻底的拷贝。\n浅拷贝的实现方式 用 for in 实现浅拷贝（比较繁琐） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, info: { desc: \u0026#39;很厉害\u0026#39;, }, }; const obj2 = {}; // 用 for in 将 obj1 的值拷贝给 obj2 for (let key in obj1) { obj2[key] = obj1[key]; } console.log(\u0026#39;obj2:\u0026#39; + JSON.stringify(obj2)); obj1.info.desc = \u0026#39;永不止步\u0026#39;; // 当修改 obj1 的第二层数据时，obj2的值也会被改变。所以 for in 是浅拷贝 console.log(\u0026#39;obj2:\u0026#39; + JSON.stringify(obj2)); 上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，obj2.info 属性，跟 obj1.info属性，它俩指向的是同一个堆内存地址。所以，当我修改 obj1.info 里的值之后，obj2.info的值也会被修改。\n打印结果如下：\n1 2 3 obj2:{\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;info\u0026#34;:{\u0026#34;desc\u0026#34;:\u0026#34;很厉害\u0026#34;}} obj2:{\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;info\u0026#34;:{\u0026#34;desc\u0026#34;:\u0026#34;永不止步\u0026#34;}} 用 Object.assgin() 实现浅拷贝（推荐的方式） 上面的 for in 方法做浅拷贝过于繁琐。ES6 给我们提供了新的语法糖，通过 Object.assgin() 可以实现浅拷贝。\nObject.assgin() 在日常开发中，使用得相当频繁，非掌握不可。\n语法：\n1 2 3 4 5 // 语法1 obj2 = Object.assgin(obj2, obj1); // 语法2 Object.assign(目标对象, 源对象1, 源对象2...); 解释：将obj1 拷贝给 obj2。执行完毕后，obj2 的值会被更新。\n作用：将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被覆盖。\n从语法2中可以看出，Object.assign() 可以将多个“源对象”拷贝到“目标对象”中。\n例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, info: { desc: \u0026#39;hello\u0026#39;, }, }; // 浅拷贝：把 obj1 拷贝给 obj2。如果 obj1 只有一层数据，那么，obj1 和 obj2 则互不影响 const obj2 = Object.assign({}, obj1); console.log(\u0026#39;obj2:\u0026#39; + JSON.stringify(obj2)); obj1.info.desc = \u0026#39;永不止步\u0026#39;; // 由于 Object.assign() 只是浅拷贝，所以当修改 obj1 的第二层数据时，obj2 对应的值也会被改变。 console.log(\u0026#39;obj2:\u0026#39; + JSON.stringify(obj2)); 代码解释：由于 Object.assign() 只是浅拷贝，所以在当前这个案例中， obj2 中的 name 属性和 age 属性是单独存放在新的堆内存地址中的，和 obj1 没有关系；但是，obj2.info 属性，跟 obj1.info属性，它俩指向的是同一个堆内存地址。所以，当我修改 obj1.info 里的值之后，obj2.info的值也会被修改。\n打印结果：\n1 2 3 obj2:{\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;info\u0026#34;:{\u0026#34;desc\u0026#34;:\u0026#34;hello\u0026#34;}} obj2:{\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;info\u0026#34;:{\u0026#34;desc\u0026#34;:\u0026#34;永不止步\u0026#34;}} 例 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const myObj = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, }; // 【写法1】浅拷贝：把 myObj 拷贝给 obj1 const obj1 = {}; Object.assign(obj1, myObj); // 【写法2】浅拷贝：把 myObj 拷贝给 obj2 const obj2 = Object.assign({}, myObj); // 【写法3】浅拷贝：把 myObj 拷贝给 obj31。注意，这里的 obj31 和 obj32 其实是等价的，他们指向了同一个内存地址 const obj31 = {}; const obj32 = Object.assign(obj31, myObj); 上面这三种写法，是等价的。所以，当我们需要将对象 A 复制（拷贝）给对象 B，不要直接使用 B = A，而是要使用 Object.assign(B, A)。\n例 3：\n1 2 3 4 5 6 let obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 26 }; let obj2 = { city: \u0026#39;shenzhen\u0026#39;, age: 28 }; let obj3 = {}; Object.assign(obj3, obj1, obj2); // 将 obj1、obj2的内容赋值给 obj3 console.log(obj3); // {name: \u0026#34;qianguyihao\u0026#34;, age: 28, city: \u0026#34;shenzhen\u0026#34;} 上面的代码，可以理解成：将多个对象（obj1和obj2）合并成一个对象 obj3。\n例4：【重要】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, desc: \u0026#39;hello world\u0026#39;, }; const obj2 = { name: \u0026#39;许嵩\u0026#39;, sex: \u0026#39;男\u0026#39;, }; // 浅拷贝：把 obj1 赋值给 obj2。这一行，是关键代码。这行代码的返回值也是 obj2 Object.assign(obj2, obj1); console.log(JSON.stringify(obj2)); 打印结果：\n1 {\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;sex\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;desc\u0026#34;:\u0026#34;hello world\u0026#34;} 注意，例 4 在实际开发中，会经常遇到，一定要掌握。它的作用是：将 obj1 的值追加到 obj2 中。如果两个对象里的属性名相同，则 obj12 中的值会被 obj2 中的值覆盖。\n深拷贝的实现方式 深拷贝其实就是将浅拷贝进行递归。\n用 for in 递归实现深拷贝 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 let obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, info: { desc: \u0026#39;hello\u0026#39;, }, color: [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;], }; let obj2 = {}; deepCopy(obj2, obj1); console.log(obj2); obj1.info.desc = \u0026#39;github\u0026#39;; console.log(obj2); // 方法：深拷贝 function deepCopy(newObj, oldObj) { for (let key in oldObj) { // 获取属性值 oldObj[key] let item = oldObj[key]; // 判断这个值是否是数组 if (item instanceof Array) { newObj[key] = []; deepCopy(newObj[key], item); } else if (item instanceof Object) { // 判断这个值是否是对象 newObj[key] = {}; deepCopy(newObj[key], item); } else { // 简单数据类型，直接赋值 newObj[key] = item; } } } ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/28-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","summary":"概念 浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用。 深拷贝：拷贝多层数据；每一层级别的数据都会拷贝。 总结： 拷贝引用的时候，是属于","title":"28-浅拷贝和深拷贝"},{"content":"Object.freeze() 冻结对象 Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。\n代码举例：\n1 2 3 4 5 6 7 8 const params = { name: \u0026#39;qianguyihao\u0026#39;; port: \u0026#39;8899\u0026#39;; } Object.freeze(params); // 冻结对象 params params.port = \u0026#39;8080\u0026#39;;// 修改无效 上方代码中，把 params 对象冻结后，如果想再改变 params 里面的属性值，是无效的。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/29-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E5%BE%85%E6%9B%B4%E6%96%B0/","summary":"Object.freeze() 冻结对象 Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对","title":"29-对象的高级操作（待更新）"},{"content":"前言 在 ES6 中，我们可以通过 ES6 引入的类 Class 来实现面向对象的编程（下一篇文章会讲到）。但是在 ES6 之前，我们是通过构造函数和原型，来模拟类的实现机制。\n今天这篇文章，我们就来学习构造函数和原型。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/30-%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%BE%85%E6%9B%B4%E6%96%B0/","summary":"前言 在 ES6 中，我们可以通过 ES6 引入的类 Class 来实现面向对象的编程（下一篇文章会讲到）。但是在 ES6 之前，我们是通过构造函数和原型，来模拟类的实现机制。 今","title":"30-原型链和原型继承（待更新）"},{"content":"","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/31-%E7%B1%BB%E5%92%8C%E6%9E%84%E9%80%A0%E7%BB%A7%E6%89%BF%E5%BE%85%E6%9B%B4%E6%96%B0/","summary":"","title":"31-类和构造继承（待更新）"},{"content":"正则表达式简介 定义：正则表达式用于定义一些字符串的规则。\n作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。\n如果你想查看正则更多的内容，可以查阅官方文档关于 RegExp 这个内置对象的用法。\n创建正则表达式的对象 方式一：使用构造函数创建正则表达式的对象 语法：\n1 2 3 var 变量 = new RegExp(\u0026#34;正则表达式\u0026#34;); // 注意，参数是字符串 var 变量 = new RegExp(\u0026#34;正则表达式\u0026#34;, \u0026#34;匹配模式\u0026#34;); // 注意，两个参数都是字符串 备注：RegExp的意思是 Regular expression。使用typeof检查正则对象，会返回object。\n上面的语法中，既可以传一个参数，也可以传两个参数。\n创建了正则表达式的对象后，该怎么使用呢？大致分为两个步骤：\n（1）创建正则表达式的对象 reg。\n（2）使用 reg 的test() 方法，判断指定字符串是否符合规则。\n正则表达式的test()方法：【重要】\n1 myReg.test(str); // 判断字符串 str 是否符合 指定的 myReg 这个正则表达式的规则 解释：使用test()这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false。\n我们来看看下面的例子。\n1、传一个参数时：\n构造函数 RegExp 中，可以只传一个参数。\n代码举例：\n1 2 3 4 5 6 7 8 var reg = new RegExp(\u0026#34;a\u0026#34;); // 定义一个正则表达式：检查一个字符串中是否含有 a var str1 = \u0026#34;qianguyihao\u0026#34;; var str2 = \u0026#34;smyh\u0026#34;; // 通过 test()方法，判断字符串是否符合 上面定义的 reg 规则 console.log(reg.test(str1)); // 打印结果：true console.log(reg.test(str2)); // 打印结果：false 注意，上面的例子中，我们是先定义了一个正则表达式的规则，然后通过正则表达式的test()方法来判断字符串是否符合之前定义的规则。\n2、传两个参数时：匹配模式 【重要】\n构造函数 RegExp 中，也可以传两个参数。我们可以传递一个匹配模式作为第二个参数。这个参数可以是：\ni 忽略大小写。这里的 i 指的是 ignore。\ng 全局匹配模式。这里的 g 指的是 global。\n代码举例：\n1 2 3 4 var reg = new RegExp(\u0026#39;A\u0026#39;, \u0026#39;i\u0026#39;); var str = \u0026#39;qiangu\u0026#39;; console.log(reg.test(str)); // 打印结果：true 方式二：使用字面量创建正则表达式 我们可以使用字面量来创建正则表达式。\n语法：\n1 2 3 var 变量 = /正则表达式/; // 注意，这个语法里没有引号 var 变量 = /正则表达式/匹配模式; // 注意，这个语法里没有引号 代码举例：\n1 2 3 4 5 var reg = /A/i; // 定义正则表达式的规则：检查一个字符串中是否含有 a。忽略大小写。 var str = \u0026#34;qiangu\u0026#34;; console.log(typeof reg); // 打印结果：object console.log(reg.test(str)); // 打印结果：true 以上两种方式的对比 方式一：使用构造函数创建时，更加灵活，因为参数中还可以传递变量。\n方式二：使用字面量的方式创建，更加简单。\n代码举例：\n1 2 3 var reg = new RegExp(\u0026#34;a\u0026#34;, \u0026#34;i\u0026#34;); // 方式一 var reg = /a/i; // 方式二 上面这两行代码的作用是等价的。\n避坑指南：全局匹配 g 慎用test()方法 对于非全局匹配的正则表达式，test()只会检测是否存在某个目标字符串（只要存在就为 true），多次检测的结果都相同。例如：\n1 2 3 4 5 6 const reg = /test/; const str = \u0026#39;_test_test\u0026#39;; reg.test(str) // true reg.test(str) // true reg.test(str) // true 重点来了。\n当设置全局标志 /g 时，一旦字符串中还存在匹配，test() 方法都将返回 true，同时匹配成功后将把 lastIndex 属性的值设置为上次匹配成功结果之后的第一个字符所在的位置，下次匹配将从 lastIndex 指示的位置开始；匹配不成功时返回 false，同时将 lastIndex 属性的值重置为 0。\n举例：（很重要的例子，看仔细）\n1 2 3 4 5 6 7 8 9 10 11 const reg = /test/g; const str = \u0026#39;_test_test\u0026#39;; console.log(reg.test(str)); // true console.log(reg.lastIndex); // 5 console.log(reg.test(str)); // true console.log(reg.lastIndex); // 10 console.log(reg.test(str)); // false console.log(reg.lastIndex); // 0 总结：\n全局匹配模式g一般用于 exec()、match()、replace()等方法。\n全局匹配模式g如果用于test()方法会有问题。因为g模式会生成一个lastindex参数来存储匹配最后一次的位置。\n参考链接：\nJS正则表达式全局匹配的那些坑\njavascript正则全局匹配g慎用test方法\nissues\n正则表达式的简单语法 检查一个字符串中是否包含 a或b 写法1：\n1 var reg = /a|b/; 解释：使用 | 表示或的意思。\n写法2：\n1 var reg = /[ab]/; // 跟上面的那行语法，是等价的 解释：这里的[]也是表示或的意思。\n[]这个符号在正则还是比较常用的。我们接下来看几个例子。\n[]表示：或 一些规则：\n/[ab]/ 等价于 /a|b/：检查一个字符串中是否包含 a或b\n/[a-z]/：检查一个字符串那种是否包含任意小写字母\n/[A-Z]/：任意大写字母\n/[A-z]/：任意字母\n/[0-9]/：任意数字\n/a[bde]c/：检查一个字符串中是否包含 abc 或 adc 或 aec\n[^ ] 表示：除了 举例1：\n1 2 3 4 var reg = /[^ab]/; // 规则：字符串中，除了a、b之外，还有没有其他的字符内容？ var str = \u0026#34;acb\u0026#34;; console.log(reg.test(str)); // 打印结果：true 举例2：（可以用来验证某字符串是否为 纯数字）\n1 2 3 4 5 6 var reg = /[^0-9]/; // 规则：字符串中，除了数字之外，还有没有其他的内容？ var str1 = \u0026#34;1991\u0026#34;; var str2 = \u0026#34;199a1\u0026#34;; console.log(reg.test(str1)); // 打印结果：false （如果字符串是 纯数字，则返回 false） console.log(reg.test(str2)); // 打印结果：true 支持正则表达式的 String 对象的方法 String对象的如下方法，是支持正则表达式的：\n方法 描述 备注 split() 将字符串拆分成数组 search() 搜索字符串中是否含有指定内容，返回索引 index match() 根据正则表达式，从一个字符串中将符合条件的内容提取出来 replace() 将字符串中的指定内容，替换为新的内容并返回 下面来分别介绍和举例。\nsplit() split()：将一个字符串拆分成一个数组。可以接受一个正则表达式作为参数。\n备注：关于split()更详细的用法，可以看之前的关于《内置对象：String》这篇文章。\n正则相关的举例：根据任意字母，将字符串拆分成数组。\n代码实现：（通过正则）\n1 2 3 4 var str = \u0026#34;1a2b3c4d5e6f7g\u0026#34;; var result = str.split(/[A-z]/); // 参数是一个正则表达式：表示所有字母 console.log(result); 打印结果：\n1 [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;\u0026#34;] search() search()：搜索字符串中是否含有指定内容。如果搜索到指定内容，则会返回第一次出现的索引；否则返回-1。\nsearch()方法可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串。serach()只会查找第一个，即使设置全局匹配也没用。\n举例：\n1 2 3 4 5 6 var str = \u0026#34;hello abc hello aec afc\u0026#34;; /* * 搜索字符串中是否含有abc 或 aec 或 afc */ result = str.search(/a[bef]c/); console.log(result); // 打印结果：6 match() match()：根据正则表达式，从一个字符串中将符合条件的内容提取出来，封装到一个数组中返回（即使只查询到一个结果）。\n注意：默认情况下，match()方法只会找到第一个符合要求的内容，找到以后就停止检索。我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，并以数组的形式返回。\n另外，我们可以为一个正则表达式设置多个匹配模式，且匹配模式的顺序无所谓。\n代码举例：\n1 2 3 4 5 6 7 8 9 var str = \u0026#34;1a2a3a4a5e6f7A8B9C\u0026#34;; var result1 = str.match(/[a-z]/); // 找到符合要求的第一个内容，然后返回 var result2 = str.match(/[a-z]/g); // 设置为“全局匹配”模式，匹配字符串中 所有的小写字母 var result3 = str.match(/[a-z]/gi); // 设置多个匹配模式，匹配字符串中 所有的字母（忽略大小写） console.log(result1); // 打印结果：[\u0026#34;a\u0026#34;] console.log(result2); // 打印结果：[\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;] console.log(result3); // 打印结果：[\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] 总结：\nmatch()这个方法还是很实用的，可以在一个很长的字符串中，提取出有规则的内容。这不就是爬虫的时候经常会遇到的场景么？\nreplace() replace()：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。\n语法：\n1 新的字符串 = str.replace(被替换的内容，新的内容); 参数解释：\n被替换的内容：可以接受一个正则表达式作为参数。\n新的内容：默认只会替换第一个。如果需要替换全部符合条件的内容，可以设置正则表达式为全局匹配模式。\n代码举例：\n1 2 3 4 5 6 //replace()方法：替换 var str2 = \u0026#34;Today is fine day,today is fine day !!!\u0026#34; console.log(str2); console.log(str2.replace(\u0026#34;today\u0026#34;,\u0026#34;tomorrow\u0026#34;)); //只能替换第一个today console.log(str2.replace(/today/gi,\u0026#34;tomorrow\u0026#34;)); //这里用到了正则，且为“全局匹配”模式，才能替换所有的today 常见正则表达式举例 检查一个字符串是否是一个合法手机号 手机号的规则：\n以1开头（^1 表示1开头 , [^1]表示非1或除了1）\n第二位是3~9之间任意数字\n三位以后任意9位数字\n正则实现：\n1 2 3 4 5 var phoneStr = \u0026#34;13067890123\u0026#34;; var phoneReg = /^1[3-9][0-9]{9}$/; console.log(phoneReg.test(phoneStr)); 备注：如果在正则表达式中同时使用^和$符号，则要求字符串必须完全符合正则表达式。\n去掉字符串开头和结尾的空格 正则实现：\n1 str = str.replace(/^\\s*|\\s*$/g,\u0026#34;\u0026#34;); 解释如下：\n1 2 3 str = str.replace(/^\\s*/, \u0026#34;\u0026#34;); //去除开头的空格 str = str.replace(/\\s*$/, \u0026#34;\u0026#34;); //去除结尾的空格 判断字符串是否为电子邮件 正则实现：\n1 2 3 4 5 var emailReg = /^\\w{3,}(\\.\\w+)*@[A-z0-9]+(\\.[A-z]{2,5}){1,2}$/; var email = \u0026#34;abchello@163.com\u0026#34;; console.log(emailReg.test(email)); ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/32-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"正则表达式简介 定义：正则表达式用于定义一些字符串的规则。 作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符","title":"32-正则表达式"},{"content":" 本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。\n以下是正文。\n事件简介 事件：就是文档或浏览器窗口中发生的一些特定的交互瞬间。对于 Web 应用来说，有下面这些代表性的事件：点击某个元素、将鼠标移动至某个元素上方、关闭弹窗等等。\nJavaScript 是以事件驱动为核心的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。\n事件的三要素 事件的三要素：事件源、事件、事件驱动程序。\n比如，我用手去按开关，灯亮了。这件事情里，事件源是：手。事件是：按开关。事件驱动程序是：灯开了或者关了。\n再比如，网页上弹出一个广告，我点击右上角的X，广告就关闭了。这件事情里，事件源是：X。事件是：onclick。事件驱动程序是：广告关闭了。\n于是我们可以总结出：谁引发的后续事件，谁就是事件源。\n总结如下：\n事件源：引发后续事件的html标签。\n事件：js已经定义好了（见下图）。\n事件驱动程序：对样式和html的操作。也就是DOM。\n也就是说，我们可以在时间对应的属性中写一些js代码，当事件被触发时，这些代码将会执行。\n代码书写步骤如下：（重要）\n（1）获取事件源：document.getElementById(“box”); // 类似于Android里面的findViewById\n（2）绑定事件： 事件源box.事件onclick = function(){ 事件驱动程序 };\n（3）书写事件驱动程序：关于DOM的操作。\n最简单的代码举例：（点击box1，然后弹框）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 1、获取事件源 var div = document.getElementById(\u0026#34;box1\u0026#34;); // 2、绑定事件 div.onclick = function () { // 3、书写事件驱动程序 alert(\u0026#34;我是弹出的内容\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 常见的事件如下：\n下面针对这事件的三要素，进行分别介绍。\n1、获取事件源的方式（DOM节点的获取） 获取事件源的常见方式如下：\n1 2 3 4 5 var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //方式一：通过id获取单个标签 var arr1 = document.getElementsByTagName(\u0026#34;div\u0026#34;); //方式二：通过 标签名 获得 标签数组，所以有s var arr2 = document.getElementsByClassName(\u0026#34;hehe\u0026#34;); //方式三：通过 类名 获得 标签数组，所以有s 2、绑定事件的方式 方式一：直接绑定匿名函数\n1 2 3 4 5 6 7 8 9 \u0026lt;div id=\u0026#34;box1\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //绑定事件的第一种方式 div1.onclick = function () { alert(\u0026#34;我是弹出的内容\u0026#34;); } \u0026lt;/script\u0026gt; 方式二：先单独定义函数，再绑定\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div id=\u0026#34;box1\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //绑定事件的第二种方式 div1.onclick = fn; //注意，这里是fn，不是fn()。fn()指的是返回值。 //单独定义函数 function fn() { alert(\u0026#34;我是弹出的内容\u0026#34;); } \u0026lt;/script\u0026gt; 注意上方代码的注释。绑定的时候，是写fn，不是写fn()。fn代表的是整个函数，而fn()代表的是返回值。\n方式三：行内绑定\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!--行内绑定--\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34; onclick=\u0026#34;fn()\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function fn() { alert(\u0026#34;我是弹出的内容\u0026#34;); } \u0026lt;/script\u0026gt; 注意第一行代码，绑定时，是写的\u0026quot;fn()\u0026quot;，不是写的\u0026quot;fn\u0026quot;。因为绑定的这段代码不是写在js代码里的，而是被识别成了字符串。\n3、事件驱动程序 我们在上面是拿alert举例，不仅如此，我们还可以操作标签的属性和样式。举例如下：\n点击鼠标时，原本粉色的div变大了，背景变红：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; #box1 { width: 100px; height: 100px; background-color: pink; cursor: pointer; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //点击鼠标时，原本粉色的div变大了，背景变红了 div1.onclick = function () { div1.style.width = \u0026#34;200px\u0026#34;; //属性值要写引号 div1.style.height = \u0026#34;200px\u0026#34;; div1.style.backgroundColor = \u0026#34;red\u0026#34;; //属性名是backgroundColor，不是background-color } \u0026lt;/script\u0026gt; 上方代码的注意事项：\n在js里写属性值时，要用引号\n在js里写属性名时，是backgroundColor，不是CSS里面的background-color。\n实现效果如下：\nonload事件 onload事件比较特殊，这里单独讲一下。\n当页面加载（文本和图片）完毕的时候，触发onload事件。\n举例：\n1 2 3 4 5 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { console.log(\u0026#34;smyhvae\u0026#34;); //等页面加载完毕时，打印字符串 } \u0026lt;/script\u0026gt; 有一点我们要知道：js的加载是和html同步加载的。因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。\n建议是：整个页面上所有元素加载完毕再执行js内容。所以，window.onload可以预防使用标签在定义标签之前。\n备注：关于 onLoad事件，在下一篇文章《DOM简介和DOM操作》中有更详细的讲解和示例。\n事件举例：京东顶部广告栏 比如上面这张图，当鼠标点击右上角的X时，关掉整个广告栏，这就要用到事件。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { padding: 0; margin: 0; } .top-banner { background-color: pink; height: 80px; } .w { width: 1210px; margin: 10px auto; position: relative; } img { display: block; width: 1210px; height: 80px; background-color: blue; } a { position: absolute; top: 5px; right: 5px; color: #fff; background-color: #000; text-decoration: none; width: 20px; height: 20px; font: 700 14px/20px \u0026#34;simsum\u0026#34;; text-align: center; } .hide { display: none!important; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;top-banner\u0026#34; id=\u0026#34;topBanner\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; id=\u0026#34;closeBanner\u0026#34;\u0026gt;×\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //需求：点击案例，隐藏盒子。 //思路：点击a链接，让top-banner这个盒子隐藏起来（加隐藏类名）。 //1.获取事件源和相关元素 var closeBanner = document.getElementById(\u0026#34;closeBanner\u0026#34;); var topBanner = document.getElementById(\u0026#34;topBanner\u0026#34;); //2.绑定事件 closeBanner.onclick = function () { //3.书写事件驱动程序 //类控制 // topBanner.className += \u0026#34; hide\u0026#34;; //保留原类名，添加新类名 topBanner.className = \u0026#34;hide\u0026#34;;//替换旧类名（方式一） // topBanner.style.display = \u0026#34;none\u0026#34;; //方式二：与上一行代码的效果相同 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意最后一行代码，这种方式会替换旧类名，意思是，不管之前的类名叫什么，都会被修改。\n事件举例： 要求实现效果：当鼠标悬停在img上时，更换为另外一张图片；鼠标离开时，还原为本来的图片。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; //window.onload页面加载完毕以后再执行此代码 window.onload = function () { //需求：鼠标放到img上，更换为另一张图片，也就是修改路径（src的值）。 //步骤： //1.获取事件源 //2.绑定事件 //3.书写事件驱动程序 //1.获取事件源 var img = document.getElementById(\u0026#34;box\u0026#34;); //2.绑定事件(悬停事件：鼠标进入到事件源中，立即触发事件) img.onmouseover = function () { //3.书写事件驱动程序(修改src) img.src = \u0026#34;image/jd2.png\u0026#34;; // this.src = \u0026#34;image/jd2.png\u0026#34;; } //2.绑定事件(悬停事件：鼠标进入到事件源中，立即触发事件) img.onmouseout = function () { //3.书写事件驱动程序(修改src) img.src = \u0026#34;image/jd1.png\u0026#34;; } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;box\u0026#34; src=\u0026#34;image/jd1.png\u0026#34; style=\u0026#34;cursor: pointer;border: 1px solid #ccc;\u0026#34;/\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/33-%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B/","summary":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 事件简介 事件：就","title":"33-事件简介"},{"content":"常见概念 JavaScript的组成 JavaScript基础分为三个部分：\nECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。\nDOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。\nBOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。\n节点 节点（Node）：构成 HTML 网页的最基本单元。网页中的每一个部分都可以称为是一个节点，比如：html标签、属性、文本、注释、整个文档等都是一个节点。\n虽然都是节点，但是实际上他们的具体类型是不同的。常见节点分为四类：\n文档节点（文档）：整个 HTML 文档。整个 HTML 文档就是一个文档节点。\n元素节点（标签）：HTML标签。\n属性节点（属性）：元素的属性。\n文本节点（文本）：HTML标签中的文本内容（包括标签之间的空格、换行）。\n节点的类型不同，属性和方法也都不尽相同。所有的节点都是Object。\n什么是DOM DOM：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。\nDOM就是由节点组成的。\n解析过程： HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树，getElementById是获取内中DOM上的元素节点。然后操作的时候修改的是该元素的属性。\nDOM树：（一切都是节点）\nDOM的数据结构如下：\n上图可知，在HTML当中，一切都是节点（非常重要）。节点的分类，在上一段中，已经讲了。\n整个html文档就是一个文档节点。所有的节点都是Object。\nDOM可以做什么 找对象（元素节点）\n设置元素的属性值\n设置元素的样式\n动态创建和删除元素\n事件的触发响应：事件源、事件、事件的驱动程序\n元素节点的获取 DOM节点的获取方式其实就是获取事件源的方式。关于事件，上一篇文章中已经讲到了。\n想要操作元素节点，必须首先要找到该节点。有三种方式可以获取DOM节点：\n1 2 3 4 5 var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //方式一：通过 id 获取 一个 元素节点（为什么是一个呢？因为 id 是唯一的） var arr1 = document.getElementsByTagName(\u0026#34;div\u0026#34;); //方式二：通过 标签名 获取 元素节点数组，所以有s var arr2 = document.getElementsByClassName(\u0026#34;hehe\u0026#34;); //方式三：通过 类名 获取 元素节点数组，所以有s 既然方式二、方式三获取的是标签数组，那么习惯性是先遍历之后再使用。\n特殊情况：数组中的值只有1个。即便如此，这一个值也是包在数组里的。这个值的获取方式如下：\n1 2 3 document.getElementsByTagName(\u0026#34;div1\u0026#34;)[0]; //取数组中的第一个元素 document.getElementsByClassName(\u0026#34;hehe\u0026#34;)[0]; //取数组中的第一个元素 DOM访问关系的获取 DOM的节点并不是孤立的，因此可以通过DOM节点之间的相对关系对它们进行访问。如下：\n节点的访问关系，是以属性的方式存在的。\nJS中的父子兄访问关系：\n这里我们要重点知道parentNode和children这两个属性的用法。下面分别介绍。\n获取父节点 调用者就是节点。一个节点只有一个父节点，调用方式就是\n1 节点.parentNode 获取兄弟节点 1、下一个节点 | 下一个元素节点：\nSibling的中文是兄弟。\n（1）nextSibling：\n火狐、谷歌、IE9+版本：都指的是下一个节点（包括标签、空文档和换行节点）。\nIE678版本：指下一个元素节点（标签）。\n（2）nextElementSibling：\n火狐、谷歌、IE9+版本：都指的是下一个元素节点（标签）。 总结：为了获取下一个元素节点，我们可以这样做：在IE678中用nextSibling，在火狐谷歌IE9+以后用nextElementSibling，于是，综合这两个属性，可以这样写：\n1 下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling 2、前一个节点 | 前一个元素节点：\nprevious的中文是：前一个。\n（1）previousSibling：\n火狐、谷歌、IE9+版本：都指的是前一个节点（包括标签、空文档和换行节点）。\nIE678版本：指前一个元素节点（标签）。\n（2）previousElementSibling：\n火狐、谷歌、IE9+版本：都指的是前一个元素节点（标签）。 总结：为了获取前一个元素节点，我们可以这样做：在IE678中用previousSibling，在火狐谷歌IE9+以后用previousElementSibling，于是，综合这两个属性，可以这样写：\n1 前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling 3、补充：获得任意一个兄弟节点：\n1 节点自己.parentNode.children[index]; //随意得到兄弟节点 获取单个的子节点 1、第一个子节点 | 第一个子元素节点：\n（1）firstChild：\n火狐、谷歌、IE9+版本：都指的是第一个子节点（包括标签、空文档和换行节点）。\nIE678版本：指第一个子元素节点（标签）。\n（2）firstElementChild：\n火狐、谷歌、IE9+版本：都指的是第一个子元素节点（标签）。 总结：为了获取第一个子元素节点，我们可以这样做：在IE678中用firstChild，在火狐谷歌IE9+以后用firstElementChild，于是，综合这两个属性，可以这样写：\n1 第一个子元素节点 = 节点.firstElementChild || 节点.firstChild 2、最后一个子节点 | 最后一个子元素节点：\n（1）lastChild：\n火狐、谷歌、IE9+版本：都指的是最后一个子节点（包括标签、空文档和换行节点）。\nIE678版本：指最后一个子元素节点（标签）。\n（2）lastElementChild：\n火狐、谷歌、IE9+版本：都指的是最后一个子元素节点（标签）。 总结：为了获取最后一个子元素节点，我们可以这样做：在IE678中用lastChild，在火狐谷歌IE9+以后用lastElementChild，于是，综合这两个属性，可以这样写：\n1 最后一个子元素节点 = 节点.lastElementChild || 节点.lastChild 获取所有的子节点 （1）childNodes：标准属性。返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）。是W3C的亲儿子。\n火狐 谷歌等高本版会把换行也看做是子节点。 用法：\n1 子节点数组 = 父节点.childNodes; //获取所有节点。 （2）children：非标准属性。返回的是指定元素的子元素节点的集合。【重要】\n它只返回HTML节点，甚至不返回文本节点。 在IE6/7/8中包含注释节点（在IE678中，注释节点不要写在里面）。 虽然不是标准的DOM属性，但它和innerHTML方法一样，得到了几乎所有浏览器的支持。\n用法：（用的最多）\n1 子节点数组 = 父节点.children; //获取所有节点。用的最多。 DOM节点的操作（重要） 上一段的内容：节点的访问关系都是属性。\n本段的内容：节点的操作都是函数（方法）。\n创建节点 格式如下：\n1 新的标签(元素节点) = document.createElement(\u0026#34;标签名\u0026#34;); 比如，如果我们想创建一个li标签，或者是创建一个不存在的adbc标签，可以这样做：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var a1 = document.createElement(\u0026#34;li\u0026#34;); //创建一个li标签 var a2 = document.createElement(\u0026#34;adbc\u0026#34;); //创建一个不存在的标签 console.log(a1); console.log(a2); console.log(typeof a1); console.log(typeof a2); \u0026lt;/script\u0026gt; 打印结果：\n插入节点 插入节点有两种方式，它们的含义是不同的。\n方式1：\n1 父节点.appendChild(新的子节点); 解释：父节点的最后插入一个新的子节点。\n方式2：\n1 父节点.insertBefore(新的子节点,作为参考的子节点) 解释：\n在参考节点前插入一个新的节点。 如果参考节点为null，那么他将在父节点里面的最后插入一个子节点。 我们可以看到，li标签确实被插入到了box1标签的里面，和box2并列了。\n方式2的举例：\n我们可以看到，b1标签被插入到了box1标签的里面，和a1标签并列，在a1标签的前面。\n特别强调：\n关于方式1的appendChild方法，这里要强调一下。比如，现在有下面这样一个div结构：\n1 2 3 4 5 6 7 8 \u0026lt;div class=\u0026#34;box11\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box12\u0026#34;\u0026gt;生命壹号\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box21\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box22\u0026#34;\u0026gt;永不止步\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上方结构中，子盒子box12是在父亲box11里的，子盒子box22是在父亲box21里面的。现在，如果我调用方法box11.appendChild(box22)，最后产生的结果是：box22会跑到box11中（也就是说，box22不在box21里面了）。这是一个很神奇的事情：\n删除节点 格式如下：\n1 父节点.removeChild(子节点); 解释：用父节点删除子节点。必须要指定是删除哪个子节点。\n如果我想删除自己这个节点，可以这么做：\n1 node1.parentNode.removeChild(node1); 复制节点（克隆节点） 格式如下：\n1 2 3 要复制的节点.cloneNode(); //括号里不带参数和带参数false，效果是一样的。 要复制的节点.cloneNode(true); 括号里带不带参数，效果是不同的。解释如下：\n不带参数/带参数false：只复制节点本身，不复制子节点。\n带参数true：既复制节点本身，也复制其所有的子节点。\n设置节点的属性 我们可以获取节点的属性值、设置节点的属性值、删除节点的属性。\n我们就统一拿下面这个标签来举例：\n1 \u0026lt;img src=\u0026#34;images/1.jpg\u0026#34; class=\u0026#34;image-box\u0026#34; title=\u0026#34;美女图片\u0026#34; alt=\u0026#34;地铁一瞥\u0026#34; id=\u0026#34;a1\u0026#34;\u0026gt; 下面分别介绍。\n1、获取节点的属性值 方式1：\n1 2 元素节点.属性名; 元素节点[属性名]; 举例：（获取节点的属性值）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;images/1.jpg\u0026#34; class=\u0026#34;image-box\u0026#34; title=\u0026#34;美女图片\u0026#34; alt=\u0026#34;地铁一瞥\u0026#34; id=\u0026#34;a1\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var myNode = document.getElementsByTagName(\u0026#34;img\u0026#34;)[0]; console.log(myNode.src); console.log(myNode.className); //注意，是className，不是class console.log(myNode.title); console.log(\u0026#34;------------\u0026#34;); console.log(myNode[\u0026#34;src\u0026#34;]); console.log(myNode[\u0026#34;className\u0026#34;]); //注意，是className，不是class console.log(myNode[\u0026#34;title\u0026#34;]); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 上方代码中的img标签，有各种属性，我们可以逐一获取，打印结果如下：\n方式2：\n1 元素节点.getAttribute(\u0026#34;属性名称\u0026#34;); 举例：\n1 2 3 console.log(myNode.getAttribute(\u0026#34;src\u0026#34;)); console.log(myNode.getAttribute(\u0026#34;class\u0026#34;)); //注意是class，不是className console.log(myNode.getAttribute(\u0026#34;title\u0026#34;)); 打印结果：\n方式1和方式2的区别在于：前者是直接操作标签，后者是把标签作为DOM节点。推荐方式2。\n2、设置节点的属性值 方式1举例：（设置节点的属性值）\n1 2 myNode.src = \u0026#34;images/2.jpg\u0026#34; //修改src的属性值 myNode.className = \u0026#34;image2-box\u0026#34;; //修改class的name 方式2：\n1 元素节点.setAttribute(\u0026#34;属性名\u0026#34;, \u0026#34;新的属性值\u0026#34;); 方式2举例：（设置节点的属性值）\n1 2 3 myNode.setAttribute(\u0026#34;src\u0026#34;,\u0026#34;images/3.jpg\u0026#34;); myNode.setAttribute(\u0026#34;class\u0026#34;,\u0026#34;image3-box\u0026#34;); myNode.setAttribute(\u0026#34;id\u0026#34;,\u0026#34;你好\u0026#34;); 3、删除节点的属性 格式：\n1 元素节点.removeAttribute(属性名); 举例：（删除节点的属性）\n1 2 myNode.removeAttribute(\u0026#34;class\u0026#34;); myNode.removeAttribute(\u0026#34;id\u0026#34;); 总结 获取节点的属性值和设置节点的属性值，都有两种方式。\n如果是节点的“原始属性”（比如 普通标签的class/className属性、普通标签的style属性、普通标签的 title属性、img 标签的src属性、超链接的href属性等），方式1和方式2是等价的，可以混用。怎么理解混用呢？比如说：用 div.title = '我是标题'设置属性，用 div.getAttribute('title')获取属性，就是混用。\n但如果是节点的“非原始属性”，比如：\n1 2 3 div.aaa = \u0026#39;qianguyihao\u0026#39;; div.setAttribute(\u0026#39;bbb\u0026#39;, \u0026#39;qianguyihao\u0026#39;); 上面的这个“非原始属性”，在使用这两种方式时，是有区别的。区别如下：\n方式1 的元素节点.属性和元素节点[属性]：绑定的属性值不会出现在标签上。\n方式2 的get/set/removeAttribut：绑定的属性值会出现在标签上。\n这两种方式不能交换使用，get值和set值必须使用同一种方法。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34; title=\u0026#34;主体\u0026#34; class=\u0026#34;asdfasdfadsfd\u0026#34;\u0026gt;我爱你中国\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementById(\u0026#34;box\u0026#34;); //采用方式一进行set div.aaaa = \u0026#34;1111\u0026#34;; console.log(div.aaaa); //打印结果：1111。可以打印出来，但是不会出现在标签上 //采用方式二进行set div.setAttribute(\u0026#34;bbbb\u0026#34;,\u0026#34;2222\u0026#34;); //bbbb作为新增的属性，会出现在标签上 console.log(div.getAttribute(\u0026#34;aaaa\u0026#34;)); //打印结果：null。因为方式一的set，无法采用方式二进行get。 console.log(div.bbbb); //打印结果：undefined。因为方式二的set，无法采用方式一进行get。 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; DOM对象的属性-补充 innerHTML和innerText的区别 value：标签的value属性。\ninnerHTML：双闭合标签里面的内容（包含标签）。\ninnerText：双闭合标签里面的内容（不包含标签）。（老版本的火狐用textContent）\n获取内容举例：\n如果我们想获取innerHTML和innerText里的内容，看看会如何：（innerHTML会获取到标签本身，而innerText则不会）\n修改内容举例：（innerHTML会修改标签本身，而innerText则不会）\nnodeType属性 这里讲一下nodeType属性。\nnodeType == 1 表示的是元素节点（标签） 。记住：在这里，元素就是标签。\nnodeType == 2 表示是属性节点。\nnodeType == 3 是文本节点。\nnodeType、nodeName、nodeValue 我们那下面这个标签来举例：\n1 2 3 \u0026lt;div id=\u0026#34;box\u0026#34; value=\u0026#34;111\u0026#34;\u0026gt; 生命壹号 \u0026lt;/div\u0026gt; 上面这个标签就包含了三种节点：\n元素节点（标签）\n属性节点\n文本节点\n获取这三个节点的方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var element = document.getElementById(\u0026#34;box1\u0026#34;); //获取元素节点（标签） var attribute = element.getAttributeNode(\u0026#34;id\u0026#34;); //获取box1的属性节点 var txt = element.firstChild; //获取box1的文本节点 var value = element.getAttribute(\u0026#34;id\u0026#34;); //获取id的属性值 console.log(element); console.log(\u0026#34;--------------\u0026#34;); console.log(attribute); console.log(\u0026#34;--------------\u0026#34;); console.log(txt); console.log(\u0026#34;--------------\u0026#34;); console.log(value); 打印结果如下：\n既然这三个都是节点，如果我想获取它们的nodeType、nodeName、nodeValue，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var element = document.getElementById(\u0026#34;box1\u0026#34;); //获取元素节点（标签） var attribute = element.getAttributeNode(\u0026#34;id\u0026#34;); //获取box1的属性节点 var txt = element.firstChild; //获取box1的文本节点 //获取nodeType console.log(element.nodeType); //1 console.log(attribute.nodeType); //2 console.log(txt.nodeType); //3 console.log(\u0026#34;--------------\u0026#34;); //获取nodeName console.log(element.nodeName); //DIV console.log(attribute.nodeName); //id console.log(txt.nodeName); //#text console.log(\u0026#34;--------------\u0026#34;); //获取nodeValue console.log(element.nodeValue); //null console.log(attribute.nodeValue); //box1 console.log(txt.nodeValue); //生命壹号 打印结果如下：\n文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行。如果将script标签写到页面的上边，在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载，会导致无法获取到DOM对象。\nonload 事件：\nonload 事件会在整个页面加载完成之后才触发。为 window 绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 【方式一：先加载，后执行】这段 js 代码是写在 \u0026lt;head\u0026gt; 标签里的，所以建议放在 window.onload 里面。 window.onload = function() { // 获取id为btn的按钮 var btn = document.getElementById(\u0026#34;btn\u0026#34;); // 为按钮绑定点击事件 btn.onclick = function() { alert(\u0026#34;hello\u0026#34;); }; }; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点我一下\u0026lt;/button\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 【方式二：后加载，后执行】这段 js 代码是写在 \u0026lt;body\u0026gt; 标签里的，代码的位置是处在页面的下方。这么做，也可以确保：在页面加载完毕后，再执行 js 代码。 // 获取id为btn的按钮 var btn = document.getElementById(\u0026#34;btn\u0026#34;); // 为按钮绑定点击事件 btn.onclick = function() { alert(\u0026#34;hello\u0026#34;); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中，方式一和方式二均可以确保：在页面加载完毕后，再执行 js 代码。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/34-dom%E7%AE%80%E4%BB%8B%E5%92%8Cdom%E6%93%8D%E4%BD%9C/","summary":"常见概念 JavaScript的组成 JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达","title":"34-DOM简介和DOM操作"},{"content":"style属性的获取和修改 在DOM当中，如果想设置样式，有两种形式：\nclassName（针对内嵌样式）\nstyle（针对行内样式）\n这篇文章，我们就来讲一下style。\n需要注意的是：style是一个对象，只能获取行内样式，不能获取内嵌的样式和外链的样式。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { border: 6px solid red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34; style=\u0026#34;width: 200px;height: 100px;background-color: pink;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var box1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; console.log(box1.style.backgroundColor); console.log(box1.style.border); //没有打印结果，因为这个属性不是行内样式 console.log(typeof box1.style); //因为是对象，所以打印结果是Object console.log(box1.style); //打印结果是对象 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n上图显示，因为border属性不是行内样式，所以无法通过style对象获取。\n通过 js 读取元素的样式 语法：（方式一）\n1 元素.style.样式名 备注：我们通过style属性读取的样式都是行内样式。\n语法：（方式二）\n1 2 3 元素.style[\u0026#34;属性\u0026#34;]; //格式 box.style[\u0026#34;width\u0026#34;]; //举例 方式二最大的优点是：可以给属性传递参数。\n通过 js 设置元素的样式 语法：\n1 元素.style.样式名 = 样式值; 举例：\n1 2 box1.style.width = \u0026#34;300px\u0026#34;; box1.style.backgroundColor = \u0026#34;red\u0026#34;; // 驼峰命名法 备注：我们通过style属性设置的样式都是行内样式，而行内样式有较高的优先级。但是如果在样式中的其他地方写了!important，则此时!important会有更高的优先级。\nstyle属性的注意事项 style属性需要注意以下几点：\n（1）样式少的时候使用。\n（2）style是对象。我们在上方已经打印出来，typeof的结果是Object。\n（3）值是字符串，没有设置值是“”。\n（4）命名规则，驼峰命名。\n（5）只能获取行内样式，和内嵌和外链无关。\n（6）box.style.cssText = “字符串形式的样式”。\ncssText这个属性，其实就是把行内样式里面的值当做字符串来对待。在上方代码的基础之上，举例：\n1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; var box1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; //通过cssText一次性设置行内样式 box1.style.cssText = \u0026#34;width: 300px;height: 300px;background-color: green;\u0026#34;; console.log(box1.style.cssText); //这一行更加可以理解,style是对象 \u0026lt;/script\u0026gt; 打印结果：\nstyle的常用属性 style的常用属性包括：\nbackgroundColor\nbackgroundImage\ncolor\nwidth\nheight\nborder\nopacity 设置透明度 (IE8以前是filter: alpha(opacity=xx))\n注意DOM对象style的属性和标签中style内的值不一样，因为在JS中，-不能作为标识符。比如：\nDOM中：backgroundColor\nCSS中：background-color\nstyle属性的举例 我们针对上面列举的几个style的样式，来举几个例子：\n举例1、改变div的大小和透明度\n举例2、当前输入的文本框高亮显示\n举例3、高级隔行变色、高亮显示\n下面来逐一实现。\n举例1：改变div的大小和透明度 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;width: 100px;height: 100px;background-color: pink;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div.onmouseover = function () { div.style.width = \u0026#34;200px\u0026#34;; div.style.height = \u0026#34;200px\u0026#34;; div.style.backgroundColor = \u0026#34;black\u0026#34;; div.style.opacity = \u0026#34;0.2\u0026#34;; //设置背景色的透明度。单位是0.1 div.style.filter = \u0026#34;alpha(opacity=20)\u0026#34;; //上一行代码的兼容性写法。注意单位是百进制 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 举例2：当前输入的文本框高亮显示 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; input { display: block; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; //需求：让所有的input标签获取焦点后高亮显示 //1.获取事件源 var inpArr = document.getElementsByTagName(\u0026#34;input\u0026#34;); //2.绑定事件 //3.书写事件驱动程序 for (var i = 0; i \u0026lt; inpArr.length; i++) { //获取焦点后，所有的input标签被绑定onfocus事件 inpArr[i].onfocus = function () { this.style.border = \u0026#34;2px solid red\u0026#34;; this.style.backgroundColor = \u0026#34;#ccc\u0026#34;; } //绑定onblur事件，取消样式 inpArr[i].onblur = function () { this.style.border = \u0026#34;\u0026#34;; this.style.backgroundColor = \u0026#34;\u0026#34;; } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 举例3：高级隔行变色、高亮显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { padding: 0; margin: 0; text-align: center; } .wrap { width: 500px; margin: 100px auto 0; } table { border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 500px; } th, td { border: 1px solid #d0d0d0; color: #404060; padding: 10px; } th { background-color: #09c; font: bold 16px \u0026#34;微软雅黑\u0026#34;; color: #fff; } td { font: 14px \u0026#34;微软雅黑\u0026#34;; } tbody tr { background-color: #f0f0f0; cursor: pointer; } .current { background-color: red !important; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;课程\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody id=\u0026#34;target\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 1 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;生命壹号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;语文\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 2 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;生命贰号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;日语\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;99\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 3 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;生命叁号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;营销学\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;98\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 4 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;生命伍号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;数学\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;90\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 5 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;许嵩\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;英语\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;96\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 6 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;vae\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;体育\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;90\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //需求：让tr各行变色，鼠标放入tr中，高亮显示。 //1.隔行变色。 var tbody = document.getElementById(\u0026#34;target\u0026#34;); var trArr = tbody.children; //循环判断并各行赋值属性（背景色） for (var i = 0; i \u0026lt; trArr.length; i++) { if (i % 2 !== 0) { trArr[i].style.backgroundColor = \u0026#34;#a3a3a3\u0026#34;; } else { trArr[i].style.backgroundColor = \u0026#34;#ccc\u0026#34;; } //鼠标进入高亮显示 //难点：鼠标移开的时候要回复原始颜色。 //计数器（进入tr之后，立刻记录颜色，然后移开的时候使用记录好的颜色） var myColor = \u0026#34;\u0026#34;; trArr[i].onmouseover = function () { //赋值颜色之前，先记录颜色 myColor = this.style.backgroundColor; this.style.backgroundColor = \u0026#34;#fff\u0026#34;; } trArr[i].onmouseout = function () { this.style.backgroundColor = myColor; } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现的效果如下：\n代码解释：\n上方代码中，我们用到了计数器myColor来记录每一行最原始的颜色（赋值白色之前）。如果不用计数器，可能很多人以为代码是写的：（错误的代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;script\u0026gt; //需求：让tr各行变色，鼠标放入tr中，高亮显示。 //1.隔行变色。 var tbody = document.getElementById(\u0026#34;target\u0026#34;); var trArr = tbody.children; //循环判断并各行赋值属性（背景色） for (var i = 0; i \u0026lt; trArr.length; i++) { if (i % 2 !== 0) { trArr[i].style.backgroundColor = \u0026#34;#a3a3a3\u0026#34;; } else { trArr[i].style.backgroundColor = \u0026#34;#ccc\u0026#34;; } //鼠标进入高亮显示 //难点：鼠标移开的时候要回复原始颜色。 //计数器（进入tr之后，立刻记录颜色，然后移开的时候使用记录好的颜色） trArr[i].onmouseover = function () { this.style.backgroundColor = \u0026#34;#fff\u0026#34;; } trArr[i].onmouseout = function () { this.style.backgroundColor = \u0026#34;#a3a3a3\u0026#34;; } } \u0026lt;/script\u0026gt; 这种错误的代码，实现的效果却是：（未达到效果）\n通过 js 获取元素当前显示的样式 我们在上面的内容中，通过元素.style.className的方式只能获取行内样式。但是，有些元素，也写了内嵌样式或外链样式。\n既然样式有这么种，那么，如何获取元素当前显示的样式（包括行内样式、内嵌样式、外链样式）呢？我们接下来看一看。\n获取元素当前正在显示的样式 （1）w3c的做法：\n1 window.getComputedStyle(\u0026#34;要获取样式的元素\u0026#34;, \u0026#34;伪元素\u0026#34;); 两个参数都是必须要有的。参数二中，如果没有伪元素就用 null 代替（一般都传null）。\n（2）IE和opera的做法：\n1 obj.currentStyle; 注意：\n如果当前元素没有设置该样式，则获取它的默认值。\n该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过对象.样式名来读取具体的某一个样式。\n通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性。\n综合上面两种写法，就有了一种兼容性的写法，同时将其封装。代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { background-color: pink; /*border: 1px solid #000;*/ padding: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;width: 100px;height: 100px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; console.log(getStyle(div1, \u0026#34;width\u0026#34;)); console.log(getStyle(div1, \u0026#34;padding\u0026#34;)); console.log(getStyle(div1, \u0026#34;background-color\u0026#34;)); /* * 兼容方法，获取元素当前正在显示的样式。 * 参数： * obj 要获取样式的元素 *. name 要获取的样式名 */ function getStyle(ele, attr) { if (window.getComputedStyle) { return window.getComputedStyle(ele, null)[attr]; } return ele.currentStyle[attr]; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/35-%E9%80%9A%E8%BF%87style%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F/","summary":"style属性的获取和修改 在DOM当中，如果想设置样式，有两种形式： className（针对内嵌样式） style（针对行内样式） 这篇文章，我","title":"35-通过style对象获取和设置行内样式"},{"content":"前言 JS动画的主要内容如下：\n1、三大家族和一个事件对象：\n三大家族：offset/scroll/client。也叫三大系列。\n事件对象/event（事件被触动时，鼠标和键盘的状态）（通过属性控制）。\n2、动画(闪现/匀速/缓动)\n3、冒泡/兼容/封装\noffset 家族的组成 我们知道，JS动画的三大家族包括：offset/scroll/client。今天来讲一下offset，以及与其相关的匀速动画。\noffset的中文是：偏移，补偿，位移。\njs中有一套方便的获取元素尺寸的办法就是offset家族。offset家族包括：\noffsetWidth\noffsetHight\noffsetLeft\noffsetTop\noffsetParent\n下面分别介绍。\n1、offsetWidth 和 offsetHight offsetWidth 和 offsetHight：获取元素的宽高 + padding + border，不包括margin。如下：\noffsetWidth = width + padding + border\noffsetHeight = Height + padding + border\n这两个属性，他们绑定在了所有的节点元素上。获取元素之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。\n举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; padding: 10px; border: 10px solid #000; margin: 100px; background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; console.log(div1.offsetHeight); //打印结果：140（100+20+20） console.log(typeof div1.offsetHeight); //打印结果：number \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2、offsetParent offsetParent：获取当前元素的定位父元素。\n如果当前元素的父元素，有CSS定位（position为absolute、relative、fixed），那么 offsetParent 获取的是最近的那个父元素。\n如果当前元素的父元素，没有CSS定位（position为absolute、relative、fixed），那么offsetParent 获取的是body。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34; style=\u0026#34;position: absolute;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34; style=\u0026#34;position: fixed;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var box3 = document.getElementsByClassName(\u0026#34;box3\u0026#34;)[0]; console.log(box3.offsetParent); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n3、offsetLeft 和 offsetTop offsetLeft：当前元素相对于其定位父元素的水平偏移量。\noffsetTop：当前元素相对于其定位父元素的垂直偏移量。\n备注：从父亲的 padding 开始算起，父亲的 border 不算在内。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box1 { width: 300px; height: 300px; padding: 100px; margin: 100px; position: relative; border: 100px solid #000; background-color: pink; } .box2 { width: 100px; height: 100px; background-color: red; /*position: absolute;*/ /*left: 10px;*/ /*top: 10px;*/ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34; style=\u0026#34;left: 10px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var box2 = document.getElementsByClassName(\u0026#34;box2\u0026#34;)[0]; //offsetTop和offsetLeft console.log(box2.offsetLeft); //100 console.log(box2.style.left); //10px \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在父盒子有定位的情况下，offsetLeft == style.left(去掉px之后)。注意，后者只识别行内样式。但区别不仅仅于此，下面会讲。\noffsetLeft 和 style.left 区别 （1）最大区别在于：\noffsetLeft 可以返回无定位父元素的偏移量。如果父元素中都没有定位，则body为准。\nstyle.left 只能获取行内样式，如果父元素中都没有设置定位，则返回\u0026quot;\u0026quot;（意思是，返回空字符串）;\n（2）offsetTop 返回的是数字，而 style.top 返回的是字符串，而且还带有单位：px。\n比如：\n1 2 3 div.offsetLeft = 100; div.style.left = \u0026#34;100px\u0026#34;; （3）offsetLeft 和 offsetTop 只读，而 style.left 和 style.top 可读写（只读是获取值，可写是修改值）\n总结：我们一般的做法是：用offsetLeft 和 offsetTop 获取值，用style.left 和 style.top 赋值（比较方便）。理由如下：\nstyle.left：只能获取行内式，获取的值可能为空，容易出现NaN。\noffsetLeft：获取值特别方便，而且是现成的number，方便计算。它是只读的，不能赋值。\n动画的种类 闪现（基本不用）\n匀速（本文重点）\n缓动（后续重点）\n简单举例如下：（每间隔500ms，向右移动盒子100px）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; background-color: pink; position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;动画\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; style=\u0026#34;left: 0px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;)[0]; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; //1、闪动 // btn.onclick = function () { // div.style.left = \u0026#34;500px\u0026#34;; // } //2、匀速运动 btn.onclick = function () { //定时器，每隔一定的时间向右走一些 setInterval(function () { console.log(parseInt(div.style.left)); //动画原理： 盒子未来的位置 = 盒子现在的位置 + 步长； //方法1：用offsetLeft获取值，用style.left赋值。 div.style.left = div.offsetLeft + 100 + \u0026#39;px\u0026#39;; // 方法2：必须一开始就在DOM节点上添加 style=\u0026#34;left: 0px;\u0026#34;属性，才能用方法2。否则， div.style.left 的值为 NaN // div.style.left = parseInt(div.style.left)+100+\u0026#34;px\u0026#34;; //方法2： }, 500); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下：\n匀速动画的封装：每间隔30ms，移动盒子10px【重要】 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box1 { margin: 0; padding: 5px; height: 300px; background-color: #ddd; position: relative; } button { margin: 5px; } .box2 { width: 100px; height: 100px; background-color: red; position: absolute; left: 195px; top: 40px; } .box3 { width: 100px; height: 100px; background-color: yellow; position: absolute; left: 0; top: 150px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;button\u0026gt;运动到 left = 200px\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;运动到 left = 400px\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btnArr = document.getElementsByTagName(\u0026#34;button\u0026#34;); var box2 = document.getElementsByClassName(\u0026#34;box2\u0026#34;)[0]; var box3 = document.getElementsByClassName(\u0026#34;box3\u0026#34;)[0]; //绑定事件 btnArr[0].onclick = function () { //如果有一天我们要传递另外一个盒子，那么我们的方法就不好用了 //所以我们要增加第二个参数，被移动的盒子本身。 animate(box2, 200); animate(box3, 200); } btnArr[1].onclick = function () { animate(box2, 400); animate(box3, 400); } //【重要】方法的封装：每间隔30ms，将盒子向右移动10px function animate(ele, target) { //要用定时器，先清除定时器 //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突 //我们可以把定时器本身，当成为盒子的一个属性 clearInterval(ele.timer); //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负 //目标值如果大于当前值取正，目标值如果小于当前值取负 var speed = target \u0026gt; ele.offsetLeft ? 10 : -10; //speed指的是步长 ele.timer = setInterval(function () { //在执行之前就获取当前值和目标值之差 var val = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + \u0026#34;px\u0026#34;; //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了 //因为步长有正有负，所有转换成绝对值来比较 if (Math.abs(val) \u0026lt; Math.abs(speed)) { ele.style.left = target + \u0026#34;px\u0026#34;; clearInterval(ele.timer); } }, 30) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现的效果：\n上方代码中的方法封装，可以作为一个模板步骤，要记住。其实，这个封装的方法，写成下面这样，会更严谨，更容易理解：（将if语句进行了改进）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //【重要】方法的封装：每间隔30ms，将盒子向右移动10px function animate(ele, target) { //要用定时器，先清除定时器 //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突 //我们可以把定时器本身，当成为盒子的一个属性 clearInterval(ele.timer); //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负 //目标值如果大于当前值取正，目标值如果小于当前值取负 var speed = target \u0026gt; ele.offsetLeft ? 10 : -10; //speed指的是步长 ele.timer = setInterval(function () { //在执行之前就获取当前值和目标值之差 var val = target - ele.offsetLeft; //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了 //因为步长有正有负，所有转换成绝对值来比较 if (Math.abs(val) \u0026lt; Math.abs(speed)) { //如果val小于步长，则直接到达目的地；否则，每次移动一个步长 ele.style.left = target + \u0026#34;px\u0026#34;; clearInterval(ele.timer); } else { ele.style.left = ele.offsetLeft + speed + \u0026#34;px\u0026#34;; } }, 30) } 代码举例：轮播图的实现 完整版代码如下：（注释已经比较详细）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;无标题文档\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; * { padding: 0; margin: 0; list-style: none; border: 0; } .all { width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative; } .screen { width: 500px; height: 200px; overflow: hidden; position: relative; } .screen li { width: 500px; height: 200px; overflow: hidden; float: left; } .screen ul { position: absolute; left: 0; top: 0px; width: 3000px; } .all ol { position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center; } .all ol li { float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer; } .all ol li.current { background: yellow; } #arr { display: none; } #arr span { width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: \u0026#39;黑体\u0026#39;; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff; } #arr #right { right: 5px; left: auto; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { //需求：无缝滚动。 //思路：赋值第一张图片放到ul的最后，然后当图片切换到第五张的时候 // 直接切换第六章，再次从第一张切换到第二张的时候先瞬间切换到 // 第一张图片，然后滑动到第二张 //步骤： //1.获取事件源及相关元素。（老三步） //2.复制第一张图片所在的li,添加到ul的最后面。 //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 //4.鼠标放到ol的li上切换图片 //5.添加定时器 //6.左右切换图片（鼠标放上去隐藏，移开显示） //1.获取事件源及相关元素。（老三步） var all = document.getElementById(\u0026#34;all\u0026#34;); var screen = all.firstElementChild || all.firstChild; var imgWidth = screen.offsetWidth; var ul = screen.firstElementChild || screen.firstChild; var ol = screen.children[1]; var div = screen.lastElementChild || screen.lastChild; var spanArr = div.children; //2.复制第一张图片所在的li,添加到ul的最后面。 var ulNewLi = ul.children[0].cloneNode(true); ul.appendChild(ulNewLi); //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 for (var i = 0; i \u0026lt; ul.children.length - 1; i++) { var olNewLi = document.createElement(\u0026#34;li\u0026#34;); olNewLi.innerHTML = i + 1; ol.appendChild(olNewLi) } var olLiArr = ol.children; olLiArr[0].className = \u0026#34;current\u0026#34;; //4.鼠标放到ol的li上切换图片 for (var i = 0; i \u0026lt; olLiArr.length; i++) { //自定义属性，把索引值绑定到元素的index属性上 olLiArr[i].index = i; olLiArr[i].onmouseover = function () { //排他思想 for (var j = 0; j \u0026lt; olLiArr.length; j++) { olLiArr[j].className = \u0026#34;\u0026#34;; } this.className = \u0026#34;current\u0026#34;; //鼠标放到小的方块上的时候索引值和key以及square同步 // key = this.index; // square = this.index; key = square = this.index; //移动盒子 animate(ul, -this.index * imgWidth); } } //5.添加定时器 var timer = setInterval(autoPlay, 1000); //固定向右切换图片 //两个定时器（一个记录图片，一个记录小方块） var key = 0; var square = 0; function autoPlay() { //通过控制key的自增来模拟图片的索引值，然后移动ul key++; if (key \u0026gt; olLiArr.length) { //图片已经滑动到最后一张，接下来，跳转到第一张，然后在滑动到第二张 ul.style.left = 0; key = 1; } animate(ul, -key * imgWidth); //通过控制square的自增来模拟小方块的索引值，然后点亮盒子 //排他思想做小方块 square++; if (square \u0026gt; olLiArr.length - 1) {//索引值不能大于等于5，如果等于5，立刻变为0； square = 0; } for (var i = 0; i \u0026lt; olLiArr.length; i++) { olLiArr[i].className = \u0026#34;\u0026#34;; } olLiArr[square].className = \u0026#34;current\u0026#34;; } //鼠标放上去清除定时器，移开后在开启定时器 all.onmouseover = function () { div.style.display = \u0026#34;block\u0026#34;; clearInterval(timer); } all.onmouseout = function () { div.style.display = \u0026#34;none\u0026#34;; timer = setInterval(autoPlay, 1000); } //6.左右切换图片（鼠标放上去显示，移开隐藏） spanArr[0].onclick = function () { //通过控制key的自增来模拟图片的索引值，然后移动ul key--; if (key \u0026lt; 0) { //先移动到最后一张，然后key的值取之前一张的索引值，然后在向前移动 ul.style.left = -imgWidth * (olLiArr.length) + \u0026#34;px\u0026#34;; key = olLiArr.length - 1; } animate(ul, -key * imgWidth); //通过控制square的自增来模拟小方块的索引值，然后点亮盒子 //排他思想做小方块 square--; if (square \u0026lt; 0) {//索引值不能大于等于5，如果等于5，立刻变为0； square = olLiArr.length - 1; } for (var i = 0; i \u0026lt; olLiArr.length; i++) { olLiArr[i].className = \u0026#34;\u0026#34;; } olLiArr[square].className = \u0026#34;current\u0026#34;; } spanArr[1].onclick = function () { //右侧的和定时器一模一样 autoPlay(); } function animate(ele, target) { clearInterval(ele.timer); var speed = target \u0026gt; ele.offsetLeft ? 10 : -10; ele.timer = setInterval(function () { var val = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + \u0026#34;px\u0026#34;; if (Math.abs(val) \u0026lt; Math.abs(speed)) { ele.style.left = target + \u0026#34;px\u0026#34;; clearInterval(ele.timer); } }, 10) } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;all\u0026#34; id=\u0026#39;all\u0026#39;\u0026gt; \u0026lt;div class=\u0026#34;screen\u0026#34; id=\u0026#34;screen\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/1.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/2.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/3.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/4.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/5.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;div id=\u0026#34;arr\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;right\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\n温馨提示：动图太大，可以把http://img.smyhvae.com/20180202_2020.gif单独在浏览器中打开。\n工程文件：\n2018-02-02-JS动画实现轮播图.rar ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/36-offset%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8C%80%E9%80%9F%E5%8A%A8%E7%94%BB%E5%90%AB%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"前言 JS动画的主要内容如下： 1、三大家族和一个事件对象： 三大家族：offset/scroll/client。也叫三大系列。 事件对象/even","title":"36-offset相关属性和匀速动画(含轮播图的实现)"},{"content":"scroll 相关属性 window.onscroll() 方法 当我们用鼠标滚轮，滚动网页的时候，会触发 window.onscroll() 方法。效果如下：（注意看控制台的打印结果）\n如果你需要做滚动监听，可以使用这个方法。\n我们来看看和 scroll 相关的有哪些属性。\n1、ScrollWidth 和 scrollHeight ScrollWidth 和 scrollHeight：获取元素整个滚动区域的宽、高。包括 width 和 padding，不包括 border和margin。\n注意：\nscrollHeight 的特点是：如果内容超出了盒子，scrollHeight为内容的高（包括超出的内容）；如果不超出，scrollHeight为盒子本身的高度。ScrollWidth同理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; padding: 10px; margin: 3px; border: 8px solid red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; // `scrollHeight` 的特点是：如果内容超出了盒子，`scrollHeight`为内容的高（包括超出的内容）；如果不超出，`scrollHeight`为盒子本身的高度。 //IE8以下（不包括IE8），为盒子本身内容的高度。 console.log(div.scrollWidth); console.log(div.scrollHeight); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n2、scrollTop 和 scrollLeft scrollLeft：获取水平滚动条滚动的距离。\nscrollTop：获取垂直滚动条滚动的距离。\n实战经验：\n当某个元素满足scrollHeight - scrollTop == clientHeight时，说明垂直滚动条滚动到底了。\n当某个元素满足scrollWidth - scrollLeft == clientWidth时，说明水平滚动条滚动到底了。\n这个实战经验非常有用，可以用来判断用户是否已经将内容滑动到底了。比如说，有些场景下，希望用户能够看完“长长的活动规则”，才允许触发接下来的表单操作。\nscrollTop 的兼容性 如果要获取页面滚动的距离，scrollTop 这个属性的写法要注意兼容性，如下。\n（1）如果文档没有 DTD 声明，写法为：\n1 document.body.scrollTop 在没有 DTD 声明的情况下，要求是这种写法，chrome浏览器才能认出来。\n（2）如果文档有 DTD 声明，写法为：\n1 document.documentElement.scrollTop 在有 DTD 声明的情况下，要求是这种写法，IE6、7、8才能认出来。\n综合上面这两个，就诞生了一种兼容性的写法：\n1 2 3 document.body.scrollTop || document.documentElement.scrollTop //方式一 document.body.scrollTop + document.documentElement.scrollTop //方式二 另外还有一种兼容性的写法：window.pageYOffset 和 window.pageXOffset。这种写法无视DTD的声明。这种写法支持的浏览器版本是：火狐/谷歌/ie9+。\n综合上面的几种写法，为了兼容，不管有没有DTD，最终版的兼容性写法：\n1 window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop; 判断是否已经 DTD 声明 方法如下：\n1 2 document.compatMode === \u0026#34;CSS1Compat\u0026#34; // 已声明 document.compatMode === \u0026#34;BackCompat\u0026#34; // 未声明 将 scrollTop 和 scrollLeft 进行封装 这里，我们将 scrollTop 和 scrollLeft 封装为一个方法，名叫scroll()，返回值为 一个对象。以后就直接调用scroll().top 和 scroll().left就好。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { height: 6000px; width: 5000px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; //需求：封装一个兼容的scroll().返回的是对象，用scroll().top获取scrollTop，用scroll().left获取scrollLeft window.onscroll = function () { // var myScroll = scroll(); // myScroll.top; console.log(scroll().top); console.log(scroll().left); } //函数封装（简单封装，实际工作使用） function scroll() { return { //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中，函数定义的那部分就是要封装的代码。\n另外还有一种比较麻烦的封装方式：（仅供参考）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function scroll() { // 开始封装自己的scrollTop if(window.pageYOffset !== undefined) { // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return { left: window.pageXOffset, top: window.pageYOffset } } else if(document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { // 标准浏览器 来判断有没有声明DTD return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop } } return { // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop } } 获取 html 文档的方法 获取title、body、head、html标签的方法如下：\ndocument.title 文档标题；\ndocument.head 文档的头标签\ndocument.body 文档的body标签；\ndocument.documentElement （这个很重要）。\ndocument.documentElement表示文档的html标签。也就是说，基本结构当中的 html 标签而是通过document.documentElement访问的，并不是通过 document.html 去访问的。\nscrollTop 举例：固定导航栏 完整版代码实现：\n（1）index.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0 } img { vertical-align: top; } .main { margin: 0 auto; width: 1000px; margin-top: 10px; } #Q-nav1 { overflow: hidden; } .fixed { position: fixed; top: 0; left: 0; } \u0026lt;/style\u0026gt; \u0026lt;!--引入工具js--\u0026gt; \u0026lt;script src=\u0026#34;tools.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { //需求1：当我们滚动界面的时候，被卷曲的头部如果超过第二个盒子距离顶部的位置，那么直接给第二个盒子加类名.fixed //需求2：当我们滚动界面的时候，被卷曲的头部如果小于第二个盒子距离顶部的位置，那么直接给第二个盒子取消类名.fixed //1.老三步。 var topDiv = document.getElementById(\u0026#34;top\u0026#34;); var height = topDiv.offsetHeight; var middle = document.getElementById(\u0026#34;Q-nav1\u0026#34;); var main = document.getElementById(\u0026#34;main\u0026#34;); window.onscroll = function () { //2.判断 ，被卷曲的头部的大小 if (scroll().top \u0026gt; height) { //3.满足条件添加类，否则删除类 middle.className += \u0026#34; fixed\u0026#34;; //第二个盒子也要占位置，为了避免重叠，我们给第三个盒子一个上padding的空间，把这个空间留给第二个盒子 main.style.paddingTop = middle.offsetHeight + \u0026#34;px\u0026#34;; } else { middle.className = \u0026#34;\u0026#34;; //清零 main.style.paddingTop = 0; } } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34; id=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/top.png\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;Q-nav1\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/nav.png\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34; id=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/main.png\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中，有一个技巧：\n1 main.style.paddingTop = middle.offsetHeight + \u0026#34;px\u0026#34;; 仔细看注释就好。\n（2）tools.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Created by smyhvae on 2018/02/03. */ function scroll() { // 开始封装自己的scrollTop if (window.pageYOffset !== undefined) { // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return { left: window.pageXOffset, top: window.pageYOffset } } else if (document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { // 标准浏览器 来判断有没有声明DTD return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop } } return { // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop } } 实现效果：\n工程文件：\n2018-02-03-scrollTop固定导航栏.rar 缓动动画 三个函数 缓慢动画里，我们要用到三个函数，这里先列出来：\nMath.ceil() 向上取整\nMath.floor() 向下取整\nMath.round(); 四舍五入\n缓动动画的原理 缓动动画的原理就是：在移动的过程中，步长越来越小。\n设置步长为：目标位置和盒子当前位置的十分之一。用公式表达，即：\n1 盒子位置 = 盒子本身位置 + (目标位置 - 盒子本身位置)/ 10； 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; background-color: pink; position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;运动到left = 400px\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;)[0]; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; btn.onclick = function () { setInterval(function () { //动画原理：盒子未来的位置 = 盒子当前的位置+步长 div.style.left = div.offsetLeft + (400 - div.offsetLeft) / 10 + \u0026#34;px\u0026#34;; }, 30); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n缓慢动画的封装（解决四舍五入的问题） 我们发现一个问题，上图中的盒子最终并没有到达400px的位置，而是只到了396.04px就停住了：\n原因是：JS在取整的运算时，进行了四舍五入。\n我们把打印396.04px这个left值打印出来看看：\n我么发现，通过div.style.left获取的值是精确的，通过div.offsetLeft获取的left值会进行四舍五入。\n此时，我们就要用到取整的函数了。\n通过对缓动动画进行封装，完整版的代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; background-color: pink; position: absolute; left: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;运动到200\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;运动到400\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;); var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; btn[0].onclick = function () { animate(div, 200); } btn[1].onclick = function () { animate(div, 400); } //缓动动画封装 function animate(ele, target) { //要用定时器，先清定时器 //一个萝卜一个坑儿，一个元素对应一个定时器 clearInterval(ele.timer); //定义定时器 ele.timer = setInterval(function () { //获取步长 //步长应该是越来越小的，缓动的算法。 var step = (target - ele.offsetLeft) / 10; //对步长进行二次加工(大于0向上取整,小于0向下取整) //达到的效果是：最后10像素的时候都是1像素1像素的向目标位置移动，就能够到达指定位置。 step = step \u0026gt; 0 ? Math.ceil(step) : Math.floor(step); //动画原理： 目标位置 = 当前位置 + 步长 ele.style.left = ele.offsetLeft + step + \u0026#34;px\u0026#34;; console.log(step); //检测缓动动画有没有停止 console.log(\u0026#34;smyhvae\u0026#34;); if (Math.abs(target - ele.offsetLeft) \u0026lt;= Math.abs(step)) { //处理小数赋值 ele.style.left = target + \u0026#34;px\u0026#34;; clearInterval(ele.timer); } }, 30); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\nwindow.scrollTo()方法举例：返回到顶部小火箭 （1）index.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; img { position: fixed; bottom: 100px; right: 50px; cursor: pointer; display: none; border: 1px solid #000; } div { width: 1210px; margin: 100px auto; text-align: center; font: 500 26px/35px \u0026#34;simsun\u0026#34;; color: red; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;tools.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { //需求：被卷去的头部超过100显示小火箭，然后点击小火箭屏幕缓慢移动到最顶端。 //难点：我们以前是移动盒子，现在是移动屏幕，我们没有学过如何移动屏幕。 // 技术点：window.scrollTo(x,y);浏览器显示区域跳转到指定的坐标 //步骤： //1.老三步 var img = document.getElementsByTagName(\u0026#34;img\u0026#34;)[0]; window.onscroll = function () { //被卷去的距离大于200显示小火箭，否则隐藏 //2.显示隐藏小火箭 if (scroll().top \u0026gt; 1000) { img.style.display = \u0026#34;block\u0026#34;; } else { img.style.display = \u0026#34;none\u0026#34;; } //每次移动滚动条的时候都给leader赋值，模拟leader获取距离顶部的距离 leader = scroll().top; } //3.缓动跳转到页面最顶端（利用我们的缓动动画） var timer = null; var target = 0; //目标位置 var leader = 0; //显示区域自身的位置 img.onclick = function () { //技术点：window.scrollTo(0,0); //要用定时器，先清定时器 clearInterval(timer); timer = setInterval(function () { //获取步长 var step = (target - leader) / 10; //二次处理步长 step = step \u0026gt; 0 ? Math.ceil(step) : Math.floor(step); leader = leader + step; //往上移动的过程中，step是负数。当前位置减去步长，就等于下一步的位置。 //显示区域移动 window.scrollTo(0, leader); //清除定时器 if (leader === 0) { clearInterval(timer); } }, 25); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;images/Top.jpg\u0026#34;/\u0026gt; \u0026lt;div\u0026gt; 我是最顶端.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）tools.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Created by smyhvae on 2015/12/8. */ //函数：获取scrollTop和scrollLeft的值 function scroll() { // 开始封装自己的scrollTop if (window.pageYOffset != null) { // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return { left: window.pageXOffset, top: window.pageYOffset } } else if (document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { // 标准浏览器 来判断有没有声明DTD return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop } } return { // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop } } 实现效果：\n小火箭的图片资源：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/37-scroll%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB/","summary":"scroll 相关属性 window.onscroll() 方法 当我们用鼠标滚轮，滚动网页的时候，会触发 window.onscroll() 方法。效果如下：（注意看控制台的打印结果） 如果你需要做滚动监听，可以使用这个方法。","title":"37-scroll相关属性和缓动动画"},{"content":"client 家族的组成 clientWidth 和 clientHeight 元素调用时：\nclientWidth：获取元素的可见宽度（width + padding）。\nclientHeight：获取元素的可见高度（height + padding）。\nbody/html 调用时：\nclientWidth：获取网页可视区域宽度。\nclientHeight：获取网页可视区域高度。\n声明：\nclientWidth 和 clientHeight 属性是只读的，不可修改。\nclientWidth 和 clientHeight 的值都是不带 px 的，返回的都是一个数字，可以直接进行计算。\nclientX 和 clientY event调用：\nclientX：鼠标距离可视区域左侧距离。\nclientY：鼠标距离可视区域上侧距离。\nclientTop 和 clientLeft clientTop：盒子的上border。\nclientLeft：盒子的左border。\n三大家族 offset/scroll/client 的区别 区别1：宽高 offsetWidth = width + padding + border\noffsetHeight = height + padding + border\nscrollWidth = 内容宽度（不包含border）\nscrollHeight = 内容高度（不包含border）\nclientWidth = width + padding\nclientHeight = height + padding\n区别2：上左 offsetTop/offsetLeft：\n调用者：任意元素。(盒子为主) 作用：距离父系盒子中带有定位的距离。 scrollTop/scrollLeft：\n调用者：document.body.scrollTop（window调用）(盒子也可以调用，但必须有滚动条) 作用：浏览器无法显示的部分（被卷去的部分）。 clientY/clientX：\n调用者：event 作用：鼠标距离浏览器可视区域的距离（左、上）。 函数封装：获取浏览器的宽高（可视区域） 函数封装如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //函数封装：获取屏幕可视区域的宽高 function client() { if (window.innerHeight !== undefined) { //ie9及其以上的版本的写法 return { \u0026#34;width\u0026#34;: window.innerWidth, \u0026#34;height\u0026#34;: window.innerHeight } } else if (document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { //标准模式的写法（有DTD时） return { \u0026#34;width\u0026#34;: document.documentElement.clientWidth, \u0026#34;height\u0026#34;: document.documentElement.clientHeight } } else { //没有DTD时的写法 return { \u0026#34;width\u0026#34;: document.body.clientWidth, \u0026#34;height\u0026#34;: document.body.clientHeight } } } 案例：根据浏览器的可视宽度，给定不同的背景的色。\nPS：这个可以用来做响应式。\n代码如下：（需要用到上面的封装好的方法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;tools.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //需求：浏览器每次更改大小，判断是否符合某一标准然后给背景上色。 // // \u0026gt;960红色，大于640小于960蓝色，小于640绿色。 window.onresize = fn; //页面大小发生变化时，执行该函数。 //页面加载的时候直接执行一次函数，确定浏览器可视区域的宽，给背景上色 fn(); //封装成函数，然后指定的时候去调用和绑定函数名 function fn() { if (client().width \u0026gt; 960) { document.body.style.backgroundColor = \u0026#34;red\u0026#34;; } else if (client().width \u0026gt; 640) { document.body.style.backgroundColor = \u0026#34;blue\u0026#34;; } else { document.body.style.backgroundColor = \u0026#34;green\u0026#34;; } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上当代码中，window.onresize事件指的是：在窗口或框架被调整大小时发生。各个事件的解释如下：\nwindow.onscroll 屏幕滑动\nwindow.onresize 浏览器大小变化\nwindow.onload\t页面加载完毕\ndiv.onmousemove 鼠标在盒子上移动（注意：不是盒子移动）\n获取显示器的分辨率 比如，我的电脑的显示器分辨率是：1920*1080。\n获取显示器的分辨率：\n1 2 3 window.onresize = function () { document.title = window.screen.width + \u0026#34; \u0026#34; + window.screen.height; } 显示效果：\n上图中，不管我如何改变浏览器的窗口大小，title栏显示的值永远都是我的显示器分辨率：1920*1080。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/38-client%E5%8F%AF%E8%A7%86%E5%8C%BA%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7/","summary":"client 家族的组成 clientWidth 和 clientHeight 元素调用时： clientWidth：获取元素的可见宽度（width + padding）。 clientHeight：获取元素的","title":"38-client(可视区)相关属性"},{"content":"绑定事件的两种方式/DOM事件的级别 我们在之前的一篇文章《04-JavaScript/22-DOM简介和DOM操作》中已经讲过事件的概念。这里讲一下绑定（注册）事件的两种方式，我们以onclick事件为例。\nDOM0的写法：onclick 1 2 3 element.onclick = function () { } 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;)[0]; //这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的 btn.onclick = function () { console.log(\u0026#34;事件1\u0026#34;); } btn.onclick = function () { console.log(\u0026#34;事件2\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 点击按钮后，上方代码的打印结果：\n1 事件2 我们可以看到，DOM对象.事件 = 函数的这种绑定事件的方式：一个元素的一个事件只能绑定一个响应函数。如果绑定了多个响应函数，则后者会覆盖前者。\nDOM2的写法：addEventListener（高版本浏览器） 1 2 3 element.addEventListener(\u0026#39;click\u0026#39;, function () { }, false); 参数解释：\n参数1：事件名的字符串(注意，没有on)\n参数2：回调函数：当事件触发时，该函数会被执行\n参数3：true表示捕获阶段触发，false表示冒泡阶段触发（默认）。如果不写，则默认为false。【重要】\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;)[0]; // addEventListener: 事件监听器。 原事件被执行的时候，后面绑定的事件照样被执行 // 这种写法不存在响应函数被覆盖的情况。（更适合团队开发） btn.addEventListener(\u0026#34;click\u0026#34;, fn1); btn.addEventListener(\u0026#34;click\u0026#34;, fn2); function fn1() { console.log(\u0026#34;事件1\u0026#34;); } function fn2() { console.log(\u0026#34;事件2\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 点击按钮后，上方代码的打印结果：\n1 2 事件1 事件2 我们可以看到，addEventListener()这种绑定事件的方式：\n一个元素的一个事件，可以绑定多个响应函数。不存在响应函数被覆盖的情况。执行顺序是：事件被触发时，响应函数会按照函数的绑定顺序执行。\naddEventListener()中的this，是绑定事件的对象。\naddEventListener()不支持 IE8 及以下的浏览器。在IE8中可以使用attachEvent来绑定事件（详见下一小段）。\nDOM2的写法：attachEvent（IE8及以下版本浏览器） 1 2 3 element.attachEvent(\u0026#39;onclick\u0026#39;, function () { }); 参数解释：\n参数1：事件名的字符串(注意，有on)\n参数2：回调函数：当事件触发时，该函数会被执行\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#39;button\u0026#39;)[0]; btn.attachEvent(\u0026#39;onclick\u0026#39;, function() { console.log(\u0026#39;事件1\u0026#39;); }); btn.attachEvent(\u0026#39;onclick\u0026#39;, function() { console.log(\u0026#39;事件2\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 在低版本的IE浏览器上，点击按钮后，上方代码的打印结果：\n1 2 事件2 事件1 我们可以看到，attachEvent()这种绑定事件的方式：\n一个元素的一个事件，可以绑定多个响应函数。不存在响应函数被覆盖的情况。注意：执行顺序是，后绑定的先执行。\nattachEvent()中的this，是window\n兼容性写法 上面的内容里，需要强调的是：\naddEventListener()中的this，是绑定事件的对象。\nattachEvent()中的this，是window。\n既然这两个写法的this不同，那么，有没有一种兼容性的写法可以确保这两种绑定方式的this是相同的呢？我们可以封装一下。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#39;button\u0026#39;)[0]; myBind(btn , \u0026#34;click\u0026#34; , function(){ alert(this); }); //定义一个函数，用来为指定元素绑定响应函数 /* * addEventListener()中的this，是绑定事件的对象 * attachEvent()中的this，是window * 需要统一两个方法this */ /* * 参数： * element 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */ function myBind(element , eventStr , callback){ if(element.addEventListener){ //大部分浏览器兼容的方式 element.addEventListener(eventStr , callback , false); }else{ /* * this是谁，由调用方式决定 * callback.call(element) */ //IE8及以下 element.attachEvent(\u0026#34;on\u0026#34;+eventStr , function(){ //在匿名函数 function 中调用回调函数callback callback.call(element); }); } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 事件对象 当事件的响应函数被触发时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传进之前的响应函数。\n这个对象中包含了与当前事件相关的一切信息。比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向等。\n获取 event 对象（兼容性问题） 所有浏览器都支持event对象，但支持的方式不同。如下。\n（1）普通浏览器的写法是 event。比如：\n（2）ie 678 的写法是 window.event。此时，事件对象 event 是作为window对象的属性保存的。\n于是，我们可以采取一种兼容性的写法。如下：\n1 event = event || window.event; // 兼容性写法 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; //点击页面的任何部分 document.onclick = function (event) { event = event || window.event; ////兼容性写法 console.log(event); console.log(event.timeStamp); console.log(event.bubbles); console.log(event.button); console.log(event.pageX); console.log(event.pageY); console.log(event.screenX); console.log(event.screenY); console.log(event.target); console.log(event.type); console.log(event.clientX); console.log(event.clientY); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; event 属性 event 有很多属性，比如：\n由于pageX 和 pageY的兼容性不好，我们可以这样做：\n鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 Event举例 举例1：使 div 跟随鼠标移动 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #box1 { width: 100px; height: 100px; background-color: red; /* * 开启box1的绝对定位 */ position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function() { /* * 使div可以跟随鼠标移动 */ //获取box1 var box1 = document.getElementById(\u0026#34;box1\u0026#34;); //给整个页面绑定：鼠标移动事件 document.onmousemove = function(event) { //兼容的方式获取event对象 event = event || window.event; // 鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; // 设置div的偏移量（相对于整个页面） // 注意，如果想通过 style.left 来设置属性，一定要给 box1开启绝对定位。 box1.style.left = pagex + \u0026#34;px\u0026#34;; box1.style.top = pagey + \u0026#34;px\u0026#34;; }; }; // scroll 函数封装 function scroll() { return { //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft }; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;height: 1000px;width: 2000px;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 举例2：获取鼠标距离所在盒子的距离 关键点：\n1 鼠标距离所在盒子的距离 = 鼠标在整个页面的位置 - 所在盒子在整个页面的位置 代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box { width: 300px; height: 200px; padding-top: 100px; background-color: pink; margin: 100px; text-align: center; font: 18px/30px \u0026#34;simsun\u0026#34;; cursor: pointer; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;animate.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //需求：鼠标进入盒子之后只要移动，哪怕1像素，随时显示鼠标在盒子中的坐标。 //技术点：新事件，onmousemove：在事件源上，哪怕鼠标移动1像素也会触动这个事件。 //一定程度上，模拟了定时器 //步骤： //1.老三步和新五步 //2.获取鼠标在整个页面的位置 //3.获取盒子在整个页面的位置 //4.用鼠标的位置减去盒子的位置赋值给盒子的内容。 //1.老三步和新五步 var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div.onmousemove = function (event) { event = event || window.event; //2.获取鼠标在整个页面的位置 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; //3.获取盒子在整个页面的位置 // var xx = // var yy = //4.用鼠标的位置减去盒子的位置赋值给盒子的内容。 var targetx = pagex - div.offsetLeft; var targety = pagey - div.offsetTop; this.innerHTML = \u0026#34;鼠标在盒子中的X坐标为：\u0026#34; + targetx + \u0026#34;px;\u0026lt;br\u0026gt;鼠标在盒子中的Y坐标为：\u0026#34; + targety + \u0026#34;px;\u0026#34; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\n举例3：商品放大镜 代码实现：\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .box { width: 350px; height: 350px; margin: 100px; border: 1px solid #ccc; position: relative; } .big { width: 400px; height: 400px; position: absolute; top: 0; left: 360px; border: 1px solid #ccc; overflow: hidden; display: none; } /*mask的中文是：遮罩*/ .mask { width: 175px; height: 175px; background: rgba(255, 255, 0, 0.4); position: absolute; top: 0; left: 0; cursor: move; display: none; } .small { position: relative; } img { vertical-align: top; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;tools.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { //需求：鼠标放到小盒子上，让大盒子里面的图片和我们同步等比例移动。 //技术点：onmouseenter==onmouseover 第一个不冒泡 //技术点：onmouseleave==onmouseout 第一个不冒泡 //步骤： //1.鼠标放上去显示盒子，移开隐藏盒子。 //2.老三步和新五步（黄盒子跟随移动） //3.右侧的大图片，等比例移动。 //0.获取相关元素 var box = document.getElementsByClassName(\u0026#34;box\u0026#34;)[0]; var small = box.firstElementChild || box.firstChild; var big = box.children[1]; var mask = small.children[1]; var bigImg = big.children[0]; //1.鼠标放上去显示盒子，移开隐藏盒子。(为小盒子绑定事件) small.onmouseenter = function () { //封装好方法调用：显示元素 show(mask); show(big); } small.onmouseleave = function () { //封装好方法调用：隐藏元素 hide(mask); hide(big); } //2.老三步和新五步（黄盒子跟随移动） //绑定的事件是onmousemove，而事件源是small(只要在小盒子上移动1像素，黄盒子也要跟随) small.onmousemove = function (event) { //新五步 event = event || window.event; //想要移动黄盒子，必须要知道鼠标在small小图中的位置。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; //x：mask的left值，y：mask的top值。 var x = pagex - box.offsetLeft - mask.offsetWidth / 2; //除以2，可以保证鼠标mask的中间 var y = pagey - box.offsetTop - mask.offsetHeight / 2; //限制换盒子的范围 //left取值为大于0，小盒子的宽-mask的宽。 if (x \u0026lt; 0) { x = 0; } if (x \u0026gt; small.offsetWidth - mask.offsetWidth) { x = small.offsetWidth - mask.offsetWidth; } //top同理。 if (y \u0026lt; 0) { y = 0; } if (y \u0026gt; small.offsetHeight - mask.offsetHeight) { y = small.offsetHeight - mask.offsetHeight; } //移动黄盒子 console.log(small.offsetHeight); mask.style.left = x + \u0026#34;px\u0026#34;; mask.style.top = y + \u0026#34;px\u0026#34;; //3.右侧的大图片，等比例移动。 //如何移动大图片？等比例移动。 // 大图片/大盒子 = 小图片/mask盒子 // 大图片走的距离/mask走的距离 = （大图片-大盒子）/（小图片-黄盒子） // var bili = (bigImg.offsetWidth-big.offsetWidth)/(small.offsetWidth-mask.offsetWidth); //大图片走的距离/mask盒子都的距离 = 大图片/小图片 var bili = bigImg.offsetWidth / small.offsetWidth; var xx = bili * x; //知道比例，就可以移动大图片了 var yy = bili * y; bigImg.style.marginTop = -yy + \u0026#34;px\u0026#34;; bigImg.style.marginLeft = -xx + \u0026#34;px\u0026#34;; } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;small\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/001.jpg\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;mask\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;big\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/0001.jpg\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）tools.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Created by smyhvae on 2018/02/03. */ //显示和隐藏 function show(ele) { ele.style.display = \u0026#34;block\u0026#34;; } function hide(ele) { ele.style.display = \u0026#34;none\u0026#34;; } function scroll() { // 开始封装自己的scrollTop if (window.pageYOffset != null) { // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return { left: window.pageXOffset, top: window.pageYOffset } } else if (document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { // 标准浏览器 来判断有没有声明DTD return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop } } return { // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop } } 效果演示：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/39-%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%91%E5%AE%9A%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1event/","summary":"绑定事件的两种方式/DOM事件的级别 我们在之前的一篇文章《04-JavaScript/22-DOM简介和DOM操作》中已经讲过事件的概念。这","title":"39-事件的绑定和事件对象Event"},{"content":"DOM事件流 事件传播的三个阶段是：事件捕获、事件冒泡和目标。\n事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。\n事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。\n事件冒泡阶段：事件从事件目标 target 开始，从子元素往冒泡祖先元素冒泡，直到页面的最上一级标签。\n如下图所示：\nPS：这个概念类似于 Android 里的 touch 事件传递。\n事件捕获 addEventListener可以捕获事件：\n1 2 3 box1.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 box3\u0026#34;); }, true); 上面的方法中，参数为true，代表事件在捕获阶段执行。\n代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //参数为true，代表事件在「捕获」阶段触发；参数为false或者不写参数，代表事件在「冒泡」阶段触发 box3.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 child\u0026#34;); }, true); box2.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 father\u0026#34;); }, true); box1.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 grandfather\u0026#34;); }, true); document.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 body\u0026#34;); }, true); 效果演示：\n（如果上面的图片打不开，请点击：http://img.smyhvae.com/20180204_1101.gif）\n重点：捕获阶段，事件依次传递的顺序是：window \u0026ndash;\u0026gt; document \u0026ndash;\u0026gt; html\u0026ndash;\u0026gt; body \u0026ndash;\u0026gt; 父元素、子元素、目标元素。\n这几个元素在事件捕获阶段的完整写法是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 window.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 window\u0026#34;); }, true); document.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 document\u0026#34;); }, true); document.documentElement.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 html\u0026#34;); }, true); document.body.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 body\u0026#34;); }, true); fatherBox.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 father\u0026#34;); }, true); childBox.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 child\u0026#34;); }, true); 说明：\n（1）第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。\n（2）JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩是最先获取到事件的。\n补充一个知识点：\n在 js中：\n如果想获取 html节点，方法是document.documentElement。\n如果想获取 body 节点，方法是：document.body。\n二者不要混淆了。\n事件冒泡 事件冒泡: 当一个元素上的事件被触发的时候（比如说鼠标点击了一个按钮），同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。\n通俗来讲，冒泡指的是：子元素的事件被触发时，父元素的同样的事件也会被触发。取消冒泡就是取消这种机制。\n代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //事件冒泡 box3.onclick = function () { alert(\u0026#34;child\u0026#34;); } box2.onclick = function () { alert(\u0026#34;father\u0026#34;); } box1.onclick = function () { alert(\u0026#34;grandfather\u0026#34;); } document.onclick = function () { alert(\u0026#34;body\u0026#34;); } （如果上面的图片打不开，请点击：http://img.smyhvae.com/20180204_1028.gif）\n上图显示，当我点击子元素 box3 的时候，它的父元素box2、box1、body都依次被触发了。即使我改变代码的顺序，也不会影响效果的顺序。\n当然，上面的代码中，我们用 addEventListener 这种 DOM2的写法也是可以的，但是第三个参数要写 false，或者不写。\n冒泡顺序：\n一般的浏览器: （除IE6.0之外的浏览器）\ndiv -\u0026gt; body -\u0026gt; html -\u0026gt; document -\u0026gt; window IE6.0：\ndiv -\u0026gt; body -\u0026gt; html -\u0026gt; document 不是所有的事件都能冒泡 以下事件不冒泡：blur、focus、load、unload、onmouseenter、onmouseleave。意思是，事件不会往父元素那里传递。\n我们检查一个元素是否会冒泡，可以通过事件的以下参数：\n1 event.bubbles 如果返回值为true，说明该事件会冒泡；反之则相反。\n举例：\n1 2 3 4 5 6 box1.onclick = function (event) { alert(\u0026#34;冒泡 child\u0026#34;); event = event || window.event; console.log(event.bubbles); //打印结果：true。说明 onclick 事件是可以冒泡的 } 阻止冒泡 大部分情况下，冒泡都是有益的。当然，如果你想阻止冒泡，也是可以的。可以按下面的方法阻止冒泡。\n阻止冒泡的方法 w3c的方法：（火狐、谷歌、IE11）\n1 event.stopPropagation(); IE10以下则是：\n1 event.cancelBubble = true 兼容代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 box3.onclick = function (event) { alert(\u0026#34;child\u0026#34;); //阻止冒泡 event = event || window.event; if (event \u0026amp;\u0026amp; event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } } 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。\n阻止冒泡的举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #box1 { width: 100px; height: 100px; background-color: red; /* * 开启box1的绝对定位 */ position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function() { /* * 使div可以跟随鼠标移动 */ //获取box1 var box1 = document.getElementById(\u0026#39;box1\u0026#39;); //给整个页面绑定：鼠标移动事件 document.onmousemove = function(event) { //兼容的方式获取event对象 event = event || window.event; // 鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; // 设置div的偏移量（相对于整个页面） // 注意，如果想通过 style.left 来设置属性，一定要给 box1 开启绝对定位。 box1.style.left = pagex + \u0026#39;px\u0026#39;; box1.style.top = pagey + \u0026#39;px\u0026#39;; }; // 【重要注释】 // 当 document.onmousemove 和 box2.onmousemove 同时触发时，通过 box2 阻止事件向 document 冒泡。 // 也就是说，只要是在 box2 的区域，就只触发 document.onmousemove 事件 var box2 = document.getElementById(\u0026#39;box2\u0026#39;); box2.onmousemove = function(event) { //阻止冒泡 event = event || window.event; if (event \u0026amp;\u0026amp; event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } }; }; // scroll 函数封装 function scroll() { return { //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft, }; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;height: 1000px;width: 2000px;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;box2\u0026#34; style=\u0026#34;width: 300px; height: 300px; background-color: #bfa;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 关键地方可以看代码中的注释。\n效果演示：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/40-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/","summary":"DOM事件流 事件传播的三个阶段是：事件捕获、事件冒泡和目标。 事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 ta","title":"40-事件的传播和事件冒泡"},{"content":"事件委托 事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown\u0026hellip;\u0026hellip;）的函数委托到另一个元素。\n比如说有一个列表 ul，列表之中有大量的列表项 \u0026lt;a\u0026gt;标签：\n1 2 3 4 5 \u0026lt;ul id=\u0026#34;parent-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;my_link\u0026#34;\u0026gt;超链接一\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;my_link\u0026#34;\u0026gt;超链接二\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;my_link\u0026#34;\u0026gt;超链接三\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 当我们的鼠标移到\u0026lt;a\u0026gt;标签上的时候，需要获取此\u0026lt;a\u0026gt;的相关信息并飘出悬浮窗以显示详细信息，或者当某个\u0026lt;a\u0026gt;被点击的时候需要触发相应的处理事件。我们通常的写法，是为每个\u0026lt;a\u0026gt;都绑定类似onMouseOver或者onClick之类的事件监听：\n1 2 3 4 5 6 7 8 9 10 window.onload = function(){ var parentNode = document.getElementById(\u0026#34;parent-list\u0026#34;); var aNodes = parentNode.getElementByTagName(\u0026#34;a\u0026#34;); for(var i=0, l = aNodes.length; i \u0026lt; l; i++){ aNodes[i].onclick = function() { console.log(\u0026#39;我是超链接 a 的单击相应函数\u0026#39;); } } } 但是，上面的做法过于消耗内存和性能。我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后来添加的。\n因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件函数的时候再去匹配判断目标元素。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function() { // 获取父节点，并为它绑定click单击事件。 false 表示事件在冒泡阶段触发（默认） document.getElementById(\u0026#39;parent-list\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function(event) { event = event || window.event; // e.target 表示：触发事件的对象 //如果触发事件的对象是我们期望的元素，则执行否则不执行 if (event.target \u0026amp;\u0026amp; event.target.className == \u0026#39;link\u0026#39;) { // 或者写成 if (event.target \u0026amp;\u0026amp; event.target.nodeName.toUpperCase() == \u0026#39;A\u0026#39;) { console.log(\u0026#39;我是ul的单击响应函数\u0026#39;); } }, false); }; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;parent-list\u0026#34; style=\u0026#34;background-color: #bfa;\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;我是p元素\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;link\u0026#34;\u0026gt;超链接一\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;link\u0026#34;\u0026gt;超链接二\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;link\u0026#34;\u0026gt;超链接三\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; 上方代码，为父节点注册 click 事件，当子节点被点击的时候，click事件会从子节点开始向父节点冒泡。父节点捕获到事件之后，开始执行方法体里的内容：通过判断 event.target 拿到了被点击的子节点\u0026lt;a\u0026gt;。从而可以获取到相应的信息，并作处理。\n换而言之，参数为false，说明事件是在冒泡阶段触发（子元素向父元素传递事件）。而父节点注册了事件函数，子节点没有注册事件函数，此时，会在父节点中执行函数体里的代码。\n总结：事件委托是利用了冒泡机制，减少了事件绑定的次数，减少内存消耗，提高性能。\n事件委托的参考链接：\n荐 | JavaScript事件代理和委托（Delegation）\nJavaScript 事件委托详解\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/41-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","summary":"事件委托 事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown\u0026hellip;\u0026hellip;）的函数委托到另一个元素。 比","title":"41-事件委托"},{"content":"鼠标的拖拽事件 拖拽的流程：\n（1）onmousedown：当鼠标在被拖拽元素上按下时，开始拖拽；\n（2）onmousemove：当鼠标移动时被拖拽元素跟随鼠标移动；\n（3）onmouseup：当鼠标松开时，被拖拽元素固定在当前位置。\n鼠标的滚轮事件 onmousewheel：鼠标滚轮滚动的事件，会在滚轮滚动时触发。但是火狐不支持该属性。\nDOMMouseScroll：在火狐中需要使用 DOMMouseScroll 来绑定滚动事件。注意该事件需要通过addEventListener()函数来绑定。\n键盘事件 事件名 onkeydown：按键被按下。\nonkeyup：按键被松开。\n注意：\n如果一直按着某一个按键不松手，那么，onkeydown事件会一直触发。此时，松开键盘，onkeyup事件会执行一次。\n当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，后续的间隔会非常快。这种设计是为了防止误操作的发生。\n键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document。代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.onkeydown = function(event) { event = event || window.event; console.log(\u0026#39;qianguyihao 键盘按下了\u0026#39;); }; document.onkeyup = function() { console.log(\u0026#39;qianguyihao 键盘松开了\u0026#39;); }; \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; 判断哪个键盘被按下 可以通过event事件对象的keyCode来获取按键的编码。\n此外，event事件对象里面还提供了以下几个属性：\naltKey\nctrlKey\nshiftKey\n上面这三个属性，可以用来判断alt、ctrl、和shift是否被按下。如果按下则返回true，否则返回false。代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.onkeydown = function(event) { event = event || window.event; console.log(\u0026#39;qianguyihao：键盘按下了\u0026#39;); // 判断y和ctrl是否同时被按下 if (event.ctrlKey \u0026amp;\u0026amp; event.keyCode === 89) { console.log(\u0026#39;ctrl和y都被按下了\u0026#39;); } }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 举例：input 文本框中，禁止输入数字。代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; //获取input var input = document.getElementsByTagName(\u0026#39;input\u0026#39;)[0]; input.onkeydown = function(event) { event = event || window.event; //console.log(\u0026#39;qianguyihao:\u0026#39; + event.keyCode); //数字 48 - 57 //使文本框中不能输入数字 if (event.keyCode \u0026gt;= 48 \u0026amp;\u0026amp; event.keyCode \u0026lt;= 57) { //在文本框中输入内容，属于onkeydown的默认行为 return false; // 如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 } }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 举例：通过键盘的方向键，移动盒子 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #box1 { width: 100px; height: 100px; background-color: red; position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 使div可以根据不同的方向键向不同的方向移动 /* * 按左键，div向左移 * 按右键，div向右移 * ... */ //为document绑定一个按键按下的事件 document.onkeydown = function(event) { event = event || window.event; //定义一个变量，来表示移动的速度 var speed = 10; //当用户按了ctrl以后，速度加快 if (event.ctrlKey) { console.log(\u0026#39;smyhvae ctrl\u0026#39;); speed = 20; } /* * 37 左 * 38 上 * 39 右 * 40 下 */ switch (event.keyCode) { case 37: //alert(\u0026#34;向左\u0026#34;); left值减小 box1.style.left = box1.offsetLeft - speed + \u0026#39;px\u0026#39;; // 在初始值的基础之上，减去 speed 大小 break; case 39: //alert(\u0026#34;向右\u0026#34;); box1.style.left = box1.offsetLeft + speed + \u0026#39;px\u0026#39;; break; case 38: //alert(\u0026#34;向上\u0026#34;); box1.style.top = box1.offsetTop - speed + \u0026#39;px\u0026#39;; break; case 40: //alert(\u0026#34;向下\u0026#34;); box1.style.top = box1.offsetTop + speed + \u0026#39;px\u0026#39;; break; } }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码，待改进的地方：\n（1）移动盒子时，如果要加速，需要先按方向键，再按Ctrl键。\n（2）首次移动盒子时，动作较慢。后续如果学习了定时器相关的内容，可以再改进。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/42-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/","summary":"鼠标的拖拽事件 拖拽的流程： （1）onmousedown：当鼠标在被拖拽元素上按下时，开始拖拽； （2）onmousemove：当鼠标移动时被拖","title":"42-键盘事件"},{"content":"常见概念 JavaScript的组成 JavaScript基础分为三个部分：\nECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。\nDOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。\nBOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。\n常见的 BOM 对象 BOM可以让我们通过JS来操作浏览器。BOM中为我们提供了一些对象，来完成对浏览器相关的操作。\n常见的 BOM对象有：\nWindow：代表整个浏览器的窗口，同时 window 也是网页中的全局对象。\nNavigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。\nLocation：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。\nHistory：代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。\nScreen：代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。\n备注：这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 window.location.href，也可以直接使用 location.href，二者是等价的。\n备注2：不要忘了，之前学习过的document也是在window中保存的。\n这篇文章，我们先来讲一下 几个常见的 BOM 对象。\nNavigator 和 navigator.userAgent Navigator代表当前浏览器的信息，通过该对象可以识别不同的浏览器。\n由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。\n一般我们只会使用navigator.userAgent来获取浏览器的信息。\nuserAgent 的值是一个字符串，简称 UA，这个字符串中包含了用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent。\n代码举例：（获取当前浏览器的UA）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var ua = navigator.userAgent; // 获取当前浏览器的 userAgent console.log(\u0026#39;qianguyihao 当前浏览器的UA是：\u0026#39; + ua); if (/firefox/i.test(ua)) { alert(\u0026#39;是火狐浏览器\u0026#39;); } else if (/chrome/i.test(ua)) { alert(\u0026#39;是Chrome浏览器\u0026#39;); } else if (/msie/i.test(ua)) { alert(\u0026#39;是IE浏览器\u0026#39;); } else if (\u0026#39;ActiveXObject\u0026#39; in window) { alert(\u0026#39;是 IE11 浏览器\u0026#39;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在电脑上模拟移动端浏览器 不同浏览器（包括微信内置的浏览器）的 userAgent 信息，是不一样的，我们可以根据 navigator.userAgent属性来获取。\n比如说，我们在电脑浏览器上，按F12，然后在控制台输入navigator.userAgent，如下：\n上图显示，MacOS上的Chrome浏览器的 userAgent 是：\n1 \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36\u0026#34; 我们还可以在电脑浏览器的控制台里可以添加很多设备，通过这种方式，可以模拟移动端浏览器的场景，非常有用，请务必掌握。操作如下：\n（1）需要点击 edit，手动添加：\n（2）添加时，根据 User agent 来识别不同的浏览器：\n不同浏览器的 userAgent iOS 版微信浏览器：\n1 Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E233 MicroMessenger/6.3.15 NetType/WIFI Language/zh_CN Android 版微信浏览器：\n1 Mozilla/5.0 (Linux; Android 5.0.1; GT-I9502 Build/LRX22C; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/43.0.2357.121 Mobile Safari/537.36 MicroMessenger/6.1.0.78_r1129455.543 NetType/WIFI iOS 版本QQ浏览器：\n1 Mozilla/5.0 (iPhone; CPU iPhone OS 11_2_2 like Mac OS X) AppleWebKit/604.4.7 (KHTML, like Gecko) Mobile/15C202 QQ/7.3.5.473 V1_IPH_SQ_7.3.5_1_APP_A Pixel/1125 Core/UIWebView Device/Apple(iPhone X) NetType/WIFI QBWebViewType/1 Android 版 QQ浏览器：\n1 Mozilla/5.0 (Linux; Android 4.4.2; PE-TL20 Build/HuaweiPE-TL20; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/043807 Mobile Safari/537.36 V1_AND_SQ_7.3.2_762_YYB_D QQ/7.3.2.3350 NetType/WIFI WebP/0.3.0 Pixel/1080 参考链接：\n微信、QQ在Android和iOS的UserAgent\n判断微信内置浏览器的UserAgent\n微信内置浏览器UserAgent的判断\nHistory 对象 History对象：可以用来操作浏览器的向前或向后翻页。\nHistory对象的属性 1 history.length 解释：获取浏览器历史列表中的 url 数量。注意，只是统计当次的数量，如果浏览器关了，数量会重置为1。\nHistory对象的方法 方法1：\n1 history.back(); 解释：用来回退到上一个页面，作用和浏览器的「回退按钮」一样。\n方法2：\n1 history.forward(); 解释：用来跳转下一个页面，作用和浏览器的「前进按钮」一样。\n方法3：\n1 2 3 4 5 6 7 8 9 10 11 12 history.go( int n); // 需要整数作为参数 // 代码举例： history.go( 1 ); // 向前跳转一个页面，相当于 history.forward() history.go( 2 ); // 表示向前跳转两个页面 history.go( 0 ); // 刷新当前页面 history.go( -1 ); // 向后跳转一个页面，相当于 history.back() history.go( -2 ); // 向后跳转两个页面 解释：向前/向后跳转 n 个页面。\n备注：浏览器的前进按钮、后退按钮，在这个位置：\nLocation 对象 Location 对象：封装了浏览器地址栏的 URL 信息。\n下面介绍一些常见的属性和方法。\nLocation 对象的属性 属性1：\n1 2 3 location.href location.href = \u0026#39;https://xxx\u0026#39;; 解释：获取当前页面的 url 路径（或者设置 url 路径）。\n代码举例1：\n1 console.log(location.href); // 获取当前页面的url 路径 代码举例2：\n1 location.href = \u0026#39;www.baidu.com\u0026#39;; // 跳转到指定的页面链接。通俗理解就是：跳转到其他的页面 从上方的举例2中可以看出：如果直接将location.href属性修改为一个绝对路径（或相对路径），则页面会自动跳转到该路径，并生成相应的历史记录。\nLocation 对象的方法 方法1：\n1 location.assign(str); 解释：用来跳转到其他的页面，作用和直接修改location.href一样。\n方法2：\n1 location.reload(); 解释：用于重新加载当前页面，作用和刷新按钮一样。\n代码举例：\n1 2 location.reload(); // 重新加载当前页面。 location.reload(true); // 在方法的参数中传递一个true，则会强制清空缓存刷新页面。 方法3：\n1 2 location.replace(); 解释：使用一个新的页面替换当前页面，调用完毕也会跳转页面。但不会生成历史记录，不能使用「后退按钮」后退。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/43-bom%E7%AE%80%E4%BB%8B%E5%92%8Cnavigator.useragenthistorylocation/","summary":"常见概念 JavaScript的组成 JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达","title":"43-BOM简介和navigator.userAgent\u0026History\u0026Location"},{"content":"定时器的常见方法 setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行）\nsetTimeout()：延时调用。将一段代码，等待一段时间之后再执行。（只执行一次）\n备注：在实际开发中，二者是可以根据需要，互相替代的。\nsetInterval() 的使用 setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行）\n参数：\n参数1：回调函数，该函数会每隔一段时间被调用一次。\n参数2：每次调用的间隔时间，单位是毫秒。\n返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。\n定义定时器 方式一：匿名函数\n每间隔一秒，将 数字 加1：\n1 2 3 4 5 let num = 1; setInterval(function () { num ++; console.log(num); }, 1000); 方式二：\n每间隔一秒，将 数字 加1：\n1 2 3 4 5 6 setInterval(fn,1000); function fn() { num ++; console.log(num); } 清除定时器 定时器的返回值是作为这个定时器的唯一标识，可以用来清除定时器。具体方法是：假设定时器setInterval()的返回值是参数1，那么clearInterval(参数1)就可以清除定时器。\nsetTimeout()的道理是一样的。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; let num = 1; const timer = setInterval(function () { console.log(num); //每间隔一秒，打印一次num的值 num ++; if(num === 5) { //打印四次之后，就清除定时器 clearInterval(timer); } }, 1000); \u0026lt;/script\u0026gt; setTimeout() 的使用 setTimeout()：延时调用。将一段代码，等待一段时间之后再执行。（只执行一次）\n参数：\n参数1：回调函数，该函数会每隔一段时间被调用一次。\n参数2：每次调用的间隔时间，单位是毫秒。\n返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。\n定义和清除定时器 代码举例：\n1 2 3 4 5 const timer = setTimeout(function() { console.log(1); // 3秒之后，再执行这段代码。 }, 3000); clearTimeout(timer); 代码举例：（箭头函数写法）\n1 2 3 setTimeout(() =\u0026gt; { console.log(1); // 3秒之后，再执行这段代码。 }, 3000); setTimeout() 举例：5秒后关闭网页两侧的广告栏 假设网页两侧的广告栏为两个img标签，它们的样式为：\n1 2 3 4 5 \u0026lt;style\u0026gt; ... ... \u0026lt;/style\u0026gt; 5秒后关闭广告栏的js代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; window.onload = function () { //获取相关元素 var imgArr = document.getElementsByTagName(\u0026#34;img\u0026#34;); //设置定时器：5秒后关闭两侧的广告栏 setTimeout(fn,5000); function fn(){ imgArr[0].style.display = \u0026#34;none\u0026#34;; imgArr[1].style.display = \u0026#34;none\u0026#34;; } } \u0026lt;/script\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/44-%E5%AE%9A%E6%97%B6%E5%99%A8/","summary":"定时器的常见方法 setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行） setTimeout()：延时调用。将一","title":"44-定时器"},{"content":" 本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。\n以下是正文。\nBOM的介绍 JavaScript的组成 JavaScript基础分为三个部分：\nECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。\nDOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。\nBOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。\n什么是BOM BOM：Browser Object Model，浏览器对象模型。\nBOM的结构图：\n从上图也可以看出：\nwindow对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的，也可以称为window的子对象。\nDOM越是BOM的一部分。\nwindow对象：\nwindow对象是JavaScript中的顶级对象。\n全局变量、自定义函数也是window对象的属性和方法。\nwindow对象下的属性和方法调用时，可以省略window。\n下面讲一下 BOM 的常见内置方法和内置对象。\n弹出系统对话框 比如说，alert(1)是window.alert(1)的简写，因为它是window的子方法。\n系统对话框有三种：\n1 2 3 alert();\t//不同浏览器中的外观是不一样的 confirm(); //兼容不好 prompt();\t//不推荐使用 打开窗口、关闭窗口 1、打开窗口：\n1 window.open(url,target,param) 参数解释：\nurl：要打开的地址。\ntarget：新窗口的位置。可以是：_blank 、_self、 _parent 父框架。\nparam：新窗口的一些设置。\n返回值：新窗口的句柄。\nparam这个参数，可以填各种各样的参数（），比如：\nname：新窗口的名称，可以为空\nfeatures：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。\nfullscreen= { yes/no/1/0 } 是否全屏，默认no\nchannelmode= { yes/no/1/0 } 是否显示频道栏，默认no\ntoolbar= { yes/no/1/0 } 是否显示工具条，默认no\nlocation= { yes/no/1/0 } 是否显示地址栏，默认no。（有的浏览器不一定支持）\ndirectories = { yes/no/1/0 } 是否显示转向按钮，默认no\nstatus= { yes/no/1/0 } 是否显示窗口状态条，默认no\nmenubar= { yes/no/1/0 } 是否显示菜单，默认no\nscrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes\nresizable= { yes/no/1/0 } 是否窗口可调整大小，默认no\nwidth=number 窗口宽度（像素单位）\nheight=number 窗口高度（像素单位）\ntop=number 窗口离屏幕顶部距离（像素单位）\nleft=number 窗口离屏幕左边距离（像素单位）\n各个参数之间用逗号隔开就行，但我们最好是把它们统一放到json里。\n2、关闭窗口：window.close()\n（1）和（2）的代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;点击我打开一个新的页面\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;点击我关闭本页面\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; //新窗口 = window.open(地址,是否开新窗口,新窗口的各种参数); var a1 = document.getElementsByTagName(\u0026#34;a\u0026#34;)[0]; var a2 = document.getElementsByTagName(\u0026#34;a\u0026#34;)[1]; a1.onclick = function () { //举例1： window.open(\u0026#34;http://www.jx.com\u0026#34;,\u0026#34;_blank\u0026#34;); var json = { \u0026#34;name\u0026#34;: \u0026#34;helloworld\u0026#34;, \u0026#34;fullscreen\u0026#34;: \u0026#34;no\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;no\u0026#34;, \u0026#34;width\u0026#34;: \u0026#34;100px\u0026#34;, \u0026#34;height\u0026#34;: \u0026#34;100px\u0026#34;, \u0026#34;top\u0026#34;: \u0026#34;100px\u0026#34;, \u0026#34;left\u0026#34;: \u0026#34;100px\u0026#34; }; window.open(\u0026#34;http://www.baidu.com\u0026#34;, \u0026#34;_blank\u0026#34;, json); //举例2 } //关闭本页面 a2.onclick = function () { window.close(); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3、新窗口相关：\n新窗口.moveTo(5,5)\n新窗口.moveBy()\n新窗口.resizeTo()\nwindow.resizeBy()\n代码举例：\n1 2 var newWin = window.open(\u0026#34;demo.html\u0026#34;, \u0026#34;_blank\u0026#34;, json); newWin.moveTo(500, 500); location对象 window.location可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。\nlocation对象的属性 href：跳转\nhash 返回url中#后面的内容，包含#\nhost 主机名，包括端口\nhostname 主机名\npathname url中的路径部分\nprotocol 协议 一般是http、https\nsearch\t查询字符串\nlocation.href属性举例：\n**举例1：**点击盒子时，进行跳转。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;smyhvae\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div.onclick = function () { location.href = \u0026#34;http://www.baidu.com\u0026#34;; //点击div时，跳转到指定链接 // window.open(\u0026#34;http://www.baidu.com\u0026#34;,\u0026#34;_blank\u0026#34;); //方式二 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 举例2：5秒后自动跳转到百度。\n有时候，当我们访问一个不存在的网页时，会提示5秒后自动跳转到指定页面，此时就可以用到location。举例：\n1 2 3 4 5 6 \u0026lt;script\u0026gt; setTimeout(function () { location.href = \u0026#34;http://www.baidu.com\u0026#34;; }, 5000); \u0026lt;/script\u0026gt; location对象的方法 location.assign()：改变浏览器地址栏的地址，并记录到历史中 设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。\nlocation.replace()：替换浏览器地址栏的地址，不会记录到历史中\nlocation.reload()：重新加载\nnavigator对象 window.navigator 的一些属性可以获取客户端的一些信息。\nuserAgent：系统，浏览器)\nplatform：浏览器支持的系统，win/mac/linux\n举例：\n1 2 console.log(navigator.userAgent); console.log(navigator.platform); 效果如下：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/bom%E7%9A%84%E5%B8%B8%E8%A7%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/","summary":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 BOM的介绍 Ja","title":"BOM的常见内置方法和内置对象"},{"content":"call()和apply() 介绍 这两个方法都是函数对象的方法，需要通过函数对象来调用。\n当函数调用call()和apply()时，函数都会立即执行。\n都可以用来改变函数的this对象的指向。\n第一个参数都是this要指向的对象（函数执行时，this将指向这个对象），后续参数用来传实参。\n显式绑定this JS提供的绝大多数函数以及我们自己创建的所有函数，都可以使用call 和apply方法。\n它们的第一个参数是一个对象。因为你可以直接指定 this 绑定的对象，因此我们称之为显式绑定。\n例1：\n1 2 3 4 5 6 7 8 9 10 function foo() { console.log(this.a); } var obj = { a: 2 }; // 将 this 指向 obj foo.apply(obj); //打印结果：2 第一个参数的传递 1、thisObj不传或者为null、undefined时，函数中的this会指向window对象（非严格模式）。\n2、传递一个别的函数名时，函数中的this将指向这个函数的引用。\n3、传递的值为数字、布尔值、字符串时，this会指向这些基本类型的包装对象Number、Boolean、String。\n4、传递一个对象时，函数中的this则指向传递的这个对象。\ncall()和apply()的区别 call()和apply()方法都可以将实参在对象之后依次传递，但是apply()方法需要将实参封装到一个数组中统一传递（即使只有实参只有一个，也要放到数组中）。\n比如针对下面这样的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var persion1 = { name: \u0026#34;小王\u0026#34;, gender: \u0026#34;男\u0026#34;, age: 24, say: function (school, grade) { alert(this.name + \u0026#34; , \u0026#34; + this.gender + \u0026#34; ,今年\u0026#34; + this.age + \u0026#34; ,在\u0026#34; + school + \u0026#34;上\u0026#34; + grade); } } var person2 = { name: \u0026#34;小红\u0026#34;, gender: \u0026#34;女\u0026#34;, age: 18 } 如果是通过call的参数进行传参，是这样的：\n1 persion1.say.call(persion2, \u0026#34;实验小学\u0026#34;, \u0026#34;六年级\u0026#34;); 如果是通过apply的参数进行传参，是这样的：\n1 persion1.say.apply(persion2, [\u0026#34;实验小学\u0026#34;, \u0026#34;六年级\u0026#34;]); 看到区别了吗，call后面的实参与say方法中是一一对应的，而apply传实参时，要封装成一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。\ncall()和apply()的作用 改变this的指向\n实现继承。Father.call(this)\nbind() 都能改变this的指向\ncall()/apply()是立即调用函数\nbind()是将函数返回，因此后面还需要加()才能调用。\nbind()传参的方式与call()相同。\n参考链接：\nhttps://www.jianshu.com/p/56a9c2d11adc\nhttps://github.com/lin-xin/blog/issues/7\nhttps://segmentfault.com/a/1190000007402815\nJS中改变this指向的方法\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/callapplybind%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"call()和apply() 介绍 这两个方法都是函数对象的方法，需要通过函数对象来调用。 当函数调用call()和apply()时，函数都会立即","title":"call、apply、bind的区别"},{"content":" title: \u0026ldquo;HelloWorld\u0026rdquo; date: 2022-11-22T17:11:35+08:00 draft: true 控制台的使用 控制台查看源码 控制台的Sources标签可以查看源码。按住快捷键「cmd + P」，可以根据文件名查找源码文件。\n其他 show user agent shadow DOM 把上图中的红框部分打钩。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/06-chrome%E6%B5%8F%E8%A7%88%E5%99%A8/","summary":"title: \u0026ldquo;HelloWorld\u0026rdquo; date: 2022-11-22T17:11:35+08:00 draft: true 控制台的使用 控制台查看源码 控制台的Sources标签可以查看源码。按住快捷键「cmd + P」，可以根据文件名查找源码文件。 其他 show user","title":"chrome浏览器"},{"content":"全局对象 global 类似于客户端 JavaScript 运行环境中的 window。\nprocess 用于获取当前的 Node 进程信息，一般用于获取环境变量之类的信息。\nconsole Node 中内置的 console 模块，提供操作控制台的输入输出功能，常见使用方式与客户端类似。\n全局函数 setInterval(callback, millisecond)\nclearInterval(timer)\nsetTimeout(callback, millisecond)\nclearTimeout(timer)\nBuffer：Class\n用于操作二进制数据 以后介绍 Node 调试 最简单的调试 最方便也是最简单的调试：console.log()\nNode 原生的调试 网址：https://nodejs.org/api/debugger.html\n第三方模块提供的调试工具 1 2 3 4 $ npm install node-inspector –g //方式一 $ npm install devtool -g //方式二 开发工具的调试 Visual Studio Code\nWebStorm\n模块化结构 Node 实现 CommonJS 规范，所以可以使用模块化的方式组织代码结构。\nNode 采用的模块化结构是按照 CommonJS 规范。\n模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。\nCommonJS 规范 CommonJS 就是一套约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。\n参考链接：\nhttp://wiki.commonjs.org/wiki/CommonJS 常用内置模块 path：处理文件路径。\nfs：操作（CRUD）文件系统。\nchild_process：新建子进程。\nutil：提供一系列实用小工具。\nhttp：提供 HTTP 服务器功能。\nurl：用于解析 URL。\nquerystring：解析 URL 中的查询字符串。\ncrypto：提供加密和解密功能。\n总结：更多内容可以参考 api文档：https://nodejs.org/api/\n文件系统操作 相关模块 fs：基础的文件操作 API\npath：提供和路径相关的操作 API\nreadline：用于读取大文本文件，一行一行读\nfs-extra（第三方）：https://www.npmjs.com/package/fs-extra\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/commonjs/","summary":"全局对象 global 类似于客户端 JavaScript 运行环境中的 window。 process 用于获取当前的 Node 进程信息，一般用于获取环境变量之类的信息。 console Node 中内置的 console 模块，提供操作控","title":"CommonJS"},{"content":"CSS display: none; 与 visibility: hidden; 的区别\n联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘 读屏器不会读取display: none;元素内容；会读取visibility: hidden元素内容 css hack原理及常用hack\n原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。 常见的hack有 属性hack 选择器hack IE条件注释 link 与 @import 的区别\nlink 是HTML方式， @import 是CSS方式 link 最大限度支持并行下载， @import 过多嵌套导致串行下载，出现FOUC link 可以通过 rel=\u0026quot;alternate stylesheet\u0026quot; 指定候选样式 浏览器对 link 支持早于 @import ，可以使用 @import 对老浏览器隐藏样式 @import 必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import CSS有哪些继承属性\n关于文字排版的属性如： font word-break letter-spacing text-align text-rendering word-spacing white-space text-indent text-transform text-shadow line-height color visibility cursor display,float,position的关系\n如果 display 为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 display 外边距折叠(collapsing margins)\n毗邻的两个或多个 margin 会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素或inline-block元素或绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n有两种， IE 盒子模型、W3C 盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？\nid选择器（ # myid）\n类选择器（.myclassname）\n标签选择器（div, h1, p）\n相邻选择器（h1 + p）\n子选择器（ul \u0026gt; li）\n后代选择器（li a）\n通配符选择器（ * ）\n属性选择器（a[rel = \u0026ldquo;external\u0026rdquo;]）\n伪类选择器（a:hover, li:nth-child）\n可继承的样式： font-size font-family color, UL LI DL DD DT\n不可继承的样式：border padding margin width height CSS优先级算法如何计算？\n优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important \u0026gt; id \u0026gt; class \u0026gt; tag important 比 内联优先级高 CSS3新增伪类有那些？\n1 2 3 4 5 6 7 8 9 10 11 p:first-of-type 选择属于其父元素的首个 \u0026lt;p\u0026gt; 元素的每个 \u0026lt;p\u0026gt; 元素。 p:last-of-type 选择属于其父元素的最后 \u0026lt;p\u0026gt; 元素的每个 \u0026lt;p\u0026gt; 元素。 p:only-of-type 选择属于其父元素唯一的 \u0026lt;p\u0026gt; 元素的每个 \u0026lt;p\u0026gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 \u0026lt;p\u0026gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 \u0026lt;p\u0026gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\n给div设置一个宽度，然后添加margin:0 auto属性 1 2 3 4 div{ width:200px; margin:0 auto; } 居中一个浮动元素 1 2 3 4 5 6 7 8 9 10 11 //确定容器的宽高 宽500 高 300 的层 //设置层的外边距 .div { width:500px ; height:300px;//高度可以不设 margin: -150px 0 0 -250px; position:relative; //相对定位 background-color:pink; //方便看效果 left:50%; top:50%; } 让绝对定位的div居中 1 2 3 4 5 6 7 8 position: absolute; width: 1200px; background: none; margin: 0 auto; top: 0; left: 0; bottom: 0; right: 0; display有哪些值？说明他们的作用\nblock 象块类型元素一样显示。 none 缺省值。象行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 position的值relative和absolute定位原点是？\nabsolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。 inherit 规定从父元素继承 position 属性的值 CSS3有哪些新特性？\n新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 增加了旋转,缩放,定位,倾斜,动画，多背景 transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation: 用纯CSS创建一个三角形的原理是什么？\n1 2 3 4 5 6 7 8 // 把上、左、右三条边隐藏掉（颜色设为 transparent） #demo { width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; } 一个满屏 品 字布局 如何设计?\n简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？\npng24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.\n浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一\nIE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;\nFirefox下,只能使用getAttribute()获取自定义属性。\n解决方法:统一通过getAttribute()获取自定义属性 IE下,even对象有x,y属性,但是没有pageX,pageY属性\nFirefox下,event对象有pageX,pageY属性,但是没有x,y属性\nli与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\n行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了 为什么要初始化CSS样式\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异 对BFC规范(块级格式化上下文：block formatting context)的理解？\n一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响 css定义的权重\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值： /*权重为1*/ div{ } /*权重为10*/ .class1{ } /*权重为100*/ #id1{ } /*权重为100+1=101*/ #id1 div{ } /*权重为10+1=11*/ .class1 div{ } /*权重为10+10+1=21*/ .class1 .class2 div{ } // 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 display:inline-block 什么时候会显示间隙？(携程)\n移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 谈谈浮动和清除浮动\n浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin) IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型) 标准(W3C)盒模型：元素宽度 = width + padding + border + margin 怪异(IE)盒模型：元素宽度 = width + margin 标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高 box-sizing 常用的属性有哪些？分别有什么作用？\nbox-sizing: content-box; // 默认的标准(W3C)盒模型元素效果 box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果 box-sizing: inherit; // 继承父元素 box-sizing 属性的值 CSS选择器有哪些？\nid选择器 #id 类选择器 .class 标签选择器 div, h1, p 相邻选择器 h1 + p 子选择器 ul \u0026gt; li 后代选择器 li a 通配符选择器 * 属性选择器 a[rel=\u0026lsquo;external\u0026rsquo;] 伪类选择器 a:hover, li:nth-child CSS哪些属性可以继承？哪些属性不可以继承？\n可以继承的样式：font-size、font-family、color、list-style、cursor 不可继承的样式：width、height、border、padding、margin、background CSS如何计算选择器优先？\n相同权重，定义最近者为准：行内样式 \u0026gt; 内部样式 \u0026gt; 外部样式 含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式 选择器优先级: 行内样式[1000] \u0026gt; id[100] \u0026gt; class[10] \u0026gt; Tag[1] 在同一组属性设置中，!important 优先级最高，高于行内样式 CSS3新增伪类有哪些？\n:root 选择文档的根元素，等同于 html 元素\n:empty 选择没有子元素的元素\n:target 选取当前活动的目标元素\n:not(selector) 选择除 selector 元素意外的元素\n:enabled 选择可用的表单元素\n:disabled 选择禁用的表单元素\n:checked 选择被选中的表单元素\n:after 在元素内部最前添加内容\n:before 在元素内部最后添加内容\n:nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n\n:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数\n:nth-child(odd)\n:nth-child(even)\n:nth-child(3n+1)\n:first-child\n:last-child\n:only-child\n:nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n\n:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数\n:nth-of-type(odd)\n:nth-of-type(even)\n:nth-of-type(3n+1)\n:first-of-type\n:last-of-type\n:only-of-type\n::selection 选择被用户选取的元素部分\n:first-line 选择元素中的第一行\n:first-letter 选择元素中的第一个字符\n请列举几种隐藏元素的方法\nvisibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在 opacity: 0; CSS3属性，设置0可以使一个元素完全透明 position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外 display: none; 元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留 \u0026lt;div hidden=\u0026quot;hidden\u0026quot;\u0026gt; HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态 height: 0; 将元素高度设为 0 ，并消除边框 filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中 rgba() 和 opacity 的透明效果有什么不同？\nopacity 作用于元素以及元素内的所有内容（包括文字）的透明度 rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果 css 属性 content 有什么作用？\ncontent 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式 CSS3有哪些新特性？\n新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)} 弹性盒模型 display: flex; 多列布局 column-count: 5; 媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}} 个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);} 颜色透明度 color: rgba(255, 0, 0, 0.75); 圆角 border-radius: 5px; 渐变 background:linear-gradient(red, green, blue); 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); 倒影 box-reflect: below 2px; 文字装饰 text-stroke-color: red; 文字溢出 text-overflow:ellipsis; 背景效果 background-size: 100px 100px; 边框效果 border-image:url(bt_blue.png) 0 10; 转换 旋转 transform: rotate(20deg); 倾斜 transform: skew(150deg, -10deg); 位移 transform: translate(20px, 20px); 缩放 transform: scale(.5); 平滑过渡 transition: all .3s ease-in .1s; 动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s; 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？\nFlexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？\n当前样式：getComputedStyle(el, null) VS el.currentStyle 事件对象：e VS window.event 鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y 按键码：e.which VS event.keyCode 文本节点：el.textContent VS el.innerText li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\nli排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔 解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小 什么是外边距重叠？ 重叠的结果是什么？\n外边距重叠就是 margin-collapse\n相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距\n折叠结果遵循下列计算规则：\n两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边距一正一负时，折叠结果是两者的相加的和 请写出多种等高布局\n在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像 模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行 css3 flexbox 布局： .container{display: flex; align-items: stretch;} css垂直居中的方法有哪些？\n如果是单行文本, line-height 设置成和 height 值 1 2 3 4 .vertical { height: 100px; line-height: 100px; } 已知高度的块级子元素，采用绝对定位和负边距 1 2 3 4 5 6 7 8 9 .container { position: relative; } .vertical { height: 300px; /*子元素高度*/ position: absolute; top:50%; /*父元素高度50%*/ margin-top: -150px; /*自身高度一半*/ } 未知高度的块级父子元素居中，模拟表格布局 缺点：IE67不兼容，父级 overflow：hidden 失效 1 2 3 4 5 6 7 .container { display: table; } .content { display: table-cell; vertical-align: middle; } 新增 inline-block 兄弟元素，设置 vertical-align 缺点：需要增加额外标签，IE67不兼容 1 2 3 4 5 6 7 8 9 10 11 .container { height: 100%;/*定义父级高度，作为参考*/ } .extra .vertical{ display: inline-block; /*行内块显示*/ vertical-align: middle; /*垂直居中*/ } .extra { height: 100%; /*设置新增元素高度为100%*/ } 绝对定位配合 CSS3 位移 1 2 3 4 5 .vertical { position: absolute; top:50%; /*父元素高度50%*/ transform:translateY(-50%, -50%); } CSS3弹性盒模型 1 2 3 4 5 .container { display:flex; justify-content: center; /*子元素水平居中*/ align-items: center; /*子元素垂直居中*/ } 圣杯布局的实现原理？\n要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽 好处：重要的内容放在文档流前面可以优先渲染 原理：利用相对定位、浮动、负边距布局，而不添加额外标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 .container { padding-left: 150px; padding-right: 190px; } .main { float: left; width: 100%; } .left { float: left; width: 190px; margin-left: -100%; position: relative; left: -150px; } .right { float: left; width: 190px; margin-left: -190px; position: relative; right: -190px; } 什么是双飞翼布局？实现原理？\n双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 .container { /*padding-left:150px;*/ /*padding-right:190px;*/ } .main-wrap { width: 100%; float: left; } .main { margin-left: 150px; margin-right: 190px; } .left { float: left; width: 150px; margin-left: -100%; /*position: relative;*/ /*left:-150px;*/ } .right { float: left; width: 190px; margin-left: -190px; /*position:relative;*/ /*right:-190px;*/ } 在CSS样式中常使用 px、em 在表现上有什么区别？\npx 相对于显示器屏幕分辨率，无法用浏览器字体放大功能 em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size 为什么要初始化CSS样式？\n不同浏览器对有些标签样式的默认值解析不同 不初始化CSS会造成各现浏览器之间的页面显示差异 可以使用 reset.css 或 Normalize.css 做 CSS 初始化 解释下什么是浮动和它的工作原理？\n非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。 工作原理： 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象） 浮动元素碰到包含它的边框或者其他浮动元素的边框停留 浮动元素引起的问题？\n父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素会跟随其后 列举几种清除浮动的方式？\n添加额外标签，例如 \u0026lt;div style=\u0026quot;clear:both\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 使用 br 标签和其自身的 clear 属性，例如 \u0026lt;br clear=\u0026quot;all\u0026quot; /\u0026gt; 父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1; 父元素也设置浮动 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout 清除浮动最佳实践（after伪元素闭合浮动）：\n1 2 3 4 5 6 7 8 9 .clearfix:after{ content: \u0026#34;\\200B\u0026#34;; display: table; height: 0; clear: both; } .clearfix{ *zoom: 1; } 什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？\n当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC 产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。 等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。 解决方法：使用 link 标签将样式表放在文档 head 介绍使用过的 CSS 预处理器？\nCSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等） 开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用 使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性 最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS CSS优化、提高性能的方法有哪些？\n多个css合并，尽量减少HTTP请求 将css文件放在页面最上面 移除空的css规则 避免使用CSS表达式 选择器优化嵌套，尽量避免层级过深 充分利用css继承属性，减少代码量 抽象提取公共样式，减少代码量 属性值为0时，不加单位 属性值为小于1的小数时，省略小数点前面的0 css雪碧图 浏览器是怎样解析CSS选择器的？\n浏览器解析 CSS 选择器的方式是从右到左 在网页中的应该使用奇数还是偶数的字体？\n在网页中的应该使用“偶数”字体： 偶数字号相对更容易和 web 设计的其他部分构成比例关系 使用奇数号字体时文本段落无法对齐 宋体的中文网页排布中使用最多的就是 12 和 14 margin和padding分别适合什么场景使用？\n需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding 抽离样式模块怎么写，说出思路？\nCSS可以拆分成2部分：公共CSS 和 业务CSS： 网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务 对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS 元素竖向的百分比设定是相对于容器的高度吗？\n元素竖向的百分比设定是相对于容器的宽度，而不是高度 全屏滚动的原理是什么？ 用到了CSS的那些属性？\n原理类似图片轮播原理，超出隐藏部分，滚动时显示 可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none; 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\n响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本 基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式 对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $(window).resize(function () { screenRespond(); }); screenRespond(); function screenRespond(){ var screenWidth = $(window).width(); if(screenWidth \u0026lt;= 1800){ $(\u0026#34;body\u0026#34;).attr(\u0026#34;class\u0026#34;, \u0026#34;w1800\u0026#34;); } if(screenWidth \u0026lt;= 1400){ $(\u0026#34;body\u0026#34;).attr(\u0026#34;class\u0026#34;, \u0026#34;w1400\u0026#34;); } if(screenWidth \u0026gt; 1800){ $(\u0026#34;body\u0026#34;).attr(\u0026#34;class\u0026#34;, \u0026#34;\u0026#34;); } } 什么是视差滚动效果，如何给每页做不同的动画？\n视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验\n一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的\n实现原理\n以 “页面滚动条” 作为 “视差动画进度条” 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果 a标签上四个伪类的执行顺序是怎么样的？\nlink \u0026gt; visited \u0026gt; hover \u0026gt; active\nL-V-H-A love hate 用喜欢和讨厌两个词来方便记忆 伪元素和伪类的区别和作用？\n伪元素 \u0026ndash; 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如： 1 2 3 4 p::before {content:\u0026#34;第一章：\u0026#34;;} p::after {content:\u0026#34;Hot!\u0026#34;;} p::first-line {background:red;} p::first-letter {font-size:30px;} 伪类 \u0026ndash; 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如： 1 2 a:hover {color: #FF00FF} p:first-child {color: red} ::before 和 :after 中双冒号和单冒号有什么区别？\n在 CSS 中伪类一直用 : 表示，如 :hover, :active 等 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法 如何修改Chrome记住密码后自动填充表单的黄色背景？\n产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=\u0026ldquo;off\u0026rdquo; 解决方案2：input:-webkit-autofill { background-color: transparent; } input [type=search] 搜索框右侧小图标如何美化？\n1 2 3 4 5 6 7 8 input[type=\u0026#34;search\u0026#34;]::-webkit-search-cancel-button{ -webkit-appearance: none; height: 15px; width: 15px; border-radius: 8px; background:url(\u0026#34;images/searchicon.png\u0026#34;) no-repeat 0 0; background-size: 15px 15px; } 网站图片文件，如何点击下载？而非点击预览？\n\u0026lt;a href=\u0026quot;logo.jpg\u0026quot; download\u0026gt;下载\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;logo.jpg\u0026quot; download=\u0026quot;网站LOGO\u0026quot; \u0026gt;下载\u0026lt;/a\u0026gt;\niOS safari 如何阻止“橡皮筋效果”？\n1 2 3 4 5 6 7 $(document).ready(function(){ var stopScrolling = function(event) { event.preventDefault(); } document.addEventListener(\u0026#39;touchstart\u0026#39;, stopScrolling, false); document.addEventListener(\u0026#39;touchmove\u0026#39;, stopScrolling, false); }); 你对 line-height 是如何理解的？\nline-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离 如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的 一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中 line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会 line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）\n带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px 百分比：将计算后的值传递给后代 设置元素浮动后，该元素的 display 值会如何变化？\n设置元素浮动后，该元素的 display 值自动变成 block 怎么让Chrome支持小于12px 的文字？\n1 2 3 4 5 .shrink{ -webkit-transform:scale(0.8); -o-transform:scale(1); display:inline-block; } 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）\n1 -webkit-font-smoothing: antialiased; font-style 属性 oblique 是什么意思？\nfont-style: oblique; 使没有 italic 属性的文字实现倾斜 如果需要手动写动画，你认为最小时间间隔是多久？\n16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s / 60 * 1000 ＝ 16.7ms display:inline-block 什么时候会显示间隙？\n相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距 非 inline-block 水平元素设置为 inline-block 也会有水平间距 可以借助 vertical-align:top; 消除垂直间隙 可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙 把 li 标签写到同一行可以消除垂直间隙，但代码可读性差 overflow: scroll 时不能平滑滚动的问题怎么处理？\n监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\n方案1： .sub { height: calc(100%-100px); } 方案2： .container { position:relative; } .sub { position: absolute; top: 100px; bottom: 0; } 方案3： .container { display:flex; flex-direction:column; } .sub { flex:1; } ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/css/","summary":"CSS display: none; 与 visibility: hidden; 的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visib","title":"CSS"},{"content":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面：\n基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。\nBFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。\n总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论\n接下来，我们把上面的六条，依次讲解。\n标准盒模型和IE盒子模型\n标准盒子模型：\nIE盒子模型：\n上图显示：\n在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：\nwidth和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别：\n在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。\nIE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。\nCSS如何设置这两种模型\n代码如下：\n1 2 3 4 5 /* 设置当前盒子为 标准盒模型（默认） */ box-sizing: content-box; /* 设置当前盒子为 IE盒模型 */ box-sizing: border-box; 备注：盒子默认为标准盒模型。\nJS如何设置、获取盒模型对应的宽和高\n方式一：通过DOM节点的 style 样式获取\n1 element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。\n这种方式有局限性，但应该了解。\n方式二（通用型）\n1 window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。\n方式三（IE独有的）\n1 element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。\n方式四\n1 element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。\n总结：\n上面的四种方式，要求能说出来区别，以及哪个的通用型更强。\nmargin塌陷/margin重叠\n标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。\n子元素和父元素之间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .father { background: green; } /* 给儿子设置margin-top为10像素 */ .son { height: 100px; margin-top: 10px; background: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。\n儿子这个盒子：\n父亲这个盒子：\n上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。\n善于使用父亲的padding，而不是儿子的margin\n其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。\n我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p）\n1 2 3 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：\n此时我们给父亲div加一个border属性，就正常了：\n如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。\nmargin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。\n所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。\nBFC（边距重叠解决方案）\nBFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。\n另外还有个概念叫IFC。不过，BFC问得更多。\nBFC 的原理/BFC的布局规则【非常重要】\nBFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：\nBFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC\n有以下几种方法：\n方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用\n**举例1：**解决 margin 重叠\n当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。\n比如说，针对下面这样一个 div 结构：\n1 2 3 4 \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;son\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了：\n1 2 3 4 \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;son\u0026#34; style=\u0026#34;overflow: hidden\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。\n举例2：BFC区域不与float区域重叠：\n针对下面这样一个div结构；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .father-layout { background: pink; } .father-layout .left { float: left; width: 100px; height: 100px; background: green; } .father-layout .right { height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section class=\u0026#34;father-layout\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt; 左侧，生命壹号 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下：\n上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。\n如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性）\n1 2 3 \u0026lt;div class=\u0026#34;right\u0026#34; style=\u0026#34;overflow: hidden\u0026#34;\u0026gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， \u0026lt;/div\u0026gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。\n**举例3：**清除浮动\n现在有下面这样的结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .father { background: pink; } .son { float: left; background: green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt; 生命壹号 \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下：\n上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。\n如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下：\n为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/css%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8Abfc/","summary":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、paddin","title":"CSS盒模型及BFC"},{"content":"CSS 概述\nCSS：Cascading Style Sheet，层叠样式表。CSS 的作用就是给 HTML 页面标签添加各种样式，定义网页的显示效果。简单一句话：CSS 将网页内容和显示样式进行分离，提高了显示功能。\nCSS 语法 语法格式：（其实就是键值对）\n1 选择器{ 属性名: 属性值; 属性名: 属性值; } 解释：\n选择器代表页面上的某类元素，选择器后一定是大括号。 属性名后必须用冒号隔开，属性值后用分号（最后一个属性可以不用分号，但最好还是加上分号）。 冒号和属性值之间可以留一个空格（编程习惯的经验）。 如果一个属性有多个值的话，那么多个值用空格隔开。 举例：\n1 2 3 p { color: red; } css 代码的注释 格式：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* 具体的注释 */ p { font-weight: bold; font-style: italic; color: red; } \u0026lt;/style\u0026gt; 注意：CSS 只有/* */这种注释，没有//这种注释。而且注释要写在\u0026lt;style\u0026gt;标签里面才算生效哦。\nCSS 和 HTML 结合的方式（样式表） 优先级： 行内 \u0026gt; 内联 \u0026gt; 外部样式表\n行内样式：在某个特定的标签里采用 style属性。范围只针对此标签。\n内嵌样式表：在页面的 head 里采用\u0026lt;style\u0026gt;标签。范围针对此页面。\n引入外部样式表 css 文件的方式。这种引入方式又分为两种：\n1、采用\u0026lt;link\u0026gt;标签。例如：\u0026lt;link rel = \u0026quot;stylesheet\u0026quot; type = \u0026quot;text/css\u0026quot; href = \u0026quot;a.css\u0026quot;\u0026gt;\u0026lt;/link\u0026gt;\n2、采用 import，必须写在\u0026lt;style\u0026gt;标签中，并且必须是第一句。例如：@import url(a.css) ;\n1、CSS 和 HTML 结合方式一：行内样式 范围只针对此标签适用，适合局部修改。\n1 \u0026lt;p style=\u0026#34;color:white;background-color:red\u0026#34;\u0026gt;我不会就这样轻易的狗带\u0026lt;/p\u0026gt; 2、CSS 和 HTML 结合方式二：内嵌样式表 写在\u0026lt;style\u0026gt;标签，可以对单个页面的样式进行统一设置，但对于局部不够灵活。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; p { font-weight: bold; font-style: italic; color: red; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;洗白白\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;color:blue\u0026#34;\u0026gt;你懂得\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; 3、CSS 和 HTML 结合方式三：引入外部样式表 css 文件 引入样式表文件的方式又分为两种：\n（1）采用\u0026lt;link\u0026gt;标签。例如：\u0026lt;link rel = \u0026quot;stylesheet\u0026quot; type = \u0026quot;text/css\u0026quot; href = \u0026quot;a.css\u0026quot;\u0026gt;\u0026lt;/link\u0026gt;\n（2）采用 import，必须写在\u0026lt;style\u0026gt;标签中，并且必须是第一句。例如：@import url(a.css) ;\n两种引入样式方式的区别：外部样式表中不能写标签，但是可以写 import 语句。\n具体操作如下：\n新建一个a.css样式文件\n1 2 3 4 p { border: 1px solid red; font-size: 40px; } 通过\u0026lt;link\u0026gt;标签引入这个 css 文件\nCSS 的四种基本选择器 权重： 内联 \u0026gt; id （#head） \u0026gt; 类选择器（.head）\u0026gt; 标签选择器 ( p ) 内联样式，如: style=\u0026quot;\u0026hellip;\u0026quot;，权值为1000。 ID选择器，如：#content，权值为0100。 类、伪类、属性选择器，如.content，权值为0010。 标签选择器、伪元素选择器**，如div p，权值为0001。 通配符、子选择器、相邻选择器等。如* \u0026gt; +，权值为0000。 继承的样式没有权值 基本选择器：\nID 选择器：针对某一个特定的标签使用 类选择器：针对你想要的所有标签使用 标签选择器：针对一类标签 通用选择器（通配符）：针对所有的标签都适用（不建议使用） 1、ID 选择器：规定用#来定义 1 #mytitle{ border:3px dashed green; } 2、类选择器：规定用圆点.来定义 css 中用.来表示类。举例如下：\n1 .one{ width:800px; } 3、标签选择器：p 、div 、a \u0026hellip; 1 p{ font-size:14px; } 4、通配符*：匹配任何标签 1 2 3 4 * { margin-left: 0px; margin-top: 0px; } CSS 的几种高级选择器 高级选择器：\n后代选择器：用空格隔开 交集选择器：选择器之间紧密相连 并集选择器（分组选择器）：用逗号隔开 伪类选择器 下面详细讲一下这几种高级（扩展）选择器。\n1、后代选择器: 定义的时候用空格隔开 对于E F这种格式，表示所有属于 E 元素后代的 F 元素，有这个样式。空格就表示后代。\n1 2 3 4 5 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .div1 p { color: red; } \u0026lt;/style\u0026gt; 空格就表示后代。.div1 p 表示.div1的后代所有的p。\n2、交集选择器：定义的时候紧密相连 一般是以标签名开头，比如div.haha，再比如p.special。\n如果后一个选择器是类选择器，则写为div.special；如果后一个选择器 id 选择器，则写为div#special。\n1 2 3 h3.special { color: red; } 选择的元素要求同时满足两个条件：必须是 h3 标签，然后必须是 special 标签。\n3、并集选择器：定义的时候用逗号隔开 1 2 3 4 5 6 p, h1, #mytitle, .one { color: red; } 一些 CSS3 选择器 1.子代选择器（直接下级），用符号\u0026gt;表示 IE7 开始兼容，IE6 不兼容。\n1 2 3 div \u0026gt; p { color: red; } div 的儿子 p。和 div 的后代 p 的截然不同。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;我是div的儿子\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; /*反例*/ \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;我是div的重孙子\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 2.序选择器 1 2 3 4 first-child /*第一个*/ last-child\t/*最后一个*/ nth-child(n)\t/*第n个*/ nth-of-type() /*第n个*/ 3.下一个兄弟选择器 +表示选择下一个兄弟\n1 2 3 4 5 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; h3 + p { color: red; } \u0026lt;/style\u0026gt; 上方的选择器意思是：选择的是 h3 元素后面紧挨着的第一个兄弟。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;h3\u0026gt;我是一个标题\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;我是一个标题\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;我是一个标题\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;我是一个标题\u0026lt;/h3\u0026gt; 效果如下：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/01-html/03-css%E9%80%89%E6%8B%A9%E5%99%A8/","summary":"CSS 概述 CSS：Cascading Style Sheet，层叠样式表。CSS 的作用就是给 HTML 页面标签添加各种样式，定义网页的显示效果。简单一句话：CSS 将","title":"CSS选择器"},{"content":"栈和队列的区别?\n栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别？\n栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构 快速 排序的思想并实现一个快排？\n\u0026ldquo;快速排序\u0026quot;的思想很简单，整个排序过程只需要三步：\n（1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function quickSort(arr){ if(arr.length\u0026lt;=1){ return arr;//如果数组只有一个数，就直接返回； } var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i\u0026lt;arr.length;i++){ if(arr[i]\u0026lt;numValue){ left.push(arr[i]);//基准点的左边的数传到左边数组 } else{ right.push(arr[i]);//基准点的右边的数传到右边数组 } } return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较 } alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87” ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/data-structure/","summary":"栈和队列的区别? 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除","title":"data-structure"},{"content":"知识点主要包括以下几个方面：\n基本概念：DOM事件的级别 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 \u0026hellip;.”。\nDOM事件模型、DOM事件流 面试官如果问你“DOM事件模型”，你不一定知道怎么回事。其实说的就是捕获和冒泡。\nDOM事件流，指的是事件传递的三个阶段。\n描述DOM事件捕获的具体流程 讲的是事件的传递顺序。参数为false（默认）、参数为true，各自代表事件在什么阶段触发。\n能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。\nEvent对象的常见应用（Event的常用api方法） DOM事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，Event对象是非常重要的。\n自定义事件（非常重要）\n一般人可以讲出事件和注册事件，但是如果让你讲自定义事件，能知道的人，就更少了。\nDOM事件的级别\nDOM事件的级别，准确来说，是DOM标准定义的级别。包括：\nDOM0的写法：\n1 2 3 element.onclick = function () { } 上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。\nDOM2的写法：\n1 2 3 element.addEventListener(\u0026#39;click\u0026#39;, function () { }, false); 【重要】上面的第三参数中，true表示事件在捕获阶段触发，false表示事件在冒泡阶段触发（默认）。如果不写，则默认为false。\nDOM3的写法：\n1 2 3 element.addEventListener(\u0026#39;keyup\u0026#39;, function () { }, false); DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。\nPS：为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。\n总结：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。\nDOM事件模型\nDOM事件模型讲的就是捕获和冒泡，一般人都能回答出来。\n捕获：从上往下。 冒泡：从下（目标元素）往上。 DOM事件流\nDOM事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。\n完整的事件流，分三个阶段：\n捕获：从 window 对象传到 目标元素。 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。 冒泡：从目标元素传到 Window 对象。 描述DOM事件捕获的具体流程\n很少有人能说完整。\n捕获的流程\n说明：捕获阶段，事件依次传递的顺序是：window \u0026ndash;\u0026gt; document \u0026ndash;\u0026gt; html\u0026ndash;\u0026gt; body \u0026ndash;\u0026gt; 父元素、子元素、目标元素。\nPS1：第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。 PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 window.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 window\u0026#34;); }, true); document.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 document\u0026#34;); }, true); document.documentElement.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 html\u0026#34;); }, true); document.body.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 body\u0026#34;); }, true); fatherBox.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 father\u0026#34;); }, true); childBox.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 child\u0026#34;); }, true); 补充一个知识点：\n在 js中：\n如果想获取 body 节点，方法是：document.body； 但是，如果想获取 html节点，方法是document.documentElement。 冒泡的流程\n与捕获的流程相反\nEvent对象的常见 api 方法\n用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过Event对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：\n方法一\n1 event.preventDefault(); 解释：阻止默认事件。 比如，已知\u0026lt;a\u0026gt;标签绑定了click事件，此时，如果给\u0026lt;a\u0026gt;设置了这个方法，就阻止了链接的默认跳转。 方法二：阻止冒泡\n这个在业务中很常见。\n有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件A，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件A。这个时候，就要用到阻止冒泡了。\nw3c的方法：（火狐、谷歌、IE11）\n1 event.stopPropagation(); IE10以下则是：\n1 event.cancelBubble = true; 兼容代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 box3.onclick = function (event) { alert(\u0026#34;child\u0026#34;); //阻止冒泡 event = event || window.event; if (event \u0026amp;\u0026amp; event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } } 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。\n方法三：设置事件优先级\n1 event.stopImmediatePropagation(); 这个方法比较长，一般人没听说过。解释如下：\n比如说，我用addEventListener给某按钮同时注册了事件A、事件B。此时，如果我单击按钮，就会依次执行事件A和事件B。现在要求：单击按钮时，只执行事件A，不执行事件B。该怎么做呢？这是时候，就可以用到stopImmediatePropagation方法了。做法是：在事件A的响应函数中加入这句话。\n大家要记住 event 有这个方法。\n属性4、属性5（事件委托中用到）\n1 2 3 4 event.currentTarget //当前所绑定的事件对象。在事件委托中，指的是【父元素】。 event.target //当前被点击的元素。在事件委托中，指的是【子元素】。 上面这两个属性，在事件委托中经常用到。\n总结：上面这几项，非常重要，但是容易弄混淆。\n自定义事件\n自定义事件的代码如下：\n1 2 3 4 5 6 7 var myEvent = new Event(\u0026#39;clickTest\u0026#39;); element.addEventListener(\u0026#39;clickTest\u0026#39;, function () { console.log(\u0026#39;smyhvae\u0026#39;); }); //元素注册事件 element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest 上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：\n1 2 3 4 5 6 7 8 9 var myEvent = new Event(\u0026#39;clickTest\u0026#39;); element.addEventListener(\u0026#39;clickTest\u0026#39;, function () { console.log(\u0026#39;smyhvae\u0026#39;); }); setTimeout(function () { element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest }, 1000); ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/dom%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93/","summary":"知识点主要包括以下几个方面： 基本概念：DOM事件的级别 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 \u0026hellip;.","title":"DOM事件的总结"},{"content":"前言 ECMAScript 是 JS 的语言标准。而 ES6 是新的 JS 语法标准。\n发展历史 20180303_1633.png\n2015年6月，ES6正式发布。 ES6 的其他优势 使用 babel 语法转换器，支持低端浏览器\n流行的库基本都是基于 ES6 构建。 React 默认使用 ES6 新源发开发。\nES6 的常用语法 ES6语法概览 块级作用域、字符串\n对象扩展、解构\n类、模块化等。\n作用域：let 和 const 用 let定义变量 ，替代 var\n用const 定义常量（定义后，不可修改）\n作用域和 {}\n举例：\n1 2 3 let a1 = \u0026#39;haha\u0026#39;; const name = `smyhvae`; 模板字符串 我们以前让字符串进行拼接的时候，是这样做的：（传统写法的字符串拼接）\n1 2 3 var name = \u0026#39;smyhvae\u0026#39;; var age = \u0026#39;26\u0026#39;; console.log(\u0026#39;name:\u0026#39;+name+\u0026#39;,age:\u0026#39;+age); //传统写法 这种写法，比较繁琐，而且容易出错。\n现在有了 ES6 语法，字符串拼接可以这样写：\n1 2 3 4 5 6 var name = \u0026#39;smyhvae\u0026#39;; var age = \u0026#39;26\u0026#39;; console.log(\u0026#39;name:\u0026#39;+name+\u0026#39;,age:\u0026#39;+age); //传统写法 console.log(`name:${name},age:${age}`); //ES6 写法 注意，上方代码中，倒数第二行用的是单引号，最后一行用的是反引号（在tab键的上方）。\n函数扩展 ES6 中函数的用法：\n参数默认值\n箭头函数\n展开运算符\n定义和调用函数：（传统写法）\n1 2 3 4 5 function fn1(name) { console.log(name); } fn1(\u0026#39;smyhvae\u0026#39;); 定义和调用函数：（ES6写法）\n1 2 3 4 5 var fn2 = (name)=\u0026gt;{ console.log(name); } fn2(\u0026#39;smyhvae\u0026#39;); 上面两端代码，执行的结果是一样的。\n当然，也可以给上面这个函数的参数加一个默认值：\n1 2 3 4 5 6 var fn2 = (name=\u0026#39;enen\u0026#39;)=\u0026gt;{ console.log(name); } fn2(); //参数用默认值 enen fn2(\u0026#39;smyhvae\u0026#39;); 比如说，1秒后执行一段代码，可以用箭头函数：\n1 2 3 setTimeout(()=\u0026gt;{ console.log(\u0026#39;something\u0026#39;); },1000); 如果函数体只有一条 return 语句，那么大括号可以省略：\n1 2 const myDouble = x=\u0026gt;x*2; console.log(myDouble(5)); //打印结果为10 箭头函数的好处：\n简写代码\n保持 this 的作用域\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/es6/","summary":"前言 ECMAScript 是 JS 的语言标准。而 ES6 是新的 JS 语法标准。 发展历史 20180303_1633.png 2015年6月，ES6正式发布。 ES6 的其他优势 使用 babel 语法转换器，支持低端浏览器 流行的库基","title":"ES6"},{"content":"1、ES5、ES6和ES2015有什么区别? ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线\n2、babel是什么，有什么作用? babel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台\n4、举一些ES6对String字符串类型做的常用升级优化? 优化部分\nES6新增了字符串模板，在拼接大段字符串时，用反斜杠()`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅\n升级部分\nES6在String原型上新增了includes()方法，用于取代传统的只能用indexOf查找包含字符的方法(indexOf返回-1表示没查到不如includes方法返回false更明确，语义更清晰), 此外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法，可方便的用于查找，补全字符串\n5、举一些ES6对Array数组类型做的常用升级优化 优化部分\n数组解构赋值。ES6可以直接以let [a,b,c] = [1,2,3]形式进行变量赋值，在声明较多变量时，不用再写很多let(var),且映射关系清晰，且支持赋默认值 扩展运算符。ES6新增的扩展运算符(...)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代arguments对象和apply方法，轻松获取未知参数个数情况下的参数集合。（尤其是在ES5中，arguments并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（let a = [2,3,4]; let b = [...a]） 升级部分\nES6在Array原型上新增了find()方法，用于取代传统的只能用indexOf查找包含数组项目的方法,且修复了indexOf查找不到NaN的bug([NaN].indexOf(NaN) === -1).此外还新增了copyWithin(), includes(), fill(),flat()等方法，可方便的用于字符串的查找，补全,转换等\n6、举一些ES6对Number数字类型做的常用升级优化 优化部分\nES6在Number原型上新增了isFinite(), isNaN()方法，用来取代传统的全局isFinite(), isNaN()方法检测数值是否有限、是否是NaN。ES5的isFinite(), isNaN()方法都会先将非数值类型的参数转化为Number类型再做判断，这其实是不合理的，最造成isNaN('NaN') === true的奇怪行为--'NaN'是一个字符串，但是isNaN却说这就是NaN。而Number.isFinite()和Number.isNaN()则不会有此类问题(Number.isNaN('NaN') === false)。（isFinite()同上）\n升级部分\nES6在Math对象上新增了Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算\n7、举一些ES6对Object类型做的常用升级优化?(重要) 优化部分\n对象属性变量式声明。ES6可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰\n1 2 let [apple, orange] = [\u0026#39;red appe\u0026#39;, \u0026#39;yellow orange\u0026#39;]; let myFruits = {apple, orange}; // let myFruits = {apple: \u0026#39;red appe\u0026#39;, orange: \u0026#39;yellow orange\u0026#39;}; 尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显\n1 2 let {keys, values, entries} = Object; let MyOwnMethods = {keys, values, entries}; // let MyOwnMethods = {keys: keys, values: values, entries: entries} 可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法\n1 2 3 4 5 6 let es5Fun = { method: function(){} }; let es6Fun = { method(){} } 对象的解构赋值。 ES6对象也可以像数组解构赋值那样，进行变量的解构赋值\n1 let {apple, orange} = {apple: \u0026#39;red appe\u0026#39;, orange: \u0026#39;yellow orange\u0026#39;}; 对象的扩展运算符(...)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解\n1 2 3 4 5 let {apple, orange, ...otherFruits} = {apple: \u0026#39;red apple\u0026#39;, orange: \u0026#39;yellow orange\u0026#39;, grape: \u0026#39;purple grape\u0026#39;, peach: \u0026#39;sweet peach\u0026#39;}; // otherFruits {grape: \u0026#39;purple grape\u0026#39;, peach: \u0026#39;sweet peach\u0026#39;} // 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数) let moreFruits = {watermelon: \u0026#39;nice watermelon\u0026#39;}; let allFruits = {apple, orange, ...otherFruits, ...moreFruits}; super 关键字。ES6在Class类里新增了类似this的关键字super。同this总是指向当前函数所在的对象不同，super关键字总是指向当前函数所在对象的原型对象\n升级部分\nES6在Object原型上新增了is()方法，做两个目标对象的相等比较，用来完善'==='方法。'==='方法中NaN === NaN //false其实是不合理的，Object.is修复了这个小bug。(Object.is(NaN, NaN) // true)\nES6在Object原型上新增了assign()方法，用于对象新增属性或者多个对象合并\n1 2 3 4 5 const target = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 注意: assign合并的对象target只能合并source1、source2中的自身属性，并不会合并source1、source2中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行get/set函数，取return的值）\nES6在Object原型上新增了getOwnPropertyDescriptors()方法，此方法增强了ES5中getOwnPropertyDescriptor()方法，可以获取指定对象所有自身属性的描述对象。结合defineProperties()方法，可以完美复制对象，包括复制get和set属性 ES6在Object原型上新增了getPrototypeOf()和setPrototypeOf()方法，用来获取或设置当前对象的prototype对象。这个方法存在的意义在于，ES5中获取设置prototype对像是通过__proto__属性来实现的，然而__proto__属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的prototype对象时，都应该采用ES6新增的标准用法 ES6在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组 8、举一些ES6对Function函数类型做的常用升级优化? 优化部分\n箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点\n箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下this的指向变得很难理解，尤其是非严格模式情况下，this有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的this,这也就导致了this总是指向上一层的this，如果上一层还是箭头函数，则继续向上指，直到指向到有自己this的函数为止，并作为自己的this 箭头函数不能用作构造函数，因为它没有自己的this，无法实例化 也是因为箭头函数没有自己的this,所以箭头函数 内也不存在arguments对象。（可以用扩展运算符代替） 函数默认赋值。ES6之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。ES6以更简洁更明确的方式进行函数默认赋值 1 2 3 4 function es6Fuc (x, y = \u0026#39;default\u0026#39;) { console.log(x, y); } es6Fuc(4) // 4, default 升级部分\nES6新增了双冒号运算符，用来取代以往的bind，call,和apply。(浏览器暂不支持，Babel已经支持转码)\n1 2 3 4 5 6 7 foo::bar; // 等同于 bar.bind(foo); foo::bar(...arguments); // 等同于 bar.apply(foo, arguments); 9、Symbol是什么，有什么作用？ Symbol是ES6引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中Symbol()属性不能被for...in遍历，但是也不是私有属性\n10、Set是什么，有什么作用？ Set是ES6引入的一种类似Array的新的数据结构，Set实例的成员类似于数组item成员，区别是Set实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重\n11、Map是什么，有什么作用？ Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。可以更加全面的描述对象的属性\n12、Proxy是什么，有什么作用？ Proxy是ES6新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的get/set等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的get/set方法，可以轻松地定制自己想要的key或者value。下面的例子可以看到，随便定义一个myOwnObj的key,都可以变成自己想要的函数`\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function createMyOwnObj() { //想把所有的key都变成函数，或者Promise,或者anything return new Proxy({}, { get(target, propKey, receiver) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { let randomBoolean = Math.random() \u0026gt; 0.5; let Message; if (randomBoolean) { Message = `你的${propKey}运气不错，成功了`; resolve(Message); } else { Message = `你的${propKey}运气不行，失败了`; reject(Message); } }, 1000); }); } }); } let myOwnObj = createMyOwnObj(); myOwnObj.hahaha.then(result =\u0026gt; { console.log(result) //你的hahaha运气不错，成功了 }).catch(error =\u0026gt; { console.log(error) //你的hahaha运气不行，失败了 }) myOwnObj.wuwuwu.then(result =\u0026gt; { console.log(result) //你的wuwuwu运气不错，成功了 }).catch(error =\u0026gt; { console.log(error) //你的wuwuwu运气不行，失败了 }) 13、Reflect是什么，有什么作用？ Reflect是ES6引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在Object、Function或者全局函数里的方法(如apply、delete、get、set等等)，统一整合到Reflect上，这样可以更加方便更加统一的管理一些原生API。其次就是因为Proxy可以改写默认的原生API，如果一旦原生API别改写可能就找不到了，所以Reflect也可以起到备份原生API的作用，使得即使原生API被改写了之后，也可以在被改写之后的API用上默认的API\n14、Promise是什么，有什么作用？ Promise是ES6引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用\n15、Iterator是什么，有什么作用？(重要) Iterator是ES6中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为ES6新增了Set、Map类型，他们和Array、Object类型很像，Array、Object都是可以遍历的，但是Set、Map都不能用for循环遍历，解决这个问题有两种方案，一种是为Set、Map单独新增一个用来遍历的API，另一种是为Set、Map、Array、Object新增一个统一的遍历API，显然，第二种更好，ES6也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。Iterator正是这样一种标准。或者说是一种规范理念 就好像JavaScript是ECMAScript标准的一种具体实现一样，Iterator标准的具体实现是Iterator遍历器。Iterator标准规定，所有部署了key值为[Symbol.iterator]，且[Symbol.iterator]的value是标准的Iterator接口函数(标准的Iterator接口函数: 该函数必须返回一个对象，且对象中包含next方法，且执行next()能返回包含value/done属性的Iterator对象)的对象，都称之为可遍历对象，next()后返回的Iterator对象也就是Iterator遍历器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。 //obj.[Symbol.iterator]() 就是Iterator遍历器 let obj = { data: [ \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39; ], [Symbol.iterator]() { const self = this; let index = 0; return { next() { if (index \u0026lt; self.data.length) { return { value: self.data[index++], done: false }; } else { return { value: undefined, done: true }; } } }; } }; ES6给Set、Map、Array、String都加上了[Symbol.iterator]方法，且[Symbol.iterator]方法函数也符合标准的Iterator接口规范，所以Set、Map、Array、String默认都是可以遍历的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //Array let array = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; array[Symbol.iterator]() //Iterator遍历器 array[Symbol.iterator]().next() //{value: \u0026#34;red\u0026#34;, done: false} //String let string = \u0026#39;1122334455\u0026#39;; string[Symbol.iterator]() //Iterator遍历器 string[Symbol.iterator]().next() //{value: \u0026#34;1\u0026#34;, done: false} //set let set = new Set([\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]); set[Symbol.iterator]() //Iterator遍历器 set[Symbol.iterator]().next() //{value: \u0026#34;red\u0026#34;, done: false} //Map let map = new Map(); let obj= {map: \u0026#39;map\u0026#39;}; map.set(obj, \u0026#39;mapValue\u0026#39;); map[Symbol.iterator]().next() {value: Array(2), done: false} 16、for\u0026hellip;in 和for\u0026hellip;of有什么区别？ 如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用for...of。ES6规定，有所部署了载了Iterator接口的对象(可遍历对象)都可以通过for...of去遍历，而for..in仅仅可以遍历对象\n这也就意味着，数组也可以用for...of遍历，这极大地方便了数组的取值，且避免了很多程序用for..in去遍历数组的恶习 17、Generator函数是什么，有什么作用？ 如果说JavaScript是ECMAScript标准的一种具体实现、Iterator遍历器是Iterator的具体实现，那么Generator函数可以说是Iterator接口的具体实现方式。 执行Generator函数会返回一个遍历器对象，每一次Generator函数里面的yield都相当一次遍历器对象的next()方法，并且可以通过next(value)方法传入自定义的value,来改变Generator函数的行为。 Generator函数可以通过配合Thunk 函数更轻松更优雅的实现异步编程和控制流管理。 18、async函数是什么，有什么作用？ async函数可以理解为内置自动执行器的Generator函数语法糖，它配合ES6的Promise近乎完美的实现了异步编程解决方案\n19、Class、extends是什么，有什么作用？ ES6 的class可以看作只是一个ES5生成实例对象的构造函数的语法糖。它参考了java语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class类可以通过extends实现继承。它和ES5构造函数的不同点\n类的内部定义的所有方法，都是不可枚举的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ///ES5 function ES5Fun (x, y) { this.x = x; this.y = y; } ES5Fun.prototype.toString = function () { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; } var p = new ES5Fun(1, 3); p.toString(); Object.keys(ES5Fun.prototype); //[\u0026#39;toString\u0026#39;] //ES6 class ES6Fun { constructor (x, y) { this.x = x; this.y = y; } toString () { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; } } Object.keys(ES6Fun.prototype); //[] ES6的class类必须用new命令操作，而ES5的构造函数不用new也可以执行。 ES6的class类不存在变量提升，必须先定义class之后才能实例化，不像ES5中可以将构造函数写在实例化之后。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 20、module、export、import是什么，有什么作用？ module、export、import是ES6用来统一前端模块化方案的设计思路和实现方案。export、import的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的AMD/CMD、requireJS、seaJS、commondJS等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，JS也能更加能实现大型的应用程序开发。 import引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。 import引入export导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？ 常用箭头函数来取代var self = this;的做法。 常用let取代var命令。 常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。 在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。 用Class类取代传统的构造函数，来生成实例化对象。 在大型应用开发中，要保持module模块化开发思维，分清模块之间的关系，常用import、export方法。 22、ES6的了解 新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=\u0026gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念\n23、说说你对Promise的理解 依照 Promise/A+ 的定义，Promise 有四种状态：\npending: 初始状态, 非 fulfilled 或 rejected.\nfulfilled: 成功的操作.\nrejected: 失败的操作.\nsettled: Promise已被fulfilled或rejected，且不是pending\n另外， fulfilled 与 rejected 一起合称 settled\nPromise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算\n24、Promise 的构造函数 构造一个 Promise，最基本的用法如下： 1 2 3 4 5 6 7 8 9 10 11 12 var promise = new Promise(function(resolve, reject) { if (...) { // succeed resolve(result); } else { // fails reject(Error(errMessage)); } }); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1 promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject 什么是 Promise ？\nPromise 就是一个对象，用来表示并传递异步操作的最终结果 Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因 Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱） 25、谈一谈你了解ECMAScript6的新特性？ 块级作用区域 let a = 1; 可定义常量 const PI = 3.141592654; 变量解构赋值 var [a, b, c] = [1, 2, 3]; 字符串的扩展(模板字符串) var sum =${a + b}; 数组的扩展(转换数组类型) Array.from($('li')); 函数的扩展(扩展运算符) [1, 2].push(...[3, 4, 5]); 对象的扩展(同值相等算法) Object.is(NaN, NaN); 新增数据类型(Symbol) let uid = Symbol('uid'); 新增数据结构(Map) let set = new Set([1, 2, 2, 3]); for\u0026hellip;of循环 for(let val of arr){}; Promise对象 var promise = new Promise(func); Generator函数 function* foo(x){yield x; return x*x;} 引入Class(类) class Foo {} 引入模块体系 export default func; 引入async函数[ES7] 1 2 3 4 5 async function asyncPrint(value, ms) { await timeout(ms); console.log(value) } 26、Object.is() 与原来的比较操作符 ===、== 的区别？ == 相等运算符，比较时会自动进行数据类型转换 === 严格相等运算符，比较时不进行隐式类型转换 Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理 1 2 3 4 5 +0 === -0 //true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true 27、什么是 Babel Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。 这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。 Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-es6/","summary":"1、ES5、ES6和ES2015有什么区别? ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES20","title":"ES6"},{"content":"Symbol 概述 背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。\n概念：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n特点：\nSymbol属性对应的值是唯一的，解决命名冲突问题\nSymbol值不能与其他数据进行计算，包括同字符串拼串\nfor in、for of 遍历时不会遍历Symbol属性。\n创建Symbol属性值 Symbol是函数，但并不是构造函数。创建一个Symbol数据类型：\n1 2 3 4 let mySymbol = Symbol(); console.log(typeof mySymbol); //打印结果：symbol console.log(mySymbol); //打印结果：Symbol() 打印结果：\n下面来讲一下Symbol的使用。\n1、将Symbol作为对象的属性值 1 2 3 4 5 6 7 8 9 10 11 let mySymbol = Symbol(); let obj = { name: \u0026#39;smyhvae\u0026#39;, age: 26 }; //obj.mySymbol = \u0026#39;male\u0026#39;; //错误：不能用 . 这个符号给对象添加 Symbol 属性。 obj[mySymbol] = \u0026#39;hello\u0026#39;; //正确：通过**属性选择器**给对象添加 Symbol 属性。后面的属性值随便写。 console.log(obj); 上面的代码中，我们尝试给obj添加一个Symbol类型的属性值，但是添加的时候，不能采用.这个符号，而是应该用属性选择器的方式。打印结果：\n现在我们用for in尝试对上面的obj进行遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let mySymbol = Symbol(); let obj = { name: \u0026#39;smyhvae\u0026#39;, age: 26 }; obj[mySymbol] = \u0026#39;hello\u0026#39;; console.log(obj); //遍历obj for (let i in obj) { console.log(i); } 打印结果：\n从打印结果中可以看到：for in、for of 遍历时不会遍历Symbol属性。\n创建Symbol属性值时，传参作为标识 如果我通过 Symbol()函数创建了两个值，这两个值是不一样的：\n1 2 3 4 5 6 let mySymbol1 = Symbol(); let mySymbol2 = Symbol(); console.log(mySymbol1 == mySymbol2); //打印结果：false console.log(mySymbol1); //打印结果：Symbol() console.log(mySymbol2); //打印结果：Symbol() 上面代码中，倒数第三行的打印结果也就表明了，二者的值确实是不相等的。\n最后两行的打印结果却发现，二者的打印输出，肉眼看到的却相同。那该怎么区分它们呢？\n既然Symbol()是函数，函数就可以传入参数，我们可以通过参数的不同来作为标识。比如：\n1 2 3 4 5 6 7 8 //在括号里加入参数，来标识不同的Symbol let mySymbol1 = Symbol(\u0026#39;one\u0026#39;); let mySymbol2 = Symbol(\u0026#39;two\u0026#39;); console.log(mySymbol1 == mySymbol2); //打印结果：false console.log(mySymbol1); //打印结果：Symbol(one) console.log(mySymbol2); //打印结果：Symbol(two)。颜色为红色。 console.log(mySymbol2.toString());//打印结果：Symbol(two)。颜色为黑色。 打印结果：\n定义常量 Symbol 可以用来定义常量：\n1 const MY_NAME = Symbol(\u0026#39;my_name\u0026#39;); 内置的 Symbol 值 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。\nSymbol.iterator属性 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/es6symbol/","summary":"Symbol 概述 背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。 概念：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它","title":"ES6：Symbol"},{"content":"GitHub的使用 GitHub添加wiki 参考链接：\nhttps://juejin.im/post/5a3216c8f265da43333e6b54 GitHub项目添加 license 参考链接：\nhttps://blog.csdn.net/qq_35246620/article/details/77647234 GitHub 引用图片的另一种方式 参考链接：\n关于markdown文件插入图片遇到的小问题和解决办法 ","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/05-github%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"GitHub的使用 GitHub添加wiki 参考链接： https://juejin.im/post/5a3216c8f265da43333e6b54 GitHub项目添加 license 参考链接： https://blog.csdn.net/qq_35246620/article/details/77647234 GitHub 引用图片的另一种方式 参考链接： 关于markdown","title":"GitHub的使用"},{"content":"HTML 语义化\nHTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构\ncss命名的语义化是指：为html标签添加有意义的class\n为什么需要语义化：\n去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便团队项目的可持续运作及维护 简述一下你对HTML语义化的理解？\n用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 Doctype作用？标准模式与兼容模式各有什么区别?\n\u0026lt;!DOCTYPE\u0026gt;声明位于位于HTML文档中的第一行，处于 \u0026lt;html\u0026gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作 HTML5 为什么只需要写 \u003c!DOCTYPE HTML\u003e？\nHTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行） 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\n行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 常见的空元素: \u0026lt;br\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;img\u0026gt; \u0026lt;input\u0026gt; \u0026lt;link\u0026gt; \u0026lt;meta\u0026gt; 页面导入样式时，使用link和@import有什么区别？\nlink属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题 介绍一下你对浏览器内核的理解？\n主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎\n渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核\nJS引擎则：解析和执行javascript来实现网页的动态效果\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎\n常见的浏览器内核有哪些？\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）] html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？\nHTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加\n绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素：\n纯表现的元素：basefont，big，center，font, s，strike，tt，u\n对可用性产生负面影响的元素：frame，frameset，noframes\n支持HTML5新标签：\nIE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim\n1 2 3 \u0026lt;!--[if lt IE 9]\u0026gt; \u0026lt;script\u0026gt; src=\u0026#34;http://html5shim.googlecode.com /svn/trunk/html5.js\u0026#34;\u0026lt;/script\u0026gt;\u0026lt;![endif]--\u0026gt; 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素 HTML5的离线储存怎么使用，工作原理能不能解释一下？\n在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n如何使用：\n页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现 1 2 3 4 5 6 7 8 9 CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\n在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n离线的情况下，浏览器就直接使用离线存储的资源。\n请描述一下 cookies，sessionStorage 和 localStorage 的区别？\ncookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）\ncookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递\nsessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n存储大小：\ncookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间：\nlocalStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？\niframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 Label的作用是什么？是怎么用的？\nlabel标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件 HTML5的form如何关闭自动完成功能？\n给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里)\nWebSocket、SharedWorker 也可以调用localstorge、cookies等本地存储方式 webSocket如何兼容低浏览器？(阿里)\nAdobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？\n通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 如何在页面上实现一个圆形的可点击区域？\nmap+area或者svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果\n1 \u0026lt;div style=\u0026#34;height:1px;overflow:hidden;background:red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 网页验证码是干嘛的，是为了解决什么安全问题\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 title与h1的区别、b与strong的区别、i与em的区别？\ntitle属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响 strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：strong会重读，而b是展示强调内容 i内容展示为斜体，em表示强调的文本 页面导入样式时，使用 link 和 @import 有什么区别？\nlink 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS 页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载 @import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题 介绍一下你对浏览器内核的理解？\n浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎 渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机 JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 常见的浏览器内核有哪些？\nBlink内核：新版 Chrome、新版 Opera Webkit内核：Safari、原Chrome Gecko内核：FireFox、Netscape6及以上版本 Trident内核（又称MSHTML内核）：IE、国产浏览器 Presto内核：原Opera7及以上 HTML5有哪些新特性？\n新增选择器 document.querySelector、document.querySelectorAll 拖拽释放(Drag and drop) API 媒体播放的 video 和 audio 本地存储 localStorage 和 sessionStorage 离线应用 manifest 桌面通知 Notifications 语意化标签 article、footer、header、nav、section 增强表单控件 calendar、date、time、email、url、search 地理位置 Geolocation 多任务 webworker 全双工通信协议 websocket 历史管理 history 跨域资源共享(CORS) Access-Control-Allow-Origin 页面可见性改变事件 visibilitychange 跨窗口通信 PostMessage Form Data 对象 绘画 canvas HTML5移除了那些元素？\n纯表现的元素：basefont、big、center、font、s、strike、tt、u 对可用性产生负面影响的元素：frame、frameset、noframes 如何处理HTML5新标签的浏览器兼容问题？\n通过 document.createElement 创建新标签 使用垫片 html5shiv.js 如何区分 HTML 和 HTML5？\nDOCTYPE声明、新增的结构元素、功能元素 HTML5的离线储存工作原理能不能解释一下，怎么使用？\nHTML5的离线储存原理：\n用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容 HTML5的离线储存使用：\n在文档的 html 标签设置 manifest 属性，如 manifest=\u0026quot;/offline.appcache\u0026quot; 在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache 在 web 服务器配置正确的 MIME-type，即 text/cache-manifest 浏览器是怎么对HTML5的离线储存资源进行管理和加载的？\n在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件 如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储 如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源。 iframe 有那些优点和缺点？\n优点：\n用来加载速度较慢的内容（如广告） 可以使脚本可以并行下载 可以实现跨子域通信 缺点：\niframe 会阻塞主页面的 onload 事件 无法被一些搜索引擎索识别 会产生很多页面，不容易管理 label 的作用是什么？怎么使用的？\nlabel标签来定义表单控件的关系：\n当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上 使用方法1：\n\u0026lt;label for=\u0026quot;mobile\u0026quot;\u0026gt;Number:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;mobile\u0026quot;/\u0026gt; 使用方法2：\n\u0026lt;label\u0026gt;Date:\u0026lt;input type=\u0026quot;text\u0026quot;/\u0026gt;\u0026lt;/label\u0026gt; 如何实现浏览器内多个标签页之间的通信？\niframe + contentWindow postMessage SharedWorker(Web Worker API) storage 事件(localStorge API) WebSocket webSocket 如何兼容低浏览器？\nAdobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？\n在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 当用户浏览其他页面，暂停网站首页幻灯自动播放 完成登陆后，无刷新自动同步其他页面的登录状态 title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？\ntitle 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响 strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b 是展示强调内容\ni 内容展示为斜体，em 表示强调的文本 自然样式标签：b, i, u, s, pre 语义样式标签：strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-html/","summary":"HTML 语义化 HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构 css命名的语义化是指：为html标签添加有意义的","title":"HTML"},{"content":"一面中，如果有笔试，考HTTP协议的可能性较大。\n1. 前言 一面要讲的内容：\nHTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的区别 HTTP状态码 什么是持久连接 什么是管线化 二面要讲的内容；\n缓存 CSRF攻击 2. HTTP协议的主要特点 简单快速 灵活 无连接 无状态 通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：无连接、无状态。\n2.1 简单快速 简单：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。\n2.2 灵活 http协议的头部有一个数据类型，通过http协议，就可以完成不同数据类型的传输。\n2.3 无连接 连接一次，就会断开，不会继续保持连接。\n2.4 无状态 客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。\n有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。\n3 HTTP报文的组成部分 在回答此问题时，我们要按照顺序回答：\n先回答的是，http报文包括：请求报文和响应报文。 再回答的是，每个报文包含什么部分。 最后回答，每个部分的内容是什么 3.1 请求报文包括： 请求行：包括请求方法、请求的url、http协议及版本。 请求头：一大堆的键值对。 空行指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体 请求体：数据部分。 3.2 响应报文包括： 状态行：http协议及版本、状态码及状态描述。 响应头 空行 响应体 4 HTTP方法 包括：\nGET：获取资源 POST：传输资源 put：更新资源 DELETE：删除资源 HEAD：获得报文首部 HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。\nget 和 post` 比较常见。 put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。 head 可能偶尔用的到。 5 get 和 post的区别 区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。 有一点要强调，get是相对不隐私的，而post是相对隐私的。 我们大概要记住以下几点：\n浏览器在回退时，get 不会重新请求，但是post会重新请求。【重要】 get请求会被浏览器主动缓存，而post不会。【重要】 get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。 get请求在url中传递的参数有大小限制，基本是2kb`，不同的浏览器略有不同。而post没有注意。 get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。 6 http状态码 http状态码分类：\n常见的http状态码：\n部分解释：\n206的应用：range指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。 301：重定向（永久）。 302：重定向（临时）。 304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。 400和401用的不多,未授权。403指的是请求被拒绝。404指的是资源不存在。 7 持久链接/http长连接 如果你能答出持久链接，这是面试官很想知道的一个点。\n轮询：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 长连接：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。 注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。\n8 长连接中的管线化 如果能答出管线化，则属于加分项。\n8.1 管线化的原理 长连接时，默认的请求这样的：\n1 请求1 --\u0026gt; 响应1 --\u0026gt;请求2 --\u0026gt; 响应2 --\u0026gt; 请求3 --\u0026gt; 响应3 管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/http%E5%8D%8F%E8%AE%AE/","summary":"一面中，如果有笔试，考HTTP协议的可能性较大。 1. 前言 一面要讲的内容： HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的","title":"HTTP协议"},{"content":"方法的注释 方法写完之后（注意，一定要先写完整），我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。\n比如：\n1 2 3 4 5 6 7 8 9 /** * 功能：给定元素查找他的第一个元素子节点，并返回 * @param ele * @returns {Element|*|Node} */ function getFirstNode(ele){ var node = ele.firstElementChild || ele.firstChild; return node; } 断点调试 （1）先让程序运行一遍。\n（2）f12，弹出代码调试工具\n（3）打断点：\n然后刷新页面。\n（4）一步步调试，每点击一次，执行一步：\n（5）监视变量：\n当然，也可以添加变量或者表达式到监视窗口。操作如下：\n上图中，选择变量或表达式，然后右键add to watch.\n然后监视窗口：\n2019-05-20-给数组、对象赋值 数组赋值的正确写法：\n1 this.todayList.splice(0, 0, ...dataList); 对象赋值的正确写法：\n1 Object.assign(obj2, obj1); 上方代码中，是将obj1 的值追加到obj2中。如果对象里的属性名相同，会被覆盖。\n2019-11-25-在新的窗口中打开url 在原来的窗体中跳转到新页面：\n1 window.location.href=\u0026#34;要跳转的新页面\u0026#34;; 在新窗体中打开新页面：\n1 window.open(\u0026#39;你所要跳转的新页面\u0026#39;); 2019-12-10-JavaScript 新特性：Optional Chaining（可选链式调用）语法 以往写代码，我们一般都这么写：\n1 2 3 if (result \u0026amp;\u0026amp; result.user \u0026amp;\u0026amp; result.user.name \u0026amp;\u0026amp; result.user.name.length) { console.log(\u0026#39;qianguyihao\u0026#39;); } 有了 Optinal Chain 语法之后，就简洁很多了，可以这么写：\n1 2 3 if (result?.user?.name?.length) { console.log(\u0026#39;qianguyihao\u0026#39;); } 参考链接：\n了解 JavaScript 新特性：Optional Chaining：https://www.infoq.cn/article/2JDORgXrU6VmZ7jlyuFD\n原文链接： https://v8.dev/features/optional-chaining\n2020-04-28-判断字符串的包含关系 1 2 3 4 var str = \u0026#39;qiangu2\u0026#39;; if (str == (\u0026#39;qiangu1\u0026#39; || \u0026#39;qiangu2\u0026#39;)) { console.log(\u0026#39;qianguyihao\u0026#39;); } 注意，上面的代码，根本就不会走 console.log 语句，因为if里面的内容是false。\n如果我们要判断变量 str 是否在 qiangu1、qiangu2的合集里，我们应该这样写：\n1 2 3 4 var str = \u0026#39;qiangu2\u0026#39;; if (str == \u0026#39;qiangu1\u0026#39; || str == \u0026#39;qiangu2\u0026#39;) { console.log(\u0026#39;qianguyihao\u0026#39;); } ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/javascript%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/","summary":"方法的注释 方法写完之后（注意，一定要先写完整），我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。 比如： 1 2 3 4 5 6 7 8 9","title":"JavaScript开发积累"},{"content":"AMD的基本语法 AMD的概念 AMD（Asynchronous Module Definition）：异步模块定义。AMD专门用于浏览器端，模块的加载是异步的。\nAMD规范：是 RequireJS 在推广过程中对模块化定义的规范化产出。\nRequireJS：一个基于AMD规范实现的模块化开发解决方案。\n暴露模块的方式 定义没有依赖的模块：（参数只有一个 function）\n1 2 3 4 5 define(function () { return 模块 }) 定义有依赖的模块：（参数有两个：模块名、function）\n1 2 3 4 5 6 //定义有依赖的模块：第一个参数为数组 define([\u0026#39;module1\u0026#39;, \u0026#39;module2\u0026#39;], function (m1, m2) { return 模块 }) 代码解释：\n第一个参数必须是数组，里面存放的是，需要依赖的其他的模块。\n第二个参数是function，里面带了形参 m1 和 m2，分别代表了 module1 和 module2。这个形参的作用是，前面依赖的模块一旦声明了，就可以一一对应地注入到 function中去，从而在 function 内部使用依赖的模块。这种方式称之为显式声明依赖注入。\n引入模块的方式 在主模块中引入其他的模块：\n1 2 3 4 5 6 //在主模块中引入其他的模块 require([\u0026#39;module1\u0026#39;, \u0026#39;module2\u0026#39;], function (m1, m2) { 使用m1 / m2 }) RequireJS：是AMD的实现 http://www.requirejs.org/\nhttp://www.ruanyifeng.com/blog/2012/11/require_js.html\nRequireJS的使用举例（自定义模块） 1、创建项目结构 在工程文件中新建如下目录：\n1 2 3 4 5 6 7 8 9 js | libs | modules | alerter.js | dataService.js | main.js index.html 所有的代码写完之后，项目结构如下：\n2、下载require.js，并导入 官网: http://requirejs.org/docs/download.html\nGitHub：https://github.com/requirejs/requirejs\n在官网下载require.js文件：\n然后将require.js文件拷贝到项目的js/libs/目录中。\n这样的话，就导入成功了。\n3、自定义模块 （1）dataService.js：\n1 2 3 4 5 6 7 8 9 10 //定义没有依赖的模块 define(function () { let name = \u0026#39;我是 dataService.js中的内容\u0026#39;; function getName() { return name; } //暴露模块 return { getName }; }); 这模块没有依赖。\n（2）alerter.js：\n1 2 3 4 5 6 7 8 9 10 11 12 //定义有依赖的模块 define([\u0026#39;myDataService\u0026#39;], function (dataService) { let msg = \u0026#39;我是 aleter.js中的内容\u0026#39;; function showMsg() { console.log(dataService.getName()); //调用了 myDataService 模块中的内容 console.log(msg); } //暴露模块 return { showMsg }; }); 这个模块，依赖了myDataService这个模块，模块名是我自己起的。稍后，我们会在main.js中做映射，将myDataService这个名字和dataService.js文件关联起来。\n（3）main.js：\n这个是主模块。\n1 2 3 4 5 6 7 8 9 10 11 requirejs.config({ //baseUrl: \u0026#39;js/\u0026#39;, //基本路径 paths: { //配置路径 myDataService: \u0026#39;./modules/dataService\u0026#39;, myAlerter: \u0026#39;./modules/alerter\u0026#39; } }); requirejs([\u0026#39;myAlerter\u0026#39;], function (alerter) { alerter.showMsg(); })(); 这个模块，依赖了myAlerter这个模块，模块名是我自己起的。并且，我们在文件的上方做了映射，将myAlerter这个名字和alerter.js文件关联了起来。\n我们来讲一下最上方的几行代码（即requirejs.config里的内容）的意思：\n我们可以看到，文件（3）依赖了文件（2），文件（2）依赖了文件（1）。\npaths里做的就是映射：将键myDataService和文件dataService.js进行关联，将键myAlerter和文件alerter.js进行关联。\n另外，再讲一下注释里的baseUrl的用法：如果没有这个注释，那么paths里的路径，是从当前这个文件（main.js）的角度出发的；如果加了一行baseUrl，表明它是 paths 里所有路径的最开头的部分，baseUrl的路径是从项目的根目录的角度出发的。\n（4）index.html：\n这个是入口文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 先通过 src 引入 require.js 文件，然后通过 data-main 引入主模块（main.js） --\u0026gt; \u0026lt;script data-main=\u0026#34;js/main.js\u0026#34; src=\u0026#34;js/libs/require.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意，上面的代码中，我们直接通过src属性引入requre.js 文件，一旦这个文件发挥作用了，会去找data-main属性里的指向，它正好指向的是主模块。\n有了上面这种引入的方式，我们就不用再老土地引入多个\u0026lt;script\u0026gt;标签了。\n运行 index.html，打印结果如下：\n项目源码：2018-04-11-RequireJSDemo\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/javascript%E6%A8%A1%E5%9D%97%E5%8C%96amd/","summary":"AMD的基本语法 AMD的概念 AMD（Asynchronous Module Definition）：异步模块定义。AMD专门用于浏览器端，模块的加载是异步","title":"JavaScript模块化：AMD"},{"content":"CMD的基本语法 CMD的概念 CMD（Common Module Definition）：同步模块定义。CMD专门用于浏览器端，模块的加载是同步的。模块在使用时才会加载执行。\nCMD规范：是 SeaJS 在推广过程中对模块化定义的规范化产出。\nSeaJS SeaJS：一个基于CMD规范实现的模块化开发解决方案。\n官网链接：\nhttp://seajs.org/\nhttps://github.com/seajs/seajs\n推荐学习链接：\nhttp://www.zhangxinxu.com/sp/seajs/\nhttp://es6.ruanyifeng.com/#docs/module\n暴露模块的方式 不管是定义没有依赖的模块，还是定义有依赖的模块，参数只有一个，那就是 function。\n定义没有依赖的模块：\n1 2 3 4 5 6 7 8 define(function (require, exports, module) { exports.xxx = value //暴露模块 module.exports = value }) 参数只有一个，那就是 function。function 里有三个参数：\n定义有依赖的模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //定义有依赖的模块 define(function (require, exports, module) { //引入依赖的模块(同步的方式) var module2 = require(\u0026#39;./module2\u0026#39;) //引入依赖的模块(异步的方式) require.async(\u0026#39;./module3\u0026#39;, function (m3) { }) //暴露模块 exports.xxx = value }) 上面的代码可以看到，在引入依赖的模块时，有两种引入的方式：同步和异步。\n引入模块的方式 1 2 3 4 5 6 7 8 define(function (require) { var m1 = require(\u0026#39;./module1\u0026#39;) var m4 = require(\u0026#39;./module4\u0026#39;) m1.show() m4.show() }) SeaJS的使用举例（自定义模块） 1、创建项目结构 在工程文件中新建如下目录：\n1 2 3 4 5 6 7 8 9 10 js | libs | sea.js | modules | module1.js | module2.js | module3.js | module4.js | main.js //主模块 index.html 2、下载SeaJS，并导入 官网: https://seajs.github.io/seajs/docs/#downloads\nGitHub：https://github.com/seajs/seajs\n在官网下载sea.js文件，然后将其拷贝到项目的js/libs/目录中。这样的话，就导入成功了。\n3、自定义模块 （1）module1.js：\n1 2 3 4 5 6 7 8 9 10 //定义没有依赖的模块 define(function (require, exports, module) { let name = \u0026#39;我是 module1 中的内容\u0026#39;; function foo1() { return name; } //暴露模块 module.exports = { foo1 }; //暴露出去的是 foo1这个函数对象 }); （2）module2.js：\n1 2 3 4 5 6 7 8 9 10 //定义没有依赖的模块 define(function (require, exports, module) { let name = \u0026#39;我是 module2 中的内容\u0026#39;; function foo2() { console.log(name); } //暴露模块 module.exports = foo2; //可以理解成：exports就是 foo2 这个函数 }); （3）module3.js:\n1 2 3 4 5 6 7 8 9 10 //定义没有依赖的模块 define(function (require,exports,module) { let data = \u0026#39;我是 module3 中的内容\u0026#39;; function foo3() { console.log(data); } //暴露模块 exports.module3 = { foo3 }; //可以理解成：给 export 对象暴露了 module3 这个属性，这个属性里有foo3 这个函数。 }); （4）module4.js：\n这个模块依赖了 module2 和 module3。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //定义有依赖的模块 define(function (require, exports, module) { let name = \u0026#39;我是 module4 中的内容\u0026#39;; //同步的方式引入 module2 let myModule2 = require(\u0026#39;./module2\u0026#39;); myModule2(); //异步的方式引入 module3 require.async(\u0026#39;./module3\u0026#39;, function (myModule3) { myModule3.module3.foo3(); }); function foo4() { console.log(name); } exports.foo4 = foo4; }) （5）main.js：\nmodule1.js没有依赖其他的模块，它是独立的\nmodule4.js依赖了module2和module3。\n因此，让main.js依赖module1.js和module4就够了。\nmain.js：\n1 2 3 4 5 6 7 8 9 10 11 12 //主模块（主模块不需要导出） define(function (require) { //导入 module1 let module1 = require(\u0026#39;./module1\u0026#39;); console.log(module1.foo1()); //执行foo1函数后，将返回值打印 //导入 module4 let module4 = require(\u0026#39;./module4\u0026#39;); module4.foo4(); }); （6）index.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入 sea.js库 --\u0026gt; \u0026lt;script src=\u0026#34;js/libs/sea.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 引入主模块 seajs.use(\u0026#39;./js/modules/main.js\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\nothers SeaJS 的介绍 SeaJS：一个基于CMD规范实现的模块化开发解决方案。\n作者：Alibaba 玉伯。\n官网：http://seajs.org/\nGitHub：https://github.com/seajs/seajs\n现在官网变成了：https://seajs.github.io/seajs/docs/\n特性：\n简单友好的模块定义规范。\n自然直观的代码组织方式。\nRequireJS（AMD）、SeaJS（CDM）、CommonJS、ES6 的对比 1、RequireJS 和 AMD：\n异步模块定义，特点是依赖前置。\n2、SeaJS 和 CMD：\n同步模块定义。\n1 2 3 4 5 6 7 8 9 // 所有模块都通过 define 来定义 define(function(require, exports, module) { //通过 require 引入依赖 var $ require(`jquery`); var Spinning = require(`./spinning`); }) 3、CommonJS：\n以上三个都是 ES5里面的规范。\n4、ES6：\nES6的特性：export/import\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/javascript%E6%A8%A1%E5%9D%97%E5%8C%96cmd/","summary":"CMD的基本语法 CMD的概念 CMD（Common Module Definition）：同步模块定义。CMD专门用于浏览器端，模块的加载是同步的。模块在使","title":"JavaScript模块化：CMD"},{"content":"模块化开发的引入 JS开发的弊端 JS 在使用时存在两大问题，而 Node.js 可以很好地避免这两个问题：\n文件依赖。比如 a 文件依赖 b 文件，b 文件依赖 c 文件。而 Node.js 中的文件依赖，不需要人工维护和人为分析。\n命名冲突。js 的各个文件是相互开放的，容易导致命名冲突。而 Node.js 是属于半封闭的状态，可以指定哪些内容是开放的，哪些内容是封闭的。\nNode.js 在解决这两个问题时，用到的就是模块化开发。\n软件开发中的模块化开发 一个功能就是一个模块，多个模块可以组成完整的应用，抽离一个模块不会影响其他功能的运行。\n效果如下：\nNode.js 中的模块化开发 Node.js 规定，一个 JS 文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法访问。\n模块内部可以使用 exports 对象进行成员导出， 使用 require 方法导入其他模块。效果如下：\nES6模块化的基本语法 ES6模块化的说明 依赖模块需要编译打包处理。原因如下：\n（1）有些浏览器不支持 ES6 的语法，写完 ES6 的代码后，需要通过Babel将 ES6 转化为 ES5。\n（2）生成了ES5之后，里面仍然有require语法，而浏览器并不认识require这个关键字。此时，可以用 Browserify编译打包 js，进行再次转换。\n推荐学习链接：\nhttp://es6.ruanyifeng.com/#docs/module 基本语法： 导出模块：\n1 export 引入模块：\n1 import xxx from \u0026#39;路径\u0026#39; ES6模块化的使用举例（自定义模块） 1、初始化项目 （1）在工程文件中新建如下目录：\n1 2 3 4 5 6 7 8 9 js | src | module1.js | module2.js | module3.js | main.js index.html （2）在工程的根目录下，新建文件package.json，内容如下：\n1 2 3 4 { \u0026#34;name\u0026#34;: \u0026#34;es6-babel-browserify\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34; } 2、环境配置：安装babel 和 browserify等 （1）安装babel 和 browserify：\n1 2 3 4 5 npm install babel-cli -g npm install babel-preset-es2015 --save-dev npm install browserify -g 安装 babel 的详细解释，可以参考本人的另外一篇文章：ES6的介绍和环境配置\n（2）新建.babelrc：\n在根目录下新建文件.babelrc，输入如下内容：\n1 2 3 4 5 6 { \u0026#34;presets\u0026#34;:[ \u0026#34;es2015\u0026#34; ], \u0026#34;plugins\u0026#34;:[] } 3、编写代码 （1）module1.js：\n1 2 3 4 5 6 7 8 9 10 11 //暴露模块：采用分别暴露的方式 export function foo1() { console.log(\u0026#39;我是 module1 中的 foo1\u0026#39;); } export function foo2() { console.log(\u0026#39;我是 module2 中的 foo2\u0026#39;); } export let arr = [1, 2, 3, 4, 5]; （2）module2.js：\n1 2 3 4 5 6 7 8 9 10 11 12 //暴露模块：采用统一暴露的方式 function fn1() { console.log(\u0026#39;我是 module2 中的 fn1\u0026#39;); } function fn2() { console.log(\u0026#39;我是 module2 中的 fn2\u0026#39;); } //统一暴露 export { fn1, fn2 }; （3）module3.js：\n1 2 3 4 5 6 7 //暴露模块：采用默认暴露的方式。 //默认暴露的方式可以暴露任意数据类型，暴露的是什么数据，接收到的就是什么数据 //语法格式：export default value; export default () =\u0026gt; { console.log(\u0026#39;我是 module3 中 default 方式暴露的函数\u0026#39;); }; 这里，我们采取了一种新的暴露方式（默认暴露），在暴露时，加上了default这个关键字。代码里暴露了一个箭头函数，稍后，我们注意在main.js里是怎么引入module3.js的。\n注意，我们只能写一次 default，也就是说，只能进行一次默认暴露。\n（4）module4.js：（default方式暴露多个属性）\n1 2 3 4 5 6 7 8 9 10 //暴露模块：采用默认暴露的方式。 //默认暴露的方式可以暴露任意数据类型，暴露的是什么数据，接收到的就是什么数据 //语法格式：export default value; export default { name: \u0026#39;我是 module4 中 default 方式暴露的属性 name\u0026#39;, foo() { console.log(\u0026#39;我是 module4 中 default 方式暴露的函数 foo\u0026#39;); } } 这里，我们依旧采取了默认暴露的方式，只能写一次 default。代码里暴露了一个对象（对象里存放了一个属性、一个方法）。稍后，我们注意在main.js里是怎么引入module4.js的。\n如果我想暴露多个属性、多个对象怎呢？很简单，把你想要暴露的所有内容，都放在default里，包成一个对象。你看module4.js就是如此， 同时暴露了多个属性\u0026amp;方法。\n（5）main.js：\n这个是主模块。现在，我们来看一下，它如何引入上面的四个模块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //主模块。引入其他的模块 import { foo1, foo2 } from \u0026#39;./module1\u0026#39;; //采用解构赋值的形式进行导入。注意，括号里的对象名，要和 module1 中的对象名一致。 import { fn1, fn2 } from \u0026#39;./module2\u0026#39;; //采用解构赋值的形式进行导入。注意，括号里的对象名，要和 module2 中的对象名一致。 import myModule3 from \u0026#39;./module3\u0026#39;; //module3 模块是采用 default 方式进行暴露的，myModule3 这个名字是我随便起的 import myModule4 from \u0026#39;./module4\u0026#39;; //module4 模块是采用 default 方式进行暴露的，myModule4 这个名字是我随便起的 //调用module1、module2中的内容 foo1(); foo2(); fn1(); fn2(); //调用module3中的内容 myModule3(); //调用module4中的内容 console.log(myModule4.name); //module4中的属性 myModule4.foo(); //module4中的方法 我们可以看出：（具体请看注释，非常重要）\nmodule1和module2是采用常规暴露的形式，在引入它们时，模块名要一致。而且，要求用对象解构赋值的形式，而不是用 import myModule from ...这种形式（否则会报错 undefined）。\nmodule2和module3是采用默认暴露的形式，在引入它们时，模块名随便起。\n（6）index.html：\n在这里引入main.js即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;dist/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4、编译转换 如果我们不进行转换，而是直接在 index.html 中加载 js/src/main.js，是会报错的：\n接下来，我们就进行转换。\n（1）利用 babel 将 ES6 转换为 ES5：\n1 babel src -d build //build目录会自动生成 上方命令的意思是，将src目录下的所有ES6文件转化为ES5文件，并放在build目录下（build目录会被自动创建）。\n转化成ES5之后，我们发现，如果直接在 index.html 中加载build目录下的ES5文件，也是会报错的，因为浏览器不认识main.js里的require关键字：\n于是，我们还要进行一次转换。\n（2）利用Browserify编译打包 build目录下的 ES5 文件：\n1 browserify build/main.js -o dist/main.js //dist目录需要手动创建 dist/main.js就是我们需要引入到 index.html 里的文件。\n以后，我们每次修改完ES6的代码，就要执行上面的两个命令，重新生成新的js文件。\n运行效果：\n工程文件：\n2018-04-13-ES6Demo.rar ES6模块化的使用举例（引入第三方模块） 下载 jQuery 包：\n1 npm install jquery@1 //下载jQuery 1.X 的版本里最新的 在main.js 中引入上面的 jQuery：\n1 import $ from \u0026#39;jQuery\u0026#39;; 然后我们就可以通过$这个符号去写jQuery的代码了。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/javascript%E6%A8%A1%E5%9D%97%E5%8C%96es6/","summary":"模块化开发的引入 JS开发的弊端 JS 在使用时存在两大问题，而 Node.js 可以很好地避免这两个问题： 文件依赖。比如 a 文件依赖 b 文件，b 文件依赖 c 文件。而 Node.js 中","title":"JavaScript模块化：ES6"},{"content":" 本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。\n以下是正文。\nCSS 预处理器 为什么要有 CSS 预处理器 CSS基本上是设计师的工具，不是程序员的工具。在程序员的眼里，CSS是很头痛的事情，它并不像其它程序语言，比如说PHP、Javascript等等，有自己的变量、常量、条件语句以及一些编程语法，只是一行行单纯的属性描述，写起来相当的费事，而且代码难以组织和维护。\n很自然的，有人就开始在想，能不能给CSS像其他程序语言一样，加入一些编程元素，让CSS能像其他程序语言一样可以做一些预定的处理。这样一来，就有了“CSS预处器（CSS Preprocessor）”。\n什么是 CSS 预处理器 是 CSS 语言的超集，比CSS更丰满。 CSS 预处理器定义了一种新的语言，其基本思想是：用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。\n通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。\nCSS预处理器技术已经非常成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：Sass（SCSS）、LESS、Stylus、Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、CSS-Trick、知乎以及各大技术论坛上，很多人为此争论不休。相比过去我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。\n到目前为止，在众多优秀的CSS预处理器语言中就属Sass、LESS和Stylus最优秀，讨论的也多，对比的也多。本文将分别从他们产生的背景、安装、使用语法、异同等几个对比之处向你介绍这三款CSS预处理器语言。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器。\nless 的介绍 less 是一款比较流行的预处理 CSS，支持变量、混合、函数、嵌套、循环等特点。\n官网\n中文网（less 文档）\nBootstrap网站的 less 文档\n推荐文章：http://www.w3cplus.com/css/less\nless 的语法 注释 less 的注释可以有两种。\n第一种注释：模板注释\n1 // 模板注释 这里的注释转换成CSS后将会删除 因为 less 要转换为 css才能在浏览器中使用。转换成 css 之后，这种注释会被删除（毕竟 css 不识别这种注释）。\n第二种注释：CSS 注释语法\n1 2 /* CSS 注释语法 转换为CSS后让然保留 */ 总结：如果在less中写注释，我们推荐写第一种注释。除非是类似于版权等内容，就采用第二种注释。\n定义变量 我们可以把重复使用或经常修改的值定义为变量，在需要使用的地方引用这个变量即可。这样可以避免很多重复的工作量。\n（1）在less文件中，定义一个变量的格式：\n1 2 3 @变量名: 变量值; //格式 @bgColor: #f5f5f5; //格式举例 （2）同时，在 less 文件中引用这个变量。\n最终，less文件的完整版代码如下：\nmain.less：\n1 2 3 4 5 6 7 // 定义变量 @bgColor: #f5f5f5; // 引用变量 body{ background-color: @bgColor; } 我们将上面的less文件编译为 css 文件后（下一段讲less文件的编译），自动生成的代码如下：\nmain.css：\n1 2 3 body{ background-color: #f5f5f5; } 使用嵌套 在 css 中经常会用到子代选择器，效果可能是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .container { width: 1024px; } .container \u0026gt; .row { height: 100%; } .container \u0026gt; .row a { color: #f40; } .container \u0026gt; .row a:hover { color: #f50; } 上面的代码嵌套了很多层，写起来很繁琐。可如果用 less 的嵌套语法来写这段代码，就比较简洁。\n嵌套的举例如下：\nmain.less:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 .container { width: @containerWidth; \u0026gt; .row { height: 100%; a { color: #f40; \u0026amp;:hover { color: #f50; } } } div { width: 100px; .hello { background-color: #00f; } } } 将上面的less文件编译为 css 文件后，自动生成的代码如下：\nmain.css\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 .container { width: 1024px; } .container \u0026gt; .row { height: 100%; } .container \u0026gt; .row a { color: #f40; } .container \u0026gt; .row a:hover { color: #f50; } .container div { width: 100px; } .container div .hello { background-color: #00f; } Mixin Mixin 的作用是把重复的代码放到一个类当中，每次只要引用类名，就可以引用到里面的代码了，非常方便。\n（1）在 less 文件中定义一个类：（将重复的代码放到自定义的类中）\n1 2 3 4 5 6 /* 定义一个类 */ .roundedCorners(@radius: 5px) { -moz-border-radius: @radius; -webkit-border-radius: @radius; border-radius: @radius; } 上方代码中，第一行里面，括号里的内容是参数：这个参数是缺省值。\n（2）在 less 文件中引用上面这个类：\n1 2 3 4 5 6 #header { .roundedCorners; } #footer { .roundedCorners(10px); } 上方代码中，header 中的引用没有带参数，表示参数为缺省值； footer 中的引用带了参数，那就用这个参数。\nImport 在开发阶段，我们可以将不同的样式放到多个文件中，最后通过@import 的方式合并。意思就是，当出现多个 less 文件时，怎么引用它们。\n这个很好理解， css 文件可以有很多个，less文件也可以有很多个。\n（1）定义一个被引用的less文件，名为_button1.less：\n_button1.less:\n1 2 3 4 .btn{ line-height: 100px; color: @btnColor; } PS1：被引用的less文件，我们习惯在前面加下划线，表示它是部分文件。\nPS2：_button1.less里可以引用main.css里的自定义变量。\n（2）在 main.css 中引用上面的 _button1.less：（代码的第二行）\nmain.css：\n1 2 3 4 5 6 7 @btnColor: red; @import url(`_button1.less:\u0026#39;); //这里的路径写的是相对路径 body{ width: 1024px; } 将 上面的main.less 编译为 main.css之后，自动生成的代码如下：\n1 2 3 4 5 6 7 8 .btn { line-height: 100px; color: red; } body { width: 1024px; } 内置函数 less 里有一些内置的函数，这里讲一下 lighten 和 darken 这两个内置函数。\nmain.less:\n1 2 3 4 body { background-color: lighten(#000, 10%); // 让黑色变亮 10% color: darken(#fff, 10%); // 让白色变暗 10% } 将 上面的 main.less 编译为 main.css 之后，自动生成的代码如下：\nmain.css：\n1 2 3 4 body { background-color: #1a1a1a; color: #e6e6e6; } 如果还有什么不懂的，可以看 api 文档，在上面的第二段附上了链接。\n在 index.html中直接引用 less.js 做法一：写完 less文件后，将其编译为 css 文件，然后在代码中引用css文件。\n做法二：在代码中直接用引用 less 文件。\n产品上线后，当然是使用做法一，因为做法二会多出编译的时间。\n平时开发或演示demo的时候可以用做法二。\n这一段，我们讲一下做法二，其实是浏览器在本地在线地把 less 文件转换为 css 文件。\n（1）在 less 官网下载 less.js 文件：\n把下载好的文件放在工程文件的lib文件夹里：\n（2）在 index.html 中引入 less.js 和我们自己写的 main.less。位置如下：\ncopy 红框那部分的代码如下：\n1 \u0026lt;link rel=\u0026#34;stylesheet/less\u0026#34; href=\u0026#34;../main.less\u0026#34;\u0026gt; 我们可以在打开的网页中，通过控制台看到效果：\n注意，我们要在服务器中打开 html 文件，否则，看不到效果。\n这里也告诉了我们：\n不提倡将 less 引入页面，因为 less 需要编译，因此你就需要再引入一个less.js, 多了一个HTTP 请求，同时当浏览器禁用了 js 你的样式就不起作用了，less 编译应该在服务端或使用 grunt 自动编译。\n工程文件：（工程文件中，我引用的less.js版本是 2.5.3）\n2018-02-27-LessDemo.rar 参考链接：\n知乎 | less文件如何引入页面 less 的编译 less 的编译指的是将写好的 less 文件 生成为 css 文件。\nless 的编译，依赖于 NodeJS 环境。因此，我们需要先安装 NodeJS。\n1、安装 Node.js 去 Node.js的官网下载安装包：\n一路 next 进行安装。\n安装完成后，配置环境变量：\n在 path 变量中追加安装路径：;C:\\Program Files\\nodejs。重启资源管理器，即可生效。\nPS：我发现，我安装的 node.js v8.9.4 版本，已经自动添加了环境变量。\n在 cmd 命令行，输入node.exe -v，可以查看 node.js 的版本。\n2、安装 less 的编译环境 将 npm.zip 解压，将解压后的文件拷贝到路径C:\\Users\\smyhvae\\AppData\\Roaming\\npm下：\n然后重启资源管理器（或者重启电脑）。在 cmd 中输入 lessc，如果能看到下面的效果，说明 less编译环境安装成功：\n如果你用的是 linux 系统，可以输入下面的命令安装：\n1 npm install -g less 3、将 less 文件编译为 css 文件 在 less 所在的路径下，输入 lessc xxx.less，即可编译成功。或者，如果输入 lessc xxx.less \u0026gt; ..\\xx.css，表示输出到指定路径。\n","permalink":"https://bablvsj.github.io/posts/interview/css/03-less%E8%AF%A6%E8%A7%A3/","summary":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 CSS 预处理器 为什么","title":"Less详解"},{"content":"浏览器本地存储\n在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 web storage和cookie的区别\nWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用 除此之外，WebStorage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 cookie 和session 的区别：\n1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\n考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n5、所以个人建议：\n将登陆信息等重要信息存放为SESSION\n其他信息如果需要保留，可以放在COOKIE中\n描述 cookies、sessionStorage 和 localStorage 的区别？\n与服务器交互：\ncookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密） cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存 存储大小：\ncookie 数据根据不同浏览器限制，大小一般不能超过 4k sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，与浏览器是否关闭无关 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/localstorage/","summary":"浏览器本地存储 在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localSto","title":"localStorage"},{"content":"MySQL 的一些简单命令 我们可以在 Navicat Premium 软件中，创建数据库和表，然后输入查询命令来查询数据。选择菜单栏「查询-\u0026gt;新建查询-\u0026gt;输入 sql 命令-\u0026gt;运行」即可，效果如下：\n我们还可以直接在终端输入命令行来操作。\n注意，在 Mac 终端执行 sql 命令时，命令的末尾必须加上;（英文格式的分号）。效果如下：\nMySQL 命令行的一些简单命令如下。\n以 root 身份进入命令行：\n1 mysql -u root -p 查看有哪些数据库：\n1 show databases; 选择进入指定的数据库：\n1 2 3 4 use xxx_database; # 举例 use qianguyihao_database; 在当前数据库中，查看有哪些表：\n1 show tables; 在当前数据库中，查询指定表的全部数据：\n1 2 3 4 SELECT * FROM xxx_table; # 举例 SELECT * FROM qianguyihao_student_table 删除指定的表：\n1 2 3 4 drop table xxx; # 举例 drop table qianguyihao_student_table; 删除指定的数据库：\n1 drop database qianguyihao_student_table; 创建一个数据库：\n1 create database qianguyihao_database2; where 条件查询 使用 where 子句可以对表中的数据进行筛选，结果为 true 的行会出现在查询结果中。\n语法格式如下：\n1 SELECT * FROM 表名 where 条件; 上面的语法格式中，条件 具体要怎么写呢？这个可能有很多种情况。我们继续往下看。\n比较运算符 = 等于 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 !=：不等于 age \u0026gt; 20：查询 age 大于 30 的数据 举例：\n1 2 # 查询 age 大于 20 的数据 SELECT * FROM qianguyihao_table WHERE age \u0026gt; 20; 逻辑运算符 AND\nOR\nNOT\n举例：\n1 2 # 查询 age 在20至30之间的数据 SELECT * FROM qianguyihao_table WHERE age BETWEEN 20 AND 30; 范围查询 in 表示在一个非连续的范围内。\nbetween ... and ... 表示在一个连续的范围内\n举例：\n1 2 3 4 # 查询 name 为 lvbu 或者 许嵩的数据 SELECT * FROM qianguyihao_table WHERE name IN [\u0026#39;lvbu\u0026#39;, \u0026#39;许嵩\u0026#39;]; SELECT * FROM qianguyihao_table WHERE age BETWEEN 20 AND 30; 模糊查询 like % 表示任意多个任意字符 _ 表示一个任意字符 % 符号举例：\n1 2 3 4 5 # 查询标题中包含“前端”这两个字的数据（“前端”这两个字的前后可能都有内容） select * from qianguyihao_table where `title` like \u0026#34;%前端%\u0026#34;; # 查询标题以“前端”开头的数据 select * from qianguyihao_table where `title` like \u0026#34;前端%\u0026#34;; _符号举例：\n1 2 # 查询标题，查询条件是：标题中至少有五个字符，而且，这五个字符中，前两个字符一定是“千古”开头的。 SELECT * FROM qianguyihao_table WHERE `title` LIKE \u0026#34;千古___\u0026#34;; NULL 的判断 is null 判断为空\nis not null 判断为非空\n注意，is null 和空字符串\u0026quot;\u0026quot; 是有区别的。学过 js 基础之后，你应该知道：空字符串并非 null，只不过是里面的值为空而已；空字符串也是会占有内存空间的。\n举例：\n1 select * from qianguyihao_table where name is not NULL; join 联表查询 联表查询命令 tableA inner join tableB：表 A 与表 B 匹配的行会出现在结果中。\ntableA left join tableB：表 A 与表 B 匹配的行会出现在结果中。表 A 中独有的数据，对应表 B 中用 null 填充。\ntableA right join tableB：表 A 与表 B 匹配的行会出现在结果中。表 B 中独有的数据，对应表 A 中用 null 填充。\n光是这样看，不好理解，我们来举个例子。\n举例 现在有下面这两张表：作者表 author、图书表 book。\n表 1、作者表 author：\nid authorId authorName 1 11 王小波 2 12 吴军 3 88 lvbu 表 2、图书表 book：\nid bookId bookName authorId 1 201 黄金时代 11 2 202 白银时代 11 3 203 青铜时代 11 4 204 浪潮之巅 12 5 205 硅谷之谜 12 6 206 数学之美 12 7 777 设计心理学 99 注意，表2中的每本图书都有对应的 authorId，这个 authorId 就是对应表1中的 authorId。通过 authorId 把两张表关联起来。\n通过联表查询上面的两张表，我们来对比一下查询结果。\n情况 0：（inner join）\n1 SELECT * FROM author INNER JOIN book; 查询结果：\n上面这种查询，没有意义，因为没有加任何查询条件。\n情况 1：（inner join）\n1 SELECT * FROM author INNER JOIN book ON author.authorId = book.authorId; 查询结果：\n上面这行命令，跟下面这行命令等价：\n1 SELECT * FROM author, book WHERE author.authorId = book.authorId; 情况 2：（left join）\n1 SELECT * FROM author LEFT JOIN book ON author.authorId = book.authorId; 查询结果：\n情况 3：（right join）\n1 SELECT * FROM author RIGHT JOIN book ON author.authorId = book.authorId; 查询结果：\n参考链接 Mysql 联表查询 自关联查询 涉及到层级关系时可以用自关联查询。\n子查询 当一个查询结果是另一个查询的条件时，这个查询称之为子查询。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"MySQL 的一些简单命令 我们可以在 Navicat Premium 软件中，创建数据库和表，然后输入查询命令来查询数据。选择菜单栏「查询-\u0026gt;新建查询-\u0026gt;输入 sql 命令-\u0026","title":"MySQL数据库的常用命令"},{"content":"前言 范式即规范。MySQL 范式的作用是：\n让我们建的表更佳简洁和高效。\n让功能独立化，避免耦合。\nMySQL 设计三大范式 第一范式（1NF）：原子性 表的每一列具有原子性，不可再分。\n第二范式：唯一性 第二范式是建立在第一范式基础上的；外要求所有非主键字段必须完全依赖主键，而不是部分依赖。\n第三范式 第三范式是建立在第二范式基础上的；且要求没有传递依赖。\n参考链接 MySql\u0026ndash;数据库设计三范式 ","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/","summary":"前言 范式即规范。MySQL 范式的作用是： 让我们建的表更佳简洁和高效。 让功能独立化，避免耦合。 MySQL 设计三大范式 第一范式（1NF）：原子性 表的每一","title":"MySQL设计三大范式"},{"content":"在 Node.js 上建一个 http 服务器 （1）新建一个文件 server01.js，然后在里面输入如下代码：\n1 2 3 4 5 6 7 8 9 10 const http = require(\u0026#39;http\u0026#39;); //引入 node.js里面的一个http包。因为引入之后，我们不会去修改它，所以用常量来表示 // 创建一台服务器 var server = http.createServer(function (){ //当有人来访问这台服务器时，就会执行 function 回调函数 console.log(\u0026#39;有人来访问我了\u0026#39;); }); server.listen(8080); //要让服务器设置为监听状态，端口设置为8080 注意看注释。\n我们把上面这个 js 文件跑起来，然后在浏览器端输入http://localhost:8080/，每请求一次，服务器的控制台就会打印 有人来访问我了。\n（2）write()函数和 end()函数：\n将上面的代码修改如下：\nserver02.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 const http = require(\u0026#39;http\u0026#39;); // 创建一台服务器 var server = http.createServer(function (request, response) { //当有人来访问这个服务器时，就会执行function 这个回调函数 console.log(\u0026#39;有人来访问我了\u0026#39;); response.write(\u0026#39;smyhvae\u0026#39;); //向浏览器输出内容 response.end(); //结束了，浏览器你走吧。 }); server.listen(8080); function 回调函数里可以设置两个参数：request 和 response。response.write()表示向浏览器输出一些内容。\n将上面的 js 代码跑起来，产生的问题是，无论我们在浏览器端输入http://localhost:8080/1.html，还是输入http://localhost:8080/2.jpg，浏览器上显示的都是smyhvae。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/node.js%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/","summary":"在 Node.js 上建一个 http 服务器 （1）新建一个文件 server01.js，然后在里面输入如下代码： 1 2 3 4 5 6 7 8 9 10 const http = require(\u0026#39;http\u0026#39;); //引入 node.js里面","title":"Node.js代码举例"},{"content":"1、姓名组件 hello lvsijun ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //组件名称必须以大写字母开头。React 会将以小写字母开头的组件视为原生 DOM 标签 //例如，\u0026lt;div /\u0026gt; 代表 HTML 的 div 标签，而 \u0026lt;Welcome /\u0026gt; 则代表一个组件，并且需在作用域内使用 Welcome。 function FormatName(user) { return \u0026lt;h1\u0026gt;Hello , {user.firstName}{user.lastName} !\u0026lt;/h1\u0026gt; } function tick() { const element = ( \u0026lt;div\u0026gt; \u0026lt;FormatName firstName=\u0026#34;Lv\u0026#34; lastName=\u0026#34;SiJun\u0026#34; /\u0026gt; \u0026lt;h2\u0026gt;It is {new Date().toLocaleTimeString()}.\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); ReactDOM.render(element, document.getElementById(\u0026#39;root\u0026#39;)); } setInterval(tick, 1000); 2、封装嵌套个人信息组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 function Comment(props) { return ( \u0026lt;div className=\u0026#34;Comment\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;UserInfo\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;Avatar\u0026#34; src={props.author.avatarUrl} alt={props.author.name} /\u0026gt; \u0026lt;div className=\u0026#34;UserInfo-name\u0026#34;\u0026gt; {props.author.name} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;Comment-text\u0026#34;\u0026gt; {props.text} \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;Comment-date\u0026#34;\u0026gt; {formatDate(props.date)} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } function Comment(props) { return ( \u0026lt;div className=\u0026#34;Comment\u0026#34;\u0026gt; \u0026lt;UserInfo user={props.author}/\u0026gt; \u0026lt;div className=\u0026#34;Comment-text\u0026#34;\u0026gt; {props.text} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } function Avatar(props) { return ( \u0026lt;img className=\u0026#34;Avatar\u0026#34; src={props.user.avatarUrl} alt={props.user.name} /\u0026gt; ); } function UserInfo(props) { return ( \u0026lt;div className=\u0026#34;UserInfo\u0026#34;\u0026gt; \u0026lt;Avatar user={props.user} /\u0026gt; \u0026lt;div className=\u0026#34;UserInfo-name\u0026#34;\u0026gt; {props.user.name} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } 3、class封装clock组件 开始使用state 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Clock extends React.Component{ constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount(){ //组件初始化之后 this.timerClock = setInterval(()=\u0026gt; this.tick() ,1000) } componentWillUnmount(){//组件销毁前 clearInterval(this.timerClock) } tick() { this.setState({ date: new Date() }); } render(){ return \u0026lt;h2\u0026gt;It is {this.state.date.toLocaleTimeString()}.\u0026lt;/h2\u0026gt;; } } 正确地使用 State 关于 setState() 你应该了解三件事： 不要直接修改 State 例如，此代码不会重新渲染组件： // Wrong this.state.comment = \u0026#39;Hello\u0026#39;; 而是应该使用 setState(): // Correct this.setState({comment: \u0026#39;Hello\u0026#39;}); 构造函数是唯一可以给 this.state 赋值的地方： 4、组件添加点击事件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Taggle extends React.Component{ constructor(props) { super(props); this.state = {isToggleOn: true}; // 为了在回调中使用 `this`，这个绑定是必不可少的 // this.handleClick = this.handleClick.bind(this); } handleClick() { console.log(\u0026#39;this is:\u0026#39;, this); this.setState(state =\u0026gt; ({ isToggleOn: !state.isToggleOn })); } render(){ return ( // this.handleClick.bind(this) // (e) =\u0026gt; this.handleClick(e) \u0026lt;button onClick={(e) =\u0026gt; this.handleClick(e)}\u0026gt; {this.state.isToggleOn ? \u0026#39;ON\u0026#39; : \u0026#39;OFF\u0026#39;} \u0026lt;/button\u0026gt; ) } } 5、条件判断 登录退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 function IsLogin(props){ if(props.isLoggedIn){ return \u0026lt;h1\u0026gt;Wellcome Back !\u0026lt;/h1\u0026gt; }else{ return \u0026lt;h2\u0026gt;Give Me Five !\u0026lt;/h2\u0026gt; } } function LogoutButton(props){ return (\u0026lt;button onClick={props.onClick}\u0026gt; Logout \u0026lt;/button\u0026gt;) } function LoginButton(props){ return (\u0026lt;button onClick={props.onClick}\u0026gt; LoginButton \u0026lt;/button\u0026gt;) } class LoginControl extends React.Component{ constructor(props){ super(props); this.state= {isLoggedIn:false} } handleLoginClick(){ this.setState({isLoggedIn: true}); } handleLogoutClick(){ this.setState({ isLoggedIn:false }) } render(){ const isLoggedIn = this.state.isLoggedIn; let button; if (isLoggedIn) { button = \u0026lt;LogoutButton onClick={this.handleLogoutClick.bind(this)} /\u0026gt;; } else { button = \u0026lt;LoginButton onClick={(e)=\u0026gt;this.handleLoginClick(e)} /\u0026gt;; } return ( \u0026lt;div\u0026gt; {button} \u0026lt;IsLogin isLoggedIn={isLoggedIn} /\u0026gt; \u0026lt;/div\u0026gt; ) } } 自上而下或者自下而上构建应用：\n自上而下 意味着首先编写层级较高的组件（比如 FilterableProductTable），适用于简单应用。\n自下而上 意味着从最基本的组件开始编写（比如 ProductRow）。适用较为大型项目，同时为低层组件编写测试是更加简单的方式。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/react/","summary":"1、姓名组件 hello lvsijun ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //组件名称必须以大写字母开头。React 会将以小写字母开头的组件视为原生 DOM 标签 //例如","title":"react"},{"content":"前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 如何做SEO优化?\n标题与关键词 设置有吸引力切合实际的标题，标题中要包含所做的关键词 网站结构目录 最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布 页面元素 给图片标注\u0026quot;Alt\u0026quot;可以让搜索引擎更友好的收录 网站内容 每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢 友情链接 对方一定要是正规网站，每天有专业的团队或者个人维护更新 内链的布置 使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接 流量分析 通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/seo/","summary":"前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要","title":"SEO"},{"content":"this this的作用 this可以帮我们简化很多代码。比如xiaoming.name、xiaoming.age可以直接写成this.name、this.age。\n特别是当我们不知道一个对象是什么，或者这个对象没有名字但又很想调用它的时候，就会使用到this对象。\n举例：\n遍历DOM对象，绑定click事件，调用当前点击的对象的id，而不是所有对象的id。 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; background-color: green; margin: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { var myDiv = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (var i = 0; i \u0026lt; myDiv.length; i++) { myDiv[i].onclick = function () { console.log(i); console.log(this.id); } } } \u0026lt;/script\u0026gt; \u0026lt;section\u0026gt; \u0026lt;div id=\u0026#34;div0\u0026#34;\u0026gt; div0\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt; div1\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div2\u0026#34;\u0026gt; div2\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div3\u0026#34;\u0026gt; div3\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div4\u0026#34;\u0026gt; div4\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 点击其中的任何一个元素后，i的打印结果是5。你可能会觉得很惊讶。我们来解释一下：\n当代码执行完毕后，i已经等于5了。因为一旦运行程序，for循环已经执行完了，此时i等于5。\n现在，我们尝试在 myDiv[i].onclick事件中写代码，如果打印：\n1 console.log(i); //打印结果为5 如果打印：\n1 console.log(myDiv[i].id); 上方这行代码，打印会报错，因为i=5；如果想打印每个div的id，应该这样写：\n1 console.log(this.id); 你看，this的作用，就体现出来了。\nPS：顺便提醒一下，上面的代码中，如果把var i改成let i，效果又完全不同了。参考链接：let和var在for循环中的表现\n全局作用域中的this 当一段代码在浏览器中执行时，所有的全局变量和对象都是在window对象上定义的。换而言之，所有的全局变量和对象都属于window对象。\nthis的定律 this关键字永远指向函数（方法）运行时的所有者。\n函数赋值给变量时，this指向window 比如：\n1 2 3 4 5 var foo1 = args.getInfo; foo1(); var foo2 = function(){}; foo2(); this都是指向window。\n以函数形式调用时，this永远都是window 以方法的形式调用时，this是调用方法的对象 解决闭包中的this指向问题 内部函数是可以访问到外部函数的变量的。\n方式一：直接通过父函数的名字访问\n方式二：如果不知道父函数的名字，在父函数里加一句_this = this，此时_this相当于父函数的名字。\n当this遇到一些特殊的函数时 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/this/","summary":"this this的作用 this可以帮我们简化很多代码。比如xiaoming.name、xiaoming.age可以直接写成this.name、th","title":"this"},{"content":"快捷键\n作用 IDEA 快捷键 VS Code 备注 复制当前行 Ctrl + D Shift + Alt + ↑↓ 使用很频繁 当前文件搜索 Ctrl + R Ctrl + F 非常实用 全局搜索内容 Ctrl + Shift + R Ctrl + Shift + F 不如上面的快捷键快 全局搜索文件 双击Shift / 格式化代码 Ctrl + Alt + L Shift + Alt + F ​\n前言 VS Code 软件实在是太酷、太好用了，越来越多的新生代互联网青年正在使用它。\n前端男神尤雨溪大大这样评价 VS Code：\n有一点你可能会感到惊讶：VS Code 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的 PC 客户端开发框架 Electron）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：\n任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。\nJeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n前端目前是处在春秋战国时代，各路英雄豪杰成为后浪，各种框架工具层出不穷，VS Code 软件无疑是大前端时代最骄傲的工具。\n如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VS Code 作为「主力开发工具」。这款软件是为前端同学量身定制的。\n如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VS Code 作为「代码编辑器」来使用，纵享丝滑。\n甚至是一些写文档、写作的同学，也经常把 VS Code 作为 markdown 写作工具，毫无违和感。\n退而求其次，即便你不属于以上任何范畴，你还可以把 VS Code 当作最简单的文本编辑器来使用，完胜 Windows 系统自带的记事本。\n写下这篇文章，是顺势而为。\n一、VS Code 的介绍 VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得很不错。\n微软有两种软件：一种是 VS Code，一种是其他软件。\nIDE 与 编辑器的对比 IDE 和编辑器是有区别的：\nIDE（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。\n编辑器：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。\n需要注意的是，VS Code 的定位是编辑器，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。\nVS Code 的特点 VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验，比如代码的智能提示、语法检查、图形化的调试工具、插件扩展、版本管理等。\n跨平台支持 MacOS、Windows 和 Linux 等多个平台。\nVS Code 的源代码以 MIT 协议开源。\n支持第三方插件，功能强大，生态系统完善。\nVS Code 自带了 JavaScript、TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。当然，其他的语言，你可以安装相应的扩展包插件，也会有智能提示。\n前端利器之争： VS Code 与 WebStorm 前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是 VS Code 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比：\n哪个更酷：显然 VS Code 更酷。\n内存占用情况：根据我的观察，VS Code 是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用，使用起来是不会有任何卡顿的感觉的。相比之下，IntelliJ IDEA 不仅非常占内存，而且还非常卡顿。如果你想换个既轻量级、又不占内存的编辑器，最好还是使用「Sublime Text」编辑器。\n使用比例：当然是 VS Code 更胜一筹。先不说别的，我就拿数据说话，我目前所在的研发团队有 200 人左右（120个后台、80个前端），他们绝大部分人都在用 VS Code 编码，妥妥的。\n所以，如果你以后还问这个问题，那就真有些掉底了。\nVS Code 的安装 VS Code 官网：https://code.visualstudio.com 二、崭露锋芒：VS Code 快捷键 VS Code 用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。\n任何工具，掌握 20%的技能，足矣应对 80% 的工作。既然如此，你可能会问：那就只保留 20% 的特性，不久可以满足 80%的用户了吗？\n但我想说的是：那从来都不是同样的 20%，每个人都会用到不同的功能。\n掌握下面这些高频核心快捷键，你和你的工具，足矣露出锋芒。\n1、工作区快捷键 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + P Ctrl + Shift + P，F1 显示命令面板 Cmd + B Ctrl + B 显示/隐藏侧边栏 很实用 Cmd + \\ Ctrl + \\ 创建多个编辑器 【重要】抄代码利器 Cmd + 1、2 Ctrl + 1、2 聚焦到第 1、第 2 个编辑器 同上重要 cmd +/- ctrl +/- 将工作区放大/缩小（包括代码字体、左侧导航栏） 在投影仪场景经常用到 Cmd + J Ctrl + J 显示/隐藏控制台 Cmd + Shift + N Ctrl + Shift + N 重新开一个软件的窗口 很常用 Cmd + Shift + W Ctrl + Shift + W 关闭软件的当前窗口 Cmd + N Ctrl + N 新建文件 Cmd + W Ctrl + W 关闭当前文件 2、跳转操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Option + 左右方向键 Ctrl + Pagedown/Pageup 在已经打开的多个文件之间进行切换 非常实用 Ctrl + Tab Ctrl + Tab 在已经打开的多个文件之间进行跳转 不如上面的快捷键快 Cmd + Shift + O Ctrl + shift + O 在当前文件的各种方法之间进行跳转 Ctrl + G Ctrl + G 跳转到指定行 Cmd+Shift+\\ Ctrl+Shift+\\ 跳转到匹配的括号 3、移动光标 Mac 快捷键 Win 快捷键 作用 备注 方向键 方向键 在单个字符之间移动光标 大家都知道 option + 左右方向键 Ctrl + 左右方向键 在单词之间移动光标 很常用 Cmd + 左右方向键 Fn + 左右方向键 在整行之间移动光标 很常用 Cmd + ← Fn + ←（或 Win + ←） 将光标定位到当前行的最左侧 很常用 Cmd + → Fn + →（或 Win + →） 将光标定位到当前行的最右侧 很常用 Cmd + ↑ Ctrl + Home 将光标定位到文章的第一行 Cmd + ↓ Ctrl + End 将光标定位到文章的最后一行 Cmd + Shift + \\ 在代码块之间移动光标 4、编辑操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Enter Ctrl + Enter 在当前行的下方新增一行，然后跳至该行 即使光标不在行尾，也能快速向下插入一行 Cmd+Shift+Enter Ctrl+Shift+Enter 在当前行的上方新增一行，然后跳至该行 即使光标不在行尾，也能快速向上插入一行 Option + ↑ Alt + ↑ 将代码向上移动 很常用 Option + ↓ Alt + ↓ 将代码向下移动 很常用 Option + Shift + ↑ Alt + Shift + ↑ 将代码向上复制 Option + Shift + ↓ Alt + Shift + ↓ 将代码向下复制 写重复代码的利器 5、多光标编辑 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Option + 上下键 Ctrl + Alt + 上下键 在连续的多列上，同时出现光标 Option + 鼠标点击任意位置 Alt + 鼠标点击任意位置 在任意位置，同时出现光标 Option + Shift + 鼠标拖动 Alt + Shift + 鼠标拖动 在选中区域的每一行末尾，出现光标 Cmd + Shift + L Ctrl + Shift + L 在选中文本的所有相同内容处，出现光标 其他的多光标编辑操作：（很重要）\n选中某个文本，然后反复按住快捷键「 Cmd + D 」键（windows 用户是按住「Ctrl + D」键）， 即可将全文中相同的词逐一加入选择。\n选中一堆文本后，按住「Option + Shift + i」键（windows 用户是按住「Alt + Shift + I」键），既可在每一行的末尾都创建一个光标。\n6、删除操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + shift + K Ctrl + Shift + K 删除整行 「Cmd + X」的作用是剪切，但也可以删除整行 option + Backspace Ctrl + Backspace 删除光标之前的一个单词 英文有效，很常用 option + delete Ctrl + delete 删除光标之后的一个单词 Cmd + Backspace 删除光标之前的整行内容 很常用 Cmd + delete 删除光标之后的整行内容 备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。\n7、编程语言相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + / Ctrl + / 添加单行注释 很常用 Option + Shift + F Alt + shift + F 代码格式化 很常用 F2 F2 以重构的方式进行重命名 改代码备 Ctrl + J 将多行代码合并为一行 Win 用户可在命令面板搜索”合并行“ Cmd + Cmd + U Ctrl + U 将光标的移动回退到上一个位置 撤销光标的移动和选择 8、搜索相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + F Ctrl + Shift +F 全局搜索代码 很常用 Cmd + P Ctrl + P 在当前的项目工程里，全局搜索文件名 Cmd + F Ctrl + F 在当前文件中搜索代码，光标在搜索框里 Cmd + G F3 在当前文件中搜索代码，光标仍停留在编辑器里 很巧妙 9、自定义快捷键 按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。\n当然，你也可以选择菜单栏「偏好设置 \u0026ndash;\u0026gt; 键盘快捷方式」，进入快捷键的设置：\n10、快捷键列表 你可以点击 VS Code 左下角的齿轮按钮，效果如下：\n上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了：\n快捷键参考链接 快捷键速查表[官方]：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf 三、命令面板的使用 Mac 用户按住快捷键 Cmd+Shift+P （Windows 用户按住快捷键Ctrl+Shift+P），可以打开命令面板。效果如下：\n如果们需要修改一些设置项，可以通过「命令面板」来操作，效率会更高。这里列举一些。\n1、设置字体大小 在命令面板输入“字体”，可以进行字体的设置，效果如下：\n当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。\n2、快捷键设置 在命令面板输入“快捷键”，就可以进入快捷键的设置。\n3、大小写转换 选中文本后，在命令面板中输入transfrom，就可以修改文本的大小写了。\n4、使用命令行启动 VS Code （1）输入快捷键「Cmd + Shift + P 」，选择install code command：\n（2）使用命令行：\ncode命令：启动 VS Code 软件\ncode pathName/fileName命令：通过 VS Code 软件打开指定目录/指定文件。\n四、私人订制：VS Code 的常见配置 1、VS Code 设置为中文语言 Mac 用户按住快捷键 Cmd+Shift+P （Windows 用户按住快捷键Ctrl+Shift+P），打开命令面板。\n在命令面板中，输入Configure Display Language，选择Install additional languages，然后安装插件Chinese (Simplified) Language Pack for Visual Studio Code即可。\n或者，我们可以直接安装插件Chinese (Simplified) Language Pack for Visual Studio Code，是一样的。\n安装完成后，重启 VS Code。\n2、面包屑（Breadcrumb） 打开 VS Code 的设置项，选择「用户设置 -\u0026gt; 工作台 -\u0026gt; 导航路径」，如下图所示：\n上图中，将红框部分打钩即可。\n设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：\n有了这个面包屑导航，我们可以在任意目录、任意文件之间随意跳转。\n3、左右显示多个编辑器窗口（抄代码利器） Mac 用户按住快捷键 Cmd + \\， Windows 用户按住快捷键Ctrl + \\，即可同时打开多个编辑器窗口，效果如下：\n按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口。随时随地，想切就切。\n学会了这一招，以后抄代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。\n4、是否显示代码的行号 VS Code 默认显示代码的行号。你可以在设置项里搜索 editor.lineNumbers修改设置，配置项如下：\n我建议保留这个设置项，无需修改。\n5、右侧是否显示代码的缩略图 VS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 editor.minimap进行设置，配置项如下：\n6、将当前行代码高亮显示（更改光标所在行的背景色） 当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想高亮显示当前行的代码，需要设置两步：\n（1）在设置项里搜索editor.renderLineHighlight，将选项值设置为all或者line。\n（2）在设置项里增加如下内容：\n1 2 3 4 \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editor.lineHighlightBackground\u0026#34;: \u0026#34;#00000090\u0026#34;, \u0026#34;editor.lineHighlightBorder\u0026#34;: \u0026#34;#ffffff30\u0026#34; } 上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。\n7、改完代码后立即自动保存 方式一：\n改完代码后，默认不会自动保存。你可以在设置项里搜索files.autoSave，修改配置项如下：\n上图中，我们将配置项修改为onFocusChange之后，那么，当光标离开该文件后，这个文件就会自动保存了。非常方便。\n方式二：\n当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。\n8、保存代码后，是否立即格式化 保存代码后，默认不会立即进行代码的格式化。你可以在设置项里搜索editor.formatOnSave查看该配置项：\n我觉得这个配置项保持默认就好，不用打钩。\n9、空格 or 制表符 VS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。\n常见的设置项如下：\neditor.detectIndentation：自动检测（默认开启）。截图如下： editor.insertSpaces：按 Tab 键时插入空格（默认）。截图如下： editor.tabSize：一个制表符默认等于四个空格。截图如下： 10、新建文件后的默认文件类型 当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。\n如果你想修改默认的文件类型，可以在设置项里搜索files.defaultLanguage，设置项如下：\n上图中的红框部分，填入你期望的默认文件类型。我填的是html类型，你也可以填写成 javascript 或者 markdown，或者其他的语言类型。\n11、删除文件时，是否弹出确认框 当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索xplorer.confirmDelete。截图如下：\n我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？\n接下来，我们来讲一些更高级的配置。\n12、文件对比 VS Code 默认支持对比两个文件的内容。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：\nVS Code 自带的对比功能并不够强大，我们可以安装插件compareit，进行更丰富的对比。比如说，安装完插件compareit之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：\n13、查找某个函数在哪些地方被调用了 比如我已经在a.js文件里调用了 foo()函数。那么，如果我想知道foo()函数在其他文件中是否也被调用了，该怎么做呢？\n做法如下：在 a.js 文件里，选中foo()函数（或者将光标放置在foo()函数上），然后按住快捷键「Shift + F12」，就能看到 foo()函数在哪些地方被调用了，比较实用。\n14、鼠标操作 在当前行的位置，鼠标三击，可以选中当前行。\n用鼠标单击文件的行号，可以选中当前行。\n在某个行号的位置，上下移动鼠标，可以选中多行。\n15、重构 重构分很多种，我们来举几个例子。\n命名重构：\n当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。\n方法重构：\n选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。\n16、在当前文件中搜索 在上面的快捷键列表中，我们已经知道如下快捷键：\nCmd + F（Win 用户是 Ctrl + F）：在当前文件中搜索，光标在搜索框里\nCmd + G（Win 用户是 F3）：在当前文件中搜索，光标仍停留在编辑器里\n另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：\n上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。\n「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 editor.find.autoFindInSelection，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以自动只在这些内容里进行查找。该设置项如下图所示：\n17、全局搜索 在上面的快捷键列表中，我们已经知道如下快捷键：\nCmd + Shift + F（Win 用户是 Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下： 上图中，你可以点击红框部分，展开更多的配置项。\n18、Git 版本管理 VS Code 自带了 Git 版本管理，如下图所示：\n上图中，我们可以在这里进行常见的 git 命令操作。如果你还不熟悉 Git 版本管理，可以先去补补课。\n与此同时，我建议安装插件GitLens，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。\n19、将工作区放大/缩小 我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。\n如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「cmd +/-」。windows 用户是按下「ctrl +/-」\n当我们在投影仪上给别人演示代码的时候，这一招十分管用。\n如果你想恢复默认的工作区大小，可以在命令面板输入重置缩放（英文是reset zoom）\n20、创建多层子文件夹 我们可以在新建文件夹的时候，如果直接输入aa/bb/cc，比如：\n那么，就可以创建多层子文件夹，效果如下：\n21、.vscode 文件夹的作用 为了统一团队的 vscode 配置，我们可以在项目的根目录下建立.vscode目录，在里面放置一些配置内容，比如：\nsettings.json：工作空间设置、代码格式化配置、插件配置。\nsftp.json：ftp 文件传输的配置。\n.vscode目录里的配置只针对当前项目范围内生效。将.vscode提交到代码仓库，大家统一配置时，会非常方便。\n22、自带终端 我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 item2。\n23、markdown 语法支持 VS Code 自带 markdown 语法高亮。也就是说，如果你是用 markdown 格式写文章，则完全可以用 VS Code 进行写作。\n写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：\n我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。\n你也可以在控制面板输入Markdown: 打开预览，直接全屏预览 markdown 文件。\n24、Emmet in VS Code Emmet可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。\n举个例子，我们在编辑器中输入缩写代码：ul\u0026gt;li*6 ，然后按下 Tab 键，即可得到如下代码片段：\n1 2 3 4 5 6 7 8 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; VS Code 默认支持 Emmet。更多 Emmet 语法规则，请自行查阅。\n25、修改字体，使用「Fira Code」字体 这款字体很漂亮，很适合用来写代码：\n安装步骤如下：\n（1）进入 https://github.com/tonsky/FiraCode 网站，下载并安装「Fira Code」字体。\n（2）打开 VS Code 的「设置」，搜索font，修改相关配置为如下内容：\n1 2 \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Fira Code\u0026#39;,Menlo, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, // 设置字体显示 \u0026#34;editor.fontLigatures\u0026#34;: false,//控制是否启用字体连字，true启用，false不启用 上方的第二行配置，取决于个人习惯，我是直接设置为\u0026quot;editor.fontLigatures\u0026quot;: null，因为我不太习惯连字。\n26、代码格式化：Prettier 我们可以使用 Prettier进行代码格式化，会让代码的展示更加美观。步骤如下：\n（1）安装插件 Prettier。\n（2）在项目的根路径下，新建文件.prettierrc，并在文件中添加如下内容：\n1 2 3 4 5 6 7 8 9 { \u0026#34;printWidth\u0026#34;: 150, \u0026#34;tabWidth\u0026#34;: 4, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;trailingComma\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;tslintIntegration\u0026#34;: true, \u0026#34;insertSpaceBeforeFunctionParenthesis\u0026#34;: false } 上面的内容，是我自己的配置，你可以参考。\n更多配置，可以参考官方文档：https://prettier.io/docs/en/options.html\n27、文件传输：sftp 如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装sftp这个插件，很好用。在公司会经常用到。\n步骤如下：\n（1）安装插件sftp。\n（2）配置 sftp.json文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入sftp:config，回车，当前工程的.vscode文件夹下就会自动生成一个sftp.json文件，我们需要在这个文件里配置的内容可以是：\nhost：服务器的 IP 地址\nusername：用户名\nprivateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）\nremotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录\nignore：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号\n举例如下：(注意，其中的注释需要去掉)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \u0026#34;host\u0026#34;: \u0026#34;192.168.xxx.xxx\u0026#34;, //服务器ip \u0026#34;port\u0026#34;: 22, //端口，sftp模式是22 \u0026#34;username\u0026#34;: \u0026#34;\u0026#34;, //用户名 \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, //密码 \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, //模式 \u0026#34;agent\u0026#34;: null, \u0026#34;privateKeyPath\u0026#34;: null, \u0026#34;passphrase\u0026#34;: null, \u0026#34;passive\u0026#34;: false, \u0026#34;interactiveAuth\u0026#34;: false, \u0026#34;remotePath\u0026#34;: \u0026#34;/root/node/build/\u0026#34;, //服务器上的文件地址 \u0026#34;context\u0026#34;: \u0026#34;./server/build\u0026#34;, //本地的文件地址 \u0026#34;uploadOnSave\u0026#34;: true, //监听保存并上传 \u0026#34;syncMode\u0026#34;: \u0026#34;update\u0026#34;, \u0026#34;watcher\u0026#34;: { //监听外部文件 \u0026#34;files\u0026#34;: false, //外部文件的绝对路径 \u0026#34;autoUpload\u0026#34;: false, \u0026#34;autoDelete\u0026#34;: false }, \u0026#34;ignore\u0026#34;: [ //忽略项 \u0026#34;**/.vscode/**\u0026#34;, \u0026#34;**/.git/**\u0026#34;, \u0026#34;**/.DS_Store\u0026#34; ] } （3）在 VS Code 的当前文件里，选择「右键 -\u0026gt; upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 host 中配置的服务器 ip）。\n我们还可以选择「右键 -\u0026gt; Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比。\n七、VS Code 配置云同步 我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件了，也不需要重新配置软件。\n我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。\n将自己本地的配置云同步到 GitHub：\n（1）安装插件 settings-sync。\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n（3）登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。\n（4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。\n换另外一个电脑时，从云端同步配置到本地：\n（1）当我们换另外一台电脑时，可以先在 VS Code 中安装 settings-sync 插件。\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n（3）登录之后，插件的界面上，会自动出现之前的同步记录：\n上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：\n如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。\n使用其他人的配置：\n如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：\n（1）安装插件 settings-sync。\n（2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」\n（3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。\n八、三头六臂：VS Code 插件推荐 VS Code 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。\n上图中，点击红框部分，即可在输入框里，查找你想要的插件名，然后进行安装。\n我来列举几个常见的插件，这些插件都很实用。注意：顺序越靠前，越实用。\n1、GitLens 【荐】 我强烈建议你安装插件GitLens，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。\nGitLens 在 Git 管理上有很多强大的功能，比如：\n将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。\n查看某个 commit 的代码改动记录\n查看不同的分支\n可以将两个 commit 进行代码对比\n甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招。\n2、Git History 有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。\n3、Live Server 【荐】 在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。\n使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。\n4、Chinese (Simplified) Language Pack for Visual Studio Code 让软件显示为简体中文语言。\n5、Bracket Pair Colorizer 2：突出显示成对的括号【荐】 Bracket Pair Colorizer 2插件：以不同颜色显示成对的括号，并用连线标注括号范围。简称彩虹括号。\n另外，还有个Rainbow Brackets插件，也可以突出显示成对的括号。\n6、sftp：文件传输 【荐】 如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装sftp这个插件，很好用。在公司会经常用到。\n详细配置已经在上面讲过。\n7、open in browser 安装open in browser插件后，在 HTML 文件中「右键选择 \u0026ndash;\u0026gt; Open in Default Browser」，即可在浏览器中预览网页。\n8、highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】 VSCode 自带的高亮显示，实在是不够显眼。用插件支持一下吧。\n所用了这个插件之后，VS Code 自带的高亮就可以关掉了：\n在用户设置里添加\u0026quot;editor.selectionHighlight\u0026quot;: false即可。\n参考链接：vscode 选中后相同内容高亮插件推荐\n9、vscode-icons vscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。\n10、Project Manager 工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。\n11、TODO Highlight 写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写TODO，而不是小写的todo）\n1 //TODO:这里有个bug，我一会儿再收拾你 或者：\n1 //FIXME:我也不知道为啥， but it works only that way. 安装了插件 TODO Highlight之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。\n12、WakaTime 【荐】 统计在 VS Code 里写代码的时间。统计效果如下：\n13、Code Time Code Time插件：记录编程时间，统计代码行数。\n安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。\n备注：团长试了一下这个 code time 插件，发现统计结果不是很准。\n14、Markdown Preview Github Styling 【荐】 以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果：\n15、Markdown Preview Enhanced 预览 Markdown 样式。\nMarkdown All in One 这个插件将帮助你更高效地在 Markdown 中编写文档。\n16、Settings Sync【荐】 地址：https://github.com/shanalikhan/code-settings-sync\n作用：多台设备之间，同步 VS Code 配置。通过登录 GitHub 账号来使用这个同步工具。\n同步的详细操作已在上面讲过。\n17、vscode-syncing 地址：https://github.com/nonoroazoro/vscode-syncing\n作用：多台设备之间，同步 VS Code 配置。\n18、Vetur Vue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VS Code 官方钦定 Vue 插件，Vue 开发者必备。\n19、ES7 React/Redux/GraphQL/React-Native snippets React/Redux/react-router 的语法智能提示。\n20、minapp：小程序支持 小程序开发必备插件。\n21、Prettier：代码格式化 Prettier 是一个代码格式化工具，只关注格式化，但不具备校验功能。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高。\n22、ESLint：代码格式校验 日常开发中，建议用可以用 Prettier 做代码格式化，然后用 eslint 做校验。\n23、Beautify 代码格式化工具。\n备注：相比之下，Prettier 是当前最流行的代码格式化工具，比 Beautify 用得更多。\n24、JavaScript(ES6) code snippets ES6 语法智能提示，支持快速输入。\n25、Search node_modules 【荐】 node_modules模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 Search node_modules 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 node_modules，在弹出的选项中选择 Search node_modules，即可搜索 node_modules 里的模块。\n26、indent-rainbow：突出显示代码缩进 indent-rainbow插件：突出显示代码缩进。\n安装完成后，效果如下图所示：\n27、javascript console utils：快速打印 log 日志【荐】 安装这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 console.log()。简直是日志党福音。\n当我们选中某个变量 name，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 console.log(name)。\n其他的同类插件还有：Turbo Console Log。\n不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。\n编程有三等境界：\n第三等境界是打日志，这是最简单、便捷的方式，略显低级，一般新手或资深程序员偷懒时会用。\n第二等境界是断点调试，在前端、Java、PHP、iOS 开发时非常常用，通过断点调试可以很直观地跟踪代码执行逻辑、调用栈、变量等，是非常实用的技巧。\n第一等境界是测试驱动开发，在写代码之前先写测试。与第二等的断点调试刚好相反，大部分人不是很习惯这种方式，但在国外开发者或者敏捷爱好者看来，这是最高效的开发方式，在保证代码质量、重构等方面非常有帮助，是现代编程开发必不可少的一部分。\n28、Code Spell Checker：单词拼写错误检查 这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish.\n29、Local History 【荐】 维护文件的本地历史记录，强烈建议安装。代码意外丢失时，有时可以救命。\n30、Polacode-2020：生成代码截图 【荐】 可以把代码片段保存成美观的图片，主题不同，代码的配色方案也不同，也也可以自定义设置图片的边框颜色、大小、阴影。\n尤其是在我们做 PPT 分享时需要用到代码片段时，或者需要在网络上优雅地分享代码片段时，这一招很有用。\n生成的效果如下：\n其他同类插件：CodeSnap。我们也可以通过 https://carbon.now.sh/这个网站生成代码图片\n有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。\n31、Image Preview 【荐】 图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。\n32、Auto Close Tag、Auto Rename Tag 自动闭合标签、自动对标签重命名。\n33、Better Comments 为注释添加更醒目、带分类的色彩。\n34、CSS Peek 增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。\n35、Vue CSS Peek CSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。\n36、Color Info 这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。\n37、RemoteHub 不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。\nRemoteHub插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。\n这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。\n38、Live Share：实时编码分享 Live Share这个神奇的插件是由微软官方出品，它的作用是：实时编码分享。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是结对编程的神器啊。\n安装方式：\n打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：\n上图中，点击红框部分，登录后就可以分享你的工作空间了。\n39、Import Cost 在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。Import Cost插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。\nPaste JSON as Code 此插件可以将剪贴板中的 JSON 字符串转换成工作代码。支持多种语言。\n八、常见主题插件 给你的 VS Code 换个皮肤吧，免费的那种。\nDracula Theme\nMaterial Theme\nNebula Theme\nOne Dark Pro\nOne Monokai Theme\nMonokai Pro\nAyu\nSnazzy Plus\nDainty\nSynthWave '84\nGitHub Plus Theme：白色主题\nHorizon Theme：红色主题\n最后一段 如果你还有什么推荐的 VS Code 插件，欢迎留言。\n大家完全不用担心这篇文章会过时，随着 VS Code 的版本更新和插件更新，本文也会随之更新。关于 VS Code 内容的后续更新，你可以关注我在 GitHub 上的前端入门项目，项目地址是：\nhttps://github.com/qianguyihao/Web\n一个超级详细和真诚的前端入门项目。\ntodo issues 84 参考链接 VSCode 插件大全｜ VSCode 高级玩家之第二篇\nhttp://www.supuwoerc.xyz/tools/vscode/plugins.html\n如何让 VS Code 更好用 10 倍？这里有一份 VS Code 新手指南\n那些你应该考虑卸载的 VSCode 扩展\nVS Code 折腾记 - (16) 推荐一波实用的插件集\nVSCode 前端必备插件，有可能你装了却不知道如何使用？\n能让你开发效率翻倍的 VSCode 插件配置（上）\nhttps://segmentfault.com/a/1190000012811886\n「Vscode」打造类 sublime 的高颜值编辑器\nMac Vscode 快捷键\n使用 VSCode 的一些技巧\n本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/01-vs-code%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"快捷键 作用 IDEA 快捷键 VS Code 备注 复制当前行 Ctrl + D Shift + Alt + ↑↓ 使用很频繁 当前文件搜索 Ctrl + R Ctrl + F 非常实用 全局搜索内容 Ctrl + Shift + R Ctrl + Shift + F 不如上面的快","title":"VS Code的使用"},{"content":"常见配置 自动保存：\n1 \u0026#34;files.autoSave\u0026#34;: \u0026#34;onFocusChange\u0026#34; 参考链接：https://blog.csdn.net/WestLonly/article/details/78048049\n在新的窗口中打开文件：\n1 \u0026#34;workbench.editor.enablePreview\u0026#34;: false, 常见操作 如何查看代码结构 方法一：「Cmd + Shift + O」\n方法二：安装插件Code Outline\n参考链接：https://www.zhihu.com/question/264045094\n在本地开启服务器 1 2 3 4 5 # 安装 npm install -g live-server # 启动 live-server 参考链接：Visual Studio Code + live-server编辑和浏览HTML网页\n常用插件 方式一：打开VS Code，左侧有五个按钮，点击最下方的按钮，然后就可以开始安装相应的插件了。\n方式二：在vscode中输入快捷键「ctrl+shift+P」，弹出指令窗口，输入extension:install，回车，左侧即打开扩展安装的界面。\nsftp：文件传输 输入快捷键「ctrl+shift+P」，弹出指令窗口，输入sftp:config，回车，当前工作工程的.vscode文件夹下就会自动生成一个sftp.json文件，我们需要在这个文件里配置的是：\nhost：服务器的IP地址\nusername：工作站自己的用户名\nprivateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是ppk文件）\nremotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用sftp上传文件之前，要手动在工作站上mkdir生成这个根目录\nignore：指定在使用sftp: sync to remote的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号\n举例如下：(注意，其中的注释不能保留)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \u0026#34;host\u0026#34;: \u0026#34;\u0026#34;, //服务器ip \u0026#34;port\u0026#34;: 22, //端口，sftp模式是22 \u0026#34;username\u0026#34;: \u0026#34;\u0026#34;, //用户名 \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, //密码 \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, //模式 \u0026#34;agent\u0026#34;: null, \u0026#34;privateKeyPath\u0026#34;: null, \u0026#34;passphrase\u0026#34;: null, \u0026#34;passive\u0026#34;: false, \u0026#34;interactiveAuth\u0026#34;: false, \u0026#34;remotePath\u0026#34;: \u0026#34;/root/node/build/\u0026#34;, //服务器上的文件地址 \u0026#34;context\u0026#34;: \u0026#34;./server/build\u0026#34;, //本地的文件地址 \u0026#34;uploadOnSave\u0026#34;: true, //监听保存并上传 \u0026#34;syncMode\u0026#34;: \u0026#34;update\u0026#34;, \u0026#34;watcher\u0026#34;: { //监听外部文件 \u0026#34;files\u0026#34;: false, //外部文件的绝对路径 \u0026#34;autoUpload\u0026#34;: false, \u0026#34;autoDelete\u0026#34;: false }, \u0026#34;ignore\u0026#34;: [ //忽略项 \u0026#34;**/.vscode/**\u0026#34;, \u0026#34;**/.git/**\u0026#34;, \u0026#34;**/.DS_Store\u0026#34; ] } Sass Formatter Sass 文件格式化。\nCode Outline：显示代码结构 安装好插件「Code Outline」后，可以在左侧的资源管理器中，显示当前文件的代码结构：\n参考链接：\nhttps://www.zhihu.com/question/50273450\nhttp://itopic.org/vscode.html\nhttps://github.com/varHarrie/varharrie.github.io/issues/10\nvscode-fileheader：添加顶部注释模板(签名) （1）安装插件vscode -fileheader，并重启。\n（2）在首选项-》设置-》中搜索fileheader，找到头部模板修改。\n默认的快捷键是：「Ctrl + option + I」。\n参考链接：\nhttps://www.zhihu.com/question/62385647 Express 在本地开启Node服务器：\n然后在浏览器的地址栏输入http://localhost/ + 文件的相对路径，就可以通过服务器的形式打开这个文件。\nhighlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】 VSCode自带的高亮显示，实在是不够显眼。用插件支持一下吧。\n所用了这个插件之后，VS Code自带的高亮就可以关掉了：\n在用户设置里添加\u0026quot;editor.selectionHighlight\u0026quot;: false即可。\n参考链接：vscode 选中后相同内容高亮插件推荐\nhighlight-words：全局高亮（跨文件多色彩） 参考链接：Visual Studio Code全局高亮着色插件(跨文件多色彩)经验纪要\ncolor-exchange：颜色格式转换【荐】 安装完插件后，在css中输入颜色，然后按cmd + .，就能进行颜色的格式转换。\nVue 相关的插件 vetur：vue 文件的基本语法高亮 安装完 vetur 后还需要加上这样一段配置下：\n1 2 3 4 \u0026#34;emmet.syntaxProfiles\u0026#34;: { \u0026#34;vue-html\u0026#34;: \u0026#34;html\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;html\u0026#34; } 参考链接：\nhttps://www.clarencep.com/2017/03/18/edit-vue-file-via-vscode/ https://github.com/varHarrie/varharrie.github.io/issues/10 参考链接 https://www.jianshu.com/p/0724921285d4\nhttps://www.cnblogs.com/AmosLee94/p/8338013.html\n常用快捷键 Win快捷键 Mac快捷键 作用 备注 Shift + Alt + F Shift + option + F 代码格式化 Ctrl + Shift + N 在当前行上面增加一行并跳至该行 Ctrl + Shift + D 复制当前行到下一行 参考链接 能让你开发效率翻倍的 VSCode 插件配置（上） ","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/05-vs-code%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/","summary":"常见配置 自动保存： 1 \u0026#34;files.autoSave\u0026#34;: \u0026#34;onFocusChange\u0026#34; 参考链接：https://blog.csdn.net/WestLonly/article/details/78048","title":"VS Code的使用积累"},{"content":"什么是mvvm？ MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象\n在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理 vue的优点是什么？ 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\u0026quot;View\u0026quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 请详细说下你对vue生命周期的理解 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后\n创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 组件之间的传值？ 父组件与子组件传值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //父组件通过标签上面定义传值 \u0026lt;template\u0026gt; \u0026lt;Main :obj=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/Main\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; //引入子组件 import Main form \u0026#34;./main\u0026#34; exprot default{ name:\u0026#34;parent\u0026#34;, data(){ return { data:\u0026#34;我要向子组件传递数据\u0026#34; } }, //初始化组件 components:{ Main } } \u0026lt;/script\u0026gt; //子组件通过props方法接受数据 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{data}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; exprot default{ name:\u0026#34;son\u0026#34;, //接受父组件传值 props:[\u0026#34;data\u0026#34;] } \u0026lt;/script\u0026gt; 子组件向父组件传递数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //子组件通过$emit方法传递参数 \u0026lt;template\u0026gt; \u0026lt;div v-on:click=\u0026#34;events\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; //引入子组件 import Main form \u0026#34;./main\u0026#34; exprot default{ methods:{ events:function(){ } } } \u0026lt;/script\u0026gt; // \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{data}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; exprot default{ name:\u0026#34;son\u0026#34;, //接受父组件传值 props:[\u0026#34;data\u0026#34;] } \u0026lt;/script\u0026gt; 路由之间跳转？ 声明式（标签跳转）\n1 \u0026lt;router-link :to=\u0026#34;index\u0026#34;\u0026gt; 编程式（ js跳转）\n1 router.push(\u0026#39;index\u0026#39;) vuex是什么？怎么使用？哪种功能场景使用它？ vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n实现 Vue SSR 其基本实现原理\napp.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。 webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__ 发送到客户端 Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的\nVue SSR 需要做的事多点（输出完整 HTML），除了 complier -\u0026gt; vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。 相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点 Vue 组件 data 为什么必须是函数 每个组件都是 Vue 的实例。 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他 Vue computed 实现 建立与其他属性（如：data、 Store）的联系； 属性改变后，通知计算属性重新计算 实现时，主要如下\n初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。 Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集 Vue complier 实现 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。 总的来说，Vue complier 是将 template 转化成一个 render 字符串。 可以简单理解成以下步骤：\nparse 过程，将 template 利用正则转化成 AST 抽象语法树。 optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。 generate 过程，生成 render 字符串 怎么快速定位哪个组件出现性能问题 用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue/","summary":"什么是mvvm？ MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Mode","title":"vue"},{"content":"WebSocket 的引入 背景分析 HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。\n当用户在浏览器上进行操作时，可以请求服务器上的api；但是反过来却不可能：服务器端发生了一个事件，无法将这个事件的信息实时主动地通知客户端。只有在客户端查询服务器当前状态时，所发生事件的信息才会从服务器传递到客户端。\n那怎么去实时地知道服务器的状态呢？方法有两个：\n（1）轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。\n（2）长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果。当服务器有了新数据时，实时地发给客户端，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。\nWebSocket 协议 最新的 HTML5协议，制定了 WebSocket 协议标准，允许客户端和服务器端以全双工的方式进行通信。\nWebSocket 的原理非常简单：利用HTTP请求产生握手，HTTP头部含有 WebSocket 协议的请求，*握手之后，二者转用TCP协议进行交流（QQ的协议）。\nWebSocket协议需要浏览器和服务器都支持才可以使用：\n支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5\n支持WebSocket协议的服务器有：Node 0、Apach7.0.2、Nginx1.3\nhttp 长连接和 websocket 的长连接区别 HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。\nwebsocket是一个真正的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。\nkeep-alive双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。\nSocket.IO 的引入 Node.js上需要写一些程序，来处理TCP请求。\nNode.js从诞生之日起，就支持 WebSocket 协议。不过，从底层一步一步搭建一个Socket服务器很费劲（想象一下Node写一个静态文件服务都那么费劲）。所以，有大神帮我们写了一个库 Socket.IO。\nSocket.IO 是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持 WebSocket 协议的浏览器，提供了长轮询的透明模拟机制。\nNode的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。\nSocket.IO 的安装 Socket.IO 的官网是：http://socket.io/\n安装方式：\n1 npm install socket.io ","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/websocket/","summary":"WebSocket 的引入 背景分析 HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。 当用户在浏览器上进行操作时，可以请","title":"WebSocket"},{"content":"常见web安全及防护原理\nsql注入原理\n就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 总的来说有以下几点\n永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双\u0026quot;-\u0026ldquo;进行转换等 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息 XSS原理及防范\nXss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 XSS防范方法\n首先代码里对用户输入的地方和变量都需要仔细检查长度和对”\u0026lt;”,”\u0026gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 XSS与CSRF有什么区别吗？\nXSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤\n登录受信任网站A，并在本地生成Cookie\n在不登出A的情况下，访问危险网站B\nCSRF的防御\n服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数 通过验证码的方法 是否了解 Web 注入攻击（最常见 XSS 和 CSRF）？\nSQL注入\n把SQL命令插入到表单或输入URL查询字符串提交，欺骗服务器达到执行恶意的SQL目的 XSS(Cross Site Script)，跨站脚本攻击\n攻击者在页面里插入恶意代码，当用户浏览该页之时，执行嵌入的恶意代码达到攻击目的 CSRF(Cross Site Request Forgery)，跨站点伪造请求\n伪造合法请求，让用户在不知情的情况下以登录的身份访问，利用用户信任达到攻击目的 如何防范 Web 前端攻击？\n不要信任任何外部传入的数据\n针对用户输入作相关的格式检查、过滤等操作 不要信任在任何传入的第三方数据\n使用 CORS，设置 Access-Control-Allow-Origin 更安全地使用 Cookie\n设置Cookie为HttpOnly，禁止了JavaScript操作Cookie 防止网页被其他网站内嵌为iframe\n服务器端设置 X-Frame-Options 响应头，防止页面被内嵌 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230802-web%E5%AE%89%E5%85%A8/","summary":"常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的","title":"web安全"},{"content":"异步编程 异步操作 Node 采用 Chrome V8 引擎处理 JavaScript 脚本。V8 最大特点就是单线程运行，一次只能运行一个任务。\nNode 大量采用异步操作（asynchronous operation），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。\n提高代码的响应能力。\n异步IO也叫非阻塞IO。例如读文件，传统的语言，基本都是读取完毕才能进行下一步操作。非阻塞就是Node的callback，不会影响下一步操作，等到文件读取完毕，回调函数自动被执行，而不是在等待。\n异步操作回调 由于系统永远不知道用户什么时候会输入内容，所以代码不能永远停在一个地方。\nNode 中的操作方式就是以异步回调的方式解决无状态的问题。\n回调函数的设计：错误优先 异步操作中，无法通过 try catch 捕获异常。\n这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try…catch对于异步操作行不通，所以只能把错误交给回调函数处理。\n统一约定：\n回调函数的第一个参数默认接收错误信息，第二个参数才是真正的回调数据（便于外界获取调用的错误情况）：\n1 2 3 4 foo1(\u0026#39;赵小黑\u0026#39;, 19, function(error, data) { if(error) throw error; console.log(data); }); 异步回调的问题 相比较于传统的代码：\n异步事件驱动的代码\n不容易阅读\n不容易调试\n不容易维护\n另外还有个问题是回调地狱：\n1 2 3 4 5 6 7 8 9 10 11 do1(function() { do2(function() { do3(function() { do4(function() { do5(function() { do6() }); }); }); }); }); 进程和线程 进程（进行中的程序） 每一个 正在运行 的应用程序都称之为进程。\n每一个应用程序运行都至少有一个进程。\n进程是用来给应用程序提供一个运行的环境。\n进程是操作系统为应用程序分配资源的一个单位。\n线程 用来执行应用程序中的代码\n在一个进程内部，可以有很多的线程\n在一个线程内部，同时只可以干一件事\n传统的开发方式大部分都是 I/O 阻塞的，所以需要多线程来更好的利用硬件资源。\n线程并不是越多越好。\n多线程的弊端 缺点一：\n- 创建线程耗费。 - 线程数量有限。 - CPU 在不同线程之间转换，有个上下文转换，这个转换非常耗时。 所谓的多线程其实都是假的，对于单核CPU而言，它们无非是在抢占 CPU 资源。线程和线程之间需要切换和调度，这是很耗费资源的。\n缺点二：\n线程之间共享某些数据，同步某个状态都很麻烦。 就算 CPU 是多核的，现在的问题是，线程与线程之间如果要共享数据，该怎么办？比如 A 线程要访问 B 线程的变量。\n事件驱动和非阻塞机制 参考链接：https://www.kancloud.cn/revin/nodejs/176211\n总结：\nNode 中将所有的阻塞操作交给了内部线程池实现。\nNode 主线程本身，主要就是不断的往返调度。\n平台实现差异 由于 Windows 和 *nix 平台（其他平台）的差异，Node 提供了 libuv 作为抽象封装层，保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。\n如下图所示：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%BA%E5%88%B6/","summary":"异步编程 异步操作 Node 采用 Chrome V8 引擎处理 JavaScript 脚本。V8 最大特点就是单线程运行，一次只能运行一个任务。 Node 大量采用异步操作（asynchronous op","title":"事件驱动和非阻塞机制"},{"content":"1 前言 1.1 面向对象的三大特性 封装 继承 多态 1.2 原型链的知识 原型链是面向对象的基础，是非常重要的部分。有以下几种知识：\n创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new 运算符 2 创建对象有几种方法 2.1 方式一：字面量 1 2 var obj11 = {name: \u0026#39;smyh\u0026#39;}; var obj12 = new Object(name: `smyh`); //内置对象（内置的构造函数） 上面的两种写法，效果是一样的。因为，第一种写法，obj11会指向Object。\n第一种写法是：字面量的方式。 第二种写法是：内置的构造函数 2.2 方式二：通过构造函数 1 2 3 4 var M = function (name) { this.name = name; } var obj3 = new M(\u0026#39;smyhvae\u0026#39;); 2.3 方法三：Object.create 1 2 var p = {name:\u0026#39;smyhvae\u0026#39;}; var obj3 = Object.create(p); //此方法创建的对象，是用原型链连接的 第三种方法，很少有人能说出来。这种方式里，obj3是实例，p是obj3的``原型（name是p原型里的属性），构造函数是Objecet` 。\n3 原型、构造函数、实例，以及原型链 PS：任何一个函数，如果在前面加了new，那就是构造函数。\n3.1 原型、构造函数、实例三者之间的关系 构造函数通过 new 生成实例 构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性） 原型对象中有 constructor，指向该原型的构造函数。 上面的三行，代码演示：\n1 2 3 4 5 var Foo = function (name) { this.name = name; } var fn = new Foo(\u0026#39;smyhvae\u0026#39;); 上面的代码中，Foo.prototype.constructor === Foo的结果是true：\n实例的__proto__指向原型。也就是说，Foo.__proto__ === M.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。\nFoo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。\n3.2 原型链 原型链的基本原理：任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。\nObject是原型链的顶端。\n原型可以起到继承的作用。原型里的方法都可以被不同的实例共享： 1 2 3 4 //给Foo的原型添加 say 函数 Foo.prototype.say = function () { console.log(\u0026#39;\u0026#39;); } 原型链的关键：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。\n3.3 instanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。 instanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。 注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。 注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。 比如说：\nfoo instance of Foo的结果为true，因为foo.__proto__ === M.prototype为true。 foo instance of Objecet的结果也为true，为Foo.prototype.__proto__ === Object.prototype为true。 但我们不能轻易的说：foo 一定是 由Object创建的实例`。这句话是错误的。我们来看下一个问题就明白了。\n3.4 分析一个问题 问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？\n分析：这就要用到原型的constructor属性了。\nfoo.__proto__.constructor === M的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。 4 new 运算符 当new Foo()时发生了什么：\n创建一个新的空对象实例。 将此空对象的隐式原型指向其构造函数的显示原型。 执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。 如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/12%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","summary":"1 前言 1.1 面向对象的三大特性 封装 继承 多态 1.2 原型链的知识 原型链是面向对象的基础，是非常重要的部分。有以下几种知识： 创建对象有几种方法 原型、构造函","title":"创建对象和原型链"},{"content":"如何解决跨域问题 JSONP：\n原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function createJs(sUrl){ var oScript = document.createElement(\u0026#39;script\u0026#39;); oScript.type = \u0026#39;text/javascript\u0026#39;; oScript.src = sUrl; document.getElementsByTagName(\u0026#39;head\u0026#39;)[0].appendChild(oScript); } createJs(\u0026#39;jsonp.js\u0026#39;); box({ \u0026#39;name\u0026#39;: \u0026#39;test\u0026#39; }); function box(json){ alert(json.name); } CORS\n服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问 通过修改document.domain来跨子域\n将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。主域相同的使用document.domain 使用window.name来进行跨域\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据\n还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法 如何解决跨域问题?\njsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面\n如何解决跨域问题?\ndocument.domain + iframe：要求主域名相同 //只能跨子域 JSONP(JSON with Padding)``：response: callback(data)`` //只支持 GET 请求 跨域资源共享CORS(XHR2)``：Access-Control-Allow` //兼容性 IE10+ 跨文档消息传输(HTML5)：postMessage + onmessage //兼容性 IE8+ WebSocket(HTML5)：new WebSocket(url) + onmessage //兼容性 IE10+ 服务器端设置代理请求：服务器端不受同源策略限制 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","summary":"如何解决跨域问题 JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url","title":"如何解决跨域问题"},{"content":"1 前言 面试中的安全问题，明确来说，就两个方面：\nCSRF：基本概念、攻击方式、防御措施 XSS：基本概念、攻击方式、防御措施 这两个问题，一般不会问太难。\n有人问：SQL注入算吗？答案：这个其实跟前端的关系不是很大。\n2 CSRF 问的不难，一般问：\nCSRF的基本概念、缩写、全称 攻击原理 防御措施 如果把攻击原理和防御措施掌握好，基本没什么问题。\n2.1 CSRF的基本概念、缩写、全称 CSRF（Cross-site request forgery）：跨站请求伪造。\nPS：中文名一定要记住。英文全称，如果记不住也拉倒。\n2.2 CSRF的攻击原理 用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。\n从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：\n登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录） 在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。 我们在讲CSRF时，一定要把上面的两点说清楚。\n温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。\n举个例子，前段时间里，微博网站有个api接口有漏洞，导致很多用户的粉丝暴增。\n2.3 CSRF如何防御 方法一、Token 验证：（用的最多）\n服务器发送给客户端一个token； 客户端提交的表单中带着这个token。 如果这个 token 不合法，那么服务器拒绝这个请求。 方法二：隐藏令牌：\n把 token 隐藏在 http 的 head头中。 方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。\n方法三、Referer 验证：\nReferer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。\n3 XSS 3.1 XSS的基本概念 `XSS（Cross Site Scripting）``：跨域脚本攻击。\n接下来，我们详细讲一下 XSS 的内容。 预备知识：HTTP、Cookie、Ajax。\n3.2 XSS的攻击原理 XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。\n最后导致的结果可能是：\n盗用Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss攻击 3.3 XSS的攻击方式 反射型 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。\n存储型 存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。\n3.4 XSS的防范措施（encode + 过滤） XSS的防范措施主要有三个：\n1. 编码：\n对用户输入的数据进行HTML Entity编码。\n如上图所示，把字符转换成 转义字符。\nEncode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。\n比如说这段代码：\n1 \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; 若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。\n进行编码处理之后，L在浏览器中的显示结果就是\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;，实现了将``$var作为纯文本进行输出，且不引起JavaScript`的执行。\n2、过滤：\n移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容） 移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。 3、校正\n避免直接对HTML Entity进行解码。 使用DOM Parse转换，校正不配对的DOM标签。 备注：我们应该去了解一下DOM Parse这个概念，它的作用是把文本解析成DOM结构。\n比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。\n还有一种简洁的答案：\n首先是encode，如果是富文本，就白名单。\n4 CSRF 和 XSS 的区别 面试官还可能喜欢问二者的区别。\n区别一：\nCSRF：需要用户先登录网站A，获取 cookie XSS：不需要登录。 区别二：（原理的区别）\nCSRF：是利用网站A本身的漏洞，去请求网站A的api。 XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/11%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98csrf%E5%92%8Cxss/","summary":"1 前言 面试中的安全问题，明确来说，就两个方面： CSRF：基本概念、攻击方式、防御措施 XSS：基本概念、攻击方式、防御措施 这两个问题，一般不会","title":"安全问题：CSRF和XSS"},{"content":"一、网络相关 1.1 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP 1 \u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;//yuchengkai.cn\u0026#34;\u0026gt; 1.2 缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度 通常浏览器缓存策略分为两种：强缓存和协商缓存 强缓存\n实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200\n1 Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效\n1 Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求\n协商缓存\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式 Last-Modified 和 If-Modified-Since\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag ETag 和 If-None-Match\nETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高 选择合适的缓存策略\n对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 1.3 使用 HTTP / 2.0 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小 1.4 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 1 \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;http://example.com\u0026#34;\u0026gt; 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好\n1.5 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染\n1 \u0026lt;link rel=\u0026#34;prerender\u0026#34; href=\u0026#34;http://example.com\u0026#34;\u0026gt; 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染 二、优化渲染过程 2.1 懒执行 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒 2.2 懒加载 懒加载就是将不关键的资源延后加载 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载\n懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","summary":"一、网络相关 1.1 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP 1 \u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;//yuchengkai.cn\u0026#34;\u0026gt; 1.2 缓存 缓存对于前端性能优化来说是个很重要的点","title":"性能优化"},{"content":" 阿里9年，我总结的前端架构演进3大阶段及团队管理心法 伟明的推荐，说是对前端开发的价值观形成有良好的影响。\n前端开发面试题 在逛公众号「前端大全」的时候发现的，然后顺着找到了对应的GitHub链接。面试题有答案哦。\n你可能不需要 Vuex 2017-08-01 资深Web技术专家曹刘阳：2016年前端技术观察 有很多争议，知乎上都有人评论了。\n2017-08-16 道阻且长啊TAT(前端面试总结) 作者毕业于华科，面的是前端的实习，还拿了不少offer：百度外卖，头条，美团，狗东，其他，最终在美团实习。我最初是在微信公众号上看到的文章。\nhello。我看你拿了不少实习offer。有没有推荐的前端学习资料呀？比如说：网站、链接、书籍等。可否分享给我？如果内容较多，欢迎发表成博客。谢啦～～～\n2017-08-17 面试分享：一年经验初探阿里巴巴前端社招 在公众号「web前端课程」上看到的文章。作者经历了4面，也是厉害了。另外，作者在gihub上的博客也是出彩的。比如说下面这篇文章就值得推荐：\n挖 \u0026ldquo;掘\u0026rdquo; 淘 \u0026ldquo;金\u0026rdquo; 之 前端闯关历险记学习资料汇总 作者搜集了几百篇在掘金上看到的好文章，让人惊叹。\n2017-09-15 你所不知道的 CSS 滤镜技巧与细节 2017-09-19 适合程序员的写作技法 写作过程包括下面的部分：\n需求 设计 实现 测试 交付 2018-01-09 翻译 | 像 JavaScript 一样思考 在MacTalk的小密圈里看到有人分享。\n大前端公共知识杂谈\n小白谈数据脱敏\n2018-01-10 MAC全栈开发环境搭建指南 今天发现这个网址，感觉还不错。在里面发现了一个比较好的Sublime Text主题。\n介绍几个上网+分流+图床工具 2018-01-12 张鑫旭 | 话说我为什么要闭关学习 作者闭关学习了半年的前端。\n2018-01-17 你的简历能帮你争取到面试机会吗\n漫话JavaScript与异步·第三话——Generator：化异步为同步\n2017-01-19 一个三年工作经验的软件工程师的经验之谈 2018-01-22 前端程序员容易忽视的一些基础知识 2018-01-23 2018 前端趋势：更一致，更简单 2018-01-24 推荐一个网站，名叫：web骇客。网址：http://www.webhek.com/\n比如：\n电影里敲代码的样子：http://www.webhek.com/post/hackertyper.html\n测试眼睛对颜色的敏感程度：http://www.webhek.com/post/color-test.html\n2018-01-25 面试分享：一年经验初探阿里巴巴前端社招 一般阿里社招都是招3-5年的P6+高级工程师。面试官明知道作者只有一年工作经验，在面了这么多轮之后却来一句：“我们只要高工”。这是不是太欺负人了？\n2018-01-28 WEB前端工作五年了，我来告诉你如何系统的学习现在的JAVASCRIPT 2018-01-29 最棒的 JavaScript 学习指南（2018版）\n我们为什么选择Vue.js而不是React\n【长文慎入】通信十年—通信行业分析与跳槽之路\n我在深圳南山写代码：是在改变世界还是养家糊口\n我所理解的前端\n开发人员的奋斗目标\n十倍效能提升——Web 基础研发体系的建立\n长期写博客的人，最少能证明他是一个善于思考和总结的人。\n这句话的来源：我依然坚持建议你开始写博客 | 写给我的 2017\n不谈面试题，谈谈招聘时我喜欢见到的特质\nJerry和您聊聊Chrome开发者工具\nWhat makes a good front end engineer\n一个bit一个bit的进行 Base64 白话科普，看不懂算你输\n技术的热门度曲线\n浅谈XXE攻击\n关于XXE攻击，这几天微信支付被爆出漏洞，使用微信支付的各个业务都在努力修补。\n《博客园美化教程大集合\u0026mdash;-极致个性化你的专属博客（超详细，看这篇就够了）》\nhttps://www.yuque.com/sxc/front/kvokg4\n作者在语雀上的系列文章，都值得一看。\n前端学习网站和资源推荐 ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/2019-%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/","summary":"阿里9年，我总结的前端架构演进3大阶段及团队管理心法 伟明的推荐，说是对前端开发的价值观形成有良好的影响。 前端开发面试题 在逛公众号「前端大全」","title":"推荐文章"},{"content":"说说你对AMD和Commonjs的理解\nCommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 模块化开发怎么做？\n立即执行函数,不暴露私有成员 1 2 3 4 5 6 7 8 9 10 11 12 13 var module1 = (function(){ var _count = 0; var m1 = function(){ //... }; var m2 = function(){ //... }; return { m1 : m1, m2 : m2 }; })(); AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？\nAsynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // CMD define(function(require, exports, module) { var a = require(\u0026#39;./a\u0026#39;) a.doSomething() // 此处略去 100 行 var b = require(\u0026#39;./b\u0026#39;) // 依赖可以就近书写 b.doSomething() // ... }) // AMD 默认推荐 define([\u0026#39;./a\u0026#39;, \u0026#39;./b\u0026#39;], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ... }) 对前端模块化的认识\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出 AMD 是提前执行，CMD 是延迟执行 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-%E6%A8%A1%E5%9D%97%E5%8C%96/","summary":"说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步","title":"模块化"},{"content":"二、跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败\n2.1 JSONP JSONP 的原理很简单，就是利用 script标签没有跨域限制的漏洞。通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时\n1 2 3 4 5 6 \u0026lt;script src=\u0026#34;http://domain/api?param1=a\u0026amp;param2=b\u0026amp;callback=jsonp\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function jsonp(data) { console.log(data) } \u0026lt;/script\u0026gt; JSONP 使用简单且兼容性不错，但是只限于 get 请求 2.2 CORS CORS需要浏览器和后端同时支持 浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源 2.3 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域 2.4 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n1 2 3 4 5 6 7 8 9 10 11 // 发送消息端 window.parent.postMessage(\u0026#39;message\u0026#39;, \u0026#39;http://test.com\u0026#39;); // 接收消息端 var mc = new MessageChannel(); mc.addEventListener(\u0026#39;message\u0026#39;, (event) =\u0026gt; { var origin = event.origin || event.originalEvent.origin; if (origin === \u0026#39;http://test.com\u0026#39;) { console.log(\u0026#39;验证通过\u0026#39;) } }); 三、Event loop 3.1 JS中的event loop 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）\nJS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 1 2 3 4 5 6 7 console.log(\u0026#39;script start\u0026#39;); setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); console.log(\u0026#39;script end\u0026#39;); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 console.log(\u0026#39;script start\u0026#39;); setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); new Promise((resolve) =\u0026gt; { console.log(\u0026#39;Promise\u0026#39;) resolve() }).then(function() { console.log(\u0026#39;promise1\u0026#39;); }).then(function() { console.log(\u0026#39;promise2\u0026#39;); }); console.log(\u0026#39;script end\u0026#39;); // script start =\u0026gt; Promise =\u0026gt; script end =\u0026gt; promise1 =\u0026gt; promise2 =\u0026gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务\n微任务\nprocess.nextTick promise Object.observe MutationObserver 宏任务\nscript setTimeout setInterval setImmediate I/O UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务\n所以正确的一次 Event loop 顺序是这样的\n执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中\n3.2 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ┌───────────────────────┐ ┌─\u0026gt;│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │\u0026lt;──connections─── │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ timer\ntimers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟 I/O\nI/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle, prepare idle, prepare 阶段内部实现\npoll\npoll 阶段很重要，这一阶段中，系统会做两件事情\n执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情\n如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check\ncheck 阶段执行 setImmediate close callbacks\nclose callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 1 2 3 4 5 6 7 8 9 10 setTimeout(() =\u0026gt; { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); setImmediate(() =\u0026gt; { console.log(\u0026#39;setImmediate\u0026#39;); }) // 这里可能会输出 setTimeout，setImmediate // 可能也会相反的输出，这取决于性能 // 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate // 否则会执行 setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 setTimeout(()=\u0026gt;{ console.log(\u0026#39;timer1\u0026#39;) Promise.resolve().then(function() { console.log(\u0026#39;promise1\u0026#39;) }) }, 0) setTimeout(()=\u0026gt;{ console.log(\u0026#39;timer2\u0026#39;) Promise.resolve().then(function() { console.log(\u0026#39;promise2\u0026#39;) }) }, 0) // 以上代码在浏览器和 node 中打印情况是不同的 // 浏览器中一定打印 timer1, promise1, timer2, promise2 // node 中可能打印 timer1, timer2, promise1, promise2 // 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行\n1 2 3 4 5 6 7 8 9 10 11 12 setTimeout(() =\u0026gt; { console.log(\u0026#34;timer1\u0026#34;); Promise.resolve().then(function() { console.log(\u0026#34;promise1\u0026#34;); }); }, 0); process.nextTick(() =\u0026gt; { console.log(\u0026#34;nextTick\u0026#34;); }); // nextTick, timer1, promise1 四、Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API\n目前该技术通常用来做缓存文件，提高首屏速度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(\u0026#34;sw.js\u0026#34;) .then(function(registration) { console.log(\u0026#34;service worker 注册成功\u0026#34;); }) .catch(function(err) { console.log(\u0026#34;servcie worker 注册失败\u0026#34;); }); } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener(\u0026#34;install\u0026#34;, e =\u0026gt; { e.waitUntil( caches.open(\u0026#34;my-cache\u0026#34;).then(function(cache) { return cache.addAll([\u0026#34;./index.html\u0026#34;, \u0026#34;./index.js\u0026#34;]); }) ); }); // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener(\u0026#34;fetch\u0026#34;, e =\u0026gt; { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response; } console.log(\u0026#34;fetch source\u0026#34;); }) ); }); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了\n在 Cache 中也可以发现我们所需的文件已被缓存\n当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的\n五、渲染机制 浏览器的渲染机制一般分为以下几个步骤\n处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM 5.1 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用\n通过以下几个常用属性可以生成新图层\n3D 变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 5.2 重绘（Repaint）和回流（Reflow） 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流\n所以以下几个动作可能会导致性能问题：\n改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关\n当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调 减少重绘和回流\n使用 translate 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/","summary":"二、跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败 2.1 JSONP JSONP 的原理很简单，就是利","title":"浏览器"},{"content":"硅谷甄选 技术栈包含: vue3+TypeScript+vue-router+pinia+element-plus+axios+echarts 等技术栈。\n一、vue3 组件通信方式 通信仓库地址: https://gitee.com/jch1011/vue3_communication.git\n不管是 vue2 还是 vue3,组件通信方式很重要,不管是项目还是面试都是经常用到的知识点。 比如:vue2 组件通信方式\nprops: 可以实现父子组件、子父组件、甚至兄弟组件通信 自定义事件: 可以实现子父组件通信 全局事件总线$bus: 可以实现任意组件通信 pubsub: 发布订阅模式实现任意组件通信 vuex: 集中式状态管理容器，实现任意组件通信 ref: 父组件获取子组件实例 VC,获取子组件的响应式数据以及方法 slot: 插槽(默认插槽、具名插槽、作用域插槽)实现父子组件通信\u0026hellip;\u0026hellip;.. 1.1 props props 可以实现父子组件通信,在 vue3 中我们可以通过 defineProps 获取父组件传递的数据。且在组件内部不需要引入 defineProps 方法可以直接使用！\n父组件给子组件传递数据\n1 \u0026lt;Child info=\u0026#34;我爱祖国\u0026#34; :money=\u0026#34;money\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 子组件获取父组件传递数据:方式 1\n1 2 3 4 5 6 7 8 9 10 let props = defineProps({ info: { type: String, //接受的数据类型 default: \u0026#39;默认参数\u0026#39;, //接受默认数据 }, money: { type: Number, default: 0, }, }) 子组件获取父组件传递数据:方式 2\n1 let props = defineProps([\u0026#39;info\u0026#39;, \u0026#39;money\u0026#39;]) 子组件获取到 props 数据就可以在模板中使用了,但是切记 props 是只读的(只能读取，不能修改)\n1.2 自定义事件 在 vue 框架中事件分为两种:一种是原生的 DOM 事件，另外一种自定义事件。\n原生 DOM 事件可以让用户与网页进行交互，比如 click、dbclick、change、mouseenter、mouseleave\u0026hellip;.\n自定义事件可以实现子组件给父组件传递数据\n1.2.1 原生 DOM 事件 代码如下:\n1 2 3 4 \u0026lt;pre @click=\u0026#34;handler\u0026#34;\u0026gt; 我是祖国的老花骨朵 \u0026lt;/pre \u0026gt; 当前代码级给 pre 标签绑定原生 DOM 事件点击事件,默认会给事件回调注入 event 事件对象。当然点击事件想注入多个参数可以按照下图操作。但是切记注入的事件对象务必叫做$event.\n1 \u0026lt;div @click=\u0026#34;handler1(1,2,3,$event)\u0026#34;\u0026gt;我要传递多个参数\u0026lt;/div\u0026gt; 在 vue3 框架 click、dbclick、change(这类原生 DOM 事件),不管是在标签、自定义标签上(组件标签)都是原生 DOM 事件。\n1.2.2 自定义事件 自定义事件可以实现子组件给父组件传递数据.在项目中是比较常用的。\n比如在父组件内部给子组件(Event2)绑定一个自定义事件\n1 \u0026lt;Event2 @xxx=\u0026#34;handler3\u0026#34;\u0026gt;\u0026lt;/Event2\u0026gt; 在 Event2 子组件内部触发这个自定义事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我是子组件2\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;handler\u0026#34;\u0026gt;点击我触发xxx自定义事件\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; let $emit = defineEmits([\u0026#39;xxx\u0026#39;]) const handler = () =\u0026gt; { $emit(\u0026#39;xxx\u0026#39;, \u0026#39;法拉利\u0026#39;, \u0026#39;茅台\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 我们会发现在 script 标签内部,使用了 defineEmits 方法，此方法是 vue3 提供的方法,不需要引入直接使用。defineEmits 方法执行，传递一个数组，数组元素即为将来组件需要触发的自定义事件类型，此方执行会返回一个$emit 方法用于触发自定义事件。\n当点击按钮的时候，事件回调内部调用$emit 方法去触发自定义事件,第一个参数为触发事件类型，第二个、三个、N 个参数即为传递给父组件的数据。\n需要注意的是:代码如下\n1 \u0026lt;Event2 @xxx=\u0026#34;handler3\u0026#34; @click=\u0026#34;handler\u0026#34;\u0026gt;\u0026lt;/Event2\u0026gt; 正常说组件标签书写@click 应该为原生 DOM 事件,但是如果子组件内部通过 defineEmits 定义就变为自定义事件了\n1 let $emit = defineEmits([\u0026#39;xxx\u0026#39;, \u0026#39;click\u0026#39;]) 1.3 全局事件总线 全局事件总线可以实现任意组件通信，在 vue2 中可以根据 VM 与 VC 关系推出全局事件总线。\n但是在 vue3 中没有 Vue 构造函数，也就没有 Vue.prototype.以及组合式 API 写法没有 this，\n那么在 Vue3 想实现全局事件的总线功能就有点不现实啦，如果想在 Vue3 中使用全局事件总线功能\n可以使用插件 mitt 实现。\nmitt:官网地址: https://www.npmjs.com/package/mitt\n1.4 v-model v-model 指令可是收集表单数据(数据双向绑定)，除此之外它也可以实现父子组件数据同步。\n而 v-model 实指利用 props[modelValue]与自定义事件[update:modelValue]实现的。\n下方代码:相当于给组件 Child 传递一个 props(modelValue)与绑定一个自定义事件 update:modelValue\n实现父子组件数据同步\n1 \u0026lt;Child v-model=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 在 vue3 中一个组件可以通过使用多个 v-model,让父子组件多个数据同步,下方代码相当于给组件 Child 传递两个 props 分别是 pageNo 与 pageSize，以及绑定两个自定义事件 update:pageNo 与 update:pageSize 实现父子数据同步\n1 \u0026lt;Child v-model:pageNo=\u0026#34;msg\u0026#34; v-model:pageSize=\u0026#34;msg1\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 1.5 useAttrs 在 Vue3 中可以利用 useAttrs 方法获取组件的属性与事件(包含:原生 DOM 事件或者自定义事件),次函数功能类似于 Vue2 框架中$attrs属性与$listeners 方法。\n比如:在父组件内部使用一个子组件 my-button\n1 2 3 4 5 6 \u0026lt;my-button type=\u0026#34;success\u0026#34; size=\u0026#34;small\u0026#34; title=\u0026#34;标题\u0026#34; @click=\u0026#34;handler\u0026#34; \u0026gt;\u0026lt;/my-button\u0026gt; 子组件内部可以通过 useAttrs 方法获取组件属性与事件.因此你也发现了，它类似于 props,可以接受父组件传递过来的属性与属性值。需要注意如果 defineProps 接受了某一个属性，useAttrs 方法返回的对象身上就没有相应属性与属性值。\n1 2 3 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {useAttrs} from \u0026#39;vue\u0026#39;; let $attrs = useAttrs(); \u0026lt;/script\u0026gt; 1.6 ref 与$parent ref,提及到 ref 可能会想到它可以获取元素的 DOM 或者获取子组件实例的 VC。既然可以在父组件内部通过 ref 获取子组件实例 VC，那么子组件内部的方法与响应式数据父组件可以使用的。\n比如:在父组件挂载完毕获取组件实例\n父组件内部代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;ref与$parent\u0026lt;/h1\u0026gt; \u0026lt;Son ref=\u0026#34;son\u0026#34;\u0026gt;\u0026lt;/Son\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Son from \u0026#39;./Son.vue\u0026#39; import { onMounted, ref } from \u0026#39;vue\u0026#39; const son = ref() onMounted(() =\u0026gt; { console.log(son.value) }) \u0026lt;/script\u0026gt; 但是需要注意，如果想让父组件获取子组件的数据或者方法需要通过 defineExpose 对外暴露,因为 vue3 中组件内部的数据对外“关闭的”，外部不能访问\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; //数据 let money = ref(1000); //方法 const handler = ()=\u0026gt;{ } defineExpose({ money, handler }) \u0026lt;/script\u0026gt; $parent 可以获取某一个组件的父组件实例 VC,因此可以使用父组件内部的数据与方法。必须子组件内部拥有一个按钮点击时候获取父组件实例，当然父组件的数据与方法需要通过 defineExpose 方法对外暴露\n1 \u0026lt;button @click=\u0026#34;handler($parent)\u0026#34;\u0026gt;点击我获取父组件实例\u0026lt;/button\u0026gt; 1.7 provide 与 inject provide[提供]\ninject[注入]\nvue3 提供两个方法 provide 与 inject,可以实现隔辈组件传递参数\n组件组件提供数据:\nprovide 方法用于提供数据，此方法执需要传递两个参数,分别提供数据的 key 与提供数据 value\n1 2 3 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {provide} from \u0026#39;vue\u0026#39; provide(\u0026#39;token\u0026#39;,\u0026#39;admin_token\u0026#39;); \u0026lt;/script\u0026gt; 后代组件可以通过 inject 方法获取数据,通过 key 获取存储的数值\n1 2 3 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {inject} from \u0026#39;vue\u0026#39; let token = inject(\u0026#39;token\u0026#39;); \u0026lt;/script\u0026gt; 1.8 pinia pinia 官网: https://pinia.web3doc.top/\npinia 也是集中式管理状态容器,类似于 vuex。但是核心概念没有 mutation、modules,使用方式参照官网\n1.9 slot 插槽：默认插槽、具名插槽、作用域插槽可以实现父子组件通信.\n默认插槽:\n在子组件内部的模板中书写 slot 全局组件标签\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 在父组件内部提供结构：Todo 即为子组件,在父组件内部使用的时候，在双标签内部书写结构传递给子组件\n注意开发项目的时候默认插槽一般只有一个\n1 2 3 \u0026lt;Todo\u0026gt; \u0026lt;h1\u0026gt;我是默认插槽填充的结构\u0026lt;/h1\u0026gt; \u0026lt;/Todo\u0026gt; 具名插槽：\n顾名思义，此插槽带有名字在组件内部留多个指定名字的插槽。\n下面是一个子组件内部,模板中留两个插槽\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;todo\u0026lt;/h1\u0026gt; \u0026lt;slot name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;b\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 父组件内部向指定的具名插槽传递结构。需要注意 v-slot：可以替换为#\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;slot\u0026lt;/h1\u0026gt; \u0026lt;Todo\u0026gt; \u0026lt;template v-slot:a\u0026gt; //可以用#a替换 \u0026lt;div\u0026gt;填入组件A部分的结构\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:b\u0026gt; //可以用#b替换 \u0026lt;div\u0026gt;填入组件B部分的结构\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Todo\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Todo from \u0026#39;./Todo.vue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 作用域插槽\n作用域插槽：可以理解为，子组件数据由父组件提供，但是子组件内部决定不了自身结构与外观(样式)\n子组件 Todo 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;todo\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!--组件内部遍历数组--\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in todos\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;!--作用域插槽将数据回传给父组件--\u0026gt; \u0026lt;slot :$row=\u0026#34;item\u0026#34; :$index=\u0026#34;index\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; defineProps([\u0026#39;todos\u0026#39;]) //接受父组件传递过来的数据 \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 父组件内部代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;slot\u0026lt;/h1\u0026gt; \u0026lt;Todo :todos=\u0026#34;todos\u0026#34;\u0026gt; \u0026lt;template v-slot=\u0026#34;{$row,$index}\u0026#34;\u0026gt; \u0026lt;!--父组件决定子组件的结构与外观--\u0026gt; \u0026lt;span :style=\u0026#34;{color:$row.done?\u0026#39;green\u0026#39;:\u0026#39;red\u0026#39;}\u0026#34;\u0026gt;{{$row.title}}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Todo\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Todo from \u0026#39;./Todo.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; //父组件内部数据 let todos = ref([ { id: 1, title: \u0026#39;吃饭\u0026#39;, done: true }, { id: 2, title: \u0026#39;睡觉\u0026#39;, done: false }, { id: 3, title: \u0026#39;打豆豆\u0026#39;, done: true }, ]) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 二、搭建后台管理系统模板 2.1 项目初始化 今天来带大家从 0 开始搭建一个 vue3 版本的后台管理系统。一个项目要有统一的规范，需要使用 eslint+stylelint+prettier 来对我们的代码质量做检测和修复，需要使用 husky 来做 commit 拦截，需要使用 commitlint 来统一提交规范，需要使用 preinstall 来统一包管理工具。\n下面我们就用这一套规范来初始化我们的项目，集成一个规范的模版。\n2.1.1 环境准备 node v16.14.2 pnpm 8.0.0 2.1.2 初始化项目 本项目使用 vite 进行构建，vite 官方中文文档参考：cn.vitejs.dev/guide/\npnpm:performant npm ，意味“高性能的 npm”。pnpm由 npm/yarn 衍生而来，解决了 npm/yarn 内部潜在的 bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具”\npnpm 安装指令\n1 npm i -g pnpm 项目初始化命令:\n1 pnpm create vite 进入到项目根目录 pnpm install 安装全部依赖.安装完依赖运行程序:pnpm run dev\n运行完毕项目跑在http://127.0.0.1:5173/,可以访问你得项目啦\n2.2 项目配置 一、eslint 配置 eslint 中文官网: http://eslint.cn/\nESLint 最初是由Nicholas C. Zakas 于 2013 年 6 月创建的开源项目。它的目标是提供一个插件化的javascript 代码检测工具\n首先安装 eslint\n1 pnpm i eslint -D 生成配置文件:.eslint.cjs\n1 npx eslint --init .eslint.cjs 配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 module.exports = { //运行环境 env: { browser: true, //浏览器端 es2021: true, //es2021 }, //规则继承 extends: [ //全部规则默认是关闭的,这个配置项开启推荐规则,推荐规则参照文档 //比如:函数不能重名、对象不能出现重复key \u0026#39;eslint:recommended\u0026#39;, //vue3语法规则 \u0026#39;plugin:vue/vue3-essential\u0026#39;, //ts语法规则 \u0026#39;plugin:@typescript-eslint/recommended\u0026#39;, ], //要为特定类型的文件指定处理器 overrides: [], //指定解析器:解析器 //Esprima 默认解析器 //Babel-ESLint babel解析器 //@typescript-eslint/parser ts解析器 parser: \u0026#39;@typescript-eslint/parser\u0026#39;, //指定解析器选项 parserOptions: { ecmaVersion: \u0026#39;latest\u0026#39;, //校验ECMA最新版本 sourceType: \u0026#39;module\u0026#39;, //设置为\u0026#34;script\u0026#34;（默认），或者\u0026#34;module\u0026#34;代码在ECMAScript模块中 }, //ESLint支持使用第三方插件。在使用插件之前，您必须使用npm安装它 //该eslint-plugin-前缀可以从插件名称被省略 plugins: [\u0026#39;vue\u0026#39;, \u0026#39;@typescript-eslint\u0026#39;], //eslint规则 rules: {}, } 1.1 vue3 环境代码校验插件 1 2 3 4 5 6 7 8 9 10 # 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查 \u0026#34;eslint-config-prettier\u0026#34;: \u0026#34;^8.6.0\u0026#34;, \u0026#34;eslint-plugin-import\u0026#34;: \u0026#34;^2.27.5\u0026#34;, \u0026#34;eslint-plugin-node\u0026#34;: \u0026#34;^11.1.0\u0026#34;, # 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低 \u0026#34;eslint-plugin-prettier\u0026#34;: \u0026#34;^4.2.1\u0026#34;, # vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南 \u0026#34;eslint-plugin-vue\u0026#34;: \u0026#34;^9.9.0\u0026#34;, # 该解析器允许使用Eslint校验所有babel code \u0026#34;@babel/eslint-parser\u0026#34;: \u0026#34;^7.19.1\u0026#34;, 安装指令\n1 pnpm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser 1.2 修改.eslintrc.cjs 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // @see https://eslint.bootcss.com/docs/rules/ module.exports = { env: { browser: true, es2021: true, node: true, jest: true, }, /* 指定如何解析语法 */ parser: \u0026#39;vue-eslint-parser\u0026#39;, /** 优先级低于 parse 的语法解析配置 */ parserOptions: { ecmaVersion: \u0026#39;latest\u0026#39;, sourceType: \u0026#39;module\u0026#39;, parser: \u0026#39;@typescript-eslint/parser\u0026#39;, jsxPragma: \u0026#39;React\u0026#39;, ecmaFeatures: { jsx: true, }, }, /* 继承已有的规则 */ extends: [ \u0026#39;eslint:recommended\u0026#39;, \u0026#39;plugin:vue/vue3-essential\u0026#39;, \u0026#39;plugin:@typescript-eslint/recommended\u0026#39;, \u0026#39;plugin:prettier/recommended\u0026#39;, ], plugins: [\u0026#39;vue\u0026#39;, \u0026#39;@typescript-eslint\u0026#39;], /* * \u0026#34;off\u0026#34; 或 0 ==\u0026gt; 关闭规则 * \u0026#34;warn\u0026#34; 或 1 ==\u0026gt; 打开的规则作为警告（不影响代码执行） * \u0026#34;error\u0026#34; 或 2 ==\u0026gt; 规则作为一个错误（代码不能执行，界面报错） */ rules: { // eslint（https://eslint.bootcss.com/docs/rules/） \u0026#39;no-var\u0026#39;: \u0026#39;error\u0026#39;, // 要求使用 let 或 const 而不是 var \u0026#39;no-multiple-empty-lines\u0026#39;: [\u0026#39;warn\u0026#39;, { max: 1 }], // 不允许多个空行 \u0026#39;no-console\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;error\u0026#39; : \u0026#39;off\u0026#39;, \u0026#39;no-debugger\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;error\u0026#39; : \u0026#39;off\u0026#39;, \u0026#39;no-unexpected-multiline\u0026#39;: \u0026#39;error\u0026#39;, // 禁止空余的多行 \u0026#39;no-useless-escape\u0026#39;: \u0026#39;off\u0026#39;, // 禁止不必要的转义字符 // typeScript (https://typescript-eslint.io/rules) \u0026#39;@typescript-eslint/no-unused-vars\u0026#39;: \u0026#39;error\u0026#39;, // 禁止定义未使用的变量 \u0026#39;@typescript-eslint/prefer-ts-expect-error\u0026#39;: \u0026#39;error\u0026#39;, // 禁止使用 @ts-ignore \u0026#39;@typescript-eslint/no-explicit-any\u0026#39;: \u0026#39;off\u0026#39;, // 禁止使用 any 类型 \u0026#39;@typescript-eslint/no-non-null-assertion\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/no-namespace\u0026#39;: \u0026#39;off\u0026#39;, // 禁止使用自定义 TypeScript 模块和命名空间。 \u0026#39;@typescript-eslint/semi\u0026#39;: \u0026#39;off\u0026#39;, // eslint-plugin-vue (https://eslint.vuejs.org/rules/) \u0026#39;vue/multi-word-component-names\u0026#39;: \u0026#39;off\u0026#39;, // 要求组件名称始终为 “-” 链接的单词 \u0026#39;vue/script-setup-uses-vars\u0026#39;: \u0026#39;error\u0026#39;, // 防止\u0026lt;script setup\u0026gt;使用的变量\u0026lt;template\u0026gt;被标记为未使用 \u0026#39;vue/no-mutating-props\u0026#39;: \u0026#39;off\u0026#39;, // 不允许组件 prop的改变 \u0026#39;vue/attribute-hyphenation\u0026#39;: \u0026#39;off\u0026#39;, // 对模板中的自定义组件强制执行属性命名样式 }, } 1.3 .eslintignore 忽略文件 1 2 dist node_modules 1.4 运行脚本 package.json 新增两个运行脚本\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;lint\u0026#34;: \u0026#34;eslint src\u0026#34;, \u0026#34;fix\u0026#34;: \u0026#34;eslint src --fix\u0026#34;, } 二、配置prettier 有了 eslint，为什么还要有 prettier？eslint 针对的是 javascript，他是一个检测工具，包含 js 语法以及少部分格式问题，在 eslint 看来，语法对了就能保证代码正常运行，格式问题属于其次；\n而 prettier 属于格式化工具，它看不惯格式不统一，所以它就把 eslint 没干好的事接着干，另外，prettier 支持\n包含 js 在内的多种语言。\n总结起来，eslint 和 prettier 这俩兄弟一个保证 js 代码质量，一个保证代码美观。\n2.1 安装依赖包 1 pnpm install -D eslint-plugin-prettier prettier eslint-config-prettier 2.2 .prettierrc.json 添加规则 1 2 3 4 5 6 7 8 9 { \u0026#34;singleQuote\u0026#34;: true, \u0026#34;semi\u0026#34;: false, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;ignore\u0026#34;, \u0026#34;endOfLine\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;tabWidth\u0026#34;: 2 } 2.3 .prettierignore 忽略文件 1 2 3 4 5 6 7 /dist/* /html/* .local /node_modules/** **/*.svg **/*.sh /public/* 通过 pnpm run lint 去检测语法，如果出现不规范格式,通过 pnpm run fix 修改\n三、配置 stylelint stylelint为 css 的 lint 工具。可格式化 css 代码，检查 css 语法错误与不合理的写法，指定 css 书写顺序等。\n我们的项目中使用 scss 作为预处理器，安装以下依赖：\n1 pnpm add sass sass-loader stylelint postcss postcss-scss postcss-html stylelint-config-prettier stylelint-config-recess-order stylelint-config-recommended-scss stylelint-config-standard stylelint-config-standard-vue stylelint-scss stylelint-order stylelint-config-standard-scss -D 3.1 .stylelintrc.cjs 配置文件 官网:https://stylelint.bootcss.com/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // @see https://stylelint.bootcss.com/ module.exports = { extends: [ \u0026#39;stylelint-config-standard\u0026#39;, // 配置stylelint拓展插件 \u0026#39;stylelint-config-html/vue\u0026#39;, // 配置 vue 中 template 样式格式化 \u0026#39;stylelint-config-standard-scss\u0026#39;, // 配置stylelint scss插件 \u0026#39;stylelint-config-recommended-vue/scss\u0026#39;, // 配置 vue 中 scss 样式格式化 \u0026#39;stylelint-config-recess-order\u0026#39;, // 配置stylelint css属性书写顺序插件, \u0026#39;stylelint-config-prettier\u0026#39;, // 配置stylelint和prettier兼容 ], overrides: [ { files: [\u0026#39;**/*.(scss|css|vue|html)\u0026#39;], customSyntax: \u0026#39;postcss-scss\u0026#39;, }, { files: [\u0026#39;**/*.(html|vue)\u0026#39;], customSyntax: \u0026#39;postcss-html\u0026#39;, }, ], ignoreFiles: [ \u0026#39;**/*.js\u0026#39;, \u0026#39;**/*.jsx\u0026#39;, \u0026#39;**/*.tsx\u0026#39;, \u0026#39;**/*.ts\u0026#39;, \u0026#39;**/*.json\u0026#39;, \u0026#39;**/*.md\u0026#39;, \u0026#39;**/*.yaml\u0026#39;, ], /** * null =\u0026gt; 关闭该规则 * always =\u0026gt; 必须 */ rules: { \u0026#39;value-keyword-case\u0026#39;: null, // 在 css 中使用 v-bind，不报错 \u0026#39;no-descending-specificity\u0026#39;: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器 \u0026#39;function-url-quotes\u0026#39;: \u0026#39;always\u0026#39;, // 要求或禁止 URL 的引号 \u0026#34;always(必须加上引号)\u0026#34;|\u0026#34;never(没有引号)\u0026#34; \u0026#39;no-empty-source\u0026#39;: null, // 关闭禁止空源码 \u0026#39;selector-class-pattern\u0026#39;: null, // 关闭强制选择器类名的格式 \u0026#39;property-no-unknown\u0026#39;: null, // 禁止未知的属性(true 为不允许) \u0026#39;block-opening-brace-space-before\u0026#39;: \u0026#39;always\u0026#39;, //大括号之前必须有一个空格或不能有空白符 \u0026#39;value-no-vendor-prefix\u0026#39;: null, // 关闭 属性值前缀 --webkit-box \u0026#39;property-no-vendor-prefix\u0026#39;: null, // 关闭 属性前缀 -webkit-mask \u0026#39;selector-pseudo-class-no-unknown\u0026#39;: [ // 不允许未知的选择器 true, { ignorePseudoClasses: [\u0026#39;global\u0026#39;, \u0026#39;v-deep\u0026#39;, \u0026#39;deep\u0026#39;], // 忽略属性，修改element默认样式的时候能使用到 }, ], }, } 3.2 .stylelintignore 忽略文件 1 2 3 4 /node_modules/* /dist/* /html/* /public/* 3.3 运行脚本 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;lint:style\u0026#34;: \u0026#34;stylelint src/**/*.{css,scss,vue} --cache --fix\u0026#34; } 最后配置统一的 prettier 来格式化我们的 js 和 css，html 代码\n1 2 3 4 5 6 7 8 9 10 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite --open\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint src\u0026#34;, \u0026#34;fix\u0026#34;: \u0026#34;eslint src --fix\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;prettier --write \\\u0026#34;./**/*.{html,vue,ts,js,json,md}\\\u0026#34;\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint src/**/*.{ts,vue} --cache --fix\u0026#34;, \u0026#34;lint:style\u0026#34;: \u0026#34;stylelint src/**/*.{css,scss,vue} --cache --fix\u0026#34; }, 当我们运行pnpm run format的时候，会把代码直接格式化\n四、配置 husky 在上面我们已经集成好了我们代码校验工具，但是需要每次手动的去执行命令才会格式化我们的代码。如果有人没有格式化就提交了远程仓库中，那这个规范就没什么用。所以我们需要强制让开发人员按照代码规范来提交。\n要做到这件事情，就需要利用 husky 在代码提交之前触发 git hook(git 在客户端的钩子)，然后执行pnpm run format来自动的格式化我们的代码。\n安装husky\n1 pnpm install -D husky 执行\n1 npx husky-init 会在根目录下生成个一个.husky 目录，在这个目录下面会有一个 pre-commit 文件，这个文件里面的命令在我们执行 commit 的时候就会执行\n在.husky/pre-commit文件添加如下命令：\n1 2 3 #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; pnpm run format 当我们对代码进行 commit 操作的时候，就会执行命令，对代码进行格式化，然后再提交。\n五、配置 commitlint 对于我们的 commit 信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用commitlint来实现。\n安装包\n1 pnpm add @commitlint/config-conventional @commitlint/cli -D 添加配置文件，新建commitlint.config.cjs(注意是 cjs)，然后添加下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 module.exports = { extends: [\u0026#39;@commitlint/config-conventional\u0026#39;], // 校验规则 rules: { \u0026#39;type-enum\u0026#39;: [ 2, \u0026#39;always\u0026#39;, [ \u0026#39;feat\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;docs\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;refactor\u0026#39;, \u0026#39;perf\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;chore\u0026#39;, \u0026#39;revert\u0026#39;, \u0026#39;build\u0026#39;, ], ], \u0026#39;type-case\u0026#39;: [0], \u0026#39;type-empty\u0026#39;: [0], \u0026#39;scope-empty\u0026#39;: [0], \u0026#39;scope-case\u0026#39;: [0], \u0026#39;subject-full-stop\u0026#39;: [0, \u0026#39;never\u0026#39;], \u0026#39;subject-case\u0026#39;: [0, \u0026#39;never\u0026#39;], \u0026#39;header-max-length\u0026#39;: [0, \u0026#39;always\u0026#39;, 72], }, } 在package.json中配置 scripts 命令\n1 2 3 4 5 6 // 在scrips中添加下面的代码 { \u0026#34;scripts\u0026#34;: { \u0026#34;commitlint\u0026#34;: \u0026#34;commitlint --config commitlint.config.cjs -e -V\u0026#34; } } 配置结束，现在当我们填写commit信息的时候，前面就需要带着下面的subject\n1 2 3 4 5 6 7 8 9 10 \u0026#39;feat\u0026#39;,//新特性、新功能 \u0026#39;fix\u0026#39;,//修改bug \u0026#39;docs\u0026#39;,//文档修改 \u0026#39;style\u0026#39;,//代码格式修改, 注意不是 css 修改 \u0026#39;refactor\u0026#39;,//代码重构 \u0026#39;perf\u0026#39;,//优化相关，比如提升性能、体验 \u0026#39;test\u0026#39;,//测试用例修改 \u0026#39;chore\u0026#39;,//其他修改, 比如改变构建流程、或者增加依赖库、工具等 \u0026#39;revert\u0026#39;,//回滚到上一个版本 \u0026#39;build\u0026#39;,//编译相关的修改，例如发布版本、对项目构建或者依赖的改动 配置 husky\n1 npx husky add .husky/commit-msg 在生成的 commit-msg 文件中添加下面的命令\n1 2 3 #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; pnpm commitlint 当我们 commit 提交信息时，就不能再随意写了，必须是 git commit -m \u0026lsquo;fix: xxx\u0026rsquo; 符合类型的才可以，需要注意的是类型的后面需要用英文的 :，并且冒号后面是需要空一格的，这个是不能省略的\n六、强制使用 pnpm 包管理器工具 团队开发项目的时候，需要统一包管理器工具,因为不同包管理器工具下载同一个依赖,可能版本不一样,\n导致项目出现 bug 问题,因此包管理器工具需要统一管理！！！\n在根目录创建scritps/preinstall.js文件，添加下面的内容\n1 2 3 4 5 6 7 if (!/pnpm/.test(process.env.npm_execpath || \u0026#39;\u0026#39;)) { console.warn( `\\u001b[33mThis repository must using pnpm as the package manager ` + ` for scripts to work properly.\\u001b[39m\\n`, ) process.exit(1) } 配置命令\n1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;preinstall\u0026#34;: \u0026#34;node ./scripts/preinstall.js\u0026#34; } 当我们使用 npm 或者 yarn 来安装包的时候，就会报错了。原理就是在 install 的时候会触发 preinstall（npm 提供的生命周期钩子）这个文件里面的代码。\n三、项目集成 3.1 集成 element-plus 硅谷甄选运营平台,UI 组件库采用的 element-plus，因此需要集成 element-plus 插件！！！\n官网地址:https://element-plus.gitee.io/zh-CN/\n1 pnpm install element-plus @element-plus/icons-vue 入口文件 main.ts 全局安装 element-plus,element-plus 默认支持语言英语设置为中文\n1 2 3 4 5 6 7 import ElementPlus from \u0026#39;element-plus\u0026#39; import \u0026#39;element-plus/dist/index.css\u0026#39; //@ts-ignore忽略当前文件ts类型的检测否则有红色提示(打包会失败) import zhCn from \u0026#39;element-plus/dist/locale/zh-cn.mjs\u0026#39; app.use(ElementPlus, { locale: zhCn, }) Element Plus 全局组件类型声明\n1 2 3 4 5 6 7 // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { // ... \u0026#34;types\u0026#34;: [\u0026#34;element-plus/global\u0026#34;] } } 配置完毕可以测试 element-plus 组件与图标的使用.\n3.2 src 别名的配置 在开发项目的时候文件与文件关系可能很复杂，因此我们需要给 src 文件夹配置一个别名！！！\n1 2 3 4 5 6 7 8 9 10 11 12 // vite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import path from \u0026#39;path\u0026#39; export default defineConfig({ plugins: [vue()], resolve: { alias: { \u0026#39;@\u0026#39;: path.resolve(\u0026#39;./src\u0026#39;), // 相对路径别名配置，使用 @ 代替 src }, }, }) TypeScript 编译配置\n1 2 3 4 5 6 7 8 9 10 // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 解析非相对模块的基地址，默认是当前目录 \u0026#34;paths\u0026#34;: { //路径映射，相对于baseUrl \u0026#34;@/*\u0026#34;: [\u0026#34;src/*\u0026#34;] } } } 3.3 环境变量的配置 项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。\n开发环境（development） 顾名思义，开发使用的环境，每位开发人员在自己的 dev 分支上干活，开发到一定程度，同事会合并代码，进行联调。\n测试环境（testing） 测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试\n生产环境（production） 生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境。)\n注意:一般情况下，一个环境对应一台服务器,也有的公司开发与测试环境是一台服务器！！！\n项目根目录分别添加 开发、生产和测试环境的文件!\n1 2 3 .env.development .env.production .env.test 文件内容\n1 2 3 4 # 变量必须以 VITE_ 为前缀才能暴露给外部读取 NODE_ENV = \u0026#39;development\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/dev-api\u0026#39; 1 2 3 NODE_ENV = \u0026#39;production\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/prod-api\u0026#39; 1 2 3 4 # 变量必须以 VITE_ 为前缀才能暴露给外部读取 NODE_ENV = \u0026#39;test\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/test-api\u0026#39; 配置运行命令：package.json\n1 2 3 4 5 6 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite --open\u0026#34;, \u0026#34;build:test\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build --mode test\u0026#34;, \u0026#34;build:pro\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build --mode production\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; }, 通过 import.meta.env 获取环境变量\n3.4 SVG 图标配置 在开发项目的时候经常会用到 svg 矢量图,而且我们使用 SVG 以后，页面上加载的不再是图片资源,\n这对页面性能来说是个很大的提升，而且我们 SVG 文件比 img 要小的很多，放在项目中几乎不占用资源。\n安装 SVG 依赖插件\n1 pnpm install vite-plugin-svg-icons -D 在vite.config.ts中配置插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { createSvgIconsPlugin } from \u0026#39;vite-plugin-svg-icons\u0026#39; import path from \u0026#39;path\u0026#39; export default () =\u0026gt; { return { plugins: [ createSvgIconsPlugin({ // Specify the icon folder to be cached iconDirs: [path.resolve(process.cwd(), \u0026#39;src/assets/icons\u0026#39;)], // Specify symbolId format symbolId: \u0026#39;icon-[dir]-[name]\u0026#39;, }), ], } } 入口文件导入\n1 import \u0026#39;virtual:svg-icons-register\u0026#39; 3.4.1 svg 封装为全局组件 因为项目很多模块需要使用图标,因此把它封装为全局组件！！！\n在 src/components 目录下创建一个 SvgIcon 组件:代表如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;svg :style=\u0026#34;{ width: width, height: height }\u0026#34;\u0026gt; \u0026lt;use :xlink:href=\u0026#34;prefix + name\u0026#34; :fill=\u0026#34;color\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; defineProps({ //xlink:href属性值的前缀 prefix: { type: String, default: \u0026#39;#icon-\u0026#39;, }, //svg矢量图的名字 name: String, //svg图标的颜色 color: { type: String, default: \u0026#39;\u0026#39;, }, //svg宽度 width: { type: String, default: \u0026#39;16px\u0026#39;, }, //svg高度 height: { type: String, default: \u0026#39;16px\u0026#39;, }, }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 在 src 文件夹目录下创建一个 index.ts 文件：用于注册 components 文件夹内部全部全局组件！！！\n1 2 3 4 5 6 7 8 9 10 import SvgIcon from \u0026#39;./SvgIcon/index.vue\u0026#39; import type { App, Component } from \u0026#39;vue\u0026#39; const components: { [name: string]: Component } = { SvgIcon } export default { install(app: App) { Object.keys(components).forEach((key: string) =\u0026gt; { app.component(key, components[key]) }) }, } 在入口文件引入 src/index.ts 文件,通过 app.use 方法安装自定义插件\n1 2 import gloablComponent from \u0026#39;./components/index\u0026#39; app.use(gloablComponent) 3.5 集成 sass 我们目前在组件内部已经可以使用 scss 样式,因为在配置 styleLint 工具的时候，项目当中已经安装过 sass sass-loader,因此我们再组件内可以使用 scss 语法！！！需要加上 lang=\u0026ldquo;scss\u0026rdquo;\n1 \u0026lt;style scoped lang=\u0026#34;scss\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; 接下来我们为项目添加一些全局的样式\n在 src/styles 目录下创建一个 index.scss 文件，当然项目中需要用到清除默认样式，因此在 index.scss 引入 reset.scss\n1 @import reset.scss 在入口文件引入\n1 import \u0026#39;@/styles\u0026#39; 但是你会发现在 src/styles/index.scss 全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$.\n在 style/variable.scss 创建一个 variable.scss 文件！\n在 vite.config.ts 文件配置如下:\n1 2 3 4 5 6 7 8 9 10 11 export default defineConfig((config) =\u0026gt; { css: { preprocessorOptions: { scss: { javascriptEnabled: true, additionalData: \u0026#39;@import \u0026#34;./src/styles/variable.scss\u0026#34;;\u0026#39;, }, }, }, } } @import \u0026quot;./src/styles/variable.less\u0026quot;;后面的;不要忘记，不然会报错!\n配置完毕你会发现 scss 提供这些全局变量可以在组件样式中使用了！！！\n3.6 mock 数据 安装依赖:https://www.npmjs.com/package/vite-plugin-mock\n1 pnpm install -D vite-plugin-mock mockjs 在 vite.config.js 配置文件启用插件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { UserConfigExport, ConfigEnv } from \u0026#39;vite\u0026#39; import { viteMockServe } from \u0026#39;vite-plugin-mock\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; export default ({ command }) =\u0026gt; { return { plugins: [ vue(), viteMockServe({ localEnabled: command === \u0026#39;serve\u0026#39;, }), ], } } 在根目录创建 mock 文件夹:去创建我们需要 mock 数据与接口！！！\n在 mock 文件夹内部创建一个 user.ts 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 //用户信息数据 function createUserList() { return [ { userId: 1, avatar: \u0026#39;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026#39;, username: \u0026#39;admin\u0026#39;, password: \u0026#39;111111\u0026#39;, desc: \u0026#39;平台管理员\u0026#39;, roles: [\u0026#39;平台管理员\u0026#39;], buttons: [\u0026#39;cuser.detail\u0026#39;], routes: [\u0026#39;home\u0026#39;], token: \u0026#39;Admin Token\u0026#39;, }, { userId: 2, avatar: \u0026#39;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026#39;, username: \u0026#39;system\u0026#39;, password: \u0026#39;111111\u0026#39;, desc: \u0026#39;系统管理员\u0026#39;, roles: [\u0026#39;系统管理员\u0026#39;], buttons: [\u0026#39;cuser.detail\u0026#39;, \u0026#39;cuser.user\u0026#39;], routes: [\u0026#39;home\u0026#39;], token: \u0026#39;System Token\u0026#39;, }, ] } export default [ // 用户登录接口 { url: \u0026#39;/api/user/login\u0026#39;, //请求地址 method: \u0026#39;post\u0026#39;, //请求方式 response: ({ body }) =\u0026gt; { //获取请求体携带过来的用户名与密码 const { username, password } = body //调用获取用户信息函数,用于判断是否有此用户 const checkUser = createUserList().find( (item) =\u0026gt; item.username === username \u0026amp;\u0026amp; item.password === password, ) //没有用户返回失败信息 if (!checkUser) { return { code: 201, data: { message: \u0026#39;账号或者密码不正确\u0026#39; } } } //如果有返回成功信息 const { token } = checkUser return { code: 200, data: { token } } }, }, // 获取用户信息 { url: \u0026#39;/api/user/info\u0026#39;, method: \u0026#39;get\u0026#39;, response: (request) =\u0026gt; { //获取请求头携带token const token = request.headers.token //查看用户信息是否包含有次token用户 const checkUser = createUserList().find((item) =\u0026gt; item.token === token) //没有返回失败的信息 if (!checkUser) { return { code: 201, data: { message: \u0026#39;获取用户信息失败\u0026#39; } } } //如果有返回成功信息 return { code: 200, data: { checkUser } } }, }, ] 安装 axios\n1 pnpm install axios 最后通过 axios 测试接口！！！\n3.7 axios 二次封装 在开发项目的时候避免不了与后端进行交互,因此我们需要使用 axios 插件实现发送网络请求。在开发项目的时候\n我们经常会把 axios 进行二次封装。\n目的:\n1:使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数)\n2:使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理 http 网络错误)\n在根目录下创建 utils/request.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import axios from \u0026#39;axios\u0026#39; import { ElMessage } from \u0026#39;element-plus\u0026#39; //创建axios实例 let request = axios.create({ baseURL: import.meta.env.VITE_APP_BASE_API, timeout: 5000, }) //请求拦截器 request.interceptors.request.use((config) =\u0026gt; { return config }) //响应拦截器 request.interceptors.response.use( (response) =\u0026gt; { return response.data }, (error) =\u0026gt; { //处理网络错误 let msg = \u0026#39;\u0026#39; let status = error.response.status switch (status) { case 401: msg = \u0026#39;token过期\u0026#39; break case 403: msg = \u0026#39;无权访问\u0026#39; break case 404: msg = \u0026#39;请求地址错误\u0026#39; break case 500: msg = \u0026#39;服务器出现问题\u0026#39; break default: msg = \u0026#39;无网络\u0026#39; } ElMessage({ type: \u0026#39;error\u0026#39;, message: msg, }) return Promise.reject(error) }, ) export default request 3.8 API 接口统一管理 在开发项目的时候,接口可能很多需要统一管理。在 src 目录下去创建 api 文件夹去统一管理项目的接口；\n比如:下面方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //统一管理咱们项目用户相关的接口 import request from \u0026#39;@/utils/request\u0026#39; import type { loginFormData, loginResponseData, userInfoReponseData, } from \u0026#39;./type\u0026#39; //项目用户相关的请求地址 enum API { LOGIN_URL = \u0026#39;/admin/acl/index/login\u0026#39;, USERINFO_URL = \u0026#39;/admin/acl/index/info\u0026#39;, LOGOUT_URL = \u0026#39;/admin/acl/index/logout\u0026#39;, } //登录接口 export const reqLogin = (data: loginFormData) =\u0026gt; request.post\u0026lt;any, loginResponseData\u0026gt;(API.LOGIN_URL, data) //获取用户信息 export const reqUserInfo = () =\u0026gt; request.get\u0026lt;any, userInfoReponseData\u0026gt;(API.USERINFO_URL) //退出登录 export const reqLogout = () =\u0026gt; request.post\u0026lt;any, any\u0026gt;(API.LOGOUT_URL) 四、项目的资源地址 贾成豪老师代码仓库地址:https://gitee.com/jch1011/vue3_admin_template-bj1.git\n项目在线文档:\n服务器域名:http://sph-api.atguigu.cn\nswagger 文档:\nhttp://139.198.104.58:8209/swagger-ui.html\nhttp://139.198.104.58:8212/swagger-ui.html#/\necharts:国内镜像网站\nhttps://www.isqqw.com/echarts-doc/zh/option.html#title\nhttp://datav.aliyun.com/portal/school/atlas/area_selector\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E7%A1%85%E8%B0%B7%E7%94%84%E9%80%89%E7%AC%94%E8%AE%B0/","summary":"硅谷甄选 技术栈包含: vue3+TypeScript+vue-router+pinia+element-plus+axios+echarts 等技术栈。 一、vue3 组件通信方式 通信仓库地址: https://gitee.com/jch1011/vue3_communication.git 不管是 vue2 还是 vue3,组件通信方式很重要,不管是项目还是面试都是经常","title":"浏览器"},{"content":"Whistle 官网 Whistle 官网：https://wproxy.org/whistle/\nWhistle 的 GitHub：https://github.com/avwo/whistle\nWhistle 安装启动 1、Whistle 安装 （1）通过 npm 安装 Whistle\n2、启动 whistle 1 w2 start 然后在浏览器输入http://127.0.0.1:8899/ 即可打开代理配置的页面。\n3、配置代理 chrome浏览器配置代理：\n暂略。\nFirefox浏览器配置代理：\n4、安装证书并添加信任： 手机设置代理 连接好指定的wifi后，点击那个wifi里的设置，将「代理」那一项，设置为手动，然后输入ip（电脑上的ip）、端口号（8899）。然后就可以通过电脑上的whistle工具，查看手机的网页请求。\n注意，要保证手机和电脑在同一个网络下。\n捕获和拦截https请求 whistle安装证书后，可以拦截 https 请求。但是，我现在又不想拦截https请求了，该怎么卸载证书呢？\n我发现，证书无法卸载，正确的操作是：\n上图中，把红框部分，去掉勾选，就不捕获https了。谢谢azh童鞋。\n参考链接：\nAndroid 手机如何设置http代理？\n使用 Whistle 对 iOS HTTPS 进行抓包\n移动端调试神器:eruda 手机连接代理时，如何看console.log的日志信息?\n现在，代码里有console.log，如果是在电脑浏览器上看，可以直接在控制台查看console.log的内容。但是，如果手机连接代理，在手机上打开网页的话，要怎么查看console.log的内容呢？具体做法如下：\n（1）在 whistle中，新建一个名叫Eruda H5的代理，代理中的内容是：\n1 http://xxx.com htmlAppend://{eruda.html} (2)新建一个values，里面的内容是：\n1 2 3 4 \u0026lt;script src=\u0026#34;//cdn.bootcss.com/eruda/1.4.3/eruda.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; eruda.init() \u0026lt;/script\u0026gt; 然后就OK了。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%92%8C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7whistle/","summary":"Whistle 官网 Whistle 官网：https://wproxy.org/whistle/ Whistle 的 GitHub：https://github.com/avwo/whi","title":"网络抓包和代理工具：Whistle"},{"content":"一、CSS相关 1.1 左边定宽，右边自适应方案：float + margin，float + calc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 方案1 */ .left { width: 120px; float: left; } .right { margin-left: 120px; } /* 方案2 */ .left { width: 120px; float: left; } .right { width: calc(100% - 120px); float: left; } 1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 .wrap { width: 100%; height: 200px; } .wrap \u0026gt; div { height: 100%; } /* 方案1 */ .left { width: 120px; float: left; } .right { float: right; width: 120px; } .center { margin: 0 120px; } /* 方案2 */ .left { width: 120px; float: left; } .right { float: right; width: 120px; } .center { width: calc(100% - 240px); margin-left: 120px; } /* 方案3 */ .wrap { display: flex; } .left { width: 120px; } .right { width: 120px; } .center { flex: 1; } 1.3 左右居中 行内元素: text-align: center 定宽块状元素: 左右 margin 值为 auto 不定宽块状元素: table布局，position + transform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* 方案1 */ .wrap { text-align: center } .center { display: inline; /* or */ /* display: inline-block; */ } /* 方案2 */ .center { width: 100px; margin: 0 auto; } /* 方案2 */ .wrap { position: relative; } .center { position: absulote; left: 50%; transform: translateX(-50%); } 1.4 上下垂直居中 定高：margin，position + margin(负值) 不定高：position + transform，flex，IFC + vertical-align:middle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* 定高方案1 */ .center { height: 100px; margin: 50px 0; } /* 定高方案2 */ .center { height: 100px; position: absolute; top: 50%; margin-top: -25px; } /* 不定高方案1 */ .center { position: absolute; top: 50%; transform: translateY(-50%); } /* 不定高方案2 */ .wrap { display: flex; align-items: center; } .center { width: 100%; } /* 不定高方案3 */ /* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */ .wrap::before { content: \u0026#39;\u0026#39;; height: 100%; display: inline-block; vertical-align: middle; } .wrap { text-align: center; } .center { display: inline-block; vertical-align: middle; } 1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距） 延伸： box-sizing\ncontent-box：默认值，总宽度 = margin + border + padding + width border-box：盒子宽度包含 padding 和 border，总宽度 = margin + width inherit：从父元素继承 box-sizing 属性 1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文 BFC：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 BFC)。产生 BFC 方式如下\nfloat 的值不为 none。 overflow 的值不为 visible。 position 的值不为 relative 和 static。 display 的值为 table-cell, table-caption, inline-block中的任何一个 用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行\nIFC：内联格式化上下文，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。\nIFC中的line box一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div ）会产生两个匿名块与 div 分隔开，即产生两个 IFC ，每个 IFC 对外表现为块级元素，与 div 垂直排列。\n用处？\n水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生IFC，通过 text-align 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中 GFC：网格布局格式化上下文（display: grid） FFC：自适应格式化上下文（display: flex） 二、JS 基础（ES5） 2.1 原型 这里可以谈很多，只要围绕 [[ prototype ]] 谈，都没啥问题\n2.2 闭包 牵扯作用域，可以两者联系起来一起谈\n2.3 作用域 词法作用域，动态作用域\n2.4 this 不同情况的调用，this指向分别如何。顺带可以提一下 es6 中箭头函数没有 this, arguments, super 等，这些只依赖包含箭头函数最接近的函数\n2.5 call，apply，bind 三者用法和区别 参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call，apply 立即执行，bind 是return 出一个 this “固定”的函数，这也是为什么 bind 是强绑定的一个原因）\n注：“固定”这个词的含义，它指的固定是指只要传进去了 context，则 bind 中 return 出来的函数 this 便一直指向 context，除非 context 是个变量\n2.6 变量声明提升 js 代码在运行前都会进行 AST 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 AST 解析，这里也可以说是形成词法作用域的主要原因\n三、JS 基础（ES6） 3.1 let，const let 产生块级作用域（通常配合 for 循环或者 {} 进行使用产生块级作用域），const 申明的变量是常量（内存地址不变）\n3.2 Promise 这里你谈 promise的时候，除了将他解决的痛点以及常用的 API 之外，最好进行拓展把 eventloop 带进来好好讲一下，microtask(微任务)、macrotask(任务) 的执行顺序，如果看过 promise 源码，最好可以谈一谈 原生 Promise 是如何实现的。Promise 的关键点在于callback 的两个参数，一个是 resovle，一个是 reject。还有就是 Promise 的链式调用（Promise.then()，每一个 then 都是一个责任人）\n3.3 Generator 遍历器对象生成函数，最大的特点是可以交出函数的执行权\nfunction 关键字与函数名之间有一个星号； 函数体内部使用 yield表达式，定义不同的内部状态； next 指针移向下一个状态 这里你可以说说 Generator的异步编程，以及它的语法糖 async 和 awiat，传统的异步编程。ES6 之前，异步编程大致如下\n回调函数 事件监听 发布/订阅 传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。\n3.4 async、await Generator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。\nasync =\u0026gt; * await =\u0026gt; yield 1 2 3 4 5 6 7 8 9 10 11 12 // 基本用法 async function timeout (ms) { await new Promise((resolve) =\u0026gt; { setTimeout(resolve, ms) }) } async function asyncConsole (value, ms) { await timeout(ms) console.log(value) } asyncConsole(\u0026#39;hello async and await\u0026#39;, 1000) 注：最好把2，3，4 连到一起讲\n3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点 AMD：requirejs 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置 CMD：seajs 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近 CommonJs：模块输出的是一个值的 copy，运行时加载，加载的是一个对象（module.exports 属性），该对象只有在脚本运行完才会生成 ES6 Module：模块输出的是一个值的引用，编译时输出接口，ES6模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。 四、框架相关 4.1 数据双向绑定原理：常见数据绑定的方案 Object.defineProperty（vue）：劫持数据的 getter 和 setter 脏值检测（angularjs）：通过特定事件进行轮循 发布/订阅模式：通过消息发布并将消息进行订阅 4.2 VDOM：三个 part 虚拟节点类，将真实 DOM 节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM 节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象 re-render：解析 patch 对象，进行 re-render 补充1：VDOM 的必要性？\n创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。 触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。 补充2：vue 为什么采用 vdom？\n引入 Virtual DOM 在性能方面的考量仅仅是一方面。\n性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好还真不是一个容易下定论的问题。 Vue 之所以引入了 Virtual DOM，更重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是： 不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升； 可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。 综上，Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。\n4.3 vue 和 react 区别 相同点：都支持 ssr，都有 vdom，组件化开发，实现 webComponents 规范，数据驱动等 不同点：vue 是双向数据流（当然为了实现单数据流方便管理组件状态，vuex 便出现了），react 是单向数据流。vue 的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树，react 每当应该状态被改变时，全部子组件都会 re-render 4.4 为什么用 vue 简洁、轻快、舒服\n五、网络基础类 5.1 跨域 很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 jsonp、iframe、cors、img、HTML5 postMessage等等。其中用到 html 标签进行跨域的原理就是 html 不受同源策略影响。但只是接受 Get 的请求方式，这个得清楚。\n延伸1：img iframe script 来发送跨域请求有什么优缺点？\n1. iframe\n优点：跨域完毕之后DOM操作和互相之间的JavaScript调用都是没有问题的 缺点：1.若结果要以URL参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是iframe本身带来的，母页面和iframe本身的交互本身就有安全性限制。 2. script\n优点：可以直接返回json格式的数据，方便处理 缺点：只接受GET请求方式 3. 图片ping\n优点：可以访问任何url，一般用来进行点击追踪，做页面分析常用的方法 缺点：不能访问响应文本，只能监听是否响应 延伸2：配合 webpack 进行反向代理？\nwebpack 在 devServer 选项里面提供了一个 proxy 的参数供开发人员进行反向代理\n1 2 3 4 5 6 7 \u0026#39;/api\u0026#39;: { target: \u0026#39;http://www.example.com\u0026#39;, // your target host changeOrigin: true, // needed for virtual hosted sites pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; // rewrite path } }, 然后再配合 http-proxy-middleware 插件对 api 请求地址进行代理\n1 2 3 4 5 6 7 8 9 const express = require(\u0026#39;express\u0026#39;); const proxy = require(\u0026#39;http-proxy-middleware\u0026#39;); // proxy api requests const exampleProxy = proxy(options); // 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项 // mount `exampleProxy` in web server const app = express(); app.use(\u0026#39;/api\u0026#39;, exampleProxy); app.listen(3000); 然后再用 nginx 把允许跨域的源地址添加到报头里面即可\n说到 nginx ，可以再谈谈 CORS 配置，大致如下\n1 2 3 4 5 6 7 8 9 10 11 12 location / { if ($request_method = \u0026#39;OPTIONS\u0026#39;) { add_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;*\u0026#39;; add_header \u0026#39;Access-Control-Allow-Methods\u0026#39; \u0026#39;GET, POST, OPTIONS\u0026#39;; add_header \u0026#39;Access-Control-Allow-Credentials\u0026#39; \u0026#39;true\u0026#39;; add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type\u0026#39;; add_header \u0026#39;Access-Control-Max-Age\u0026#39; 86400; add_header \u0026#39;Content-Type\u0026#39; \u0026#39;text/plain charset=UTF-8\u0026#39;; add_header \u0026#39;Content-Length\u0026#39; 0; return 200; } } 5.2 http 无状态无连接 http 协议对于事务处理没有记忆能力 对同一个url请求没有上下文关系 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 人生若只如初见，请求过的资源下一次会继续进行请求 http协议无状态中的 状态 到底指的是什么？！\n【状态】的含义就是：客户端和服务器在某次会话中产生的数据 那么对应的【无状态】就意味着：这些数据不会被保留 通过增加cookie和session机制，现在的网络请求其实是有状态的 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话 5.3 http-cache：就是 http 缓存 1. 首先得明确 http 缓存的好处\n减少了冗余的数据传输，减少网费 减少服务器端的压力 Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间 加快客户端加载网页的速度 2. 常见 http 缓存的类型\n私有缓存（一般为本地浏览器缓存） 代理缓存 3. 然后谈谈本地缓存\n本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是\n第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来 第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去Cache-Control的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器 如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。 与本地缓存相关的头有：Cache-Control、Expires，Cache-Control有多个可选值代表不同的意义，而Expires就是一个日期格式的绝对值。\n3.1 Cache-Control\nCache-Control是HTPP缓存策略中最重要的头，它是HTTP/1.1中出现的，它由如下几个值\nno-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 max-age：从当前请求开始，允许获取的响应被重用的最长时间（秒）。 1 2 3 4 # 例如： Cache-Control: public, max-age=1000 # 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。 3.2 Expires\nExpires是HTTP/1.0出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如Mon, 10 Jun 2015 21:31:12 GMT，只要发送请求时间是在Expires之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现Cache-Control：max-age和Expires，那么max-age优先级更高。他们可以这样组合使用\n1 2 Cache-Control: public Expires: Wed, Jan 10 2018 00:27:04 GMT 3.3 所谓的缓存协商\n当第一次请求时服务器返回的响应头中存在以下情况时\n没有 Cache-Control 和 Expires Cache-Control 和 Expires 过期了 Cache-Control 的属性设置为 no-cache 时 那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据HTTP的另外两组头信息，分别是：Last-Modified/If-Modified-Since 与 ETag/If-None-Match。\nLast-Modified 与 If-Modified-Since\n浏览器第一次请求资源时，服务器会把资源的最新修改时间Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT放在响应头中返回给浏览器 第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头If-Modified-Since:Thu, 29 Dec 2011 18:23:55发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比 如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时Last-Modified头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同Last-Modified头一起返回\n1 2 3 4 # 第一次请求返回的响应头 Cache-Control:max-age=3600 Expires: Fri, Jan 12 2018 00:27:04 GMT Last-Modified: Wed, Jan 10 2018 00:27:04 GMT 1 2 # 第二次请求的请求头信息 If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT 这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 ETag 与 If-None-Match\nETag与If-None-Match\nETag/If-None-Match与Last-Modified/If-Modified-Since的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如MD5 hash）来判断\n浏览器发送第二次请求时，会把第一次的响应头信息ETag的值放在If-None-Match的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用ETag的好处是如果因为某种原因到时资源的修改时间没改变，那么用ETag就能区分资源是不是有被更新。\n1 2 3 4 # 第一次请求返回的响应头： Cache-Control: public, max-age=31536000 ETag: \u0026#34;15f0fff99ed5aae4edffdd6496d7131f\u0026#34; 1 2 3 # 第二次请求的请求头信息： If-None-Match: \u0026#34;15f0fff99ed5aae4edffdd6496d7131f\u0026#34; 5.4 cookie 和 session session： 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念 cookie：它是一个世纪存在的东西，http 协议中定义在 header 中的字段，可以认为是 session 的一种后端无状态实现 现在我们常说的 session，是为了绕开 cookie 的各种限制，通常借助 cookie本身和后端存储实现的，一种更高级的会话状态实现\nsession 的常见实现要借助cookie来发送 sessionID\n5.5 安全问题，如 XSS 和 CSRF XSS：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动 防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义\nCSRF：跨站请求伪造，也称 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。与 XSS 相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。 防范：用户操作验证（验证码），额外验证机制（token使用）等\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%AE%80%E7%89%88%E6%9C%AC/","summary":"一、CSS相关 1.1 左边定宽，右边自适应方案：float + margin，float + calc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 方案1 */ .left { width: 120px; float: left; }","title":"面试题精简版本"},{"content":"前端代码规范-推荐资料 JS规范，重点推荐下面这两个 1、Airbnb JavaScript Style Guide：\n英文原版：https://github.com/airbnb/javascript\n中文版：https://github.com/lin-123/javascript\n2、clean code JavaScript：\n英文原版：https://github.com/ryanmcdermott/clean-code-javascript\n中文版1：https://github.com/alivebao/clean-code-js\n中文版2：https://github.com/beginor/clean-code-javascript\neslint规范 1、eslint-config-airbnb：\nhttps://www.npmjs.com/package/eslint-config-airbnb\nhttps://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb\n2、凹凸实验室的eslint规范：\nhttps://www.npmjs.com/package/eslint-config-o2team-wx\n备注：o2team-wx 这一套规则是参考了 StandardJS 和 Airbnb 的 JS 规范，然后结合业务中的最佳实践整理输出的。\n其他相关资料 1、百度前端团队-前端各类规范集合：https://github.com/ecomfe/spec\n2、The mother of all demo apps：https://github.com/gothinkster/realworld\n3、JavaScript 代码规范：https://github.com/standard/standard/blob/master/docs/README-zhcn.md\n参考链接 文案、编程、Git 风格规范汇总：https://www.bihell.com/article/130\ngithubStars：https://blog.teefing.top/posts/2019/05/27/githubstars.html\n其他链接 http://blog.lovebug.cn/details/html/page02.html\nhttps://github.com/ecomfe/spec\nhttps://juejin.im/post/5e3d0362e51d4526d87c605d\nhttps://juejin.im/post/592d4a5b0ce463006b43b6da\nhttps://juejin.im/post/5b67e49551882508603d1431\nhttps://juejin.im/post/5e1abeede51d453c913c340e\nhttps://juejin.im/post/5d5d5197518825237330552d\nhttp://alloyteam.github.io/CodeGuide/\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/01-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","summary":"前端代码规范-推荐资料 JS规范，重点推荐下面这两个 1、Airbnb JavaScript Style Guide： 英文原版：https://github.com/airbn","title":"01-前端代码规范"},{"content":"前言 要监控的内容：\n业务数据\n稳定性\n性能\n错误\n用户操作路径\n怎么监控：\nPV/UV、业务操作上报\n根据上报寻找异常\n将页面性能数据上报\n将页面产生错误上报\n跟踪用户操作路径\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%8A%80%E6%9C%AF/","summary":"前言 要监控的内容： 业务数据 稳定性 性能 错误 用户操作路径 怎么监控： PV/UV、业务操作上报 根据上报寻找异常 将页面性能数据上报 将页面产生错误上报 跟","title":"前端监控技术"},{"content":"egg-sequelize 连接多个数据库如何配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 config.sequelize = { datasources: [ { delegate: \u0026#39;model\u0026#39;, // 加载所有的模型到 app.model and ctx.model baseDir: \u0026#39;model\u0026#39;, // 要加载的模型目录`app/model/*.js` dialect: \u0026#39;mysql\u0026#39;, host: \u0026#39;10.52.18.8\u0026#39;, port: 3306, username: \u0026#39;root\u0026#39;, // 用户名 password: \u0026#39;root\u0026#39;, // 用户密码 database: \u0026#39;crt_crland_screen\u0026#39;, // 数据库名 dateStrings: true, // 解决时间格式 pool: { max: 20, min: 0, idle: 10000, }, }, { delegate: \u0026#39;appModel\u0026#39;, // 加载所有的模型到 app.logModel and ctx.logModel baseDir: \u0026#39;model_app\u0026#39;, // 要加载的模型目录 `app/model_log/*.js` // local dialect: \u0026#39;mysql\u0026#39;, host: \u0026#39;10.52.18.8\u0026#39;, port: 3306, username: \u0026#39;root\u0026#39;, // 用户名 password: \u0026#39;root\u0026#39;, // 用户密码 database: \u0026#39;hotel_report\u0026#39;, // 数据库名 dateStrings: true, // 解决时间格式 pool: { max: 20, min: 0, idle: 10000, }, }, ], }; 注意事项：\n很多人担心 controller 、service 、 model 需要怎么编写\ncontroller \\ service 正常编写\nmodel 需要注意 后续添加的数据库指定了baseDir（新的model 目录）\n配置的delegate 属性 ==\u0026gt; app.appModel / ctx.appModel （连接表 / 服务时记得把model 换成配置的 delegate ）\n​\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/egg.js-1/","summary":"egg-sequelize 连接多个数据库如何配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 config.sequelize = { datasources: [ { delegate: \u0026#39;model\u0026#39;, // 加载所有的模型到 app.model and ctx.model baseDir:","title":"egg.js"},{"content":"腾讯云服务器控制台： https://iaas.cloud.tencent.com/webshell?regionId=4\u0026amp;instanceId=ins-56hta1uv\u0026amp;username=root\u0026amp;port=22\n****LL612lv.\nNginx 查看80端口被占用的进程 1 lsof -i:80 通过kill命令干掉该进程 1 kill -9 进程号(pid) 重启Nginx 1 nginx -s reload 服务器 安全组配置 TCP / UDP :8080 协议/端口\n来源 0.0.0.0/0 任何ip都可访问 , 或设置特定ip/端口可访问\n","permalink":"https://bablvsj.github.io/posts/tech/linux/%E4%B8%AA%E4%BA%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/","summary":"腾讯云服务器控制台： https://iaas.cloud.tencent.com/webshell?regionId=4\u0026amp;instanceId=ins-56hta1uv\u0026amp;username=root\u0026amp;port=22 ****LL612lv. Nginx 查看80端口被占用的进程 1 lsof -i:80 通过kill命令干掉该进程 1 kill -9 进程号(pid) 重启Nginx 1 nginx -s reload 服务器 安全组配","title":"云服务器Mind"},{"content":"前端人应该知道的 Centos/Nginx/Node的基本操作 Centos Centos 是一个基于 Linux 的开源免费操作系统，下面列出一些常用操作\n1 2 # 本地拷贝文件到远程服务器 scp output.txt root@47.93.242.155:/data/ output.txt:本地文件 root:登录远程服务器的账号 47.93.242.155:远程服务器的 IP /data/:远程服务器的目录 1 2 # 拷贝D盘https目录下的所有文件到 远程的 /data 目录 scp D:/https/* root@47.93.242.155:/data 本地链接远程 Centos 服务器 1 ssh \\-p 端口 用户名@服务器IP 例子:\n1 2 3 4 ssh -p 22 root@47.93.242.155 # 输入登录密码 # 成功 yum 切换为阿里源 1 2 3 4 5 6 cd /etc/yum.repos.d/ curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo # 重新生成缓存--查看执行结果，如果有aliyun 字样就算成功 yum makecache 其他 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 创建 /data/test 目录 mkdir /data/test # 创建 /data/newtest 目录 mkdir /data/newtest # 创建 /data/test/index.html 文件 touch /data/test/index.html # 编辑文件 vi /data/test/index.html # 查看文件内容 cat /data/www/index.html # 将 `test`目录下的所有文件复制到 `newtest`目录 下 cp –r /data/test/* /data/newtest # 删除 /data/newtest/index.html 文件 rm -rf /data/newtest/index.html # 将 `test`目录下的所有文件移动到新目录 `newtest`目录 下 mv /data/test/* /data/newtest # 查看当前目录的路径 pwd 复制代码 # 检查端口被哪个进程占用 netstat -lnp|grep 88 #88请换为你需要的端口，如：80 执行netstat \\-lnp|grep 端口号之后会打印出被占用的进程及其编号\n1 2 # 杀掉编号为1777的进程（请根据实际情况输入） kill -9 1777 查看当前 Centos 操作系统发行版信息\n1 cat /etc/redhat-release Nginx 服务器搭建 nginx-logo\nNginx 是一个高性能的 HTTP 和反向代理 web 服务器，使用 nginx 网站有：百度、京东、新浪、网易、腾讯、淘宝\u0026hellip;。\nCentos 下安装 Nginx 服务器 这里我们使用 yum 安装 Nginx 服务器。\n1 yum install -y nginx 启动 Nginx 服务器 安装后的 Nginx 没有启动，先启动 Nginx 服务器。\n1 nginx 此时，访问 http://\u0026lt;您的域名或IP\u0026gt; 可以看到 Nginx 的测试页面\n如果无法访问，请重试用 nginx \\-s reload 命令重启 Nginx\nnginx-index\n配置静态服务器访问路径 外网用户访问服务器的 Web 服务由 Nginx 提供，Nginx 需要配置静态资源的路径信息才能通过 url 正确访问到服务器上的静态资源。\n打开 Nginx 的默认配置文件 /etc/nginx/nginx.conf ，修改 Nginx 配置\n1 vi /etc/nginx/nginx.conf 将默认的 /usr/share/nginx/html; 修改为: /data/www;，如下：\n示例代码：/etc/nginx/nginx.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; # 修改为以下路径 root /data/www; include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } 配置文件将 /data/www/static 作为所有静态资源请求的根路径，如访问: http://\u0026lt;您的域名或IP\u0026gt;/static/index.js，将会去 /data/www/static/ 目录下去查找 index.js/index.html。现在我们需要重启 Nginx 让新的配置生效，如：\n1 nginx -s reload 创建第一个静态文件 现在让我们新建一个静态文件，查看服务是否运行正常。\n首先让我们在 /data 目录 下创建 www 目录，如：\n1 mkdir -p /data/www 在 /data/www 目录下创建我们的第一个静态文件 index.html\n1 2 3 touch /data/www/index.html vi /data/www/index.html 示例代码：/data/www/index.html\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;第一个静态文件\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello world！\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 现在访问 http://\u0026lt;您的域名或IP\u0026gt;/index.html 应该可以看到页面输出 Hello world!\n到此，一个基于 Nginx 的静态服务器就搭建完成了，现在所有放在 /data/www 目录下的的静态资源都可以直接通过域名/IP 访问。\n如果无显示，请刷新浏览器页面\n配置 Nginx 反向代理 客户端对代理服务器是无感知的，客户端不需要做任何配置，用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。\n反向代理服务器和目标服务器对外而言就是一个服务器，只是暴露的是代理服务器地址，而隐藏了真实服务器的 IP 地址。\n20210416165016\n参考从原理到实战，彻底搞懂 Nginx！\n访问路径:/api/getUser\n1 当 nginx 配置文件 `proxy_pass` 的 **url 末尾 带`/`时**: 1 2 3 4 5 6 7 8 server { listen 80; server_name www.123.com; location /api/ { proxy_pass http://127.0.0.1:18081/; } } 代理到后端的路径为：http://127.0.0.1:18081/getUser，省略了匹配到的/api/路径；\n1 当 nginx 配置文件 `proxy_pass` 的 **url 末尾 不带`/`时**： 1 2 3 4 5 6 7 8 server { listen 80; server_name www.123.com; location /api/ { proxy_pass http://127.0.0.1:18081; } } 代理到后端的路径为：http://127.0.0.1:18081/api/getUser，连同匹配到的/api/路径，一起进行反向代理；\nCentos 下搭建 Node.js 环境 node-logo\nNode.js 是运行在服务端的 JavaScript, 是基于 Chrome JavaScript V8 引擎建立的平台。\n安装 Node.js 的几种方式\n方法一：从EPEL库安装Node.js\u0026ndash;yum install nodejs，不足:安装的node/npm版本较低,需要手动切换版本 方法二:使用官方编译过的二进制数据包安装,不足:安装步骤繁杂 方法三: 通过NVM安装,方便快捷不足:安装时国外的网不好 🥶 方法四:源码下载后编译安装,版本是最新的 yum install nodejs 方式安装 查看当前系统自带了哪些nodejs的版本\n1 sudo dnf module list nodejs centos-node-list\n可以看到有三个版本的 Node:10,12,14. 在版本 10 上有个[d]符号,它代表系统将会默认安装的版本。如果你想要切换默认安装的版本，可以执行下面的命令\n1 sudo dnf module enable nodejs:14 安装 Node\n1 sudo dnf install nodejs 查看 node 版本，可以发现是Node14的版本\n1 node --v NVM 方式安装 我们可能同时在进行 2 个项目，而 2 个不同的项目所使用的 node 版本又是不一样的，对于维护多个版本的node将会是一件非常麻烦的事情，而nvm就是为解决这个问题而产生的，它可以方便的在同一台设备上进行多个node版本之间切换\n注: 使用此方式，在后面的 Jenkins 脚本使用 npm/yarn 会提示找不到命令，我也不知道咋解决，求大佬科普 🤪\n下面是(2021/04)的最新稳定版: 可以在去NVM 官网看一下，替换成最新的链接\n1 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | cp 还需要运行下面的命令，以确认上一条命令的更改结果\n1 source ~/.bash_profile 查看 Node 版本列表\n1 nvm list-remote 安装一个长期支持的版本\n1 nvm install 14.16.1 确认是否安装成功\n1 2 3 nvm current node -v npm -v 通过 环境变量echo $PATH 查看安装的位置\n1 2 3 echo $PATH # 打印出的结果中，需要取出 `/root/.nvm/versions/node/v14.16.1/bin` 使用官方编译过的二进制数据包的方式安装 注: 使用此方式，在后面的 Jenkins 脚本使用 npm/yarn 能够正常运行\n下面是(2021/04)的最新稳定版: 可以在去Node.js 官网看一下，替换成最新的链接\n下载 14.16.0 到/data 目录\n1 2 cd /data wget https://nodejs.org/dist/v14.16.0/node-v14.16.0-linux-x64.tar.xz 下载完成后, 将其解压\n1 tar xvJf node-v14.16.0-linux-x64.tar.xz 将解压的 Node.js 目录移动到 /usr/local 目录下\n1 mv node-v14.16.0-linux-x64 /usr/local/node-v14 配置 node 软链接到 /bin 目录\n1 ln -s /usr/local/node-v14/bin/node /bin/node 配置和使用 npm npm 是 Node.js 的包管理和分发工具。它可以让 Node.js 开发者能够更加轻松的共享代码和共用代码片段\n下载 node 的压缩包中已经包含了 npm , 我们只需要将其软链接到 bin 目录下即可\n1 ln -s /usr/local/node-v14/bin/npm /bin/npm 配置环境变量 将 /usr/local/node-v14/bin 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具\n1 echo \u0026#39;export PATH=/usr/local/node-v14/bin:$PATH\u0026#39; \u0026gt;\u0026gt; /etc/profile 使环境变量生效\n1 source /etc/profile 使用 npm 通过 npm 配置淘宝源\n1 2 npm config set registry https://registry.npm.taobao.org npm get registry 全局安装yarn并配置淘宝源\n1 2 3 npm install yarn -g yarn config set registry http://registry.npm.taobao.org/ yarn config get registry ","permalink":"https://bablvsj.github.io/posts/tech/linux/%E5%89%8D%E7%AB%AF%E4%BA%BA%E5%BA%94%E7%9F%A5%E7%9A%84-centosnginxnode-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"前端人应该知道的 Centos/Nginx/Node的基本操作 Centos Centos 是一个基于 Linux 的开源免费操作系统，下面列出一些常用操作 1 2 # 本地拷贝文件到远程","title":"前端人应知的 CentosNginxNode 的基本操作"},{"content":"资源分享 新手学习Node.js\n推荐狼叔的《如何正确学习Node.js》，地址：https://github.com/i5ting/How-to-learn-node-correctly\nNode.js国内交流社区：https://cnodejs.org/\n推荐书籍：《Node.js实战》（第二版）、《Node.js调试指南》、《深入浅出Node.js》（有一定的基础后再看）、《更了不起的Node.js》（据说今年会出版）\npromise的各种用法：https://github.com/sindresorhus/promise-fun\n张鑫旭大佬一篇旧文\n话说我为什么要闭关学习：http://www.zhangxinxu.com/life/?p=98 一点感慨：就算张鑫旭大佬从事别的事业，肯定也是拔尖的。\n2018年8月中级前端开发推荐书籍：https://zhuanlan.zhihu.com/p/40761206 张鑫旭的《CSS世界》真是写的是真的好，准备翻出来看第三遍了。我最近看的书都是按照这个书单看的，前面基本还可以，从《Node.js:来一打C++扩展》后面开始感觉就有点get不到书里面的主题了。\n《编程语言的发展趋势：从没有分号，到DSL》\nPython - 100天从新手到大师：https://github.com/jackfrued/Python-100-Days\n国内10大前端团队网站：https://zhuanlan.zhihu.com/p/60091235\n腾讯新闻前端团队维护的一个周刊：https://github.com/Tnfe/TNFE-Weekly\n看到一篇to b产品UX \u0026amp; UI 设计总结不错。\n后台产品 UX \u0026amp; UI 设计总结（上）- 设计要点概括：https://zhuanlan.zhihu.com/p/28787738\nweb安全学习笔记：https://websec.readthedocs.io/\n可能是最全的前端动效库汇总：https://juejin.im/post/5cc089eae51d456e7d189f9d\n成都-颜乐乐：\n撸了一个 node 爬虫：TS+puppeteer+cheerio+fs-extra\nhttps://github.com/yanlele/node-spider 使用JavaScript写爬虫：https://zhuanlan.zhihu.com/p/53763115 mysql相关的书籍推荐：《深入浅出MySQL 数据库开发 优化与管理维护》\n猴子都能懂的Git入门：https://backlog.com/git-tutorial/cn/\n像玩游戏闯关一样学习git！: https://learngitbranching.js.org/\n知识积累 userAgent相关：判断微信内置浏览器的UserAgent\npromise的实现，关键词：Promises/A、Promises/B、bluebird\nlocation.pathname：获取 url 的后半部分。参考链接：#\n代码解读：callback \u0026amp;\u0026amp; callback()的含义\n对比 sass、less、stylus 这三个css预处理器，sass 比 less强大，stylus的书写方式比较奇怪。\n时间戳和年月日的转换：https://blog.csdn.net/qq_26747571/article/details/53289120?locationNum=10\u0026amp;fps=1\n对象数组通过对象的属性进行排序：https://blog.csdn.net/xiaobing_hope/article/details/68638706\n数组随机打乱顺序：https://www.zhihu.com/question/68330851/answer/262111061 最佳的打乱算法是Fisher-Yates算法。\ncss 动画实现闪烁效果：https://blog.csdn.net/wangxiuyan0228/article/details/80701523 动画水平/镜像翻转 参考链接1：https://www.oschina.net/question/2443483_247744\n代码实现举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; @keyframes featuresicon { 0% { transform: scaleX(1); } 20% { transform: scaleX(1); } 50% { transform: scaleX(0); } 80% { transform: scaleX(1); } 100% { transform: scaleX(1); } } .cube { width: 40px; height: 40px; background: url(images/bg2.png) left 0 no-repeat; animation: featuresicon 1.3s linear alternate none infinite; } body { background-color: cornflowerblue; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;cube\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 参考链接2：https://blog.csdn.net/wjnf012/article/details/78679131\n代码实现：（立体感更强一点）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; *{ padding: 0; margin: 0; } .cube{ display: block; color: #ffffff; text-align: center; width: 40px; height: 40px; border-radius: 4px; /* background-color: #9a6ad8 */ background: url(images/bg.png) left 0 no-repeat; animation: proRotate 1.3s ease-in-out 500ms alternate none infinite; } @keyframes proRotate { 0%{transform:perspective(200px) rotateY(180deg);} 100%{transform:perspective(200px) rotateY(0deg);} } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;test_wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;cube\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/html\u0026gt; 学习路线 Web前端入门的自学路线 新手入门前端，需要学习的基础内容有很多，如下。\n一、HTML、CSS基础、JavaScript语法基础。学完基础后，可以仿照电商网站（例如京东、小米）做首页的布局。\n二、JavaScript语法进阶。包括：作用域和闭包、this和对象原型等。相信我，JS语法，永远是面试中最重要的部分。\n三、jQuery、Ajax等。jQuery没有过时，它仍然是前端基础的一部分。\n四、ES6语法。这部分属于JS新增的语法，面试必问。其中，关于 promise、async 等内容要尤其关注。\n五、HTML5和CSS3。要熟悉其中的新特性。\n六、canvas。面试时，有的公司不一定会问canvas，靠运气。如果时间不够，这部分的内容可以先不学。但如果你会，绝对属于加分项。\n七、移动Web开发、Bootstrap等。要注意移动开发中的适配和兼容性问题。\n八、前端框架：Vue.js和React。这两个框架至少要会一个。入门时，建议先学Vue.js，上手相对容易。但无论如何，同时掌握 Vue 和 React 才是合格的前端同学。\n九、Node.js。属于加分项，如果时间不够，可以先不学，但至少要知道 node 环境的配置。\n十、前端工程化：构建工具 Webpack、构建工具 gulp、CSS 预处理器 Sass 等。注意，Sass 比 Less 用得多，gulp 比 grunt 用得多。\n十一、前端综合：HTTP协议、跨域通信、安全问题（CSRF、XSS）、浏览器渲染机制、异步和单线程、页面性能优化、防抖动（Debouncing）和节流阀（Throtting）、lazyload、前端错误监控、虚拟DOM等。\n十二、编辑器相关。Sublime Text 是每个学前端的人都要用到的编辑器。另外，前端常见的IDE有两个：WebStorm 和 Visual Studio Code。WebStorm 什么都好，可就是太卡顿；VS Code就相对轻量很多。个人总结一下：用VS Code 的人越来越多，用 WebStorm 的人越来越少。具体可以看：《第一次使用VS Code时你应该知道的一切配置》\n十三、TypeScript（简称TS）。ES 是 JS 的标准，TS 是 JS 的超集。TS属于进阶内容，建议把上面的基础掌握之后，再学TS。\n备注：框架有时候都很虚；熟练掌握 JavaScript 基础，才是行走江湖、驰骋千里的关键。\n推荐的前端图文教程 我在GitHub上有一个Web前端入门的学习教程，非常详细，地址是：\nhttps://github.com/qianguyihao/Web\n非常详细和贴心，你值得star。这个前端教程主要有三个作用：\n网上的大部分入门教程，都不太适合初学者，本项目争取照顾到每一位入门者的同理心。\n帮助前端同学提供一个精品学习路线和资源，提高学习效率，少走很多弯路。\n可以当做前端字典，随时翻阅，查漏补缺。\n推荐的技术博客 阮一峰\n张鑫旭\n推荐的书籍 《你不知道的JavaScript》 上面这套书有上、中、下三本，你都可以读一读。如果时间不够，那就先读第一本。\n《网络是怎样连接的》 程序员面试的时候，经常会被问的一个问题是：“在浏览器的地址栏输入url，按下回车后，发生了什么？”\n为了清楚这个问题，看上面这本书，足够了。如果你想入门计算机网络，这本书也是必读的。评价非常高。\n关于这个问题，也可以看下面这篇文章：浏览器输入 URL 后发生了什么？\n《CSS世界》 关于 CSS 的书籍，首先推荐这本书，我身边的大佬们都说这本书好。虽然我不是大牛，但我也觉得这本书很好。\n如果 js 熟练，说明你是有技术深度的前端；如果 css 熟练，说明你是有经验的前端。\n前端资讯订阅源 前端开发者必须要订阅的：\nDaily JS：https://medium.com/dailyjs - medium 上的博客。 JavaScript Weekly：https://javascriptweekly.com/ - 聚合类的技术周刊。 推荐链接 「颜值即正义」那些管UI小姐姐要来的网站\n前端面试图谱：https://yuchengkai.cn/docs/zh/\ncss的各种效果实现：https://lhammer.cn/You-need-to-know-css/#/\n现代 JavaScript 教程：https://zh.javascript.info/\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/20230806-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/","summary":"资源分享 新手学习Node.js 推荐狼叔的《如何正确学习Node.js》，地址：https://github.com/i5ting/How-t","title":"内容分享"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;template\u0026gt; \u0026lt;view\u0026gt; \u0026lt;view class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;search-icon\u0026#34; src=\u0026#34;../../../static/zfdygl-search@2x.png\u0026#34; mode=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入行业名称/代码\u0026#34; v-model=\u0026#34;searchIdCard\u0026#34; maxlength=\u0026#34;18\u0026#34; @input=\u0026#34;handInputSearch\u0026#34; @confirm=\u0026#34;searchIDcardConfirm\u0026#34;confirm-type=\u0026#34;搜索\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;search-content\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;li one-line-overflow\u0026#34; v-for=\u0026#34;(sItem,sIndex) in searchList\u0026#34; :key=\u0026#34;sIndex\u0026#34;\u0026gt; \u0026lt;text v-html=\u0026#34;sItem.industry_code\u0026#34;\u0026gt;\u0026lt;/text\u0026gt;- \u0026lt;text v-html=\u0026#34;sItem.industry_name\u0026#34;\u0026gt;\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; methods:{ brightKeyword(val) { let keyword = this.searchIdCard.toString(); if (val.indexOf(keyword) !== -1) { return val.replace(keyword, `\u0026lt;span style=\u0026#34;color:#3995FF;font-weight:bold;\u0026#34;\u0026gt;${keyword}\u0026lt;/span\u0026gt;`) } else { return val } }, handInputSearch(e){ clearTimeout(this.searchTime); this.searchTime = setTimeout(() =\u0026gt; { this.searchForm.industry_code = e.detail.value; this.searchForm.parent_indu = \u0026#34;\u0026#34;; this.getDataist(this.searchForm); }, 500) }, getDataist(){ Service.apiIndustryList(fd).then(res =\u0026gt; { if (res.RetCode == 100) { this.searchList = []; res.data.industry.forEach(i =\u0026gt; { i.industry_name = this.brightKeyword(i.industry_name) i.industry_code = this.brightKeyword(i.industry_code) }) this.searchList = res.data.industry }).catch(error =\u0026gt; { console.log(error) }) } } ","permalink":"https://bablvsj.github.io/posts/tech/frontend/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;template\u0026gt; \u0026lt;view\u0026gt; \u0026lt;view class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;search-icon\u0026#34; src=\u0026#34;../../../static/zfdygl-search@2x.png\u0026#34; mode=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=","title":"模糊查询关键字高亮"},{"content":"字体分类 常见的字体可以分为两类：衬线体、无衬线体。\n1、serif（衬线体）：在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同。\n常见的衬线体有：\n宋体、楷体\nTimes New Roman\n2、sans-serif（无衬线体）：笔划粗细基本一致，只剩下主干，造型简明有力，起源也很晚。适用于标题、广告等，识别性高。\n常见的无衬线体有：\n黑体 Windows 平台默认的中文字体：微软雅黑（Microsoft Yahei） Windows 平台默认的英文字体：Arial Mac \u0026amp; iOS 平台默认的中文字体：苹方（PingFang SC） Mac \u0026amp; iOS 平台默认的英文字体：San Francisco Android 平台默认字体：Droid Sans 字体族 CSS 中的字体族可以理解成是某一类字体。常见的字体族可以分为五类：\nserif：衬线体。 sans-serif：无衬线体。 monospace：等宽字体。每一个字母所占的宽度是相同的。写代码的字体尽量用等宽字体。 cursive：手写字体。比如徐静蕾手写体。 fantasy：梦幻字体。比如一些艺术字。 多字体 fallback 机制 多字体 fallback 机制：当指定的字体找不到（或者某些文字不支持这个字体）时，那就接着往后找。比如：\n1 2 3 .div1{ font-family: \u0026#34;PingFang SC\u0026#34;, \u0026#34;Microsoft Yahei\u0026#34;, monospace; } 上方 CSS 代码的意思是：让指定标签元素中的文字，在 Mac \u0026amp; iOS 平台用苹方字体，在 Win 平台用微软雅黑字体，如果这两个字体都没有，就随便找一个等宽的字体进行渲染。\nfont-weight：字体的加粗属性 font-weight 属性：在设置字体是否加粗时，属性值既可以直接填写 100 至 900 这样的数字，也可以填写normal、bold这样的单词。normal的值相当于 400，bold的值相当于 700。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 font-weight: 100; font-weight: 200; font-weight: 300; font-weight: 400; font-weight: 500; font-weight: 600; font-weight: 700; font-weight: 800; font-weight: 900; font-weight: normal; // 相当于 400 font-weight: bold; // 相当于 700 各大平台的默认字体加粗效果 Mac \u0026amp; iOS 平台的“苹方”字体：500 和600，加粗效果是不同的；\u0026gt;=600的加粗效果是相同的。\nWindows 平台的“微软雅黑”字体：只有 \u0026gt;=600 才会加粗，而且加粗效果相同。\nAndroid 平台的 Droid Sans 字体，只有 \u0026gt;=700才会加粗；而且加粗效果相同。\n推荐字体 Arual 这是一款设计师都爱用的英文字体，简单实用。\n最后一段 所谓「见微知著」，一个再不起眼的知识点，也是有很多学问的。光是“字体”这一点，就足够成为一门学科。\n2005年，苹果公司创始人乔布斯（Steve Jobs）在斯坦福大学的毕业典礼演讲上，有过这样一段话：\n当时的我从来没有期盼过我所学的这些东西，能够在我的生活中有什么实际的用处。\n但是到了十年之后，当我们在设计第一台 Macintosh 电脑时，这些所学都涌进了我的头脑。于是，我把这些设计融入到了 Mac 电脑之中，这也使这台 Mac 成为了第一台拥有漂亮字体的电脑。\n可以说，如果我当时没有退学，就不会有机会去参加我感兴趣的美术字课程，Mac 也就不会拥有那些美妙的排版和字体。而当 Windows 系统借鉴了Mac之后，似乎所有的电脑都应该是这个样子。\n当时的我没有办法把这些点点滴滴连接起来，但是，当我十年后回顾的时候，一切都变得豁然开朗。\n推荐阅读 常见的免费字体：http://zenozeng.github.io/Free-Chinese-Fonts/\niconfont\n乔布斯斯坦福大学演讲-翻译\n乔布斯斯坦福大学演讲-翻译\n阿里巴巴官方发布免费商用字体：阿里巴巴普惠体\n得到 | 从甲骨文至得到今楷，造字的人都是神\n《独立宣言》使用了什么字体？\n你的版权常识指南\n免费商用 | 这几款字体你值得拥有\n","permalink":"https://bablvsj.github.io/posts/tech/wait/01-html/03-%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BC%80%E5%8F%91%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%AD%97%E4%BD%93%E7%9A%84%E5%B8%B8%E8%AF%86/","summary":"字体分类 常见的字体可以分为两类：衬线体、无衬线体。 1、serif（衬线体）：在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同","title":"网页设计和开发中，关于字体的常识"},{"content":"教程：https://sqlmother.solargod.cn/\n基础语法 数据列输出顺序 SELECT {列名...} 全表查询 select * from 表名\n查询 - 别名 别名语法 {原始字段名} as {别名} 来为查询结果的列名取一个便于理解的名称。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和年龄（age）信息，并为它们取别名为 学生姓名 和 学生年龄\n1 2 3 4 5 select name as \u0026#39;学生姓名\u0026#39;, age as \u0026#39;学生年龄\u0026#39; from student; 查询 - 常量和运算 请编写一条 SQL 查询语句，从名为student的数据表中选择出所有学生的姓名（name）和分数（score），并且额外计算出分数的 2 倍（double_score）。\n1 2 3 4 5 6 select name, score, score * 2 as double_score from student; 条件查询 - where 1 2 3 SELECT 列1, 列2, ... FROM 表名 WHERE 条件; 请编写一条 SQL 查询语句，从名为student 的数据表中选择出所有学生的姓名（name）和成绩（score），要求学生姓名为 \u0026rsquo;lvsj\u0026rsquo;。\n1 2 3 4 5 6 7 select name, score from student where name = \u0026#39;lvsj\u0026#39;; 条件查询 - 运算符 =、 !=、\u0026lt;、\u0026gt; \u0026ldquo;BETWEEN\u0026rdquo; 运算符来筛选出在某个范围内的值。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和年龄（age），要求学生姓名不等于 \u0026lsquo;热dog\u0026rsquo; 。\n1 2 3 4 5 6 7 select name, age from student where name != \u0026#39;热dog\u0026#39;; 条件查询 空值 is null / is not null 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）、年龄（age）和成绩（score），要求学生年龄不为空值。\n1 2 3 4 5 6 7 8 select name, age, score from student where age is not null; 模糊查询 like / not like **通配符：\n百分号（%）：表示任意长度的任意字符序列。 下划线（_）：表示任意单个字符。 还可以使用模糊查询匹配开头和结尾：\n1 2 3 4 5 -- 只查询以 \u0026#34;张\u0026#34; 开头的数据行 select name, age, position from employees where name like \u0026#39;张%\u0026#39;; -- 只查询以 \u0026#34;张\u0026#34; 结尾的数据行 select name, age, position from employees where name like \u0026#39;%张\u0026#39;; 同理，可以使用 not like 来查询不包含某关键字的信息。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和成绩（score），要求姓名（name）不包含 \u0026ldquo;李\u0026rdquo; 这个字。\n1 2 3 4 5 6 7 select name, score from student where name not like \u0026#39;%李%\u0026#39;; 逻辑运算 AND / OR / NOT AND：表示逻辑与，要求同时满足多个条件，才返回 true。 OR：表示逻辑或，要求满足其中任意一个条件，就返回 true。 NOT：表示逻辑非，用于否定一个条件（本来是 true，用了 not 后转为 false） 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）、成绩（score），要求学生的姓名包含 \u0026ldquo;李\u0026rdquo;，或者成绩（score）大于 500。\n1 2 3 4 5 6 7 8 select name, score from student where name like \u0026#39;%李%\u0026#39; or score \u0026gt; 500; 去重 distinct 除了按照单字段去重外，DISTINCT 关键字还支持根据多个字段的组合来进行去重操作，确保多个字段的组合是唯一的。\n示例语法如下：\n1 distinct 字段1, 字段2, 字段3, ... 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有不重复的班级 ID（class_id）和考试编号（exam_num）的组合。\n1 2 3 4 5 select distinct class_id, exam_num from student; 排序 order by 在排序的基础上，我们还可以根据多个字段的值进行排序。当第一个字段的值相同时，再按照第二个字段的值进行排序，以此类推。\n示例语法如下：\n1 order by 字段1 [升序/降序], 字段2 [升序/降序], ... 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出学生姓名（name）、年龄（age）和成绩（score），首先按照成绩从大到小排序，如果成绩相同，则按照年龄从小到大排序。\n1 2 3 4 5 6 7 8 9 select name, age, score from student order by score desc, age asc; 截断和偏移 LIMIT关键字 请编写一条 SQL 查询语句，从名为 student 的数据表中选择学生姓名（name）和年龄（age），按照年龄从小到大排序，从第 2 条数据开始、截取 3 个学生的信息。\n1 2 3 4 5 6 7 8 9 select name, age from student order by age asc limit 1, 3; 条件分支 case when 实例语法：\n1 2 3 4 CASE WHEN (条件1) THEN 结果1 WHEN (条件2) THEN 结果2 ... ELSE 其他结果 END 题目： 假设有一个学生表 student，包含以下字段：name（姓名）、age（年龄）。请你编写一个 SQL 查询，将学生按照年龄划分为三个年龄等级（age_level）：60 岁以上为 \u0026ldquo;老同学\u0026rdquo;，20 岁以上（不包括 60 岁以上）为 \u0026ldquo;年轻\u0026rdquo;，20 岁及以下、以及没有年龄信息为 \u0026ldquo;小同学\u0026rdquo;。\n返回结果应包含学生的姓名（name）和年龄等级（age_level），并按姓名升序排序。\n1 2 3 4 5 6 7 8 9 10 11 select name, case when (age \u0026gt; 60) then \u0026#39;老同学\u0026#39; when (age \u0026gt; 20) then \u0026#39;年轻\u0026#39; else \u0026#39;小同学\u0026#39; end as age_level from student order by name asc; 函数 - 时间函数 常用的时间函数有：\nDATE：获取当前日期 DATETIME：获取当前日期时间 TIME：获取当前时间 假设有一个学生表 student，包含以下字段：name（姓名）、age（年龄）。 请你编写一个 SQL 查询，展示所有学生的姓名（name）和当前日期（列名为 \u0026ldquo;当前日期\u0026rdquo;）。\n1 2 3 4 5 select name, date() as \u0026#39;当前日期\u0026#39; from student; 函数 - 字符串处理 1 2 3 4 5 6 7 8 \u0026#39;`UPPER` 将字段转换为大写\u0026#39; select name, upper(name) as upper_name from employees; \u0026#39;`LOWER` 将字段转换为小写\u0026#39; select name, lower(name) as lower_name from employees; \u0026#39;`LENGTH` 计算字段长度\u0026#39; select name, length(name) as name_length from employees; 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）。请你编写一个 SQL 查询，筛选出姓名为 \u0026lsquo;热dog\u0026rsquo; 的学生，展示其学号（id）、姓名（name）及其大写姓名（upper_name）。\n1 2 3 4 5 6 7 8 select id, name, upper(name) as upper_name from student where name = \u0026#39;热dog\u0026#39; 函数 - 聚合函数 聚合函数是一类用于对数据集进行 汇总计算 的特殊函数。\n常见的聚合函数包括：\nCOUNT：计算指定列的行数或非空值的数量。 SUM：计算指定列的数值之和。 AVG：计算指定列的数值平均值。 MAX：找出指定列的最大值。 MIN：找出指定列的最小值。 示例 假设有一个订单表 orders，包含以下字段：order_id（订单号）、customer_id（客户编号）、amount（订单金额）。数据如下：\norder_id customer_id amount 1 A001 100 2 A002 200 3 A001 150 4 A003 50 1）使用聚合函数 COUNT 计算订单表中的总订单数：\n1 select count(*) as order_num from orders; // order_num = 4 2）使用聚合函数 COUNT(DISTINCT 列名) 计算订单表中不同客户的数量：\n1 select count(distinct customer_id) as customer_num FROM orders; // customer_num = 3 3）使用聚合函数 SUM 计算总订单金额：\n1 select sum(amount) as total_amount from orders; // total_amount = 500 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、class_id（班级编号）、score（成绩）。请你编写一个 SQL 查询，汇总学生表中所有学生的总成绩（total_score）、平均成绩（avg_score）、最高成绩（max_score）和最低成绩（min_score）。\n1 2 3 4 5 6 7 select sum(score) as total_score, avg(score) as avg_score, max(score) as max_score, min(score) as min_score from student; 分组聚合 - 单字段分组 分组聚合是一种对数据进行分类并对每个分类进行聚合计算的操作。它允许我们按照指定的列或字段对数据进行分组，然后对每个分组应用聚合函数，如 COUNT、SUM、AVG 等，以获得分组后的汇总结果。\n举个例子：某个学校可以按照班级将学生分组，并对每个班级进行统计。查看每个班级有多少学生、每个班级的平均成绩。这样我们就能够对学校各班的学生情况有一个整体的了解，而不是单纯看个别学生的信息。\n在 SQL 中，通常使用 GROUP BY 关键字对数据进行分组。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、class_id（班级编号）、score（成绩）。请你编写一个 SQL 查询，统计学生表中每个班级的平均成绩（avg_score）。\n1 2 3 4 5 6 7 select class_id, avg(score) as avg_score from student group by class_id; 分组聚合 - 多字段分组 有时，单字段分组并不能满足我们的需求，比如想统计学校里每个班级每次考试的学生情况，这时就可以使用多字段分组。\n多字段分组和单字段分组的实现方式几乎一致，使用 GROUP BY 语法即可。\n假设有一个学生表 student，包含以下字段id（学号）、name（姓名）、class_id（班级编号）、exam_num（考试次数）、score（成绩）。请编写一个 SQL 查询，统计学生表中每个班级每次考试的总学生人数（total_num）。\n1 2 3 4 5 6 7 8 9 select class_id, exam_num, count(*) as total_num from student group by class_id, exam_num 分组聚合 - having 子句 HAVING 子句用于在分组聚合后对分组进行过滤。它允许我们对分组后的结果进行条件筛选，只保留满足特定条件的分组。\nHAVING 子句与条件查询 WHERE 子句的区别在于，WHERE 子句用于在 分组之前 进行过滤，而 HAVING 子句用于在 分组之后 进行过滤。\n假设有一个学生表 student，包含以下字段：id（学号)、name（姓名）、class_id（班级编号)、score（成绩）。请编写一个 SQL 查询，统计学生表中班级的总成绩超过 150 分的班级编号（class_id）和总成绩（total_score），并将总成绩按从高到低排序。\n1 2 3 4 5 6 7 8 9 10 11 select class_id, sum(score) as total_score from student group by class_id having total_score \u0026gt; 150 order by total_score desc 查询进阶 - 关联查询 cross join 关联查询是一种用于联合多个数据表中的数据的查询方式\nCROSS JOIN 是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 每一行 与右表的 每一行 进行组合，返回的结果是两个表的笛卡尔积。\n示例 假设有一个员工表 employees，包含以下字段：emp_id（员工编号）、emp_name（员工姓名）、department（所属部门）、salary（工资）。数据如下：\nemp_id emp_name department salary 1 小明 技术部 5000 2 鸡哥 财务部 6000 3 李华 销售部 4500 假设还有一个部门表 departments，包含以下字段：department（部门名称）、manager（部门经理）、location（所在地）。数据如下：\ndepartment manager location 技术部 张三 上海 财务部 李四 北京 销售部 王五 广州 使用 CROSS JOIN 进行关联查询，将员工表和部门表的所有行组合在一起，获取员工姓名、工资、部门名称和部门经理，示例 SQL 代码如下：\n1 2 3 SELECT e.emp_name, e.salary, e.department, d.manager FROM employees e CROSS JOIN departments d; 注意，在多表关联查询的 SQL 中，我们最好在选择字段时指定字段所属表的名称（比如 e.emp_name），还可以通过给表起别名（比如 employees e）来简化 SQL 语句。\n查询结果：\nemp_name salary department manager 小明 5000 技术部 张三 小明 5000 财务部 李四 小明 5000 销售部 王五 鸡哥 6000 技术部 张三 鸡哥 6000 财务部 李四 鸡哥 6000 销售部 王五 李华 4500 技术部 张三 李华 4500 财务部 李四 李华 4500 销售部 王五 假设有一个学生表 student ，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）；还有一个班级表 class ，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，将学生表和班级表的所有行组合在一起，并返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）以及班级名称（class_name）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#39;错误示范\u0026#39; -- select -- s.name as student_name, -- s.age as student_age, -- s.calss_id, -- c.name as class_name -- from student s -- cross join class c; select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name from student s join class c; inner join INNER JOIN 是一种常见的关联查询方式，它根据两个表之间的关联条件，将满足条件的行组合在一起。\nINNER JOIN 只返回两个表中满足关联条件的交集部分，即在两个表中都存在的匹配行。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）、level（班级级别）。\n请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level）。\n1 2 3 4 5 6 7 select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s join class c on s.class_id = c.id; outer join out join 是一种关联查询方式，它根据关联条件，将两个表中满足条件的行组合在一起，并包含没有匹配的行 。\n在 out join 中，包括 left out join 和 right out join 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。\n有些数据库并不支持 right join 语法，那么如何实现 right join 呢？ 其实只需要把主表（from 后面的表）和关联表（ left join 后面的表）顺序进行调换即可！\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）、level（班级级别）。\n请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level），要求必须返回所有学生的信息（即使对应的班级编号不存在）。\n1 2 3 4 5 6 7 8 9 select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s left join class c on s.class_id = c.id; 子查询 子查询是指在一个查询语句内部 嵌套 另一个完整的查询语句，内层查询被称为子查询。子查询可以用于获取更复杂的查询结果或者用于过滤数据。\n","permalink":"https://bablvsj.github.io/posts/exams/%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"教程：https://sqlmother.solargod.cn/ 基础语法 数据列输出顺序 SELECT {列名...} 全表查询 select * from 表名 查询 - 别名 别名语法","title":""},{"content":"命令总结\n命令参数的长格式与短格式示例\n长格式 短格式 man \u0026ndash;help man -h 一、常用系统工作命令 1．echo - 输出值 echo 命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。\n例如，把指定字符串“Linuxprobe.com”输出到终端屏幕的命令为： [root@linuxprobe ~]# echo Linuxprobe.Com 该命令会在终端屏幕上显示如下信息： Linuxprobe.Com\n下面，我们使用$变量的方式提取变量 SHELL 的值，并将其输出到屏幕上： [root@linuxprobe ~]# echo $SHELL /bin/bash\n2．date - 时间相关 date 命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。\n只需在date 命令以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期。 例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2017-9-1.tar.gz”， 用户只需要看一眼文件名称就能大概了解到每个文件的备份时间了。\ndate 命令中常见的参数格式及作用\n参数 作用 %t 跳格[Tab 键] %H 小时（00～23） %I 小时（00～12） %M 分钟（00～59） %S 秒（00～59） %j 今年中的第几天 按照默认格式查看当前系统时间的 date 命令 [root@linuxprobe ~]# date Mon Aug 24 16:11:23 CST 2017\n按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的 date 命令 [root@linuxprobe ~]# date \u0026ldquo;+%Y-%m-%d %H:%M:%S\u0026rdquo; 2017-08-24 16:29:12\n将系统的当前时间设置为 2017 年 9 月 1 日 8 点 30 分的 date 命令 [root@linuxprobe ~]# date -s \u0026ldquo;20170901 8:30:00\u0026rdquo; Fri Sep 1 08:30:00 CST 2017\n再次使用 date 命令并按照默认的格式查看当前的系统时 [root@linuxprobe ~]# date Fri Sep 1 08:30:01 CST 2017\ndate 命令中的参数%j 可用来查看今天是当年中的第几天。 [root@linuxprobe ~]# date \u0026ldquo;+%j\u0026rdquo; 244\n3．reboot - 系统重启 reboot 命令用于重启系统，其格式为 reboot。\n由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用 root 管理员来 重启，其命令如下： [root@linuxprobe ~]# reboot\n4．poweroff - 关闭系统 poweroff 命令用于关闭系统，其格式为 poweroff。\n该命令与 reboot 命令相同，都会涉及硬件资源的管理权限，因此默认只有 root 管理员才 可以关闭电脑，其命令如下： [root@linuxprobe ~]# poweroff\n5．wget - 下载网络文件 wget 命令用于在终端中下载网络文件，格式为“wget [参数] 下载地址”。 wget 命令的参数以及作用\n参数 作用 -b 后台下载模式 -P 下载到指定目录 -t 最大尝试次数 -c 断点续传 -p 下载页面内所有资源，包括图片、视频等 -r 递归下载 尝试使用 wget 命令从本书的配套站点中下载本书的最新 pdf 格式电子文档，这个文件的完整路径为 http://www.linuxprobe.com/docs/LinuxProbe.pdf ，执行该命令后的下载效果如下： [root@linuxprobe ~]# wget http://www.linuxprobe.com/docs/LinuxProbe.pdf \u0026ndash;2017-08-24 19:30:12 \u0026ndash; http://www.linuxprobe.com/docs/LinuxProbe.pdf Resolving www.linuxprobe.com (www.linuxprobe.com)\u0026hellip; 220.181.105.185 Connecting to www.linuxprobe.com (www.linuxprobe.com)|220.181.105.185|:80\u0026hellip; connected. HTTP request sent, awaiting response\u0026hellip; 200 OK Length: 45948568 (44M) [application/pdf] Saving to: ‘LinuxProbe.pdf’ 100%[===========================================\u0026gt;] 45,948,568 32.9MB/s in 1.3s 2017-08-24 19:30:14 (32.9 MB/s) - ‘LinuxProbe.pdf’ saved [45948568/45948568]\n接下来，我们使用 wget 命令递归下载 www.linuxprobe.com 网站内的所有页面数据以及文件，下载完后会自动保存到当前路径下一个名为 www.linuxprobe.com 的目录中。执行该操作的命令为 wget -r -p http://www.linuxprobe.com ，该命令的执行结果如下: [root@linuxprobe ~]# wget -r -p http://www.linuxprobe.com \u0026ndash;2017-08-24 19:31:41\u0026ndash; http://www.linuxprobe.com/ Resolving www.linuxprobe.com\u0026hellip; 106.185.25.197 Connecting to www.linuxprobe.com|106.185.25.197|:80\u0026hellip; connected. HTTP request sent, awaiting response\u0026hellip; 200 OK Length: unspecified [text/html] Saving to: \u0026lsquo;www.linuxprobe.com/index.html' ………………省略下载过程………………\n6．ps - 查看进程状态 ps 命令用于查看系统中的进程状态，格式为“ps [参数]”。\nps 命令与管道符技术搭配使用，用来抓取与某个指定服务进程相对应的 PID 号码。 ps 命令的参数以及作用\n参数 作用 -a 显示所有进程（包括其他用户的进程） -u 用户以及其他详细信息 -x 显示没有控制终端的进程 Linux 系统中，有 5 种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。\nR（运行）：进程正在运行或在运行队列中等待。 S（中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。 D（不可中断）：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。 Z（僵死）：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数后将进程释放。 T（停止）：进程收到停止信号后停止运行。 当执行 ps aux 命令后通常会看到如表 2-7 所示的进程状态，表 2-7 中只是列举了部分输出值，而且正常的输出值中不包括中文注释。\n进程状态\n进程的所有者 进 程ID 号 运算器占用率 内存占用率 虚拟内存使用量（单位是 KB） 占用的固定内存量（单位是KB） 所在终端 进程状态 被启动的时间 实际使用CPU的时间 命令名称与参数 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.4 53684 7628 ? Ss 07 :22 0:02 /usr/lib/systemd/systemd root 2 0.0 0.0 0 0 ? S 07:22 0:00 [kthreadd] ………………省略部分输出信息……………… 7．top 命令 top 命令用于动态地监视进程活动与系统负载等信息，其格式为 top。 top 命令相当强大，能够动态地查看系统运维状态，完全将它看作 Linux 中的“强化版的 Windows 任务管理器”。top 命令的运行界面如下\n1 2 3 4 5 top - 19:19:51 up 11 min， 2 users, load average : 0.01, 0.17, 0.19 Tasks: 519 total, 2 running, 517 sleeping, 0 stopped, 0 zombie %Cpu(s): 1.1 us, 0.6 sy, 0.0 ni, 97.1 id, 1.1 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem: 3869044 total, 900604 used, 2968440 free, 924 buffers KiB Swap: 2097148 total, 0 used, 2097148 free, 278556 cached Mem top 命令执行结果的前 5 行为系统整体的统计信息，其所代表的含义如下。\n第 1 行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为 1 分钟、5分钟、15 分钟内的平均值，数值越小意味着负载越低）。 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。 注：第 3 行中的数据均为 CPU 数据并以百分比格式显示，例如“97.1 id”意味着有 97.1%的 CPU 处理器资源处于空闲。 第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。 8．pidof 查询某个进程PID pidof 命令用于查询某个指定服务进程的 PID 值，格式为“pidof [参数] [服务名称]”。\n每个进程的进程号码值（PID）是唯一的，因此可以通过 PID 来区分不同的进程。例如， 可以使用如下命令来查询本机上 sshd 服务程序的 PID： [root@linuxprobe ~]# pidof sshd 2156\n9．kill - 中止单个进程 kill 命令用于终止某个指定 PID 的服务进程，格式为“kill [参数] [进程 PID]”。\n接下来，我们使用 kill 命令把上面用 pidof 命令查询到的 PID 所代表的进程终止掉，其命令如下所示。 这种操作的效果等同于强制停止 sshd 服务。 [root@linuxprobe ~]# kill 2156\n10．killall - 中止批量进程 killall 命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进程名称]”。\n通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用 killall 命令来批量结束某个服务程序带有的全部进程。下面以 httpd 服务程序为例，来结束其全部进程。由于 RHEL7 系统默认没有安装 httpd 服务程序，因此大家此时只需看操作过程和输出结果即可，等学习了相关内容之后再来实践。\n[root@linuxprobe ~]# pidof httpd 13581 13580 13579 13578 13577 13576 [root@linuxprobe ~]# killall httpd [root@linuxprobe ~]# pidof httpd [root@linuxprobe ~]#\n如果我们在系统终端中执行一个命令后想立即停止它，可以同时按下 Ctrl + C 组合键，这样将立即终止该命令的进程。 或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加上一个\u0026amp;符号，这样命令将进入系统后台来执行。\n二、系统状态检测命令 1．ifconfig - 网卡配置与网络状态 ifconfig 命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]”。\n使用 ifconfig 命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet 参数后面的 IP 地址、ether 参数后面的网卡物理地址（又称为 MAC 地址），以及 RX、TX 的接收数据包与发送数据包的个数及累计流量（即下面加粗的信息内容）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@linuxprobe ~]# ifconfig eno16777728: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.10.10 netmask 255.255.255.0 broadcast 192.168.10.255 inet6 fe80::20c:29ff:fec4:a409 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 00:0c:29:c4:a4:09 txqueuelen 1000 (Ethernet) RX packets 36 bytes 3176 (3.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 38 bytes 4757 (4.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 0 (Local Loopback) RX packets 386 bytes 32780 (32.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 386 bytes 32780 (32.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 2．uname - 系统内核与系统版本 uname 命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。\n在使用 uname 命令时，一般会固定搭配上-a 参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。\n[root@linuxprobe ~]# uname -a Linux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux\n顺带一提，如果要查看当前系统版本的详细信息，则需要查看 redhat-release 文件，其命令以及相应的结果如下： [root@linuxprobe ~]# cat /etc/redhat-release Red Hat Enterprise Linux Server release 7.0 (Maipo)\n3．uptime - 系统负载信息 uptime 用于查看系统的负载信息，格式为 uptime。\nuptime 命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。 负载值越低越好，尽量不要长期超过 1，在生产环境中不要超过 5。\n平均负载值指的是系统在最近 1 分钟、5 分钟、15 分钟内的压力情况； [root@linuxprobe ~]# uptime 22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18\n4．free - 内存使用量 free 用于显示当前系统中内存的使用量信息，格式为“free [-h]”。\n可以结合使用 -h 参数以更人性化的方式输出当前内存的实时使用量信息。 [root@linuxprobe ~]# free -h 执行 free -h 命令后的输出信息\n内存总量 已用量 可用量 进程共享的内存量 磁盘缓存的内存量 缓存的内存量 total used free shared buffers cached Mem 1.8GB 1.3GB 542MB 9.8MB 1.6MB 413MB -/+ buffers/cache 869MB 957MB Swap 2.0GB 0 2.0GB 5．who - 登入主机的用户终端信息 who 用于查看当前登入主机的用户终端信息，格式为“who [参数]”。\n这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端信息。 [root@linuxprobe ~]# who 执行 who 命令的结果\n登录的用户名 终端设备 登录到系统的时间 root :0 2017-08-24 17:52 (:0) root pts/0 2017-08-24 17:52 (:0) 6．last - 系统的登录记录 last 命令用于查看所有系统的登录记录，格式为“last [参数]”。\n使用 last 命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！\n1 2 3 4 5 6 7 8 [root@linuxprobe ~]# last root pts/0 :0 Mon Aug 24 17:52 still logged in root :0 :0 Mon Aug 24 17:52 still logged in (unknown :0 :0 Mon Aug 24 17:50 - 17:52 (00:02) reboot system boot 3.10.0-123.el7.x Tue Aug 25 01:49 - 18:17 (-7:-32) root pts/0 :0 Mon Aug 24 15:40 - 08:54 (7+17:14) root pts/0 :0 Fri Jul 10 10:49 - 15:37 (45+04:47) ………………省略部分登录信息……………… 7．history - 显示历史执行过的命令 history 命令用于显示历史执行过的命令，格式为“history [-c]”。\nhistory 命令应该是作者最喜欢的命令。执行 history 命令能显示出当前用户在本地计算机中执行过的最近 1000 条命令记录。如果觉得 1000 不够用，还可以自定义/etc/profile 文件中的HISTSIZE 变量值。在使用 history 命令时，如果使用-c 参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [root@linuxprobe ~]# history 1 tar xzvf VMwareTools-9.9.0-2304977.tar.gz 2 cd vmware-tools-distrib/ 3 ls 4 ./vmware-install.pl -d 5 reboot 6 df -h 7 cd /run/media/ 8 ls 9 cd root/ 10 ls 11 cd VMware\\ Tools/ 12 ls 13 cp VMwareTools-9.9.0-2304977.tar.gz /home 14 cd /home 15 ls 16 tar xzvf VMwareTools-9.9.0-2304977.tar.gz 17 cd vmware-tools-distrib/ 18 ls 19 ./vmware-install.pl -d 20 reboot 21 history [root@linuxprobe ~]# !15 anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures Templates Desktop Downloads Music Public Videos 历史命令会被保存到用户家目录中的.bash_history 文件中。Linux 系统中以点（.）开头的文件均代表隐藏文件，这些文件大多数为系统服务文件，可以用 cat 命令查看其文件内容。 [root@linuxprobe ~]# cat ~/.bash_history 要清空当前用户在本机上执行的 Linux 命令历史记录信息，可执行如下命令： [root@linuxprobe ~]# history -c\n8．sosreport - 系统配置及架构信息 sosreport 命令用于收集系统配置及架构信息并输出诊断文档，格式为 sosreport。\n当 Linux 系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，亦或让他们能提前了解某些复杂问题。在下面的输出信息中，加粗的部分是收集好的资料压缩文件以及校验码，将其发送给技术支持人员即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [root@linuxprobe ~]# sosreport sosreport (version 3.0) This command will collect diagnostic and configuration information from this Red Hat Enterprise Linux system and installed applications. An archive containing the collected information will be generated in /var/tmp and may be provided to a Red Hat support representative. Any information provided to Red Hat will be treated in accordance with the published support policies at: https://access.redhat.com/support/ The generated archive may contain data considered sensitive and its content should be reviewed by the originating organization before being passed to any third party. No changes will be made to system configuration. Press ENTER to continue, or CTRL-C to quit. 此处敲击回车来确认收集信息 Please enter your first initial and last name [linuxprobe.com]: 此处敲击回车来确认主机编号 Please enter the case number that you are generating this report for: 此处敲击回车来确认主机编号 Running plugins. Please wait ... Running 70/70: yum... Creating compressed archive... Your sosreport has been generated and saved in: /var/tmp/sosreport-linuxprobe.com-20170905230631.tar.xz The checksum is: 79436cdf791327040efde48c452c6322 Please send this file to your support representative. 三、工作目录切换命令 1．pwd - 当前所在工作目录 pwd 命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。 [root@linuxprobe etc]# pwd /etc\n2．cd - 切换工作路径 cd 命令用于切换工作路径，格式为“cd [目录名称]”。\n常见的切换目录方式： cd - 命令返回到上一次所处的目录 cd .. 命令进入上级目录 cd ~ 命令切换到当前用户的家目录 cd ~ username 切换到其他用户的家目录\n例如，可以使用“cd 路径”的方式切换进/etc 目录中： [root@linuxprobe ~]# cd /etc 同理，可使用下述命令切换到/bin 目录中： [root@linuxprobe etc]# cd /bin\n要返回到上一次的目录（即/etc 目录），可执行如下命令： [root@linuxprobe bin]# cd - /etc [root@linuxprobe etc]#\n通过下面的命令快速切换到用户的家目录： [root@linuxprobe etc]# cd ~ [root@linuxprobe ~]#\n3．ls - 显示目录中的文件信息 ls 命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。\n所处的工作目录不同，当前工作目录下的文件肯定也不同。 使用 ls 命令的“-a”参数看到全部文件（包括隐藏文件）， 使用“-l”参数可以查看文件的属性、大小等详细信息。\n这两个参数整合之后，再执行 ls 命令即可查看当前目录中的所有文件并输出这些文件的属性信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 [root@linuxprobe ~]# ls -al total 60 dr-xr-x---. 14 root root 4096 May 4 07:56 . drwxr-xr-x. 17 root root 4096 May 4 15:55 .. -rw-------. 1 root root 1213 May 4 15:44 anaconda-ks.cfg -rw-------. 1 root root 957 May 4 07:54 .bash_history -rw-r--r--. 1 root root 18 Dec 28 2013 .bash_logout -rw-r--r--. 1 root root 176 Dec 28 2013 .bash_profile -rw-r--r--. 1 root root 176 Dec 28 2013 .bashrc drwx------. 10 root root 4096 May 4 07:56 .cache drwx------. 15 root root 4096 May 4 07:49 .config -rw-r--r--. 1 root root 100 Dec 28 2013 .cshrc drwx------. 3 root root 24 May 4 07:46 .dbus drwxr-xr-x. 2 root root 6 May 4 07:49 Desktop drwxr-xr-x. 2 root root 6 May 4 07:49 Documents drwxr-xr-x. 2 root root 6 May 4 07:49 Downloads -rw-------. 1 root root 16 May 4 07:49 .esd_auth -rw-------. 1 root root 628 May 4 07:56 .ICEauthority -rw-r--r--. 1 root root 1264 May 4 07:48 initial-setup-ks.cfg drwx------. 3 root root 18 May 4 07:49 .local drwxr-xr-x. 2 root root 6 May 4 07:49 Music drwxr-xr-x. 2 root root 6 May 4 07:49 Pictures drwxr-xr-x. 2 root root 6 May 4 07:49 Public -rw-r--r--. 1 root root 129 Dec 28 2013 .tcshrc drwxr-xr-x. 2 root root 6 May 4 07:49 Templates drwxr-xr-x. 2 root root 6 May 4 07:49 Videos -rw-------. 1 root root 1962 May 4 07:54 .viminfo 如果想要查看目录属性信息，则需要额外添加一个-d 参数。例如，可使用如下命令查看 /etc 目录的权限与属性信息： [root@linuxprobe ~]# ls -ld /etc drwxr-xr-x. 132 root root 8192 Jul 10 10:48 /etc\n四、文本文件编辑命令 1．cat - 文本文件_内容较少的 cat 命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。\nLinux 系统中有多个用于查看文本内容的命令，每个命令都有自己的特点，比如这个 cat命令就是用于查看内容较少的纯文本文件的。\n如果在查看文本内容时还想顺便显示行号的话，不妨在 cat 命令后面追加一个-n 参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@linuxprobe ~]# cat -n initial-setup-ks.cfg 1 #version=RHEL7 2 # X Window System configuration information 3 xconfig --startxonboot 4 5 # License agreement 6 eula --agreed 7 # System authorization information 8 auth --enableshadow --passalgo=sha512 9 # Use CDROM installation media 10 cdrom 11 # Run the Setup Agent on first boot 12 firstboot --enable 13 # Keyboard layouts 14 keyboard --vckeymap=us --xlayouts=\u0026#39;us\u0026#39; 15 # System language 16 lang en_US.UTF-8 ………………省略部分输出信息……………… 2．more - 文本文件_内容多的 more 命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。\n对于长篇的文本内容，推荐使用 more 命令来查看。more命令会在最下面使用百分比的形式来提示您已经阅读了多少内容。您还可以使用空格键或回车键向下翻页：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [root@linuxprobe ~]# more initial-setup-ks.cfg #version=RHEL7 # X Window System configuration information xconfig --startxonboot # License agreement eula --agreed # System authorization information auth --enableshadow --passalgo=sha512 # Use CDROM installation media cdrom # Run the Setup Agent on first boot firstboot --enable # Keyboard layouts keyboard --vckeymap=us --xlayouts=\u0026#39;us\u0026#39; # System language lang en_US.UTF-8 ignoredisk --only-use=sda # Network information network --bootproto=dhcp --device=eno16777728 --onboot=off --ipv6=auto network --bootproto=dhcp --hostname=linuxprobe.com --More--(43%) 3．head - 文本文档的前 N 行 head 命令用于查看纯文本文档的前 N 行，格式为“head [选项] [文件]”。\n如果只想查看文本中前 20 行的内容，该怎么办呢？head 命令可以派上用场了： [root@linuxprobe ~]# head -n 20 initial-setup-ks.cfg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [root@linuxprobe ~]# head -n 20 initial-setup-ks.cfg #version=RHEL7 # X Window System configuration information xconfig --startxonboot # License agreement eula --agreed # System authorization information auth --enableshadow --passalgo=sha512 # Use CDROM installation media cdrom # Run the Setup Agent on first boot firstboot --enable # Keyboard layouts keyboard --vckeymap=us --xlayouts=\u0026#39;us\u0026#39; # System language lang en_US.UTF-8 ignoredisk --only-use=sda # Network information network --bootproto=dhcp --device=eno16777728 --onboot=off --ipv6=auto [root@linuxprobe ~]# 4．tail- 文本文档后 N 行/持续刷新内容 tail 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式为“tail [选项] [文件]”。\n如需要查看文本内容的最后 20 行，只需要执行“tail -n 20 文件名”命令\ntail 命令最强悍的功能是可以持续刷新一个文件的内容，当想要实时查看最新日志文件时，这特别有用，此时的命令格式为“tail -f 文件名”：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@linuxprobe ~]# tail -f /var/log/messages May 4 07:56:38 localhost gnome-session: Window manager warning: Log level 16: STACK_OP_ADD: window 0x1e00001 already in stack May 4 07:56:38 localhost gnome-session: Window manager warning: Log level 16: STACK_OP_ADD: window 0x1e00001 already in stack May 4 07:56:38 localhost vmusr[12982]: [ warning] [Gtk] gtk_disable_setlocale() must be called before gtk_init() May 4 07:56:50 localhost systemd-logind: Removed session c1. Aug 1 01:05:31 localhost systemd: Time has been changed Aug 1 01:05:31 localhost systemd: Started LSB: Bring up/down networking. Aug 1 01:08:56 localhost dbus-daemon: dbus[1124]: [system] Activating service name=\u0026#39;com.redhat.SubscriptionManager\u0026#39; (using servicehelper) Aug 1 01:08:56 localhost dbus[1124]: [system] Activating service name=\u0026#39;com. redhat.SubscriptionManager\u0026#39; (using servicehelper) Aug 1 01:08:57 localhost dbus-daemon: dbus[1124]: [system] Successfully activated service \u0026#39;com.redhat.SubscriptionManager\u0026#39; Aug 1 01:08:57 localhost dbus[1124]: [system] Successfully activated service \u0026#39; com.redhat.SubscriptionManager\u0026#39; 5．tr - 替换文本文件中的字符 tr 命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。\n快速地替换文本中的一些词汇，就可以先使用 cat 命令读取待处理的文本，然后通过管道符把这些文本内容传递给 tr 命令进行替换操作即可。 例如，把某个文本内容中的英文全部替换为大写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 [root@linuxprobe ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z] #VERSION=RHEL7 # SYSTEM AUTHORIZATION INFORMATION AUTH --ENABLESHADOW --PASSALGO=SHA512 # USE CDROM INSTALLATION MEDIA CDROM # RUN THE SETUP AGENT ON FIRST BOOT FIRSTBOOT --ENABLE IGNOREDISK --ONLY-USE=SDA # KEYBOARD LAYOUTS KEYBOARD --VCKEYMAP=US --XLAYOUTS=\u0026#39;US\u0026#39; # SYSTEM LANGUAGE LANG EN_US.UTF-8 # NETWORK INFORMATION NETWORK --BOOTPROTO=DHCP --DEVICE=ENO16777728 --ONBOOT=OFF --IPV6=AUTO NETWORK --HOSTNAME=LOCALHOST.LOCALDOMAIN # ROOT PASSWORD ROOTPW --ISCRYPTED $6$PDJJF42G8C6PL069$II.PX/YFAQPO0ENW2PA7MOMKJLYOAE2ZJMZ2UZJ7 BH3UO4OWTR1.WK/HXZ3XIGMZGJPCS/MGPYSSOI8HPCT8B/ # SYSTEM TIMEZONE TIMEZONE AMERICA/NEW_YORK --ISUTC USER --NAME=LINUXPROBE --PASSWORD=$6$A9V3INSTNBWEIR7D$JEGFYWBCDOOOKJ9SODECCDO. ZLF4OSH2AZ2SS2R05B6LZ2A0V2K.RJWSBALL2FEKQVGF640OA/TOK6J.7GUTO/ --ISCRYPTED -- GECOS=\u0026#34;LINUXPROBE\u0026#34; # X WINDOW SYSTEM CONFIGURATION INFORMATION XCONFIG --STARTXONBOOT # SYSTEM BOOTLOADER CONFIGURATION BOOTLOADER --LOCATION=MBR --BOOT-DRIVE=SDA AUTOPART --TYPE=LVM # PARTITION CLEARING INFORMATION CLEARPART --NONE --INITLABEL %PACKAGES @BASE @CORE @DESKTOP-DEBUGGING @DIAL-UP @FONTS @GNOME-DESKTOP @GUEST-AGENTS @GUEST-DESKTOP-AGENTS @INPUT-METHODS @INTERNET-BROWSER @MULTIMEDIA @PRINT-CLIENT @X11 %END 6．wc - 统计文本的字数行数字节数 wc 命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。\nwc 的参数以及作用\n参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 在 Linux 系统中，passwd 是用于保存系统账户信息的文件，要统计当前系统中有多少个 用户，可以使用下面的命令来进行查询，是不是很神奇： [root@linuxprobe ~]# wc -l /etc/passwd 38 /etc/passwd\n7．stat - 文件具体存储信息和时间 stat 命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。\n命令 stat anaconda-ks.cfg 会显示出文件的三种时间状态：Access、Modify、Change。这三种时间的区别将在下面的 touch命令中详细详解：\n1 2 3 4 5 6 7 8 9 10 [root@linuxprobe ~]# stat anaconda-ks.cfg File: ‘anaconda-ks.cfg’ Size: 1213 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 68912908 Links: 1 Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root) Context: system_u:object_r:admin_home_t:s0 Access: 2017-07-14 01:46:18.721255659 -0400 Modify: 2017-05-04 15:44:36.916027026 -0400 Change: 2017-05-04 15:44:36.916027026 -0400 Birth: - 8．cut - 按“列”提取文本字符 cut 命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。\n一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。 但是如果按列搜索，不仅要使用-f 参数来设置需要看的列数，还需要使用-d 参数来设置间隔符号。 passwd 在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用 下述命令尝试提取出 passwd 文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 [root@linuxprobe ~]# head -n 2 /etc/passwd root❌0:0:root:/root:/bin/bash bin❌1:1:bin:/bin:/sbin/nologin [root@linuxprobe ~]# cut -d: -f1 /etc/passwd root bin daemon adm lp sync shutdown halt mail operator games ftp nobody dbus polkitd unbound colord usbmuxd avahi avahi-autoipd libstoragemgmt saslauth qemu rpc 9．diff - 比较多个文本文件的差异 diff 命令用于比较多个文本文件的差异，格式为“diff [参数] 文件”。\n可以使用 \u0026ndash;brief 参数来确认两个文件是否不同 可以使用 -c 参数来详细比较出多个文件的差异之处 先使用 cat 命令分别查看 diff_A.txt 和 diff_B.txt 文件的内容，然后进行比较： [root@linuxprobe ~]# cat diff_A.txt Welcome to linuxprobe.com Red Hat certified Free Linux Lessons Professional guidance Linux Course\n[root@linuxprobe ~]# cat diff_B.txt Welcome tooo linuxprobe.com Red Hat certified Free Linux LeSSonS ////////\u0026hellip;..//////// Professional guidance Linux Course\n接下来使用 diff \u0026ndash;brief 命令显示比较后的结果，判断文件是否相同： [root@linuxprobe ~]# diff \u0026ndash;brief diff_A.txt diff_B.txt Files diff_A.txt and diff_B.txt differ\n最后使用带有-c 参数的 diff 命令来描述文件内容具体的不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@linuxprobe ~]# diff -c diff_A.txt diff_B.txt *** diff_A.txt 2017-08-30 18:07:45.230864626 +0800 --- diff_B.txt 2017-08-30 18:08:52.203860389 +0800 *************** *** 1,5 **** ! Welcome to linuxprobe.com Red Hat certified ! Free Linux Lessons Professional guidance Linux Course --- 1,7 ---- ! Welcome tooo linuxprobe.com ! Red Hat certified ! Free Linux LeSSonS ! ////////.....//////// Professional guidance Linux Course 五、文件目录管理命令 1．touch - 创建空白文件/设置文件时间 touch 命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。\n比如，touch linuxprobe 命令可以创建出一个名为 linuxprobe 的空白文本文件。 对 touch 命令来讲，有难度的操作主要是体现在 设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime） 上面。 touch 命令的参数及其作用如表所示\n参数 作用 -a 仅修改“读取时间”（atime） -m 仅修改“修改时间”（mtime） -d 同时修改 atime 与 mtime 接下来我们先使用 ls 命令查看一个文件的修改时间，然后修改这个文件，最后再通过 touch 命令把修改后的文件时间设置成修改之间的时间（很多黑客就是这样做的呢）：\n1 2 3 4 5 6 7 8 9 10 11 12 [root@linuxprobe ~]# ls -l anaconda-ks.cfg //查看文件的修改时间 -rw-------. 1 root root 1213 May 4 15:44 anaconda-ks.cfg [root@linuxprobe ~]# echo \u0026#34;Visit the LinuxProbe.com to learn linux skills\u0026#34; \u0026gt;\u0026gt; anaconda-ks.cfg //修改文件 [root@linuxprobe ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1260 Aug 2 01:26 anaconda-ks.cfg [root@linuxprobe ~]# touch -d \u0026#34;2017-05-04 15:44\u0026#34; anaconda-ks.cfg //设置文件的修改时间 [root@linuxprobe ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1260 May 4 15:44 anaconda-ks.cfg 2．mkdir - 创建空白的目录 mkdir 命令用于创建空白的目录，格式为“mkdir [选项] 目录”。 [root@linuxprobe ~]# mkdir linuxprobe [root@linuxprobe ~]# cd linuxprobe\nmkdir命令还可以结合-p 参数来递归创建出具有嵌套叠层关系的文件目录。 [root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e [root@linuxprobe linuxprobe]# cd a [root@linuxprobe a]# cd b [root@linuxprobe b]#\n3．cp - 复制文件/目录 cp 命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。\n复制操作具体分为 3 种情况：\n如果目标文件是目录，则会把源文件复制到该目录中； 如果目标文件也是普通文件，则会询问是否要覆盖它； 如果目标文件不存在，则执行正常的复制操作 cp 命令的参数及其作用\n参数 作用 -a 仅修改“读取时间”（atime） -m 仅修改“修改时间”（mtime） -d 同时修改 atime 与 mtime -p 保留原始文件的属性 -d 若对象为“链接文件”，则保留该“链接文件”的属性 -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p、d、r 为上述参数） 接下来，使用 touch 创建一个名为 install.log 的普通空白文件，然后将其复制为一份名为 x.log 的备份文件，最后再使用 ls 命令查看目录中的文件： [root@linuxprobe ~]# touch install.log [root@linuxprobe ~]# cp install.log x.log [root@linuxprobe ~]# ls install.log x.log\n4．mv - 剪切文件/文件重命名 mv 命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。\n如果在同一个目录中对一个文件进行剪切操作，其实也就是对其进行重命名： [root@linuxprobe ~]# mv x.log linux.log [root@linuxprobe ~]# ls install.log linux.log\n5．rm - 删除文件/目录 rm 命令用于删除文件或目录，格式为“rm [选项] 文件”。 rm -f 强制删除 rm -r 删除一个目录\n我们来尝试删除前面创建的 install.log和 linux.log 文件： [root@linuxprobe ~]# rm install.log rm: remove regular empty file ‘install.log’? y [root@linuxprobe ~]# rm -f linux.log [root@linuxprobe ~]# ls [root@linuxprobe ~]#\n6．dd - 按指定大学复制文件 dd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。\ndd 命令它能够让用户按照指定大小和个数的数据块来复制文件的内容。 当然如果愿意的话，还可以在复制过程中转换其中的数据。 Linux系统中有一个名为/dev/zero 的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为 dd命令的输入文件，来生成一个指定大小的文件。\ndd 命令的参数及其作用\n参数 作用 if 输入的文件名称 of 输出的文件名称 bs 设置每个“块”的大小 count 设置要复制“块”的个数 例如我们可以用 dd 命令从/dev/zero 设备文件中取出一个大小为 560MB 的数据块，然后 保存成名为 560_file 的文件。 [root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M 1+0 records in 1+0 records out 587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s\ndd 命令的功能不仅限于复制文件 如果您想把光驱设备中的光盘制作成 iso 格式的镜像文件，在 Windows 系统中需要借助于第三方软件才能做到，但在 Linux 系统中可以直接使用 dd 命令来压制出光盘镜像文件，将它编程一个可立即使用的 iso 镜像： [root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso 7311360+0 records in 7311360+0 records out 3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s\n考虑到有些读者会纠结 bs 块大小与 count 块个数的关系，下面举一个吃货的例子进行解释。假设小明的饭量（即需求）是一个固定的值，用来盛饭的勺子的大小即 bs 块大小，而用勺子盛饭的次数即 count 块个数。小明要想吃饱（满足需求），则需要在勺子大小（bs块大小）与用勺子盛饭的次数（count 块个数）之间进行平衡。勺子越大，用勺子盛饭的次数就越少。有上可见，bs 与 count 都是用来指定容量的大小，只要能满足需求，可随意组合搭配方式。\n7．file - 查看文件的类型 file 命令用于查看文件的类型，格式为“file 文件名”。\n[root@linuxprobe ~]# file anaconda-ks.cfg anaconda-ks.cfg: ASCII text [root@linuxprobe ~]# file /dev/sda /dev/sda: block special\n六、打包压缩与搜索命令 1．tar - 打包压缩或解压 tar 命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。\n在 Linux 系统中，常见的文件格式比较多，其中主要使用的是.tar 或.tar.gz 或.tar.bz2 格式，其实这些格式大部分都是由 tar 命令来生成的。 tar 命令的参数及其作用\n参数 作用 -c 创建压缩文件 -x 解开压缩文件 -t 查看压缩包内有哪些文件 -z 用 Gzip 压缩或解压 -j 用 bzip2 压缩或解压 -v 显示压缩或解压的过程 -f 目标文件名 -p 保留原始的权限与属性 -P 使用绝对路径来压缩 -C 指定解压到的目录 首先，-c 参数用于创建压缩文件，-x 参数用于解压文件，因此这两个参数不能同时使用。 其次，-z 参数指定使用 Gzip 格式来压缩或解压文件，-j 参数指定使用 bzip2 格式来压缩或解 压文件。用户使用时则是根据文件的后缀来决定应使用何种格式参数进行解压。 推荐使用-v 参数向用户不断显示压缩或解压的过程。 -C 参数用于指定要解压到哪个指定的目录。 -f 参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。\n刘遄老师一般使用“tar -czvf 压缩包名称.tar.gz 要打包的目录” 命令把指定的文件进行打包压缩；相应的解压命令为“tar -xzvf 压缩包名称.tar.gz”。\n下面我们来逐个演示下打包压缩与解压的操作。 先使用 tar 命令把/etc 目录通过 gzip 格式进行打包压缩，并把文件命名为 etc.tar.gz：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [root@linuxprobe ~]# tar -czvf etc.tar.gz /etc tar: Removing leading \u0026#39;/\u0026#39; from member names /etc/ /etc/fstab /etc/crypttab /etc/mtab /etc/fonts/ /etc/fonts/conf.d/ /etc/fonts/conf.d/65-0-madan.conf /etc/fonts/conf.d/59-liberation-sans.conf /etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf /etc/fonts/conf.d/59-liberation-mono.conf /etc/fonts/conf.d/66-sil-nuosu.conf ………………省略部分压缩过程信息……………… 接下来将打包后的压缩包文件指定解压到/root/etc 目录中（先使用 mkdir 命令来创建/root/etc 目录）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [root@linuxprobe ~]# mkdir /root/etc [root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etc etc/ etc/fstab etc/crypttab etc/mtab etc/fonts/ etc/fonts/conf.d/ etc/fonts/conf.d/65-0-madan.conf etc/fonts/conf.d/59-liberation-sans.conf etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf etc/fonts/conf.d/59-liberation-mono.conf etc/fonts/conf.d/66-sil-nuosu.conf etc/fonts/conf.d/65-1-vlgothic-gothic.conf etc/fonts/conf.d/65-0-lohit-bengali.conf etc/fonts/conf.d/20-unhint-small-dejavu-sans.conf ………………省略部分解压过程信息……………… 2．grep - 执行关键词搜索 grep 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。 grep 命令的参数及其作用\n参数 作用 -b 将可执行文件（binary）当作文本文件（text）来搜索 -c 仅显示找到的行数 -i 忽略大小写 -n 显示行号 -v 反向选择—仅列出没有“关键词”的行 两个最最常用的参数： -n 参数用来显示搜索到信息的行号； -v 参数用于反选信息（即没有包含关键词的所有信息行）\n这两个参数几乎能完成您日后 80%的工作需要，至于其他上百个参数，即使以后在工作期间遇到了，再使用 man grep 命令查询也来得及。\n在 Linux 系统中，/etc/passwd 文件是保存着所有的用户信息，而一旦用户的登录终端被设置成 /sbin/nologin，则不再允许登录系统，因此可以使用 grep 命令来查找出当前系统中不允许登录系统的所有用户信息： [root@linuxprobe ~]# grep /sbin/nologin /etc/passwd bin❌1:1:bin:/bin:/sbin/nologin daemon❌2:2:daemon:/sbin:/sbin/nologin adm❌3:4:adm:/var/adm:/sbin/nologin lp❌4:7:lp:/var/spool/lpd:/sbin/nologin mail❌8:12:mail:/var/spool/mail:/sbin/nologin operator❌11:0:operator:/root:/sbin/nologin ………………省略部分输出过程信息………………\n3．find - 查找文件 find 命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。\n搜索工作一般都是通过 find 命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上。\nfind 命令中的参数以及作用\n参数 作用 -name 匹配名称 -perm 匹配权限（mode 为完全匹配，-mode 为包含即可） -user 匹配所有者 -group 匹配所有组 -mtime -n +n 匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前） -atime -n +n 匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前） -ctime -n +n 匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前） -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件 f1 新但比 f2 旧的文件 \u0026ndash;type b/d/c/p/l/f 匹配文件类型（后面的字幕参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件） -size 匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 -prune 忽略某个目录 -exec …… {}; 后面可跟用于进一步处理搜索结果的命令（下文会有演示） 这里需要重点讲解一下-exec 参数重要的作用。这个参数用于把 find 命令搜索到的结果交由紧随其后的命令作进一步处理，它十分类似于第 3 章将要讲解的管道符技术，并且由于 find命令对参数的特殊要求，因此虽然 exec 是长格式形式，但依然只需要一个减号（-）。 根据文件系统层次标准（Filesystem Hierarchy Standard）协议，Linux 系统中的配置文件会保存到/etc 目录中（详见第 6 章）。如果要想获取到该目录中所有以 host 开头的文件列表，可以执行如下命令： [root@linuxprobe ~]# find /etc -name \u0026ldquo;host*\u0026rdquo; -print /etc/avahi/hosts /etc/host.conf /etc/hosts /etc/hosts.allow /etc/hosts.deny /etc/selinux/targeted/modules/active/modules/hostname.pp /etc/hostname\n如果要在整个系统中搜索权限中包括 SUID 权限的所有文件（详见第 5 章），只需使用-4000 即可： [root@linuxprobe ~]# find / -perm -4000 -print /usr/bin/fusermount /usr/bin/su /usr/bin/umount /usr/bin/passwd /usr/sbin/userhelper /usr/sbin/usernetctl ………………省略部分输出信息………………\n复习题 1．在 RHEL 7 系统及众多的 Linux 系统中，最常使用的 Shell 终端是什么？ 答：Bash（Bourne-Again SHell）解释器。\n2．执行 Linux 系统命令时，添加参数的目的是什么？ 答：为了让 Linux 系统命令能够更贴合用户的实际需求进行工作。\n3．Linux 系统命令、命令参数及命令对象之间，普遍应该使用什么来间隔？ 答：应该使用一个或多个空格进行间隔。\n4．请写出用 echo 命令把 SHELL 变量值输出到屏幕终端的命令。 答：echo $SHELL。\n5．简述 Linux 系统中 5 种进程的名称及含义。 答：在 Linux 系统中，有下面 5 种进程名称。\n（运行）：进程正在运行或在运行队列中等待。 （中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。 （不可中断）：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。 （僵死）：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数后将进程释放。 （停止）：进程收到停止信号后停止运行。 6．请尝试使用 Linux 系统命令关闭 PID 为 5529 的服务进程。 答：执行 kill 5529 命令即可；若知道服务的名称，则可以使用 killall 命令进行关闭。\n7．使用 ifconfig 命令查看网络状态信息时，需要重点查看的 4 项信息分别是什么？ 答：这 4 项重要信息分别是网卡名称、IP 地址、网卡物理地址以及 RX/TX 的收发流量数据大小。\n8．使用 uptime 命令查看系统负载时，对应的负载数值如果是 0.91、0.56、0.32，那么最近 15分钟内负载压力最大的是哪个时间段？ 答：通过负载数值可以看出，最近 1 分钟内的负载压力是最大的。\n9．使用 history 命令查看历史命令的执行记录时，命令前面的数字除了排序外还有什么用处？ 答：还可以用“!数字”的命令格式重复执行某一次的命令记录，从而避免了重复输入较长命令的麻烦。\n10．若想查看的文件具有较长的内容，那么使用 cat、more、head、tail 中的哪个命令最合适？ 答：文件内容较长，使用 more 命令；反之使用 cat 命令。\n11．在使用 mkdir 命令创建有嵌套关系的目录时，应该加上什么参数呢？ 答：应该加上-p 递归迭代参数，从而自动化创建有嵌套关系的目录。复习题\n12．在使用 rm 命令删除文件或目录时，可使用哪个参数来避免二次确认呢？ 答：可使用-f 参数，这样即可无需二次确认。\n13．若有一个名为 backup.tar.gz 的压缩包文件，那么解压的命令应该是什么？ 答：应该用 tar 命令进行解压，执行 tar -xzvf backup.tar.gz 命令即可。\n14．使用 grep 命令对某个文件进行关键词搜索时，若想要进行文件内容反选，应使用什么参数？ 答：可使用-v 参数来进行匹配内容的反向选择，即显示出不包含某个关键词的行。\n","permalink":"https://bablvsj.github.io/posts/tech/linux/20230809-linux-%E6%96%B0%E6%89%8B%E5%BF%85%E5%A4%87%E5%91%BD%E4%BB%A4/","summary":"命令总结 命令参数的长格式与短格式示例 长格式 短格式 man \u0026ndash;help man -h 一、常用系统工作命令 1．echo - 输出值 echo 命令用于在终端输出字符串或变量提取后的值，","title":"Linux 新手必备命令"},{"content":"个人说明 我是小布。\n2023，面朝大海，春暖花开！。 \u0026ndash;2022.12\n博客日志 2023-07-25: 引用hugo主题 PaperMod。\n2022-12-15: 引用hugo主题 hugo-theme-Reader。\n2022-12-10: 博客使用hugo构建。\n一些文章写的不错的博主 冴羽写四个系列：JavaScript深入系列、JavaScript专题系列、ES6系列、React系列。\n颜乐乐在头条做前端，博客内容很全，尤其是“单元测试”系列。\n致谢 网站开发有借鉴 子舒 Kevin 两位的网站\n版权声明：网站文章所有版权如无特殊说明，均归本人所有。允许转载，标明出处即可。\n","permalink":"https://bablvsj.github.io/about/","summary":"about","title":"关于"},{"content":"一、数据结构 数据结构 优点 缺点 运行时间 添加/删除 链表 数据的添加/删除都较为方便 访问数据比较耗费时间 O(n) O(1) 数组 访问数据十分简单 添加/删除数据比较耗费时间 O(1) O(n) 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 访问 添加 删除 链表 慢 快 快 数组 快 慢 慢 1.1 链表 数据结构 优点 缺点 普通链表 数据的添加和删除都较为方便 访问比较耗费时间 循环链表 想要保存数量固定的最新数据时使用 访问比较耗费时间 双向链表 可以前后遍历数据 十分方便 一是指针数的增加会导致存储空间需求增加；二是添加和删除数据时需要改变更多指针的指向。 1.2 数组 数据结构 优点 缺点 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 1.3 栈 后进先出 的结构，我们称为 Last In First Out，简称 LIFO。 链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。\n1.4 队列 像队列这种最先进去的数据最先被取来，即 先进先出 的结构，我们称为 First In First Out，简称 FIFO。\n1.5 哈希表 只能从头开始查询。这个操作便叫作 线性查找\n在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。\n如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。\n1.6 堆 堆是一种图的树形结构，被用于实现“优先队列”（priority queues）。\n优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。 在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。\n堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为 O(1)。\n假设数据量为n，根据堆的形状可知树的高度为 log2n ，那重构树的时间复杂度为O(logn)。\n添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度成正比，也是 O(logn)。\n1.7 二叉查找树 二叉查找树（又叫作二叉搜索树或二叉排序树）是一种数据结构，采用了图的树形结构。数据存储于二叉查找树的各个结点中。\n每个节点最多有两个子节点\n两个性质：\n第一个是每个结点的值均大于其左子树上任意一个结点的值。 第二个是每个结点的值均小于其右子树上任意一个结点的值。 所以二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。 反之，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。 比较的次数取决于树的高度。所以如果结点数为 n，而且树的形状又较为均衡的话，比较大小和移动的次数最多就是 log2n。因此，时间复杂度为 O(logn)。 但如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了 O(n)。\n二、排序 2.1 冒泡排序 第 1 轮需要比较 n -1 次，第 2 轮需要比较 n -2 次……第 n -1 轮需 要比较 1 次。因此，总的比较次数为 (n-1) +(n-2) +…+1 ≈ n2/2。 不过，交换数字的次数和输入数据的排列顺序有关。假设出现某种极端情况，如输 入数据正好以从小到大的顺序排列，那么便不需要任何交换操作； 反过来，输入数据要是以从大到小的顺序排列，那么每次比较数字后便都要进行交换。因此，冒泡排序的时间复杂度为O($n^2$)。\n1 2 3 4 5 6 7 8 9 10 let Arr = [100, 49, 22, 1, 4, 15, 59, 28, 29, 10,] for (let i = 0; i \u0026lt; Arr.length; i++) { for (let j = Arr.length; j \u0026gt; i; j--) { if (Arr[j] \u0026lt; Arr[j-1]) { let temp = Arr[j-1] Arr[j-1] = Arr[j] Arr[j] = temp } } } 2.2 选择排序 选择排序就是重复从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换 这一操作的算法。在序列中寻找最小值时使用的是线性查找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 for (let i = 0; i \u0026lt; Arr.length; i++) { let startIndex=i,startValue = Arr[i],min = Arr[i], minIndex = i; for (let j = i; j \u0026lt; Arr.length; j++) { if (Arr[j] \u0026lt; min) { min = Arr[j] minIndex = j } } if(startIndex !== minIndex ){ Arr[startIndex] = Arr[minIndex] Arr[minIndex] = startValue } } 选择排序使用了线性查找来寻找最小值，因此在第 1 轮中需要比较 n -1 个数字，第 2 轮需要比较 n -2 个数字……到第 n -1 轮的时候就只需比较 1 个数字了。因此，总的比 较次数与冒泡排序的相同，都是 (n-1)+(n-2)+…+1 ≈ n2/2 次。 每轮中交换数字的次数最多为 1 次。如果输入数据就是按从小到大的顺序排列的， 便不需要进行任何交换。选择排序的时间复杂度也和冒泡排序的一样，都为 O($n^2$)。\n2.3 插入排序 插入排序是一种从序列左端开始依次对数据进行排序的算法。在排序过程中，左侧的数据陆续归位，而右侧留下的就是还未被排序的数据。插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内合适的位置上。\n1 2 3 4 5 6 7 8 9 10 11 let tempArr = [] for (let i = 0; i \u0026lt; Arr.length; i++) { tempArr.push(Arr[i]) for (let j = tempArr.length - 1; j \u0026gt;0 ; j--) { if (tempArr[j] \u0026lt; tempArr[j - 1]) { let temp = tempArr[j - 1] tempArr[j - 1] = tempArr[j] tempArr[j] = temp } } } 具体来说，就是第 k 轮需要比较 k -1 次。因此，在最糟糕的情况下，第 2 轮需要操作 1 次，第 3 轮操作 2 次……第 n 轮操作 n -1次，所以时间复杂度和冒泡排序的一样，都为 O($n^2$)。\n2.4 堆排序 堆排序的特点是利用了数据结构中的堆\n堆排序一开始需要将 n 个数据存进堆里，所需时间为 O(nlogn)。 排序过程中，堆从空堆的状态开始，逐渐被数据填满。由于堆的高度小于 log2n，所以插入 1 个数据所需要的时间为 O(logn)。 每轮取出最大的数据并重构堆所需要的时间为 O(logn)。由于总共有 n 轮，所以重构后排序的时间也是 O(nlogn)。 因此，整体来看堆排序的时间复杂度为 O(nlogn)。 这样来看，堆排序的运行时间比之前讲到的冒泡排序、选择排序、插入排序的时间O($n^2$) 都要短，但由于要使用堆这个相对复杂的数据结构，所以实现起来也较为困难。\n2.5 归并排序 论哪一行都是 n 个数据，所以每行的运行时间都为 O(n)。 而将长度为 n 的序列对半分割直到只有一个数据为止时，可以分成 log2n 行，因此，总 共有 log2n 行。也就是说，总的运行时间为 O(nlogn)，这与前面讲到的堆排序相同。\n2.6 快速排序 快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分 为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。 [ 比基准值小的数 ] 基准值 [ 比基准值大的数 ] 接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/20230809-%E7%AE%97%E6%B3%95/","summary":"一、数据结构 数据结构 优点 缺点 运行时间 添加/删除 链表 数据的添加/删除都较为方便 访问数据比较耗费时间 O(n) O(1) 数组 访问数据十分简单 添加/删除数据比较耗","title":"我的第一本算法书"},{"content":"","permalink":"https://bablvsj.github.io/message/","summary":"","title":"留言"}]