[{"content":"基础语法 数据列输出顺序 SELECT {列名...} 全表查询 select * from 表名\n查询 - 别名 别名语法 {原始字段名} as {别名} 来为查询结果的列名取一个便于理解的名称。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和年龄（age）信息，并为它们取别名为 学生姓名 和 学生年龄\nselect name as \u0026#39;学生姓名\u0026#39;, age as \u0026#39;学生年龄\u0026#39; from student; 查询 - 常量和运算 请编写一条 SQL 查询语句，从名为student的数据表中选择出所有学生的姓名（name）和分数（score），并且额外计算出分数的 2 倍（double_score）。\nselect name, score, score * 2 as double_score from student; 条件查询 - where SELECT 列1, 列2, ... FROM 表名 WHERE 条件; 请编写一条 SQL 查询语句，从名为student 的数据表中选择出所有学生的姓名（name）和成绩（score），要求学生姓名为 \u0026rsquo;lvsj\u0026rsquo;。\nselect name, score from student where name = \u0026#39;lvsj\u0026#39;; 条件查询 - 运算符 =、 !=、\u0026lt;、\u0026gt; \u0026ldquo;BETWEEN\u0026rdquo; 运算符来筛选出在某个范围内的值。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和年龄（age），要求学生姓名不等于 \u0026lsquo;热dog\u0026rsquo; 。\nselect name, age from student where name != \u0026#39;热dog\u0026#39;; 条件查询 空值 is null / is not null 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）、年龄（age）和成绩（score），要求学生年龄不为空值。\nselect name, age, score from student where age is not null; 模糊查询 like / not like **通配符：\n百分号（%）：表示任意长度的任意字符序列。 下划线（_）：表示任意单个字符。 还可以使用模糊查询匹配开头和结尾：\n-- 只查询以 \u0026#34;张\u0026#34; 开头的数据行 select name, age, position from employees where name like \u0026#39;张%\u0026#39;; -- 只查询以 \u0026#34;张\u0026#34; 结尾的数据行 select name, age, position from employees where name like \u0026#39;%张\u0026#39;; 同理，可以使用 not like 来查询不包含某关键字的信息。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和成绩（score），要求姓名（name）不包含 \u0026ldquo;李\u0026rdquo; 这个字。\nselect name, score from student where name not like \u0026#39;%李%\u0026#39;; 逻辑运算 AND / OR / NOT AND：表示逻辑与，要求同时满足多个条件，才返回 true。 OR：表示逻辑或，要求满足其中任意一个条件，就返回 true。 NOT：表示逻辑非，用于否定一个条件（本来是 true，用了 not 后转为 false） 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）、成绩（score），要求学生的姓名包含 \u0026ldquo;李\u0026rdquo;，或者成绩（score）大于 500。\nselect name, score from student where name like \u0026#39;%李%\u0026#39; or score \u0026gt; 500; 去重 distinct 除了按照单字段去重外，DISTINCT 关键字还支持根据多个字段的组合来进行去重操作，确保多个字段的组合是唯一的。\n示例语法如下：\ndistinct 字段1, 字段2, 字段3, ... 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有不重复的班级 ID（class_id）和考试编号（exam_num）的组合。\nselect distinct class_id, exam_num from student; 排序 order by 在排序的基础上，我们还可以根据多个字段的值进行排序。当第一个字段的值相同时，再按照第二个字段的值进行排序，以此类推。\n示例语法如下：\norder by 字段1 [升序/降序], 字段2 [升序/降序], ... 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出学生姓名（name）、年龄（age）和成绩（score），首先按照成绩从大到小排序，如果成绩相同，则按照年龄从小到大排序。\nselect name, age, score from student order by score desc, age asc; 截断和偏移 LIMIT关键字 请编写一条 SQL 查询语句，从名为 student 的数据表中选择学生姓名（name）和年龄（age），按照年龄从小到大排序，从第 2 条数据开始、截取 3 个学生的信息。\nselect name, age from student order by age asc limit 1, 3; 条件分支 case when 实例语法：\nCASE WHEN (条件1) THEN 结果1 WHEN (条件2) THEN 结果2 ... ELSE 其他结果 END 题目： 假设有一个学生表 student，包含以下字段：name（姓名）、age（年龄）。请你编写一个 SQL 查询，将学生按照年龄划分为三个年龄等级（age_level）：60 岁以上为 \u0026ldquo;老同学\u0026rdquo;，20 岁以上（不包括 60 岁以上）为 \u0026ldquo;年轻\u0026rdquo;，20 岁及以下、以及没有年龄信息为 \u0026ldquo;小同学\u0026rdquo;。\n返回结果应包含学生的姓名（name）和年龄等级（age_level），并按姓名升序排序。\nselect name, case when (age \u0026gt; 60) then \u0026#39;老同学\u0026#39; when (age \u0026gt; 20) then \u0026#39;年轻\u0026#39; else \u0026#39;小同学\u0026#39; end as age_level from student order by name asc; 函数 - 时间函数 常用的时间函数有：\nDATE：获取当前日期 DATETIME：获取当前日期时间 TIME：获取当前时间 假设有一个学生表 student，包含以下字段：name（姓名）、age（年龄）。 请你编写一个 SQL 查询，展示所有学生的姓名（name）和当前日期（列名为 \u0026ldquo;当前日期\u0026rdquo;）。\nselect name, date() as \u0026#39;当前日期\u0026#39; from student; 函数 - 字符串处理 \u0026#39;`UPPER` 将字段转换为大写\u0026#39; select name, upper(name) as upper_name from employees; \u0026#39;`LOWER` 将字段转换为小写\u0026#39; select name, lower(name) as lower_name from employees; \u0026#39;`LENGTH` 计算字段长度\u0026#39; select name, length(name) as name_length from employees; 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）。请你编写一个 SQL 查询，筛选出姓名为 \u0026lsquo;热dog\u0026rsquo; 的学生，展示其学号（id）、姓名（name）及其大写姓名（upper_name）。\nselect id, name, upper(name) as upper_name from student where name = \u0026#39;热dog\u0026#39; 函数 - 聚合函数 聚合函数是一类用于对数据集进行 汇总计算 的特殊函数。\n常见的聚合函数包括：\nCOUNT：计算指定列的行数或非空值的数量。 SUM：计算指定列的数值之和。 AVG：计算指定列的数值平均值。 MAX：找出指定列的最大值。 MIN：找出指定列的最小值。 示例 假设有一个订单表 orders，包含以下字段：order_id（订单号）、customer_id（客户编号）、amount（订单金额）。数据如下：\norder_id customer_id amount 1 A001 100 2 A002 200 3 A001 150 4 A003 50 1）使用聚合函数 COUNT 计算订单表中的总订单数：\nselect count(*) as order_num from orders; // order_num = 4 2）使用聚合函数 COUNT(DISTINCT 列名) 计算订单表中不同客户的数量：\nselect count(distinct customer_id) as customer_num FROM orders; // customer_num = 3 3）使用聚合函数 SUM 计算总订单金额：\nselect sum(amount) as total_amount from orders; // total_amount = 500 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、class_id（班级编号）、score（成绩）。请你编写一个 SQL 查询，汇总学生表中所有学生的总成绩（total_score）、平均成绩（avg_score）、最高成绩（max_score）和最低成绩（min_score）。\nselect sum(score) as total_score, avg(score) as avg_score, max(score) as max_score, min(score) as min_score from student; 分组聚合 - 单字段分组 分组聚合是一种对数据进行分类并对每个分类进行聚合计算的操作。它允许我们按照指定的列或字段对数据进行分组，然后对每个分组应用聚合函数，如 COUNT、SUM、AVG 等，以获得分组后的汇总结果。\n举个例子：某个学校可以按照班级将学生分组，并对每个班级进行统计。查看每个班级有多少学生、每个班级的平均成绩。这样我们就能够对学校各班的学生情况有一个整体的了解，而不是单纯看个别学生的信息。\n在 SQL 中，通常使用 GROUP BY 关键字对数据进行分组。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、class_id（班级编号）、score（成绩）。请你编写一个 SQL 查询，统计学生表中每个班级的平均成绩（avg_score）。\nselect class_id, avg(score) as avg_score from student group by class_id; 分组聚合 - 多字段分组 有时，单字段分组并不能满足我们的需求，比如想统计学校里每个班级每次考试的学生情况，这时就可以使用多字段分组。\n多字段分组和单字段分组的实现方式几乎一致，使用 GROUP BY 语法即可。\n假设有一个学生表 student，包含以下字段id（学号）、name（姓名）、class_id（班级编号）、exam_num（考试次数）、score（成绩）。请编写一个 SQL 查询，统计学生表中每个班级每次考试的总学生人数（total_num）。\nselect class_id, exam_num, count(*) as total_num from student group by class_id, exam_num 分组聚合 - having 子句 HAVING 子句用于在分组聚合后对分组进行过滤。它允许我们对分组后的结果进行条件筛选，只保留满足特定条件的分组。\nHAVING 子句与条件查询 WHERE 子句的区别在于，WHERE 子句用于在 分组之前 进行过滤，而 HAVING 子句用于在 分组之后 进行过滤。\n假设有一个学生表 student，包含以下字段：id（学号)、name（姓名）、class_id（班级编号)、score（成绩）。请编写一个 SQL 查询，统计学生表中班级的总成绩超过 150 分的班级编号（class_id）和总成绩（total_score），并将总成绩按从高到低排序。\nselect class_id, sum(score) as total_score from student group by class_id having total_score \u0026gt; 150 order by total_score desc 查询进阶 - 关联查询 cross join 关联查询是一种用于联合多个数据表中的数据的查询方式\nCROSS JOIN 是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 每一行 与右表的 每一行 进行组合，返回的结果是两个表的笛卡尔积。\n示例 假设有一个员工表 employees，包含以下字段：emp_id（员工编号）、emp_name（员工姓名）、department（所属部门）、salary（工资）。数据如下：\nemp_id emp_name department salary 1 小明 技术部 5000 2 鸡哥 财务部 6000 3 李华 销售部 4500 假设还有一个部门表 departments，包含以下字段：department（部门名称）、manager（部门经理）、location（所在地）。数据如下：\ndepartment manager location 技术部 张三 上海 财务部 李四 北京 销售部 王五 广州 使用 CROSS JOIN 进行关联查询，将员工表和部门表的所有行组合在一起，获取员工姓名、工资、部门名称和部门经理，示例 SQL 代码如下：\nSELECT e.emp_name, e.salary, e.department, d.manager FROM employees e CROSS JOIN departments d; 注意，在多表关联查询的 SQL 中，我们最好在选择字段时指定字段所属表的名称（比如 e.emp_name），还可以通过给表起别名（比如 employees e）来简化 SQL 语句。\n查询结果：\nemp_name salary department manager 小明 5000 技术部 张三 小明 5000 财务部 李四 小明 5000 销售部 王五 鸡哥 6000 技术部 张三 鸡哥 6000 财务部 李四 鸡哥 6000 销售部 王五 李华 4500 技术部 张三 李华 4500 财务部 李四 李华 4500 销售部 王五 假设有一个学生表 student ，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）；还有一个班级表 class ，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，将学生表和班级表的所有行组合在一起，并返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）以及班级名称（class_name）。\n\u0026#39;错误示范\u0026#39; -- select -- s.name as student_name, -- s.age as student_age, -- s.calss_id, -- c.name as class_name -- from student s -- cross join class c; select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name from student s join class c; inner join INNER JOIN 是一种常见的关联查询方式，它根据两个表之间的关联条件，将满足条件的行组合在一起。\nINNER JOIN 只返回两个表中满足关联条件的交集部分，即在两个表中都存在的匹配行。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）、level（班级级别）。\n请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level）。\nselect s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s join class c on s.class_id = c.id; outer join out join 是一种关联查询方式，它根据关联条件，将两个表中满足条件的行组合在一起，并包含没有匹配的行 。\n在 out join 中，包括 left out join 和 right out join 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。\n有些数据库并不支持 right join 语法，那么如何实现 right join 呢？ 其实只需要把主表（from 后面的表）和关联表（ left join 后面的表）顺序进行调换即可！\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）、level（班级级别）。\n请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level），要求必须返回所有学生的信息（即使对应的班级编号不存在）。\nselect s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s left join class c on s.class_id = c.id; 子查询 子查询是指在一个查询语句内部 嵌套 另一个完整的查询语句，内层查询被称为子查询。 子查询可以用于获取更复杂的查询结果或者用于过滤数据。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，使用子查询的方式来获取存在对应班级的学生的所有数据，返回学生姓名（name）、分数（score）、班级编号（class_id）字段。\nselect name, score, class_id from student where class_id in ( select distinct id from class ) 子查询 - exists 子查询中的一种特殊类型是 \u0026ldquo;exists\u0026rdquo; 子查询，用于检查主查询的结果集是否存在满足条件的记录，它返回布尔值（True 或 False），而不返回实际的数据。\n和 exists 相对的是 not exists，用于查找不满足存在条件的记录。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，使用 exists 子查询的方式来获取 不存在对应班级的 学生的所有数据，返回学生姓名（name）、年龄（age）、班级编号（class_id）字段。\nselect name, age, class_id from student where not exists ( select 1 from class where student.class_id = class.id ) 组合查询 组合查询是一种将多个 SELECT 查询结果合并在一起的查询操作。\n包括两种常见的组合查询操作：UNION 和 UNION ALL。\nUNION 操作：它用于将两个或多个查询的结果集合并， 并去除重复的行 。即如果两个查询的结果有相同的行，则只保留一行。 UNION ALL 操作：它也用于将两个或多个查询的结果集合并， 但不去除重复的行 。即如果两个查询的结果有相同的行，则全部保留。 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个新学生表 student_new，包含的字段和学生表完全一致。\n请编写一条 SQL 语句，获取所有学生表和新学生表的学生姓名（name）、年龄（age）、分数（score）、班级编号（class_id）字段，要求保留重复的学生记录。\nselect name, age, score, class_id from student union all select name, age, score, class_id from student_new 开窗函数 - sum over 开窗函数是一种强大的查询工具，它允许我们在查询中对分组数据进行计算、 同时保留原始行的详细信息 。\n开窗函数可以与聚合函数（如 SUM、AVG、COUNT 等）结合使用，但与普通聚合函数不同，开窗函数不会导致结果集的行数减少。\n打个比方，可以将开窗函数想象成一种 \u0026ldquo;透视镜\u0026rdquo;，它能够将我们聚焦在某个特定的分组，同时还能看到整体的全景。\n本节我们先讲第一个开窗函数：sum over。\n该函数用法为：\nsum(计算字段名) over (partition by 分组字段名) 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并计算每个班级的学生平均分（class_avg_score）。\nselect id, name, age, score, class_id, avg(score) over ( partition by class_id ) as class_avg_score from student 开窗函数 - sum over order by 学习 sum over 函数的另一种用法：sum over order by，可以实现同组内数据的 累加求和 。\n示例用法如下：\nsum(计算字段名) over (partition by 分组字段名 order by 排序字段 排序规则) 举一个应用场景：老师在每个班级里依次点名，每点到一个学生，老师都会记录当前已点到的学生们的分数总和。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数升序的方式累加计算每个班级的学生总分（class_sum_score）。\nselect id, name, age, score, class_id, sum(score) over ( partition by class_id order by score asc ) as class_sum_score from student 开窗函数 - rank Rank 开窗函数是 SQL 中一种用于对查询结果集中的行进行 排名 的开窗函数。它可以根据指定的列或表达式对结果集中的行进行排序，并为每一行分配一个排名。在排名过程中，相同的值将被赋予相同的排名，而不同的值将被赋予不同的排名。\n当存在并列（相同排序值）时，Rank 会跳过后续排名，并保留相同的排名。\n**Rank 开窗函数的常见用法是在查询结果中查找前几名（Top N）或排名最高的行。\nRank 开窗函数的语法如下：\nrank() over ( partition by 列名1, 列名2, ... -- 可选，用于指定分组列 order by 列名3 [asc|desc], 列名4 [asc|desc], ... -- 用于指定排序列及排序方式 ) as rank_column 其中，partition by 子句可选，用于指定分组列，将结果集按照指定列进行分组；order by 子句用于指定排序列及排序方式，决定了计算 rank 时的排序规则。as rank_column 用于指定生成的 Rank 排名列的别名。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式计算每个班级内的学生的分数排名（ranking）。\nselect id, name, age, score, class_id, rank() over ( partition by class_id order by score desc ) as ranking from student 开窗函数 - row_number Row_Number 开窗函数是 SQL 中的一种用于为查询结果集中的每一行 分配唯一连续排名 的开窗函数。\n它与之前讲到的 Rank 函数不同，Row_Number 函数为每一行都分配一个唯一的整数值，不管是否存在并列（相同排序值）的情况。每一行都有一个唯一的行号，从 1 开始连续递增。\nrow_number 开窗函数的语法如下（几乎和 rank 函数一模一样）：\nrow_number() over ( partition by column1, column2, ... -- 可选，用于指定分组列 order by column3 [asc|desc], column4 [asc|desc], ... -- 用于指定排序列及排序方式 ) as row_number_column 其中，PARTITION BY子句可选，用于指定分组列，将结果集按照指定列进行分组。ORDER BY 子句用于指定排序列及排序方式，决定了计算 Row_Number 时的排序规则。AS row_number_column 用于指定生成的行号列的别名。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式给每个班级内的学生分配一个编号（row_number）。\nselect id, name, age, score, class_id, ROW_NUMBER() over ( partition by class_id order by score desc ) as row_number from student 开窗函数 - lag / lead 开窗函数 Lag 和 Lead 的作用是获取在当前行之前或之后的行的值，这两个函数通常在需要比较相邻行数据或进行时间序列分析时非常有用。\n1）Lag 函数\nLag 函数用于获取 当前行之前 的某一列的值。它可以帮助我们查看上一行的数据。\nLag 函数的语法如下：\nlag(column_name, offset, default_value) over ( partition by partition_column order by sort_column ) 参数解释：\ncolumn_name：要获取值的列名。 offset：表示要向上偏移的行数。例如，offset为1表示获取上一行的值，offset为2表示获取上两行的值\u0026hellip; default_value：可选参数，用于指定当没有前一行时的默认值。 PARTITION BY和ORDER BY子句可选，用于分组和排序数据。 2）Lead 函数\nLead 函数用于获取 当前行之后 的某一列的值。它可以帮助我们查看下一行的数据。\nLead 函数的语法如下：\nlead(column_name, offset, default_value) over ( partition by partition_column order by sort_column) 参数解释：\ncolumn_name：要获取值的列名。 offset：表示要向下偏移的行数。例如，offset为1表示获取下一行的值，offset为2表示获取下两行的值\u0026hellip; default_value：可选参数，用于指定当没有后一行时的默认值。 PARTITION BY和ORDER BY子句可选，用于分组和排序数据。 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式获取每个班级内的学生的前一名学生姓名（prev_name）、后一名学生姓名（next_name）。\nselect id, name, age, score, class_id, lag(name, 1, null) over ( partition by class_id order by score desc ) as prev_name, lead(name, 1, null) over ( partition by class_id order by score desc ) as next_name from student 测验 冒险者和金币 假设有一家冒险者公会，他们有一张名为 rewards 的表格，用于记录每个冒险者在各个任务中获得的金币奖励情况。\n表格字段如下：\nadventurer_id：冒险者ID，唯一标识每个冒险者。 adventurer_name：冒险者姓名。 task_id：任务ID，唯一标识每个任务。 task_name：任务名称。 reward_coins：冒险者在该任务中获得的金币奖励数量。 请你编写一条 SQL 查询语句，依次输出每个冒险者的 id（adventurer_id）、冒险者姓名（adventurer_name）、获得的总金币奖励（total_reward_coins），并按照总金币奖励从高到低排序，其中只列出总金币奖励排名前 3 的冒险者。\nselect adventurer_id, adventurer_name, sum(reward_coins) as total_reward_coins from rewards group by adventurer_id,adventurer_name order by total_reward_coins desc limit 3; 魔法学院 假设有一家魔法学院，里面有许多学员在不同科目上进行学习和考试。请你设计一张名为magic_scores的表格，用于记录每位学员在不同科目中的考试成绩情况。表格字段如下：\nstudent_id：学员ID，唯一标识每位学员。 student_name：学员姓名。 subject_id：科目ID，唯一标识每个科目。 subject_name：科目名称。 score：学员在该科目的考试成绩。 请你编写一条 SQL 查询语句，依次输出每位学员的学院 ID（student_id）、学员姓名（student_name）、科目 ID（subject_id）、科目名称（subject_name）、学员在该科目的考试成绩（score）、该学员在每个科目中的成绩排名（score_rank），并将结果按照成绩从高到低进行排序。\nselect student_id, student_name, subject_id, subject_name, score, rank() over ( partition by subject_id order by score desc ) as score_rank from magic_scores 大浪淘鸡 在神秘的海岛上，有一只传说中的大浪淘鸡，它身躯高大威武，羽毛闪烁着神秘的光芒。岛上的居民都传说大浪淘鸡是海洋之神的化身，它能够操纵海浪，带来平静或狂暴的海洋。为了验证这个传说是否属实，岛上的居民决定对大浪淘鸡进行观测和记录。\n有一张 chicken_observation 的表格，用于记录居民观测大浪淘鸡的信息。表格字段如下：\nobservation_id：观测记录ID，唯一标识每条观测记录 observer_name：观测者姓名 observation_date：观测日期 observation_location：观测地点 wave_intensity：观测到的海浪强度，用整数表示，数值越大，海浪越狂暴 请你编写一条 SQL 查询语句，找出观测地点包含 \u0026ldquo;大浪淘鸡\u0026rdquo; 且海浪强度超过 5 的观测记录，并依次输出每位观测者的姓名（observer_name）、观测日期（observation_date）以及观测到的海浪强度（wave_intensity）。\nselect observer_name, observation_date, wave_intensity, observation_location from chicken_observation where (observation_location like \u0026#39;%大浪淘鸡%\u0026#39;) and (wave_intensity \u0026gt; 5) order by wave_intensity desc ","permalink":"https://bablvsj.github.io/posts/life/exams/sql%E4%B9%8B%E6%AF%8D/","summary":"SQL从入门到入门","title":"SQL之母"},{"content":" 让子弹飞（申遗！）\n阿甘正传（“我妈妈经常说，生活就像巧克力，你永远不知道下一颗是什么口味。”）\n初恋这件小事（这就是初恋的感觉）\n楚门的世界（“如果再不能见到你，祝你早安、午安、晚安”）\n当幸福来敲门（“不要让别人告诉你，你不能做什么！”）\n地道战（抗日人民的脑洞真的很大）\n闻香识女人（这部电影的台词真叫一个绝！）\n肖申克的救赎（经典不解释）\n放牛班的春天（天籁之音）\n蜘蛛侠 1 （没看过漫画，比较喜欢老版电影）\n机器人总动员（瓦力超会卖萌）\n怦然心动（两个人的视角来讲述一个青春故事）\n入殓师（没有令人不适的镜头，可以放心观看，治愈系）\n三傻大闹宝莱坞（人物冲突处理到极致）\n海上钢琴师（音乐很棒）\n那些年 我们一起追过的女孩\n千与千寻（就挺奇幻的）\n夺宝奇兵系列（看敌人在耍大刀，无奈一枪放倒）\n封神三部曲 （第一部 狐狸出世纣王无道天下大乱 第二部 纣王率军伐西岐 第三部 姬发联合各诸侯反攻）\n钢铁侠 1 （个人认为漫威系列最佳）\n国王的演讲（带英国挺过二战的国王是个口吃，超长待机女王是他的长女）\n哈利波特 1 、2 （让我对魔法世界最有新鲜感的两部，后面就有点暗黑了）\n好想告诉你（电影+动画）\n黑客帝国系列（见证了两个导演从兄弟变为姐弟在变为姐妹）\n横空出世（“你愿意隐姓埋名一辈子吗？”）\n虎胆龙威系列（英文名Die hard超级贴切 喜欢布鲁斯威利斯被两头坑的无奈表情）\n歌舞青春 1 （歌挺好听的）\n环太平洋（音乐起！）\n回到未来系列（被致敬无数次的科幻经典）\n机器管家（一个想成为人类的机器人的人生）\n疾速追杀系列（“A fuxxing pencil!”）\n罗马假日(男女主颜值超高)\n玫瑰人生（ Edith Piaf 传记，喜欢她的歌可以看一看）\n七磅（片名出自威尼斯商人，主角的还“债”历程，同时也是自我的救赎）\n情书（光良的童话 MV 里面两个人看的那个电影，治愈系）\n速度与激情 3 （可能我是个异类？）\n天使爱美丽（色彩、音乐都很棒，文艺片）\n天堂电影院（一段忘年之交）\n头文字 D （“永远不要有跟人斗的心，你要赢的是你自己。”）\n我，机器人（威尔史密斯主演动作电影的入坑作，其他像黑衣人之类的也很棒）\n我是传奇 1 （有点丧尸版鲁滨逊漂流记的感觉）\n无间道（港版经典）\n西西里的美丽传说（又硬又难受，人言可畏）\n逍遥法外（又叫猫鼠游戏，小李子和汤姆汉克斯版）\n小鬼当家系列（脑洞超大，超搞笑）\n窈窕奶爸（罗宾威廉姆斯演技、口技超一流）\n云图（一旦看懂了，就挺妙）\n战争之王（点子超多的军火商的传奇故事）\n终结者 2 （👍）\n最后的武士（挺悲壮的故事）\n宝莲灯（动画，个人认为已经逼近迪士尼水准了）\n暴力街区 Banlieue 13 （跑酷鼻祖大卫贝尔主演）\n变相怪杰（金凯瑞的脸简直就像橡皮泥）\n不能说的秘密（曲子都是精品）\n宫崎骏作品（我是有少女心？）：\n天空之城（入坑作，我一直感觉是映射侵华战争）\n龙猫（超可爱！）\n幽灵公主（又叫魔法少女，久石让作曲超美）\n魔女宅急便（我也想养一只黑猫）\n哈尔的移动城堡（全程注意力在菜头上）\n周星驰主演的经典无厘头，和猫和老鼠一样，可以电视轮播偶尔看一眼：\n喜剧之王\n唐伯虎点秋香\n百变星君\n大话西游系列\n功夫\n国产凌凌漆\n","permalink":"https://bablvsj.github.io/posts/life/20221216-%E4%BA%9B%E5%80%BC%E5%BE%97%E4%B8%80%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/","summary":"留出点时间，去看看电影。","title":"一些值得一看的电影"},{"content":"1、《百年孤独》 无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。\n2、《被讨厌的勇气》 我们终其一生就是要摆脱他人的期待，找到真正的自己；\n经历本身不会决定什么，我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活。。。\n3、《社会契约论》 人生而自由，却又时时处在枷锁之中。自认为主宰一切，反而更像是一切的奴隶；\n人们能够争取自由，却永远无法恢复自由。\n4、《论人类不平等的起源和基础》 教育不仅使受教育的人之间产生差异，而且也使那些受教育的人在文化成熟方面产生差异。要知道：当巨人与矮子同时行走在一条道路上时，他们每多走一步，巨人相对矮子的优势就越大。\n5、《那不勒斯四部曲》 我的整个生命，只是一场为了提升社会地位的低俗斗争；\n假如一个人想一直做庶民，那他的孩子、孙子，都会命若草芥，不值一提。\n6、《活出生命的意义》 人所拥有的任何东西，都可以被剥夺，唯独人性最后的自由，——也就是在任何境遇中选择一己态度和生活方式的自由——不能被剥夺。\n7、《财富自由》 财富不是你快乐的理由，学会从通往财富的旅途中收获幸福才是。等到哪一天，消费再也无法控制你，你成了生活的主人时，生活自此也就充满了喜悦。\n《伟大的博弈》 《宏观经济学原理》 《微观经济学原理》 《货币银行学》 《稳定不稳定经济》 《明斯基时刻》\n商：《低风险创业》 心：《空谷幽兰》 文：《你永远无法叫醒一个装睡的人》 ","permalink":"https://bablvsj.github.io/posts/life/thinks/20210501-%E4%B8%80%E4%BA%9B%E9%97%B2%E4%B9%A6/","summary":"待看闲书，进入收藏夹。","title":"一些闲书"},{"content":"web3职务要求\n熟悉 JavaScript ，ES6 熟悉 web3 框架，etherjs 或 web3js 熟悉前端相关框架，了解 nodejs 工作流 了解 DOM 以及现代浏览器各种技术 熟悉 webgl ，three.js 加分 手写 HTML ，熟悉 CSS 编写，有一定审美 主动学习能力 [任职要求] 大学相关专业本科或研究生毕业 两年以上互联网 /web3 行业一线工作经验 英文文档阅读能力 熟悉 Linux ，熟悉开源，熟悉 git ，github ，pull request 工作流 有分布式办公经验，有独立解决问题的能力 有开源作品加分 发送简历请附带 github 地址 ","permalink":"https://bablvsj.github.io/posts/temp/","summary":"web3职务要求 熟悉 JavaScript ，ES6 熟悉 web3 框架，etherjs 或 web3js 熟悉前端相关框架，了解 nodejs 工作流 了解 DOM 以及现代浏览器各种技术 熟悉 webgl ，three.j","title":"待学"},{"content":"个人说明 大家好，我是小布。是一名前端开发者，希望能做个很酷的东西，希望能一直酷下去！ Github: https://github.com/bablvsj/ E-mail: bandblvsj@163.com\n博客日志 2023-12-20: Markdown 样式优化 2023-07-25: 引用hugo主题 PaperMod。\n2022-12-15: 引用hugo主题 hugo-theme-Reader。\n2022-12-10: 博客使用hugo构建。\n致谢 网站开发有借鉴 子舒 Kevin 两位的网站\n版权声明：网站文章所有版权如无特殊说明，均归本人所有。允许转载，标明出处即可。\n","permalink":"https://bablvsj.github.io/about/","summary":"about","title":"关于"},{"content":"","permalink":"https://bablvsj.github.io/message/","summary":"","title":"留言"}]