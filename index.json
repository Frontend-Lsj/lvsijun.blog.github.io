[{"content":"第一章 Java概述 考点一 Java语言的特点 1.**语法简单，功能强大，安全可靠 强类型语言： 没有指针（ 与C、C++ 对比 ）、 没有多重继承机制( 可通过接口方式实现 )； 自动无用内存回收机制 纯面向对象语言\n在语言定义阶段、字节码检查阶段、程序执行阶段实行三级全检查机制。对参数类型匹配、对象访问权限、内存回收等都进行了严格的检查和控制，可以有效防止非法代码的侵入，阻止对内存的越权访问，能够避免病毒的侵害\n2.与平台无关：JVM Java（Java Virtual Machine）虚拟机是实现这一特点的关键，做了适配转换。\n3.解释编译两张运行方式： 解释字节码、即时编译功能（JIT，just-in-time 编译器，将字节码转换成本机的机器代码）\n4.多线程 1)类Thread 2) 同步机制 5.动态执行兼有丰富的API文档及类库 考点二 开发环境的搭建 JVM、JRE、JDK\nJDK 编译、运行等开发工具 JRE Java运行环境 Java 系统类库 JVM\n工具下载\n安装\n设置环境变量\n编译工具的测试\njavac 编译 java 解析类\njavaAPI库 https://docs.oracle.com/javase/8/docs/api/index.html\n面向对象技术\n1.面向过程\n众多函数名 2.面向对象\n程序结构简单，相互写作容易，程序的重用性大大提高 面向对象方法学：使分析、设计和实现一个系统的方法尽可能接近人们认识一个系统的方法。 面向对象的分析 （OOA Object-Oriented Analysis） 面向对象的设计 (OOD design) 面向对象的程序设计 ( OOP programming)\nJava 是一种“纯”面向对象语言，它的所有数据类型包括最基本的布尔型、数值型、字符型都有相应的类，程序完全可以基于对象编写\n类： 现实世界中存在很多同类的对象，它们来自于同一种原型，具有一样的共性。 对象： 类的某个特定实体就是实例或称对象\nOOP技术把问题看成是相互作用的事物的集合，也就是对象的集合。 对象具有两个特性，一是状态，而是行为。 状态是指对象本身的信息，行为是实现对对象的操作。在OOP中用属性来描述状态，而把对他的操作定义为方法。属性也称为数据，这样对象就是数据+方法。可以将现实生活中的对象经过抽象、映射为程序中的对象。\nOOP三大技术：\n封装：将对象的属性和实现细节隐藏起来，只给出如何使用的信息。将数据及对数据的操作捆绑在一起成为类，这就是封装。 继承：将一个已有类中的数据和方法保留，并加上自己特殊的数据和方法，构成一个新类。 父类（基类、超类） 多态：在一个类或多个类中，可以让多个方法使用同样一个名字，从而具有多态性。 第二章 数据和表达式 1.基本语法元素 标识符：由字母、数字、下划线( _ )、美元符$组成 数字不能为标识符的开头，区分大小写，长度不限制\nJava源码使用的是 unicode码（16bits），而不是ASCII码( 8 bits )\n类名或接口名： 每个单词的首字母大写，如 HelloWorld，Customer\n方法名： 首字母小写，其余单词首字母大写，如 getName，setAddress\n常量名：字母全部大写，单词间用下划线间隔。如 BLUE_COLOR\nif-else 所有语句都使用一对大括号括起来，即使只有一条语句。\n2.基本数据类型 基本数据类型：\n整数类型 byte，short，int，long 整数类型 整数长度 字节数 表示范围 byte 8位 1 -128 ~ 127 short 16位 2 $-2^15 —— 2^15-1$ int 32位 4 $-2^31 —— 2^31-1$ long 64位 8 $-2^63 —— 2^63-1$ 进制表示： 十进制：1~9开头，如123 八进制： 0开头，0~7 077 = 78 + 71 = 63（十进制） 十六进制： 0x开头，0~9，a~f(大小写均可) 0xBABE = 11 * 16^3 + 10 * 16^2 + 11 * 16^1 + 14 * 16^0 = 11 * 4096 + 10 * 256 + 11 * 16 + 14 = 47806 整形常量是int型，如果想表示长整型，则在数后面加个L、l\n浮点数类型 float，double float：单精度，32bits double：双精度，64bits 浮点数默认为double，除非有f\n字符类型 char ( 16bits ) 单个字符用char类型表示 常量用单引号括起来\n转义字符\n转义字符 含义 转义字符 含义 \\b 退格符 \\\\ 反斜杠\\ \\n 换行符 \\' 单引号' \\r 回车符 \\\u0026quot; 双引号\u0026quot; \\t 水平制表符（Tab） 布尔类型 boolean true / false Java是严格数据类型语言，不允许数值类型和布尔类型之间的转换，必须显式地进行变量类型的转换。 复合数据类型\n类类型 class 数组 接口 interface 3.表达式 操作数 + 运算符\n3.1 常量：简单数据类型和String类型\n1 2 3 4 5 23.59 //double常量 -1245.1f //float常量 true //boolean常量 \u0026#34;This is a String\u0026#34; //String常量 \u0026#39;a\u0026#39; //char常量 3.2 变量\n声明格式：类型 变量名 [ = 初值1]\n类类型变量也称为引用\n声明的位置 ： 方法内[ 局部变量、临时变量、栈变量] 类定义内[ 成员变量 ]\n空间分配时刻： 简单类型变量：声明后自动分配空间 引用：声明后只分配引用空间，new创建对象示例后才会分配空间 （堆空间）\n不允许将未经初始化的变量用作操作数\nJava是严格数据类型语言，不允许数值类型和布尔类型之间的转换，必须显式地进行变量类型的转换。\n每个数据都与特定的类型有关，运行整型、浮点型、字符型数据进行混合运算。运算时，不同类型的数据转换为同一种类型，后再进行运算。 转换的一般原则是位数少的类型转换为位数多的类型，这称作自动类型转换 自动类型转换的类型顺序为： byte -1 short -2 char -2 int -4 long -8 float -4 double -8\n3.3运算符\n算术运算符 + - * / % 取模允许对浮点数操作： 15.2 % 5 = 0.2 ； 10 % 3 = 1； 取模可用于负数，结果符合与第一个操作数相同：5 % -2 = 1； -5 % -3 = -2；\n位运算符：对二进制进行操作 7个位运算符： 按位取反 ~ 按位与 \u0026amp; 按位或 | 按位异或 ^\n右移 \u0026raquo; 左移 \u0026laquo; 无符号右移 \u0026raquo;\u0026gt; 只能对整型和字符型数据进行操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 27 \u0026amp; 4 =\u0026gt; 11011 00100 00000 = 0 128 + 32 + 2 128 \u0026gt;\u0026gt; 1 = 10 000 000 -\u0026gt; 01 000 000 = 64 256 \u0026gt;\u0026gt; 4 = 100 000 000 -\u0026gt; 10 000 = 16 -256 \u0026gt;\u0026gt;4 =-100 000 000 -\u0026gt; -10 000 = -16 0xa2 \u0026gt;\u0026gt;\u0026gt;2= 2 + 160 = 162 = 10 100 010 = 34 错误 10 100 010 右移两位 -\u0026gt; 10 100 0 = 40 (byte)0xa2 \u0026gt;\u0026gt; 2 = -24 (byte)0xa2 \u0026gt;\u0026gt;\u0026gt; 2 = 1073741800 (byte)0x80 \u0026gt;\u0026gt; 2 = -32 \u0026gt;\u0026gt;\u0026gt; 操作符只能用于整型，只对int或long值起作用。如果short或byte值，进行\u0026gt;\u0026gt;\u0026gt;操作前，使用符号扩展将其提升为int型，然后再移位。 其他运算符 实例运算符 instanceof\n1 2 3 obj instanceof Array obj instanceof Object obj instanceof String new 运算符 数组下标运算符 []\n第三章 流程控制语句 1. Java 程序的结构 一个Java程序可以由一个或多个.java文件组成，这些文件成为源文件。\n每个源文件中含有一个或多个类或接口，一个源文件如果有多个类，则最多只能有一个是public类，且该源文件的名字即为这个共有类的名字，且大小写也要一直。\n构成要素 package语句、import语句、具有public权限的类定义、其他类定义、接口定义。\n1.1 Java 包的概念\n包是类的容器，包的设计人员利用包来划分名字空间，以避免类名的冲突。 例如：java.util有类LinkedList，自己也可以定义LinkedList的类、包。 不指定，则是默认的无名包。 包语句的格式： package pag1[ .pkg2 [ .pkg3 \u0026hellip;]] 第一条必须是非注释语句 一个文件最多只能有一条package语句\n包的名字有层次关系，各层之间以点分隔。包层次关系必须与Java开发系统的文件系统结构相同，通常全部用小写字母。\n一个包可以包含若干个类文件或包。\n一个包要放在指定目录下，通常用CLASSPATH指定搜寻包的路径。\n类名就是文件名，包名就是文件夹名。反之，目录名不一定是包名。\n使用别人定义包的方法： 使用全名 import 引入指定类、引入全部类\n2. 流程控制 语句流 顺序流：循环语句 分支流：分支语句 循环流：循环语句\n赋值语句 表达式语句\n分支语句 : if语句；if(条件) 条件必须得到一个逻辑值 switch语句： 表达式中的结果必须是 int型（整型）或char型（字符型）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 switch (type){ case 1: System.out.println(\u0026#34;这是1类型\u0026#34;); break; case 2 ： System.out.println(\u0026#34;这是1类型\u0026#34;); break; default: break; } switch (month){ case 2: days = 28; break; case 4: case 6: case 9: case 11: days = 30; break; default: days = 31 break; } 循环语句： for语句：适合确切执行次数的情况\nwhile语句：执行次数不知道\n1 2 3 4 5 6 7 8 while(条件表达式) 循环体语句 int i = 0; while(i\u0026lt;3){ System.out.println(\u0026#39;输出3次\u0026#39;); i++; } do-while语句：最少执行一次\n1 2 3 4 5 6 7 8 9 10 格式 do 循环语句 while(条件表达式) int i = 0; do System.out.println(\u0026#39;输出4次\u0026#39;) i++; while(i\u0026lt;3) 跳转语句 break\n1. switch语句 2. for、while和do语句（break直接跳过本块中余下的所有语句） 3. 语句块： break 标号； 1 2 3 4 5 6 7 8 9 int x = 20; out: for(int i=2;i\u0026lt;10;i++){ System.out.println(\u0026#34;i=\u0026#34;+i) while(x\u0026lt;1000){ System.out.println(\u0026#34;i=\u0026#34;+i +\u0026#34;,x=\u0026#34; + x) if(i*x \u0026gt;=80 ) break out; else x+=5 } } continue：立即结束当前循环，开始执行下一次循环。 continue 标号；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 for(int i=0;i\u0026lt;5;i++){ if(i==2){ continue; } System.out.println(i); } // 0 1 3 4 for(int i=0;i\u0026lt;10;i++){ for(int j=0;j\u0026lt;10;j++) { if(j\u0026gt;i) continue; System.out.print(\u0026#34;*\u0026#34;); } System.out.println(); } 3. 简单的输入/输出 3.1 Scanner 类，可以方便读取不同类型的输入值，如键盘输入、从文件中输入等 使用方法：Scanner scan = new Scanner(System.in) next()：读入下一个对象，以字符串返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Scanner scan = new Scanner(System.in) while(true){ System.out.println(scan.next()) } /*示例代码-计算bmi*/ double weight,height,bmi; Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;请输入你的体重(kg)：\u0026#34;); weight = scanner.nextDouble(); System.out.print(\u0026#34;请输入你的身高(m):\u0026#34;); height = scanner.nextDouble(); bmi = weight / (height * height); System.out.println(\u0026#34;你的BMI为：\u0026#34; + bmi); //19.591836734693878 3.2 NumberFormat类和DecimalFormat类 NumberFormat类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /*NumberFormat类*/ double myNumber = 199998888.82; String myString = NumberFormat.getInstance().format(myNumber); System.out.println(\u0026#34;默认格式：\u0026#34;+myString); //默认格式：199,998,888.82 myString = NumberFormat.getCurrencyInstance().format(myNumber); System.out.println(\u0026#34;货币格式：\u0026#34;+myString); //货币格式：￥199,998,888.82 myString = NumberFormat.getNumberInstance().format(myNumber); System.out.println(\u0026#34;通用数值格式：\u0026#34;+myString); //通用数值格式：199,998,888.82 myString = NumberFormat.getPercentInstance().format(myNumber); System.out.println(\u0026#34;百分比格式：\u0026#34;+myString); //百分比格式：19,999,888,882% NumberFormat format = NumberFormat.getInstance(); format.setMaximumFractionDigits(4);//最长小数点位数 System.out.println(format.format(199998888.82277222)); //199,998,888.8228 System.out.println(format.getMaximumIntegerDigits()); //整型最大位数 2147483647 format.setMinimumFractionDigits(2);//最短小数点位数 System.out.println(format.format(199998888)); //199,998,888.00 format.setMaximumIntegerDigits(5); //设置最长位数 System.out.println(format.format(199998888)); // 98,888.00 /*DecimalFormat*/ DecimalFormat fmt = new DecimalFormat(\u0026#34;0.##\u0026#34;); System.out.println(\u0026#34;BMI:\u0026#34; + fmt.format(bmi) ); //19.591836734693878 =\u0026gt; 19.59 4. 处理异常 非致命：异常（Exception），修正后能继续运行； 如打开一个不存在的文件、除零溢出、数组越界。\n致命：错误（Error)，不能恢复。如内存耗尽。\n异常及其处理机制： Java提供异常处理机制，预定义了Exception类。在类中定义了程序产生异常的条件。 处理： 统一处理，提高效率，代码复用率高。 自己编写特殊的异常处理程序。 发现错误的代码可以抛出一个异常，程序可以去捕获该异常，如果可能则处理它，然后恢复程序运行。\n异常分类 受检异常：如选择一个错误的文件\n处理受检异常的两种方法 在方法内处理异常、告诉方法的调用者来处理 运行时异常：通常是程序中的逻辑错误的结果。如数组下标越界 错误：如内存异常，程序很难处理，所以一般不处理\n异常处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 执行过程 try { //抛出一个IOException异常 } catch(IOException e){ //处理代码 System.out.println(e.getMessage()); System.exit(0); } catch(FileNotFoundException e){...} catch(...){...} finally{ //必须执行的代码，除非前面调用了System.exit(); } 公共异常，Java预定义了一些常见的异常 ArithmeticException // 整数除法中，分母为0 NullPointerException // 对象没有实例化 NegativeArraySizeException // 例如：String[] arr = new String[-1] ArrayIndexOutOfBoundsException //数组下标越界 程序员处理异常的第二种方法：不在当前方法内处理异常，而是把异常抛出到调用方法中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 private static void errorTest() throws ArrayIndexOutOfBoundsException { int i = 0; String greetings[] = { \u0026#34;Hello world\u0026#34;, \u0026#34;Hello lvsj\u0026#34;, \u0026#34;Hello lnn\u0026#34; }; for(i=0;i\u0026lt;4;i++) { if(i\u0026gt;2) { throw new ArrayIndexOutOfBoundsException(); } System.out.println(i); } } public static void NextMain() { try { errorTest(); } catch (ArrayIndexOutOfBoundsException e) { // TODO: handle exception System.out.println(\u0026#34;ArrayIndexOutOfBoundsException\u0026#34;); } } 第四章 面向对象程序设计（重点） 1. 类和对象 类的定义 类包含两部分： 数据成员变量和成员方法\n1 2 3 4 5 6 7 8 9 格式： 修饰符 class 类名 [ extends 父类名]{ 修饰符 类型 成员变量1; 修饰符 类型 成员变量2; ... 修饰符 类型 成员方法1（参数列表）{ 方法体 } ... } 类定义中的修饰符是访问权限修饰符，包括public、private、protected，不写表示默认修饰符。\n类型 无修饰符 private protected public 同一类 是 是 是 是 同一包中的子类 是 否 是 是 同一包中的非子类 是 否 是 是 不同包中的子类 否 否 否 是 不同包中的非子类 否 否 否 是 public 都能访问 private 只有同一个类才能访问 protected 同一个包、同一个类才能访问\n类定义总结： - 源文件必须根据文件中的公有类名来定义，并且要区分大小写 - 类定义中可以指明父类，也可以不指名。Object类是Java所有类的直接或间接父类。 - class定义的大括号后没有分隔符“;”\n构造方法 每个类至少有一个构造方法，如果未定义，系统会自动为该类生成一个默认的构造方法。 默认构造方法的参数列表和方法体均为空。所生成对象的属性值也为空或0。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Xyz{ int x; public Xyz() {//构造方法 x = 0; System.out.println(\u0026#34;Xyz()\u0026#34;); } public void Xyz() { //成员方法 x = 0; System.out.println(\u0026#34;Xyz2()\u0026#34;); } public Xyz(int i) { x = i; System.out.println(\u0026#34;Xyz(i)\u0026#34;+ x); } } Xyz xyz = new Xyz(); // \u0026#34;Xyz()\u0026#34; xyz.Xyz(); // \u0026#34;Xyz2()\u0026#34; Xyz xyz3 = new Xyz(5); // \u0026#34;Xyz(i)5\u0026#34; 如需不传参，应再定义一个参数列表为空的构造方法。\n1 2 3 4 5 6 7 8 9 class Xyz{ int x; public Xyz(int i) { x = i; System.out.println(\u0026#34;Xyz(i)\u0026#34;+ x); } } Xyz test = new Xyz() //报错：The constructor Xyz() is undefined 默认构造方法\n1 2 3 4 5 6 7 8 9 10 DefaultMethods dmInfo = new DefaultMethods(); System.out.println(\u0026#34;name:\u0026#34;+dmInfo.name); // name:null System.out.println(\u0026#34;height:\u0026#34;+dmInfo.height); // height:0.0 System.out.println(\u0026#34;weight:\u0026#34;+dmInfo.weight); // weight:0 class DefaultMethods{ String name; float height; long weight; } 构造方法重载 this关键字指代本类中的其他构造方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Student { String name; int age; public Student(String s,int n){ name = s; age = n; } public Student(String s){ this(s,20) } public Student(){ this(\u0026#34;Unknown\u0026#34;) } } this还可以用来指明要操作的对象本身\n1 2 3 4 5 6 class Date{ private int day,month,year; public void printData(){ System.out.println(\u0026#34;Date:\u0026#34;+this.day + \u0026#34;/\u0026#34; +this.month + \u0026#34;/\u0026#34; + this.year) } } Java自动用this关键字把所有变量和方法引用结合在一起\n1 System.out.println(\u0026#34;Date:\u0026#34;+day + \u0026#34;/\u0026#34; +month + \u0026#34;/\u0026#34; + year) 对象的创建和初始化 **声明变量后，在内存中建立了一个引用，此时它不指向任何内存空间。需要使用new申请相应的内存空间，内存空间的大小依class的定义而定，并将该内存的首地址赋给建立的引用。\n创建对象实例格式： 变量名 = new 类名(参数列表); 类名 变量名 = new 类名(参数列表); 自动初始化（数值=0，布尔=false，引用=null）\n引用变量的赋值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 String s = \u0026#34;Hello\u0026#34;; String t = s; System.out.print(s) // \u0026#34;Hello\u0026#34; System.out.print(t) // \u0026#34;Hello\u0026#34; s = \u0026#34;world\u0026#34;; System.out.print(s) // \u0026#34;world\u0026#34; System.out.print(t) // \u0026#34;Hello\u0026#34; StringBuffer sn1 = new StringBuffer(s); \u0026#39;String 一般只读，StringBuffer 可修改的。\u0026#39; StringBuffer sn2 = sn1; System.out.println(sn1); // \u0026#34;Hello\u0026#34; System.out.println(sn2); // \u0026#34;Hello\u0026#34; sn1.setCharAt(0,\u0026#39;w\u0026#39;); \u0026#39;setCharAt 修改指向第0个字符为w\u0026#39; System.out.print(sn1) // \u0026#34;wello\u0026#34; System.out.print(sn2) // \u0026#34;wello\u0026#34; 2. 定义方法 方法的定义 private的成员变量，在类外不能通过点操作符直接访问，必须通过成员方法才能访问。成员变量应尽量声明为private，同时提供一组相关的访问方法供其他类使用。\n格式： 修饰符 返回类型 方法名(参数列表）块 返回类型是方法返回值的类型，如果不返回任何值，则应声明为void。 参数列表的各元素以逗号隔开，每个元素由一个类型和标识符组成\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Date{ private int day,month,year; void test() { System.out.println(\u0026#34;test\u0026#34;); } Date(){ day = 1; month = 1; year = 1998; } Date(int i,int j, int k){ day = k; month = j; year = i; } Date(Date d){ day = d.day; month = d.month; year = d.year; } public String printDate() { return year +\u0026#34;/\u0026#34; + month +\u0026#34;/\u0026#34; + day ; } public Date tomorrow() { Date date = new Date(this); date.day++; if(date.day \u0026gt; date.daysInMonth()) { date.day=1; date.month++; if(date.month\u0026gt;12) { date.month = 1; date.year ++; } } return date;\t} public int daysInMonth() { if(month\u0026lt;=0||month\u0026gt;=13) return -1; switch (month) { case 1:case 3:case 5:case 7:case 8:case 10:case 12: return 31; case 4:case 6:case 9:case 11: return 30; default: if((year%4==0 \u0026amp;\u0026amp; year %100!=0)||(year%400==0)){ return 29; }else { return 28; } } } } Date d1 = new Date(); Date d2 = new Date(2020,01,01); Date d3 = new Date(d2); System.out.println(d1.printDate()); // 1998/1/1 System.out.println(d2.printDate()); // 2020/1/1 System.out.println(d3.printDate()); // 2020/1/1 System.out.println(d3.tomorrow()); // Date@7852e922 System.out.println(d3.tomorrow().printDate()); // 2020/1/2 按值传递 实参：传给方法的值 形参：方法的参数列表中列出的值\n重载方法名：允许多个方法使用同一个方法名 规则：方法的参数列表必须不完全相同。 方法签名：方法名+方法的参数列表（参数的个数、顺序、类型） 方法重载时，方法签名一定不能相同。\n两条规则： - 调用语句的实参类别必须足够判断要调用的是哪个方法。 - 方法的返回类型可以相同也可以不同。2个方法名仅有返回参数不同，而参数列表完全相同，这是不够的。\n3. 静态成员：类中用static修饰的成员 内存分配时刻： - 非静态成员：实例化对象时 - 静态对象：类定义时，此时尚未创建对象\n用处：多个实例对象所共享，多个对象之间的通信；统计对象创建个数。\n静态变量从某种意义上类似于全局变量。\n如需在未创建一个对象实例时引用方法的程序代码，那么标记上关键字static即可实现\n1 2 3 4 5 6 7 8 class GeneralFunction{ public static int addUp(int x,int y) { return x + y ; } } int c = GeneralFunction.addUp(10, 11); System.out.println(\u0026#34;直接调用类方法addUp：\u0026#34; + c); // 直接调用类方法addUp：21 静态方法不存在this值，因此静态方法只能使用其内部的参数或静态变量，如果想使用非静态变量将引起编译错误。\n1 2 3 4 5 6 public class HelloWorld{ int x; public static void main(String[] args){ x = 9; // 报错： Cannot make a static reference to the non-static field x } } 静态方法不能被重写。\n4. 包装类 包装类的作用：编码过程中只接收对象的情况，不能传入基本数据类型，但可以传入对于的包装类，方便类型之间的转换，比如String和int直接的转换可以通过 int 的包装类 Integer 来实现。\n包装类是一种特殊的基本类型。 例如Integer类表示一个普通的整型量。 由Integer类创建的对象只保存一个int型的值。 包装类的构造方法接受一个基本类型的值，并保存它。\n例如:：Integer ageObj = new Integer (40);\n基本数据类型的包装类\n基本数据类型 包装类 基本数据类型 包装类 byte Byte double Double short Short boolean Boolean long Long float Float int Integer char Character void Void Void 不能被实例化，只表示void引用的概念。 byte \\ double \\ float \\ int \\ long + Value() 获取原来的基本数据类型的值\n1 byteValue()、doubleValue... parseInt // 字符串转换为整型数 toBinaryString // 整型数转换为字符串 toHexString toOctalString\n1 2 3 4 5 6 7 8 9 int i = 3; Integer integer = i; System.out.println(integer); // 3 System.out.println(integer.intValue()); // 3 String s = \u0026#34;12\u0026#34;; i = Integer.parseInt(s); System.out.println(\u0026#34;i=\u0026#34;+ i); // i=12 System.out.println(integer.toString(i)); // 字符串 12 包装类中常常含有常量：MAX_VALUE，MIN_VALUE\n自动装箱（Autoboxing）: 基本数据类型 -\u0026gt; 包装类，由小 -\u0026gt; 大\n1 2 3 Integer obj1; int num1 = 69; obj1 = num1; 自动拆箱：逆向的转换，由大 -\u0026gt; 小。 一般来说，基本数据类型与对象之间的赋值是不相容的。自动装箱和自动拆箱仅能用在基本数据类型与对应的包装类之间，其他情况会导致编译错误。\n第五章 数组与字符串 1.数组 定义格式： 类型 数组名[ ]; / 类型[ ] 数组名； char s[]; char[] s; int intArray[]; Date dateArray[];\n创建数组，数组经过初始化后才能使用。\n静态初始化： 声明数组的同时给数组元素赋初值。使用一对大括号将初值括起来，每个元素对应一个基本数据类型变量或对象引用。 int intArray[] = {1,2,3,4}; String names[] = {\u0026ldquo;Jen\u0026rdquo;,\u0026ldquo;Tom\u0026rdquo;}; 动态初始化：使用运算符 new 为数组分配空间。 String names[]; names = new String[4]; names[0] = \u0026ldquo;Jen\u0026rdquo;; 基本数据类型数组创建： 类型 数组名[ ] = new 类型[数组大小]; 类型[ ] 数组名 = new 类型[数组大小]； char s[] = new char[20] / char[] s = new char[20]\n类类型的数组，需要分两步： 第一步：创建数组本身 类型 数组名[ ] = new 类型[数组大小]; 第二步：分别创建各个数组元素 数组名[0] = new 类型（初值表） \u0026hellip; 数组名[数组长度-1] = new 类型（初值表); class Point{\u0026hellip;} Point points[]; points = new Points[100]; Point[0] = new Point();\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Calculate{ static int average(int[] arr) { int sum = 0; for(int i=0;i\u0026lt;arr.length;i++) { sum += arr[i]; } return sum / arr.length; } static int maxNum(int[] arr) { int sum = Integer.MIN_VALUE; for(int i=0;i\u0026lt;arr.length;i++) { if(arr[i]\u0026gt;sum) { sum = arr[i]; } } return sum ; } } 求最大值和平均值 int iArray[] = {1,23,4,5,6,7,8,9,110,10}; System.out.print(\u0026#34;avg:\u0026#34; + Calculate.average(iArray)); System.out.print(\u0026#34;maxNum:\u0026#34; + Calculate.maxNum(iArray)); 多维数组 如 int [] [] []; 定义格式如下： 1 2 3 类型 数组名[][] ; 类型[][] 数组名 ; 类型[] 数组名[]; 静态初始化：定义数组时为数组元素赋值。 int intArray[][] = [{2,3},{1,4},{3,5}]\n动态初始化： 直接分配：直接为每一维分配空间 类型 数组名[][] = new 类型[第一维大小][第二维大小]； 例子：int intArray[][] = new int[2][3]; // 2行3列 按维分配：从最高维起（而且必须从最高维开始），分别为每一维分配类型，创建二维数组的一般格式： 类型 数组名[][] = new 类型[第一维大小]； 数组名[0] = new 类型[第二维大小]； int twoDim[][] = new int[4][]; twoDim[0] = new int[5]; twoDim[1] = new int[5]; twoDim[2] = new int[5]; twoDim[3] = new int[5];\n多维数组的初始化：按维分配 String s[][] = new String[2][]; /分配二维 s[0] = new String[3]; /3个引用 s[1] = new String[3];\ns[0][0] = new String(\u0026quot;Good\u0026quot;); s[0][1] = new String(\u0026quot;Luck\u0026quot;); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 多维数组的引用： 数组的长度是固定的，初始化后，数组的大小不会再动态变化。 数组变量是一个指向数组对象实例的引用。 数组创建后就不能改变它的大小，但可以使用同一个引用变量指向另一个全新的数组，例如： int elements[] = new int [6]; elements = new int[10]; 第一个数组被丢失了，除非还有其他引用指向它。 ```js java.util.Arrays 中为数组提供了一系列静态方法 equals(type[],type[]):判断2个数组的值是否相同 sort(type[]):按照升序排序 fill(type[],type value): 将value赋给数组的每个元素 binarySearch(type[],type value):采用二分查找法在type类型的数组中查找type类型的值value. arraycopy(copy数据，下标，被copy数据，下标，copy长度) 复制数据 2.字符串 字符串是由有限个字符串组成的序列，字符串是一个对象，而不是一个以“\\0”结尾的字符数组。 java.lang中封装了String类和StringBuffer类，可以\nString类：处理不变字符串 StringBuffer类：处理可变字符串\n字符串是内存中连续排列的0个或多个字符。不变字符串是指字符串一旦创建，其内容就不能改变。 字符串：常量，变量。 常量：用双引号括起来的一串字符。系统自动为字符串常量创建一个String对象。System.out.println(\u0026ldquo;This is a String!\u0026rdquo;);\n变量：使用之前要显式声明，并进行初始化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 声明两个字符串： String s1; StringBuffer ss1; 创建空的字符串： String s1 = new String(); StringBuffer strb1 = new StringBuffer(); 由字符数创建字符串： char chars[] = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;}; String s2 = new String(chars); 用字符串常量初始化字符串： String s3 = \u0026#34;Hello world\u0026#34;; StringBuffer对象不能用字符串常量创建： StringBuffer strerr = \u0026#34;This\u0026#34; //Type mismatch: cannot convert from String to StringBuffer 可以用String对象来创建StringBuffer对象： String s4 = \u0026#34;Hello\u0026#34;; StringBUffer sb4 = new StringBuffer(s4) String对象时不可改变，创建后对字符串施加操作并不改变字符串本身，而是生成另一个实例。\nStringBuffer类处理对象可变字符串，当修改一个StringBuffer类的字符串时，不是再创建一个新的字符串对象，而是直接操作原字符串。\n共有常用方法：\nlength()：返回字符串长度 charAt(int index) :返回指定下标位置的字符 subString( int beginINdex)：截取当前字符串中从beginIndex 开始到末尾的子串。 String类中常用方法:\nreplace( char oldChar, char newChar)：替换，将当前字符串中oldChar替换为newChar toUpperCase()：当前字符串全转换为大写 toLowerCase()：当前字符串全转换为小写 concat(String str)：将str连接在当前字符串尾部 startsWith(String prefix)：测试prefix是否为当前字符串的前缀 trim()：去除字符串前面及后面的空白 valueOf(type value)：将type类型的参数value转换为字符串形式。 基本数据类型 -\u0026gt; 字符串 int i = 10; String str = String.valueOf(i); 字符串 -\u0026gt; 基本数据类型 Integer.parseInt(String s)：将s转换为 int String类型字符串的连接还可以通过 + 运算符来实现\nStringBuffer类中常用方法:\nappend( String str)：将str连接在当前字符串尾部 repalce( int start, int end, String str)：用str替换 start到end之间的子串 capacity()：返回当前的容量:字符串长度 +缓冲区大小 系统为String类对象分配内存时，是按照对象中所含字符串的实际个数等量分配。 StringBuffer类对象分配内存时，除去字符串所占空间外，再额外加16个字符大小的缓冲区。\nlength()：返回字符串长度 capacity()：返回当前的容量:字符串长度 +缓冲区大小 String类中有多个比较方法：compareTo(),equals(),equalsIgnoreCase(),regionMatches() Java中可以用 \u0026ldquo;= =\u0026rdquo; 判断两个字符串对象是否是同一个实例，即它们在内存中的存储空间是否相同。\n3.Vector类 Vector 是java.util包提供的一个非常重要的工具类，它类似于数组，可以使用整数下标访问各个元素，但功能更强大。\n变长数组。创建Vector对象后，如果增加或删除其中的元素，Vector的大小相应的变大或变小。 保存的元素类型可以不一样。 什么时候选用Vector类：\n处理数目不定、类型不同的对象组成的对象序列。 需要频繁在对象序列中进行插入、删除、查找操作时。 Vector类的实例中只能保存对象类型，不能是基本数据类型。 Vector类包含的成员变量有3个： protected int capacityIncrement：增量大小。如果值为0，则缓冲区的大小每次倍增。 protected int elementCount：元素的数量。 protected Object elementData[]：元素存储的数组缓存区。 系统内部会记录Vector类实例的容量capacity\n构造方法\n构造空的向量Vector: 1 2 3 public Vector(); public Vector(int initialCapacity); public Vector(int initialCapacity,int capacityIncrement); 创建Vector的实例时，要指明其中保存的元素的类型，例如: 1 2 Vector\u0026lt;String\u0026gt; myVector = new Vector\u0026lt;String\u0026gt;(100,50); 添加方法 1 2 3 addElement(Object obj)：添加到尾部。 insertElementAt(Object obj,int index)：插入到index位置，其他往后移。 add(int index,Object obj)：插入到index位置，其他往后移。 元素的修改与删除方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 修改： setElementAt(Object obj,int index); 删除： removeElement(Object obj);删除第一个obj,后面往前移，返回布尔值表示删除是否成功。 removeElementAt(int index); 删除指定下标元素 removeAllElements(); 删除所有元素 Vector\u0026lt;String\u0026gt; myVector = new Vector\u0026lt;String\u0026gt;(); for(int i =0;i\u0026lt;5;i++) { myVector.addElement(\u0026#34;Hello\u0026#34; + i); } printVector(myVector); myVector.remove(1); printVector(myVector); myVector.remove(\u0026#34;Hello4\u0026#34;); printVector(myVector); public static void printVector(Vector obj) { for(int i =0;i\u0026lt;obj.size();i++) { System.out.print(obj.elementAt(i) + \u0026#34; \u0026#34;); } System.out.println(); } 第六章 继承与多态 1.子类 has a 使用继承这一面向对象的特征，可以支持软件的可复用性，保证了代码可以在类之间共享。\nis a : 一般与特殊的关系 has a : 整体与部分的关系\nextends 关键字 与一般的面向对象语言一样，java提供了 派生 机制，允许程序员用以前已定义的类来定义一个新类。新类称作子类，原来的类称为父类，也称为基类或超类。 两个类中共同的内容放到父类中，特殊的内容放到子类中。 用 extends 表示派生，格式如下： 1 2 3 4 修饰类 class 子类名 extends 父类名{ 类体... } public class A extends B // A是子类，B是父类 如果一个类中没有出现extends关键字，则表明这个类派生于Object类，java中预定义及程序员自己定义的任何类都直接或间接派生于Object类，Object类是所有类的父类或祖先类。\n派生机制改善了程序的可维护性，增加了可靠性。对父类Employee的修改延伸到子类Manager中。\nObject类 Object类是Java程序中所有类的直接或间接父类，处于类层次的最高点。\npublic final Class getClass()：获取当前所属的类信息，返回Class对象。 public String toString()：按字符串对象返回当前对象本身的有关信息。 public boolean equals(Object object)：比较两个对象是否为同一对象，是则返回true。 对象相等的判别，另一种方式： == 运算符\n要判断两个对象各个属性域的值是否相同，不能使用从Object类继承来的equals方法，而需要在类声明中对equals方法进行覆盖，即重新修改这个方法。\n单向继承 单重继承：如果一个类有父类，则其父类只能有一个，也就是只允许从一个类中扩展类。\nJava是完全的面向对象语言，具有完全的OOP能力。在类的机制中，它抛弃了多重继承功能，仅实现了单重继承机制。\n一个类可以从其所有的祖先类中继承属性及行为。但不能继承构成方法。 只有两种方式能让一个类得到构造方法，一种方式是自己编写构造方法；另一种方式是，在用户没有编写构造方法时，由系统为类提供唯一一个默认的构造方法。\n类不能直接访问其父类中定义的私有属性及方法，但可以使用父类中定义的公有（及保护）方法访问私有数据成员。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class B{ public int a =10; private int b = 20; protected int c = 30; public int getB(){ return b; } } class A extends B { public int d; public void tryVariables(){ System.out.println(a); // 10 System.out.println(b); // The field B.b is not visible System.out.println(getB()); // 20 System.out.println(c) //30 } } A a = new A() a.tyyVariables(); 多重继承是指从多个类共同派生一个子类，即一个类可以有多个子类。 如果子类的多个父类中有同名的方法和属性，那么容易造成子类实例的混乱，这是多重继承不可客服的缺点。多重继承可通过 接口 interface 来实现。\n##### 对象转型 和大多数面向对象语言一样，Java允许使用对象的父类类型的一个变量指向该对象，比如\n1 Employee e = new Manager(); // 子类Manager的实例赋给父类变量e 对象引用的赋值兼容原则允许把子类的实例赋给父类的引用。\n反过来是错误的，不能把父类的实例赋给子类的引用，如\n1 Manager m = new Employee() // 错误 通过 instanceof 运算符来判断一个引用到底指向哪个实例。\n1 2 3 4 5 6 7 8 9 public void method(Employee e){ if(e instanceof Manager){ ... }else if(e instanceof Contractor){ ...\t}else { ... } } 使用intanceof判定父类的引用是否指向子类实例，可以进行转换，恢复对象的全部功能。\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args){ Employee betty = new Manager(); betty.name = \u0026#34;Betty\u0026#34;; System.out.println(betty.getName()); betty.employeeNumber = 2l3323; // betty.department = \u0026#39;test\u0026#39;; //错误 if(betty instanceof Manager){ Manger m = (Manager)betty; //将Employeele类型的betty转型为 Manager类型 m.department = \u0026#34;Test\u0026#34;； // 允许 System.out.println(\u0026#34;This is the manager of\u0026#34; + m.department); } } 对象引用转型规则\n沿类层次向\u0026quot;上\u0026quot;转型总是合法的，例如，把Manager引用转型为 Employee引用，只需赋值语句即可完成。 1 Employee e = new Manager(); 对于向 “下” 转型，只能是祖先类转型到后代类，其他类之间是不允许的。例如，把Manager 引用转型为Contractor引用是非法的，因为 Contractor 不是 Manager。这两个类没有继承关系，要替换的类（赋值号右侧）必须是当前引用类型（赋值号左侧）的父类，且要使用显式转换。 2.方法覆盖与多态 方法覆盖 方法覆盖：修改父类中已有的方法，也称为方法重写或隐藏\n子类中定义的方法名字、返回类型及参数列表和父类中方法使用的是完全一样的，即具有相同的方法签名，但可以执行不同的功能。要注意，子类方法不能比父类方法的访问权限更严格。\n子类方法覆盖了父类的方法，从逻辑上看是子类的成员方法覆盖父类中的同名方法。\n覆盖父类方法之后，在子类中想使用父类方法，可使用super关键字。\n使用 super.methods()调用父类methods方法，将执行该方法中所有操作，可能会出现一些原本不希望进行的操作，所以需谨慎操作 super.methods 语句不一定是在父类中加以描述的，也可能是父类方法从祖先类中继承而来。可以需要按继承层次关系往上查询才能找到。 **应用覆盖时必须注意以下两条重要原则\n覆盖方法的允许访问范围不能小于原方法。 覆盖方法所抛出的异常不能比原方法更多。 以上两条规则均源于多态性和Java所具有的“类型安全性”的要求。 **与方法重载的区别\n方法名相同，而参数列表不同，是对方法的重载，调用重载方法，编译器会根据参数个数、类型的不同来选择对应的方法执行。\n重载的方法属于同一个类，覆盖的方法分属于父类、子类中。\n调用父类的构造方法 子类不能继承父类构造方法，子类调用父类的构造方法可使用super关键字。\n子类构造方法的定义中没有明确调用父类的构造方法，系统在执行子类的构造方法时会自动调用父类的默认构造方法（无参数的构造方法）。\n如果在子类构造方法的定义中调用父类的构造方法，则语句必须出现在子类构造方法的开头位置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Employee{ String name; public Employee(String s) { // 构造方法 name = s; } } class Manager extends Employee{ String department; public Manager(String s,String d){ super(s); // 构造方法 department = d; //调用父类的构造方法第一行 } } 多态 多态：允许同一条方法调用指令在不同的上下文中做不同的事情。\n重载一个方法名可以看作是多态的， 父子类之间直接或间接重写的方法，要由对象运行时确定将调用哪个方法，这也是多态。\n要执行的是与对象真正类型（运行时）相关的方法，而不是与引用类型（编译时）相关的方法\nEmployee e = new Manager();\n静态类型（引用类型）：变量在声明时的类型，变量e的静态类型是 Employee。 动态类型：运行过程中某一时刻变量指向的对象类型，这是此刻的真正类型，动态类型会随着运行进制而改变。此例中动态类型为 Manager。 动态绑定：调用稍后可能被覆盖的方法。动态绑定一定要到运行时才能确定要执行的方法。 静态绑定/前绑定：在编译过程中能确定调用方法的处理方式。 3.终极类与抽象类 final 终极类 final 终极 ： final修饰的类或类的成员都是不能改变的。\n如果一个类被定义为final，则不能有子类 如果一个类被定义为final , 则不能被修改 如果一个变量被定义为final，则它的值不能被修改 final 用处： - 一些类不能被继承。如 Java.lang.String - 某个类的结构和功能已经很完整，不需要生成其他的子类\n声明格式\n1 2 3 final class 终极类名{ 类体 } final 方法 fanal 方法不能被覆盖，从而可以确保被调用的方法是最原始的方法。\n1 2 3 final 返回值类型 终极方法名（[参数列表]）{ 方法体 } 终极变量 终极变量是一个常量，不能被修改。 将一个引用类型的变量标记为final，那该变量将不再指向其他对象，但所指对象中的属性值是可变的。\n1 2 3 4 5 6 7 8 9 10 class Car{ int number = 1234; } class FinalVariable{ public static void main(String args[]){ final Car mycar = new Car(); maycar.number = 666; // 可以，修改的是myCar 指向的内存的值 mycar = new Car(); // 错误，不能修改mycar本身的值 } } 抽象类 只可用于类或方法，表示抽象。使用 abstract 修饰的方法的方法体为空，修饰的类必须北子类继承。\n定义了方法但没有具体实现的类称为抽象类。 每一个未被定义具体实现的方法也应标记为 abstract，称为抽象方法。 不能用抽象类作为模板来创建对象，必须生成抽象类的一个非抽象的子类后才能创建实例。 一个抽象类可以包含非抽象方法和成员变量。包含抽象方法的类一定是抽象类，但抽象类中的方法不一定都是抽象方法。 如果一个类中全是抽象方法，则使用接口更合适。 抽象类不能创建对象，但可以定义抽象类的引用变量。 抽象类的定义格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public abstract class 抽象类名{ 类体 // 抽象类 } abstract class Employee{ int basic = 2000; abstract void Salary(); // 抽象方法 } class Manager extends Employee{ void Salary(){ // 子类中的实现 System.out.println(\u0026#34;薪资等于\u0026#34; + basic) } } class Worker extends Employee{ void Salary(){ // 子类实现 System.out.println(\u0026#34;薪资等于\u0026#34; + basic * 2) } } 抽象方法：\n1 public abstract 返回值类型 抽象方法名（[参数列表]） 4.接口 接口的定义 接口是体现抽象类功能的另一种方式，可将其想象成一个“纯”的抽象类，方法名、参数列表以及返回值类型，但不规定方法体。因此接口中所有方法都是抽象方法，都没有方法体。\n接口可以实现不同于抽象类的功能，Java不支持多重继承的功能，一个类只能从唯一的一个类继承而来。\nJava运行一个类实现多个接口，从而实现了多重继承的能力。\n接口定义格式：\n1 2 3 [接口修饰符] interface 接口名[ extends 父接口列表]{ ... // 方法原型或静态常量 } 接口与一般类一样，本身也具有数据成员变量与方法。\n数据成员：隐式使用且必须是 public static final，变量一定要赋初始值，且此值不能在更改。 方法： 隐式使用 public abstract，必须是“抽象方法”。 1 2 3 4 interface CharStorage{ // 使用 interface void put(char c); // 抽象方法 char get() // 抽象方法 } 接口的实现 要实现接口，可以在类的声明中用关键字 implements 来表示。接口中的所有抽象方法必须在类或子类中实现。implements 语句格式如下：\n1 2 3 class 类名 implements 接口名[接口名，[接口名]]{ ... } 实现接口的类不能从接口的定义中继承任何行为。在实现该接口的类的任何对象中，都能够调用这个接口中定义的方法。一个类可以同时实现多个接口。\n1 2 3 4 5 6 7 8 9 10 11 12 class Stack implements CharStorage{ private char mem[] = new char[10]; private int point = 0; public void put(char c){ mem[point] = c; point++; } public char get(){ point--; return mem[point]; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 interface Insurable{ // 定义接口 public int getPolicyNumber(); // 抽象方法 public int getCoverageAmount(9); public double calculatePremium(); public Date getExpiryDate(); } public class Car implements Insurable{ // 接口的实现 public int getPolicyNumber(){} public double calculatePremium(){} public Date getExpiryDate(){} public int getCoverageAmount(){} } implements后面可声明多个接口，意味着多重继承的能力。 即使不同的接口中有同名的方法，类的实例也不会混淆，因为接口中的方法都是抽象方法，并不包含任何的具体代码，这些方法的实现都是在具体的类中完成。 在实现时，类一定要实现这两个接口中的所有方法，否则必须用abstract继续声明为一个抽象类。 实例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 interface Shape2D{ // 定义接口 final double pi = 3.14; // 数据成员一定要初始化 public abstract double area(); // 抽象方法 } class Circle implements Shape2D{ double radius; public Circle(double r) { // 构造方法 radius = r; } public double area() { return pi * radius * radius ; } } class Rectangle implements Shape2D{ int width,height; public Rectangle(int w,int h) { // 构造方法 width = w; height = h; } public double area() { return width * height; } } Rectangle rect = new Rectangle(10, 6); System.out.println(\u0026#34;矩形面积：\u0026#34; + rect.area()); Circle circle = new Circle(2); System.out.println(\u0026#34;圆的面积：\u0026#34; + circle.area()); 接口定义中，运行省略数据成员的 final 关键字、方法的 public 及 abstract 关键字。\n1 2 3 4 interface Shape2D{ double pi = 3.14; double area(); } 不能由接口来创建对象，而必须由实现接口的类来实现。 可以声明接口类型的变量，并用它来访问对象。 使用时将根据动态绑定原则，视该对象所指向的具体实例来操作。\n1 2 3 4 5 6 7 8 9 10 public class VariableTester{ public static void main(String[] args){ Shape2D var1,var2; // 接口类型的变量,定义两个对象引用。 var1 = new Rectangle(10, 6); System.out.println(\u0026#34;矩形面积：\u0026#34; + var1.area()); var2 = new Circle(2); System.out.println(\u0026#34;圆的面积：\u0026#34; + var2.area()); } } 第七章 输入和输出流 1.数据流的基本概念 流（Stream）：不同类型的输入、输出流抽象为流 输入/ 输出的数据称为数据流（Data Stream）\n数据流： 是指一组有顺序、有起点和终点的字节集合。\n分为输入数据流和输出数据流，输入数据流只能读不能写，输出数据流只能写不能读。 从数据流中读取数据时，必须有一个数据源与该数据流相连。 java.io 包中提供了表示数据流的4个基本抽象类，包括 InputStream、OutputStream、Reader 和 Writer。\n涉及到数据流操作的程序中，要使用引入语句：\n1 import java.io.* 输入数据流 是指只能读不能写的数据流，用于向计算机内输入数据使用\njava.io包中所有输入数据流都是从抽象类 InputStream 继承而来，包括读取数据、标记位置、重置读写指针、获取数据量等。 操作方法： 1 2 3 4 5 6 7 8 int read(): 从输入流中读取一个字节的二进制数据。 int read(byte[] b): 将多个字节读取到数组中，填满整个数组。 int read(byte[]b,int of,int len): 从输入流中读取长度为len的数据，从数组b中下标为of的位置开始放置读入的数据，读毕后返回读取的字节数。 以上三个方法读取的数据读默认为字节类型。当输入流读取结束时，会得到-1，以标志数据流的结束。 void close():关闭数据流。建议显式关闭输入/输出流。 int available():返回目前可以从数据流中读取的字节数（但实际的读操作所读的字节数可能大于该返回值） long skip(long):跳过数据流中long长度的字节不读取，返回值表示实际跳过的字节数。 数据流中字节的读取通常是按从头到尾顺序进行的，如果要反方向读取，则需要回推（Push Back）操作。\n回推操作的常用方法：\n1 2 3 boolean markSupported():用于测试数据是否支持回推操作，支持mark()和reset()时返回true,反之false. void mark(int markarea):用于标记数据流的当前位置，并规划出一个缓冲区，其大小至少为指定参数大小。 void reset():将输入流重新定位到对此流最后调用mark方法时的位置。 输出数据流 是指只能写不能读的流，用于从计算机中输出数据。 OutputStream 方法：\n1 2 3 4 5 void write(int i):将字节i写入数据流中，它只输出所读入参数的最低8位。 void write(byte b[]):将数组b[]中的全部b.length个字节写入数据流。 void write(byte b[],int off,int len):将数据b[]中从下标off开始的len个字节写入数据流。 void close(): 当结束对输出数据流的操作时应当将其关闭。 void flush(): 刷新此输出流并强制写出所有缓冲的输出字节。 为提高数据缓冲区的输出效率，在提交数据之前把所要输出的数据先暂时保存在内存缓存中。\n2.基本字节流数据 byte 文件数据流 包括 FileInputStream 和 FileOutputSteram 来进行文件的 I/O 处理，不支持回推操作。\n构造文件数据流时，可以直接给出文件名：\n1 FileInputStream fis = new FileInputStream(\u0026#34;myFile\u0026#34;) // 文件myFile 作为该数据流的数据源 可使用FileOutputStream 向文件中输出字节。\n进行IO操作\n对于FileInputStream 类对象，如果指定文件不存在，则产生 FileNotFound 异常。由于它是非运行时异常，因此必须加以捕获 对于FileOutputStream 类的实例对象，如果指定文件不存在，则在系统创建文件；如存在，则写入内容将覆盖文件原有数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 try { FileOutputStream out = new FileOutputStream(\u0026#34;myfile.dat\u0026#34;); out.write(\u0026#39;H\u0026#39;); out.write(\u0026#39;L\u0026#39;); out.close(); FileInputStream in = new FileInputStream(\u0026#34;myfile.dat\u0026#34;); while (in.available()\u0026gt;0) { System.out.println(\u0026#34;读:\u0026#34;+(char)in.read()); \u0026#39;(char)in.read()\u0026#39; 强转类型：int -\u0026gt; char } in.close(); }catch (FileNotFoundException e) { // TODO: 文件没找到 }catch (IOException e) { // TODO: 不能写入到文件中 } 过滤器( filter )数据流 缓冲区数据流（为提高读写效率） BufferedInputStream 和 BUfferedOutputStream，它们是在数据流上增加了缓存区。 当读写数据时，数据以块为单位先进入缓冲区，其后的读写操作则作用于缓冲区。可提高 I/O 操作的效率。此外这两个流还支持 回推操作（mark()、rest、skip）的支持 创建该类的实例对象时，可以使用两种方法，一种是使用默认缓冲区大小。\n1 2 3 4 5 6 7 8 FileInputStream fis = new FileInputStream(\u0026#34;my File\u0026#34;); InputStream isDefault = new BufferedInputStream(fis); // 使用默认缓冲区大小 InputStream is = new BufferedInputStream(fis,1024); // 自行设置缓冲区大小 FileOutputStream fos = new FileOutputStream(\u0026#34;myFile\u0026#34;); OutputStream osDefault = new BufferedOutputStream(fos); // 使用默认缓冲区大小 OutputStream os = new BufferedOutputStream(fos,1024);// 自行设置缓冲区大小 \u0026#39;一般在关闭一个缓冲区输出流之前，应先使用flush()方法强制输出剩余数据，以确保缓冲区内的所有数据全部写入输出流\u0026#39; 数据数据流 （操作基本数据） 之前处理的数据都是指字节或字节数组\nDataInputStream 和 DataOutputStream 允许通过数据流读写Java基本类型，包括布尔值（boolean）和 浮点型（float）等。\n1 2 3 is / os 分别是前面已经建立好的输入 / 输出数据流对象 DataInputStream dis = new DataInputStream(is); DataOutputStream dos = new DataOutputStream(os) DataInputStream 提供如下一些方法：\n1 2 3 4 5 6 7 8 9 byte readByte() long readlong() double readDouble() boolean readBoolean() string readUTF() int readInt() float readFloat() short readShort() char reaadChar() DataOutputStream 提供如下一些方法：\n1 2 3 4 5 6 7 8 9 void writeByte() void writeLong() void writeDouble() void writeBoolean() void writeBUTF() void writeInt() void writeFloat() void writeShort() void writeChar() 把对象写入文件数据流或从文件数据流中读出功能： java.io 包中的 ObjectInputStream / ObjectOutputStream 两个类实现的 能够输入/ 输出对象的流称为对象流\n对象流 （操作对象数据） 写入对象数据流 将一个 java.util.Date对象实例 写入文件\n1 2 3 4 5 6 7 8 9 Date d = new Date(); // 一个对象d try{ FileOutputStream f = new FileOutputStream(\u0026#34;date.ser\u0026#34;); // 输出文件 ObjectOutputStream s = new ObjectOutputStream(f); // 写入文件数据流 s.writeObject(d); s.close(); }cathc(IOException e){ e.printStackTrace(); } 读取对象数据流\n1 2 3 4 5 6 7 8 9 Date d = null; FileInputStream f = new FileInputStream(\u0026#34;date.ser\u0026#34;); ObjectInputStream s = new ObjectInputStream(f); try { d = (Date)s.readObject(); s.close(); }cathc(IOException e){ e.printStackTrace(); } 序列化 对象的持久性：能够记录自己的状态以便将来得到复原的能力。\n对象序列化：把对象转换为字节序列的过程。 对象的反序列化：把字节列恢复为对象的过程。 序列化的主要任务是写出对象实例变量的数值。\njava.io.Serializable 作了改动以支持将Java对象存为数据流的功能\n只有实现Serializable接口的类才能被序列化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Student implements Serializable{ int id; String name; int age; String department; public Student(int id,String name,int age,String department){ this.id = id; this.age = age; this.department = department; } } Student stu = new Student(999, \u0026#34;Lv si jun\u0026#34;, 25, \u0026#34;CSD\u0026#34;); Student stu1; try { FileOutputStream out = new FileOutputStream(\u0026#34;myfile.ser\u0026#34;); ObjectOutputStream os = new ObjectOutputStream(out); os.writeObject(stu); os.close(); FileInputStream fileInputStream = new FileInputStream(\u0026#34;myfile.ser\u0026#34;); ObjectInputStream si = new ObjectInputStream(fileInputStream); stu1 =( Student )si.readObject(); si.close(); System.out.println(stu1.id); }catch (Exception e) { // TODO: 文件没找到 } 序列化只能保存对象的非静态成员变量，而不能保存任何成员方法和静态成员变量 ，并且保存的只是变量的值，对于变量的任何修饰符都不能保存。访问权限对数据域的序列化没有影响。\n有一些对象类不具有可持久性，其状态是瞬时的，如Thread对象或流对象。这类对象需用transient 关键字标明，否则编译器将报错。任何使用 transient 关键字标明的成员变量，都不会被保存。\n1 2 3 4 5 6 class MyClass implements Serializable{ public transient Thread myThread; private transient String customerID; private int total; } myThread域有transient修饰，所以尽管它是不可序列化元素，但其整个对象仍可序列化。如果对象的成员数据不适合进行序列化，则可以使用关键字 transient 以防止数据被序列化。 3.基本字符流 char java.io 加入了 专门用于字符流处理的类，是以Reader和Writer为基础派生的一系列类。\nReader / Writer 是抽象类，能实现对不同平台之间的数据流进行转换。\n其他程序设计语言使用 ASCII 字符，ASCII 是以一个字节（8bit）表示一个字符 Java 使用 Unicode 字符集来表示字符串和字符，Unicode是两个字节表示一个字符。\n1 2 3 4 InputStreamReader(InputStream in):默认规范 InputStreamReader(InputStream in,String enc):指定规范 OutputStreamWriter(OutputStream out):默认规范。 OutputStreamWriter(OutputStream out,String enc): 指定规范 缓冲区Reader 和 缓冲区Writer 整行字符的处理方法\n1 2 public String readLine(): BufferedReader的方法，从输入流中读取一行字符，行结束标志为 \u0026#39;\\n\u0026#39;、\u0026#39;\\r\u0026#39; public void newLine(): BufferedWriter的方法，向输出流中写入一个行结束标志。 BufferedReader 或 BufferedWriter 正确连接到 InputStreamReader 或 OutputStreamWriter末尾是一个很好的方法。但是要在BufferedWriter中使用flush()方法，以强制清空缓存区中的剩余内容。\n缓冲区实例\n1 2 3 4 5 6 FileInputStream fis = new FileInputStream(\u0026#34;hello.txt\u0026#34;);//输入文件 InputStreamReader isr = new InputStreamReader(fis,\u0026#34;UTF-8\u0026#34;); //外部转换为内部， 读取流，utf-8格式 BufferedReader bufferedReader = new BufferedReader(isr); // buffer读取 while((buffReader = bufferedReader.readLine()) != null) { //读取多行数据 System.out.println(buffReader); } 从标准输入通道读取字符串信息，然后进行输出。\n1 2 3 4 5 InputStreamReader isr = new InputStreamReader(System.in); // 系统输入读取 BufferedReader bufferedReader = new BufferedReader(isr); // 作为缓冲区 while((buffReader = bufferedReader.readLine()) != null) { // System.out.println(\u0026#34;Read:\u0026#34;+buffReader); }\t使用PrintWriter类中的 print() 或 println() 方法，输出文本格式的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class BankAccount{ private String ownerName; private int accountNumber; private float balance; String getOwnerName() { return ownerName; } void setOweerName(String ownerName) { this.ownerName = ownerName; } int getAccountNumber() { return accountNumber; } void setAccountNumber(int accountNumber) { this.accountNumber = accountNumber; } float getBalance() { return balance; } void setBalance(float balance) { this.balance = balance; } void deposit(float depo) { this.balance += depo; } BankAccount() { this.ownerName = \u0026#34;nobody\u0026#34;; this.accountNumber = 0; this.balance = 0; } BankAccount(String ownername,int accountnumber) { this.ownerName = ownername; this.accountNumber = accountnumber; } BankAccount(String ownername,int accountnumber,float balance) { this.ownerName = ownername; this.accountNumber = accountnumber; this.balance = balance; } } PrintWriter pwF = new PrintWriter(new FileWriter(\u0026#34;account.txt\u0026#34;)); //打开文件，进行写入操作 BankAccount ba = new BankAccount(\u0026#34;lvsj\u0026#34;,1998); // new 银行对象 pwF.println(ba.getOwnerName()); // 开始执行写入操作 pwF.println(ba.getAccountNumber()); pwF.println(ba.getBalance()); pwF.close(); BufferedReader baIn = new BufferedReader(new FileReader(\u0026#34;account.txt\u0026#34;)); //读取文件 BankAccount ba = new BankAccount(); ba.setOweerName(baIn.readLine()); ba.setAccountNumber(Integer.parseInt(baIn.readLine())); baIn.read(); ba.deposit(111); System.out.println(ba); System.out.println(ba.getAccountNumber() + \u0026#34;:\u0026#34; +ba.getOwnerName() + \u0026#34;:\u0026#34; +ba.getBalance()); 4.文件的处理 file 类 ，用来生成文件或目录结构相关的对象。\njava.io.file\n1 2 3 4 5 6 7 8 9 10 方法一 File myFile; myFile = new File(\u0026#34;account.txt\u0026#34;); 方法二 myFile = new File(\u0026#34;/\u0026#34;,\u0026#34;account.txt\u0026#34;); 方法三 File myDir = new File(\u0026#34;/\u0026#34;); myFile = new File(myDir,\u0026#34;account.txt\u0026#34;) 与文件名相关的方法\n1 2 3 4 5 getName() 获取文件名 getPath() 获取文件路径 getAbsolutePath() 获取文件绝对路径 getParent() 获取文件父目录名词 renameTo（File newName） 更改文件名，成功返回true，否则返回false. 文件测定方法\n1 2 3 4 5 6 exists() 文件对象是否存在 canWrite() 文件对象是否可写 canRead() 文件对象是否可读 isfile() 文件对象是否是文件 isDirectory() 文件对象是否是目录 isAbsolute() 文件目录是否是绝对路径 常用文件信息和方法\n1 2 3 lastModified() 获取文件最后修改时间 length delete() 目录工具\n1 2 3 mkdir() 创建目录 mkdirs() 创建新目录 String[] list() 列出符合模式的文件名 随机访问文件 RandomAccessFile 类来处理这种类型的输入 / 输出\n创建一个随机访问文件有以下两种方法供选择\n使用文件名 1 myRAFile = new RandomAccessFile(String name,String mode); 使用文件对象 1 2 myRAFile = new RandomAccessFile(File file,String mode); \u0026#39;mode\u0026#39;参数决定以只读（\u0026#34;r\u0026#34;） / 读写（\u0026#34;rw\u0026#34;）访问文件 示例：打开一个数据库进行更新\n1 2 3 RandomAccessFile myRAFile; myRAFile = new RandomAccessFile(\u0026#34;db/stock.dbf\u0026#34;,\u0026#34;rw\u0026#34;); 对象RandomAccessFile读写信息的方法同数据输入/输出对象的方法相同，它可以访问DataInputStream 和 DataOutputStream 中的所有read() 和 write() 方法。 移动文件读写指针的方法：\n1 2 3 long getFilePointer() 返回文件指针的当前位置 void seek(long pos) 将文件指针置于指定的绝对位置。位置值以从文件开始处的字节偏移量pos来计算，pos为0代表文件开始。 long length() 返回文件的长度，位置值为length() 代表文件的结尾 示例：为文件添加信息时可以利用随机访问文件来完成文件输出的模式\n1 2 3 myRAFile = new RandomAccessFile(\u0026#34;java.log\u0026#34;,\u0026#34;rw\u0026#34;); myRAFile.seek(myRAFile,length()) 现在文件的读写指针已经移至文件的末尾，在 第八章 图形界面设计 AWT 与 swing java.awt包和 javax.swing 中定义了多种用于创建图形用户界面的组件类\nAWT组件定义在 java.awt Swing组件定义在 javax.swing\n设计图形用户界面一般有三个步骤：\n选取组件\n设计布局\n响应事件\n标签按钮在 java.awt包中分别用 Label 和 Button 表示，而在 javax.swing包中，则用 JLable 和 JButton表示，多数 Swing组件以字母 ”J\u0026quot; 开头。\n组件是构建图形的基本元素。例如，按钮（JButton）、文本输入框（JTextField）、标签（JLabel）\n框架（Frame）、面板（Panel）等组件称为容器（Container），它们是特殊的组件，可以包含组件，各种组件（包括容器）可以通过 add方法添加到容器中。\n容器 顶层容器： JFrame、JApplet、JDiglog 和 JWindow\nJFrame类常用的构造方法有以下几种。 JFrame()：构建一个初始时不可见、无标题的新框架窗体 JFrame(String title)：构建一个初始时不可见、有指定标题的新框架窗体 JFrame类中常用方法：\n1 2 3 4 5 6 7 8 void setBounds(int x, int y, int width, int height)：移动并调整框架大小，横纵坐标位置 x,y 框架宽高 width height void setSize(int width, int height)：设置框架大小。宽度是width,高度是height. void setBackground(Color bg):设置框架的背景颜色 -void setVisible(boolean aFlag):设置框架的显示隐藏 -void pack():设置框架的大小，以适应其子组件的首选大小和布局 void setTitle(String title):设置框架的标题 -Container getContentPane():返回框架窗体的内容窗格对象 -void setLayout(LayoutManager manager):设置布局管理器 示例\n1 2 3 4 5 6 7 JFrame frame = new JFrame(\u0026#34;这是一个窗口\u0026#34;); // 创建框架 JButton button = new JButton(\u0026#34;提交\u0026#34;); // new 按钮 frame.setBounds(500,500,0,0); frame.getContentPane().add(button,BorderLayout.CENTER); // 将按钮添加到框架中 frame.pack(); // 适应子内容大小 frame.setVisible(true); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); 内容窗格 两个方法可以将组件放入内容窗格中\n通过容器 getContentPane()： 1 2 Container contentPane = new frame.getContentPane(); contentPane.add(button,BorderLayout.CENTER); 创建一个新的内容窗格，以取代顶层容器默认的内容窗格。做法是创建一个JPanel的实例，它是 java.awt.Container的子类，然后将组件添加到JPanel实例额，再通过顶层容器的 setContentPane()将JPanel 实例设置为新的内容窗格。 顶层容器默认内容窗格的布局管理器是 Border layout，而 JPanel 默认的布局管理器是 FlowLayout 面板 普通面板（JPanel）和 滚动面板（JScrollPane）都是广泛使用的容器，面板不能独立存在，必须被添加到其他容器内部。\nJPanel类常用的构造方法：\n1 2 JPanel()：创建具有 FlowLayout布局的新面板 JPanel(LayoutManager layout)：创建具有指定容器的新面板 使用 public Component add( Conmponent comp ) 方法可以将指定组件追加到面板中。\nJScrollPanel是带有滚动条的面板，它是Container类的子类，但只能添加一个组件。 JScrollPanel类常用的构造方法：\n1 2 JScrollPane()：创建一个空的JScrollPane，需要时水平和垂直滚动条都可显示。 JScrollPane(Component view)：创建一个显示指定组件内容的JScrollPane,只要组件的内容超过试图大小，就会显示水平和垂直滚动条。 例题： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import java.awt.*; import javax.swing.*; import java.io.*; public static Test33{ private JFrame frame; private JButton btn1,btn2,btn3; public static void main(String args[]){ Test33 that = new Test33(); that.go(); } void go(){ frame = new JFrame(\u0026#34;Buttons\u0026#34;); Container con = frame.getContentPane(); btn1 = new JButton(\u0026#34;North\u0026#34;); btn2 = new JButton(\u0026#34;Center\u0026#34;); btn3 = new JButton(\u0026#34;South\u0026#34;); con.add(btn1,BorderLayout.NORTH); con.add(btn2,BorderLayout.CENTER); con.add(btn3,BorderLayout.SOUTH); frame.pack(); frame.setVisible(true);\t} } 标签及按钮 标签 JLabel 通常用于显示提示性文本信息或图标，不可被编辑。 构造方法：\n1 JLabel(String text)：创建一个显示文本信息的标签 按钮 JButton、切换按钮 JToggleButton、复选按钮 JCheckBox、单选按钮 JRadioButton\n共有方法：\n1 2 3 4 public void addActionlistener(Actionlistener I)：为按钮添加事件监听程序 setEnabled()：是否可用 setText()： setIcon()： JButton JButton(String text)：创建一个有显示文本但没有图标的按钮。\nJToggleButton 具有两种状态的按钮，选中状态和未选中状态。\n1 JToggleButton(String text)：创建一个有显示文本但没有图标的切换按钮，默认未选中。 JCheckBox 和 JRadioButton 都是 JToggleButton 的子类。\n1 2 3 4 5 6 isSelected()：返回按钮的当前状态：true选中，false未选中。 // 创建 ButtonGroup 按钮组，并在组中添加按钮。 ButtonGroup group1 = new ButtonGroup(); group1.add(cb4); // 加入按钮组后只能单选。 例题： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class MyWindow extends JFrame implements ItemListener{ JTextArea text; JCheckBox []box; String boxName[] = {\u0026#34;lv\u0026#34;,\u0026#34;si\u0026#34;,\u0026#34;jun\u0026#34;}; MyWindow(String s) { super(s); Container con = this.getContentPane(); con.setLayout(new GridLayout(1,2)); setLocation(500,500); JPanel panel = new JPanel(); int len = boxName.length; panel.setLayout(new GridLayout(len,1)); box = new JCheckBox[len]; for(int i=0;i\u0026lt;len;i++) { box[i] = new JCheckBox(boxName[i],false); box[i].addItemListener(this); panel.add(box[i]); } text = new JTextArea(4,10); con.add(text); con.add(panel); setVisible(true); pack(); } public void itemStateChanged(ItemEvent e) { text.setText(null); for(int i=0;i\u0026lt;box.length;i++) { if(box[i].isSelected()) { text.append(boxName[i] + \u0026#34;被选中\\n\u0026#34;); }else { text.append(boxName[i] + \u0026#34;没有被选中\\n\u0026#34;); } } } } new MyWindow(\u0026#34;测试1\u0026#34;); 布局管理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 -setLayout() 改变容器的布局管理器 -FlowLayout ：默认此布局，流式布局 -BorderLayout：东南西北中，顶层容器容器默认此布局 BorderLayout.NORTH (SOUTH、WEST、EAST、CENTER) frame.getContentPane().add(button,BorderLayout.NORTH) 默认放中间 -GridLayout： GridLayout(int rows,int cols)：创建具有指定行数和列数的网格布局 -CardLayout：卡片式，每一时刻只显示出其中的一张 public void first(Container parent) public void last(Container parent) public void previous(Container parent) public void next(Container parent) public void show(Container parent,String name) myCard.next(contentPane); -BoxLayout：排成一行或一列 Box类 特殊容器 public static Box createHorizontalBox()：创建水平方向的BoxLayout public static Box createVerticalBox()：创建垂直方向的BoxLayout -空布局 setLayout(null); 将布局管理器设置为空 setBounds(int x,int y,int width,int height) 设置组件位置和大小 事件处理 事件处理模型 用户在程序界面所进行的操作称为用户事件，对应事件的响应称为事件处理。 为了接收并处理某类用户事件，组件必须注册相应的事件处理程序，称为事件侦听程序（Listener,也称侦听器）。\n委托事件处理模型：事件被直接送往产生这个事件的组件，组件需要注册一个或多个侦听程序，侦听程序的类中包含了事件处理程序，用来接收和处理该事件。\n事件处理的步骤：\n引入 import java.awt.event. * 给所需事件源对象注册事件侦听程序。 1 事件源.addXXXListener(XXXListener); 实现相应的方法。 事件的种类 ActionEvent、ItemEvent、MouseEvent、KeyEvent等等，每种事件都有一个对应的接口，接口中声明了一个或多个抽象的事件处理方法。\n事件类型 组件 接口名称 方法及说明 ActionEvent JButton、JCheckBox、JComboBox、JMenuItem、JRadioButton ActionListener actionPerformed（ActionEvent）单击按钮、选择菜单项或在文本框中按（Enter）键时 ItemEvent JCheckBox、JComboBox、JMenuItem、JRadioButton ItemListener itemStateChanged(ItemEvent)选择复选框、选项框、单列表框、选中复选框菜单时 KeyEvent 同 ComponentEvent KeyListener 处理键盘事件 keyPressed(KeyEvent)键按下时、keyReleased(KeyEvent)键释放时、keyTyped(KeyEvent)击键时 MouseBuuttonEvent 同 ComponentEvent MouseListener mousePressed(MouseEvent) 鼠标键按下时、mouseReleased(MouseEvent)鼠标键松开时、mouseEntered(MouseEvent)鼠标进入时、mouseExited(MouseEvent)鼠标离开时、mouseClicked(MouseEvent)单击鼠标时 MouseMotionEvent 同 ComponentEvent MouseMotionListener mouseDragged(MouseEvent)鼠标拖拽、mouseMoved(MouseEvent)鼠标移动时 绘画基础 颜色 1 2 int r = 255,g = 255, b =0; Color color = new Color(r,g,b); 字体 三要素： 字体、样式、字号\n1 Font(String name,int style,int size)：根据指定名称、样式、字号创建一个新Font对象 Graphics类的基本功能 Graphics 类是所有图形上下文的抽象父类 ，允许应用程序在组件以及屏幕图像上进行绘制。 先后绘图的图形有重叠时，如何确定重叠部分的颜色？这称为绘图模式。\n正常模式下，后绘制的图形覆盖先绘制的图形使得先绘制的图形被重叠的部分不再可见；setPaintMode() 异或模式下，当前绘制的颜色、先前绘制的颜色及所选定的某种颜色之间进行某种处理，使用得到的新颜色值进行绘制。setXORmode(Color c) 在某个组件中绘图，一般应该为这个组件所属的子类重写paint()方法，在该重写的方法中进行绘图。 但要在 JComponent 子类的组件中绘图，应重写 paintComponent() 方法，在该方法中进行绘图。 Graphics 绘图方法：\n1 2 3 4 5 6 drawArc(int x,int y,int width,int height,int startAngle,int arcAngle)： 绘制一个由左上角为（x,y)、宽为 width、高为height的外接矩形所限定的（开始角度为startAngle,结束角度为arcAngle）的椭圆 drawLine(int xl,int yl,int x2,int y2) drawOval(int x,int y,int width,int height): 绘制一个由左上角为（x,y)、宽为width、高为height的外接矩形所 限定的椭圆 drawPolygon(int[] xPoints,int[] yPoints,int nPoints): 绘制由x和y坐标数组定义的一系列连接线。每对（x,y） 坐标定义了一个点。如果第一个点和最后一个点不同，则图形不是闭合的。 -drawRect(int x,int y,int width,int height): 绘制矩形，左上角为（x,y）宽高为width,height Graphics2D绘图\nstroke属性：控制线的宽度、笔形样式、线段连接方式或短划线 paint属性：控制填充效果 transform属性：用来实现图形的平移、缩放、斜切等变换操作 clip属性：用于实现剪切效果 composit属性：设置图形重叠区域的效果 使用Graphics2D类的新方法画一个图形的步骤：\n先在重画方法 paintComponent() 或 paint() 中，把参数对象 g 强制转换为 Graphics 对象 用上述各图形类提供的静态方法 Double() 创建该图形对象 最后，以图形对象为参数调用 Graphics2D 对象的draw() 方法绘制图形 1 2 3 4 5 6 7 8 9 10 class MyPanel extends JPanel{ protected void paintComponent(Graphics g){ super.paintComponent(g); Graphics2D g2d = (Graphics)g; Line2D line = new Line2D.Double(30,30,340,30); g2d.draw(line); RoundRectangle2D rRect = new RoundRectangle2D.Double(13,30,100,70,40,20); g2d.draw(rRect); } } 1 2 3 4 5 6 7 8 9 10 声明并创建线段对象，起点是（2,3）, 终点是（200,300）； Line2D line = new Line2D(2,3,200,300) 声明并创建矩形对象，矩形左上角是（20,30） 宽高为300、400 Rectangle2D rect = new Rectangle2D.Double(20,30,300,400) 声明并创建圆角矩形，左上角（20,30），宽高130、100，圆角的长短轴为 18、15 RoundRectangle2D rectRound = new Round Rectangle2D.Double(20,30,130,100,18,15); 声明并创建椭圆，左上角（20,30），宽高100、50 Elipse2D ellipse = new Ellipse2D.Double(20,30,100,50); 声明并创建圆弧，外接矩形的左上角是（8,30），宽高85、60，起始角为5度，终止角为90度，Arc2D.OPEN表示是一个开弧： Arc2D arcl = new Arc2D.Double(8,30,85,60,5,270,Arc2D.OPEN) 例题：请写出创建 Font 类型对象fn的代码，fn的属性值是 Courier 字体，BOLD样式，20磅字号。 1 2 Font fn = new Font(\u0026#34;Courier\u0026#34;，\u0026#34;BOLD\u0026#34;,20); 名称-样式-字号 // 错误 正确答案： Font fn = new Font(\u0026#34;Courier\u0026#34;,font.BOLD,20) 第九章 Swing组件 组合框与列表 1.组合框 JComboBox 组合框是一个下拉式菜单，分两类：不可编辑、可编辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 JComboBox(): 创建一个没有任何可选项的默认组合框 JComboBox(Object[] items)：根据Object数组创建组合框 String[] itemList=[\u0026#34;one\u0026#34;,\u0026#34;tow\u0026#34;,\u0026#34;three\u0026#34;...]; JComboxBox jcb = new JComboBox(itemList) setEditable(true): 设置为可编辑的,默认不可编辑 void addItem(Object anObject): 在末尾位置添加新的可选项 void insertItemAt(Object anObject,int index): 在 index 指定的位置添加新的可选项 anObject -int getSelectedIndex(): 获取选择的下标 -Object getSelectedItem(): 返回当前选中项 removeAllItems(): 删除所有 removeItem(Object anObject) 删除指定项 removeItemAt(int anIndex) 删除 anIndex处的可选项 用户事件可通过 ActionListener 、ItemListener 处理 输入项目按Enter键，对应接口是 ActionListener (通常使用) 用户选定项目对应接口是 ItemListener\n例题： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 JFrame frame = new JFrame(\u0026#34;JComboBox demo\u0026#34;) JComboBox\u0026lt;String\u0026gt; jcb1,jcb2; JTextArea ta = new JTextArea(0,30); // 用于显示结果的内容区 public void go(){ JPanel p1 = new JPanel(); // 创建内部JPanel容器 JPanel p2 = new JPanel(); JPanel p3 = new JPanel(); JPanel p4 = new JPanel(); Stringp[] itemList = {\u0026#34;one\u0026#34;,\u0026#34;two\u0026#34;,\u0026#34;three\u0026#34;,\u0026#34;four\u0026#34;}; jcb1 = new JComboBox\u0026lt;String\u0026gt;(itemList); p1.add(jcb1); jcb1.setSelectedIndex(3); Border etched = BorderFactory.createEtchedBorder();// 创建边框 Border border = BorderFactory.createTitledBorder(etched,\u0026#34;Uneditable JComboBox\u0026#34;); p1.setBorder(border); // 添加边框 jcb2 = new JComboBox\u0026lt;String\u0026gt;(); jcb2.addItem(\u0026#34;Six\u0026#34;); // 添加4个可选项 jcb2.addItem(\u0026#34;Seven\u0026#34;); jcb2.addItem(\u0026#34;Eight\u0026#34;); jcb2.addItem(\u0026#34;nine\u0026#34;); jcb2.setEditable(true); // 将jcb2设置为可编辑的 border = BorderFactory.createTitledBorder(etched,\u0026#34;Editable JComboBox\u0026#34;); p2.setBorder(border); JScrollPane jp = new JScrollPane(ta); p3.setLayout(new BorderLayout()); p3.add(jp) border = BorderFactory.createTitledBorder(etched,\u0026#34;Result\u0026#34;); p3.setBorder(border); ActionListener al = new ActionListener(){ public void actionPerformed(ActionEvent e){ JComboBox jcb = (JComboBox)2.getSource(); if(jcb == jcb1){ // 将选项插入jcb2的第一个位置 jcb2.insertItemAt((String)jcb1.getSelectedItem(),0); ta.append(\u0026#34;\\n Item\u0026#34; + jcb1.getSelectedItem() + \u0026#34;inserted\u0026#34;); }else{ ta.append(\u0026#34;\\n You selected item:\u0026#34; + jcb2.getSelectedItem()); jcb2.addItem((String)jcb2.getSelectedItem()); } } } jcb1.addActionListener(a1); jcb2.addActionListener(a1); p4.setLayout(new GridLayout(0,1)); p4.add(p1); p4.add(p2); Container cp = new frame.getContentPane(); cp.add(p3); cp.add(p4); frame.pack(); frame.setVisible(true); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); } 2.列表 JList 支持单项选择、连续或间断的多项选择\n1 2 3 4 5 6 7 8 9 10 11 JList(): 构造一个空列表 JList(Object[] listData): 构造一个列表,列表的可选项由对象数组listData指定 Jlist(Vector\u0026lt;?\u0026gt; listData): 构造一个列表，使其显示指定Vector中的元素 public int getSelectedIndex(): 返回选中项的下标，如果没有所选项则返回 -1 public Object getSelectedValue(): 返回所选的第一个值，如果选择为空，则返回 null public void setVisibleRowCount(int visibleRowCount): 设置不使用滚动条时在列表显示的行数 setSelectionMode(int selectionMode) 选择模式， ListSelectionModel.SINGLE_SELECTION 单选 ListSelectionModel.SINGLE_INTERVAL_SELECTION 可多项选择，但多个选项必须是连续的 ListSelectionModel.MULTIPLE_INTERVAL_SELECTION 可多项选择，多个选项可以是间断的，默认值是这个。 当用户在列表上选择时，会引发 ListSelectionEvent 事件，在JList中提供\n1 2 addListSectionListener(ListSelectionListener listener ) 方法用于注册对应事件侦听 public void valueChanged(ListSelectionEvent e):列表选项发生变化时，将会调用该方法 例题： 以下MyPanel 类在面板上放置一个列表，当单击列表中某个选项时，该选项的值保存在seleItem中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class MyPanel extends JPanel implements __1__{ private String seleItem = null; JList list; MyPanel(String[] listItems){ list = new JList(listItems); list.setVisibleRowCount(2); list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION); list.addListSelectionListener(this); JScrollPane jsp = new JScrollPane(list); add(jsp) } public String getSeleItem(){ return seleItem; } public void valueChanged(__2__ e){ if(e.getSource() == list){ seleItem = list.__3__.toString(); } } } \u0026#39;答案\u0026#39;： ListSelectionListener ListSelectionEvent getSelectedValue() 文本组件 文本域 JTextField （单行） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 JTextField(String text)：构造显示指定初始字符串的文本域 JTextField(String text,int columns): 构造一个列数column，显示初始字符串text的文本域 String getText(): 获取文本域所有内容 String getText(int offs,int len): 获取指定范围的文本内容，从offs 开始，长度为len的文本内容 void setText(Sting t)：设置文本组件中的文本内容 setEditable() 设置是否可编辑 String getSelectedText(): 获取文本域中被选中的内容 void selectAll() 选中所有文本内容 void select(int selectionStart,intselectionEnd): 在文本组件中选中指定起始和结束位置之间的文本内容 addActionListener(ActionListener I) :添加指定操作侦听器 removeActionListener(ActionListener I)：移除指定操作侦听器 setFont(Font f): 设置当前字体 setHorizontalALignment(int alignment): 设置文本的水平对齐方式， JTextField.LEFT \\ CENTER \\ RIGHT \\ LEADing \\ TRAILING JComponent 类中的常用方法： requestFocusInWindow(): 请求当前组件获得输入焦点\n文本区 JTextArea （多行多列） 1 2 3 4 5 6 7 JTextArea(String text)：初始文本 JTextArea(int rows,int columns) 构造行数为rows,列数为columns的空文本区 JTextArea(String text,int rows,int columns) 构造初始文本为text,行数为rows,列数为columns的空文本区 void append(String text)：将指定文本str追加到文本区 void insert(String str,int pos) 将str文本插入到特定位置pos处 void replaceRange(String str,int start,int end): 用指定文本str替换文本区中 起始位置start到结束位置end的内容 文本区本身不带滚动条，由于文本区内显示内容较多，因此一般将其放入滚动窗格 JScrollPane中\n1 2 JTextArea ta = new JTextArea(); JScrollPane jsp = new JScrollPane(ta); // 给文本区添加滚动条 例题： 创建一个列数为 30，初始字符串为“Single Line”的文本域的语句是\n1 JTextField tf = new JTextField(___) \u0026#39;答案\u0026#39;： \u0026#34;Single Line\u0026#34;,30 菜单组件 下拉式菜单 / 弹出式菜单 菜单栏： JMenuBar 菜单： JMenu 菜单项： JMenuItem\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 JFrame frame = new JFrame(\u0026#34;Menu Demo\u0026#34;); // 菜单窗口 JTextField tf = new JTextField(); JMenuBar menubar = new JMenuBar() // 创建菜单栏 frame.setJMenubar(menubar) // 添加到窗口上方 JMenu menu1 = new JMenu(\u0026#34;File\u0026#34;); // 创建菜单File JMenu menu2 = new JMenu(\u0026#34;Edit\u0026#34;); menubar.add(menu1); menubar.add(menu2); JMenuItem menuItem = new JMenuItem(\u0026#34;Open...\u0026#34;); JMenuItem mi2 = new JMenuItem(\u0026#34;Save\u0026#34;,KeyEvent.VK_S); // 设置了快捷键 Alt + S menu1.add(menuItem); menu1.addSeparator(); // 加入分割线, menu1.add(mi2); menuItem.setMnemonic(KeyEvent.VK_0); // 快捷键 alt + 0 menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_1,ActionEvent.ALT_MASK)); // 加速键 注册侦听器 menuItem.addActionListener(this); 复选菜单项和单选菜单项 复选菜单项前面有个小方框 单选菜单前面有个小圆圈\nitemEvent事件， 使用 ItemListener 中的 itemStateChanged() 对此时间进行响应\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 复选框 JCheckBoxMenuItem(String text,Icon icon,boolean b) : 有文本、图标、初始状态 JRadioButtonMenuItem(String text,Icon icon,boolean selected) 有文本、图标、初始状态 JCheckBoxMenuItem mi1 = new JCheckBoxMenuItem(\u0026#34;Persistent\u0026#34;) //显示Persisten,初始状态未选中 JCheckBoxMenuItem mi2 = new JCheckBoxMenuItem(\u0026#34;transient\u0026#34;,true) // 显示transient,初始状态选择 mi1.addItemListener(this); menu1.add(mi1) public void itemStateChanged(ItemEvent e){ int state = e.getStateChange(); JMenuItem amenuItem = (JMenuItem)e.getSource(); String command = amenuItem.getText(); if(state == ItemEvent.SELECTED){ tf.setText(command + \u0026#34;SELECTED\u0026#34;); }else{ tf.setText(command + \u0026#34;DESELECTED\u0026#34;); } } // 单选需要添加到组内 JRadioButtonMenuItem rm = new JRadioButtonMenuItem(\u0026#34;Small\u0026#34;,true); rm.addItemListener(this); menu1.add(rm); ButtonGroup group = new ButtonGroup(); group.add(rm); rm = new JRadioButtonMenuItem(\u0026#34;Large\u0026#34;); rm.addItemListener(this); menu1.add(rm); group.add(rm); 对话框 JDialog 强制型：在关闭前，其他窗口无法接收任何形式的输入，例如选择文件窗口，也称为模式窗口 非强制型：可以中断对话过程，去响应对话框外的事件\nJDialog(Dialog owner ,String title, boolean modal) : 创建一个具有指定拥有者、指定标题的对话框，boolean型参数modal指定对话框是有模式或无模式的。\n创建的对话框默认不可见的，需要调用 setVisible(true) 方法将其显示出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 JFrame frame; JDialog dialog; JButton button; frame = new JFrame(\u0026#34;JDialog Demo\u0026#34;); dialog = new JDialog(frame,\u0026#34;Dialog\u0026#34;,false); dialog.getContentPane().add(new JLabel(\u0026#34;Hello I\u0026#39;m Dialog\u0026#34;)); dialog.setSize(30,60); button = new JButton(\u0026#34;show dialog\u0026#34;); button.addActionListener(this); frame.getContentPane().add(button,BorderLayout.SOUTH); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setSize(200,150); frame.setVisible(true); public void actionPerformed(ActionEvent e){ dialog.setVisible(true) } 标准对话框： JOptionPane 类中的静态方法\nshowConfirmDialog() showInputDialog() showMessageDialog() showOptionDialog() showXxxDialog方法的参数大同小异：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Component parentComponent ：对话框的父窗口对象 String title : 对话框的标题 Object message: 显示在对话框中的描述信息，可以是一个String对象、一个图标、一个组件或一个对象数组 int messageType:对话框所传递的信息 Error_MESSAGE 错误信息 INFORMATION_MESSAGE WARNING_MESSAGE QUESTION_MESSAGE PLAIN_MESSAGE 没有图标 int optionType：对话框上按钮的类型，可以为以下常量： DEFAULT_OPTION YES_NO_OPTION YES_NO_CANCEL_OPTION OK_CANCEL_OPTION 例题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 JFrame frame = new JFrame(\u0026#34;各种标准对话框demo\u0026#34;); JPanel panel = new JPanel(); //showMessageDialog JButton button1 = new JButton(\u0026#34;ShowMessageDialog-ERROR_MESSAGE\u0026#34;) button1.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ JOptionPane.showMessageDialog(panel,\u0026#34;消息提示\u0026#34;，\u0026#34;title\u0026#34;,JOptionPane.ERROR_MESSAGE) } }) // showConfirmDialog JButton button2 = new JButton(\u0026#34;ShowConfirmDialog-DEFAULT_OPTION\u0026#34;); button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ int rtn = JOptionPane.showConfirmDialog(panel,\u0026#34;消息提示\u0026#34;，\u0026#34;title\u0026#34;,JOptionPane.DEFAULT_OPTION); } }) int rtn = JOptionPane.showConfirmDialog(panel,\u0026#34;消息提示\u0026#34;，\u0026#34;title\u0026#34;,JOptionPane.YES_NO_CANCEL_OPTION); System.out.println(rtn) // YES:0 NO:1 CANCEL:2 // showInputDialog int rtn = JOptionPane.showInputDialog(panel,\u0026#34;消息提示\u0026#34;); System.out.println(rtn) // 用户输入的东西 // showOptionDialog JButton button2 = new JButton(\u0026#34;showOptionDialog\u0026#34;); button.addActionListener(new ActionListener(){ public void actionPerformed(ActionEvent e){ Object[] options = new Object[]{\u0026#34;Red\u0026#34;,\u0026#34;Green\u0026#34;,\u0026#34;Blue\u0026#34;}; int rtn = JOptionPane.showOptionDialog(panel,\u0026#34;消息提示\u0026#34;，\u0026#34;title\u0026#34;, JOptionPane.DEFAULT_OPTION,JOptionPane.QUESTION_MESSAGE,null,options,options[0]); // options[0] 默认选中 System.out.println(\u0026#34;What ireceived is :\u0026#34; + options[rtn]); } }) JOptionPane.PLAIN_MESSAGE 没有图标 System.exit(0) 退出Java运行环境\n文件对话框： JFieldChooser类中的静态方法 1 2 3 JFileChooser()：构造一个指向用户默认目录的文件对话框 JFileChooser(File currentDirectory)：使用给定的File作为路径来构造一个文件对话框 JFileChooser(String currentDirectoryPath)：构造一个使用给定路径的对话框 刚刚创建的文件对话框是不可见的，可通过以下方法展示出来\n1 2 showOpenDialog(Component parent) ：弹出一个\u0026#34;打开\u0026#34;文件对话框 showSaveDialog(Component parent)：弹出一个\u0026#34;保存\u0026#34;文件对话框 通过 getSelectedFile() 方法取得用户所选择的文件\n例题： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 JFrame frame = new JFrame(\u0026#34;JFileChooser Demo\u0026#34;); JFileChooser fc = new JFileChooser(); JTextField tf = new JTextField(); JButton openButton,saveButton,deleteButton; openButton = new Button(\u0026#34;Open a File...\u0026#34;); openButton.addActionListener(this); saveButton = new Button(\u0026#34;Save a File...\u0026#34;); saveButton.addActionListener(this); deleteButton = new Button(\u0026#34;Delete a File...\u0026#34;); deleteButton.addActionListener(this); JPanel jp = new JPanel(); jp.add(openButton); jp.add(saveButton); jp.add(deleteButton); frame.getContentPane().add(jp,BorderLayout.CENTER); frame.getContentPane().add(tf,BorderLayout.SOUTH); frame.setDefaultCloseOperation(frame.EXIT_ON_CLOSE); frame.setSize(300,300); frame.setVisible(true); public void actionPerformed(ActionEvent e){ JButton button = (JButton)e.getSource(); if(button == openButton){ int select = fc.showOpenDialog(frame); if(select == JFileChooser.APPROVE_OPTION){ File file = fc.getSelectedFile(); tf.setText(\u0026#34;opening:\u0026#34; + file.getName() ) }else{ tf.setText(\u0026#34;Open command cancelled by user\u0026#34;) } } if(button == saveButton){ int select = fc.showSaveDialog(frame); if(select == JFileChooser.APPROVE_OPTION){ File file = fc.getSelectedFile(); tf.setText(\u0026#34;saving:\u0026#34; + file.getName() ) }else{ tf.setText(\u0026#34;save command cancelled by user\u0026#34;) } } if(button == deleteButton){ int select = fc.showDialog(frame,\u0026#34;删除\u0026#34;); if(select == JFileChooser.APPROVE_OPTION){ File file = fc.getSelectedFile(); tf.setText(\u0026#34;deleting:\u0026#34; + file.getName() ) }else{ tf.setText(\u0026#34;delete command cancelled by user\u0026#34;) } } } 第十章 多线程 线程与多线程 进程： 一个入口、一个出口和一个顺次执行的语句序列。从入口开始按语句的顺序（包括顺序、分支和循环结构）相应指令直到结尾，再从出口退出，整个程序结束的过程。\n进程既包括所要执行的指令，又包括执行指令所需的任何系统资源，如CPU、内存空间、IO端口等，不同进程所占用的系统资源相对独立。\n程序：静态\n进程： 动态（程序跑起来的过程），包括指令、系统资源（CPU、内存空间、IO端口）\n多线程： 共享该进程的系统资源\n线程的4种状态：\n新建、可运行、死亡、阻塞\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 sequenceDiagram title: 序列图 # participant, 参与者 participant 新建 participant 可运行状态 participant 阻塞 participant 死亡 note over 新建:new Thread() note over 可运行状态: 就绪、运行状态 note over 阻塞: 等待睡眠挂起阻塞 可运行状态-\u0026gt;\u0026gt;可运行状态:yield() 新建-\u0026gt;\u0026gt;可运行状态:start() 可运行状态-\u0026gt;\u0026gt;阻塞:sleep()/wait()/IO流阻塞 阻塞-\u0026gt;\u0026gt;可运行状态:notify()/notifyAll()/IO完成 可运行状态-\u0026gt;\u0026gt;死亡:run()退出/异常退出 创建线程 创建线程两种方法： **定义一个继承 Thread类的子类\n用Thread类的子类创建线程的步骤： 从 Thread类派生出一个子类，在类中一定要实现 run() 1 2 3 class Lefthand extends Thread { public void run(){ ...线程体 } } 用该类创建一个对象 1 Lefthand left = new Lefthand(); 用 start()方法启动线程。 1 left.start(); Thread的构造方法包含一个 Runnable实例的参数，即必须定义一个实现Runnable接口的类并产生一个该类的实例，对实例的引用就是适合于这个构造方法的参数。 1 2 3 4 5 6 7 8 9 10 11 class xyz implements Runnable{ int i; public void run(){ while(true){ System.out.println(\u0026#34;Hello\u0026#34; + i++); } } } Runnable r = new xyz(); Thread t = new Thread(r); Thread t 管理CPU资源 class xyz run Code Data xyz r\n例题：请写出用 THread类的子类创建线程并启动线程所包含的步骤。 从Thread类派生出一个子类。 实现run()。 用该类创建一个对象。 用start()方法启动线程。 线程的基本控制 线程的基本控制 1 2 3 4 5 6 start(): 启动线程对象，让线程从新建状态转为就绪状态。 run(): 用来定义线程对象被调度之后所执行的操作，用户必须重写run方法。 yield(): 强制终止线程的执行。 isAlive()： 测试当前线程是否在活动。 sleep(int millisecond): 使线程休眠段时间，时间长短由millisecond决定，单位ms. void wait():使线程处于等待状态。 线程的调度 抢占式、优先级，高优先级抢占低优先级。\nyield()方法只给同优先级进程以运行机会。 sleep() 调用允许低优先级进程运行。 isAlive() 来获得一个线程是否还在活动状态的信息。活动状态不意味着这个线程正在执行，只说明这个线程已被启动且未死亡。\n挂起线程 sleep() wait() 和 (notify() / notifyAll())可唤醒wait join()\n线程的互斥 对象互斥锁\n多线程共同访问同一个资源时，将其锁定，处理完再解锁。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class stack{ int idx =0; char data[]= new char[6]; public void push(char c){ data[idx] = c; idx++; } public char pop(){ idx--; return data[idx]; } } class Stack{ int idx =0; char data[]= new char[6]; public void push(char c){ synchronized(this){ data[idx] = c; idx++; } } public char pop(){ synchronized(this){ idx--; return data[idx]; } } } 线程的同步 生产者消费者问题\n1 2 3 4 5 6 7 8 9 10 synchronized(drainingBoard){ if(drainingBoard.isEmpty()){ // 如果为空，则进程等待睡着 drainingBoard.wait(); } } synchronized(drainingBoard){ drainingBoard.addItem(plate); drainingBoard.notify(); // 唤醒 } 在执行 wait()调用时，java将先把锁定标志返回给对象。\n例题：在解决线程同步问题时，wait方法的作用是让当前线程释放其所持有的 __ 对象互斥锁__ 模拟考试 类MyClass经Java编译程序编译后，产生的文件是 MyClass.class\n在一个类中允许多个方法使用同一个方法名，这是方法的重载\n顶层容器默认内容窗格的布局管理器是 Borderlayout，而 JPanel默认的布局管理器是FlowLayout\nJava程序的运行入口是 main() 方法\nchar类型的值用16 位无符号整数表示\n在方法头中，用关键字 throws 来声明这个方法可能抛出的异常。\n子类和父类，是一个 is a 关系\nReader 和 Write 是用于 字符流处理的类\nGraphics2D类中，用于绘制线段的类是 Line2D\n简答题 重载方法的两条原则： 调用语句的实参列表必须足够判明要调用哪个方法。实参的类型可能要进行正常的扩展提升。 方法的返回参数可以相同也可不同。 以下声明数组是否正确 1 2 1. int a[2][3]; 2. int [][]b = new int[][5] 不正确，不允许声明静态数组 不正确，维数声明应从高维到低微 final类和final方法的特点 final类不能被继承，final方法不能被覆盖\nstart() 与 yield() 的作用\nstart() 用于启动线程对象 ， yield()用于强制终止线程的执行\n","permalink":"https://bablvsj.github.io/posts/exams/java/","summary":"第一章 Java概述 考点一 Java语言的特点 1.**语法简单，功能强大，安全可靠 强类型语言： 没有指针（ 与C、C++ 对比 ）、 没有多重继承机制( 可","title":"Java"},{"content":"Vue 响应式系统的原理 Vue 实现响应式主要是采用数据劫持结合发布者-订阅者模式的方式。具体实现就是整合 Observer，Compiler 和 Watcher 三者。\nObserver\n观察者。Vue 通过 Observer 对数据对象的所有属性进行监听，当把一个普通对象传给 Vue 实例的 data 选项时，Observer 将遍历它的所有属性，并为其添加 getter 和 setter。getter 将收集此属性所有的订阅者，setter 将在属性发生变动的时候，重新为此属性赋值，并通知订阅者调用其对应的更新函数。\n在 Vue 2 中是通过 ES5 的 Object.defineProperty() 方法实现。\n在 Vue 3 中是通过 ES6 的 new Proxy() 实现的。\nCompiler\n模板编译器。它的作用是对每个元素节点的指令 v- 和模板语法 {{}} 进行扫描，替换对应的真实数据，或绑定相应的事件函数。\nWatcher\n发布者/订阅者。Watcher 作为连接 Observer 和 Compiler 的桥梁，能够订阅并收到每个属性变动的通知，然后执行相应的回调函数。Compiler 在编译时通过 Watcher 绑定对应的数据更新回调函数，Observer 在监听到数据变化时执行此回调。在 Observer 中，Watcher 就是订阅者，在 Compiler 中，Watcher 就是发布者。\n为什么 Vue 3.x 采用了 Proxy 抛弃了 Object.defineProperty() ？ Proxy 可以代理任何对象，包括数组，而 Vue 2 中是通过重写数组的以下七种方法实现的。\npush()（将一个或多个元素添加到数组的末尾，并返回该数组的新长度） pop()（移除并返回数组的最后一个元素） unshift()（将一个或多个元素添加到数组的开头，并返回该数组的新长度） shift()（移除并返回数组的第一个元素） splice()（删除数组中的一个或多个元素，并将其返回） sort()（对数组进行排序） reverse()（对数组进行反转） Proxy 可以直接监听整个对象而非属性，而 Object.defineProperty() 只能先遍历对象属性再去进行监听。相比之下 Proxy 更加简洁，更加高效，更加安全。\nProxy 返回的是一个新对象，我们可以只操作新的对象达到目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const cat = { name: \u0026#39;Tom\u0026#39;, } const myCat = new Proxy(cat, { get(target, property) { console.log(`我的 ${property} 被读取了`) return property in target ? target[property] : undefined }, set(target, property, value) { console.log(`我的 ${property} 被设置成了 ${value}`) target[property] = value return true }, }) myCat.name // expected output: 我被读取了：name myCat.name = \u0026#39;Kitty\u0026#39; // expected output: 我的 name 被设置成了 Kitty Object.defineProperty() 的本质是在一个对象上定义一个新属性，或者修改一个现有属性。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const cat = { name: \u0026#39;Tom\u0026#39;, } Object.defineProperty(cat, \u0026#39;name\u0026#39;, { get() { console.log(`我被读取了`) }, set(value) { console.log(`我被设置成了 ${value}`) }, }) cat.name // expected output: 我被读取了 cat.name = \u0026#39;Kitty\u0026#39; // expected output: 我被设置成了 Kitty 而 Proxy 天生用于代理一个对象，它有 13 种基本操作的拦截方法，是 Object.defineProperty() 不具备的。\napply()（拦截函数的调用） construct()（拦截构造函数的调用） defineProperty()（拦截属性的定义） deleteProperty()（拦截属性的删除） get()（拦截对象属性的读取） getOwnPropertyDescriptor()（拦截对象属性的描述） getPrototypeOf()（拦截对象的原型） has()（拦截对象属性的检查） isExtensible()（拦截对象是否可扩展的检查） ownKeys()（拦截对象的属性列表） preventExtensions()（拦截对象是否可扩展的设置） set()（拦截对象属性的设置） setPrototypeOf()（拦截对象的原型的设置） Vue 3 对 diff 算法进行了哪些优化 在 Vue 2 中，每当数据发生变化时，Vue 会创建一个新的虚拟 DOM 树，并对整个虚拟 DOM 树进行递归比较，即使其中大部分内容是静态的，最后再找到不同的节点，然后进行更新。\nVue 3 引入了静态标记的概念，通过静态标记，Vue 3 可以将模板中的静态内容和动态内容区分开来。这样，在更新过程中，Vue 3 只会关注动态部分的比较，而对于静态内容，它将跳过比较的步骤，从而避免了不必要的比较，提高了性能和效率。\n1 2 3 4 5 6 7 \u0026lt;div\u0026gt; \u0026lt;!-- 需静态提升 --\u0026gt; \u0026lt;div\u0026gt;foo\u0026lt;/div\u0026gt; \u0026lt;!-- 需静态提升 --\u0026gt; \u0026lt;div\u0026gt;bar\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;{{ dynamic }}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 手写代码 手写实现双向绑定 Vue 是如何实现数据双向绑定的？v-model 的原理？ Vue 组件可以通过使用 v-model 指令以实现双向绑定。\nv-model 是 vue 的一个语法糖，它用于监听数据的改变并将数据更新。以 input 元素为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; :value=\u0026#34;message\u0026#34; @input=\u0026#34;updateMessage($event.target.value)\u0026#34;\u0026gt; {{ message }} \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { data() { return { message: \u0026#39;\u0026#39; }; }, methods: { updateMessage(value) { this.message = value; } } }; \u0026lt;/script\u0026gt; 如何在组件中实现 v-model ？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 父组件 \u0026lt;Father v-model=\u0026#34;message\u0026#34; /\u0026gt; // 等价于 \u0026lt;Father :value=\u0026#34;messge\u0026#34; @input=\u0026#34;message=$event.target.value\u0026#34; /\u0026gt; // 子组件 \u0026lt;input :value=\u0026#34;messgae\u0026#34; @input=\u0026#34;onMessage\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; // vue2 props:{ value: message } const onMessage = (e) =\u0026gt; { $emit(\u0026#39;input\u0026#39;, e.target.value); } //vue3, 组合式 API 实现 `v-model`，需要定义 `modelValue` 参数，和 `emits` 方法 defineProps({ modelValue: { type: String, default: \u0026#39;\u0026#39; }, }) const emits = defineEmits([\u0026#39;update:modelValue\u0026#39;]) function onInput(val) { emits(\u0026#39;update:modelValue\u0026#39;, val) } \u0026lt;/script\u0026gt; ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/202309-vue%E9%9D%A2%E8%AF%95%E9%A2%98/","summary":"Vue 响应式系统的原理 Vue 实现响应式主要是采用数据劫持结合发布者-订阅者模式的方式。具体实现就是整合 Observer，Compiler 和 Watcher 三者。 Observer","title":"vue面试题"},{"content":"教程：\n基础语法 数据列输出顺序 SELECT {列名...} 全表查询 select * from 表名\n查询 - 别名 别名语法 {原始字段名} as {别名} 来为查询结果的列名取一个便于理解的名称。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和年龄（age）信息，并为它们取别名为 学生姓名 和 学生年龄\n1 2 3 4 5 select name as \u0026#39;学生姓名\u0026#39;, age as \u0026#39;学生年龄\u0026#39; from student; 查询 - 常量和运算 请编写一条 SQL 查询语句，从名为student的数据表中选择出所有学生的姓名（name）和分数（score），并且额外计算出分数的 2 倍（double_score）。\n1 2 3 4 5 6 select name, score, score * 2 as double_score from student; 条件查询 - where 1 2 3 SELECT 列1, 列2, ... FROM 表名 WHERE 条件; 请编写一条 SQL 查询语句，从名为student 的数据表中选择出所有学生的姓名（name）和成绩（score），要求学生姓名为 \u0026rsquo;lvsj\u0026rsquo;。\n1 2 3 4 5 6 7 select name, score from student where name = \u0026#39;lvsj\u0026#39;; 条件查询 - 运算符 =、 !=、\u0026lt;、\u0026gt; \u0026ldquo;BETWEEN\u0026rdquo; 运算符来筛选出在某个范围内的值。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和年龄（age），要求学生姓名不等于 \u0026lsquo;热dog\u0026rsquo; 。\n1 2 3 4 5 6 7 select name, age from student where name != \u0026#39;热dog\u0026#39;; 条件查询 空值 is null / is not null 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）、年龄（age）和成绩（score），要求学生年龄不为空值。\n1 2 3 4 5 6 7 8 select name, age, score from student where age is not null; 模糊查询 like / not like **通配符：\n百分号（%）：表示任意长度的任意字符序列。 下划线（_）：表示任意单个字符。 还可以使用模糊查询匹配开头和结尾：\n1 2 3 4 5 -- 只查询以 \u0026#34;张\u0026#34; 开头的数据行 select name, age, position from employees where name like \u0026#39;张%\u0026#39;; -- 只查询以 \u0026#34;张\u0026#34; 结尾的数据行 select name, age, position from employees where name like \u0026#39;%张\u0026#39;; 同理，可以使用 not like 来查询不包含某关键字的信息。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和成绩（score），要求姓名（name）不包含 \u0026ldquo;李\u0026rdquo; 这个字。\n1 2 3 4 5 6 7 select name, score from student where name not like \u0026#39;%李%\u0026#39;; 逻辑运算 AND / OR / NOT AND：表示逻辑与，要求同时满足多个条件，才返回 true。 OR：表示逻辑或，要求满足其中任意一个条件，就返回 true。 NOT：表示逻辑非，用于否定一个条件（本来是 true，用了 not 后转为 false） 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）、成绩（score），要求学生的姓名包含 \u0026ldquo;李\u0026rdquo;，或者成绩（score）大于 500。\n1 2 3 4 5 6 7 8 select name, score from student where name like \u0026#39;%李%\u0026#39; or score \u0026gt; 500; 去重 distinct 除了按照单字段去重外，DISTINCT 关键字还支持根据多个字段的组合来进行去重操作，确保多个字段的组合是唯一的。\n示例语法如下：\n1 distinct 字段1, 字段2, 字段3, ... 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有不重复的班级 ID（class_id）和考试编号（exam_num）的组合。\n1 2 3 4 5 select distinct class_id, exam_num from student; 排序 order by 在排序的基础上，我们还可以根据多个字段的值进行排序。当第一个字段的值相同时，再按照第二个字段的值进行排序，以此类推。\n示例语法如下：\n1 order by 字段1 [升序/降序], 字段2 [升序/降序], ... 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出学生姓名（name）、年龄（age）和成绩（score），首先按照成绩从大到小排序，如果成绩相同，则按照年龄从小到大排序。\n1 2 3 4 5 6 7 8 9 select name, age, score from student order by score desc, age asc; 截断和偏移 LIMIT关键字 请编写一条 SQL 查询语句，从名为 student 的数据表中选择学生姓名（name）和年龄（age），按照年龄从小到大排序，从第 2 条数据开始、截取 3 个学生的信息。\n1 2 3 4 5 6 7 8 9 select name, age from student order by age asc limit 1, 3; 条件分支 case when 实例语法：\n1 2 3 4 CASE WHEN (条件1) THEN 结果1 WHEN (条件2) THEN 结果2 ... ELSE 其他结果 END 题目： 假设有一个学生表 student，包含以下字段：name（姓名）、age（年龄）。请你编写一个 SQL 查询，将学生按照年龄划分为三个年龄等级（age_level）：60 岁以上为 \u0026ldquo;老同学\u0026rdquo;，20 岁以上（不包括 60 岁以上）为 \u0026ldquo;年轻\u0026rdquo;，20 岁及以下、以及没有年龄信息为 \u0026ldquo;小同学\u0026rdquo;。\n返回结果应包含学生的姓名（name）和年龄等级（age_level），并按姓名升序排序。\n1 2 3 4 5 6 7 8 9 10 11 select name, case when (age \u0026gt; 60) then \u0026#39;老同学\u0026#39; when (age \u0026gt; 20) then \u0026#39;年轻\u0026#39; else \u0026#39;小同学\u0026#39; end as age_level from student order by name asc; 函数 - 时间函数 常用的时间函数有：\nDATE：获取当前日期 DATETIME：获取当前日期时间 TIME：获取当前时间 假设有一个学生表 student，包含以下字段：name（姓名）、age（年龄）。 请你编写一个 SQL 查询，展示所有学生的姓名（name）和当前日期（列名为 \u0026ldquo;当前日期\u0026rdquo;）。\n1 2 3 4 5 select name, date() as \u0026#39;当前日期\u0026#39; from student; 函数 - 字符串处理 1 2 3 4 5 6 7 8 \u0026#39;`UPPER` 将字段转换为大写\u0026#39; select name, upper(name) as upper_name from employees; \u0026#39;`LOWER` 将字段转换为小写\u0026#39; select name, lower(name) as lower_name from employees; \u0026#39;`LENGTH` 计算字段长度\u0026#39; select name, length(name) as name_length from employees; 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）。请你编写一个 SQL 查询，筛选出姓名为 \u0026lsquo;热dog\u0026rsquo; 的学生，展示其学号（id）、姓名（name）及其大写姓名（upper_name）。\n1 2 3 4 5 6 7 8 select id, name, upper(name) as upper_name from student where name = \u0026#39;热dog\u0026#39; 函数 - 聚合函数 聚合函数是一类用于对数据集进行 汇总计算 的特殊函数。\n常见的聚合函数包括：\nCOUNT：计算指定列的行数或非空值的数量。 SUM：计算指定列的数值之和。 AVG：计算指定列的数值平均值。 MAX：找出指定列的最大值。 MIN：找出指定列的最小值。 示例 假设有一个订单表 orders，包含以下字段：order_id（订单号）、customer_id（客户编号）、amount（订单金额）。数据如下：\norder_id customer_id amount 1 A001 100 2 A002 200 3 A001 150 4 A003 50 1）使用聚合函数 COUNT 计算订单表中的总订单数：\n1 select count(*) as order_num from orders; // order_num = 4 2）使用聚合函数 COUNT(DISTINCT 列名) 计算订单表中不同客户的数量：\n1 select count(distinct customer_id) as customer_num FROM orders; // customer_num = 3 3）使用聚合函数 SUM 计算总订单金额：\n1 select sum(amount) as total_amount from orders; // total_amount = 500 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、class_id（班级编号）、score（成绩）。请你编写一个 SQL 查询，汇总学生表中所有学生的总成绩（total_score）、平均成绩（avg_score）、最高成绩（max_score）和最低成绩（min_score）。\n1 2 3 4 5 6 7 select sum(score) as total_score, avg(score) as avg_score, max(score) as max_score, min(score) as min_score from student; 分组聚合 - 单字段分组 分组聚合是一种对数据进行分类并对每个分类进行聚合计算的操作。它允许我们按照指定的列或字段对数据进行分组，然后对每个分组应用聚合函数，如 COUNT、SUM、AVG 等，以获得分组后的汇总结果。\n举个例子：某个学校可以按照班级将学生分组，并对每个班级进行统计。查看每个班级有多少学生、每个班级的平均成绩。这样我们就能够对学校各班的学生情况有一个整体的了解，而不是单纯看个别学生的信息。\n在 SQL 中，通常使用 GROUP BY 关键字对数据进行分组。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、class_id（班级编号）、score（成绩）。请你编写一个 SQL 查询，统计学生表中每个班级的平均成绩（avg_score）。\n1 2 3 4 5 6 7 select class_id, avg(score) as avg_score from student group by class_id; 分组聚合 - 多字段分组 有时，单字段分组并不能满足我们的需求，比如想统计学校里每个班级每次考试的学生情况，这时就可以使用多字段分组。\n多字段分组和单字段分组的实现方式几乎一致，使用 GROUP BY 语法即可。\n假设有一个学生表 student，包含以下字段id（学号）、name（姓名）、class_id（班级编号）、exam_num（考试次数）、score（成绩）。请编写一个 SQL 查询，统计学生表中每个班级每次考试的总学生人数（total_num）。\n1 2 3 4 5 6 7 8 9 select class_id, exam_num, count(*) as total_num from student group by class_id, exam_num 分组聚合 - having 子句 HAVING 子句用于在分组聚合后对分组进行过滤。它允许我们对分组后的结果进行条件筛选，只保留满足特定条件的分组。\nHAVING 子句与条件查询 WHERE 子句的区别在于，WHERE 子句用于在 分组之前 进行过滤，而 HAVING 子句用于在 分组之后 进行过滤。\n假设有一个学生表 student，包含以下字段：id（学号)、name（姓名）、class_id（班级编号)、score（成绩）。请编写一个 SQL 查询，统计学生表中班级的总成绩超过 150 分的班级编号（class_id）和总成绩（total_score），并将总成绩按从高到低排序。\n1 2 3 4 5 6 7 8 9 10 11 select class_id, sum(score) as total_score from student group by class_id having total_score \u0026gt; 150 order by total_score desc 查询进阶 - 关联查询 cross join 关联查询是一种用于联合多个数据表中的数据的查询方式\nCROSS JOIN 是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 每一行 与右表的 每一行 进行组合，返回的结果是两个表的笛卡尔积。\n示例 假设有一个员工表 employees，包含以下字段：emp_id（员工编号）、emp_name（员工姓名）、department（所属部门）、salary（工资）。数据如下：\nemp_id emp_name department salary 1 小明 技术部 5000 2 鸡哥 财务部 6000 3 李华 销售部 4500 假设还有一个部门表 departments，包含以下字段：department（部门名称）、manager（部门经理）、location（所在地）。数据如下：\ndepartment manager location 技术部 张三 上海 财务部 李四 北京 销售部 王五 广州 使用 CROSS JOIN 进行关联查询，将员工表和部门表的所有行组合在一起，获取员工姓名、工资、部门名称和部门经理，示例 SQL 代码如下：\n1 2 3 SELECT e.emp_name, e.salary, e.department, d.manager FROM employees e CROSS JOIN departments d; 注意，在多表关联查询的 SQL 中，我们最好在选择字段时指定字段所属表的名称（比如 e.emp_name），还可以通过给表起别名（比如 employees e）来简化 SQL 语句。\n查询结果：\nemp_name salary department manager 小明 5000 技术部 张三 小明 5000 财务部 李四 小明 5000 销售部 王五 鸡哥 6000 技术部 张三 鸡哥 6000 财务部 李四 鸡哥 6000 销售部 王五 李华 4500 技术部 张三 李华 4500 财务部 李四 李华 4500 销售部 王五 假设有一个学生表 student ，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）；还有一个班级表 class ，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，将学生表和班级表的所有行组合在一起，并返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）以及班级名称（class_name）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026#39;错误示范\u0026#39; -- select -- s.name as student_name, -- s.age as student_age, -- s.calss_id, -- c.name as class_name -- from student s -- cross join class c; select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name from student s join class c; inner join INNER JOIN 是一种常见的关联查询方式，它根据两个表之间的关联条件，将满足条件的行组合在一起。\nINNER JOIN 只返回两个表中满足关联条件的交集部分，即在两个表中都存在的匹配行。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）、level（班级级别）。\n请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level）。\n1 2 3 4 5 6 7 select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s join class c on s.class_id = c.id; outer join out join 是一种关联查询方式，它根据关联条件，将两个表中满足条件的行组合在一起，并包含没有匹配的行 。\n在 out join 中，包括 left out join 和 right out join 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。\n有些数据库并不支持 right join 语法，那么如何实现 right join 呢？ 其实只需要把主表（from 后面的表）和关联表（ left join 后面的表）顺序进行调换即可！\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）、level（班级级别）。\n请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level），要求必须返回所有学生的信息（即使对应的班级编号不存在）。\n1 2 3 4 5 6 7 8 9 select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s left join class c on s.class_id = c.id; 子查询 子查询是指在一个查询语句内部 嵌套 另一个完整的查询语句，内层查询被称为子查询。 子查询可以用于获取更复杂的查询结果或者用于过滤数据。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，使用子查询的方式来获取存在对应班级的学生的所有数据，返回学生姓名（name）、分数（score）、班级编号（class_id）字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 select name, score, class_id from student where class_id in ( select distinct id from class ) 子查询 - exists 子查询中的一种特殊类型是 \u0026ldquo;exists\u0026rdquo; 子查询，用于检查主查询的结果集是否存在满足条件的记录，它返回布尔值（True 或 False），而不返回实际的数据。\n和 exists 相对的是 not exists，用于查找不满足存在条件的记录。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，使用 exists 子查询的方式来获取 不存在对应班级的 学生的所有数据，返回学生姓名（name）、年龄（age）、班级编号（class_id）字段。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 select name, age, class_id from student where not exists ( select 1 from class where student.class_id = class.id ) 组合查询 组合查询是一种将多个 SELECT 查询结果合并在一起的查询操作。\n包括两种常见的组合查询操作：UNION 和 UNION ALL。\nUNION 操作：它用于将两个或多个查询的结果集合并， 并去除重复的行 。即如果两个查询的结果有相同的行，则只保留一行。 UNION ALL 操作：它也用于将两个或多个查询的结果集合并， 但不去除重复的行 。即如果两个查询的结果有相同的行，则全部保留。 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个新学生表 student_new，包含的字段和学生表完全一致。\n请编写一条 SQL 语句，获取所有学生表和新学生表的学生姓名（name）、年龄（age）、分数（score）、班级编号（class_id）字段，要求保留重复的学生记录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 select name, age, score, class_id from student union all select name, age, score, class_id from student_new 开窗函数 - sum over 开窗函数是一种强大的查询工具，它允许我们在查询中对分组数据进行计算、 同时保留原始行的详细信息 。\n开窗函数可以与聚合函数（如 SUM、AVG、COUNT 等）结合使用，但与普通聚合函数不同，开窗函数不会导致结果集的行数减少。\n打个比方，可以将开窗函数想象成一种 \u0026ldquo;透视镜\u0026rdquo;，它能够将我们聚焦在某个特定的分组，同时还能看到整体的全景。\n本节我们先讲第一个开窗函数：sum over。\n该函数用法为：\n1 sum(计算字段名) over (partition by 分组字段名) 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并计算每个班级的学生平均分（class_avg_score）。\n1 2 3 4 5 6 7 8 9 10 11 12 select id, name, age, score, class_id, avg(score) over ( partition by class_id ) as class_avg_score from student 开窗函数 - sum over order by 学习 sum over 函数的另一种用法：sum over order by，可以实现同组内数据的 累加求和 。\n示例用法如下：\n1 sum(计算字段名) over (partition by 分组字段名 order by 排序字段 排序规则) 举一个应用场景：老师在每个班级里依次点名，每点到一个学生，老师都会记录当前已点到的学生们的分数总和。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数升序的方式累加计算每个班级的学生总分（class_sum_score）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 select id, name, age, score, class_id, sum(score) over ( partition by class_id order by score asc ) as class_sum_score from student 开窗函数 - rank Rank 开窗函数是 SQL 中一种用于对查询结果集中的行进行 排名 的开窗函数。它可以根据指定的列或表达式对结果集中的行进行排序，并为每一行分配一个排名。在排名过程中，相同的值将被赋予相同的排名，而不同的值将被赋予不同的排名。\n当存在并列（相同排序值）时，Rank 会跳过后续排名，并保留相同的排名。\n**Rank 开窗函数的常见用法是在查询结果中查找前几名（Top N）或排名最高的行。\nRank 开窗函数的语法如下：\n1 2 3 4 rank() over ( partition by 列名1, 列名2, ... -- 可选，用于指定分组列 order by 列名3 [asc|desc], 列名4 [asc|desc], ... -- 用于指定排序列及排序方式 ) as rank_column 其中，partition by 子句可选，用于指定分组列，将结果集按照指定列进行分组；order by 子句用于指定排序列及排序方式，决定了计算 rank 时的排序规则。as rank_column 用于指定生成的 Rank 排名列的别名。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式计算每个班级内的学生的分数排名（ranking）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 select id, name, age, score, class_id, rank() over ( partition by class_id order by score desc ) as ranking from student 开窗函数 - row_number Row_Number 开窗函数是 SQL 中的一种用于为查询结果集中的每一行 分配唯一连续排名 的开窗函数。\n它与之前讲到的 Rank 函数不同，Row_Number 函数为每一行都分配一个唯一的整数值，不管是否存在并列（相同排序值）的情况。每一行都有一个唯一的行号，从 1 开始连续递增。\nrow_number 开窗函数的语法如下（几乎和 rank 函数一模一样）：\n1 2 3 4 row_number() over ( partition by column1, column2, ... -- 可选，用于指定分组列 order by column3 [asc|desc], column4 [asc|desc], ... -- 用于指定排序列及排序方式 ) as row_number_column 其中，PARTITION BY子句可选，用于指定分组列，将结果集按照指定列进行分组。ORDER BY 子句用于指定排序列及排序方式，决定了计算 Row_Number 时的排序规则。AS row_number_column 用于指定生成的行号列的别名。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式给每个班级内的学生分配一个编号（row_number）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 select id, name, age, score, class_id, ROW_NUMBER() over ( partition by class_id order by score desc ) as row_number from student 开窗函数 - lag / lead 开窗函数 Lag 和 Lead 的作用是获取在当前行之前或之后的行的值，这两个函数通常在需要比较相邻行数据或进行时间序列分析时非常有用。\n1）Lag 函数\nLag 函数用于获取 当前行之前 的某一列的值。它可以帮助我们查看上一行的数据。\nLag 函数的语法如下：\n1 2 3 4 lag(column_name, offset, default_value) over ( partition by partition_column order by sort_column ) 参数解释：\ncolumn_name：要获取值的列名。 offset：表示要向上偏移的行数。例如，offset为1表示获取上一行的值，offset为2表示获取上两行的值\u0026hellip; default_value：可选参数，用于指定当没有前一行时的默认值。 PARTITION BY和ORDER BY子句可选，用于分组和排序数据。 2）Lead 函数\nLead 函数用于获取 当前行之后 的某一列的值。它可以帮助我们查看下一行的数据。\nLead 函数的语法如下：\n1 2 3 lead(column_name, offset, default_value) over ( partition by partition_column order by sort_column) 参数解释：\ncolumn_name：要获取值的列名。 offset：表示要向下偏移的行数。例如，offset为1表示获取下一行的值，offset为2表示获取下两行的值\u0026hellip; default_value：可选参数，用于指定当没有后一行时的默认值。 PARTITION BY和ORDER BY子句可选，用于分组和排序数据。 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式获取每个班级内的学生的前一名学生姓名（prev_name）、后一名学生姓名（next_name）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 select id, name, age, score, class_id, lag(name, 1, null) over ( partition by class_id order by score desc ) as prev_name, lead(name, 1, null) over ( partition by class_id order by score desc ) as next_name from student 测验 冒险者和金币 假设有一家冒险者公会，他们有一张名为 rewards 的表格，用于记录每个冒险者在各个任务中获得的金币奖励情况。\n表格字段如下：\nadventurer_id：冒险者ID，唯一标识每个冒险者。 adventurer_name：冒险者姓名。 task_id：任务ID，唯一标识每个任务。 task_name：任务名称。 reward_coins：冒险者在该任务中获得的金币奖励数量。 请你编写一条 SQL 查询语句，依次输出每个冒险者的 id（adventurer_id）、冒险者姓名（adventurer_name）、获得的总金币奖励（total_reward_coins），并按照总金币奖励从高到低排序，其中只列出总金币奖励排名前 3 的冒险者。\n1 2 3 4 5 6 7 8 9 select adventurer_id, adventurer_name, sum(reward_coins) as total_reward_coins from rewards group by adventurer_id,adventurer_name order by total_reward_coins desc limit 3; 魔法学院 假设有一家魔法学院，里面有许多学员在不同科目上进行学习和考试。请你设计一张名为magic_scores的表格，用于记录每位学员在不同科目中的考试成绩情况。表格字段如下：\nstudent_id：学员ID，唯一标识每位学员。 student_name：学员姓名。 subject_id：科目ID，唯一标识每个科目。 subject_name：科目名称。 score：学员在该科目的考试成绩。 请你编写一条 SQL 查询语句，依次输出每位学员的学院 ID（student_id）、学员姓名（student_name）、科目 ID（subject_id）、科目名称（subject_name）、学员在该科目的考试成绩（score）、该学员在每个科目中的成绩排名（score_rank），并将结果按照成绩从高到低进行排序。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 select student_id, student_name, subject_id, subject_name, score, rank() over ( partition by subject_id order by score desc ) as score_rank from magic_scores 大浪淘鸡 在神秘的海岛上，有一只传说中的大浪淘鸡，它身躯高大威武，羽毛闪烁着神秘的光芒。岛上的居民都传说大浪淘鸡是海洋之神的化身，它能够操纵海浪，带来平静或狂暴的海洋。为了验证这个传说是否属实，岛上的居民决定对大浪淘鸡进行观测和记录。\n有一张 chicken_observation 的表格，用于记录居民观测大浪淘鸡的信息。表格字段如下：\nobservation_id：观测记录ID，唯一标识每条观测记录 observer_name：观测者姓名 observation_date：观测日期 observation_location：观测地点 wave_intensity：观测到的海浪强度，用整数表示，数值越大，海浪越狂暴 请你编写一条 SQL 查询语句，找出观测地点包含 \u0026ldquo;大浪淘鸡\u0026rdquo; 且海浪强度超过 5 的观测记录，并依次输出每位观测者的姓名（observer_name）、观测日期（observation_date）以及观测到的海浪强度（wave_intensity）。\n1 2 3 4 5 6 7 8 9 10 11 12 select observer_name, observation_date, wave_intensity, observation_location from chicken_observation where (observation_location like \u0026#39;%大浪淘鸡%\u0026#39;) and (wave_intensity \u0026gt; 5) order by wave_intensity desc ","permalink":"https://bablvsj.github.io/posts/exams/sql%E4%B9%8B%E6%AF%8D/","summary":"教程： 基础语法 数据列输出顺序 SELECT {列名...} 全表查询 select * from 表名 查询 - 别名 别名语法 {原始字段名} as {别名} 来为查询结果的列名取一个便于理解的名","title":"SQL之母"},{"content":"概念 浅拷贝：\n1.创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 2.如果属性是基本类型，拷贝的就是基本类型的值。 3.如果属性是引用类型，拷贝的就是内存地址 。 4.所以如果其中一个对象改变了这个地址，就会影响到另一个对象。\n深拷贝：整个对象拷贝到另一个内存中，修改内容互不影响。\n实现 乞丐版 JSON.. 1 JSON.parse(JSON.stringify()) 可以应对大部分的应用场景，但有很大缺陷， 比如拷贝其他引用类型、拷贝函数、循环引用等情况。\ndeepClone 涉及普通数据类型、复杂数据类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function clone(target) { if (target === null || typeof target !== \u0026#39;object\u0026#39;) { //如果不是复杂数据类型，直接返回 return target; } if (target instanceof RegExp) return new RegExp(target); if (target instanceof Date) return new Date(target); if (typeof target === \u0026#39;object\u0026#39;) { let cloneTarget = target instanceof Array ? [] : {}; for (const key in target) { cloneTarget[key] = clone(target[key]); } return cloneTarget; } }; ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/20230823-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/","summary":"概念 浅拷贝： 1.创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。 2.如果属性是基本类型，拷贝的就是基本类型的值。 3.如果属性是引用","title":"深浅拷贝"},{"content":"什么是原型 任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的 prototype 指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有 prototype，只有方法才有 prototype。\n什么是原型链？ 原型链基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。我们知道，每个构造函数都有一个原型对象，每个原型对象都有一个指向构造函数的指针，而实例又包涵一个指向原型对象的内部指 针。 原型链的核心就是依赖对象的_proto_的指向，当自身不存在的属性时，就一层层的扒出创建对象的构造函数，直至到 Object 时，就没有_proto_指向了。 因为_proto_实质找的是 prototype，所以我们只要找这个链条上的构造函数的 prototype。其中 Object.prototype 是没有_proto_属性的，它==null。每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的 指针，而实例都包含指向原型对象内部的指针。 我们让原型对象（1）等于另一个原型对象的实例（2）,此时原型对象（2）将包含一个指向原型对象（1）的指针，再让原型对象（2）的实例等于原型对象（3），如此层层递进就构成了实例和原型的链条，这就是原型链的概念每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数想指针(constructor)，而实例对象都包含一个指向原型对象的内部指针(proto)。如果让原型对象等于另一个原型对象的实例，此时的原型对象将包含一个指向另一个原型的指针(proto)，另一个原型也包含着一个指向另一个构造函数的指针(constructor)。假如另一个原型又是另一个类型的实例……这就构成了实例与原型的链条。也叫原型链\n原型继承是 js 的一种继承方式，原型链作为实现继承的主要方法,其基本思路是利用原型让一个引用类型继承另一个引用类型的属性和方法,\n原型继承 利用原型中的成员可以被和其相关的对象共享这一特性，可以实现继承，这种实现继承的方式，就叫做原型继承.\n","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AE%80%E8%BF%B0%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/","summary":"什么是原型 任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的 prototype 指向的对象，即任何对象都是由","title":"简述原型、原型链、(原型)继承"},{"content":"1.判断数据类型 typeof\n1 2 3 4 5 6 7 8 9 10 typeof \u0026#39;seymoe\u0026#39; // \u0026#39;string\u0026#39; typeof true // \u0026#39;boolean\u0026#39; typeof 10 // \u0026#39;number\u0026#39; typeof Symbol() // \u0026#39;symbol\u0026#39; typeof null // \u0026#39;object\u0026#39; `无法判定是否为 null ` typeof undefined // \u0026#39;undefined\u0026#39; typeof {} // \u0026#39;object\u0026#39; typeof [] // \u0026#39;object\u0026#39; typeof(() =\u0026gt; {}) // \u0026#39;function\u0026#39; 弊端：\nnull 的判定有误差 数组、对象都判定为 object instanceof\n1 2 3 4 5 6 7 8 9 10 {} instanceof Object //true [] instanceof Array //true (()=\u0026gt;{}) instanceof Function //true `instanceof 也不是万能的` let arr = [] let obj = {} arr instanceof Array // true arr instanceof Object // true obj instanceof Object // true Object.prototype.toString() 可以说是判定 JavaScript 中数据类型的终极解决方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Object.prototype.toString.call({}) // \u0026#39;[object Object]\u0026#39; Object.prototype.toString.call([]) // \u0026#39;[object Array]\u0026#39; Object.prototype.toString.call(() =\u0026gt; {}) // \u0026#39;[object Function]\u0026#39; Object.prototype.toString.call(\u0026#39;seymoe\u0026#39;) // \u0026#39;[object String]\u0026#39; Object.prototype.toString.call(1) // \u0026#39;[object Number]\u0026#39; Object.prototype.toString.call(true) // \u0026#39;[object Boolean]\u0026#39; Object.prototype.toString.call(Symbol()) // \u0026#39;[object Symbol]\u0026#39; Object.prototype.toString.call(null) // \u0026#39;[object Null]\u0026#39; Object.prototype.toString.call(undefined) // \u0026#39;[object Undefined]\u0026#39; Object.prototype.toString.call(new Date()) // \u0026#39;[object Date]\u0026#39; Object.prototype.toString.call(Math) // \u0026#39;[object Math]\u0026#39; Object.prototype.toString.call(new Set()) // \u0026#39;[object Set]\u0026#39; Object.prototype.toString.call(new WeakSet()) // \u0026#39;[object WeakSet]\u0026#39; Object.prototype.toString.call(new Map()) // \u0026#39;[object Map]\u0026#39; Object.prototype.toString.call(new WeakMap()) // \u0026#39;[object WeakMap]\u0026#39; 2.toString和String的区别 toString()可以将数据都转为字符串，但是null和undefined不可以转换。\n1 2 console.log(null.toString()) //报错 TypeError: Cannot read property \u0026#39;toString\u0026#39; of null console.log(undefined.toString())//报错 TypeError: Cannot read property \u0026#39;toString\u0026#39; of undefined toString()括号中可以写数字，代表进制\n1 2 3 4 二进制：.toString(2); 八进制：.toString(8); 十进制：.toString(10); 十六进制：.toString(16); String()可以将null和undefined转换为字符串，但是没法转进制字符串\n1 2 console.log(String(null));// null console.log(String(undefined));// undefined 3.JS 闭包经典使用场景和含闭包必刷题 闭包是什么？ 闭包是指有权访问另一个函数作用域中变量的函数\n形成闭包的原因 内部的函数存在外部作用域的引用就会导致闭包。\n1 2 3 4 5 6 7 8 9 var a = 0 function foo(){ var b =14 function fo(){ console.log(a, b) } fo() } foo() 变量提升 问题：说一下你对JavaScript变量提升的理解。\n定义：\n在函数体内部，声明变量，会把该变量提升到函数体的最顶端。注意：只提升变量声明，不赋值。\n代码1：\n1 2 3 4 5 fn(); function fn() { var x = 1; var y = 2; } 上方代码中：\n（1）给fn创建函数上下文，找到fn中所有用var声明的变量（即x和y）； （2）将这些变量初始化为undefined； （3）将x赋值为1，将y赋值为2。\n代码2：\n1 2 3 4 fn2(); function fn2() { console.log(2); } 上方代码中：\n（1）创建全局上下文，找到所有用function声明的变量，在环境中“创建”这些变量。 （2）将这些变量初始化，并赋值为 function(){ console.log(2) }（并不是undefined） （3）开始执行代码fn2();\n代码3：（let的出现）\n1 2 3 4 { let x = 1 x = 2 } 上方代码中：\n（1）找到所有用 let 声明的变量，在环境中「创建」这些变量 （2）开始执行代码（注意现在还没有初始化） （3）执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined） （4）执行 x = 2，对 x 进行「赋值」\n代码4：\n1 2 3 4 5 let x = \u0026#39;global\u0026#39; { console.log(x) // Uncaught ReferenceError: x is not defined let x = 1 } 原因有两个：\nconsole.log(x) 中的 x 指的是下面的 x，而不是全局的 x\n执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）\n看到这里，你应该明白了 let 到底有没有提升：\nlet 的「创建」过程被提升了，但是初始化没有提升。\nvar 的「创建」和「初始化」都被提升了。\nfunction 的「创建」「初始化」和「赋值」都被提升了。\n参考链接：\n我用了两个月的时间才理解 let this 问题：下方代码的打印结果是什么？\n1 2 3 4 5 6 7 8 9 10 11 12 function A() { this.name = \u0026#39;smyhvae\u0026#39;; } A.prototype.test = function () { setTimeout(function () { console.log(this.name); }, 1) } var a = new A(); a.test(); 打印结果是window.name，但实际的结果是空的。\n总结1：this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。即：谁调用，指向谁。\n举例：\n1 2 3 4 5 6 7 8 var name = \u0026#39;全局\u0026#39;; function getName() { var name = \u0026#39;局部\u0026#39;; return this.name; }; alert(getName()); 上方代码的打印结果是：全局。\n分析：getName()这个函数其实是window调用的，所以this指向的window，因为外部有name这个变量，所以打印结果为全局。\n总结2：没有明确的当前对象时，this永远指向window。这个在setTimeout里比较常见。\nJS 的 new 操作符做了哪些事情 new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。\nJS 中的垃圾回收机制 必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必 须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。\n这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时 候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：\n1 var a=\u0026#34;hello world\u0026#34;; var b=\u0026#34;world\u0026#34;;var a=b;//这时，会释放掉\u0026#34;hello world\u0026#34;， **释放内存以便再引用垃圾回收的方法：\n标记清除、计数引用。\n**标记清除\n这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可 能用到他们。当离开环境时，就标记为离开环境。 垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。\n**引用计数法\n引用计数法的意思就是每个值没引用的次数， 当声明了一个变量，并用一个引用类型的值赋值给改变量， 则这个值的引用次数为 1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。 用引用计数法会存在内存泄露，下面来看原因：\n1 2 3 4 function problem() { var objA = new Object(); var objB = new Object(); objA.someOtherObject = objB; objB.anotherObject = objA; } 在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。特 别 是 在 DOM对 象 中 ， 也 容 易 存 在 这 种 问 题 ：\n1 2 3 varelement=document.getElementById （ ’‘ ）； var myObj=new Object(); myObj.element=element; element.someObject=myObj; 这样就不会有垃圾回收的过程。\n手写区域 1.自己实现一个 bind 函数 原理：通过 apply 或者 call 方法来实现。\n(1)初始版本\n1 2 3 4 5 6 7 8 Function.prototype.bind=function(obj,arg){ var arg = Array.prototype.slice.call(arguments,1); var context = this; return function(newArg){ arg = arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); } } (2) 考虑到原型链 为什么要考虑？因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型\n1 2 3 4 5 6 7 8 9 10 11 12 13 Function.prototype.bind=function(obj,arg){ var arg = Array.prototype.slice.call(arguments,1); var context = this; var bound = function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); } var F=function(){} //这里需要一个寄生组合继承 F.prototype=context.prototype; bound.prototype=new F(); return bound; } 2.实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正 则对象）\n通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象 Number，String ，Boolean，以及 Date 对象，RegExp 对象的复制。 (1) 前文的方法\n1 2 3 4 5 6 7 function deepClone(obj){ var newObj= obj instanceof Array?[]:{}; for(var i in obj){ newObj[i]=typeof obj[i]==\u0026#39;object\u0026#39;? deepClone(obj[i]) : obj[i]; } return newObj; } 这种方法可以实现一般对象和数组对象的克隆，比如：\n1 2 3 4 5 6 var arr=[1,2,3]; var newArr=deepClone(arr); //newArr-\u0026gt;[1,2,3] var obj={x:1,y:2} var newObj=deepClone(obj); // newObj={x:1,y:2} 但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //Number 包装对象 var num = new Number(1); typeof num // \u0026#34;object\u0026#34; var newNum=deepClone(num); //newNum -\u0026gt; {} 空对象 //String 包装对象 var str=new String(\u0026#34;hello\u0026#34;); typeof str //\u0026#34;object\u0026#34; var newStr=deepClone(str); //newStr-\u0026gt; {0:\u0026#39;h\u0026#39;,1:\u0026#39;e\u0026#39;,2:\u0026#39;l\u0026#39;,3:\u0026#39;l\u0026#39;,4:\u0026#39;o\u0026#39;}; //Boolean 包装对象 var bol=new Boolean(true); typeof bol //\u0026#34;object\u0026#34; var newBol=deepClone(bol); // newBol -\u0026gt;{} 空对象 (2) valueof()函数 所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值， 因此默认的 valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。 对 于 原 始 值 或 者 包 装 类 ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function baseClone(base){ return base.valueOf(); } //Number var num = new Number(1); var newNum = baseClone(num); //newNum-\u0026gt;1 //String var str = new String(\u0026#39;hello\u0026#39;); var newStr = baseClone(str); // newStr-\u0026gt;\u0026#34;hello\u0026#34; //Boolean var bol = new Boolean(true); var newBol = baseClone(bol); //newBol-\u0026gt; true 其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， 这里用 valueOf 实现，语法上比较符合 规范。\n对于 Date 类型： 因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1 月 1 日以来的毫秒数.因此我们可以在 Date的原型上定义克隆的方法：\n1 2 3 4 5 6 Date.prototype.clone = function(){ return new Date(this.valueOf()); } var date=new Date(\u0026#39;2010\u0026#39;); var newDate=date.clone(); // newDate-\u0026gt; Fri Jan 01 2010 08:00:00 GMT+0800 对 于 正 则 对 象\n1 2 3 4 5 6 7 8 9 10 11 12 RegExp：RegExp.prototype.clone = function() { var pattern = this.valueOf(); var flags = \u0026#39;\u0026#39;; flags += pattern.global ? \u0026#39;g\u0026#39; : \u0026#39;\u0026#39;; flags += pattern.ignoreCase ? \u0026#39;i\u0026#39; : \u0026#39;\u0026#39;; flags += pattern.multiline ? \u0026#39;m\u0026#39; : \u0026#39;\u0026#39;; return new RegExp(pattern.source, flags); }; var reg = new RegExp(\u0026#39;/111/\u0026#39;); var newReg = reg.clone(); //newReg-\u0026gt; /\\/111\\// ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%9F%BA%E7%A1%80/","summary":"1.判断数据类型 typeof 1 2 3 4 5 6 7 8 9 10 typeof \u0026#39;seymoe\u0026#39; // \u0026#39;string\u0026#39; typeof true // \u0026#39;boolean\u0026#39; typeof 10 // \u0026#39;number\u0026#39; typeof Symbol() // \u0026#39;symbol\u0026#39; typeof null // \u0026#39;object\u0026#39; `无法判定是否为 null ` typeof undefined // \u0026#39;undefined\u0026#39; typeof {} // \u0026#39;object\u0026#39; typeof [] // \u0026#39;object\u0026#39; typeof(() =\u0026gt; {}) // \u0026#39;function\u0026#39; 弊端： null","title":"JS基础"},{"content":"1.css 选择器 CSS选择器包括行内样式、id选择器、class选择器、标签选择器，优先级依次降低，!important可用于优先级提升，比行内样式优先级还要高，权重的计算依次为1000,100,10,1，!important的优先级为正无穷。\n2.BFC Block Formatting Context : 块级格式化上下文\nBFC有哪些特性？ 属于同一个BFC的两个相邻容器的上下margin可能会重叠 计算BFC高度时浮动元素也会被计算 BFC的区域不会与浮动容器发生重叠 所有属于BFC中的盒子默认左对齐，并且它们的左边距可以触及到容器的左边线。最后一个盒子，尽管是浮动的，但依然遵循这个原则 BFC是独立容器，容器内部元素不会影响容器外部元素 我们可以解决哪些问题？ 解决外边框的塌陷问题 解决父元素高度塌陷问题 解决浮动重叠问题 怎么生成一个BFC区域？ 设置定位（position）, 不为static或relative（为 absolute 、 fixed） 设置 display 为这些值 inline-block、flex、grid、table、table-cell、table-caption 设置 overflow，且值不为visible (为 auto、scroll、hidden) 设置浮动（float），且值不为none（为 left、right）， 3.盒模型 标准盒模型：width/height = content + padding + border + margin content = content box-sizing:content-box\nie 盒模型：width/height = content + margin content = content + padding + border box-sizing: border-box\n4.实现元素水平垂直居中的多种办法 **4.1 flex\n1 2 3 display:flex; justify-content:center; align-items:center; **4.2 grid\n1 2 3 4 display:grid; justify-content:center; align-items:center; peace-content:center; **4.3 absolute + translate\n1 2 3 4 position:absolute; letf:50%; top:50%; transform:translate(-50%,-50%) **4.4 absolute + 知道元素宽高\n1 2 3 4 5 6 7 width:100px; height:200px; position:absolute; left:50%; top:50%; margin-left:-50px; margin-top:-100px **4.5 absolute + margin:auto\n1 2 3 4 5 6 position:absolute; left:0; right:0; top:0; bottom:0; margin:auto; **4.6 line-height=元素高度 + text-align:center\n1 2 3 4 5 6 .wrap{ width: 400px; height: 300px; line-height: 300px; text-align: center; } 5.css加载会造成堵塞吗？ css并不会阻塞DOM树的解析 css加载会阻塞DOM树渲染 css加载会阻塞后面的js语句的执行\n6.position relative、absolute、static、fixed、sticky\nsticky 粘性定位 relative与fixed的结合体，元素在跨越特定值前被认为是相对定位，之后为固定定位\n7.grid布局 Grid网格布局，是一个基于栅格的二维布局系统，相对于flex一维布局，Grid布局的功能更为强大\nGrid布局可以将网页分成一个个网格，可以任意组合不同的网格，做出各种各样的布局\n网格布局生成属性 1 display:grid | inline-grid grid为块级网格布局，inline-grid为内联块级网格布局\n容器属性 1.grid-template-columns、grid-template-rows grid-template-columns 属性定义每一列的列宽 grid-template-rows 属性定义每一行的行高 值有几个就代表有几列或几行\n1 grid-template-columns\u0026lt;rows\u0026gt;: length | percent(百分比) | auto | fr; 列宽行高都是200px\n1 2 grid-template-columns: 200px 200px 200px; grid-template-rows: 200px 200px 200px; **百分比\n1 2 grid-template-columns: 30% 40% 30%; grid-template-rows: 30% 40% 30%; auto，子项会自适应容器剩余大小撑开\n1 2 grid-template-columns: 200px 100px auto; grid-template-rows: 200px auto 100px; fr，可以理解为比例值，将行与列都分成3份\n1 2 grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; 将第二行与第二列都划分为2份\n1 2 grid-template-columns: 1fr 2fr 1fr; grid-template-rows: 1fr 2fr 1fr; 2.grid-template-areas 网格布局允许指定区域，一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域，以及配合项目上的属性grid-area\n1 2 3 4 5 6 7 grid-template-columns: 1fr 1fr 1fr; grid-template-rows: 1fr 1fr 1fr; grid-template-areas: \u0026#39;f i b\u0026#39; \u0026#39;d a g\u0026#39; \u0026#39;e h c\u0026#39;; // 6 9 2 // 4 1 7 // 5 8 3 3. justify-content、align-content、place-content align-content属性是整个内容区域的垂直位置 justify-content属性是整个内容区域在容器里面的水平位置 place-content 是 align-centent 和 justify-content 的简写\n1 place-content: \u0026lt;align-content\u0026gt; \u0026lt;justify-content\u0026gt;; 4.justify-items、align-items、place-items justify-items属性设置单元格内容的水平位置 align-items属性设置单元格内容的垂直位置 默认值都是stretch，在没给定子项宽高的情况下，会自动拉伸铺满整个容器\nstretch当项目没设置宽度(高度)或是auto的时候，将会自动占满整个容器。 当项目有宽高度是，默认值为start\n1 justify-items\u0026lt;align-items\u0026gt;: start | end | center | stretch; place-items属性是align-items属性和justify-items属性的简写\n1 place-items: \u0026lt;align-items\u0026gt; \u0026lt;justify-items\u0026gt;; 5. repeat()、auto-fill、minmax() repeat()去简化重复的值 auto-fill关键字表示自动填充 minmax()函数产生一个长度范围，表示长度就在这个范围之中，它接受两个参数，分别为最小值和最大值\n项目属性 1.grid-area 通过grid-area属性就可以指定项目放在哪一个区域，但前提是容器需要使用grid-template-areas属性指定了区域\n1 2 3 4 5 6 .father{ display:grid; grid-template-areas: \u0026#39;a a b\u0026#39;\u0026#39;c d d\u0026#39;\u0026#39;e h i\u0026#39;; } .aaa { grid-area: a; background-color: red; } 1 grid-area: grid-row-start / grid-column-start / grid-row-end / grid-column-end; 2.grid-column-start、grid-column-end和grid-row-start、grid-row-end与span关键字 表示grid子项占据的区域的起始和终止位置，具体方法就是指定项目的四个边框，分别定位在哪根网格线\ngrid-column-start左边框所在的垂直网格线 grid-column-end右边框所在的垂直网格线 grid-row-start上边框所在的水平网格线 grid-row-end下边框所在的水平网格线 1 2 3 4 grid-column-start: 2; grid-column-end: 3; grid-row-start: 2; grid-row-end: 3; 除了使用默认网格线名字，还可以直接命名网格线\n1 2 3 4 5 6 7 8 9 10 grid-template-columns: [col1] 200px [col2] 200px [col3] 200px [col4]; grid-template-rows: [row1] 200px [row2] 200px [row3] 200px [row4]; .aaa { grid-column-start: col2; grid-column-end: col3; grid-row-start: row2; grid-row-end: row3; background-color: red; } span表示跨越，即左右变宽(上下边框)之间跨越多少个网格\n1 2 grid-column-start: 2; grid-column-end: span 2; 3.grid-row、grid-column grid-column属性是grid-column-start和grid-column-end的简写 grid-row属性是grid-row-start和grid-row-end的简写\n1 2 grid-column: \u0026lt;start-line\u0026gt;/ \u0026lt;end-line\u0026gt;; grid-row: \u0026lt;start-line\u0026gt;/ \u0026lt;end-line\u0026gt;; 4.justify-self、align-self、place-self justify-self属性设置单元格内容的水平位置，跟justify-items属性的用法完全一致，但只作用于单个项目 align-self属性设置单元格内容的垂直位置，跟align-items属性的用法完全一致，只作用于单个项目 place-self属性是align-self属性和justify-self属性的简写\n1 2 3 4 justify-self: start | end | center | stretch; align-self: start | end | center | stretch; place-self: \u0026lt;align-self\u0026gt; \u0026lt;justify-self\u0026gt;; 布局案例 栅格化布局 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 .main { display: grid; grid-template-columns: repeat(12, 1fr); grid-template-rows: 200px; grid-auto-rows: 200px; gap: 20px; width: 600px; height: 600px; margin: 50px auto; padding: 20px; background-color: beige; } .item { display: flex; justify-content: center; align-items: center; color: #fff; font-size: 72px; text-align: center; } .col-1 { grid-area: auto/auto/auto/span 1; background-color: red; } .col-2 { grid-area: auto/auto/auto/span 2; background-color: orange; } .col-3 { grid-area: auto/auto/auto/span 3; background-color: green; } .col-4 { grid-area: auto/auto/auto/span 4; background-color: blue; } .col-5 { grid-area: auto/auto/auto/span 5; background-color: pink; } .col-6 { grid-area: auto/auto/auto/span 6; background-color: aqua; } .col-7 { grid-area: auto/auto/auto/span 7; background-color: darkgoldenrod; } .col-8 { grid-area: auto/auto/auto/span 8; background-color: blueviolet; } .col-9 { grid-area: auto/auto/auto/span 9; background-color: darkcyan; } .col-10 { grid-area: auto/auto/auto/span 10; background-color: blueviolet; } .col-11 { grid-area: auto/auto/auto/span 11; background-color: crimson; } .col-12 { grid-area: auto/auto/auto/span 12; background-color: rgb(183, 241, 241); } \u0026lt;div class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item col-6\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item col-4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item col-8\u0026#34;\u0026gt;8\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 不规则子项排列 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 .list { display: grid; grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(4, 1fr); grid-template-areas: \u0026#39;a1 a2 a2\u0026#39;\u0026#39;a3 a2 a2\u0026#39;\u0026#39;a4 a4 a5\u0026#39;\u0026#39;a6 a7 a7\u0026#39;; gap: 20px; width: 600px; height: 800px; margin: 50px auto; padding: 20px; } .item1 { grid-area: a1; background-color: pink; } .item2 { grid-area: a2; background-color: pink; } .item3 { grid-area: a3; background-color: skyblue; } .item4 { grid-area: a4; background-color: pink; } .item5 { grid-area: a5; background-color: pink; } .item6 { grid-area: a6; background-color: orange; } .item7 { grid-area: a7; background-color: orange; } \u0026lt;div class=\u0026#34;list\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item item1\u0026#34;\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item2\u0026#34;\u0026gt;2\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item3\u0026#34;\u0026gt;3\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item4\u0026#34;\u0026gt;4\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item5\u0026#34;\u0026gt;5\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item6\u0026#34;\u0026gt;6\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item item7\u0026#34;\u0026gt;7\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 两栏布局 1 2 3 4 5 6 7 8 9 10 \u0026lt;style\u0026gt; .container{ display: grid; grid-template-columns: 100px auto; /* 或者 100px 1fr */ } \u0026lt;/style\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;aside\u0026gt;\u0026lt;/aside\u0026gt; \u0026lt;main\u0026gt;\u0026lt;/main\u0026gt; \u0026lt;/div\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /*自适应列,每列200px*/ grid-template-columns: repeat(auto-fit,200px); /*5列,每列等宽*/ grid-template-columns: repeat(5, 1fr); /*自适应列,每列最小200px*/ grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); /*第一列100px,二三列按1:2比例*/ grid-template-columns: 100px 1fr 2fr; /*第一列100px,后面列自适应剩余空间*/ grid-template-columns: 100px auto auto auto; /*前面两列11等宽,后面最后一列最小40px，正常情况下是前一列2倍*/ grid-template-columns: 1fr 1fr minmax(40px,2fr); ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/css/","summary":"1.css 选择器 CSS选择器包括行内样式、id选择器、class选择器、标签选择器，优先级依次降低，!important可用于优先级提升，比行内样式","title":"Css库"},{"content":"事件循环概念 JavaScript代码的执行过程中，除了依靠函数调用栈来限制函数的执行顺序外，还要依靠任务队列(task queue)来约束其它代码的执行。整个执行过程，我们称为事件循环过程。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列分为macro-task（宏任务）与micro-task（微任务），在最新标准中，它们被分别称为task与jobs。\n**macro-task大概包括：\nscript(整体代码) setTimeout setInterval setImmediate I/O UI render **micro-task大概包括:\nprocess.nextTick Promise Async/Await(实际就是promise) MutationObserver(html5新特性) 执行顺序：\n执行宏任务，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行微任务，微任务执行完毕后，再回到宏任务中进行下一轮循环。举个例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 async function async1(){ await async2() console.log(\u0026#34;async1 end\u0026#34;) // 入微任务 } async function async2(){ console.log(\u0026#34;async2 end\u0026#34;) } async1() setTimeout(()=\u0026gt;{ console.log(\u0026#39;setTimeout\u0026#39;) // 入宏任务 },0) new Promise(resolve =\u0026gt;{ console.log(\u0026#39;Promise\u0026#39;) resolve() }).then(()=\u0026gt;{ console.log(\u0026#34;promise1\u0026#34;) // 入微任务 }).then(()=\u0026gt;{ console.log(\u0026#34;promise2\u0026#34;) // 入微任务 }) // async2 end -\u0026gt; Promise -\u0026gt; async1 end -\u0026gt; promise1 -\u0026gt; promise2 -\u0026gt;setTimeout async/await执行顺序 我们知道async隐式返回 Promise 作为结果的函数,那么可以简单理解为， await后面的函数执行完毕时，await会产生一个微任务(Promise.then是微任务)。 但是我们要注意这个微任务产生的时机，它是执行完await之后，直接跳出async函数，执行其他代码(此处就是协程的运作，A暂停执行，控制权交给B)。其他代码执行完毕后，再回到async函数去执行剩下的代码，然后把await后面的代码注册到微任务队列当中。我们来看个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 console.log(\u0026#39;script start\u0026#39;) async function async1() { await async2() console.log(\u0026#39;async1 end\u0026#39;) // 入微任务1 } async function async2() { console.log(\u0026#39;async2 end\u0026#39;) } async1() setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;) // 入宏任务1 }, 0) new Promise(resolve =\u0026gt; { console.log(\u0026#39;Promise\u0026#39;) resolve() }) .then(function() { console.log(\u0026#39;promise1\u0026#39;) }) .then(function() { console.log(\u0026#39;promise2\u0026#39;) }) console.log(\u0026#39;script end\u0026#39;) script start -\u0026gt; async2 end -\u0026gt; Promise -\u0026gt; script end -\u0026gt; async1 end -\u0026gt; promise1 -\u0026gt; promise2 -\u0026gt; set // 旧版输出如下，但是请继续看完本文下面的注意那里，新版有改动 // script start =\u0026gt; async2 end =\u0026gt; Promise =\u0026gt; script end =\u0026gt; promise1 =\u0026gt; promise2 =\u0026gt; async1 end =\u0026gt; setTimeout ","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/","summary":"事件循环概念 JavaScript代码的执行过程中，除了依靠函数调用栈来限制函数的执行顺序外，还要依靠任务队列(task queue)来约束其它","title":"事件循环机制"},{"content":"源码实现 基础功能 1 2 3 4 5 6 7 8 9 10 const p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;fulfilled\u0026#39;) reject(\u0026#39;rejected\u0026#39;) }) p.then(value=\u0026gt;{ consolo.log(value) },reason=\u0026gt;{ console.log(reason) }) new Promise 的实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 const PENDING = \u0026#39;pending\u0026#39; const FULFILLED = \u0026#39;fulfilled\u0026#39; const REJECTED = \u0026#39;rejected\u0026#39; class SelfPromise { status = PENDING; //初始状态值pending value = null; //成功之后的值 reason = null; //失败之后的值 // 保存 onFulfilled 回调函数 onFulfilledCallback = null; // 保存 onRejected 回调函数 onRejectedCallback = null; constructor(executor){ executor(this.resolve,this.reject) // 将 resolve 和 reject 传给 new Promsie 的回调函数 } // 箭头函数可以使函数里面的 this 始终指向 Promise 实例对象 resolve = (value) =\u0026gt; { // status 只有是pending 的情况下，才改变为 fulfilled 的状态 if(this.status === PENDING) { this.status = FULFILLED this.value = value; this.onFulfilledCallback \u0026amp;\u0026amp; this.onFulfilledCallback(value); } } reject = (reason) =\u0026gt; { // status 只有是pending 的情况下，才改变为 rejected 的状态 if(this.status === PENDING) { this.status = REJECTED this.reason = reason this.onRejectedCallback \u0026amp;\u0026amp; this.onRejectedCallback(reason) } } then(onFulfilled,onRejected){ if(this.status === FULFILLED){ // 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。 onFulfilled(this.value) }else if(this.status === REJECTED){ // 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。 onRejected(this.reason) }else { // pending 状态下保存回调函数 （处理异步逻辑） this.onFulfilledCallback = onFulFilled this.onRejectedCallback = onRejected } } } then 的多次调用 目前的代码只能输出1个fulfilled，关键在于源码当中 then 方法保存回调函数的方式：\n回调函数会直接保存在 this.onFulfilledCallback 或 this.onRejectedCallback 中，这样就会导致保存的是最后一个 then 方法的回调函数，所以这里不能直接用两个变量来保存，而是用两个数组来保存所有的回调函数，同时 Promise 内部的 resolve 和 reject 方法也需要循环调用所有的回调函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 const PENDING = \u0026#39;pending\u0026#39; const FULFILLED = \u0026#39;fulfilled\u0026#39; const REJECTED = \u0026#39;rejected\u0026#39; class SelfPromise { status = PENDING; //初始状态值pending value = null; //成功之后的值 reason = null; //失败之后的值 // 保存 onFulfilled 回调函数 onFulfilledCallbacks = []; // 保存 onRejected 回调函数 onRejectedCallbacks = []; constructor(executor){ executor(this.resolve,this.reject) // 将 resolve 和 reject 传给 new Promsie 的回调函数 } // 箭头函数可以使函数里面的 this 始终指向 Promise 实例对象 resolve = (value) =\u0026gt; { // status 只有是pending 的情况下，才改变为 fulfilled 的状态 if(this.status === PENDING) { this.status = FULFILLED this.value = value; //this.onFulfilledCallback \u0026amp;\u0026amp; this.onFulfilledCallback(value); // 执行所有的 onFulfilled 回调函数 this.onFulfilledCallbacks.forEach((fn) =\u0026gt; fn(value)); } } reject = (reason) =\u0026gt; { // status 只有是pending 的情况下，才改变为 rejected 的状态 if(this.status === PENDING) { this.status = REJECTED this.reason = reason //this.onRejectedCallback \u0026amp;\u0026amp; this.onRejectedCallback(reason) this.onRejectedCallbacks.forEach((fn) =\u0026gt; fn(reason)); } } then(onFulfilled,onRejected){ if(this.status === FULFILLED){ // 把 resolve 的值传递给 fulfilled 状态的回调函数，并且调用它。 onFulfilled(this.value) }else if(this.status === REJECTED){ // 把 reject 的值传递给 rejected 状态的回调函数，并且调用它。 onRejected(this.reason) }else { // pending 状态下保存回调函数 （处理异步逻辑） this.onFulfilledCallbacks.push(onFulFilled) this.onRejectedCallbacks.push(onRejected) } } } then 方法的链式调用 Promise 最核心的功能就是 then 方法的链式调用，这也是解决回调地狱的关键所在。就目前我们手动实现的代码来看，是不能够进行 then 方法的链式调用的，因为 then 方法没有任何返回值。\n","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/20230814-%E7%9C%9F%E6%AD%A3%E7%90%86%E8%A7%A3promise/","summary":"源码实现 基础功能 1 2 3 4 5 6 7 8 9 10 const p = new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;fulfilled\u0026#39;) reject(\u0026#39;rejected\u0026#39;) }) p.then(value=\u0026gt;{ consolo.log(value) },reason=\u0026gt;{ console.log(reason) }) new Promise 的实现原理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29","title":"真正理解Promise"},{"content":"TypeScript的特性 类型系统 TypeScript是静态类型 （根据类型检查的时机来分类） 动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误。JavaScript 是一门解释型语言，没有编译阶段，所以它是动态类型，以下这段代码在运行时才会报错：\n1 2 3 4 let foo = 1; foo.split(\u0026#39; \u0026#39;); // Uncaught TypeError: foo.split is not a function // 运行时会报错（foo.split 不是一个函数），造成线上 bug 静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 TypeScript 是静态类型，这段 TypeScript 代码在编译阶段就会报错了：\n1 2 3 4 let foo = 1; //类型推断 let foo: number = 1; foo.split(\u0026#39; \u0026#39;); // Property \u0026#39;split\u0026#39; does not exist on type \u0026#39;number\u0026#39;. // 编译时会报错（数字没有 split 方法），无法通过编译 TypeScript / JavaScript 都是弱类型 （根据是否允许隐式类型转换来分类） 安装typescript 1 2 3 npm install -g typescript tsc -v // Version x.x.x TS基础 1.基础类型 布尔值 boolean 1 2 3 4 let isDone: boolean = false; let createdByNewBoolean: Boolean = new Boolean(1); //非布尔值！ 返回的是一个 Boolean对象 let createdByBoolean: Boolean = Boolean(1) // 直接调用可返回一个 boolean 类型 数值 number 1 2 3 4 5 6 7 8 let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; //ES6的二进制表示法 会被编译成十进制 let octalLiteral: number = 0o744; //ES6的八进制表示法 ... let notANumber: number = NaN; let infinityNumber: number = Infinity; 字符串 string 1 2 3 4 5 6 let myName: string = \u0026#39;Tom\u0026#39;; let myAge: number = 25; // 模板字符串 let sentence: string = `Hello, my name is ${myName}. I\u0026#39;ll be ${myAge + 1} years old next month.`; null 和 undefined 在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n1 2 let u: undefined = undefined; let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n1 2 // 这样不会报错 let num: number = undefined; 1 2 3 // 这样也不会报错 let u: undefined; let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量：\n1 2 3 let u: void; let num: number = u; // Type \u0026#39;void\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. 任意值 any 什么是任意值类型 如果是一个普通类型，在赋值过程中改变类型是不被允许的：\n1 2 3 let myFavoriteNumber: string = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. 但如果是 any 类型，则允许被赋值为任意类型。\n1 2 let myFavoriteNumber: any = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 任意值的属性和方法 在任意值上访问任何属性都是允许的：\n1 2 3 let anyThing: any = \u0026#39;hello\u0026#39;; console.log(anyThing.myName); console.log(anyThing.myName.firstName); 也允许调用任何方法：\n1 2 3 4 let anyThing: any = \u0026#39;Tom\u0026#39;; anyThing.setName(\u0026#39;Jerry\u0026#39;); anyThing.setName(\u0026#39;Jerry\u0026#39;).sayHello(); anyThing.myName.setFirstName(\u0026#39;Cat\u0026#39;); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。\n未声明类型的变量 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n1 2 3 4 let something; something = \u0026#39;seven\u0026#39;; something = 7; something.setName(\u0026#39;Tom\u0026#39;); 等价于\n1 2 3 4 let something: any; something = \u0026#39;seven\u0026#39;; something = 7; something.setName(\u0026#39;Tom\u0026#39;); unknow 类型 就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。\n1 2 3 4 5 6 7 8 9 10 11 12 let value: unknown; value = true; // OK value = 42; // OK value = \u0026#34;Hello World\u0026#34;; // OK value = []; // OK value = {}; // OK value = Math.random; // OK value = null; // OK value = undefined; // OK value = new TypeError(); // OK value = Symbol(\u0026#34;type\u0026#34;); // OK 不能将 unknown的值 赋值给其他类型的变量，unknown类型只能被赋值给 any 类型和 unknown 类型本身\n1 2 3 4 5 6 7 8 9 10 let value: unknown; let value1: unknown = value; // OK let value2: any = value; // OK let value3: boolean = value; // Error let value4: number = value; // Error let value5: string = value; // Error let value6: object = value; // Error let value7: any[] = value; // Error let value8: Function = value; // Error **unknown 应用场景\n1 2 3 4 5 6 7 8 // any 写法，不推荐 function divide(param: any) { return param / 2; } // unknown写法，推荐 function divide(param:unknown) { return param as number / 2 } 空值 void void 表示没有任何返回值的函数\n1 2 3 function alertName(): void { alert(\u0026#39;My name is Lv\u0026#39;); } 声明一个 void 类型的变量没用，因为你只能将它赋值为 undefined 和 null（只在 \u0026ndash;strictNullChecks 未指定时）：\n1 let unusable: void = undefined; never 类型 never类型表示的是那些用不存在的值的类型。\n有些情况下值会永不存在，比如，\n如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值，因为抛出异常会直接中断程序运行。 函数中执行无限循环的代码，使得程序永远无法运行到函数返回值那一步。 1 2 3 4 5 6 7 8 9 // 异常 function fn(msg: string): never { throw new Error(msg) } // 死循环 千万别这么写，会内存溢出 function fn(): never { while (true) {} } never 类型是任何类型的子类型，也可以赋值给任何类型。\n1 2 let test1: never; test1 = \u0026#39;lin\u0026#39; // 报错，Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;never\u0026#39; 没有类型是 never 的子类型，没有类型可以赋值给 never 类型（除了 never 本身之外）。 即使 any也不可以赋值给 never 。\n1 2 3 4 let test1: never; let test2: any; test1 = test2 // 报错，Type \u0026#39;any\u0026#39; is not assignable to type \u0026#39;never\u0026#39; 数组的类型 类型+方括号 表示法 1 let fibonacci: number[] = [1, 1, 2, 3, 5]; 数组的项中不允许出现其他的类型：\n1 2 let fibonacci: number[] = [1, \u0026#39;1\u0026#39;, 2, 3, 5]; // Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\n1 2 3 let fibonacci: number[] = [1, 1, 2, 3, 5]; fibonacci.push(\u0026#39;8\u0026#39;); // Argument of type \u0026#39;\u0026#34;8\u0026#34;\u0026#39; is not assignable to parameter of type \u0026#39;number\u0026#39;. 数组泛型 array\u0026lt;elemType\u0026gt; 我们也可以使用数组泛型（Array Generic） Array\u0026lt;elemType\u0026gt;来表示数组：\n1 let fibonacci: Array\u0026lt;number\u0026gt; = [1, 1, 2, 3, 5]; 用接口表示数组 1 2 3 4 interface NumberArray { [index: number]: number; } let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 元组 Tuple 类型 在单个变量中存储不同类型的值\n1 2 let tupleType: [string, boolean]; tupleType = [\u0026#34;semlinker\u0026#34;, true]; 在元组初始化的时候，如果出现类型不匹配的话，比如：\n1 2 3 4 tupleType = [true, \u0026#34;semlinker\u0026#34;]; //报错 [0]: Type \u0026#39;true\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. [1]: Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;boolean\u0026#39;. 在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误。\n可以对元组使用数组的方法，比如使用 push 时，不会有越界报错\n1 2 let tuple: [number, string] = [18, \u0026#39;lin\u0026#39;] tuple.push(100) // 但是只能 push 定义的 number 或者 string 类型 2.函数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 function sum(x: number, y: number): number { return x + y; } //可选参数 function buildName(firstName: string, lastName?: string) { if (lastName) { return firstName + \u0026#39; \u0026#39; + lastName; } else { return firstName; } } let tomcat = buildName(\u0026#39;Tom\u0026#39;, \u0026#39;Cat\u0026#39;); let tom = buildName(\u0026#39;Tom\u0026#39;); //参数默认值 function buildName(firstName: string, lastName: string = \u0026#39;Cat\u0026#39;) { return firstName + \u0026#39; \u0026#39; + lastName; } let tomcat = buildName(\u0026#39;Tom\u0026#39;, \u0026#39;Cat\u0026#39;); let tom = buildName(\u0026#39;Tom\u0026#39;); //剩余参数 ...rest rest 参数只能是最后一个参数 function push(array, ...items) { items.forEach(function(item) { array.push(item); }); } let a: any[] = []; push(a, 1, 2, 3); 函数重载 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。\n利用联合类型，我们可以这么实现：\n1 2 3 4 5 6 7 function reverse(x: number | string): number | string | void { if (typeof x === \u0026#39;number\u0026#39;) { return Number(x.toString().split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)); } else if (typeof x === \u0026#39;string\u0026#39;) { return x.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n这时，我们可以使用重载定义多个 reverse 的函数类型：\n1 2 3 4 5 6 7 8 9 function reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string | void { if (typeof x === \u0026#39;number\u0026#39;) { return Number(x.toString().split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)); } else if (typeof x === \u0026#39;string\u0026#39;) { return x.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。\nTypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n其实写起来挺麻烦的，后面了解泛型之后写起来会简洁一些，不必太纠结函数重载，知道有这个概念即可，平时一般用泛型来解决类似问题。\n3.interface 接口 基本概念 TypeScript 中的接口是一个非常灵活的概念，常用于对「对象的形状（Shape）」进行描述。\n1 2 3 4 5 6 7 8 9 interface Person { name: string; age: number; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, age: 25 }; 定义的变量比接口少了一些属性或多一些属性都是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致\n可选属性 ？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 interface Person { name: string; age?: number; } let tom: Person = { name: \u0026#39;Tom\u0026#39; }; let tom: Person = { name: \u0026#39;Tom\u0026#39;, age:100, gender:\u0026#34;male\u0026#34; //报错 仍然不允许添加未定义的属性 }; 只读属性 readonly 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 interface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { id: 89757, name: \u0026#39;Tom\u0026#39;, gender: \u0026#39;male\u0026#39; }; tom.id = 9527; // index.ts(14,5): error TS2540: Cannot assign to \u0026#39;id\u0026#39; because it is a constant or a read-only property. 只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候\n1 2 3 4 5 6 7 8 9 10 11 12 13 interface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, gender: \u0026#39;male\u0026#39; }; tom.id = 89757; //第一错没有给id初始值，第二错id为只读属性 interface 描述函数类型 interface 也可以用来描述函数类型，代码如下：\n1 2 3 4 5 6 7 interface ISum { (x:number,y:number):number } const add:ISum = (num1, num2) =\u0026gt; { return num1 + num2 } 任意属性 一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\n1 2 3 4 5 6 7 8 9 10 11 interface Person { name: string; age?: number; [propName: string]: string | number; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, age: 25, gender: \u0026#39;male\u0026#39; }; duck typing ( 鸭子类型 ) 1 2 3 4 5 6 7 8 9 10 11 12 13 const fn: FunctionWithProps = (x) =\u0026gt; { return x } fn.fnName = \u0026#39;hello world\u0026#39; //React 的 `FunctionComponent（函数式组件）` interface FunctionComponent\u0026lt;P = {}\u0026gt; { (props: PropsWithChildren\u0026lt;P\u0026gt;, context?: any): ReactElement\u0026lt;any, any\u0026gt; | null; propTypes?: WeakValidationMap\u0026lt;P\u0026gt; | undefined; contextTypes?: ValidationMap\u0026lt;any\u0026gt; | undefined; defaultProps?: Partial\u0026lt;P\u0026gt; | undefined; displayName?: string | undefined; } 4.class 类 类的属性与方法 在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。\n我们可以用Class关键字来定义一个类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person { // 成员属性 name: string //构造函数 - 执行初始化操作 constructor(name: string) { this.name = name } speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lin\u0026#39;) // 新建实例 p1.name // 访问属性和方法 p1.speak() 继承 继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。\n我们可以通过 extends 关键字来实现继承\n1 2 3 4 5 6 7 8 9 class Student extends Person { study() { console.log(`${this.name} needs study`) } } const s1 = new Student(\u0026#39;lin\u0026#39;) s1.study() super关键字 注意，上例中 Student 类没有定义自己的属性，可以不写 super ，但是如果 Student 类有自己的属性，就要用到 super 关键字来把父类的属性继承过来。\n比如，Student 类新增一个 grade(成绩) 属性，就要这么写：\n1 2 3 4 5 6 7 8 9 10 11 class Student extends Person { grade: number constructor(name: string,grade:number) { super(name) this.grade = grade } } const s1 = new Student(\u0026#39;lin\u0026#39;, 100) //不写 super 会报错。 多态 子类对父类的方法进行了重写，子类和父类调同一个方法时会不一样。\n1 2 3 4 5 class Student extends Person { speak() { return `Student ${super.speak()}` } } 私有字段 与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：\n私有字段以 # 字符开头，有时我们称之为私有名称； 每个私有字段名称都唯一地限定于其包含的类； 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）； 私有字段不能在包含的类之外访问，甚至不能被检测到。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person { #name: string; //私有字段 constructor(name: string) { this.#name = name; } greet() { console.log(`Hello, my name is ${this.#name}!`); } } let semlinker = new Person(\u0026#34;Semlinker\u0026#34;); semlinker.#name; // ~~~~~ // Property \u0026#39;#name\u0026#39; is not accessible outside class \u0026#39;Person\u0026#39; // because it has a private identifier. 只属于类自己 它的实例能否访问 继承它的子类能否访问 public 公有的 能 能 private 私有的 是 不能 不能 protected 受保护的 不能 能 static 不能 能 private\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Person { private name: string public constructor(name: string) { this.name = name } public speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lv\u0026#39;) p1.name //报错 “name” is private... class Student extends Person { study(){ console.log(`${this.name} needs study`) //报错 “name” is private... } } protected\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Person { protected name: string public constructor(name: string) { this.name = name } public speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lv\u0026#39;) p1.name //报错 “name” is protected... class Student extends Person { study(){ console.log(`${this.name} needs study`) } } 访问器 我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 let passcode = \u0026#34;Hello TypeScript\u0026#34;; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode \u0026amp;\u0026amp; passcode == \u0026#34;Hello TypeScript\u0026#34;) { this._fullName = newName; } else { console.log(\u0026#34;Error: Unauthorized update of employee!\u0026#34;); } } } let employee = new Employee(); employee.fullName = \u0026#34;Semlinker\u0026#34;; if (employee.fullName) { console.log(employee.fullName); } 抽象类 使用 abstract 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多个抽象方法。所谓的抽象方法，是指不包含具体实现的方法：\n1 2 3 4 5 6 7 8 abstract class Person { constructor(public name: string){} abstract say(words: string) :void; } // Cannot create an instance of an abstract class.(2511) const lolo = new Person(); // Error 抽象类不能被直接实例化，我们只能实例化实现了所有抽象方法的子类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 abstract class Person { constructor(public name: string){} // 抽象方法 abstract say(words: string) :void; } class Developer extends Person { constructor(name: string) { super(name); } say(words: string): void { console.log(`${this.name} says ${words}`); } } const lolo = new Developer(\u0026#34;lolo\u0026#34;); lolo.say(\u0026#34;I love ts!\u0026#34;); // lolo says I love ts! 类方法重载 对于类的方法来说，它也支持重载。比如，示例中我们重载了 ProductService 类的 getProducts 成员方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class ProductService { getProducts(): void; getProducts(id: number): void; getProducts(id?: number) { if(typeof id === \u0026#39;number\u0026#39;) { console.log(`获取id为 ${id} 的产品信息`); } else { console.log(`获取所有的产品信息`); } } } const productService = new ProductService(); productService.getProducts(666); // 获取id为 666 的产品信息 productService.getProducts(); // 获取所有的产品信息 5.interface 和 class 的关系 interface 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。 interface 同样可以用来约束 class，要实现约束，需要用到 implements 关键字。\nimplements implements 是实现的意思，class 实现 interface。\n比如手机有播放音乐的功能，可以这么写：\n1 2 3 4 5 6 7 interface MusicInterface { playMusic(): void } class Cellphone implements MusicInterface { playMusic() {} // 如果 Cellphone 类上不写 playMusic 方法，会报错。 } 定义了约束后，class 必须要满足接口上的所有条件。\n处理公共的属性和方法 不同的类有一些共同的属性和方法，使用继承很难完成。\n比如汽车（Car 类）也有播放音乐的功能，你可以这么做：\n用 Car 类继承 Cellphone 类 找一个 Car 类和 Cellphone 类的父类，父类有播放音乐的方法，他们俩继承这个父类 很显然这两种方法都不合常理。\n实际上，使用 implements，问题就会迎刃而解\n1 2 3 4 5 6 7 8 9 10 11 interface MusicInterface { playMusic(): void } //Car 类和 Cellphone 类都约束了播放音乐的功能。 class Car implements MusicInterface { playMusic() {} } class Cellphone implements MusicInterface { playMusic() {} } 再比如，手机还有打电话的功能，就可以这么做，Cellphone 类 implements 两个 interface。\n1 2 3 4 5 6 7 8 9 10 11 12 interface MusicInterface { playMusic(): void } interface CallInterface { makePhoneCall(): void } class Cellphone implements MusicInterface, CallInterface { playMusic() {} makePhoneCall() {} } interface 来约束 class，class 实现了 interface 规定的属性或方法，没有继承那么多条条框框，非常灵活。\n约束构造函数和静态属性 使用 implements 只能约束类实例上的属性和方法，要约束构造函数和静态属性，需要这么写。\n以我们上文提过的 Circl 类为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 interface CircleStatic { new (radius: number): void pi: number } const Circle:CircleStatic = class Circle { static pi: 3.14 public radius: number public constructor(radius: number) { this.radius = radius } } const Circle:CircleStatic = class Circle { public radius: number //未定义静态属性 pi，会报错： \u0026#39;pi\u0026#39; is missing public constructor(radius:string){ //constructor 入参类型不对，会报错： type \u0026#39;number\u0026#39; is not... to type \u0026#39;string\u0026#39; this.radius = radius } } 6.Enum 枚举类型 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。\n数字枚举 1 2 3 4 5 6 7 8 enum Direction { NORTH, //0 SOUTH, EAST, WEST, //3 } let dir: Direction = Direction.NORTH; 设置 NORTH 的初始值，比如：\n1 enum Direction { NORTH = 3, SOUTH, EAST, WEST, }` 字符串枚举 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\n1 2 3 4 5 6 enum Direction { NORTH = \u0026#34;NORTH\u0026#34;, SOUTH = \u0026#34;SOUTH\u0026#34;, EAST = \u0026#34;EAST\u0026#34;, WEST = \u0026#34;WEST\u0026#34;, } 异构枚举 1 2 3 4 5 6 7 8 9 10 11 12 enum Enum { A, B, C = \u0026#34;C\u0026#34;, D = \u0026#34;D\u0026#34;, E = 8, F, } //反向映射 console.log(Enum.A) //输出：0 console.log(Enum[0]) // 输出：A 7.类型推论 TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\n1 2 3 4 let myFavoriteNumber = \u0026#39;seven\u0026#39;; // let myFavoriteNumber: string = \u0026#39;seven\u0026#39; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查\n1 2 3 let myFavoriteNumber; myFavoriteNumber = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 虽然 TS 可以推导出最合适的类型，但最好还是在写的时候就定义好类型，下面的例子，可以用ts这么写：\n1 2 3 4 5 6 // let arr = [0, 1, null, \u0026#39;lin\u0026#39;]; type arrItem = number | string | null let arr: arrItem[] = [0, 1, null, \u0026#39;lin\u0026#39;]; let pets: Pets[] = [new Dog(), new Cat()] 8.内置类型 JS 八种内置类型 1 2 3 4 5 6 7 8 let name: string = \u0026#34;lin\u0026#34;; let age: number = 18; let isHandsome: boolean = true; let u: undefined = undefined; let n: null = null; let obj: object = {name: \u0026#39;lin\u0026#39;, age: 18}; let big: bigint = 100n; let sym: symbol = Symbol(\u0026#34;lin\u0026#34;); ECMAScript 的内置对象 比如，Array、Date、Error 等\n1 2 3 4 5 const nums: Array\u0026lt;number\u0026gt; = [1,2,3] const date: Date = new Date() const err: Error = new Error(\u0026#39;Error!\u0026#39;); const reg: RegExp = /abc/; Math.pow(2, 9) DOM 和 BOM 比如 HTMLElement、NodeList、MouseEvent 等\n1 2 3 4 5 6 7 8 let body: HTMLElement = document.body let allDiv: NodeList = document.querySelectorAll(\u0026#39;div\u0026#39;); document.addEventListener(\u0026#39;click\u0026#39;, (e: MouseEvent) =\u0026gt; { e.preventDefault() // Do something }); TS 进阶 1.高级类型（一） 联合类型 联合类型表示可以取值为多类型中的一种\n1 2 3 let myFavoriteNumber: string | number; myFavoriteNumber = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 只能访问此联合类型的所有类型里共有的属性或方法：\n1 2 3 4 5 6 function getLength(something: string | number): number { return something.length; } // index.ts(2,22): error TS2339: Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;string | number\u0026#39;. // Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;number\u0026#39;. 上例中，length 不是 string 和 number 的共有属性，所以会报错。 访问 string 和 number 的共有属性是没问题的：\n1 2 3 function getString(something: string | number): string { return something.toString(); } 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型\n1 2 3 4 5 6 7 let myFavoriteNumber: string | number; myFavoriteNumber = \u0026#39;seven\u0026#39;; console.log(myFavoriteNumber.length); // 5 被推断为string myFavoriteNumber = 7; console.log(myFavoriteNumber.length); // 编译时报错 被推断为number // index.ts(5,30): error TS2339: Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;number\u0026#39;. 交叉类型 \u0026amp; 运算符 在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 \u0026amp; 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\n1 2 3 4 5 6 interface Person { name: string age: number } type Student = Person \u0026amp; { grade: number } 联合类型 | 是指可以取几种类型中的任意一种，而交叉类型 \u0026amp; 是指把几种类型合并起来。\n交叉类型和 interface 的 extends 非常类似，都是为了实现对象形状的组合和扩展。\n类型别名（ type ） 类型别名（type aliase），听名字就很好理解，就是给类型起个别名。\n就像 NBA 球员 扬尼斯-阿德托昆博，名字太长难记，我们叫他字母哥。\n就像我们项目中配置 alias，不用写相对路径就能很方便地引入文件\n1 2 3 import componentA from \u0026#39;../../../../components/componentA/index.vue\u0026#39; 变成 import componentA from \u0026#39;@/components/componentA/index.vue 类型别名用 type 关键字来书写，有了类型别名，我们书写 TS 的时候可以更加方便简洁。\n比如下面这个例子，getName 这个函数接收的参数可能是字符串，可能是函数，就可以这么写。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 type Name = string type NameResolver = () =\u0026gt; string type NameOrResolver = Name | NameResolver // 联合类型 function getName(n: NameOrResolver): Name { if (typeof n === \u0026#39;string\u0026#39;) { return n } else { return n() } } getName(\u0026#39;lin\u0026#39;) getName(() =\u0026gt; \u0026#39;lin\u0026#39;) 类型别名的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 type Name = string // 基本类型 type arrItem = number | string // 联合类型 const arr: arrItem[] = [1,\u0026#39;2\u0026#39;, 3] type Person = { name: Name } type Student = Person \u0026amp; { grade: number } // 交叉类型 type Teacher = Person \u0026amp; { major: string } type StudentAndTeacherList = [Student, Teacher] // 元组类型 const list:StudentAndTeacherList = [ { name: \u0026#39;lin\u0026#39;, grade: 100 }, { name: \u0026#39;liu\u0026#39;, major: \u0026#39;Chinese\u0026#39; } ] 接口与类型别名的区别 共同点 都可以用来描述对象或函数签名： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //接口 interface Point { x: number; y: number; } interface SetPoint { (x: number, y: number): void; } //类型别名 type Point = { x: number; y: number; }; type SetPoint = (x: number, y: number) =\u0026gt; void; 都允许继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // interface 继承 interface interface PartialPointX { x: number; } interface Point extends PartialPointX { y: number; } // type 继承 type type PartialPointX = { x: number; }; type Point = PartialPointX \u0026amp; { y: number; }; // interface 继承 type type Person = { name: string } interface Student extends Person { \u0026#34;interface用 extends 来继承\u0026#34; grade: number } // type 继承 interface interface Person { name: string } type Student = Person \u0026amp; { grade: number } \u0026#34;type用交叉类型来继承\u0026#34; 不同点 设计角度 interface（接口） 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。\ntype 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\ntype 用于其它类型 与 interface 不一样，**type 可以声明基本类型、联合类型、交叉类型、元组\n1 2 3 4 5 6 7 8 9 10 11 12 // primitive type Name = string; // object type PartialPointX = { x: number; }; type PartialPointY = { y: number; }; // union type PartialPoint = PartialPointX | PartialPointY; // tuple type Data = [number, string]; interface可以合并重复声明，type 不行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 interface Person { name: string } interface Person { // 重复声明 interface，就合并了 age: number } const person: Person = { name: \u0026#39;lin\u0026#39;, age: 18 } type Person = { name: string } type Person = { // 报错，Duplicate identifier \u0026#39;Person\u0026#39; age: number } const person: Person = { name: \u0026#39;lin\u0026#39;, age: 18 } Implements 类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 interface Point { x: number; y: number; } class SomePoint implements Point { x = 1; y = 2; } type Point2 = { x: number; y: number; }; class SomePoint2 implements Point2 { x = 1; y = 2; } // 错误示例 type PartialPoint = { x: number; } | { y: number; }; // A class can only implement an object type or // intersection of object types with statically known members. class SomePartialPoint implements PartialPoint { // Error x = 1; y = 2; } 这两者的区别说了这么多，其实本不该把这两个东西拿来做对比，他们俩是完全不同的概念。\ninterface 是接口，用于描述一个对象。\ntype 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\n只是有时候两者都能实现同样的功能，才会经常被混淆\n平时开发中，一般使用组合或者交叉类型的时候，用 type。\n一般要用类的 extends 或 implements 时，用 interface。\n其他情况，比如定义一个对象或者函数，就看你心情了。\n类型保护 如果有一个 getLength 函数，入参是联合类型 number | string，返回入参的 length，\n1 2 3 function getLength(arg: number | string): number { return arg.length } 从上文可知，这么写会报错，因为 number 类型上没有 length 属性。\n这个时候，类型保护（Type Guards）出现了，可以使用 typeof 关键字判断变量的类型。\n我们把 getLength 方法改造一下，就可以精准地获取到 string 类型的 length 属性了，\n1 2 3 4 5 6 7 function getLength(arg: number | string): number { if(typeof arg === \u0026#39;string\u0026#39;) { return arg.length } else { return arg.toString().length } } 类型断言 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n尖括号语法 1 2 let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (\u0026lt;string\u0026gt;someValue).length; as语法 1 2 let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (someValue as string).length; 注意，类型断言不是类型转换，把一个类型断言成联合类型中不存在的类型会报错。 字面量类型 有时候，我们需要定义一些常量，就需要用到字面量类型，比如，\n1 2 3 4 5 type ButtonSize = \u0026#39;mini\u0026#39; | \u0026#39;small\u0026#39; | \u0026#39;normal\u0026#39; | \u0026#39;large\u0026#39; type Sex = \u0026#39;男\u0026#39; | \u0026#39;女\u0026#39; const theSet: Sex = \u0026#34;不男不女\u0026#34; // Type \u0026#39;不男不女\u0026#39; is not assignable to type \u0026#39;sex\u0026#39; 这样就只能从这些定义的常量中取值，乱取值会报错。\n2.泛型 泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。\n它可以轻松解决输入输出要一致的问题。\n泛型基本使用 处理函数参数 其中 T 代表 Type，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。除了 T 之外，以下是常见泛型变量代表的意思：\nK（Key）：表示对象中的键类型； V（Value）：表示对象中的值类型； E（Element）：表示元素类型。 其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数：\n1 2 3 4 5 function identity \u0026lt;T, U\u0026gt;(value: T, message: U) : T { console.log(message); return value; } console.log(identity\u0026lt;Number, string\u0026gt;(68, \u0026#34;Semlinker\u0026#34;)); TS 类型推断，自动推导出类型。\n1 console.log(identity(68, \u0026#34;Semlinker\u0026#34;)); **ype 和 interface 都可以定义函数类型，也用泛型来写一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // type type Print = \u0026lt;T\u0026gt;(arg: T) =\u0026gt; T const printFn:Print = function print(arg) { console.log(arg) return arg } // interface interface Iprint\u0026lt;T\u0026gt; { (arg: T): T } function print\u0026lt;T\u0026gt;(arg:T) { console.log(arg) return arg } const myPrint: Iprint\u0026lt;number\u0026gt; = print 默认参数 1 2 3 4 5 6 7 8 9 10 interface Iprint\u0026lt;T = number\u0026gt; { (arg: T): T } function print\u0026lt;T\u0026gt;(arg:T) { console.log(arg) return arg } const myPrint: Iprint = print 处理多个函数参数 传入一个只有两项的元组，交换元组的第 0 项和第 1 项，返回这个元组。\n1 2 3 4 5 6 7 function swap\u0026lt;T,U\u0026gt;(tuple:[T,U]):[U,T]{ return [tuple[1], tuple[0]] } const swap = \u0026lt;T,U\u0026gt;(tuple:[T,U]): [U,T] =\u0026gt;{ return [tuple[1],tuple[0]] } 函数副作用操作 调用 API 都清晰的知道返回类型是什么数据结构\n1 2 3 4 5 6 7 8 9 10 11 12 interface UserInfo { name: string age: number } function request\u0026lt;T\u0026gt;(url:string): Promise\u0026lt;T\u0026gt; { return fetch(url).then(res =\u0026gt; res.json()) } request\u0026lt;UserInfo\u0026gt;(\u0026#39;user/info\u0026#39;).then(res =\u0026gt;{ console.log(res) }) 约束泛型 假设现在有这么一个函数，打印传入参数的长度，我们这么写：\n1 2 3 4 function printLength\u0026lt;T\u0026gt;(arg: T): T { console.log(arg.length) //不确定 T 是否有 length 属性，会报错： property \u0026#39;length\u0026#39; does not ... return arg } 那么现在我想约束这个泛型，一定要有 length 属性，怎么办？\n可以和 interface 结合，来约束类型。\n1 2 3 4 5 6 7 8 interface ILength { length: number } function printLength\u0026lt;T extends ILength\u0026gt;(arg: T): T { console.log(arg.length) return arg } 泛型的一些应用 **泛型约束类 定义一个栈，有入栈和出栈两个方法，如果想入栈和出栈的元素类型统一，就可以这么写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Stack\u0026lt;T\u0026gt; { private data: T[] = [] push(item:T) { return this.data.push(item) } static pop():T | undefined { //给pop方法定义 static 关键字，报错 return this.data.pop() \u0026#39;泛型无法约束类的静态成员\u0026#39; } } const stack = new Stack\u0026lt;string\u0026gt;() stack.push(\u0026#39;124\u0026#39;) stack.push(123) // 类型number 不能复制给string stack.pop() **泛型约束接口 1 2 3 4 5 6 7 interface IKeyValue\u0026lt;T, U\u0026gt; { key: T value: U } const k1:IKeyValue\u0026lt;number, string\u0026gt; = { key: 18, value: \u0026#39;lin\u0026#39;} const k2:IKeyValue\u0026lt;string, number\u0026gt; = { key: \u0026#39;lin\u0026#39;, value: 18} **泛型定义数组 1 2 3 4 5 //之前我们这么写 const arr: number[] = [1,2,3] //现在可以这样写 const arr: Array\u0026lt;number\u0026gt; = [1,2,3] 小结 泛型的好处 函数和类可以轻松地支持多种类型，增强程序的拓展性\n不必写冗长的联合类型，增强代码的可读性\n灵活控制类型之间的约束\n泛型接口 1 2 3 interface GenericIdentityFn\u0026lt;T\u0026gt; { (arg: T): T; } 泛型类 1 2 3 4 5 6 7 8 9 10 class GenericNumber\u0026lt;T\u0026gt; { zeroValue: T; add: (x: T, y: T) =\u0026gt; T; } let myGenericNumber = new GenericNumber\u0026lt;number\u0026gt;(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function (x, y) { return x + y; }; 泛型工具类型 3.高级类型（二） 索引类型 从对象中抽取一些属性的值，然后拼接成数组，可以这么写\n1 2 3 4 5 6 7 8 9 10 11 12 13 const userInfo = { name: \u0026#39;lin\u0026#39;, age: \u0026#39;18\u0026#39;, } function getValues(userInfo: any, keys: string[]) { return keys.map(key =\u0026gt; userInfo[key]) } // 抽取指定属性的值 console.log(getValues(userInfo, [\u0026#39;name\u0026#39;,\u0026#39;age\u0026#39;])) // [\u0026#39;lin\u0026#39;, \u0026#39;18\u0026#39;] // 抽取obj中没有的属性: console.log(getValues(userInfo, [\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;])) // [undefined, undefined] keyof（索引查询） keyof 操作符用于获取某种类型的所有键，其返回类型是联合类型。\n1 2 3 4 5 6 7 8 interface Person { name: string; age: number; } type K1 = keyof Person; // \u0026#34;name\u0026#34; | \u0026#34;age\u0026#34; type K2 = keyof Person[]; // \u0026#34;length\u0026#34; | \u0026#34;toString\u0026#34; | \u0026#34;pop\u0026#34; | \u0026#34;push\u0026#34; | \u0026#34;concat\u0026#34; | \u0026#34;join\u0026#34; type K3 = keyof { [x: string]: Person }; // string | number T[K]（索引访问） T[K]，表示接口 T 的属性 K 所代表的类型\n1 2 3 4 5 6 7 interface IPerson { name: string; age: number; } let type1: IPerson[\u0026#39;name\u0026#39;] // string let type2: IPerson[\u0026#39;age\u0026#39;] // number extends (泛型约束) T extends U，表示泛型变量可以通过继承某个类型，获得某些属性。\n1 2 3 4 5 6 7 8 interface Lengthwise { length: number; } function loggingIdentity\u0026lt;T extends Lengthwise\u0026gt;(arg: T): T { console.log(arg.length); return arg; } 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\n1 loggingIdentity(3); // Error, number doesn\u0026#39;t have a .length property 这时我们需要传入符合约束类型的值，必须包含必须的属性\n1 loggingIdentity({length: 10, value: 3}); 检查动态属性 对 getValue 函数进行改造，实现对象上动态属性的检查。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //改造前 const userInfo = { name: \u0026#39;lin\u0026#39;, age: \u0026#39;18\u0026#39;, } function getValues(userInfo: any, keys: string[]) { return keys.map(key =\u0026gt; userInfo[key]) } // 抽取指定属性的值 console.log(getValues(userInfo, [\u0026#39;name\u0026#39;,\u0026#39;age\u0026#39;])) // [\u0026#39;lin\u0026#39;, \u0026#39;18\u0026#39;] // 抽取obj中没有的属性: console.log(getValues(userInfo, [\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;])) // [undefined, undefined] //改造后 - 定义泛型 T、K，用于约束 userInfo 和 keys - 为 K 增加一个泛型约束,使 K 继承 userInfo 的所有属性的联合类型, 即`K extends keyof T` function getValues\u0026lt;T, K extends keyof T\u0026gt;(userInfo: T, keys: K[]): T[K][] { return keys.map(key =\u0026gt; userInfo[key]) } getValues(userInfo,[\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;]) //这样当我们指定不在对象里的属性时，就会报错，Type \u0026#39;sex\u0026#39; is not assignable to type \u0026#39;\u0026#34;name\u0026#34;|\u0026#34;age\u0026#34;\u0026#39; 映射类型 TS允许将一个类型映射成另外一个类型。\nin in 用来遍历枚举类型\n1 2 3 4 5 type Keys = \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; type Obj = { [p in Keys]: any } // -\u0026gt; { a: any, b: any, c: any } Partial Partial\u0026lt;T\u0026gt; 的作用就是将某个类型里的属性全部变为可选项 ?。\n1 2 3 4 5 6 7 /** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; 示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 interface Todo { title: string; description: string; } function updateTodo(todo: Todo, fieldsToUpdate: Partial\u0026lt;Todo\u0026gt;) { return { ...todo, ...fieldsToUpdate }; } const todo1 = { title: \u0026#34;Learn TS\u0026#34;, description: \u0026#34;Learn TypeScript\u0026#34;, }; const todo2 = updateTodo(todo1, { description: \u0026#34;Learn TypeScript Enum\u0026#34;, }); 上面的 updateTodo 方法中，我们利用 Partial\u0026lt;T\u0026gt; 工具类型，定义 fieldsToUpdate 的类型为 Partial\u0026lt;Todo\u0026gt;，即：\n1 2 3 4 { title?: string | undefined; description?: string | undefined; } Partial 原理\nPartial 的实现用到了 in 和 keyof\n1 2 3 4 5 6 /** * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P] } [P in keyof T]遍历T上的所有属性 ?:设置属性为可选的 T[P]设置类型为原来的类型 Readonly Readonly\u0026lt;T\u0026gt;将T的所有属性映射为只读的，例如：\n1 2 3 4 5 6 7 8 9 10 11 12 interface IPerson { name: string age: number } type IReadOnly = Readonly\u0026lt;IPerson\u0026gt; let p1: IReadOnly = { name: \u0026#39;lin\u0026#39;, age: 18 } p1.name = \u0026#39;lv\u0026#39; //报错，Cannot assign to \u0026#39;name\u0026#39; because it is a read-only property. **Readonly 原理\n和 Partial 几乎完全一样\n1 2 3 4 5 6 /** * Make all properties in T readonly */ type Readonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P] } typeof typeof 操作符用来获取一个变量声明或对象的类型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 interface Person { name: string; age: number; } const sem: Person = { name: \u0026#39;semlinker\u0026#39;, age: 33 }; type Sem= typeof sem; // -\u0026gt; Person function toArray(x: number): Array\u0026lt;number\u0026gt; { return [x]; } type Func = typeof toArray; // -\u0026gt; (x: number) =\u0026gt; number[] 条件类型 工具类型（Utility Types） 类型体操是什么？ 4.TS声明文件 TS 实战 todolist 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 \u0026lt;div style=\u0026#34;padding: 50px; background: pink\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;todoMsg\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;clearHasDone\u0026#34;\u0026gt;清理\u0026lt;/button\u0026gt; \u0026lt;div v-if=\u0026#34;lists.length\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;(item, index) in lists\u0026#34; :key=\u0026#34;item.msg\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;item.done\u0026#34; /\u0026gt; \u0026lt;span :class=\u0026#34;{ done: item.done }\u0026#34;\u0026gt;{{ item.msg }}\u0026lt;/span\u0026gt; \u0026lt;span @click=\u0026#34;deleteItem(index)\u0026#34;\u0026gt;❎\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;全选\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;isAllDone\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ hasDone }} / {{ lists.length }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;暂无数据\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; import { ElMessage } from \u0026#34;element-plus\u0026#34;; import { ref, computed } from \u0026#34;vue\u0026#34;; interface listType { done: boolean; msg: string; } const lists = ref\u0026lt;listType[]\u0026gt;([ { msg: \u0026#34;吃饭\u0026#34;, done: true }, { msg: \u0026#34;睡觉\u0026#34;, done: false }, { msg: \u0026#34;打游戏\u0026#34;, done: false } ]); const todoMsg = ref\u0026lt;string\u0026gt;(\u0026#34;\u0026#34;); const add = () =\u0026gt; { if (!todoMsg.value) { ElMessage.error(\u0026#34;请输入相关值！\u0026#34;); return; } let params: listType = { done: false, msg: todoMsg.value }; lists.value.push(params); todoMsg.value = \u0026#34;\u0026#34;; }; const clearHasDone = () =\u0026gt; { lists.value = lists.value.filter(item =\u0026gt; !item.done); }; const deleteItem = (index: number) =\u0026gt; { lists.value.splice(index, 1); }; const hasDone = computed(() =\u0026gt; { return lists.value.filter(item =\u0026gt; item.done).length; }); const isAllDone = computed\u0026lt;boolean\u0026gt;({ // 所有的事项是否完成，双向绑定到全选按钮 get() { // isAllDone 的获取方法，用于双向绑定数据 return hasDone.value === lists.value.length; }, set(value: boolean) { // isAllDone 的更改方法，用于实现全选 和 取消全选功能 lists.value.forEach(item =\u0026gt; { item.done = value; }); } }); 泛型约束后端接口参数类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 import axios from \u0026#39;axios\u0026#39; interface API { \u0026#39;/book/detail\u0026#39;: { id: number, }, \u0026#39;/book/comment\u0026#39;: { id: number comment: string } ... } function request\u0026lt;T extends keyof API\u0026gt;(url: T, obj: API[T]) { return axios.post(url, obj) } request(\u0026#39;/book/comment\u0026#39;, { id: 1, comment: \u0026#39;非常棒！\u0026#39; }) TS 封装 axios 请求 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 import { HttpResponse } from \u0026#39;@/common/interface\u0026#39; import Taro from \u0026#39;@tarojs/taro\u0026#39; import publicConfig from \u0026#39;@/config/index\u0026#39; import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, Canceler } from \u0026#39;axios-miniprogram\u0026#39; import errorHandle from \u0026#39;../common/errorHandle\u0026#39; const CancelToken = axios.CancelToken class HttpRequest { private baseUrl: string private pending: Record\u0026lt;string, Canceler\u0026gt; constructor(baseUrl: string) { this.baseUrl = baseUrl this.pending = {} } // 获取axios配置 getInsideConfig() { const config = { baseURL: this.baseUrl, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json;charset=utf-8\u0026#39; }, timeout: 10000 } return config } removePending(key: string, isRequest = false) { if (this.pending[key] \u0026amp;\u0026amp; isRequest) { this.pending[key](\u0026#39;取消重复请求\u0026#39;) } delete this.pending[key] } // 设定拦截器 interceptors(instance: AxiosInstance) { instance.interceptors.request.use( config =\u0026gt; { let isPublic = false publicConfig.publicPath.map(path =\u0026gt; { isPublic = isPublic || path.test(config.url || \u0026#39;\u0026#39;) }) const token = Taro.getStorageSync(\u0026#39;token\u0026#39;) if (!isPublic \u0026amp;\u0026amp; token) { config.headers.Authorization = \u0026#39;Bearer \u0026#39; + token } const key = config.url + \u0026#39;\u0026amp;\u0026#39; + config.method this.removePending(key, true) config.cancelToken = new CancelToken(c =\u0026gt; { this.pending[key] = c }) return config }, err =\u0026gt; { errorHandle(err) return Promise.reject(err) } ) // 响应请求的拦截器 instance.interceptors.response.use( res =\u0026gt; { const key = res.config.url + \u0026#39;\u0026amp;\u0026#39; + res.config.method this.removePending(key) if (res.status === 200) { return Promise.resolve(res.data) } else { return Promise.reject(res) } }, err =\u0026gt; { errorHandle(err) return Promise.reject(err) } ) } // 创建实例 request(options: AxiosRequestConfig) { const instance = axios.create() const newOptions = Object.assign(this.getInsideConfig(), options) this.interceptors(instance) return instance(newOptions) } get(url: string, config?: AxiosRequestConfig): Promise\u0026lt;AxiosResponse\u0026gt; | Promise\u0026lt;HttpResponse\u0026gt; { const options = Object.assign( { method: \u0026#39;get\u0026#39;, url: url }, config ) return this.request(options) } post(url: string, data?: unknown): Promise\u0026lt;AxiosResponse\u0026gt; | Promise\u0026lt;HttpResponse\u0026gt; { return this.request({ method: \u0026#39;post\u0026#39;, url: url, data: data }) } } export default HttpRequest waiting 七、TypeScript 数组 **数组解构\n1 2 3 let x: number; let y: number; let z: number; let five_array = [0,1,2,3,4]; [x,y,z] = five_array; **数组展开运算符\n1 2 let two_array = [0, 1]; let five_array = [...two_array, 2, 3, 4]; **数组遍历\n1 2 3 4 5 let colors: string[] = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;]; for (let i of colors) { //获取每一个对象 console.log(i); } // for (let i in colors) 获取下标 八、TypeScript 对象 1 2 3 4 5 6 //公共数组 let person = { name: \u0026#34;Semlinker\u0026#34;, gender: \u0026#34;Male\u0026#34;, address: \u0026#34;Xiamen\u0026#34;, }; **对象解构\n1 let {name, gender} = person **对象展开运算符\n组装对象 1 let personWithAge = { ...person, age: 33 }; 获取除了某些项外的其它项 1 let { name, ...rest } = person; 十三、配置文件 tsconfig.json 作用： 用于标识 TypeScript 项目的根路径； 用于配置 TypeScript 编译器； 用于指定编译的文件。 重要字段 files - 设置要编译的文件的名称； include - 设置需要进行编译的文件，支持路径模式匹配； exclude - 设置无需进行编译的文件，支持路径模式匹配； compilerOptions - 设置与编译流程相关的选项 compilerOptions 选项 compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。\ncompilerOptions 每个选项的详细说明如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 { \u0026#34;compilerOptions\u0026#34;: { /* 基本选项 */ \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, // 指定 ECMAScript 目标版本: \u0026#39;ES3\u0026#39; (default), \u0026#39;ES5\u0026#39;, \u0026#39;ES6\u0026#39;/\u0026#39;ES2015\u0026#39;, \u0026#39;ES2016\u0026#39;, \u0026#39;ES2017\u0026#39;, or \u0026#39;ESNEXT\u0026#39; \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, // 指定使用模块: \u0026#39;commonjs\u0026#39;, \u0026#39;amd\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;umd\u0026#39; or \u0026#39;es2015\u0026#39; \u0026#34;lib\u0026#34;: [], // 指定要包含在编译中的库文件 \u0026#34;allowJs\u0026#34;: true, // 允许编译 javascript 文件 \u0026#34;checkJs\u0026#34;: true, // 报告 javascript 文件中的错误 \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, // 指定 jsx 代码的生成: \u0026#39;preserve\u0026#39;, \u0026#39;react-native\u0026#39;, or \u0026#39;react\u0026#39; \u0026#34;declaration\u0026#34;: true, // 生成相应的 \u0026#39;.d.ts\u0026#39; 文件 \u0026#34;sourceMap\u0026#34;: true, // 生成相应的 \u0026#39;.map\u0026#39; 文件 \u0026#34;outFile\u0026#34;: \u0026#34;./\u0026#34;, // 将输出文件合并为一个文件 \u0026#34;outDir\u0026#34;: \u0026#34;./\u0026#34;, // 指定输出目录 \u0026#34;rootDir\u0026#34;: \u0026#34;./\u0026#34;, // 用来控制输出目录结构 --outDir. \u0026#34;removeComments\u0026#34;: true, // 删除编译后的所有的注释 \u0026#34;noEmit\u0026#34;: true, // 不生成输出文件 \u0026#34;importHelpers\u0026#34;: true, // 从 tslib 导入辅助工具函数 \u0026#34;isolatedModules\u0026#34;: true, // 将每个文件做为单独的模块 （与 \u0026#39;ts.transpileModule\u0026#39; 类似）. /* 严格的类型检查选项 */ \u0026#34;strict\u0026#34;: true, // 启用所有严格类型检查选项 \u0026#34;noImplicitAny\u0026#34;: true, // 在表达式和声明上有隐含的 any类型时报错 \u0026#34;strictNullChecks\u0026#34;: true, // 启用严格的 null 检查 \u0026#34;noImplicitThis\u0026#34;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \u0026#34;alwaysStrict\u0026#34;: true, // 以严格模式检查每个模块，并在每个文件里加入 \u0026#39;use strict\u0026#39; /* 额外的检查 */ \u0026#34;noUnusedLocals\u0026#34;: true, // 有未使用的变量时，抛出错误 \u0026#34;noUnusedParameters\u0026#34;: true, // 有未使用的参数时，抛出错误 \u0026#34;noImplicitReturns\u0026#34;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, // 选择模块解析策略： \u0026#39;node\u0026#39; (Node.js) or \u0026#39;classic\u0026#39; (TypeScript pre-1.6) \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 用于解析非相对模块名称的基目录 \u0026#34;paths\u0026#34;: {}, // 模块名到基于 baseUrl 的路径映射的列表 \u0026#34;rootDirs\u0026#34;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \u0026#34;typeRoots\u0026#34;: [], // 包含类型声明的文件列表 \u0026#34;types\u0026#34;: [], // 需要包含的类型声明文件名列表 \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \u0026#34;sourceRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \u0026#34;mapRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到映射文件而不是生成文件的位置 \u0026#34;inlineSourceMap\u0026#34;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \u0026#34;inlineSources\u0026#34;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \u0026#34;experimentalDecorators\u0026#34;: true, // 启用装饰器 \u0026#34;emitDecoratorMetadata\u0026#34;: true // 为装饰器提供元数据的支持 } } 3.2 非空断言 在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。具体而言，x! 将从 x 值域中排除 null 和 undefined 。\n那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。\n1.忽略 undefined 和 null 类型 1 2 3 4 5 6 function myFunc(maybeString: string | undefined | null) { // Type \u0026#39;string | null | undefined\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. // Type \u0026#39;undefined\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. const onlyString: string = maybeString; // Error const ignoreUndefinedAndNull: string = maybeString!; // Ok } 2.调用函数时忽略 undefined 类型 1 2 3 4 5 6 7 8 type NumGenerator = () =\u0026gt; number; function myFunc(numGenerator: NumGenerator | undefined) { // Object is possibly \u0026#39;undefined\u0026#39;.(2532) // Cannot invoke an object which is possibly \u0026#39;undefined\u0026#39;.(2722) const num1 = numGenerator(); // Error const num2 = numGenerator!(); //OK } 因为 ! 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：\n1 2 3 const a: number | undefined = undefined; const b: number = a!; console.log(b); 以上 TS 代码会编译生成以下 ES5 代码：\n1 2 3 const a: number | undefined = undefined; const b: number = a!; console.log(b); 虽然在 TS 代码中，我们使用了非空断言，使得 const b: number = a!; 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，! 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 undefined。\n3.3 确定赋值断言 在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：\n1 2 3 4 5 6 7 8 let x: number; initialize(); // Variable \u0026#39;x\u0026#39; is used before being assigned.(2454) console.log(2 * x); // Error function initialize() { x = 10; } 很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：\n1 2 3 4 5 6 7 let x!: number; initialize(); console.log(2 * x); // Ok function initialize() { x = 10; } 通过 let x!: number; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。\n","permalink":"https://bablvsj.github.io/posts/tech/codelanguage/20230815-typescript/","summary":"TypeScript的特性 类型系统 TypeScript是静态类型 （根据类型检查的时机来分类） 动态类型是指在运行时才会进行类型检查，这种语言的","title":"TypeScript"},{"content":"作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。\n分词/词法分析（Tokenizing/Lexing） 由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，程序 var a = 2;。这段程序通常会被分解成为这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。\n分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。 解析/语法分析（Parsing） 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。\n代码生成 将 AST 转换为可执行代码的过程称被称为代码生成。\n比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。\n首先，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。\n对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。\n简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。\n1.2 理解作用域 LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。 赋值操作还有其他几种形式，因此在概念上最好将其理解为 赋值操作的目标是谁（LHS） 以及谁是赋值操作的源头（RHS）。\nLHS 赋值操作，如a = 2；对a进行了 LHS查询\nRHS 查找源头，如 console.log(b)，对b进行了RHS查询\n如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。\n赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。\nLHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。\n不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。\n小测及答案 1 2 3 4 5 6 7 8 9 function foo(a) { var b = a; return a + b; } var c = foo( 2 ); 1. 找出所有的 LHS 查询（这里有 3 处！） c = ..;、a = 2（隐式变量分配）、b = .. 2. 找出所有的 RHS 查询（这里有 4 处！） foo(2..、= a;、a ..、.. b 第2章 词法作用域 2.1 词法阶段 词法作用域就是定义在词法阶段的作用域。\n查找\n作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。\n无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\nJavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。\n这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。\n第3章 函数作用域和块作用域 3.2隐藏内部实现 **最小授权或最小暴露原则： 应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。\n这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //示例代码 function doSomething(a) { b = a + doSomethingElse( a * 2 ); console.log( b * 3 ); } function doSomethingElse(a) { return a - 1; } var b; doSomething( 2 ); // 15 // 优化后 function doSomething(a) { function doSomethingElse(a) { return a - 1; } var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 ); } doSomething( 2 ); // 15 b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。\n规避冲突\n“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。\n1 2 3 4 5 6 7 8 9 10 function foo() { function bar(a) { i = 3; // 修改 for 循环所属作用域中的 i console.log( a + i ); } for (var i=0; i\u0026lt;10; i++) { bar( i * 2 ); // 糟糕，无限循环了！ } } foo(); 3.3 函数作用域 函数声明\n1 2 3 4 5 6 7 var a = 2; function foo() { var a = 3; console.log( a ); // 3 } foo(); console.log( a ); // 2 函数表达式\n1 2 3 4 5 6 var a = 2; (function foo(){ var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。 比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。 换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。\n3.3.1 匿名和具名 对于函数表达式你最熟悉的场景可能就是回调参数了，比如：\n1 2 3 setTimeout( function() { console.log(\u0026#34;I waited 1 second!\u0026#34;); }, 1000 ); 这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它有几个缺点需要考虑。\n匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：\n1 2 3 setTimeout( function timeoutHandler() { // \u0026lt;-- 快看，我有名字了！ console.log( \u0026#34;I waited 1 second!\u0026#34; ); }, 1000 ); 3.3.2 立即执行函数表达式 IIFE\n1 2 3 4 5 6 var a = 2; (function foo() { var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2 比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。\n传递参数\n1 2 3 4 5 6 7 var a = 2; (function IIFE( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 })( window ); console.log( a ); // 2 IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Definition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。\n1 2 3 4 5 6 7 8 var a = 2; (function IIFE( def ) { def( window ); })(function def( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 }); 函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值。\n3.4 块作用域 with / try catch / let / cost\n第4章 提升 任何声明在某个作用域内的变量，都将附属于这个作用域。\n4.1 先有鸡还是先有蛋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 例1： a = 2; var a; console.log( a ); // 2 形如： var a; a = 2; console.log(a) 例2： console.log( a ); // undefined var a = 2; 形如： var a; console.log(a) a = 2; 提升：变量和函数声明从它们在代码中出现的位置被“移动”到了最上面的过程。 就是先有声明后有赋值。\n4.3 函数优先 函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。\n1 2 3 4 5 6 7 8 foo(); // 1 var foo; function foo() { console.log( 1 ); } foo = function() { console.log( 2 ); }; var foo 尽管出现在 function foo()\u0026hellip; 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。\n尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的\n1 2 3 4 5 6 7 8 9 10 foo(); // 3 function foo() { console.log( 1 ); } var foo = function() { console.log( 2 ); }; function foo() { console.log( 3 ); } 第5章 作用域闭包 JavaScript中闭包无处不在，你只需要能够识别并拥抱它。\n5.1 实质问题 1 2 3 4 5 6 7 8 9 function foo() { var a = 2; function bar() { console.log( a ); } return bar; } var baz = foo(); baz(); // 2 —— 朋友，这就是闭包的效果。 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。\n而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n1 2 3 4 5 6 7 8 9 10 function foo() { var a = 2; function baz() { console.log( a ); // 2 } bar( baz ); } function bar(fn) { fn(); // 妈妈快看呀，这就是闭包！ } 1 2 3 4 5 6 7 8 9 10 11 12 13 var fn; function foo() { var a = 2; function baz() { console.log( a ); } fn = baz; // 将 baz 分配给全局变量 } function bar() { fn(); // 妈妈快看呀，这就是闭包！ } foo(); bar(); // 2 5.3 现在我懂了 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。 这就是闭包。\n通常认为 IIFE 是典型的闭包例子，但根据先前对闭包的定义，我并不是很同意这个观点。\n1 2 3 4 var a = 2; (function IIFE() { console.log( a ); })(); 虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有 a）。a 是通过普通的词法作用域查找而非闭包被发现的。\n5.4 循环和闭包 当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。\n1 2 3 4 5 6 for (var i=1; i\u0026lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 ); } // 6 6 6 6 6 代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？ 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，**实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。\nIIFE 会通过声明并立即执行一个函数来创建作用域。我们来试一下：\n1 2 3 4 5 6 7 8 for (var i=1; i\u0026lt;=5; i++) { (function (){ setTimeout( function timer() { console.log( i ); }, i*1000 ); })(); } // 6 6 6 6 6 如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。\n它需要有自己的变量，用来在每个迭代中储存 i 的值：\n1 2 3 4 5 6 7 8 for (var i=1; i\u0026lt;=5; i++) { (function (j){ setTimeout( function timer() { console.log( j ); }, i*1000 ); })(i); } // 1 2 3 4 5 重返块作用域\nlet 声明 ，本质上这是将一个块转换成一个可以被关闭的作用域\nfor 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n1 2 3 4 5 6 for (let i=1; i\u0026lt;=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 ); } // 1 2 3 4 5 5.5 模块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function CoolModule() { var something = \u0026#34;cool\u0026#34;; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( \u0026#34; ! \u0026#34; ) ); } return { doSomething: doSomething, doAnother: doAnother }; } var foo = CoolModule(); foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3 这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。\n模块模式需要具备两个必要条件。\n必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。\n","permalink":"https://bablvsj.github.io/posts/tech/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-%E4%B8%8A/","summary":"作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（T","title":"你不知道的JavaScript-上"},{"content":"1. 重绘与重排的区别 重绘：更换背景色 重排/回流：隐藏删除元素，页面dom重新渲染，重新生成布局，重新排列元素，非常影响性能。 『重绘』不一定会出现『重排』，『重排』必然会出现『重绘』。\n2. BFC 的原理/BFC的布局规则【非常重要】 BFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：\n（1）BFC 内部的子元素，在垂直方向，边距会发生重叠。 （2）BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。 （3）BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。 （4）计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 3. 如何生成BFC 有以下几种方法：\n方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex 参考链接：\nBFC原理详解 BFC详解 前端精选文摘：BFC 神奇背后的原理 4. 标准 / IE盒子模型 在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：\nwidth和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别：\n在 标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。 IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-css-%E9%A2%98%E5%BA%93/","summary":"1. 重绘与重排的区别 重绘：更换背景色 重排/回流：隐藏删除元素，页面dom重新渲染，重新生成布局，重新排列元素，非常影响性能。 『重绘』不一定会出","title":"Css题库"},{"content":"准备运行环境 C/C++ 运行环境配置 参考文章 ：https://devpress.csdn.net/chongqing/64b8f6fb9a15ac690d7c5feb.html?dp_token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTA2Njc5LCJleHAiOjE2OTc2Mzk4OTEsImlhdCI6MTY5NzAzNTA5MSwidXNlcm5hbWUiOiJxcV80MzI5OTMxNSJ9.AKfunYXnvGq2CxnGIzupjZ--k2h3qhbQJl3Pf4FaH6Y#devmenu1\n白纸编程 ：https://www.penpencode.com/problems\n实验楼 ： https://www.lanqiao.cn/courses/57/learning/?id=297\u0026amp;compatibility=true\n.vscode 文件下新建三个文件 c_cpp_properties.json、launch.json、tasks.json c_cpp_properties.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Win32\u0026#34;, \u0026#34;includePath\u0026#34;: [\u0026#34;${workspaceFolder}/**\u0026#34;], \u0026#34;defines\u0026#34;: [\u0026#34;_DEBUG\u0026#34;, \u0026#34;UNICODE\u0026#34;, \u0026#34;_UNICODE\u0026#34;], \u0026#34;windowsSdkVersion\u0026#34;: \u0026#34;10.0.17763.0\u0026#34;, \u0026#34;compilerPath\u0026#34;: \u0026#34;D:\\\\Program\\\\MinGW\\\\mingw64\\\\bin\\\\g++.exe\u0026#34;, /*修改成自己bin目录下的g++.exe，是两个反斜杠\\\\*/ \u0026#34;cStandard\u0026#34;: \u0026#34;c11\u0026#34;, \u0026#34;cppStandard\u0026#34;: \u0026#34;c++17\u0026#34;, \u0026#34;intelliSenseMode\u0026#34;: \u0026#34;${default}\u0026#34; } ], \u0026#34;version\u0026#34;: 4 } launch.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;g++.exe build and debug active file\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: true, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;D:\\\\Program\\\\MinGW\\\\mingw64\\\\bin\\\\gdb.exe\u0026#34;, /*修改成自己bin目录下的gdb.exe，这里是两个反斜杠\\\\*/ \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;为 gdb 启用整齐打印\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;task g++\u0026#34; } ] } tasks.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 { // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;task g++\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;D:\\\\Program\\\\MinGW\\\\mingw64\\\\bin\\\\g++.exe\u0026#34;, /*修改成自己bin目录下的g++.exe，这里的路径和电脑里复制的文件目录有一点不一样，这里是两个反斜杠\\\\*/ \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;-I\u0026#34;, \u0026#34;E:\\\\blog\\\\exams\\\\C++\u0026#34;, /*修改成自己放c/c++项目的文件夹，不能包含中文，两个反斜杆*/ \u0026#34;-std=c++17\u0026#34;, \u0026#34;-fexec-charset=GBK\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;D:\\\\Program\\\\MinGW\\\\mingw64\\\\bin\u0026#34; /*修改成自己bin目录，这里是两个反斜杠\\\\*/ }, \u0026#34;problemMatcher\u0026#34;:[ \u0026#34;$gcc\u0026#34; ], \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34;, } ] } 编译 gcc xxx.c文件 运行 xxx.out 文件\n数据类型 输入输出函数 格式输出函数 printf() printf(格式控制，输出表列)。例如：printf(\u0026quot;%d,%d\u0026quot;,a,b); 括号内包含两个部分：\n格式控制是用双引号括起来的一个字符串，称“转换控制字符串”，简称“格式字符串”，它包括两个信息：\n格式声明：格式声明由 % 和格式字符组成，如 %d （%d 代表输出整数，%f 代表输出实数），它的作用是将输出的数据转换为指定的格式然后输出。格式声明总是由 % 字符开始。 普通字符：普通字符即在需要输出时原样输出的字符。例如上例中的 printf(\u0026quot;Please enter a value：\u0026quot;);中的 Please enter a value: 即为原样输出。 输出表列是程序需要输出的数据。看下面例子：\n1 printf(\u0026#34;I love %d and %d\u0026#34;,x,s); 格式输入函数 scanf() 一般形式：scanf(格式控制，地址表列)。格式控制的含义同 printf() 函数。\n看下面的例子：\n1 scanf(\u0026#34;a=%d,b=%d\u0026#34;,\u0026amp;a,\u0026amp;b); 在格式字符串中除了有格式声明的 %d 以外，其它普通字符在赋值时需要原样输入（如“ a= ”，“ b= ”和“,”），假如给 a 和 b 分别赋值 5 和 6，将输入 a=5,b=6。 建议大家不要在格式控制中加过多的普通字符，否则会发生不可预料的 BUG。\n注意：scanf() 函数中的表列是地址表列。 scanf(\u0026quot;a=%d,b=%d\u0026quot;,\u0026amp;a,\u0026amp;b); 中 a 和 b 前面的 \u0026amp; 不能省掉，这一点要和 printf 作区分。\n常量 顾名思义，值不能被改变的量称为常量。如 5、7、19 或者 0.54、4.33 这些值，常见的常量分为以下类型：\n1 const int AMOUNT = 100; // 只读不能被修改 整型常量 如 0、100、-30 等整数都是整型常量。\n实型常量 就是我们通常所说的小数，如 12.34, -5.45, 143.342 等，小数还可以用指数形式表现，如 32.23e3（表示 32.23*10^3），-323.34e-6（表示 -323.34*10^-6），由于计算机无法表示上角和下角，所以规定以字母 e 或者 E 代表以 10 为底的指数。\n注意：e 或者 E 之前必须有数字，且 e 或者 E 后面必须为整数，不能是 e3 或者 12e4.1 这种形式。\n字符常量，字符常量有两种 普通字符：用单引号括起来的一个字符，如 \u0026lsquo;a\u0026rsquo;、\u0026lsquo;E\u0026rsquo;、\u0026rsquo;%\u0026rsquo;、\u0026lsquo;3\u0026rsquo;。不能写成 \u0026lsquo;ab\u0026rsquo;、\u0026lsquo;12\u0026rsquo;。字符常量只能是一个字符，不包括单引号。\n转义字符：除了以上形式的字符常量外，C 语言还允许用一种特殊形式的字符常量，就是以字符 \\ 开头的字符序列，比如我们本节课的 3-1.c 中，\\n 代表的就是换行符，显示跳转到下一行。这是一种在屏幕上无法显示的“控制字符”。\n常用的控制字符： 转义字符 含义 转义字符 含义 \\n 换行 \\t 水平制表（右移 8 格） \\v 垂直制表 \\b 退格 \\r 回车（不换行） \\f 换页 \\a 响铃 \\|反斜线 ' 单引号 '\u0026rsquo; 双引号 \\add 3 位 8 进制数代表的字符 \\xhh 2 位 16 进制数代表的字符 什么是变量 变量定义的一般形式：\n1 2 3 4 \u0026lt;类型名称\u0026gt;\u0026lt;变量名称\u0026gt; int price; int amount; int price,amount; a，b，c 都是变量。变量代表一个有名字的、具有特殊属性的存储单元。它可以用来保存数据。变量的值是可以改变的。变量在程序中定义的一般形式就是： \u0026lt;类型名称\u0026gt; \u0026lt;变量名称\u0026gt;。例如：\nint a； int b; int a,b; int price; int amount; \u0026hellip;\nint 代表定义的变量是整数类型。 我们在 3-1.c 的例子中便是直接定义了 a，b，c 三个变量为整数类型： 1 int a，b，c； 标识符 变量需要一个名字，变量的名字便是一种“标识符”，用来区别它和其它不同的变量。用来对变量、函数、数组等命名的字符序列统称为标识符，上面提到的 price 、amount 是标识符，函数名 printf 也是一种标识符。C 语言规定标识符只能由字母、数字和下划线构成，且第一个字符必须为字母或下划线。 ￥ qa，1ew，#22 这些都是非法的标识符。\n变量的赋值与初始化 1 int price = 0; 变量必须先定义后使用。这一行定义了一个变量，变量的名字是 price，类型是 int，初始的值是 0。\n注意：和数学不同，a=b 在数学中表示关系，即 a 和 b 的值一样；而在程序设计中，a=b 表示要求计算机做一个动作：将 b 的值赋值给 a。关系是静态的，而动作是动态的。在数学中，a=b 和 b=a 是等价的，而在程序设计中，两者意思相反。\n什么是数据类型 我们之前的案例中讲到了整数类型 int 定义整型变量，在程序中我们还会用到浮点类型（float）来表示具有小数点的实数，讲解数据类型之前我们先来看一个用到浮点型数据的例子：\n一台拖拉机耕地一亩耗油 0.85kg，它的油箱的容积是 100 升（0.1m3），柴油的密度是 850kg/m3，该拖拉机装满油后最多耕地的亩数是多少？\n我们在函数中首先要定义几个变量，定义油箱的容积的变量为浮点型类型 tank_volume，油的密度为浮点类型 oil_density，油箱装在油的总质量为浮点型 oil_kg，该拖拉机装满油最多耕地的亩数是浮点型 area。下面我们建立一个程序并输入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main(){ float tank_volume; // 定义油箱的容积为浮点类型变量 tank_volume float oil_density; // 定义油的密度为浮点类型变量 oil_density float oil_kg; float area; tank_volume = 0.1; // 给变量 tank_volume 赋值 oil_density = 850; // 给变量 oil_density 赋值 oil_kg = tank_volume*oil_density; // 求 tank_volume 和 oil_density 的积并赋值给 oil_kg area = oil_kg/0.85; // 求 oil_kg/0.85 的商并赋值给 area printf(\u0026#34;Most farming is %f mu\u0026#34;,area); return 0; } 代码说明： 下面我们来解释这个程序。下面的语句定义了四个变量：\n1 2 3 4 float tank_volume; float oil_density; float oil_kg; float area; 下面这两条语句是给 tank_volume 和 oil_density 这两个变量赋值：\n1 2 tank_volume = 0.1; // 给变量 tank_volume 赋值 oil_density = 850; // 给变量 oil_density 赋值 其实 tank_volume=0.1; 与 oil_density=850; 这两条语句可以和前面的 float tank_volume; 与 float oil_density; 这两条语句放在一起，定义变量的同时初始化赋值，即：\n1 2 float tank_volume = 0.1; float oil_density = 850; 接下来我们使用乘法运算符 * 将油箱的容积和油的密度相乘，计算出油箱可以存放油的总质量：\n1 oil_kg = tank_volume*oil_density; // 求 tank_volume 和 oil_density 的积并赋值给 oil_kg 之后我们利用除法运算符 / 求出最多可耕地的亩数，并赋值给 area：\n1 area = oil_kg / 0.85; 为什么在用计算机运算时，需要指定数据的类型呢？\n在数学中，数值是不区分类型的，数值的运算是绝对准确的，例如：1/3 的值是 0.33333\u0026hellip;（循环小数）。数学是研究抽象的学科，数和数的运算都是抽象的。而在计算机中，数据是存储在计算机中的一个个单元里面，它是具体存在的。而且，存储单元是由有限的字节构成的，每一个存储单元存储的数据是有限的，不可能存放无限大的数，也不能存放无限循环小数，例如计算和输出 1/3：\n1 printf(\u0026#34;%f\u0026#34;,1.0/3.0); 得到的结果是 0.333333，只能得到六位小数，而不是无穷位的小数。\n数据类型概览 基本类型\n数值类型 整型：char、短整型 short 、 整型 int 、长整型 long 浮点型： 单精度 float 、双精度 double 字符类型 char 构造类型：数值 、结构体 struct 、共用体 union 、 枚举类型 enum 指针类型 空类型 void 整数类型 为了方便大家理解数据在计算机中的存储方式，我们首先给大家讲述一下计算机内存。计算机在执行程序的时候，组成程序的指令和程序所操作的数据都必须存储在某个地方，这个地方就是计算机的内存，也称为 RAM。\n可以将计算机的 RAM 想象成一排井然有序的盒子。每个盒子都有两个状态：满为 1，空为 0 ，因此每个盒子代表一个二进制数：0 或 1 。计算机有时用真和假表示它们：1 为真，0 为假。每个盒子称为一个位（bit）。每 8 个位组成一个字节，在计算机中，一个英文字母（不分大小写）占一个字节的空间，一个中文汉字占两个字节的空间。\n计算机中常用的单位是千字节（KB）、兆字节（MB）、千兆字节（GB）。 这些单位的意义如下： 1KB 是 1024 字节。其中 1024=2^10（2 的 10 次方），1MB=1024KB，1GB=1024MB 。\nchar的字节数1 short 的字节数2 int 的字节数4 long 的字节数8\nint是用来表达寄存器的，int和long的大小取决于编译器（cpu），通常是一个字。\n补码的意义：拿补码和源码可以加出一个溢出的“零”\n1 2 3 4 5 6 7 8 考虑-1，我们希望-1 + 1 -\u0026gt; 0，如何能做到？ -1 + 1 -\u0026gt; 0 0 -\u0026gt; 0000 0000 1 -\u0026gt; 0000 0001 1111 1111 + 0000 0001 -\u0026gt; 1 0000 0000 因为 0 - 1 -\u0026gt; -1，所以 -1 = （1）00000000 - 00000001 -\u0026gt; 11111111 11111111 被当做纯二进制看待时，是255，被当做补码看待时是 -1； 同理，对于-a，其补码就是 0 - a，实际是 2^n - a，n是这种类型的位数 数的范围： 对于一个字节（8位），可以表达的是： 00000000 - 11111111 其中\n0000 0000 -\u0026gt; 0 1111 1111 ~ 1000 0000 -\u0026gt; -1 ~ -128 0000 0001 ~ 0111 1111 -\u0026gt; 1 ~ 127 1 2 3 4 5 6 7 8 char c = 255; int i = 255; printf(\u0026#34;c=%d,i=%d\u0026#34;,c,i); // c = -1, d = 255 因为int有32个bit,c最高位为1 所以c为负数。 c =\u0026gt; 11111111 i =\u0026gt; 00000000 00000000 00000000 11111111 unsigned ：不以补码的形式来表示负数。高位为1不看成补码，看成是二进制。\n1 2 255U unsigned char c = 255 // c = 255 unsigned 的初衷并非扩展数能表达的范围，而是为了做纯二进制运算，主要是为了移位。\n整数的输入输出 int / long long %d ：int %u ：unsigned %ld ：long long ( 比int大的用ld) %lu ：unsigned long long\n%o 八进制 %x 十六进制\n以0开头的数字字面量是8进制 以0x开头的数字字面量是16进制\n不同类型占用的空间 在这里大家可以通过 sizeof() 运算符查看各类型的常量占据多少字节。\nsizeof() 是静态运算符，不要在sizeof的括号里做运算。\n创建 test.c 文件并输入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include\u0026lt;stdio.h\u0026gt; int main(){ printf(\u0026#34;%d\\n\u0026#34;,sizeof(int)); printf(\u0026#34;%d\\n\u0026#34;,sizeof(short)); printf(\u0026#34;%d\\n\u0026#34;,sizeof(long)); return 0; } // 保存后编译运行显示以下结果： // 4 // 2 // 8 4,2,8 代表 int，short，long 占用的字节数。\n如果没有特殊需求，只使用 int\n浮点型数据 浮点数类型包括 float（单精度浮点型）、double（双精度浮点型）、long double（长双精度浮点型）。\n类型 字长 范围 有效数字 float 32（4个字节） 10^-37 ~ 10^38 只有7个数字是有效的 double 64（8个字节） 10^-307 ~ 10^308 \u0026hellip;15个数 1 2 3 double a=11110.2121231234,b=123123.22345667112414141; printf(\u0026#34;%e,%f\u0026#34;,a,b); // 1.111021e+04 , 123123.223457 浮点的输入输出 类型 scanf printf float %f %f , %e(科学计数法) double %lf %f , %e 输出精度 在 % 和 f 后面加上 .n 可以制定输出小数点后几位，这样的输出是做四舍五入的。\n1 2 3 4 5 6 printf(\u0026#34;%.3f\\n\u0026#34;,-0.0049); printf(\u0026#34;%.30f\\n\u0026#34;,-0.0049); printf(\u0026#34;%.3f\\n\u0026#34;,-0.00049); // -0.005 // -0.004899999999999999841793218991 // -0.000 超出范围的浮点数 +-无穷大 nan 不存在的浮点数\n1 2 3 4 printf(\u0026#34;%f\\n\u0026#34;,12.0/0.0); // inf printf(\u0026#34;%f\\n\u0026#34;,-12.0/0.0); // -inf printf(\u0026#34;%f\\n\u0026#34;,0.0/0.0); // nan printf(\u0026#34;%d\\n\u0026#34;,12/0); // 报错，division by zero is undefined 浮点数的精度 只带小数点的字面量是double而非float float 需要用 f 或 F 后缀来表明身份 1 2 3 4 5 6 7 8 9 10 11 12 float a,b,c; a = 1.345f; b = 1.123f; c = a + b; if(c = 2.468) printf(\u0026#34;相等\\n\u0026#34;); else printf(\u0026#34;不相等\u0026#34;); // fl == f2 可能失败 fabs(f1 - f2) \u0026lt; 1e-8 // 相减的绝对值小于 1e-8 如果没有特殊需求，只使用double 。\n例题：我们要做的是利用输入的直径计算一个圆桌的周长及面积。计算圆的周长或者面积时，数学公式要使用 pi（周长 = 2*pi*r，面积 = pi*r^2，其中 r 是半径）。如果不记得这些公式也不用担心。这不是数学课本，所以只要理解程序是如何运行的即可。\n编写 4-2.c 程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include\u0026lt;stdio.h\u0026gt; int main(){ float radius,diameter; float circumference,area; float pi = 3.1415926; printf(\u0026#34;Input the diameter of the table:\u0026#34;); scanf(\u0026#34;%f\u0026#34;,\u0026amp;diameter); radius = diameter / 2.0; circumference = 2.0 * pi * radius; area = pi * radius * radius; printf(\u0026#34;\\nThe circumference is %f\u0026#34;,circumference); printf(\u0026#34;\\nThe area is %f\u0026#34;,area); return 0; } 在平时我们使用的浮点型数据的时候要注意这几个点哦！ 超过有效位的数字被舍去，可能产生舍入误差\n编写 4-3.c 程序，输入以下代码：\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main(){ float a , b ; a = 123456.789e5 ; /* 相当于 123456.789 * 10^5 */ b = a + 20 ; /* 20加上无意义 */ printf(\u0026#34; %f \u0026#34;, b) ; return 0; } 编译运行结果为：\n1 12345678848.000000 为什么计算出来不是正确的结果呢？是因为 float 数据的有效位是 7 位，a = 123456.789e5 这条语句中赋值给 a 的值超过了 float 的有效位；输出结果中 12345678848.000000 中只有前 7 位才是有效数字\n现在我们再次编写 4-3.c，把程序修改如下：\n1 2 3 4 5 6 7 8 9 #include \u0026lt;stdio.h\u0026gt; int main(){ double a , b ; //把 float 改为 double 类型 a = 123456.789e5 ; b = a + 20 ; printf(\u0026#34; %f \u0026#34;, b) ; return 0; } 程序修改完成后保存并再次编译，运行程序得到了以下结果：\n1 12345678920.000000 这个时候我们发现运行的结果是一个正确的计算结果。因为 double 型的有效数字是 15~16 位，而 123456.789e5（12345678900）其有效数字是 11 位，把它赋值给 a 不会出现溢出。\n在我们以后的项目编程中一定要小心数值溢出的问题，不要以为这种情况很难出现。举个简单的例子，我国很多城市的地铁造价每公里超过了 5 亿，我国 2014 年上半年国内生产总值 269044 亿元，这个时候如果我们定义变量为 float 甚至是 double 类型，都是很危险的。\n字符型 char 1个字节 字符型数据在存储时，并不是把该字符本身存放到内存单元中，而是把该字符相应的 ASCII 码值存放到该存储单元中。如 x 的十进制 ASCII 码是 120，y 的十进制 ASCII 码是 121。对字符变量 a、b 赋予 \u0026lsquo;x\u0026rsquo; 和 \u0026lsquo;y\u0026rsquo; 值：\n1 2 a = \u0026#39;x\u0026#39;; b = \u0026#39;y\u0026#39;; 实际上是在 a、b 两个单元内存放 120 和 121 的二进制代码： 1 2 a: 0111 1000 b: 0111 1001 另外还有需要注意的是，字符常量是区分大小写的，例如，字符 \u0026lsquo;c\u0026rsquo; 的 ASCII 码值是 99，\u0026lsquo;C\u0026rsquo; 的 ASCII 码值是 67\n我们编写程序 4-4.c，代码如下：\n1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; int main(){ char a,b; //定义a和b为字符型变量 a = \u0026#39;c\u0026#39;; //把字符常量 \u0026#39;c\u0026#39; 赋值给变量 a b = 121; printf(\u0026#34;%c,%c\\n\u0026#34;,a,b); %c 表示以字符的形式输出 printf(\u0026#34;%d,%d\\n\u0026#34;,a,b); %d 表示以有符号十进制形式输出整数型 return 0; } 编译并运行之后的结果是：\n1 2 c,y 99,121 %c，对应输出的变量值为字符 %d，对应输出的变量值为整数。\n以字符形式输出时，先将存储单元中的 ASCII 码转换成相应的字符再输出； 以整数的形式输出时，直接输出其 ASCII 码。\n我们还可以对字符型数据进行算术运算，此时相当于对他们的 ASCII 码进行运算，编写程序 4-5.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include\u0026lt;stdio.h\u0026gt; int main(){ char a,x; int b; a = \u0026#39;c\u0026#39;; b = 1; x = a + b; printf(\u0026#34;%c\\n\u0026#34;,x); printf(\u0026#34;%d\\n\u0026#34;,x); return 0; } //结果 d 100 逃逸字符 / 转义字符 字符 意义 字符 意义 \\b 回退一格 \u0026quot; 双引号 \\t 到下一个表格位 ' 单引号 \\n 换行 \\ \\ 反斜杠本身 \\r 回车 字符串常量 字符串常量是用一对双引号括起来的零个或多个字符组成的序列，如 \u0026ldquo;hello\u0026rdquo;，\u0026ldquo;China\u0026rdquo;，\u0026ldquo;b\u0026rdquo; 都是字符串常量。\n字符串常量的存储与字符常量的存储是不同的。字符串中的每个字符占用一个字节，在存储字符串常量时还要自动在其末尾加上 \u0026lsquo;\\0\u0026rsquo; 作为字符串结束的标志。 我们先来一起看下 \u0026ldquo;How do you do.\u0026rdquo; 是如何存储的吧！\n1 2 How do you do . \\0 分配15个字节 字符串结束符 因此大家不要将字符常量和字符串常量混淆哦，\u0026lsquo;b\u0026rsquo; 和 \u0026ldquo;b\u0026rdquo; 是完全不同的。前者是字符常量，在内存中占用的字节数为 1；而后者是字符串常量，在内存中占用的字节数为 2，包含字符 ‘b’ 和 ‘\\0’。\n习题： 追风少年小明骑电瓶车的速度是 40km/h，他以这样的速度从家到公司花费了 1 小时 30 分钟，红绿灯时间忽略不计，小明家与公司的距离是多远？\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;stdio.h\u0026gt; int main(){ int speed = 40; double time = 1.5; double len; len = speed * time; printf(\u0026#34;小明到家的距离是 %.2f公里\\n\u0026#34;,len); return 0; } 运算符和数据转换 不同数据之间的混合运算 经常会遇到不同类型的数据进行运算，比如 7 * 3.5。如果一个运算符的两侧数据类型不同，则先进行类型的转换，使两者具有同一种类型，然后进行运算。因此整型、浮点型、字符型数据之间可以进行混合运算。\n数据类型计算的时候究竟是如何转换类型的呢？大家先看下表：\n1 2 3 4 5 6 7 8 9 从高到低 long double double float long unsigned int int short char 如果 int 类型的数据和 float 或 double 型数据进行运算时，先把 int 型和 float 型数据转换为 double 型数据，然后进行运算，结果为 double 型。其他的大家可以按照上图来做。 字符 (char) 型数据和整型数据进行运算，就是把字符的 ASCII 代码与整型运算。如 4+\u0026lsquo;B\u0026rsquo;，由于字符 \u0026lsquo;B\u0026rsquo; 的 ASCII 代码是 66，相当于 66+4=70。字符型数据可以直接和整型数据进行运算。如果字符型数据和浮点型数据运算，则将字符的 ASCII 码先转化为 double 型，然后再进行运算。 我们编写一个程序分析一下他们转换的编译过程，编写程序 5-3.c：\n1 2 3 4 5 6 7 8 9 10 # include\u0026lt;stdio.h\u0026gt; int main(){ int i = 3; float f = 4.3; double d = 7.5; double sum; sum = 10 + \u0026#39;a\u0026#39; + i*f - d/3; printf(\u0026#34;%lf\\n\u0026#34;,sum); return 0; } 在 sum=10+'a'+i*f-d/3; 这条语句中，右边的表达式从左到右扫描，运算次序为：\n10 + \u0026lsquo;a\u0026rsquo; 的运算，\u0026lsquo;a\u0026rsquo; 的值是整数 97，运算结果为 107。 i*f 的运算。先将 i 与 f 都转换为 double 型，两者运算 12.9，double 型。 整数 107 与 i * f 的值相加，结果为 119.9，double 型。 d/3 的运算，现将 3 转换 double 类型，d/3 的结果为 2.5，double 型。 将 119.9 与 2.5 相减，117.4，double 型。\n编译运行结果如下：\n1 117.400002 要求给定一个大写字母得到其小写字母输出，编写 5-4.c。\n解题思路：我们前面已经介绍过，字符数据以 ASCII 码存储在内存中，形式与整数的存储形式相同，所以字符型数据和其他算数型数据之间可以相互赋值和运算。\n通过 ASCII 码表我们可以找到同一个字母的大写形式和小写形式之间有什么内在的联系。那就是同一个字母，用小写表示的字符的 ASCII 码比用大写表示的 ASCII 码大 32。\n代码如下：\n1 2 3 4 5 6 7 8 9 #include\u0026lt;stdio.h\u0026gt; int main(){ char c1,c2; printf(\u0026#34;Please enter a capital letter:\u0026#34;); scanf(\u0026#34;%c\u0026#34;,\u0026amp;c1); c2 = c1 + 32; printf(\u0026#34;%c\\n\u0026#34;,c2); return 0; } 程序运行结果如下：\n1 2 Please enter a capital letter:R r 自动类型转换 当运算符的两边出现不一致的类型时，会自动转换成较大的类型。\n大的意思是能表达的数的范围更大 char -\u0026gt; short -\u0026gt; int -\u0026gt; long -\u0026gt; long long int -\u0026gt; float -\u0026gt; double printf ：任何小于int的类型会被转换成 int ；float 会被转换成 double scanf不会，要明确输入输出类型；要输入 short 需要 %hd\n强制类型转换 利用强制类型转换运算符将一个数据类型转换为所需的类型，例如：\n1 2 (double)a //将 a 转换成为 double 型 (int)(x + y) //将 x+y 的值转换成为 int 类型 其一般形式就是\n（需要转成的类型）值\n上述例子中如果写成 (int)x + y，则只将 x 转换成为整型再与 y 相加。\n在强制类型转换时，得到一个所需类型的中间数据，而原来变量的类型未发生变化。例如 a = (int)x。 如果已经定义了 x 为 float 型变量，a 为整型变量，进行强制类型运算 (int)x 后得到一个 int 类型的临时值，它的值等于 x 的整数部分，把它赋值给 a，注意 x 的值和类型都未变化，仍为 float 型，该临时值在赋值后就不再存在了。\n强制类型转换的优先级高于四则运算\n1 2 3 4 5 double a = 1.0; double b = 2.0; int i = (int)a / b; // 错误，还是double型 int i = (int)(a/b); 数据的输入和输出 %d 以带符号的十进制形式输入输出整数 %ld 表示数据按十进制有符号长型整数输入或输出 %c 以字符形式输入输出单个字符 %s 输入输出字符串\n%f 以小数点形式输入输出单、双精度实数 %e 以标准指数形式输入输出单、双精度实数\n%o 以无符号的八进制形式输入输出整数 %x 以无符号的十六进制形式输入输出整数 %u 以无符号的十进制形式输入输出整数 %g 选用输入输出宽度较小的格式输出实数\n1 2 3 4 5 double foot,inch; scanf(\u0026#34;%lf %lf\u0026#34;,\u0026amp;foot,\u0026amp;inch); 整数 入输出用 %d 浮点型 输入时要用%lf 输出时用%f 计算时间差\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int hour1,hour2; int minute1,minute2; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;hour1,\u0026amp;minute1); scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;hour2,\u0026amp;minute2); //法一 int t1 = hour1 * 60 + minute1; int t2 = hour2 * 60 + minute2; int t = t1 - t2; printf(\u0026#34;时间差是：%d时 %d分\u0026#34;,t/60,t%60); // 法二 int ih = hour2 - hour1; int im = minute2 - minute1; if(im \u0026lt; 0){ im = 60 + im ih--; } printf(\u0026#34;时间差是：%d时 %d分\u0026#34;,ih,im); 赋值也是运算， a = b = 6 ==\u0026gt; a = ( b = 6)\n关系运算的结果，如果为真则为1，反之为0。\n1 2 printf(\u0026#34;%d\\n\u0026#34;,5==3); // 0 printf(\u0026#34;%d\\n\u0026#34;,5\u0026gt;3); // 1 1 2 3 4 5 6 7 8 9 10 11 switch(控制表达式){ 控制表达式只能是整数型的结果 case 常量1： 语句1... break; case 常量2： 语句2... break; default: 语句... break; } 1 2 3 4 5 6 7 while(循环条件){ // 循环条件为真，不断的进入循环体 循环体 } do{ // 最少执行一次循环体 循环体 }while(条件) // 循环条件为真，不断的进入循环体 brake ：跳出循环，不管是 for、while、do-while continue：跳过当前循环剩下的语句，进入下一轮循环\ngoto xxx 适用跳出多重循环\n接力brake 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include \u0026lt;stdlib.h\u0026gt; int main() { int x; int one,two,five; int exit = 0; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); for(one = 1;one\u0026lt;x*10;one++){ for(two = 1;two\u0026lt;x*5;two++){ for(five = 1;five\u0026lt;x*2;five++){ if(one + two*2 +five * 5 == x *10){ printf(\u0026#34;可以用%d个一角%d个贰角%d个伍角组成%d元\\n\u0026#34;,one,two,five,x); exit = 1; break; } } if(exit) break; } if(exit) break; } return 0; 方法二： goto xxx scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); for(one = 1;one\u0026lt;x*10;one++){ for(two = 1;two\u0026lt;x*5;two++){ for(five = 1;five\u0026lt;x*2;five++){ if(one + two*2 +five * 5 == x *10){ printf(\u0026#34;可以用%d个一角%d个贰角%d个伍角组成%d元\\n\u0026#34;,one,two,five,x); goto out; } } if(exit) break; } if(exit) break; } out: return 0; } 正序分解整数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;stdlib.h\u0026gt; int main() { int x; scanf(\u0026#34;%d\u0026#34;,\u0026amp;x); int mask = 1; int t = x; while(t\u0026gt;9){ t /= 10; mask *= 10; } printf(\u0026#34;x=%d,mask=%d\\n\u0026#34;,x,mask); do{ int d = x / mask; printf(\u0026#34;%d\u0026#34;,d); if(mask \u0026gt; 9){ printf(\u0026#34; \u0026#34;); } x %= mask; mask /= 10; }while(mask\u0026gt;0); return 0; } // 14551 // x=14451,mask=10000 // 1 4 4 5 1 求两个数的最大公约数 辗转相除法\n如果b等于0，计算结束，a就是最大公约数； 否则，计算a除以b的余数，让 a = b，b = 那个余数 再进行循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdlib.h\u0026gt; int main() { int a,b; int t; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;a,\u0026amp;b); while(b!=0){ t = a % b; a = b; b = t; } printf(\u0026#34;最大公约数是%d\u0026#34;,a); } 数学函数 rand() 生成一个随机的整数\n函数 函数结构\n1 2 3 4 5 6 7 8 9 返回类型 函数名(参数列表...){ 函数体 } void sum(int begin,int end){ for(i=begin;i\u0026lt;=end;i++){ sum += i; } } 函数声明（函数原型）和函数定义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u0026lt;stdio.h\u0026gt; int isPreme(int i); // 函数声明，可不写参数 // int isPreme(int); // 函数声明，可不写参数 int main(){ int m,n; int sum = 0,cnt = 0; int i; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n); if(m == 1) m = 2; for(i=m;i\u0026lt;=n;i++){ if(isPreme(i)){ sum += i; cnt++; } } printf(\u0026#34;%d %d\\n\u0026#34;,cnt,sum); return 0; } int isPreme(int i){ // 函数定义 int ret = 1; int k; for(k = 2;k\u0026lt;i-1;k++){ if( i%k == 0){ ret = 0; break; } } return ret; } 调用函数是给的值与参数的类型不匹配，编译器会自动做类型转换\n1 2 3 4 5 6 7 8 void cheer(int i){ printf(\u0026#34;cheer: %d\\n\u0026#34;,i); } int main(){ cheer(2.44444); return 0; } 定义原型一定要把参数写全 1 2 3 4 5 6 7 8 9 void swap(); int main(){ ... } void swap(double a,double b){ } 不允许函数嵌套定义 素数求和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;stdio.h\u0026gt; int isPreme(int i){ int ret = 1; int k; for(k = 2;k\u0026lt;i-1;k++){ if( i%k == 0){ ret = 0; break; } } return ret; } int main(){ int m,n; int sum = 0,cnt = 0; int i; scanf(\u0026#34;%d %d\u0026#34;,\u0026amp;m,\u0026amp;n); if(m == 1) m = 2; for(i=m;i\u0026lt;=n;i++){ if(isPreme(i)){ sum += i; cnt++; } } printf(\u0026#34;%d %d\\n\u0026#34;,cnt,sum); return 0; } 局部变量 块里定义变量会覆盖外面同名的变量 数组 其中所有的元素具有相同的数据类型 一旦创建，不能改变大小 一维数组 定义一维数组 1 2 类型 数组名[元素数量] int student[10]; 一维数组的初始化 在定义数组时对全部数组元素赋予初值。例如： 1 int a[10] = {0,1,2,3,4,5,6,7,8,9}； 给数组中的部分元素赋值，例如： 1 2 3 4 5 6 7 8 int a[10] = {0,1,2,3}; // {0,1,2,3,0,0,0,0,0,0} int a[10] = {[1]=1,4,[5]=6}; // {0,1,4,0,0,6,0,0,0,0} int a[] = {[1]=1,4,[5]=6}; // {0,1,4,0,0,6} 计算数组长度 sizeof(a) / sizeof(a[0])\n数组赋值 1 2 int a[] = {1,2,3,4,5,6,7,8,9}; int b[] = a; // 不允许赋值 数组变量本身不能被赋值 要把一个数组的所有元素赋给另一个数组，必须采用遍历赋值。 数组作为函数的参数时：\n不能在 中给出数组的大小 不能再利用sizeof来计算数组的元素个数 二维数组 很多问题需要我们用到二维数组，比如一个年级有 4 个班，每个班有 30 个人，需要统计每个班的学生成绩，这个时候就要用的二维数组。如果建立一个数组 student[][]，第一维用来表示第几班，二维用来表示第几号，比如 student[2][3] 表示 2 班的 3 号同学。\n定义二维数组 二维数组的定义方法和一维数组类似，其一般形式为：\n1 2 3 类型 数组名[ 行 ][ 列 ] float a[3][4]; 二维数组的初始化 分行给二维数组赋初值。例如： 1 int a[3][4] = {{1,2,3,4},{5,6,7,8},{9,10,11,12}}; 可以将所有的数据放在一个花括号内，例如： 1 int a[3][4] = {1,2,3,4,5,6,7,8,9,10,11,12}; 效果和第一种相同。但是很显然第一种方式较好。\n可以对部分元素赋初值。例如： 1 int a[3][4]={{1},{3},{5}}; 它的作用是只给各行第 0 列的元素赋初值，其他元素默认为 0。赋初值后的结果为：\n1 2 3 1 0 0 0 3 0 0 0 5 0 0 0 列数必须给出，行数可以由编译器来数\n1 2 3 4 int a[][5]={ {1,2,3,4,5}, {3,4,5,6,7} }; 二维数组的举例 有一个 3 * 4 的矩阵，求出其中的最大值并输出最大值和其所在的行号和列号。\n编写源程序 8-3.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; int main(){ int i,j,row = 0,colum = 0,max; int a[3][4] = {{3,4,16,2},{7,5,1,9},{11,23,3,8}}; max = a[0][0]; for(i=0;i\u0026lt;3;i++) for(j=0;j\u0026lt;4;j++) if(a[i][j]\u0026gt;max) { max = a[i][j]; row = i; colum = j; } printf(\u0026#34;max=%d\\nrow=%d\\ncolum=%d\\n\u0026#34;,max,row,colum); return 0; } 运行结果为：\n1 2 3 max = 23 row = 2 colum = 1 字符数组 前面我们已经讲解过，字符型数据是以字符的 ASCII 代码存储在存储单元中的，一般占一个字节。由于 ASCII 代码属于整数形式，因此，把字符型归纳为整数类型中的一种。 由于字符数据的应用十分广泛，尤其是作为字符串形式的使用，有其自己的特点，我们单独成节来讲述该内容。\n注意：C 语言中没有字符串类型，字符串都是存储在字符型数组中的。\n字符数组的定义 定义字符数组的方法与定义数值型数组的方法类似：例如：\n1 char c[10]; 以上就定义了 c[ ] 为字符数组，包含 10 个元素。\n字符数组的初始化 把各个字符以此赋给数组中各元素。例如：\n1 char c[10]={\u0026#39;I\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;y\u0026#39;}; 把这 10 个字符以此赋给 c[0]~c[9] 这 10 个元素。\n注意：上面例子中花括号提供的初值个数（即字符个数）等于数组长度，倘若花括号中的提供\n初值个数大于数组长度，则会出现语法错误。 倘若初值个数小于数组长度，则只将这些字符赋给数组中前面那些元素，其余元素自动定为空字符（即\u0026rsquo;\\0\u0026rsquo;）。 在定义数组时可以省略数组长度，系统会自动根据数组个数确定数组长度。例如：\n1 char c[]={\u0026#39;I\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;p\u0026#39;,\u0026#39;y\u0026#39;}; 数组 c[ ] 的长度自动定为 10。\n例如，输出一个正方形。\n解题思路：\n先画出一个平面正方形图案，每行包含 5 个字符，其中有的是空白字符，有的是 \u0026lsquo;*\u0026rsquo; 字符，定义一个字符型的二维数组并初始化，用 for 循环嵌套输出。\n编写源程序 8-4.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; int main(){ char c[ ][9]={ {\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;}, {\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;}, {\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;}, {\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;}, {\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;*\u0026#39;}, }; int i,j; for(i=0;i\u0026lt;5;i++) { for(j=0;j\u0026lt;9;j++) printf(\u0026#34;%c\u0026#34;,c[i][j]); printf(\u0026#34;\\n\u0026#34;); } return 0; } 补充一点：C 语言中，二维数组初始化的语句中可以不指定行数进行初始化，比如 char c[ ][9] 就省略了行数，编译器自动将其识别为 char c[5][9]。\n字符串和字符串结束标志 在 C 语言中，是将字符串作为字符数组来处理的。在平时的应用中，人们往往关心的是字符串的有效长度而不是字符数组的长度。例如，定义一个字符数组长度 50，而实际有效字符只有 30 个。为了测定字符串的实际长度，C 语言规定了一个“字符串结束标志（\u0026rsquo;\\0\u0026rsquo;）”，以字符 \u0026lsquo;\\0\u0026rsquo; 作为结束标志。\n如果字符数组中存在若干字符，前面 9 个字符都不是空字符（\u0026rsquo;\\0\u0026rsquo;），而第 10 个字符是 \u0026lsquo;\\0\u0026rsquo;，则认为数组中有一个字符串，其有效字符为 9 个。 系统在用字符数组存储字符串常量时会自动加一个 \u0026lsquo;\\0\u0026rsquo; 作为结束符。例如：\n1 printf(\u0026#34;Shiyanlou\u0026#34;); 在执行次语句时系统怎么知道该输出到哪里为止呢？实际上，在向内存中存储时，系统自动在最后一个字符 \u0026lsquo;u\u0026rsquo; 后面加一个 \u0026lsquo;\\0\u0026rsquo; 作为字符串结束标志。在执行 printf() 函数时，每输出一个字符检查一次，看下一个字符是否为 \u0026lsquo;\\0\u0026rsquo;，遇到 \u0026lsquo;\\0\u0026rsquo; 就停止输出。\n有了上述理解，在对字符数组初始化的方法上面我们做出一些补充。例如：\n1 char[] = {\u0026#34;I love shiyanlou\u0026#34;}; 我们也可以直接省去花括号：\n1 char[] = \u0026#34;I love shiyanlou\u0026#34;; 这里不像之前单个字符作为字符数组的初值，而是用字符串作为初值（字符串做初值是用双撇号而不是单撇号）。这种方法更直观、更方便。\n注意：此时数组的长度是 17，而不是 16，因为字符串常量的最后系统自动加了一个 \u0026lsquo;\\0\u0026rsquo;。上面的初始化与下面的初始化等价的。\n1 char c[] = {\u0026#39;I\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;u\u0026#39;,\u0026#39;\\0\u0026#39;}; 和下面的这个不等价：\n1 char c[] = {\u0026#39;I\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;v\u0026#39;,\u0026#39;e\u0026#39;,\u0026#39; \u0026#39;,\u0026#39;s\u0026#39;,\u0026#39;h\u0026#39;,\u0026#39;i\u0026#39;,\u0026#39;y\u0026#39;,\u0026#39;a\u0026#39;,\u0026#39;n\u0026#39;,\u0026#39;l\u0026#39;,\u0026#39;o\u0026#39;,\u0026#39;u\u0026#39;}; 字符数组的输入输出 1.字符数组的输入输可以像前面的输入输出数字一样，用格式输入输出控制符。\n逐个字符输入输出，用格式“%c”输入或者输出一个字符。 将整个字符串一次输入或者输出，用“%s”格式符，例如： 1 2 char c[] = \u0026#34;shiyanlou\u0026#34;; printf(\u0026#34;%s\u0026#34;, c); //用%s格式符输入或输出字符串时，接受项是字符数组名 2.也可以用puts 和 gets函数。其一般形式如下：\nputs（字符数组）：其作用是将一个字符串输出到终端，因此该函数用的不是很多，我们可以编写小程序来体验。 gets（字符数组）：其作用是从终端输入一个字符串到字符数组，并且得到一个函数值。 编写源程序 8-5.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; \u0026#39;在使用字符串处理函数时，在程序文件的开头用 #include\u0026lt;string.h\u0026gt;\u0026#39; int main(){ char str[] = \u0026#34;China\\nChengdu\u0026#34;; puts(str); printf(\u0026#34;Enter a new string:\u0026#34;); gets(str); //有的编译器会报 warning，提示 gets() 函数不安全； //这里说明一下，这个warning是编译器针对这个函数的，不影响实验。 puts(str); return 0; } 运行结果为：\n1 2 3 4 China Chengdu Enter a new string:hello shiyanlou hello shiyanlou 字符串处理函数 strcat 函数-字符串连接函数 其一般形式如下：\nstrcat（字符数组 1，字符数组 2）\n其作用是把两个字符数组中的字符串连接起来，把字符串 2 接到 1 后面，结果放到字符串 1 中。\n编写源程序 8-6.c：\n1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; //在使用字符串处理函数时，在程序文件的开头用 #include\u0026lt;string.h\u0026gt; int main(){ char str1[30] = \u0026#34;People\u0026#39;s Republic of\u0026#39;\u0026#34;; char str2[] = \u0026#34;China\u0026#34;; printf(\u0026#34;%s\u0026#34;,strcat(str1,str2)); //结果 : People\u0026#39;s Republic of\u0026#39; China return 0; } 注意：\n连接前两个字符串后面都有 \u0026lsquo;\\0\u0026rsquo;，连接时将字符串 1 后面的 \u0026lsquo;\\0\u0026rsquo; 取消，只在新串后面保留 \u0026lsquo;\\0\u0026rsquo;。 字符串 1 必须足够大，以便于容纳字符串 2。如果在定义是定义为 char str1[]=\u0026quot;People's Republic of\u0026quot;; 就会出现问题，因为长度不够。 strlen 函数-测字符串长度的函数 其一般形式如下：\nstrlen(字符数组)\n它是测量字符串长度的函数。函数的值为字符串中的实际长度。例如：\n1 2 char str[] = \u0026#34;China\u0026#34;; printf(\u0026#34;%d\u0026#34;,strlen(str)); 注意：strlen() 返回的值比实际占用的长度要小，因为不包含 \u0026lsquo;\\0\u0026rsquo;。\nstrcpy ——字符串复制函数 其一般形式如下：\nstrcpy（字符串 1，字符串 2）\n作用是将字符串 2 复制到字符串 1 中。例如：\n1 2 char str1[10],str2[] = \u0026#34;China\u0026#34;; strcpy(str1,str2); 注意：\n字符数组 1 必须定义的足够大，以便容纳被复制的字符串 2。\n“字符数组 1” 必须写成数组名形式（如 str1），“字符串 2”可以使字符数组名，也可以是一个字符串常量。例如：strcpy(str1,\u0026quot;China\u0026quot;); 作用与前面的相同。\n不能用赋值语句将一个字符串常量直接给一个字符数组。如下面两行是错误的：\n1 2 str1 = \u0026#34;shiyanlou\u0026#34;; //错误，企图用赋值语句将一个字符串常量直接赋值给一个数组 str1 = str2; //错误，企图用赋值语句将一个字符数组直接赋给另一个字符数组 strcmp——字符串比较函数 其一般形式如下：\nstrcmp（字符串 1，字符串 2）\n它的作用是比较字符串 1 和字符串 2（按照 ASCII 码值大小比较）。例如：\n1 2 strcmp(str1,str2); strcmp(\u0026#34;Chengdu\u0026#34;,\u0026#34;Beijing\u0026#34;); 比较规则：\n将两个字符串自左向右逐个字符比较（按照 ASCII 码值大小比较），直到出现不同的字符或者遇到 \u0026lsquo;\\0 \u0026lsquo;为止。\n如果全部字符相同，则认为两个字符串相同。 若出现不同的字符，则以第 1 对不相同的字符的比较结果为准。例如：\u0026ldquo;A\u0026rdquo;\u0026lt;\u0026ldquo;D\u0026rdquo;，\u0026ldquo;e\u0026rdquo;\u0026gt;\u0026ldquo;E\u0026rdquo;，\u0026ldquo;these\u0026rdquo;\u0026gt;\u0026ldquo;that\u0026rdquo;，\u0026ldquo;computer\u0026rdquo;\u0026gt;\u0026ldquo;compare\u0026rdquo;。 比较结果由函数值带回。 字符串 1=字符串 2，则函数值为 0 字符串 1\u0026gt;字符串 2，则函数值为一个正整数 字符串 1\u0026lt;字符串 2，则函数值为一个负整数 关于字符串处理函数，还有 strlwr 函数（转换为小写的函数）、strupr 函数（转换为大写的函数）strncpy 函数等其它函数。\n字符数组应用举例 任意键入 3 个字符串，编程找出最小的一个。\n编写源程序 8-7.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;string.h\u0026gt; int main(){ char string[30]; // 定义一个二维数组 // ch[1]、ch[2]、ch[3] 都是一个字符数组，相当于三个字符串 char ch[3][30]; int i; // 循环读取三行，并且将每行存到 ch[i] 中 for(i=0;i\u0026lt;3;i++) gets(ch[i]); // 有的编译器会报 warning，提示 gets() 函数不安全，不影响实验。 strcpy(string,ch[0]); for(i=1;i\u0026lt;3;i++) if(strcmp(ch[i],string)\u0026lt;0) strcpy(string,ch[i]); printf(\u0026#34;The result is :\\n%s\u0026#34;,string); return 0; } 这里要注意的是，我们定义的 ch[1]、ch[2]、ch[3] 都只有 30 个字符大小，gets() 函数还会自动补 \\0，因此我们每行的输入不要超过 29 个字符。\n运行结果为：\n1 2 3 4 5 love love you love you forever THe result is : love 运算符 \u0026amp; 获取变量的地址，它的操作数必须是变量\n1 scanf(\u0026#34;%d\u0026#34;,\u0026amp;i); 1 2 3 4 5 6 7 8 9 10 11 12 int i = 0; printf(\u0026#34;0x%x\\n\u0026#34;,\u0026amp;i); // 0xbff12d70 printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;i); // 0xbff12d70 用%p 以16进制的方式输出一个地址 int p; // p = \u0026amp;i; //类型转换的报错 p = (int)\u0026amp;i; printf(\u0026#34;0x%x\\n\u0026#34;,p); // 0xbff12d70 64位架构 printf(\u0026#34;0x%x\\n\u0026#34;,p); // 0x5c961d28 printf(\u0026#34;%p\\n\u0026#34;,\u0026amp;i); // 0x7fff5c961d28 地址的大小是否与int相同取决于编译器\n1 2 3 4 5 6 7 32位架构 printf(\u0026#34;%lu\\n\u0026#34;,sizeof(int)); // 4个字节 printf(\u0026#34;%lu\\n\u0026#34;,sizeof(\u0026amp;i)); // 4 64位架构 printf(\u0026#34;%lu\\n\u0026#34;,sizeof(int)); // 4个字节 printf(\u0026#34;%lu\\n\u0026#34;,sizeof(\u0026amp;i)); // 8 \u0026amp;a == a == \u0026amp;a[0]，\u0026amp;a[1] - \u0026amp;a[0] = 4\n指针 就是保存地址的变量\n1 2 3 4 int i; int* p = \u0026amp;i; int* p,q; int *p,q; *是一个 单目运算符，用来访问指针值所代表的地址上的变量 可以做右值，也可以做左值 1 2 int k = *p; *p = k + 1; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void f(int *p); void g(int k); int main(void){ int i = 6; printf(\u0026#34;\u0026amp;i=%p\\n\u0026#34;,\u0026amp;i); f(\u0026amp;i); g(i); return 0; } void f(int *p){ printf(\u0026#34;p = %p\\n\u0026#34;,p); printf(\u0026#34;*p=%d\\n\u0026#34;,*p); *p =26; } void g(int k){ printf(\u0026#34;k=%d\\n\u0026#34;,k); } 结果 //\u0026amp;i = 0xbffbcd70; // p = 0xbffbcd70; //*p = 6; //k = 26; 指针的使用 交换两个变量的值 1 2 3 4 5 void swap(int *pa, int *pb){ int t = *pa; *pa = *pb; *pb = t; } 2.1通过指针返回多个参数 传入的参数实际上是需要保存带回的结果的变量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include\u0026lt;stdio.h\u0026gt; void minmax(int all,int len,int *max,int *min); int main（void）{ int al={1,2,3,4,5,6,7,8,9,12,13,14,16,17,21,23,55}; int min，max; minmax(a,sizeof(a)/sizeof(a[0]),\u0026amp;min,\u0026amp;max); printf(\u0026#34;min=%d,max=%d\\n\u0026#34;,min,max); return 0; } void minmax(int a[],int len,int *min,int *max){ int i; *min = *max = a[0]; for(i = 1;i\u0026lt;len;i++){ if(a[i]\u0026lt;*min){ *min = a[i] } if(a[i]\u0026gt;*max){ *max = a[i] } } } 2.2 函数返回运算的状态，结果通过指针返回 常用的套路是 让函数返回特殊的不属于有效范围内的值来表示出错：\n-1 或 0 但是当任何数值都是有效的可能结果时，就得分开返回了。 指针常见错误 定义了指针变量，但还没指向任何变量，就开始使用指针。\n1 2 3 4 int *p; int k; k = 12; *p = 12; // 没有指向任何变量，不能使用 指针与数组 传入函数的数组变成了什么？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u0026lt;stdio.h\u0026gt; void minmax(int all,int len,int *max,int *min); int main（void）{ int al={1,2,3,4,5,6,7,8,9,12,13,14,16,17,21,23,55}; int min，max; printf(\u0026#34;main sizeof(a) = %lu\\n\u0026#34;,sizeof(a)); printf(\u0026#34;main a = %p\\n\u0026#34;,a); minmax(a,sizeof(a)/sizeof(a[0]),\u0026amp;min,\u0026amp;max); printf(\u0026#34;a[0] = %d\\n\u0026#34;,a[0]); printf(\u0026#34;min=%d,max=%d\\n\u0026#34;,min,max); return 0; } void minmax(int a[],int len,int *min,int *max){ int i; printf(\u0026#34;minmax sizeof(a) = %lu\\n\u0026#34;,sizeof(a)); printf(\u0026#34;minmax a = %p\\n\u0026#34;,a); *min = *max = a[0]; a[0] = 1000; for(i = 1;i\u0026lt;len;i++){ if(a[i]\u0026lt;*min){ *min = a[i] } if(a[i]\u0026gt;*max){ *max = a[i] } } } 结果： // main sizeof(a) = 68 // mian a = 0xbff67d10 // // minmax sizeof(a) = 4 // minmax a = 0xbff67d10 //a[0] = 1000 // min=2,max=1000 函数参数表中的数组实际上是指针 sizeof( a ) == sizeof(int * ) 但可以使用数组的运算符【】进行运算 int a[] == int a*\n以下四种函数原型是等价的\n1 2 3 4 int sum(int *ar,int n); int sum(int *,int); int sum(int ar[],int n); int sum(int [],int); 数组变量是特殊的指针 数组变量本身表达地址，所以\nint a[10];int * p =a; // 无需用\u0026amp;取地址 但是数组的单元表达的是变量，需要用\u0026amp;取地址 a == \u0026amp;a[0] [ ] 运算符可以对数组做，也可以对指针做： p[0] \u0026lt;==\u0026gt; a[0]\n1 2 3 int *p = \u0026amp;min; printf(\u0026#34;*p=%d\\n\u0026#34;,*p); // p = 2 printf(\u0026#34;p[0]=%d\\n\u0026#34;,p[0]); // p[0]=2 *运算符可以对指针做，也可以对数组做： *a = 25\n1 printf(\u0026#34;*a = %d\\n\u0026#34;,*a); // *a=1000 ==\u0026gt; a[0] 数组变量是const的指针，所以数组之间不能直接赋值\n1 int b[] --\u0026gt; int * const b; 指针与const 指针：\n一旦得到了某个变量的地址，不能再指向其他变量\n1 2 3 int * const q = \u0026amp;i; // q是const *q = 26; q++; // error 不能通过这个指针取修改那个变量（并不能使得那个变量成为const）\n1 2 3 4 const int *p = \u0026amp;i; *p = 26; // ERROR ！ （*p）是const i = 26; // OK p = \u0026amp;j; const 在 * 前面：他所指的东西不能被修改 const 在 * 后面：指针不能被修改\n1 2 3 4 int i; const int* p1 = \u0026amp;i; int const* p2 = \u0026amp;i; int *const p3 = \u0026amp;i; 转换 总是可以把一个非 const 的值转换成 const 的\n1 2 3 4 5 6 7 void f(const int* x); int a = 15; f(\u0026amp;a); //ok const int b = a; f(\u0026amp;b); //ok b = a + 1; // Error ! const 数组 const int a[] = {1,2,3,4,5,6};\n数组变量已经是 const 的指针了，这里的 const 表明数组的每个单元都是 const in 所以必须通过初始化赋值 保护数组值 因为把数组传入函数时传递的是地址，所以那个函数内部可以修改数组的值 为了保护数组不被函数破坏，可以设置参数为 const 1 int sum(const int a[], int length); 指针运算 给指针加 1 表示要让指针指向下一个变量\n1 2 3 4 5 6 7 char ac[] = {0,1,2,3,4,5,6,7,8,9}; char *p = ac; *p -\u0026gt; ac[0] *(p+1) -\u0026gt; ac[1] // 1 *(p+n) == ac[n] 两个指针相减是他们之间相差几个数组元素\n1 2 3 4 char ac[] = {0,1,2,3,4,5,6,7,8,9}; char *p = ac; char *p1 = \u0026amp;ac[5]; printf(\u0026#34;p1-p = %d\\n\u0026#34;,p1-p); // p1 - p = 5 *p++：取出p所指的数据后，顺便把p移到下一个位置去，因为 ++的优先级高于 *\n1 2 3 4 char ac[] = {0,1,2,3,4,5,6,7,8,9,-1}; for(p = ac; *p!=-1 ;p++){ printf(\u0026#34;%d\\n\u0026#34;,*p++); } 指针比较 比较它们在内存中的地址\n0地址：通常是个不能随便碰的地址 返回的指针是无效的 指针没有被真正的初始化（先初始化为0） NULL是一个预定定义的符号，表示0地址 指针的类型 无论指向什么类型，所有的指针大小都是一样的，因为都是地址 但指向不同类型的指针是不能直接互相赋值的，这是为了避免用错指针。 1 2 3 4 5 6 7 8 char ac[] = {0,1,2,3,4,5,6,7,8,9}; char *p = ac; int ai[] = {0,1,2,3,4,5,6,7,8,9}; char *q = ai; q = p; // 错误 return 0; 指针的类型转换 void * 表示不知道指向什么东西的指针\n指针可以转换类型\n1 2 int *p = \u0026amp;i; void *q = (void*)p; 这并没有改变p所指向的变量的类型，而是让后人用不同的眼光通过p看它所指的变量\n指针的用处 需要传入较大的数据时用作参数 传入数组后对数组进行操作 函数返回不止一个结果时 需要用函数来修改多个变量时 需要动态申请内存时 动态内存分配 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;stdlib.h\u0026gt; // malloc头文件 格式： int *a = (int*)malloc(n*sizeof(int)); #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; int main(void){ int number; int* a = 0; int i; printf(\u0026#34;输入数量：\u0026#34;); scanf(\u0026#34;%d\u0026#34;,\u0026amp;number); // int a[number]; a = (int*)malloc(number*sizeof(int)); // malloc数据转换为 int* for(i=0;i\u0026lt;number;i++){ scanf(\u0026#34;%d\u0026#34;,\u0026amp;a[i]); } free(a); // 把申请来的空间还给系统 } 如果没空间了，则返回 0 或 NULL\n申请了没有free -\u0026gt; 长时间运行内存逐渐下降 free 过后再 free -\u0026gt; 系统会崩溃\n数学常识 素数（质数）：一个大于 1 的自然数，除了 1 和它本身外，不能被其他自然数整除。\n","permalink":"https://bablvsj.github.io/posts/exams/c%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/","summary":"准备运行环境 C/C++ 运行环境配置 参考文章 ：https://devpress.csdn.net/chongqing/64b8f6fb9a15ac69","title":"C语言基础"},{"content":" am pm 28 Java程序设计 数据库原理 29 C++程序设计 英语二 Java程序设计 04747 - 2017\n数据库系统原理 04735 - 2018\nC++程序设计 04737 - 2019\n英语二 00015 - 2012\n","permalink":"https://bablvsj.github.io/posts/exams/20231028-for-four-exams/","summary":"am pm 28 Java程序设计 数据库原理 29 C++程序设计 英语二 Java程序设计 04747 - 2017 数据库系统原理 04735 - 2018 C++程序设计 04737 - 2019 英语二 00015 - 2012","title":"for four exams"},{"content":"在Vue 3中，reactive和ref是用于创建响应式数据的两种不同方式。\nreactive函数用于将一个普通的JavaScript对象转换为响应式对象。它会递归地将对象的所有属性转换为响应式属性，这意味着当属性的值发生变化时，Vue会自动追踪和更新相关的视图。使用reactive函数创建的对象可以像普通对象一样使用，可以直接访问和修改属性。\n1 2 3 4 5 6 7 8 import { reactive } from \u0026#39;vue\u0026#39; const state = reactive({ count: 0 }) console.log(state.count) // 输出: 0 state.count++ // 修改count的值 console.log(state.count) // 输出: 1 ref函数用于创建一个简单的响应式引用。它将一个普通的JavaScript值转换为一个响应式对象，该对象具有一个名为value的属性，该属性包含实际的值。与reactive不同，ref只能用于包装单个值，而不是对象。\n1 2 3 4 5 6 import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) console.log(count.value) // 输出: 0 count.value++ // 修改值 console.log(count.value) // 输出: 1 当在模板中使用响应式对象时，可以直接访问ref包装的值，而不需要访问.value属性。Vue会自动进行解包。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;Count: {{ count }}\u0026lt;/p\u0026gt; \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#39;vue\u0026#39; const count = ref(0) const increment = () =\u0026gt; { count.value++ } \u0026lt;/script\u0026gt; 综上所述，reactive用于创建响应式对象，适用于复杂的数据结构，而ref用于创建简单的响应式引用，适用于单个值。\n","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/20230810-reactive%E4%B8%8Eref%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"在Vue 3中，reactive和ref是用于创建响应式数据的两种不同方式。 reactive函数用于将一个普通的JavaScript对象转换为","title":"reactive与ref的区别"},{"content":"","permalink":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/ts/","summary":"","title":"TS面试题"},{"content":"你知道Vue3.x响应式数据原理吗？ Vue3.x改用Proxy替代Object.defineProperty。\n因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。\nProxy只会代理对象的第一层，Vue3是怎样处理这个问题的呢？\n判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。 Proxy 与 Object.defineProperty 优劣对比 Proxy 的优势如下: Proxy 可以直接监听对象而非属性；\nProxy 可以直接监听数组的变化；\nProxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的； Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改； Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利； Object.defineProperty 的优势如下:\n兼容性好，支持 IE9，而 Proxy 的存在浏览器兼容性问题,而且无法用 polyfill 磨平，因此 Vue 的作者才声明需要等到下个大版本( 3.0 )才能用 Proxy 重写。 什么情况下使用 Vuex？ 如果应用够简单，最好不要使用 Vuex，一个简单的 store 模式即可\n需要构建一个中大型单页应用时，使用Vuex能更好地在组件外部管理状态\nVuex和单纯的全局对象有什么区别？ Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 为什么 Vuex 的 mutation 中不能做异步操作？ Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。 每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。 新增：vuex的action有返回值吗？返回的是什么？ store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise\nAction 通常是异步的，要知道 action 什么时候结束或者组合多个 action以处理更加复杂的异步流程，可以通过定义action时返回一个promise对象，就可以在派发action的时候就可以通过处理返回的 Promise处理异步流程\n一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。\n新增：为什么不直接分发mutation,而要通过分发action之后提交 mutation变更状态 mutation 必须同步执行，我们可以在 action 内部执行异步操作 可以进行一系列的异步操作，并且通过提交 mutation 来记录 action 产生的副作用（即状态变更） 对于即将到来的 vue3.0 特性你有什么了解的吗？ 监测机制的改变\n3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。 消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制： 只能监测属性，不能监测对象\n检测属性的添加和删除； 检测数组索引和长度的变更； 支持 Map、Set、WeakMap 和 WeakSet。 模板\n模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。 对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。 对象式的组件声明方式\nvue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。 3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易 其它方面的更改\n支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 tree shaking 优化，提供了更多的内置功能 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue3-%E7%9F%A5%E8%AF%86%E7%82%B9/","summary":"你知道Vue3.x响应式数据原理吗？ Vue3.x改用Proxy替代Object.defineProperty。 因为Proxy可以直接监听对象","title":"Vue3 知识点"},{"content":"勒布朗（LeBlanc）法则：稍后等于永不（Later equals never）\n","permalink":"https://bablvsj.github.io/posts/tech/think.md/","summary":"勒布朗（LeBlanc）法则：稍后等于永不（Later equals never）","title":"些许思考"},{"content":"Vue Vue2为什么要对数组的常用方法进行重写？\nVue的nextTick是怎么实现的？\n数据获取是用的哪个 API？ 回答 Axios。Axios 中有做哪些全局处理吗？\n同一个请求发送多次，如何保证获取的是最后一次的结果（这个当时没有想清楚）\n实现一个深拷贝，拷贝对象，要考虑循环引用\nVue 的 nextTick 是用来做什么的？它的原理是什么？\nVue 中 $set 是做什么的。写一个 $set 的伪代码。\n我写代码的时候用了 Object.create(null)，问了一下它是做什么的。\n在响应式上有什么区别？如何拦截 for\u0026hellip;in\n页面上的性能优化\n你讲一下vue双向绑定的原理\n介绍一下 Vue2 和 Vue3 的区别\n怎么把 Vue2 项目升级到 Vue3？\nProxy 和 Object.defineProperty 区别\nVue2 和 Vue3 响应式的性能有区别吗？为什么？\nVue3 有什么其他的优化，比如静态节点的优化。\nVue2 和 Vue3 的 diff 用了什么算法库？\nVue 中的数据状态管理用的什么？Vuex 的作用和用法。\nVue.extend(延长) 有用过吗？什么原理？\nVue 的路由模式哪几种，实现原理。history 服务端需要做哪些配置？\nVue2 里面 data 为什么是一个 function ？\n属性发生变化，视图会同步渲染吗？\n详细说一下 Vue2 和 Vue3 diff 算法的详细过程。这两个算法的复杂度。\n是否做过 Vue 相关的性能优化\ndefineProperty 有什么问题，处理一个对象 a.b.c 是怎么处理的？\nProxy 是怎么处理的？\nProxy 和 Reflect(反映) 有什么关系？\n介绍一下 Vue 的主要原理\n在 Diff 过程中怎么做的，Diff 算法有了解过吗？\n2.0 和 3.0 算法差异速度提高多少有了解过吗？\n数据列表渲染，动态添加一些事件有了解过吗？\n通过下标指定 key 的话会有什么问题？\n这个问题出现在 diff 算法的哪个节点？\nVue Router 的原理，hash 和 history 有什么区别？\nKeepAlive 有用过吗？实现机制。\n如果一个组件既在 exclude(排除) 又在 include 会被缓存吗？为什么这么设计？\nwebpack 讲一下webpack的打包原理\n讲一下webpack的loader和plugin\n讲一下webpack5的模块联邦\n讲一下Babel的原理，讲一下AST抽象语法树\n讲一下你所知道的设计模式\n讲一下浏览器的垃圾回收机制\n讲一下浏览器的渲染流程\n讲一下浏览器多进程的渲染优势\n谈谈你对浏览器架构的理解\n讲一下webpack5的模块联邦 说一下使用 Webpack 的优化。\n说一下 CommonJS 和 ES Module 的差异。\nWebpack 如何实现热更新？\nWebpack 和 Vite 热更新区别？\nWebpack 和 Vite 的构建流程有什么差异。\nTree Shaking 的原理，CommonJS能用吗，Tree Shaking 有什么副作用吗？\nWebpack 项目中通过 script 标签引入资源，在项目中如何处理？\n如果打包100个文件，只有某个文件发生变化，有办法单独做更新吗？\nWebpack的初始化流程？\nmodule，chunk，bundle(捆绑) 是什么意思。\n你可以说一下对 Webpack，Vite，EsBuild，SWC的理解。\n如何进行选择？\n打包速度慢怎么解决？\nWebpack 和 Vite 区别。\nJavaScript 怎么理解 JS 的异步？\n如果有多个异步函数，怎么串行执行？回答 async/await\n异步的一些 API，比如 setTimeout，setInterval，requestIdleCallback 和 requestAnimationFrame 还有 Promise，这几个有什么区别？\n有什么方法可以改变 this 指针？（call bind ）\n数组操作 map 和 forEach 有什么区别，是否可以打断循环？ filter 和 find 返回值有什么区别？\n十万个数组取第1万和第6万个元素速度有什么区别吗？为什么？\n数组的 sort 默认是按什么排序的？使用的什么算法？\ngenerator 函数和 async 函数有什么区别\n真实数组和伪数组有什么区别？\nWeakSet 和 WeakMap 有什么区别？是否可以遍历？\n订阅发布和观察者模式有什么区别？\n单例模式和工厂函数有什么区别。\n每次获取一个对象的属性都会打印 获取对象xxx的xxx，比如获取 obj.a.b，怎么实现？\nES6 现在基本上都会使用ES6开发。ES6也成为了一个面试必考点。一般面试官都会问用过ES6的哪些新特性，再针对你所回答的进行深入的提问。\n· let、const、var区别\n· 箭头函数与普通函数的区别\n· 变量的结构赋值\n· promise、async await、Generator的区别\n· ES6的继承与ES5相比有什么不同\n· js模块化（commonjs/AMD/CMD/ES6）\n能说说你对 Promise 的理解吗？\n如何处理多个 .then 导致代码一大坨很丑怎么解决？（回答了用 async/await）\nasync/await 和 Promise 什么区别？\nasync/await 怎么实现的？（我没回答出来，这个也不知道怎么回答，知道的大佬教教我）\nES6 新增了哪些数据类型，说一下用法。\n说一下事件循环机制。\nPromise.all 如果有报错，是在 then 还是 catch 接收数据？接收的是什么样的数据？\nES6 中的 Set 和 Map 有什么区别？可以遍历吗，如何遍历？\nCORS 如何实现跨域？\n观察一组数列，写一个方法求出第31个数字是什么？（通过观察后，发现那是一组斐波那契数列）\n实现一个深拷贝函数\n写一个通用的方法来获取地址栏的某个参数对应的值，不能使用正则表达式。\n假设要设计一个全局的弹窗组件你会怎么设计？\n如果这个弹窗组件可以弹出多个，消息会垂直排列，新消息会把旧消息顶起来，每个消息都可以设置一个停留时间，到了时间后就会消失，这一块你会怎么设计？\n你了解堆这种数据结构吗？讲一讲你对它的理解\n讲一下V8的垃圾回收机制\n讲一下chrome是如何渲染一个网页的\n大文件分块上传以及断点续传，你会怎么实现\nTS 是否用过 TS，用到什么功能 定义了一个 interface 只用到之前的 interface 的某几个字段则怎么办 讲一讲 TS 泛型 TS中，如果声明了一个对象，又声明了一个对象和之前的对象大部分key是相同的，怎么做。 TS 中 any 和 unknow 的区别。 写过泛型吗？说一下对泛型的理解。（问了两遍……） 一个对象，每一个 {key:value} 单独取出来声明一个联合对象？ JS 里面时间循环的过程，浏览器和 Node 的。 实现TS 内置的 Pick\nPick 类型用于从T类型中选择部分属性K来构造新的类型。\n首先，我们需要遍历对象 T。那就要使用映射类型来遍历：\n1 2 3 type MappedType\u0026lt;T\u0026gt; = { [Key in keyof T]: T[Key]; } keyof T用于从对象类型T中获取键值 key; in用于对对象键值key进行迭代; Key 就是对象键值 key 本身; T[Key]是指定 Key 的值; 要想迭代获取对象的某个部分，就需要指定要迭代的key：\n1 2 3 type MappedType\u0026lt;T, Keys\u0026gt; = { [Key in Keys]: T[Key]; }; 这样写就会有两个错误：\n不能将类型“Keys”分配给类型“string | number | symbol”。 类型“Key”无法用于索引类型“T”。 这两个错误都与迭代规则有关：\nkey 可以是string、number、symbol; 如果T中不存在Key，就不能调用T[Key]。 如果规则 2 成立，那么规则 1 一定是成立的，因为现有的 keys 是指定类型之一。为了迭代现有的 key，我们需要使用extends(延长)关键字进行约束。这样，如果指定不存在的 key，TypeScript 将抛出一个错误，如果T中不存在这个 key，就不能调用T[key]。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 type MyPick\u0026lt;T, Keys extends keyof T\u0026gt; = { [Key in Keys]: T[Key]; }; export { } // Pick可以获取指定的接口函数 interface ddd { name: string age: number } type MyPick\u0026lt;T, K extends keyof T\u0026gt; = { [P in K]: T[K] } // 拿到对象ddd的属性name的类型定义 type MyTest = MyPick\u0026lt;ddd, \u0026#39;name\u0026#39;\u0026gt; // MyTest = { name: string } js 相关\nes6 基本语法 promise async / await 原型链 渲染机制 运行机制：异步同步、 宏任务微任务 vue3相关\nref / reactive 与其区别 pinia / vuex 与其区别区别 vite / webpack 与其区别区别 vue3的优缺点 传参方式 网络\n跨域请求 Http请求码 http / https 安全：CSRF、XSS 性能优化\n前端错误监控 页面性能 算法问题\n排序（快速、选择、冒泡） 递归 CSS position 定位的方式。说一下 sticky。\n-less 和 sass 什么区别？\n什么是BFC、可以解决哪些问题\n盒模型\n· 垂直居中方法\n· 三栏布局\n· 选择器权重计算方式\n· 清除浮动的方法\nFlex flex: 1 代表什么？flex-basis可以设置哪些值，和 width 哪个优先级更高？ space-between 和 space-around 区别，是否能调整他们间隙的值？ align-content 和 justify-content 区别？ 介绍一下 flex 布局。 flex-basis是做什么的，和 width 哪个优先高？ flex 中如果有剩余元素或者空间不够会怎么办？ · 如何实现一个自适应的正方形\n浏览器相关知识 浏览器相关知识几乎是每个公司都会问到的考点，里面涉及的东西也比较多。其中缓存、http2、跨域必问。\n· 从输入URL到呈现页面过程\n· 强缓存、协商缓存、CDN缓存\n· HTTP2\n· HTTP状态码\n· 三次握手与四次挥手\n· 跨域（JSONP/CORS）\n· 跨域时如何处理cookie\n· 垃圾回收机制\nHTTP 和 HTTPS有什么区别？\n使用 HTTPS 一定是安全的吗？\nweb安全 一般我都会从xss和csrf说起。\n· https\n· 什么是xss，如何预防\n· 什么是csrf，如何预防\n· 为什么会造成csrf攻击\n事件循环 事件循环绝对是一个必考题。其中涉及到宏任务、微任务、UI渲染等的执行顺序，浏览器端的必须要掌握，node端的有精力的最好也能掌握。\n框架（vue） 因为我一直用的都是vue框架，所以问的也都是跟vue相关的。vue中的高频题也不外乎双向绑定、虚拟dom、diff算法这些。\n· watch与computed的区别\n· vue生命周期及对应的行为\n· vue父子组件生命周期执行顺序\n· 组件间通讯方法\n· 如何实现一个指令\n· vue.nextTick实现原理\n· diff算法\n· 如何做到的双向绑定\n· 虚拟dom为什么快\n· 如何设计一个组件\nwebpack webpack也基本上成了必考的内容，一般会问是否配置过webpack、做过哪些优化之类的。\n· 用过哪些loader和plugin\n· loader的执行顺序为什么是后写的先执行\n· webpack配置优化\n· webpack打包优化（happypack、dll）\n· plugin与loader的区别\n· webpack执行的过程\n· 如何编写一个loader、plugin\n· tree-shaking作用，如何才能生效\n性能优化 · 首屏加载如何优化\n· 一个网页从请求到呈现花了很长时间，如何排查\n1.工作中使用过加密方法，简单介绍一下\nMD5 / ASC / DESC\n2. 对前端模块化的了解有多少，为什么要模块化开发\n2 提高代码复用率\n3 提高维护性\n4 依赖关系的管理\n3.将下面这个数组去重（写出3种方法即可）\nlet arr=[1,29,3,1,50,5,10,57,6,5]\n手写编程题 1.扁平结构转嵌套结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // 扁平结构 const list = [ { name: \u0026#39;数据1\u0026#39;, parent: null, id: 1, }, { name: \u0026#39;数据2\u0026#39;, id: 2, parent: 1, }, { name: \u0026#39;数据3\u0026#39;, parent: 2, id: 3, }, { name: \u0026#39;数据4\u0026#39;, parent: 3, id: 4, }, ]; // 树形结构 const tree = [ { name: \u0026#39;数据1\u0026#39;, id: 1, children: [ { name: \u0026#39;数据2\u0026#39;, id: 2, children: [ { name: \u0026#39;数据3\u0026#39;, id: 3, children: [ { name: \u0026#39;数据4\u0026#39;, id: 4, }, ], }, ], }, ], }, ]; 2.给一段代码，求输出 1 2 3 4 5 6 7 8 9 var length = 5 function a() { console.log(this.length) } function b(fn) { fn() arguments[0]() } b(a, 1) · 防抖和节流\n· 深拷贝\n· 数组去重、数组乱序\n· 手写call、apply、bind\n· 继承（ES5/ES6）\n· sleep函数\n· 实现promise\n· 实现promise.all\n· 实现promise.retry\n· 将一个同步callback包装成promise形式\n· 写一个函数，可以控制最大并发数\n· jsonp的实现\n· eventEmitter(emit,on,off,once)\n· 实现instanceof\n· 实现new\n· 实现数组flat、filter等方法\n· lazyMan\n· 函数currying\n代码题，写一个发布订阅\n出了一道算法题，找一个字符串中最长的不含重复字符的子串，滑动窗口可做。\n项目管理 介绍下项目A\n项目有什么效果，如何判断效率提升率？（本地测还是统计数据发送到服务端？）\n项目后续规划，现在有什么问题？风险怎么处理？\n项目中有什么是收获很多的？\n推广过程中遇到什么困难？\n重新做一遍你觉得有哪些你觉得可以做得做好的事情？\n用到一些插件的原理\n项目排期的管控。\n技术之外 最近有了解哪些新技术吗？\n你认为一个五年的前端工程师应该需要哪些能力？你哪方面做的好或不好？\n你觉得你是一个什么样的人？\n你有哪些优点？\n你想成为一个什么样的人？\n你觉得你的技术水平怎么样？\n如果让你给自己打标签，你会打什么标签？\n回看你的过往人生，你后悔吗？\n-平时怎么学习前端技术？\n还有什么有亮点的项目。\n怎么做技术选型。\n说一下你的优点\n说一下你的缺点\n最近几份工作的主要内容\n你这几份工作的离职原因\n你认为你做的最有亮点的事情\n有什么事情是你认为你做的不够好的\n什么事情是你认为比较有成就感的\n和产品或其他人出现分歧怎么办\n你找工作更看重什么/对新工作有什么期待\n未来的发展方向\n工作强度大能接受吗\n","permalink":"https://bablvsj.github.io/posts/interview/temp-question-list/","summary":"Vue Vue2为什么要对数组的常用方法进行重写？ Vue的nextTick是怎么实现的？ 数据获取是用的哪个 API？ 回答 Axios。Axios 中有做","title":"面试题列表"},{"content":"完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import os import re import sys import glob path = \u0026#39;D:/2cr/temp/hugoBlog/content/temp\u0026#39; # 指定所需处理文件的目录 # 递归遍历文件夹 for root, dirs, files in os.walk(path): for file in files: if os.path.splitext(file)[1] == \u0026#39;.md\u0026#39;: # 匹配后缀名为md的文件 filename = os.path.splitext(file)[0] # 获取文件名 dirFile = os.path.join(root, file) # 获取文件完整目录（如果文件层级过深） print(filename) def write_file(): # with open(file,\u0026#34;r+\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) as f: # f.seek(0) # content = f.read() # print(tempText) # f.write(tempText) # f.close() # 读取文件内容 f = open(dirFile, \u0026#34;r\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) #指定编码类型 content = f.read() tempText = \u0026#34;--- \\n title: \u0026#34;+filename+\u0026#34; \\n date: 2020-01-01T17:11:35+08:00 \\n draft: false \\n tags: \\n - 开发软件快捷使用 \\n---\\n \\n\u0026#34; + content f.close() # 写入文件内容 f = open(dirFile, \u0026#34;w\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) f.write(tempText) f.close() 读取文件 open(文件路径,读写方式,编码) r: 文件以只读方式打开（也是默认模式）。 w: 文件以写入方式打开，会重置文件。 x: 创建一个新文件且写入。 a: 追加写入(如果文件存在，会在末尾进行追加)。 b: 文件以二进制打开。 t: 文件以文本模式打开（也是默认模式）。 +: 打开文件进行更新（可读可写）。\n1 2 3 openFile = open(\u0026#34;xxxx.txt\u0026#34;,\u0026#34;w\u0026#34;) print(openFile) open_file.close() 写入文件 1 2 3 f = open(dirFile, \u0026#34;w\u0026#34;,encoding=\u0026#39;utf-8\u0026#39;) f.write(tempText) f.close() ","permalink":"https://bablvsj.github.io/posts/tech/python/20230802-%E6%89%B9%E9%87%8F%E8%AF%BB%E5%8F%96%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6/","summary":"完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import os import re import sys import glob path = \u0026#39;D:/2cr/temp/hugoBlog/content/temp\u0026#39; # 指定所需处理文件的目录 # 递归遍历文件夹 for root, dirs,","title":"Python 批量读取修改指定类型文件"},{"content":"https://juejin.cn/post/7262007830721757244#heading-4 https://juejin.cn/post/7213994684262891576#heading-11\nPinia 的优点 更贴合 Vue 3 的 Composition API 风格,学习成本更低 不需要区分 Mutation 和 Action,统一使用 Actions 操作状态 支持 TypeScript,可以充分利用 TS 的静态类型系统 模块化管理 States,每个模块是一个 Store 直观的 Devtools,可以看到每个 State 的变化 使用 Pinia 1.安装 1 2 yarn add pinia //或者使用 npm npm install pinia 2.引入 1 2 3 4 5 6 7 8 //main.ts import { createApp } from \u0026#39;vue\u0026#39; import { createPinia } from \u0026#39;pinia\u0026#39; const pinia = createPinia() const app = createApp(App) app.use(pinia) 3.Option Store 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // store/user.ts import { defineStore } from \u0026#39;pinia\u0026#39; export const useUserStore = defineStore(\u0026#39;user\u0026#39;, { // state 定义响应式状态 state: () =\u0026gt; { return { name: \u0026#39;lvbu\u0026#39;, age:\u0026#34;\u0026#34; } }, // getters 计算属性 getters: { getUserName(state) { return state.name } }, //定义方法修改状态 actions: { changeUserName(name) { this.name = name } } }) 4.使用 1 2 3 4 5 import { useUserStore } from \u0026#39;@/store/user\u0026#39; const store:any = useUserStore() console.log(store.name) 5. 修改数据 修改数据多种方法，可以直接修改，也可以使用 actions 修改。\n方法1：直接修改 1 2 3 import { useUserStore } from \u0026#39;@/store/user\u0026#39; const store = useUserStore() store.userInfo = obj // obj 指新值 方法2：借助 actions 修改 1 2 3 import { useUserStore } from \u0026#39;@/store/user\u0026#39; const store = useUserStore() store.changeUserName(obj) // obj 指新值 方法3：多属性修改 1 2 3 4 5 6 7 8 import { defineStore } from \u0026#39;pinia\u0026#39; export const useUserStore = defineStore(\u0026#39;user\u0026#39;, { state: () =\u0026gt; ({ name: null, age: null, sex: null, }), }) 上面的方法都是用来修改单个属性的，如果你需要一次修改多个属性，虽然你可以重复操作上面的方法，但是 pinia 提供了新的方法，我更推荐使用官方推荐的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 import { useUserStore } from \u0026#39;@/store/user\u0026#39; const store = useUserStore() // 你可以这样去修改（不建议） store.name = \u0026#39;张三\u0026#39; store.age = 24 store.sex = \u0026#39;男\u0026#39; // 推荐使用下面这种方式 √ store.$patch({ name: \u0026#39;张三\u0026#39;, age: 24, sex: \u0026#39;男\u0026#39;, }) 修改数据的场景及方法当然不止这些，有些复杂的数据修改仅靠这些是难以实现的，不过本文的目的是简单讲解 pinia 的使用方法，就不多做赘述了，想具体了解推荐去看 Pinia 官方文档。\n","permalink":"https://bablvsj.github.io/posts/interview/vue3/20230801-vue3%E6%96%B0%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7-pinia/","summary":"https://juejin.cn/post/7262007830721757244#heading-4 https://juejin.cn/post/7213994684262891576#heading-11 Pinia 的优点 更贴合 Vue 3 的 Composition API 风格,学习成本更低 不需要区分 Mutation 和 Action,统一使用 Actions 操作状态 支持 TypeScript,可以充分利用 TS 的静态类","title":"Vue3 新的状态管理工具 Pinia"},{"content":"父子组件 props 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //父组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildrenVue :msg=\u0026#39;msg\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup \u0026gt; import ChildrenVue from \u0026#39;../components/Children.vue\u0026#39;; import { ref } from \u0026#39;vue\u0026#39; const msg = ref(\u0026#39;哈喽哈喽\u0026#39;) } \u0026lt;/script //子组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt; {{msg}}\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; export default { props: [\u0026#39;msg\u0026#39;], const msg = props.msg } \u0026lt;/script\u0026gt; defineProps 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //我是子组件 \u0026lt;template\u0026gt; \u0026lt;h1\u0026gt; {{props.msg}}\u0026lt;/h1\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; // const props = defineProps\u0026lt;{ msg?: string, }\u0026gt;() ts写法 const props = defineProps({ // 写法一 // msg: String //写法二 msg: { type: String, default: \u0026#39;\u0026#39; } }) console.log(props.msg); \u0026lt;/script\u0026gt; emit 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //父组件 \u0026lt;template\u0026gt; \u0026lt;ChildrenVue @myClick=\u0026#39;onMyClick\u0026#39; /\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import ChildrenVue from \u0026#39;../components/Children.vue\u0026#39;; const onMyClick = (msg) =\u0026gt; { console.log(msg); } \u0026lt;/script\u0026gt; //子组件 \u0026lt;template\u0026gt; \u0026lt;button @click=\u0026#34;handleClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import { defineEmits } from \u0026#39;vue\u0026#39; const emit = defineEmits([\u0026#39;myClick\u0026#39;]) const handleClick = () =\u0026gt; { emit(\u0026#39;myClick\u0026#39;, \u0026#39;我是子组件给父组件的\u0026#39;) } \u0026lt;/script\u0026gt; ref 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 //父组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Childre ref=\u0026#39;children\u0026#39; /\u0026gt; \u0026lt;button @click=\u0026#34;getChild\u0026#34;\u0026gt;获取子组件的属性和方法\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; import Children from \u0026#39;../components/Children.vue\u0026#39;; import { ref } from \u0026#39;vue\u0026#39; const children = ref(null) const getChild = () =\u0026gt; { console.log(children.value.title); children.value.toggle() } \u0026lt;/script\u0026gt; //子组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; 我是子组件 \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup\u0026gt; const title = \u0026#39;我是子组件的属性\u0026#39; const toggle = () =\u0026gt; { console.log(\u0026#39;我是子组件的方法\u0026#39;); } \u0026lt;/script\u0026gt; 兄弟组件 路由传参 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 传递 import { useRouter } from \u0026#39;vue-router\u0026#39; const router = useRouter() router.push({ path: \u0026#39;/detail\u0026#39;, query: { id: 12345 } }) // 接收 import { useRoute, computed } from \u0026#39;vue-router\u0026#39; const route = useRoute() const id = computed(() =\u0026gt; { return route.query.id }) 本地缓存 1 2 3 4 5 6 7 // 存储 sessionStorage.setItem(\u0026#34;id\u0026#34;, 12345); localStorage.setItem(\u0026#34;id\u0026#34;, 12345); // 读取 sessionStorage.getItem(\u0026#34;id\u0026#34;); localStorage.getItem(\u0026#34;id\u0026#34;); 通用 provide / inject 依赖注入 1 2 3 4 5 6 7 8 9 10 11 12 //父组件(传值组件) \u0026lt;script setup\u0026gt; import { provide } from \u0026#34;vue\u0026#34; provide(\u0026#34;name\u0026#34;, \u0026#34;lvxiaobu\u0026#34;) \u0026lt;/script\u0026gt; //子组件(接收组件) \u0026lt;script setup\u0026gt; import { inject } from \u0026#34;vue\u0026#34; const name = inject(\u0026#34;name\u0026#34;) console.log(name) // lvxiaobu \u0026lt;/script\u0026gt; pinia (推荐使用) / vuex Vuex和Pinia可以轻松实现组件通信\neventBus Vue3中移除了事件总线，但是可以借助于第三方工具来完成，Vue官方推荐mitt或tiny-emitter\n","permalink":"https://bablvsj.github.io/posts/interview/vue3/20230801-vue3-%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F/","summary":"父子组件 props 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //父组件 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;ChildrenVue :msg=\u0026#39;msg\u0026#39; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup \u0026gt; import ChildrenVue from \u0026#39;../components/Children.vue\u0026#39;; import { ref } from \u0026#39;vue\u0026#39; const msg = ref(\u0026#39;哈喽哈","title":"Vue3 常用传参方式"},{"content":"一、git 下载安装与检测是否安装成功 1、git 官网官网地址，这边提醒您官网是外网下载速度极慢。 所以我推荐阿里的下载地址，版本有特别多，那就随机抽取一个幸运的安装包吧！ 1、下载完成点击安装，一路 next 无脑操作就行。 2、安装完成后输入Win + R打开命令窗口，输入git version后如下方显示则安装成功。 1 2 C:\\Users\\lvsj\u0026gt;git version git version 2.30.1.windows.1 二、git 命令常用操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 1、git 常用命令 查看状态 git status 增加文件 git add \u0026#39;text.html\u0026#39; 提交到暂存区 git commit -m \u0026#39;测试提交\u0026#39; 查看所有分支 git branch -a 查看当前使用分支 git branch(结果列表中前面标*号的表示当前使用分支) 切换分支 git checkout 分支名 查看版本号 git log --pretty=oneline 切换版本 git reset --hard 134b(版本号) 查看每一次命令 git reflog 查看分支图 git log --graph 删除文件 git rm text.vue 删除文件夹 git rm -r text.vue 将提交推送到另一分支 git push origin master:dev 拉取代码： C:\\Users\\Administrator\u0026gt;git config --global user.name \u0026#34;lvsijun\u0026#34; C:\\Users\\Administrator\u0026gt;git config --global user.email \u0026#34;1369573083@qq.com\u0026#34; 生成ssh密匙： ssh-keygen -t rsa -C \u0026#34;1369573083@qq.com\u0026#34; 密匙文件目录：C:\\Users\\Administrator\\.ssh\\ 的id_rsa.pub文件 3、如何将代码上传到自己的git上 (1).初始化本地仓库 git init (2).查看文件状态 git status (3).添加文件 git add . (4).删除文件 git rm -r xxx文件名 (5).提交文件到本地仓库 git commit -m \u0026#34;您需要填写的备注\u0026#34; (6).推送到远端git地址 git push （如果是第一次提交代码看第7条） (7).如果是第一次提交的话看这里: I、更改路径 git remote add origin git@github.com:xxxxxxx/test.git II、推送 git push -u origin master 命令：git update-index --no-assume-unchanged 文件名 作用：上一个命令的逆操作，重新追踪文件改动。 常用操作 强拉代码 1 2 3 git fetch --all git reset --hard origin/master git pull 忽略文件改动不进行提交 git update-index \u0026ndash;assume-unchanged 文件名\n作用：忽略文件的改动，但不加入.gitignore中，可以达到仅在本地目录中忽略，不影响其他团队成员的工作。\n删除文件 删除文件 git rm text.vue 删除文件夹 git rm -r text.vue\n","permalink":"https://bablvsj.github.io/posts/blog/2023/001-gitinstall/","summary":"一、git 下载安装与检测是否安装成功 1、git 官网官网地址，这边提醒您官网是外网下载速度极慢。 所以我推荐阿里的下载地址，版本有特别多，那就随","title":"git安装/常用命令"},{"content":"1. 基础环境搭建 安装 git 从 github 拉取/推送代码 安装 hugo 在 v 站看到 子舒 的个人网站，十分简约美观，开始了解到 hugo。\n2. Hugo 网站生成 3. GitPage 部署个人网页 4. GitActions 自动化部署 ","permalink":"https://bablvsj.github.io/posts/life/20230725-%E5%BB%BA%E7%AB%99%E5%8E%86%E7%A8%8B/","summary":"1. 基础环境搭建 安装 git 从 github 拉取/推送代码 安装 hugo 在 v 站看到 子舒 的个人网站，十分简约美观，开始了解到 hugo。 2. Hugo 网站生成 3. GitPage 部署个人网页 4. GitActions 自动","title":"本站创建历程"},{"content":" 让子弹飞（申遗！）\n阿甘正传（“我妈妈经常说，生活就像巧克力，你永远不知道下一颗是什么口味。”）\n初恋这件小事（这就是初恋的感觉）\n楚门的世界（“如果再不能见到你，祝你早安、午安、晚安”）\n当幸福来敲门（“不要让别人告诉你，你不能做什么！”）\n地道战（抗日人民的脑洞真的很大）\n闻香识女人（这部电影的台词真叫一个绝！）\n肖申克的救赎（经典不解释）\n放牛班的春天（天籁之音）\n蜘蛛侠 1 （没看过漫画，比较喜欢老版电影）\n机器人总动员（瓦力超会卖萌）\n怦然心动（两个人的视角来讲述一个青春故事）\n入殓师（没有令人不适的镜头，可以放心观看，治愈系）\n三傻大闹宝莱坞（人物冲突处理到极致）\n海上钢琴师（音乐很棒）\n那些年 我们一起追过的女孩\n千与千寻（就挺奇幻的）\n夺宝奇兵系列（看敌人在耍大刀，无奈一枪放倒）\n封神三部曲 （第一部 狐狸出世纣王无道天下大乱 第二部 纣王率军伐西岐 第三部 姬发联合各诸侯反攻）\n钢铁侠 1 （个人认为漫威系列最佳）\n国王的演讲（带英国挺过二战的国王是个口吃，超长待机女王是他的长女）\n哈利波特 1 、2 （让我对魔法世界最有新鲜感的两部，后面就有点暗黑了）\n好想告诉你（电影+动画）\n黑客帝国系列（见证了两个导演从兄弟变为姐弟在变为姐妹）\n横空出世（“你愿意隐姓埋名一辈子吗？”）\n虎胆龙威系列（英文名Die hard超级贴切 喜欢布鲁斯威利斯被两头坑的无奈表情）\n歌舞青春 1 （歌挺好听的）\n环太平洋（音乐起！）\n回到未来系列（被致敬无数次的科幻经典）\n机器管家（一个想成为人类的机器人的人生）\n疾速追杀系列（“A fuxxing pencil!”）\n罗马假日(男女主颜值超高)\n玫瑰人生（ Edith Piaf 传记，喜欢她的歌可以看一看）\n七磅（片名出自威尼斯商人，主角的还“债”历程，同时也是自我的救赎）\n情书（光良的童话 MV 里面两个人看的那个电影，治愈系）\n速度与激情 3 （可能我是个异类？）\n天使爱美丽（色彩、音乐都很棒，文艺片）\n天堂电影院（一段忘年之交）\n头文字 D （“永远不要有跟人斗的心，你要赢的是你自己。”）\n我，机器人（威尔史密斯主演动作电影的入坑作，其他像黑衣人之类的也很棒）\n我是传奇 1 （有点丧尸版鲁滨逊漂流记的感觉）\n无间道（港版经典）\n西西里的美丽传说（又硬又难受，人言可畏）\n逍遥法外（又叫猫鼠游戏，小李子和汤姆汉克斯版）\n小鬼当家系列（脑洞超大，超搞笑）\n窈窕奶爸（罗宾威廉姆斯演技、口技超一流）\n云图（一旦看懂了，就挺妙）\n战争之王（点子超多的军火商的传奇故事）\n这个杀手不太冷（反差萌）\n终结者 2 （👍）\n最后的武士（挺悲壮的故事）\n宝莲灯（动画，个人认为已经逼近迪士尼水准了）\n暴力街区 Banlieue 13 （跑酷鼻祖大卫贝尔主演）\n变相怪杰（金凯瑞的脸简直就像橡皮泥）\n不能说的秘密（曲子都是精品）\n宫崎骏作品（我是有少女心？）：\n天空之城（入坑作，我一直感觉是映射侵华战争）\n龙猫（超可爱！）\n幽灵公主（又叫魔法少女，久石让作曲超美）\n魔女宅急便（我也想养一只黑猫）\n哈尔的移动城堡（全程注意力在菜头上）\n周星驰主演的经典无厘头，和猫和老鼠一样，可以电视轮播偶尔看一眼：\n喜剧之王\n唐伯虎点秋香\n百变星君\n大话西游系列\n功夫\n国产凌凌漆\n","permalink":"https://bablvsj.github.io/posts/life/20221216-%E4%B8%80%E4%BA%9B%E5%80%BC%E5%BE%97%E4%B8%80%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/","summary":"让子弹飞（申遗！） 阿甘正传（“我妈妈经常说，生活就像巧克力，你永远不知道下一颗是什么口味。”） 初恋这件小事（这就是初恋的感觉） 楚门的世界（“","title":"一些值得一看的电影"},{"content":"初始模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 title: \u0026#34;模板\u0026#34; date: 2023-07-25T13:46:19+08:00 draft: true # 是否为草稿 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 showToc: true # 显示目录 TocOpen: true # 自动展开目录 hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等 comments: true disableShare: false # 底部不显示分享栏 showbreadcrumbs: true #顶部显示当前路径 description: \u0026#34;\u0026#34; weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序 slug: \u0026#34;\u0026#34; cover: image: \u0026#34;\u0026#34; caption: \u0026#34;\u0026#34; alt: \u0026#34;\u0026#34; relative: false ![[Pasted image 20230728135404.png]]\n","permalink":"https://bablvsj.github.io/posts/life/20230725-helloworld/","summary":"初始模板 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 title: \u0026#34;模板\u0026#34; date: 2023-07-25T13:46:19+08:00 draft: true # 是否为草稿 categories: - 分类1 - 分类2 tags: - 标签1 - 标签2 showToc: true","title":"HelloWorld"},{"content":"最新自考笔记 : https://github.com/Eished/self-study-exam_notes\nhttps://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx\n大纲 2018 版 题型 题数 * 得分 合计 单项选择题 15 题 x 2 分 30 分 填空题 10 题 x 1 分 10 分 设计题 5 题 x 4 分 20 分 简答题 5 题 x 6 分 30 分 综合题 1 题 x 10 分 10 分 数据库系统原理试卷分析 选择题 30 分（重要） 1 数据库概念发展 2 数据库系统结构 3 关系数据结构 4 关系数据结构 5 关系数据结构 6 数据库设计 7 数据库设计 8 MySQL 操作 9 MYSQL 操作 10 数据库编程 存储过程 11 数据库完整性约束 12 触发器 13 用户权限 14 数据仓库 15 数据仓库 大数据\n填空题 10 分 16DBMS 概念 17 表的态 18 数据库设计 19 数据库设计安全 20 数据库操作语句 21 数据库安全 完整性约束 触发器 22 数据库安全 权限 23 数据库安全 事务 24 数据 25 大数据\n设计题 20 分 (重要) 27 关系代数查询 28SQL 语句查询 29SQL 语句查询 30SQL 语句建立视图\n简答题 30 分 (重要) 31 数据库系统的结构 32 数据库安全完整 33 数据库编程存储 34 数据库编程存储过程体 35 数据库安全事务-封锁\n综合题 10 分\n36 数据库设计 （1）E-R 图 （2）关系模式 （3）SQL 语句建立表\n使用软件 MySQL Workbench 第一章 数据库系统概论 第一节 数据库基本概念 数据(Data)：描述事物的符号记录，是指利用物理符号记录下来的、可以鉴别的信息。\n数据库（DataBase, DB）：指长期存储在计算机内、有组织的、可共享的大量数据的集合。 数据库中存储的数据的三个基本特点：永久存储、有组织、可共享\n数据库管理系统(DataBase Management System, DBMS)：专门用于建立和管理数据库的一套软件，介于应用程序和操作系统之间的。\nDBMS 的主要功能：\n数据库的定义功能（提供数据定义语言（DDL）、定义数据库中的数据对象） 数据组织、存储和管理功能 数据库的操纵功能（提供数据操纵语言（DML）、 基本的数据操作有检索和更新两类） 数据库的事务管理和运行管理 数据库的建立和维护功能（提供实用程序/工具， 完成数据库数据批量装载， 数据库转储， 介质故障恢复， 数据库的重组织和性能监视等） 其它功能 数据库系统(DataBase System,DBS)：指在计算机系统中引入数据库后的系统构成。一般由数据库、数据库管理系统、应用程序、数据库管理员（Database Administrator，DBA）和用户构成。\n1．DBS 的组成：是数据库、硬件、软件和数据库管理员的集合体。 2．软件包括 DBMS、OS、各种主语言和应用开发支撑软件等程序。其中，DBMS 是 DBS 的核心软件，要在 OS 支持下才能工作。 3．数据库管理员（DBA）：是控制数据整体结构的一组人员，负责 DBS 的正常运行，承担创建、监控和维护数据库结构的责任。\n第二节 数据管理技术的发展 数据管理是指对数据进行分类、组织、编码、存储、检索和维护的工作，是数据处理和数据分析的中心问题\n人工管理 （20世纪50年代中之前）\n数据不保存 应用程序管理数据（没有专门的数据库管理系统） 数据面向应用程序（数据不能共享、一组数据只能对应一个程序） 文件系统 （20世纪50年代末\u0026ndash;60年代中）\n长期保存 文件系统提供了数据的物理独立性 实现数据的文件级共享, 不能实现数据普通共享, 存在大量数据冗余 数据库系统 （20世纪60年代末\u0026ndash;至今）\n数据集成（主要目的） 数据共享性高 数据冗余小 数据一致性 数据独立性高 实施统一管理与控制 减少应用程序开发与维护的工作量 数据库引起不一致的根源是数据冗余，通过消除或控制数据冗余\n数据库系统具有对数据的统一管理和控制功能包括4个方面：\n数据安全性（Security）保护：保护数据，以防止不合法的使用，而造成数据的泄密和破坏 数据的完整性（Integrity）检查：保证数据的正确性、 有效性和相容性 并发控制（Concurrency Control）：对多用户的并发操作加以控制和协调， 防止相互干扰导致的错误 故障恢复（Recovery）：将数据库从错误状态恢复到某一已知的正确状态的功能 第三节 数据库系统的结构 1.3.1 数据库系统的三级模式结构 DBA视角 内部系统结构： 采用三级模式：外模式、模式、内模式 外部系统结构： 集中式结构、分布式结构、并行结构\n数据库应用的用户角度： CS(客户/服务器 )结构、BS(浏览器/服务器)结构\n名称 别称 视图类型 模式 概念模式、逻辑模式 概念视图 外模式 子模式、用户模式 数据视图，即用户视图 内模式 存储模式 内部视图、存储视图 模式（Schema）: 逻辑模式 / 概念模式\n是数据库全体数据的逻辑结构和特征的描述, 是所有用户的公共数据视图。 外模式（External Schema）:子模式 / 用户模式\n数据库用户使用的局部数据的逻辑结构和特征的描述。 一个外模式可以为 多个应用系统所使用，一个应用程序只能使用一个外模式 内模式（Internal Schema）: 存储模式\n是数据物理结构和存储方式的描述。 一个数据库只有一个内模式 三级模式结构的两层映像与数据独立性\n映像，是一种对应规则，它指出映像双方是如何进行转换的。\n逻辑数据独立性：外模式 / 模式 当模式改变时，DBA对 外模式／模式 映像作相应改变， 使外模式保持不变，则应用程序不必修改， 保证了数据与程序的逻辑独立性。\n物理数据独立性：模式 / 内模式 当数据库的存储结构改变了（例如选用了另一种存储结构） ， DBA修改模式／内模式映象， 使模式保持不变。模式不变， 则应用程序不变。 保证了数据与程序的物理独立性。\n应用A/B/C \u0026lt;\u0026mdash;\u0026gt; 外模式1/2/3 \u0026lt;\u0026ndash; 外模式/模式映像 \u0026ndash;\u0026gt; 模式 \u0026lt;\u0026ndash; 模式/内模式映像 \u0026ndash;\u0026gt; 内模式 \u0026lt;\u0026mdash;\u0026gt; 数据库\n外模式/模式映像，存在于外模式和逻辑模式之间，用于定义外模式和逻辑模式之间的对应性。 逻辑模式/内模式映像，存在于逻辑模式和内模式之间，用于定义逻辑模式和内模式之间的对应性。 模式（Schema）：是对数据库逻辑结构和特征的描述，是型的描述， 不涉及具体值，模式是相对稳定的\n实例（Instance）：数据库某一时刻的状态——模式的一个具体值，同一个模式可以有很多实例，实例随数据库中的数据的更新而变动\n例题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 “学生选课数据库” 模式：学生、课程和学生选课3个关系模式： 学生表： Student(Sno， Sname， Ssex， Sage， Sdept) 课程表： Course(Cno， Cname， Cpno， Ccredit) 学生选课表： SC(Sno， Cno， Grade) 2014年的学生选课数据库实例： 2014年学校中所有学生的记录 2014年学校开设的所有课程的记录 2014年所有学生选课的记录 2013年的学生选课数据库实例： 2013年学校中所有学生的记录 2013年学校开设的所有课程的记录 2013年所有学生选课的记录 2014年度和2013年度对应“学生选课数据库”模式的2个数据库实例是不同的 1.3.2 数据库系统的运行与应用结构 客户/服务器 (Client/Server, CS) 结构 客户端、前台、表示层主要完成与数据库使用者的交互任务。 服务器、后台、数据层主要负责数据管理\n浏览器/服务器 (Browser/Server, B/S) 结构 三层客户/服务器结构，表示层、处理层（中间层）、数据层\n第四节 数据模型 数据模型是对现实世界数据特征的抽象，通俗地讲数据模型就是现实世界的模拟。\n1.4.1 数据特征与数据模型组成要素 数据模型组成 数据结构\u0026ndash;描述系统的静态特征，即数据对象的数据类型、内容、属性以及数据对象之间的练习。 数据操作\u0026ndash;描述系统的动态特征，对象的实例允许执行的操作的集合，主要有更新和检索两大类。 数据约束：描述数据结构中数据间的语法和语义关联 1.4.2 数据模型的分类 现实世界 ==\u0026gt; 概念模型 ： 数据库设计人员完成 概念模型 ==\u0026gt; 逻辑模型 ：数据库设计人员完成、数据库设计工具辅助完成 逻辑模型 ==\u0026gt; 物理模型 ：由DBMS完成 1 2 3 4 graph TD c1((现实世界)) ---- c2((认识抽象)) c2((认识抽象)) --- 信息世界-概念模型 信息世界-概念模型 --- 机器世界-数据库管理系统支持的数据模型 概念模型的表示方法\n实体型: 用矩形表示, 内写实体名 属性: 椭圆表示, 内写名称, 无向边连接相应实体 联系: 菱形表示, 内写名称, 无向边连接实体 概念模型的一种表示方法：实体-联系图（Entity-Relationship，E-R图）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 graph TD c1((开始)) --- 供应商 c2((账号)) --- 供应商 c3((地址)) --- 供应商 c4((电话号码1)) --- 供应商 供应商 --- b1{供应} b1{供应} --- 零件 零件 --- c5((零件号)) 零件 --- c6((规格)) 零件 --- c7((名称)) 零件 --- b2{库存} b2{库存} --- c16((库存量)) b2{库存} --- 仓库 仓库 --- c13((仓库号)) 仓库 --- c14((面积)) 仓库 --- c15((电话号码2)) 仓库 --- b3{工作} b3{工作} --- 职工 c12((职工号)) --- 职工 c11((姓名1)) --- 职工 概念层数据模型 概念模型的用途\n概念模型用于信息世界的建模\n是现实世界到机器世界的一个中间层次\n是数据库设计的有力工具\n数据库设计人员和用户之间进行交流的语言\n信息世界中的基本概念\n实体(Entity)：客观存在并可相互区别的事物称为实体。可以是具体的人、 事、 物或抽象的概念 属性(Attribute)：实体所具有的某一特性称为属性。 一个实体可以由若干个属性来刻画 码或键(Key)：唯一标识实体的属性集称为码。 域(Domain) 实体型(Entity Type)：用实体名及其属性名集合来抽象和刻画同类实体 实体集(Entity Set)：同一类型实体的集合称为实体集 联系(Relationship)：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型） 内部的联系和实体（型） 之间的联系。 实体内部的联系: 是指组成实体的各属性之间的联系\n实体之间的联系: 通常是指不同实体集之间的联系。实体之间的联系有一对一（1:1)、一对多（1:n）和多对多（m:n）\n逻辑层数据模型，是按照计算机系统的观点对数据建模， 用于DBMS实现。\n网状模型 层次模型 关系模型 二维表 面向对象数据模型 对象关系数据模型 半结构化数据模型 物理层数据模型，是对数据最底层的抽象，用于描述数据在系统内（磁盘上） 的表示方式和存取方法。\n第二章 关系型数据库（重点） 第一节 关系型数据库概述 商用数据库管理系统中，关系模型逐渐取代早起的网状模型和层次模型，成为主流数据模型。\n关系型数据库的基本特征是使用关系数据模型组织数据。 关系型数据库的优点：高级的分过程语言接口、较好的数据独立性、为商品化的关系数据库管理系统的研制做好了技术上的准备。\n关系数据库系统是支持关系模型的数据库系统\n关系模型由关系数据结构、关系操作集合和完整性约束三部分构成\n关系数据结构\n一张扁平的二维表 可以描述现实世界中的实体以及实体间的各种关系 关系操作集合\n集合操作方式（操作对象和结果都是集合） 操作包括：选择、投影、连接、除、并、交、差等查询操作和增、删、改操作两部分构成 结构化查询语言（SQL, Structured Query Language）是关系数据库操作的标准语言 完整性约束\n实体完整性 参照完整性 用户定义的完整性 第二节 关系型数据模型 2.2.1 关系数据结构(字典) 表(Table)\n也称关系, 二维的数据结构; 由唯一表名、若干列、若干行数据组成 关系(Relation)：一个关系对应通常说的一张表，现实世界的实体以及实体间的各种联系均用关系来表示。\n基本关系: 实际存在的表，是实际存储数据的逻辑表示 查询表: 查询结果对应的表 视图表: 由基本表或其它试图表导出的表，是虚表，不对应实际存储的数据 列(Column)：字段或属性，属性的个数成为关系的元或度\n也称字段(Field)或属性; 有唯一列名, 表示一种属性 域(Domain)：属性的取值范围来自某个域。 例：学生年龄属性的域（15～45岁），性别的域是（男， 女）\n行(Row)：称元组(Tuple)或记录(Record)，表中的一行即为一个元组\n分量(Component)：元组中的一个属性值\n码或键(Key)：称码键，唯一标识元组关系的属性。\n超码或超键(Super Key)\n在关系中的一个码移去某个属性, 它任然是这个关系的码, 称为该关系的超码或超键 一般每个关系至少有一个默认的超码, 即该关系的所有属性的集合 候选码或候选键(Candidate Key)：能够唯一标识一条记录的最小属性集\n候选键是没有多余属性的超键 例如， 学号唯一，而且没有多余属性，所以是一个候选键 姓名唯一，而且没有多余属性，所以是一个候选键 （姓名，性别）唯一，但是单独姓名一个属性就能确定这个人是谁，所以性别这个属性就是多余属性，所以（姓名，性别）不是候选键 主属性(Primary Attribute)和非主属性(Nonprimary Attribute)\n关系中包含在任何一个候选码中的属性称为主属性 不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute） 主码或主键(Primary Key)：若干候选码中指定一个用来唯一标识关系的元组\n全码或全键(All-Key)：一个关系模式的所有属性集合是这个关系的主码或主键\n外码或外键(Foreign Key)：关系中的某个属性(或属性组)不是这个关系的主码或候选码, 而是另一关系的主码\n参照关系(Referencing Relation)和被参照关系(Referenced Relation)\n参照关系（从关系）: 外码所在的关系 被参照关系（主关系）: 以外码作为主码的关系 例如，选课表中，学号和课程号是主码，但在课程表中作为外码。 数据类型(Data Type)\n限制该列中存储的数据 关系模式(Relation Schema)：对关系的描述。如关系名（属性1，属性2， …，属性n）、学生（学号， 姓名，年龄，性别，系名，年级）\n数据库有型(type)和 值(value) 之分，关系模式是型, 关系是值; 关系模式是静态的, 关系是动态的、随时间不断变化的。 关系数据库(Relation Database)：所有关系的集合构成一个关系数据库 关系数据库对关系的限定/要求：\n每一个属性都是不可分解的（不允许表中有表，如工资表）\n每一个关系仅仅有一种关系模式\n每一个关系模式中的属性必须命名，属性名不同\n同一个关系中不允许出现候选码或候选键值完全相同的元组\n在关系中元组的顺序（即行序）是无关紧要的，可以任意交换。\n在关系中属性的顺序（即列序）是无关紧要的，可以任意交换。\n数据库表名字段等, 一般不使用中文, 用英文 关系数据库的型: 关系数据库模式, 对关系数据库的描述 关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库 关系必须是规范化的， 满足一定的规范条件 最基本的规范条件：关系的每一个分量必须是一个不可分的数据项， 不允许表中还有表。 下图中工资和扣除是可分的数据项 ,不符合关系模型要求\n域的笛卡尔积空间 给定一组域D_1, D_2, …, D_n，允许其中某些域是相同的。D_1, D_2, …, D_n的笛卡尔积空间为：D_1×D_2×…×D_n={(d_1,d_2,…,d_n)|d_i∈D_i,i=1,2,…,n} 所有域取值的任意组合 笛卡尔积可以看作为关系的“域” 基数（Cardinal number） 若D_i(i=1,2,…,n)为有限集，其基数为m_i，则D_1×D_2×…×D_n的基数M为：M=∏_i^n▒m_i\n笛卡尔积的表示方法 笛卡尔积可以表示为一张二维表 表中的每行对应一个元组，表中的每一列对应一个域\n例题： 给出3个域： D1=导师集合SUPERVISOR=｛张清玫， 刘逸｝ D2=专业集合SPECIALITY=｛计算机专业， 信息专业｝ D3=研究生集合POSTGRADUATE=｛李勇， 刘晨， 王敏｝ D1， D2， D3的笛卡尔积为\n1 2 3 4 5 6 7 答：D1×D2×D3＝｛ (张清玫，计算机专业，李勇)， (张清玫，计算机专业，刘晨)， (张清玫，计算机专业，王敏)， (张清玫，信息专业，李勇)， (张清玫，信息专业，刘晨)， (张清玫，信息专业，王敏)， (刘逸，计算机专业，李勇)， (刘逸，计算机专业，刘晨)， (刘逸，计算机专业，王敏)， (刘逸，信息专业，李勇)， (刘逸，信息专业，刘晨)， (刘逸，信息专业，王敏) ｝ 笛卡尔积的二维表表示：\nSUPERVISOR SPECIALITY POSTGRADUATE 张清玫 计算机专业 李勇 张清玫 计算机专业 刘晨 张清玫 计算机专业 王敏 张清玫 信息专业 李勇 张清玫 信息专业 刘晨 张清玫 信息专业 王敏 刘逸 计算机专业 李勇 刘逸 计算机专业 刘晨 刘逸 计算机专业 王敏 刘逸 信息专业 李勇 刘逸 信息专业 刘晨 刘逸 信息专业 王敏 2.2.2 关系操作集合 基本的关系操作 查询(Query) 选择\\投影\\连接\\除\\并\\差\\交\\笛卡尔积等 插入(Insert) 删除(Delete) 修改(Update) 关系数据语言的分类 特点: 高度非过程化\n关系代数语言 关系演算语言 两者兼备的语言(SQL) 关系代数σ 关系代数运算符 关系到数操作经过有限次复合的式子称为关系代数操作表达式, 简称为关系代数表达式; 可以使用关系代数表达式表示所需要执行的各种数据库查询和修改处理; 因而, 关系代数也是一种抽象的查询语言, 它通过对关系的操作来表达查询 传统的集合运算：并、差、交、笛卡尔积 4 种运算 学生住宿登记关系 S1\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901001 钟义 男 N201 901002 海燕 女 N302 901003 肖沙 男 N201 学生住宿登记关系 S2\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901004 秦学 男 C101 901005 赵月 女 D303 901003 肖沙 男 N201 并( UNION)： R3=R1UR2，合并元组 S1 U S2\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901001 钟义 男 N201 901002 海燕 女 N302 901003 肖沙 男 N201 901004 秦学 男 C101 901005 赵月 女 D303 差( DIFFERENCE)：R3 = R1 - R2 属于R1但不属于R2 S1 - S2\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901001 钟义 男 N201 901002 海燕 女 N302 交( INTERSECTION)：R3=R1∩R2，找共同元组 S1 ∩ S2\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901003 肖沙 男 N201 笛卡尔积( CARTESIAN PRODUCT)：R3=R1×R2 新关系 R3 中元组的前 m 个分量是 R1 的一个元组，后 n 个分量为 R2 的一个元组。 笛卡尔积示例— “学生”关系\n学号（SNO） 姓名(SNAME) 89199 陈星 89200 易南 89201 林俊 笛卡尔积示例— “课程”关系\n课程号（CNO） 课程名(CNAME) 教室（CROOM） 1 操作系统 C5-201 2 数据库 C5 - 307 笛卡尔积示例— “学生选课”关系\n学号（SNO） 姓名(SNAME) 课程号（CNO） 课程名(CNAME) 教室（CROOM） 89199 陈星 1 操作系统 C5-201 89199 陈星 2 数据库 C5 - 307 89200 易南 1 操作系统 C5-201 89199 易南 2 数据库 C5 - 307 89201 林俊 1 操作系统 C5-201 89201 林俊 2 数据库 C5 - 307 专门的关系运算（重点） σ π ÷\n一元专门关系操作包括对单个关系进行垂直分解的投影运算和进行水平分解选择运算； 二元专门关系操作则是对两个关系进行操作，包括连接运算和除 选择(select) σ F(R) : F 为条件表达式, R 为指定的被运算关系名。选择满足条件的记录。 select 关系名 where 条件; 条件是由常数、属性名或列名、比较操作符（\u0026gt;、≥、\u0026lt;、≤、≠）及逻辑操作符（-、∧、V）组成的条件表达式。 例如，查找性别为男性的，select S1 where 性别 = “男” 1 σ 性别 = \u0026#34;男性\u0026#34;（S1） 学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901001 钟义 男 N201 901003 肖沙 男 N201 进行逻辑运算（∧与、∨或、¬非） 1 2 查询一个宿舍为N201的男生 σ 宿舍 = N201(S1) ∧性别 = 男（S1） 投影 π_A(R) ：选择若干列组成新的关系，新关系中不含重复舒服，R 为被运算关系名, A 为属性序列。 projection 关系名(属性名1, 属性名2, ..., 属性名n); 例如，选择学号、姓名这两列, 。 projection S1 (学号，姓名) 1 π 学号,姓名（S1） 学号（SNO） 姓名(SNAME) 901001 钟义 901002 海燕 901003 肖沙 例如，假设想要找出年龄大于19岁的学生的名字和年龄，则可以将前面的两个查询组合起来，表达式如下：\n1 π_Sname,Sage(σ_Sage\u0026gt;19(S)) 连接(join) ⨝，从两个关系的笛卡尔积中选取属性间满足一定条件的元组。R3=R1⨝R2 join 关系名1 AND 关系名2 where 条件; 笛卡尔积 只保留属性值相等 去除重复列 R\nA B C a1 b1 5 a1 b2 6 a2 b3 8 a2 b4 12 S\nB E b1 3 b2 7 b3 10 b3 2 b5 2 一般连接：在一般连接上，A和B分别为R和S上列数相等且可比的属性组，θ为比较运算符\n举个例子：输出 R⋈S 且C\u0026lt;E的元组，结果为\nA R .B C S.B E a1 b1 5 b2 7 a1 b1 5 b3 10 a1 b2 6 b2 7 a1 b2 6 b3 10 a2 b3 8 b3 10 等值连接 （equijoin） θ为“=”的连接运算称为等值连接。它是从关系R与S的广义笛卡尔积中选取A、B属性组值相等的那些元组\n举个例子：R⋈S,且R.B=S.B，结果为\nA R .B C S.B E a1 b1 5 b1 3 a1 b2 6 b2 7 a2 b3 8 b3 10 a2 b3 8 b3 2 等值连接会去除属性列不相等的元组\nA R .B C S.B E a1 b1 5 b1 3 a1 b2 6 b2 7 a2 b3 8 b3 10 a2 b3 8 b3 2 除(division)：÷ 若除关系为 m 元关系，除关系为 n 元关系，则运算结果为一个 m-n 元关系 2.2.3 关系的完整性约束 数据库的数据完整性是指数据库中数据的正确性、相容性、一致性。\n关系的完整性约束分类：\n实体完整性约束(Entity Integrity Constraint)：是指关系的主属性，即主码的组成不能为NULL。关系对应于现实世界中的实体集，而现实世界的实体是可区分的，即说明每个实体具有唯一性标识。\n参照完整性约束(Referential Integrity Constraint)：是定义外码和主码之间的引用规则，要么外码等于主码中某个元组的主码值，要么为空值。例如， 教师（职工号、姓名、性别、职称、系编号）系编号属于外码 系（系编号、系名、办公地点、办公电话）\n用户自定义完整性约束：是针对某一应用环境的完整性约束条件，它反映了某一具体应用所涉及的数据应满足的要求。\n关系模型提供定义和检验这类完整性规则的机制，其目的是用统一的方式由系统来处理它们，不再由应用程序来完成这项工作。 在实际系统中，这类完整性规则一般在建立数据库表的同时进行定义，但如果某些约束条件没有建立在库表级，则应用编程人员应在各模块的具体编程中通过程序进行检查和控制 关系模型完整性约束的检验\n执行插入操作 首先，检查实体完整性约束，检查插入行在主码属性上的值是否已经存在，若不存在，可以执行插入操作；否则不可以执行插入操作。或者，检查插入行在主码的各个属性上的值是否为空（NULL），若都不为空，可以执行插入操作；否则不可以执行插入操作。 然后，再检查参照完整性约束，如果是向被参照关系插入，不需要考虑参照完整性约束；如果是向参照关系插入，检查插入行在外码属性上的值是否已经在相应被参照关系的主码属性值中存在，若存在，可以执行插入操作；否则不可以执行插入操作，或将插入行在外码属性上的值改为空值后再执行插入操作（假定该外码允许取空值）。 最后，检查用户定义完整性约束，检查要被插入的元组中各属性值是否满足域完整性约束和其他特殊定义的完整性规则，包括数据类型、精度、取值范围、是否允许空值、是否有默认值等，以及检查插入行在相应属性上的值是否遵守具体应用的业务规则，若满足，可以执行插入操作；否则不可以执行插入操作，并给出错误信息。 执行删除操作 执行更新操作 第三节 关系数据库的规范化理论 （重点） 2.3.1 关系模式中可能存在的冗余和异常问题 数据冗余：是指同一数据被反复存储的情况。 更新异常：数据冗余，更新数据时，维护数据完整性代价太大。 插入异常：是指该插入的数据不能执行插入操作的情形。 删除异常：是指不应该删去的数据被删去的情形。 关系模式中产生上述问题的原因，及消除的方法，都与数据依赖的概念有密切关系。\n2.3.2 函数依赖与关键字(重点) 关系：一张二维表 关系模式：用来定义关系，如 Student(Sno、Sname、Ssex、Sage、Sdept)，Student用来描述关系。 关系数据库：基于关系模型的数据库，利用关系来描述现实世界\n函数依赖：关系中属性的对应关系\n双箭头是“等价于”,就是充要条件\nA←B, A 是 B 的必要非充分条件 (如果有事物情况 B，则必然有事物情况 A；如果有事物情况 A 不一定有事物情况 B)\nA→B, A 是 B 的充分非必要条件 (如果有事物情况 A，则必然有事物情况 B；如果有事物情况 B 不一定有事物情况 A，A 就是 B 的充分而不必要的条件)\n只有一对多和一对一的情况会存在函数依赖，多对多无法形成函数依赖。\nSC(Sno，Cno，Grade) 学号、课程、成绩 非平凡函数依赖（如果 X → Y，但Y 不属于 X，则称 X → Y 是非平凡函数依赖 ）： (Sno,Cno) \u0026ndash;\u0026gt; Grade 平凡函数依赖（如果 X → Y，但Y 属于 X，则称 X → Y 是平凡函数依赖 ）： （Sno,Cno）\u0026ndash;\u0026gt; Sno / (Sno,Cno) \u0026ndash;\u0026gt; Cno\n候选码：能够决定其他所有属性的属性或者属性集。 组成候选码的属性叫做主属性。\n例题 R(职工名、项目名、工资、部门名、部门经理) 如果规定每个职工可参加多个项目，各领一份工资；每个项目只属于一个部门；每个部门只有一个经理。试写出关系模式R的基本函数依赖和码。 基本函数依赖： （职工名，项目名）-\u0026gt; 工资、项目名 -\u0026gt; 部门名、部门名 -\u0026gt; 部门经理 候选码： （职工名，项目名）\n完全函数依赖 X → Y : X的每一个值，属性Y只有唯一值与之对应，则称 X能决定Y（Y函数依赖X） 学号（SNO） 姓名(SNAME) 性别（SSEX） 901001 钟义 男 901002 海燕 女 901003 肖沙 男 SNO → SNAME SNO → SSEX\n设 R 为任一给定关系，X、Y 为其属性集， 若 X→Y，且对 X 中的任何真子集 X 都有 X→Y，则称Y 完全函数依赖于 X 。 例如，一个有关学生选课信息的关系模式 SC(SNO, CNO, CTITLE, INAME, IPLACE, GRADE)， 其各属性的含义分别是：学号、课程编号、课程名、授课老师、老师办公地址、成绩， 在该关系中，函数依赖 (SNO,CNO) → GRADE 为完全函数依赖。 显然，其中的单个属性 SNO 或 CNO 都不能单独函数决定 GRADE，即 SNO ↛ GRADE，CNO ↛ GRADE 部分函数依赖 设 R 为任一给定关系，X、Y 为其属性集，若 X→Y，且 X 中存在一个真子集 X 满足 X→Y，则称 Y 部分函数依赖于 X Y 集合或者单独都可以确定 X 例如，在表有关学生住宿登记的关系 S1 中，有函数依赖 (SNO,SNAME)→SSEX，但其中SNO→SSEX，所以(SNO, SNAME)→SSEX为部分函数依赖。\n传递函数依赖\n设 R 为任一给定关系，X、Y、Z 为其不同属性子集，若 X→Y, Y ↛ X, Y→Z，则有 X→Z，称为 Z 传递函数依赖于 X 例如，假设有一个关系模式 BOOKS（BNO, PNAME, PADDRESS）， 其各属性的含义分别是 书号 出版社名称 出版社地址。 一种书对应一个唯一书号，并只能在某一个出版社出版； 一个出版社一般只有一个唯一名称和唯一地址，但一个出版社可出版多种书。 此时，该关系中存在函数依赖： Sno → Sdept , Sdept → Mname；所以Mname 传递函数依赖于Sno。 严格的关键字的定义:\n设 R 为任一给定关系，U 为其所含的全部属性集合，X 为 U 的子集，若有完全函数依赖X→U，则 X 为 R 的一个候选关键字。 X 可以唯一确定 R 例题-候选关键字 例如，在上述有关学生选课信息的关系模式 SC 中， SC（SNO，CNO，CTITLE，INAME，IPLACE，GRADE） (SNO，CNO) → CTITLE， (SNO，CNO) → INAME， (SNO，CNO) → IPLACE， (SNO，CNO) → GRADE， 则属性集`（SNO,CNO）`为候选关键字，于是`SNO和CNO`为主属性，除此之外的其他属性均为非主属性 2.3.3 范式与规范化过程 关系数据库的规范化理论是数据库逻辑设计的工具。\n关系数据库中的关系需要满足一定的要求，不同程度的要求称为不同的范式（Normal Form, NF）。\n满足最低要求的称为第一范式，称简 1NF，这是最基本的范式； 在第一范式的基础上进一步满足一些新要求的称为第二范式（2NF）； 以此类推，再进一步的范式是第三范式（3NF）及其改进形式 BCNF（ Boyce-Codd Normal Form）； 关系模式的规范化（ Normalization）：一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合的过程。\n第一范式 1NF（存在非主属性对候选码的部分函数依赖） 设 R 为任一给定关系，如果 R 中的所有属性都是不可再分的基本数据项，则 R 为第一范式 ID cusLinkInfo 1 北京市海淀区成府路 010-62283393 2 北京市海淀区成府路 010-62283393 3 北京市海淀区成府路 010-62283393 ID cusLinkInfo casTel 1 北京市海淀区成府路 010-62283393 2 北京市海淀区成府路 010-62283393 3 北京市海淀区成府路 010-62283393 第一范式的缺点：冗余高、插入操作异常、删除操作异常\n第二范式（2NF）\n设 R 为任一给定关系，若 R 为 1NF，且其所有非主属性都完全函数依赖于候选关键字，则 R 为第二范式 完全函数依赖的意思，就是所有的非主属性都依赖于所有的主属性。 不符合2NF举例： 非主键列全部依赖于部分主键 非主键列部分依赖于全部主键 非主键列部分依赖于部分主键 第三范式（3NF）\n设 R 为任一给定关系，若 R 为 2NF，且其每一个不存在非主属性对候选关键字的传递函数依赖，则 R 为第三范式。 若R属于3NF，则R的每一个非主属性既不部分函数依赖于候选码，也不传递函数依赖于候选码。 第三范式的改进形式 BCNF\n若 R 为 1NF，如果对于R的每个函数依赖 X→Y，若Y 不属于 X，则 X 必包含候选关键字，则 R 为 BCNF。 如果R属于3NF，且R只有一个候选码，则R必属于BCNF 1NF -\u0026gt; 2NF：消除非主属性对候选码的部分函数依赖 找到候选关键字，看其余的属性是否完全函数依赖候选关键字，如果是，与候选关键字一同抄下来形成一个表格，如果不是，抄下来形成第二个表格，并将候选关键字里能够唯一决定表格2的属性组抄在第一列。\n2NF -\u0026gt; 3NF：消除非主属性对码的传递函数依赖 找到表格中传递函数依赖关系的三个属性组，设为x、y、z，将这三个属性组拆成两个表格，第一个表格为 x、y，第二个表格为y、z。\n3NF -\u0026gt; BCNF：消除主属性对码的部分和传递函数依赖。 列出表格中的所有函数依赖关系，每个关系拆出一个表格\n例题：1NF ~4NF 1NF：SLC(Sno，Sdept(所在系)，Sloc(宿舍楼)，Cno，Grade)\n2NF：SC(Sno，Cno，Grade)、SL(Sno，Sdept，Sloc) SL(Sno，Sdept，Sloc) 的函数依赖 Sno -\u0026gt; Sdept Sno -\u0026gt; Sloc Sdept -\u0026gt; Sloc SL的候选码为 Sno，Sloc传递函数依赖于Sno。\n3NF 将传递函数依赖分解 SL(Sno，Sdept，Sloc) 分解 SD(Sno，Sdept) DL(Sdept，Sloc)\nBCNF ： 主属性部分依赖于候选码\n例题：设计题 某超市商品采购数据库包含三个关系： 商品（商品编号、商品名、价格、生产日期） 采购员（编号、姓名、性别、联系电话） 采购（商品编号、编号、采购日期、采购数量） 实现以下操作： 1.使用关系代数查询“女”采购员的所有信息 2.使用关系代数查询所有商品的商品名和生产日期\n1 2 3 4 5 6 7 1. select 采购员 where 性别 = \u0026#34;女\u0026#34; 2. projection 商品（商品名，生产日期） 错误 正确答案： 1. 选择运算 σ 性别 = \u0026#39;女\u0026#39;(采购员) 2. π 商品名，生产日期（商品） 例题：设计题【综合题】 设有关系模式R（读者号，姓名，单位号，单位名，图书号，书名 借阅日期，还书日期）存储读者借阅图书等信息。 如果规定：每个读者只属于一个单位；每个读者可以借阅多本图书，每本图书也可以被多名读者借阅，每个读者也可以对某本围 书多次借阅，但每个读者每本图书每天最多借一次。 （1）根据上述条件，写出模式R的关键字。 （2）R最高属于第几范式，为什么？ （3）举例说明R在何种情况下会发生删除异常。 （4）将R规范到3NF\n1 2 3 4 5 6 7 8 正确答案 1.读者号、图书号、借阅日期 2. R ⊆ 1NF，因为存在非主属性对码的部分函数依赖 3. 删除读者借阅图书信息时，有可能把读者的基本信息也删除了。 4. R1(读者号、姓名、单位号) R2(单位号、单位名) R3(图书号、书名) R4(读者号、图书号、借阅日期、还书日期) 例题：BC范式 在关系模式STC(S,T,C)中，S表示学生，T表示教师，C表示课程。\n假设每一位教师只教一门课，每门课由若干教师教。 某一学生选定某门课，就确定一个固定的教师。 某个学生选修某个教师的课就确定了所选课的名称。 函数依赖： T-\u0026gt;C、(S,C)-\u0026gt; T、(S,T)-\u0026gt;C\n候选码：(S,C)、(S,T) STC属于3NF 主属性：S、T、C\n解决办法：采用投影分解法，将STC分解为两个关系模式，SC(S,C)、TC(T,C)\n2.3.4 关系规范化理论的应用 关系规范化理论主要应用于数据库设计中的概念设计阶段，对所产生的概念设计，可用它来分析其实体划分是否适合，判断属性分配到哪个实体中更为合理。在实现设计中当将 E-R 图向关系模型转换时，还可以用它来分析并发现概念设计中可能存在的遗漏或不当之处，特别是联系实体是否不单独转换为一独立关系而集成到与之相联的基本实体中去处理时，规范化理论是最有效的评价准则 第三章 数据库设计 第一节 数据库设计概述 3.1.1 数据库的生命周期 通常，从数据库演变过程的角度来看，数据库的生命周期可分为两个阶段， 分别是数据库分析与设计阶段、数据库实现与操作阶段。 其中，数据库分析与设计阶段包括需求分析、概念设计、逻辑设计和物理设计四个环节； 数据库实现与操作阶段包含数据库的实现、操作与监督、修改与调整三个子阶段。 3.1.2 数据库设计的目标 事实上，数据库设计具有两个十分重要的目标，即满足应用功能需求和良好的数据库性能。 满足应用功能需求，主要是指用户当前与可预知的将来应用所需要的数据及其联系，应全部准确地存储在数据库之中，从而可满足用户应用中所需要的对数据进行的存、取、删、改等操作； 良好的数据库性能，主要是指对数据的高效率存取和空间的节省，并具有良好的数据共享性、完整性、一致性及安全保密性。 3.1.3 数据库设计的内容 数据库设计是从用户对数据的需求出发，研究并构造数据库的过程。主要包括：\n数据库结构设计（静态的）\n数据库结构设计是针对给定的应用环境进行数据库的模式或子模式的设计，包括数据库的\n概念结构设计 逻辑结构设计 物理结构设计 模式定义并给出各应用程序共享的结构，是静态的，一经形成通常不会改变。\n数据库行为设计（动态的）\n数据库行为设计是确定数据库用户的行为和动作，而用户的行为和动作是对数据库的操作 3.1.4 数据库设计的方法 直观设计法\n直观设计法是一类最原始的数据库设计方法，它利用设计者的经验和技巧来设计数据库模式。不适应如今信息系统的开发。 规范设计法\n规范设计法是一类较为普遍、常用的数据库设计方法。 新奥尔良（ New Orleans）设计方法 将数据库设计分为四个阶段，分别是需求分析、概念结构设计、逻辑结构设计和物理结构设计，它注重数据库的结构设计，而不太考虑数据库的行为设计 基于 ER 模型的数据库设计方法 基本思想是在需求分析的基础上用 E-R 图构造一个反映现实世界实体之间联系的企业模式，然后将此模式转换成某一特定 DBMS 下的概念模式。 基于第三范式的设计方法 是一类结构化设计方法，其思想是在需求分析的基础上首先确定数据库的模式、属性及属性间的依赖关系，然后将它们组织在一个单一的关系模式中，再分析模式中不符合第三范式的约束条件，进行模式分解，规范成若干个第三范式关系模式的集合。 计算机辅助设计法 — 计算机辅助软件工程工具（俗称 case 工具）\n以领域专家的知识或经验为主导，模拟某规范化设计的方法，通常通过人机交互的方式来完成设计的某些过程。目前，许多计算机辅助软件工程工具（俗称 case 工具），可以用来帮助数据库设计人员完成数据库设计的些工作，如此可减轻数据库设计人员的工作量，加快数据库设计的进度，例如 Rational 公司的 Rational rose 等。 3.1.5 数据库设计的过程 需求分析阶段； 结构设计阶段，其包括概念结构设计、逻辑结构设计和物理结构设计； 行为设计阶段，其包括功能设计、事务设计和程序设计； 数据库实施阶段，其包括加载数据库数据和调试运行应用程序； 数据库运行和维护阶段。 第二节 数据库设计的基本步骤 数据库设计过程中涉及的5个基本步骤： 需求分析、概念结构设计、逻辑结构设计、数据库实施、数据库运行与维护。\n3.2.1 需求分析(数据库设计的起点) 目标：是了解与分析用户的信息及应用处理的要求，并将结果按一定格式整理而形成需求分析报告。 **需求分析报告的作用：是后续概念设计、逻辑设计、物理设计、数据库建立与维护的依据。\n确定数据库范围：确定数据库应支持哪些应用功能。\n应用过程分析：了解并分析数据与数据处理间的关系。\n收集与分析数据：数据收集与分析的任务是了解并分析数据的组成格式及操作特征，每个数据元素的语义及关系等，并将它们收集起来整理归档。\n编写需求分析报告\n3.2.2 概念结构设计(概念模型) 概念结构设计的任务是在需求分析中产生的需求分析报告的基础上，按照特定的方法设计满足应用需求的用户信息结构，该信息结构通常称为概念模型。 概念模型独立于任何软件与硬件，其设计的主要目标是最大限度地满足应用需求 关系的规范化理论主要用于概念设计阶段。 概念结构设计的常用方法有实体分析法（自顶向下法）和属性综合法（自底向上法） 两种 3.2.3 逻辑结构设计 目标将概念模型转换为等价的、并为特定DBMS所支持数据模型的结构；在基本表的基础上再建立必要的视图，形成数据的外模式。\n三种逻辑模型：层次模型、网状模型、关系数据模型\n逻辑结构设计的输入与输出信息\n独立于特定 DBMS 的概念模型。 有关响应时间、安全保密性、数据完整性及恢复方面的要求说明，包括保持数据致性的规则说明。 数据量及使用频率 特定 DBMS 特性，包括 DBMS 支持的数据模型及数据定义语言的说明 在完成逻辑结构设计之后，应该形成如下输出信息。\n一个特定 DBMS 支持的概念模式，或称之为模式。 一个或多个外部视图，或称之为子模式。 物理设计说明，其主要包括存入数据库中的数据量、使用频率及响应时间要求。 程序设计说明，其是在需求分析的基础上，根据已完成的逻辑模型，编制各程序名、执行逻辑步、存取数据的名、顺序及操作特征（读、写、删、改）的说明。 逻辑结构设计的步骤\n1 2 3 4 5 6 7 8 9 graph TD c1((概念设计)) --- 模型转换 模型转换 --- 子模式设计 模型转换 --- 应用程序设计说明 子模式设计 --- 设计评价 应用程序设计说明 --- 设计评价 设计评价 --- 物理设计 模型转换 将概念模型等价地转换为特定 DBMS 支持的关系模型、网状模型或层次模型表示。对于一个特定的应用环境，通常只转换为用户要求的某个特定 DBMS 所支持的一种模型表示。 子模式设计 抽取或导出模式的子集，以构造不同用户使用的局部数据逻辑结构。具体的规则在 DBMS 的使用指南中通常会有明确的说明。 编制应用程序设计说明 为可实际运行的应用程序设计提供依据与指导，并作为设计评价的基础。 设计评价 分析并检验模式及子模式的正确性与合理性，其方法是通过程序设计指南中提交的程序执行逻辑步骤在子模式上的模拟执行来考核模式及子模式是否满足应用需求，有无遗漏，并进一步估计数据容量及存取效率，为物理设计提供参考信息。评价分析中，如若发现不合理之处，则返回到模型转换处重新执行，如此反复，直至满足要求为止 3.2.4 物理设计 物理设计是指对于一个给定的数据库逻辑结构，研究并构造物理结构的过程 其具体任务主要是确定数据库在存储设备上的存储结构及存取方法， 因 DBMS 的不同还可能包括建立索引和聚集，以及物理块大小、缓冲区个数和大小、数据压缩的选择等 3.2.5 数据库实施 加载数据 应用程序设计 数据库试运行 3.2.6 数据库运行和维护 只有经过试运行之后，确认系统无故障或暂未发现故障时，系统才能投入到生产实际中运行。数据库系统投入实际运行标志着数据库设计和应用开发的基本完成，但绝不意味着设计和应用开发工作的终止。随着应用的深入和拓展，有可能暴露原未发现的问题；也有可能因对数据的不断增、删、改而使得系统的物理存储结构变坏或存取效率下降；另外，应用需求也有可能发生改变或扩展。所有这些，都需要工作人员在系统运行中做好维护工作，监督、发现和分析问题，提出改进或扩展方案并付诸实施。此外，还应定期或不定期地进行数据转储，当系统出现故障吋进行恢复处理，并实施安全与完整性控制。 系统维护中最困难的工作是数据库重组与重构。重组是当空间利用率和存取效率下降时进行的，它并不改变数据库的逻辑结构和物理结构，只是利用 DBMS 提供的设施调整数据库中数据的存储位置，从而回收“碎片”，使有关联的数据尽可能靠近存放，达到提高空间利用率和数据存取效率的目的。重构是指部分修改数据库的逻辑结构或物理结构，这往往因应用需求的改变与拓展或发现当初的设计欠妥而引起的，例如增、删、改数据类型，增、删、改索引与聚集等。 第三节 关系数据库设计方法(重点) 3.3.1 关系数据库设计过程与各级模式 如图 3 所示，按照数据库设计的基本步骤，在关系数据库设计的不同阶段，会形成数据库的各级模式: 1 2 3 4 5 6 7 8 9 10 11 12 13 graph LR 应用要求-应用1 --综合--\u0026gt; 概念模式 应用要求..2 --综合--\u0026gt; 概念模式 应用要求..3 --综合--\u0026gt; 概念模式 应用要求..4 --综合--\u0026gt; 概念模式 概念模式 --转换--\u0026gt; 逻辑模式 逻辑模式 --映像--\u0026gt; 外模式-应用1 逻辑模式 --映像--\u0026gt; 外模式..2 逻辑模式 --映像--\u0026gt; 外模式..3 逻辑模式 --映像--\u0026gt; 外模式..4 逻辑模式 --映像--\u0026gt; c1((内模式)) 在需求分析阶段，综合各个用户的应用需求；\n在概念结构设计阶段形成独立于机器特点、独立于各个关系数据库管理系统产品（如 MySQL、 Oracle、SQL Server 等）的概念模式，\n例如本书使用的 E-R 图；\n在逻辑结构设计阶段，将 E-R 图转换成具体的数据库产品支持的关系数据模型，形成数据库逻辑模式， 然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图，形成数据的外模式； 在物理结构的设计阶段，根据关系数据库管理系统的特点和处理的需要，进行物理存储安排，建立索引，形成数据库内模式。 3.3.2 概念结构设计方法 E-R 图的表示方法\n实体型，其用矩形表示，矩形框内写明实体的名称\n属性，其用椭圆形表示，并用无向边将其与相应的实体连接起来\n联系，其用菱形表示，菱形框内写明联系的名称，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或 M:N），如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来。\n两个实体型之间的三类联系的E-R图示例\n1 2 3 4 5 6 7 graph TD 系 --1--\u0026gt; C1{隶属} C1{隶属} --1--\u0026gt;系主任 班级 --1--\u0026gt; C2{包含} C2{包含} --N--\u0026gt;学生1 学生2 --M--\u0026gt; C3{选课} C3{选课} --N--\u0026gt;课程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 graph LR 用户与部门之间 c1((用户名)) --- 用户 c2((用户ID)) --- 用户 c3((年龄)) --- 用户 c4((口令)) --- 用户 用户 --N--\u0026gt; C1{包含} C1{包含} --1--\u0026gt; 部门 部门 --- c5((部门ID)) 部门 --- c6((部门名)) 部门 --- c7((部门地址)) 部门 --- c8((部门领导)) 用户与用户组之间 用户1 --N--\u0026gt; C11{属于} C11{属于} --1--\u0026gt; 用户组 用户组与权限之间 用户组1 --M--\u0026gt; C21{拥有} C21{属于} --N--\u0026gt; 权限 3.3.3 逻辑结构设计方法 E-R 图向关系模型的转换 一个实体型转换为一个关系模式。 实体的属性作为关系的属性，实体的码作为关系的码。 一对一（1:1）联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。 如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码； 如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。 一对多（1:N）联系可以转换为一个独立的关系模式，也可以与N 端对应的关系模式合并。 如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为 N 端实体的码。 多对多（M:N）联系转换为一个关系模式。 与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。 三个或三个以上实体间的一个多元联系可以转换为一个关系模式。 与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合 具有相同码的关系模式可合并。 3.3.4 物理结构设计方法 建立索引 建立索引的方式通常有静态和动态两种。 静态建立索引是指应用人员预先建立索引，旦建立，后续的应用程序均可直接使用该索引存取数据，它多适合于用户较多且使用周期相对较长的数据； 动态建立索引是指应用人员在程序内外临时建立索引，它多适合于单独用户或临时性使用要求情况。 建立聚集 聚集是将相关数据集中存放的物理存储技术，借以提高 IO 的数据命中率而改善存取速度，其功能由具体的 DBMS 所提供，如 MySQL。 所谓集中存放是指将相关数据尽可能地存放于一个物理块中，或一个磁道中，或一个柱面中，或相邻区域（块、磁道、柱面）中。 例如，一个教师关系中含姓名、出生时间、性别、职称等属性，若 1975 年出生的教师有 100 个，则该关系中含有 100 个 1975 年出生教师数据的元组，最坏情况下，100 个元组分布在 100 个不同物理块中，当按出生时间访问 1975 年出生的教师信息时，则可能需要 100 次 IO（假定一次 IO 读入一个物理块）。若按出生时间集中存放数据，则一次能读入多个 1975 年出生的教师数据。 数据聚集结构的一种有效方式是块结构方式，块与块之间由指针连接，一个块对应于一个物理分区。数据聚集可在一个或多个关系上建立。若在一个关系上建立聚集，则可按垂直或水平方向对关系分组。可将常用或经常一起使用的属性值或元组值集中存放，其他的则另外存放。若在多个关系上建立聚集，则将多个不同关系中常在一起使用的数据集中存放。无论采用何种方式，数据使用频率较高的数据才有必要建立聚集，数据量通常也较大，且更新操作应较少。 对关系数据库系统来说，就市场上流行的主要 DBMS 而言，建立了索引和聚集之后，其物理设计就基本完成，而逻辑模型本身通常并不需要进行改变。此时的物理模型实际上就是关于在逻辑模型上建立了哪些索引与聚集，以及如何建立的说明。显然，程序编制说明中应加入如何利用索引和聚集来加快数据访问的速度，从而提高应用程序执行效率的相关说明。 第四章 SQL 与关系型数据库基本操作 第一节 SQL 概述 4.1.1 SQL 的发展 SQL 标准是 1986 年 10 月由美国国家标准局颁布 SQL3/SQL-99：1999年颁布的SQL标准 4.1.2 SQL 的特点 SQL 不是某个特定数据库供应商专有的语言。几乎所有重要的关系数据库管理系统都支持 SQL，所以掌握 SQL 可以帮助用户与几乎所有的关系数据库进行交互。 SQL 简单易学。它的语句全都是由具有很强描述性的英语单词所组成，而且这些单词的数目不多。 SQL 尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素可以进行非常复杂和高级的数据库操作。 需要注意的是：SQL 语句不区分大小写。许多 SQL 开发人员习惯于对所有 SQL关键字使用大写，而对所有列和表的名称使用小写，这样的书写方式可使代码更易于阅读和调试，本书列举的实例也将遵照这个方式。 4.1.3 SQL 的组成 数据定义语言(Data Definition Language,DDL)：定义结构 create：用于创建数据库或数据库对象。 alter：用于对数据库或数据库对象进行修改。 drop：用于删除数据库或数据库对象。 数据操纵语言(Data Manipulation Language, DML)：定义数据 select：用于从表或视图中检索数据，其是数据库中使用最为频繁的 SQL 语句 insert：用于将数据插入到表或视图中。 update：用于修改表或视图中的数据，其既可修改表或视图中一行数据，也可同时修改多行或全部数据 delete：用于从表或视图中删除数据，其中可根据条件删除指定的数据。 数据控制语言(Data Control Language, DCL)：授权和回收权限 grant：用于授予权限，可把语句许可或对象许可的权限授予其他用户和角色。 revoke：用于收回权限，其功能与 grant 相反，但不影响该用户或角色从其他作为成员继承许可权限。 嵌入式和动态 SQL 规则 SQL 调用和会话规则 第二节 MySQL 预备知识 4.2.1 MySQL 使用基础 MySQL是一个关系型数据库管理系统。\nLAMP（ Linux+ Apache+MySQL+ PHP/Perl/Python），即使用 Linx 作为操作系统， Apache 作为 Wb 服务器， MySQL 作为数据库管理系统，PHP、Perl 或 Python 语言作为服务器端脚本解释器 WAMP（ Windows+ Apache+ MySQL+ PHP/Perl/Python），即使用 Windows 作为操作系统， Apache 作为 Web 服务器， MySQL 作为数据库管理系统，PHP、Perl 或 Python 语言作为服务器端脚本解释器 4.2.2 MySQL 中的 SQL 常量\n常量是指在程序运行过程中值不变的量，也称为字面值或标量值。常量的使用格式取决于值的数据类型，可分为字符串常量、数值常量、十六进制常量、时间日期常量、位字段值、布尔值和 null 值。\n字符串常量是指用单引号或双引号括起来的字符序列，分为 ASCⅡ 字符串常量和 Unicode 字符串常量。 数值常量可以分为整数常量和浮点数常量。其中，整数常量是不带小数点的十进制数；浮点数常量则是使用小数点的数值常量。 一个十六进制值通常指定为一个字符串常量，每对十六进制数字被转换为一个字符，其最前面有一个大写字母“X”或小写字“x” 日期时间常量是用单引号将表示日期时间的字符串括起来而构成的。 可以使用b'value'格式符号书写位字段值。其中， value 是一个用 0 或 1 书写的二进制值。位字段符号可以方便地指定分配给 BIT 列的值。 布尔值只包含两个可能的值，分别是 TRUE 和 FALSE。其中， FALSE 的数字值是 “0”，TRUE 的数字值是“1”。 NUL 值通常用于表示“没有值”“无数据”等意义，它与数字类型的“0”或字符串类型的空字符串是完全不同的。 变量\n变量用于临时存储数据，变量中的数据可以随着程序的运行而变化。变量有名字和数据类型两个属性。其中，变量的名字用于标识变量，变量的数据类型用于确定变量中存储数值的格式和可执行的运算。 在 MySQL 中，变量分为用户变量和系统变量。在使用时，用户变量前常添加一个符号“@”，用于将其与列名区分开；而大多数系统变量应用于其他 SQL 语句中时，必须在系统变量名称前添加两个“@”符号。 运算符\n常用的运算符算术运算符有： +（加）、-（减）、*（乘）、/（除）和%（求模） 5 种运算。 位运算符有： \u0026amp;（位与）、|（位或）、^（位异或）、~（位取反）、\u0026gt;（位右移）、\u0026lt;（位左移）。 比较运算符有： =（等于）、\u0026gt;（大于）、\u0026lt;（小于）、\u0026gt;（大于等于）、\u0026lt;=（小于等于）、∞（不等于）、！=（不等于）、\u0026lt;→（相等或都等于空） 逻辑运算符有： NOT或！（逻辑非）、AND或\u0026amp;\u0026amp;（逻辑与）、OR或‖（逻辑或）XOR（逻辑异或) 表达式\n表达式是常量、变量、列名、复杂计算、运算符和函数的组合。 一个表达式通常可以得到一个值。与常量、变量一样，表达式的值也具有某种数据类型，可能的数据类型有字符类型、数值类型、日期时间类型。因而，根据表达式的值的数据类型，表达式可分为字符型表达式、数值型表达式和日期表达式。 内置函数\n数学函数，例如abs()函数、sort()函数； 聚合函数，例如 count()函数；count 计数，sum求和 字符串函数，例如 asc()函数、 char()函数 日期和时间函数，例如now()函数、 year()函数； 加密函数，例如 encode()函数、 encrypt()函数 控制流程函数，例如if()函数、 ifnull()函数； 格式化函数，例如 format()函数 类型转换函数，例如cast()函数； 系统信息函数，例如 user()函数、version()函数。 第三节 数据定义 4.3.1 数据库模式定义 创建数据库\n1 2 3 create {database|schema}[if not exists] db_name [default] character set[=]charset_name |[default] collate[=]collation_name []标示其内容为可选项; | 用于分隔花括号中的选择项,表示可任选其中一项来与花括号外的语法成分共同组成 SQL 语句命令, 即选项彼此间是\u0026quot;或\u0026quot;的关系 db_name 用于标示具体的数据库命名,且该数据库名必须符合操作系统文件夹命名规则, 而在 MySQL 中则不区分大小写; 关键字 default 用于指定默认值; 关键字 character set 用于指定数据库字符集 Charset; 关键字 collate 用于指定字符集的校对规则; 关键字 if not exists 用于在创建数据库前进行判断,只有该数据库目前尚不存在时才执行 create database 操作,即此选项可以避免出现数据库已经存在而再新建的错误 例 4.1\n1 create database test_db; 选择数据库\n1 use db_name; 修改数据库\n1 2 alter {database|schema} [db_name] alter_specification... 例 4.2 修改已有数据库 test_db 的默认字符集和校对规则\n1 2 3 alter database test_db default character set gb2312 # 修改字符集 default collate gb2312_chinese_ci; # 用于指定字符集的校对规则 删除数据库\n1 drop {database|schema}{if exists} db_name; 例 4.3\n1 drop database if exists mytest; 查找数据库\n1 2 3 show{database|schemas} [like \u0026#39;pattern\u0026#39;|where expr] like 关键字用于匹配指定的数据库名称 例 4.4\n1 show databases; 4.3.2 表定义与操作 创建表\ncreate table语句的语法内容较多,主要由表创建定义( create definition)、表选项( table options)和分区选项( partition options)等内容所构成。\nMySQL主要数据类型： 数值型： 包括 int、double、float(n) 字符串型： char(n)、varchar(n)；前者是定长(固定长度n)，后者为变长串 位串型：bit(n)、bit varying(n) ；同上 时间型：date、time\n1 2 3 4 5 6 7 8 9 10 11 create [TEMPORARY] table tbl_name ( 字段名1 数据类型 [列级完整性约束条件][默认值] [,字段名2 数据类型[列级完整性约束条件][默认值]] [,...] [,表级完整性约束条件] )[ENGINE=引擎类型]; PRIMARY KEY(id) 指定主键 AUTO_INCREMENT 设置自增属性,自动编号 DEFAULT 指定默认值 例 4.5 在一个已有数据库mysql_list中新建一个包含客户姓名、性别、地址、联系方式等内容的客户基本信息表, 要求将客户的 id 号指定为该表的主键.\n1 2 3 4 5 6 7 8 9 10 11 use test_db; mysql\u0026gt; create table customers -\u0026gt; ( -\u0026gt; cust_id INT not null AUTO_INCREMENT, -\u0026gt; cust_name char(50) not null, -\u0026gt; cust_sex char(1) not null default 0, -\u0026gt; cust_address char(50) null, -\u0026gt; cust_contact char(50) null, -\u0026gt; primary key(cust_id) -\u0026gt; ); Query OK, 0 rows affected (0.17 sec) 临时表与持久表\nTEMPORARY 为临时表, 不加为持久表 临时表只有创建者可见, 断开连接会自动删除 数据类型\n关键字 AUTO_INCREMENT\n为表中数据类型为整型的列设置自增属性 每个表只能有一个自增列, 并且它必须被索引 指定默认值 default\n而如若该列被定义为 not null,则默认值取决于该列的类型 对于一个AUTO INCREMENT列,默认值是在顺序中的下一个值; 对于除 timestamp以外的日期和时间类型,默认值是该类型适当的\u0026quot;零\u0026quot;值; 对于表中第一个 timestamp列,默认值是当前的日期和时间 null 值\n主键 primary key()\n更新表\nadd[column] 子句\n例 4.6 向数据库 test_db的表 customers中添加一列,并命名为 cust_city, 用于描述用户所在的城市, 要求其不能为null, 默认值为字符串Wuhan, 且该列位于原表 cust_sex列之后\n1 2 mysql\u0026gt; alter table test_db.customers -\u0026gt; add column cust_city char(10) not null default \u0026#39;Wuhan\u0026#39; after cust_sex; 通过关键字\u0026quot; after\u0026ldquo;在原表 cust_sex列之后添加了一个新列 cust_city,也可通过关键字\u0026rdquo; FIRST\u0026quot;将新列 cust_city作为原表的第一列,若不指定这两个关键字,则新列会添加到原表的最后.另外,此例中对表名的指定采用的是完全限定的表名方式, 即\u0026quot; db_name.tbl_name\u0026ldquo;的表名格式\n类似地,可以在 alter table语句中通过使用 ADDPRIMARY key子句、add foreign key子句、 add index子句为原表添加一个主键、外键和索引等.\nchange[column] 子句，修改表中列的名称或数据类型\n例 4.7 将数据库 test_db中表 customers的 cust sex列重命名为sex,且将其数据类型更改为字符长度为 1 的字符数据类型char(1),允许其为null,默认值为字符常量M.\n1 2 3 mysql\u0026gt; alter table test_db.customers -\u0026gt; change column cust_sex sex char(1) null default \u0026#39;M\u0026#39;; Query OK, 0 rows affected (0.04 sec) 如果试图改变的数据类型与原有数据类型不兼容，SQL 命令则不会被执行，且系统会提示错误；而在类型兼容的情况下，该列的数据可能会被截断\nalter[column] 子句，修改或删除表中指定列的默认值\n例 4.8 将数据库 test_db中表 customers的 cust city列的默认值修改为字符常量 ‘Beijing’\n1 2 3 mysql\u0026gt; alter table test_db.customers -\u0026gt; alter column cust_city set default \u0026#39;Beijing\u0026#39;; Query OK, 0 rows affected (0.04 sec) modify[column] 子句，只修改指定列的数据类型，不会干涉它的类名\n例 4.9 将数据库 test_db中表 customers的 cust name列的数据类型由之前的字符长度为 50 的定长字符数据类型 char（50）更改为字符长度为 20 的定长字符数据类型 char（20），并将此列设置成表的第一列。\n1 2 mysql\u0026gt; alter table test_db.customers -\u0026gt; modify column cust_name char(20) FIRST; drop[column] 子句，删除表中指定列\n例 4.10 删除数据库 test_db中表 customers的 cust contact列。\n1 2 3 mysql\u0026gt; alter table test_db.customers -\u0026gt; drop column cust_contact; Query OK, 0 rows affected (0.05 sec) 类似地,也可分别通过在 alter table 语句中添加 drop primary key子句、 drop foreign key子句、drop index子句卸除原表的主键、外键和索引等\nrename[TO] 子句，给表重新命名\n例 4.11 使用 rename [TO]子句,重命名数据库 test_db中表 customers的表名为backup customers\n1 2 3 mysql\u0026gt; alter table test_db.customers -\u0026gt; rename TO test_db.backup_customers; Query OK, 0 rows affected (0.03 sec) 重命名表\n```mysql rename table tbl_name TO new_tbl_name [,tbl_name2 to new_tbl_name2] ... ``` 例 4.12 使用 rename table语句,将例 4.1 中的表 backup customers再重新命名为customer\n1 2 mysql\u0026gt; rename table test_db.backup_customers TO test_db.customers; Query OK, 0 rows affected (0.05 sec) 删除表 1 drop [TEMPORARAY] table [if exists] tbl_name[,tbl_name]... [restrict|CASXADE] 需要注意的是: drop table语句可以同时删除多个表(包括临时表), 但操作者必须拥有该命令的权限;\n当表被删除时, 其中存储的数据和分区信息均会被删除, 所以使用该语句须格外小心, 但操作者在该表上的权限并不会自动被删除 查看表\n显示表的名称\n1 2 show [full] tables {from|in} db_name] [like\u0026#39;pattern\u0026#39;|where expr] 例 4.13 显示数据库 test_db中所有的表名 1 2 3 4 5 6 7 mysql\u0026gt; show tables; +----------------------+ | Tables_in_mysql_test | +----------------------+ | customers | +----------------------+ 1 row in set (0.00 sec) 显示表的结构\n1 2 show [full] columns {from|in} tbl_name [{from|in} db_name] [like\u0026#39;pattern\u0026#39;|where expr] 1 {describe|desc} tbl_name[col_name|wild] MySQL 支持用 describe作为 show columns from的一种快捷方式\n例 4.14 显示数据库 test_db中表 customers的结构\n1 2 3 4 5 6 7 8 9 10 11 mysql\u0026gt; desc test_db.customers; +--------------+----------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------------+----------+------+-----+---------+----------------+ | cust_name | char(20) | YES | | null | | | cust_id | int(11) | NO | PRI | null | auto_increment | | sex | char(1) | YES | | M | | | cust_city | char(10) | NO | | Beijing | | | cust_address | char(50) | YES | | null | | +--------------+----------+------+-----+---------+----------------+ 5 rows in set (0.00 sec) 4.3.3 索引定义 索引是提高数据文件访问效率的有效方法\nDBMS 根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表,因而索引实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表 在列上创建了索引之后,查找数据时可以直接根据该列上的索引找到对应记录行的位置, 从而快速地查找到数据 **索引是以文件的形式存储的，如果有大量的索引，索引文件可能会比数据文件更快地达到最大的文件尺寸。**特别是如果在一个大表上创建了多种组合索引，索引文件会膨胀得非常快。 索引在提高查询速度的同时，却会降低更新表的速度。在更新表中索引列上的数据时，索引会被自动更新，以确保索引树与表中的内容保持一致，这可能需要重新组织一个索引。如果表中的索引很多，这会非常浪费时间，由此会降低 INSERT、 UPDATE、 delete 和其他写入操作的效率。表中的索引越多，则更新表的时间就会越长。 根据具体用途，索引在逻辑上通常包含有如下几类 普通索引（ index）是最基本的索引类型，它没有任何限制。创建普通索引时，通常使用关键字index或key 唯一性索引（ unique）：区别普通索引，即索引列中的所有值都只能出现一次，必须是唯一的。创建唯一性索引时，通常使用的关键字 unique。 主键（ primary key） 主键是一种唯一性索引。创建主键时，必须指定关键字 primary key，且不能有空值。主键一般是在创建表的时候指定，也可以通过修改表的方式添加主键，并且每个表只能有一个主键。 索引的创建\n使用 create index语句创建索引\n可以使用专门用于创建索引的 create index语句在一个已有的表上创建索引，但该语句不能创建主键。\n1 2 create [unique] index index_name on tbl_name(index_col_name,...) index_col_name的格式为：\n1 col_name[(length)][asc|desc] 可选项“ unique”关键字用于指定创建唯一性索引；“ index_name”用于指定索引名，一个表可以创建多个索引，但每个索引在该表中的名称必须是唯一的；“ tbl_name”用于指定要建立索引的表名；“ index_col_name”是关于索引列的描述。\n关于索引列的描述可包含这样三个语法要素：“ col_name”用于指定要创建索引的列名，通常可考虑将查询语句中在 where子句和JOIN子句里出现的列来作为索引列可选项“ length”，用于指定使用列的前 length个字符来创建索引，使用列的一部分创建索引有利于减小索引文件的大小，节省磁盘空间；关键字“asc”或“desc”是可选项，用于指定索引按升序（ASC）还是降序（desc）来排列，默认时为asc\n例 4.5 在数据库 test_db的表 customers上，根据客户姓名列的前三个字符创建个升序索引 index_customers\n1 2 3 mysql\u0026gt; create index index_customers -\u0026gt; on test_db.customers(cust_name(3) asc); Query OK, 0 rows affected (0.05 sec) 该语句成功执行后，接着输入语句 show index from test_db.customers即可查看到已建立的索引\n例 4.16 在数据库 test_db的表 customers上，根据客户姓名列和客户 id 号创建一个组合索引 index_cust\n1 2 3 mysql\u0026gt; create index index_cust -\u0026gt; on test_db.customers(cust_name,cust_id); Query OK, 0 rows affected (0.02 sec) 使用 create table语句创建索引\n语法项 (constraint [symbol]] primary key(index_col_name;…), 用于表示在创建新表的同时创建该表的主键\n语法项 {index|key}[index_name](index_col_name,…), 用于表示在创建新表的同时创建该表的索引\n语法项 [constraint[symbol]] unique [index|key][index_name](inde_name,…),用于表示在创建新表的同时创建该表的唯一性索引;\n语法项[constraint[symbo]foreign key[lindex name](Gindex_col_name,…),用于表示在创建新表的同时创建该表的外键\n其中,关键字\u0026rdquo;key\u0026ldquo;是关键字 index的同义词;\n关键字\u0026rdquo; constraint\u0026ldquo;用于为主键、 unique键、外键定义一个名字;\n在使用 create table语句定义列选项的时候,可以通过直接在某个列定义后面添加关键字\u0026rdquo; primary key\u0026ldquo;的方式来创建主键,而当主键是由多个列组成的多列索引时,则不能使用这种方法,只能通过在语句最后加上一个 primary key( col name,…)子句的方式来实现\n例 4.17 在已有数据库 test_db上新建一个包含产品卖家 id 号、姓名、地址、联系方式、售卖产品类型、当月销量等内容的产品卖家信息表 seller ,要求在创建表的同时, 为该表添加由卖家 id 号和售卖产品类型组成的联合主键, 并在当月销量上创建索引\n1 2 3 4 5 6 7 8 9 10 11 12 mysql\u0026gt; create table seller -\u0026gt; ( -\u0026gt; seller_id int not null AUTO_INCREMENT, -\u0026gt; seller_name char(50) not null, -\u0026gt; seller_adderss char(50) null, -\u0026gt; seller_contact char(50) null, -\u0026gt; product_type int(5) not null, -\u0026gt; sales int null, -\u0026gt; primary key(seller_id,product_type), -\u0026gt; index index_seller(sales) -\u0026gt; ); Query OK, 0 rows affected, 1 warning (0.03 sec) 主键都不能为空\n使用 alter table语句创建索引\n语法项 add{ index key} index name](index col name,…),用于表示在修改表的同时为该表添加索引 语法项 add[ constraint[ symbol]] primary key( Gindex col name;…),用于表示在修改表的同时为该表添加主键; 语法项 add[ constraint[ symbol]unique[ idex key][ index name]( index col name,…),用于表示在修改表的同时为该表添加唯一性索引; 语法项 add[ constraint[ symbol]foreign key[ lindex name]( index col name;…),用于表示在修改表的同时为该表添加外键. 例 4.8 使用 alter table语句在数据库 test_db中表 seller的姓名列上添加一个非唯一的索引,取名为 index_seller_name\n1 2 3 mysql\u0026gt; alter table test_db.seller -\u0026gt; add index index_seller_name(seller_name); Query OK, 0 rows affected (0.02 sec) 索引的查看\n1 2 3 4 show {index|INDEXES|keys} {from|in} tbl_name [{from|in} db_name] [where expr] 索引的删除\n使用 drop index语句删除索引\n1 drop index index_name on tbl_name 其中,\u0026rdquo; index_name\u0026ldquo;用于指定要删除的索引名,\u0026rdquo; tbl_name\u0026ldquo;用于指定该索引所在的表\n例 4.19 删除 例 4.16 中所创建的索引 index_cust\n1 2 mysql\u0026gt; drop index index_cust on test_db.customers; Query OK, 0 rows affected (0.02 sec) 使用 alter table语句删除索引\n选用 drop primary key子句用于删除表中的主键, 由于一个表中只有一个主键, 其也是一个索引;\n选用 drop index子句用于删除各种类型的索引\n选用 drop foreign key子句用于删除外键\n例 4.20 使用 alter table语句删除数据库 test_db中表 customers的主键和索引index_customers\n1 2 3 mysql\u0026gt; alter table test_db.customers -\u0026gt; #drop primary key, -\u0026gt; drop index index_customers; 主键有 auto_increment，先清除自增才能删 modify column cust_id INT not null; 删除后设置回 key\n1 2 3 4 mysql\u0026gt; alter table test_db.customers -\u0026gt; modify column cust_id INT not null key AUTO_INCREMENT FIRST -\u0026gt; add column cust_contact char(50) null -\u0026gt; change column sex cust_sex char(1) null default \u0026#39;M\u0026#39;; Query OK, 0 rows affected (0.04 sec)\n1 2 3 4 5 6 7 8 9 10 11 12 mysql\u0026gt; desc test_db.customers; +--------------+----------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +--------------+----------+------+-----+---------+----------------+ | cust_id | int(11) | NO | PRI | null | auto_increment | | cust_name | char(20) | YES | | null | | | cust_sex | char(1) | YES | | M | | | cust_city | char(10) | NO | | Beijing | | | cust_address | char(50) | YES | | null | | | cust_contact | char(50) | YES | | null | | +--------------+----------+------+-----+---------+----------------+ 6 rows in set (0.00 sec) 第四节 数据更新 4.4.1 插入数据 使用 insert...values 语句插入单行或多行元组数基\n1 2 insert [into] tbl_name[(col_name,...)] {values|value}({expr|default},...),(...),... \u0026quot; tbl_name\u0026ldquo;指定欲被插入数据的表名.\n\u0026quot; col_name\u0026ldquo;指定需要插入数据的列名列表;\n如果要向表中所有列插入数据, 则全部列名均可省略; 如果只是向表的部分列插入数据, 则需要明确指定这些列的列名; 而对于那些没有被指定的列, 它们的值可根据列的默认值或相关属性来确定, 通常 MySQL 是按照下列原则进行处理的: 对于具有标志( IDENTITY)属性的列, 系统会自动生成序号值来唯一标志该列; 具有默认值的列, 其值可通过在 insert 语句中指定关键字\u0026rdquo; default\u0026ldquo;将其设为默认值; 没有默认值的列, 若允许为空值, 则其值可通过在 insert 语句中指定关键字 \u0026ldquo;null\u0026rdquo; 将其设为空值, 若不允许为空值, 则 insert 语句执行出错; 对于类型为 timestamp的列,系统会为其自动赋值 由于 AUTO INCREMENT属性列的值是在表中其他列被赋值之后生成的,所以在对表中其他列做任何赋值操作(如 insert语句)时,对该 AUTO INCREMENT属性列的引用只会返回数字 0 通过关键字\u0026rdquo; values\u0026ldquo;或\u0026rdquo;value\u0026ldquo;引导的子句,其包含各列需要插入的数据清单; 数据清单中数据的顺序必须与列的顺序相对应,同时该子句中的值可以是:\n\u0026ldquo;expr\u0026quot;,表示一个常量、变量或一个表达式,也可以是空值null,其值的数据类型要与列的数据类型一致,如果表达式的类型与列值不匹配,这样做会造成类型转化或插入语句出错,另外当列值为字符型时,需要用单引号括起 关键字\u0026rdquo; default\u0026quot;,即用于指定此列值为该列的默认值,前提是该列之前已经明确指定了默认值,否则插入语句会出错. 例 4.21 使用 insert… values语句向数据库 test_db的表 customers中插入这样行完整数据:(901,张三,F,北京市,朝阳区) 1 2 3 mysql\u0026gt; insert into test_db.customers -\u0026gt; values(901,\u0026#39;张三\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;北京市\u0026#39;,\u0026#39;朝阳区\u0026#39;); Query OK, 1 row affected (0.07 sec) 例 4.22 使用 insert… values 语句向数据库 test_db的表 customers中插入一行数据,要求该数据目前只用明确给出 cust name列和 cust address列的信息,即分别为\u0026quot;李四\u0026quot;和\u0026quot;武汉市\u0026rdquo;,而 cust id列的值由系统自动生成, cust sex列选用表中默认值,另外cust contact列的值暂不确定,可不用指定 1 2 3 mysql\u0026gt; insert into test_db.customers -\u0026gt; values(0,\u0026#39;李四\u0026#39;,default,\u0026#39;武汉市\u0026#39;,null); Query OK, 1 row affected (0.01 sec) values 语句的使用中没有给出待插入表的列表清单 , 最好将其改为这样的 SQL 语句形式\n1 2 3 mysql\u0026gt; insert into test_db.customers(cust_id,cust_name,cust_sex,cust_address,cust_contact) -\u0026gt; values(0,\u0026#39;王五\u0026#39;,default,\u0026#39;上海市\u0026#39;,null); Query OK, 1 row affected (0.01 sec) 其中,第一个列 cust id指定为数字 0,也可设置为null,这是因为每次插入一个新行时,该列会由 MySQL 在前一行该列值的基础上自动增量;\n使用 insert...set 语句插入部分列值数据 1 2 insert [into] tbl_name set col_name={expr|default},... 例 4.23 使用 insert...set语句来实现 例 4.22 的数据插入需求\n1 2 3 mysql\u0026gt; insert into test_db.customers -\u0026gt; set cust_name=\u0026#39;李四\u0026#39;,cust_address=\u0026#39;武汉市\u0026#39;,cust_sex=default; Query OK, 1 row affected (0.01 sec) 使用 insert...select 语句插入子查询数据 1 2 insert [into] tbl_name[(col_name,...)] select... 在此语法中: select子句用于快速地从一个或多个表中取出数据,并将这些数据作为行数据插入到另一个表中, select子句返回的是一个查询到的结果集, insert语句将这个结果集插入到指定表中,其中结果集中每行数据的字段数、字段的数据类型必须与被操作的表完全一致\n4.4.2 删除数据 1 2 3 4 delete from tbl_name [where where_condition] [order by ...] [limit row_count] \u0026quot; tbl name\u0026ldquo;指定要删除数据的表名;\n可选项 where子句表示为删除操作限定删除条件,从而删除特定的行,\n若省略 where子句,则表示删除该表中的所有行,但表的定义仍在数据字典中,即 delete语句删除的是表中的数据,而不是关于表的定义; 可选项 order by子句表示各行将按照子句中指定的顺序进行删除;\n可选项LIMT子句用于告知服务器在控制命令被返回到客户端前被删除的行的最大值\n例 4.24 使用 delete语句删除数据库 test_db的表 customers中客户名为\u0026quot;王五\u0026rdquo; 的客户信息\n1 2 3 mysql\u0026gt; delete from test_db.customers -\u0026gt; where cust_name=\u0026#39;王五\u0026#39;; Query OK, 1 row affected (0.03 sec) 4.4.3 修改数据 1 2 3 4 5 update tbl_name set col_name={expr1|default}[,col_name2={expr2|default}]... [where where_condition] [order by ...] [limit row_count] tbl name指定要修改的表的名称;\nset子句用于指定表中要修改的列名及其列值, 其中每个指定的列值可以是表达式, 也可以是该列所对应的默认值, 如果指定的是默认值,则用关键字\u0026rdquo; default\u0026ldquo;表示列值;\n可选项 where子句用于限定表中要修改的行,若不指定此子句,则 update语句会修改表中所有的行;\n可选项 order by子句用于限定表中的行被修改的次序;\n可选项limit子句用于限定被修改的行数\n例 4.25 使用 update语句将数据库 test_db的表 customers中姓名为\u0026quot;张三\u0026quot;的客户的地址更新为\u0026quot;武汉市\u0026rdquo;\n1 2 3 4 mysql\u0026gt; update test_db.customers -\u0026gt; set cust_address=\u0026#39;南京市\u0026#39; -\u0026gt; where cust_name=\u0026#39;张三\u0026#39;; Query OK, 1 row affected (0.01 sec) 更新多个值用 , 分隔; 删除即设置为空;\n第五节 数据查询(难点) 4.5.1 select 语句 语法格式\n1 2 3 4 5 6 7 8 9 10 11 select [ALL|DISTINCT|DISTINCTROW] select_expr[,select_expr ...] from table_refrences [where where_condition] [group by{col_name|expr|position} [asc|desc],... [WITH ROLLUP]] [having where_condition] [order by {col_name|expr|position} [asc|desc], ...] [limit {[offset,] row_count|row_count offset offset}] select子句用于指定输出的字段;\nfrom子句用于指定数据的来源; where子句用于指定数据的选择条件; group by子句用于对检索到的记录进行分组;(仅在按组计算聚合时使用) having子句用于指定组的选择条件; order by子句用于对查询的结果进行排序 select子句和from子句是必需的,其他子句都是可选的,并且在select语句的使用中, 所有被添加选用的子句必须依照 select 语句的语法格式所罗列的顺序来使用,\n例如,一个 having子句必须位于 group by子句之后,并位于 order by子句之前, 在 select语句的语法结构中, 三个关键字\u0026rdquo;ALL\u0026quot;\u0026quot; DISTINCT\u0026quot;\u0026quot; DISTINC TROW\u0026ldquo;为可选项,用于指定是否应返回结果集中的重复行;\n默认为ALL,即 select操作中所有匹配的行,包括可能存在的重复行,都将被返回;\n4.5.2 列的选择与指定 选择指定的列 若查询列有多个,则列名之间用逗号分隔, 且查询结果次序是依照select语句中指定列的次序给出的; 若查询所有列, 则可 select * 例 4.26 查询数据库 test_db的表 customers中各个客户的姓名、性别和地址信息\n```mysql mysql\u0026gt; select cust_name,cust_sex,cust_address -\u0026gt; from test_db.customers; ``` 例 4.27 查询数据库 test_db的表 customers中各个客户的所有信息\n```mysql mysql\u0026gt; select * from test_db.customers; ``` 定义并使用列的别名\n1 column_name[as]column_alias 例 4.28 查询数据库 test_db的表 customers中客户的 cust_name、 cust_address和 cust_contact,要求将结果集中 cust_address列的名称使用别名\u0026quot;地址\u0026quot;替代.\n```mysql mysql\u0026gt; select cust_name,cust_address as 地址,cust_contact -\u0026gt; from test_db.customers; ``` 替换查询结果集中的数据\n1 2 3 4 5 6 case when 条件1 then 表达式2 when 条件2 then 表达式2 ... else 表达式 end [as] column_alias 例 4.29 查询表 customers中客户的 cust_name、cust_sex, 要求判断结果集中 cust_ sex列的值, 如果该列的值为 M, 则显示输出\u0026quot;男\u0026rdquo;, 否则为\u0026quot;女\u0026quot;, 同时在结果集的显示中将 cust_sex列用别名\u0026quot;性别\u0026quot;标注\n```mysql mysql\u0026gt; select cust_name, -\u0026gt; case -\u0026gt; when cust_sex='M' then'男' -\u0026gt; else '女' -\u0026gt; end as 性别 -\u0026gt; from test_db.customers; ``` 计算列的值 例 4.30 查询数据库 test_db的表 customers中每个客户的 cust_name列、 cust_sex列,以及对 cust_id列加上数字 100 后的值\n```mysql mysql\u0026gt; select cust_name,cust_sex,cust_id+100 -\u0026gt; from test_db.customers; ``` 聚合函数\nselect 语句的语法项\u0026quot; select expr\u0026ldquo;也可以指定为聚合函数; 聚合函数通常是数据库系统中一类系统内置函数,常用于对一组值进行计算,然后返回单个值; 它通常与 group by子句一起使用,如果 select语句中有一个 group by子句,则这个聚合函数对所有列起作用,如果没有,则 select语句只产生一行作为结果 除 count 函数外,聚合函数忽略空值 1 2 3 4 5 6 7 8 9 10 11 count 求中项数 max 最大值 min 最小值 sum 求和 avg 平均值 std / stddev 返回给定表达式中所有值的标准值 variance 所有值的方差 group_concat 值连接组合而成的结果 bit_and 逻辑或 bir_or 逻辑与 bit_xor 逻辑异或 4.5.3 from 子句与多表连接查询 交叉连接 cross join\n交叉连接,又称笛卡尔积; 在 MySQL 中,它是通过在from子句中使用关键字\u0026rdquo; CROSS JOIN\u0026ldquo;来连接两张表, 从而实现一张表的每一行与另一张表的每一行的笛卡尔乘积, 并返回两张表的每一行相乘的所有可能的搭配结果, 供 select语句中其他语法元素( 如 where子句、 group by子句等)进行过滤和筛选操作 例 4.31 假设数据库中有两张表,分别是tbl1和tbl2, 现要求输出这两张表执行交叉联接后的所有数据集\n```mysql mysql\u0026gt; select * from tbl cross join tbl2; ``` 在from子句中也可以省略关键字 cross join, 而使用逗号分隔交叉联接的两张表\n1 mysql\u0026gt; select * from tbl,tbl2; 内连接\n1 select some_columns from table1 inner GION table2 on some_conditions; \u0026quot; some columns\u0026ldquo;用于指定需要检索的列的名称或列别名;\n\u0026quot; tablel\u0026ldquo;和\u0026rdquo;table2\u0026ldquo;用于指定进行内连接的两张表的表名或表别名;\non子句通过事先设定的连接条件some conditions\u0026rdquo;, 来指定两张表按什么条件进行连接, 且连接条件中可采用任何一种比较运算符;\n接条件\u0026rdquo; some conditions\u0026ldquo;一般使用的语法格式是:\n1 [\u0026lt;table\u0026gt;.]\u0026lt;列名或列别名\u0026gt;\u0026lt;比较运算符\u0026gt;[\u0026lt;table2\u0026gt;.]\u0026lt;列名或列别名\u0026gt; 例 4.32 根据第二章描述的学生基本信息登记表 tb student和学生成绩表 tb score, 使用内连接查询每个学生及其选课成绩的详细信息;\n由于学生基本信息存储在 tb student表中, 学生选课成绩信息存储在 tb score表中, 所以这个查询涉及两张表, 这两张表之间进行连接的连接条件是两个表中的 studentNo相等\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; select* -\u0026gt; from tb_student INNER JOIN tb_score -\u0026gt; on tb_student.studentNo=tb_score.studentNo; +-----------+--------+-----------+---------+ | studentNo | stName | studentNo | stScore | +-----------+--------+-----------+---------+ | 1 | 32 | 1 | 99 | +-----------+--------+-----------+---------+ 1 row in set (0.00 sec) 由于内连接是系统默认的表连接, 因而在from子句中可以省略关键字\u0026rdquo; INNER\u0026quot;,而只用关键字\u0026rdquo;JOIN\u0026ldquo;连接表; 在from子句中,也可以在多个表之间连续使用关键字INNER JOIN\u0026ldquo;或关键字\u0026rdquo;JOIN\u0026quot;,如此可以同时实现多个表的内连接; 此外,关于内连接的使用,通常有如下三种情形\n等值连接 在from子句中使用关键字\u0026rdquo; INNER JOIN\u0026ldquo;或\u0026rdquo;JOIN\u0026ldquo;连接两张表时, 如若在on子句的连接条件中使用运算符\u0026rdquo;=\u0026quot;(即等号), 即进行相等性测试, 则此连接方式称为等值连 非等值连接 在from子句中使用关键字\u0026quot; INNER JOIN\u0026ldquo;或\u0026rdquo;JOIN\u0026ldquo;连接两张表时, 如若在on子句的连接条件中使用除运算符\u0026rdquo;=\u0026ldquo;之外的运算符, 即进行不相等性测试, 则此连接方式称为非等值连接,也称为不等连接 自连接 在from子句中使用关键字\u0026rdquo; INNER JOIN\u0026ldquo;或\u0026rdquo;JOIN\u0026ldquo;连接表时, 可以将一个表与它自身进行连接, 这种连接方式称为自连接; 自连接是一种特殊的内连接, 若需要在一个表中查找具有相同列值的行, 则可以考虑使用自连; 使用自连接时, 需要为表指定两个不同的别名, 且对所有查询列的引用均必须使用表别名限定, 否则 select操作会失败 外连接\n左外连接 左外连接，也称左连接，它的使用语法格式与内连接大致相同，区别仅在于它在from子句中使用关键字\u0026rdquo; LEFT OUTER JOIN\u0026ldquo;或关键字\u0026rdquo; LEFT JOIN\u0026ldquo;来连接两张表，而不是使用关键字\u0026rdquo; INNER JOIN\u0026ldquo;或\u0026rdquo;JOIN\u0026quot;，如此可用于接收关键字\u0026quot; LEFT OUTER JOIN\u0026ldquo;或\u0026rdquo; LEFT JOIN\u0026quot;左边表（也称为基表）的所有行，并用这些行与该关键字右边表（也称为参考表） 中的行进行匹配，即匹配左表中的每一行及右表中符合条件的行。 这种连接方式特别适合当左表与右表具有一对多关系的情形。在左外连接的结果集中除了匹配的行之外，还包括左表中有的，但在右表中不匹配的行，对于这样的行，从右表中被选择的列的值被设置为null; 也就是说，左外连接的结果集中的null值表示右表中没有找到与左表相符的记录 右外连接 右外连接，也称右连接，它的使用语法格式与内连接大致相同，区别仅在于它在from子句中使用关键字“ RIGHT OUTER JOIN”或关键字“ RIGHT JOIN”来连接两张表，而不是使用关键字“ INNER JOIN”或“JOIN” 右外连接是以右表为基表，其连接方法与左外连接完全一样。在右外连接的结果集中除了匹配的行之外，还包括右表中有的，但在左表中不匹配的行，对于这样的行，从左表中被选择的列的值被设置为null 例 4.33 根据第二章描述的学生基本信息登记表 tb student和学生成绩表 tb score，使用左外连接查询每个学生及其选课成绩的详细信息\n1 2 3 mysql\u0026gt; select* -\u0026gt; from tb_student LEFT JOIN tb_score -\u0026gt; on tb_student.studentNo=tb_score.studentNo; 在实际使用中，例 4.32 和 例 4.33 的执行结果可能会存在如下两种情形\n返回结果完全一样，这说明 tb student表中不存在未选修任何课程的学生。 返回结果不一样，即使用内连接只能查询到部分学生的基本登记信息，以及他们所选课程号和对应的成绩，而使用左外连接可以查询到全部学生的基本登记信息，以及部分学生的选课课程号和对应的成绩，且剩余学生的选课课程号和对应的成绩则为null，这说明在 tb student表中存在有学生未选修任何课程。 因此，尽管有可能对两张表分别使用内连接和外连接之后，所返回的结果相同，但实质上这两类连接的操作语义是不同的，它们的差别在于外连接一定会在结果集中提供数据行，无论该行数据能否在另外一张表中找出相匹配的数据行 4.5.4 where 子句与条件查询 比较运算\n比较运算用于比较两个表达式的值。\n其中， MySQL 支持表 44 列出的所有比较运算符。 当两个表达式的值均不为null时，除了“\u0026lt;=\u0026gt;”运算符，其他比较运算返回逻辑值TRUE（真）或 FALSE（假）; 而当两个表达式值中有一个为空值或都为空值时，则将返回 UNKNOWN。 运算符“\u0026lt;=\u0026gt;” 不会出现值为UNKNOWN的情况。 例 4.34 在数据库 test_db的表 customers中查找所有男性客户的信息。\n1 2 mysql\u0026gt; select *from test_db.customers -\u0026gt; where cust_sex=\u0026#39;M\u0026#39;; 判定范围\nBETWEEN...AND\n查询的过滤条件被限定在值的某个范围, 表达式 expression 的值不能大于表达式 expression2的值, 否则返回 FALSE；如果使用关键字not时，其返回值正好相反 1 expression [not] BETWEEN expression1 AND expression2 例 4.35 在数据库 test_db 的表 customers中，查询客户 id 号在 903 至 912 之间的十个客户的信息。 1 2 mysql\u0026gt; select *from test_db.customers -\u0026gt; where cust_id BETWEEN 903 AND 912; in\n使用关键字“in”可以指定一个值的枚举表，该表中会列出所有可能的值，当要判定的值能与该表中任意一个值匹配时，会返回结果TRUE，否则返回 FALSE, 其使用语法格式是： 1 expression in(expression[,...]) 例 4.36 在数据库 test_db的表 customers中，查询客户 id 号分别为 903、906 和 908 个客户的信息。\n1 2 mysql\u0026gt; select *from test_db.customers -\u0026gt; where cust_id in(903,906,908); 判定空值\n使用关键字“ IS null”\n1 expression IS[not]null 例 4.37 在数据库 test_db的表 customers中，查询是否存在没有填写客户联系方式的客户。\n1 2 mysql\u0026gt; select cust_name from test_db.customers -\u0026gt; where cust_contact IS null; 子查询\n使用 select语句创建子查询 表子查询，即子查询返回的结果集是一个表。 行子查询，即子查询返回的结果集是带有一个或多个值的一行数据。 列子査询，即子査询返回的结果集是一列数据，该列可以有一行或多行，但每行只有一个值 标量子查询，即子查询返回的结果集仅仅是一个值。 结合关键字使用的子查询\n结合关键字“in”所使用的子查询主要用于判定一个给定值是否存在于在子查询的结果集中，其使用语法格式是\n1 expression[not]in (subquery) 例 4.38 根据第 2 章描述的学生基本信息登记表 tb student和学生成绩表 tb score，使用子査询的方式查询任意所选课程成绩高于 80 分的学生的学号和姓名信息。\n1 2 3 mysql\u0026gt; select studentNo,studentName -\u0026gt; from tb_student -\u0026gt; where studentNo in (select studentNo from tb_score where stScore\u0026gt;80); 结合比较运算符使用的子查询\n结合比较运算符所使用的子査询主要用于将表达式的值与子査询的结果进行比较运算，其使用语法格式是：\n1 expression{=|\u0026lt;|\u0026lt;=|\u0026gt;|\u0026gt;=|\u0026lt;\u0026gt;|!=}{ALL|SOME|ANY}{subquery} 在此语法中：三个关键字“ALL”“SOME”或“ANY”为选择项，用于指定对比较运算的限制。\n其中，关键字“ALL”用于指定表达式需要与子查询结果集中的每个值都进行比较，当表达式与每个值都满足比较关系时，会返回 TRUE，否则返回 FALSE； 关键字“SOME”和“ANY”是同义词，表示表达式只要与子查询结果集中的某个值满足比较关系时，就返回 TRUE，否则返回 FALSE。 结合关键字“ EXIST”使用的子查询\n结合关键字“ EXIST”所使用的子查询主要用于判定子查询的结果集是否为空, 否则返回 FALSE。它的使用语法格式是：\n1 EXIST(subquery) 4.5.5 group by 子句与分组查询 在 select语句中，允许使用 group by子句，将结果集中的数据行根据选择列的值逻辑分组，以便能汇总表内容的子集，即实现对每个组的聚集计算。\n1 group by{col_name|expr|position}{asc|desc},...[WITH ROLLUP] col name：指定用于分组的选择列。 可以指定多个列，彼此间用逗号分隔。注意， group by子句中的各选择列必须也是 select语句的选择列表清单中的一项。 expr：指定用于分组的表达式。 该表达式通常与聚合函数一块使用，例如可将表达式“ COUNT（*）AS '人数'”作为 select语句的选择列表清单中的一项 position：指定用于分组的选择列在 select语句结果集中的位置，通常是一个正整数。 例如，使用 group by 3表示根据 select语句中列清单上的第 3 列的值进行逻辑分组。 asc|desc：关键字“asc”表示按升序分组；关键字“desc”表示按降序分组。 其中，默认值为 ASC。这两个关键字必须位于对应的列名、表达式、列的位置之后。 WITH ROLLUP：此关键字为可选项，用于指定在结果集中不仅包含由 group by子句分组后的数据行，还包含各分组的汇总行，以及所有分组的整体汇总行。 因此，使用该关键字，可以得到每个分组以及每个分组汇总级别的值。 其汇总规则是：按列的排列的逆序依次进行汇总，并且在生成的同一逻辑组的汇总行中，对于具有不同列值的字段值将被设置为 NULL。 例 4.39 在数据库 test_db的表 customers中获取一个数据结果集，要求该结果集中分别包含每个相同地址的男性客户人数和女性客户人数。\n1 2 3 4 5 6 7 8 9 10 11 mysql\u0026gt; select cust_address,cust_sex,count(*) as \u0026#39;人数\u0026#39; -\u0026gt; from test_db.customers -\u0026gt; group by cust_address,cust_sex; +--------------+----------+--------+ | cust_address | cust_sex | 人数 | +--------------+----------+--------+ | 南京市 | F | 1 | | null | M | 1 | | 武汉市 | M | 1 | +--------------+----------+--------+ 3 rows in set (0.05 sec) 例 4.40 在数据库 test_db的表 customers中获取一个数据结果集，要求该结果集中包含每个相同地址的男性客户人数、女性客户人数、总人数以及客户的总人数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 mysql\u0026gt; select cust_address,cust_sex,count(*)as\u0026#39;人数\u0026#39; -\u0026gt; from test_db.customers -\u0026gt; group by cust_address,cust_sex -\u0026gt; WITH ROLLUP; +--------------+----------+--------+ | cust_address | cust_sex | 人数 | +--------------+----------+--------+ | null | M | 1 | | null | null | 1 | | 南京市 | F | 3 | | 南京市 | null | 3 | | 武汉市 | M | 2 | | 武汉市 | null | 2 | | null | null | 6 | +--------------+----------+--------+ 7 rows in set (0.03 sec) 此外，对于 group by子句的使用，需要注意以下几点。\ngroup by子句可以包含任意数目的列，使得其可对分组进行嵌套，为数据分组提供更加细致的控制。 如果在 group by子句中嵌套了分组，那么将按 group by子句中列的排列顺序的逆序方式依次进行汇总，并将在最后规定的分组上进行一个完全汇总。 group by子句中列出的每个列都必须是检索列或有效的表达式，但不能是聚合函数。如果在 select语句中使用表达式，则必须在 group by子句中指定相同的表达式。注意，不能使用别名 除聚合函数之外， select语句中的每个列都必须在 group by子句中给出。 如果用于分组的列中含有null值，则null将作为一个单独的分组返回；如果该列中存在多个null值，则将这些null值所在的行分为一组。 4.5.6 having 子句 在结果集中规定包含哪些分组和排除哪些分组。\nhaving子句的使用语法格式是\n1 having where_condition having子句与 where子句非常相似， having子句支持 where子句中所有的操作符和句法，但两者之间仍存在以下几点差异\nwhere子句主要用于过滤数据行，而 having子句主要用于过滤分组，即having子句可基于分组的聚合值而不是特定行的值来过滤数据。 having子句中的条件可以包含聚合函数，而 where子句中则不可以。 where子句会在数据分组前进行过滤， having子句则会在数据分组后进行过滤。因而， where子句排除的行不包含在分组中，这就会可能改变计算值，从而影having子句基于这些值过滤掉的分组。 例 4.41 在数据库 test_db的表 customers中查找这样一类客户信息：要求在返回的果集中，列出相同客户地址中满足客户人数少于 3 的所有客户姓名及其对应地址。\n1 2 3 4 mysql\u0026gt; select cust_name,cust_address -\u0026gt; from test_db.customers -\u0026gt; group by cust_address,cust_name -\u0026gt; having count(*)\u0026lt;=3; 4.5.7 order by 子句 可以使用 order BY 子句将结果集中的数据行按一定的顺序进行排列\norder BY 子句的使用语法格式是：\n1 2 order by {col_name|expr|position}[asc|desc],... order by cust_name desc,cust_address desc; col name：指定用于排序的列。可以同时指定多个列，列名彼此间用逗号分隔。 expr：指定用于排序的表达式。 position：指定用于排序的列在 select语句结果集中的位置，通常是一个正整数例如，使用 order by 2表示对 select语句中列清单上的第 2 列进行排序。 asc|desc：关键字“asc”表示按升序排列；关键字“desc”表示按降序排列。其中，默认值为asc。这两个关键字必须位于对应的列名、表达式、列的位置之后。 例 4.42 在数据库 test_db的表 customers中依次按照客户姓名和地址的降序方式输出客户的姓名和性别。\n1 2 3 4 5 6 7 8 9 10 11 12 13 mysql\u0026gt; select cust_name,cust_sex from test_db.customers -\u0026gt; order by cust_name desc,cust_address desc; +-----------+----------+ | cust_name | cust_sex | +-----------+----------+ | 张三 | F | | 王五 | F | | 王五 | F | | 王六 | M | | 李四 | M | | 李四 | M | +-----------+----------+ 6 rows in set (0.00 sec) 此外，关于 order by子句的使用，需要注意以下几点。\norder by子句中可以包含子查询。 当对空值进行排序时， order by子句会将该空值作为最小值来对待。即，若按升序排列结果集，则 order by子句会将该空值所在的数据行置于结果集的最上方；若是使用降序排序，则会将其置于结果集的最下方 若在 order by子句中指定多个列进行排序，则在 MySQL 中会按照这些列从左至右所罗列的次序依次进行排序。 在使用 group by子句时，通常也会同时使用 order by子句。 4.5.8 limit 子句 可以使用 LIMIT 子句来限制被 select语句返回的行数。\nLIMIT子句的使用语法格式是：\n1 limit {[offset,] row_count|row_count offset offset} offset：为可选项，默认为数字 0，用于指定返回数据的第一行在 select语句结果集中的偏移量，其必须是非负的整数常量。注意， select语句结果集中第一行（初始行）的偏移量为 0 而不是 1。 row count：用于指定返回数据的行数，其也必须是非负的整数常量。若这个指定行数大于实际能返回的行数时，在 MySQL 中将只返回它能返回的数据行。 row count offset offset：从第 offset+1行开始，取 row count行。 例 443 在数据库 test_db的表 customers中查找从第 5 位客户开始的 3 位客户的 id 号 和姓名信息。\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; select cust_id,cust_name from test_db.customers -\u0026gt; order by cust_id -\u0026gt; limit 4,3; #也可以写成 limit 3 offset 4; +---------+-----------+ | cust_id | cust_name | +---------+-----------+ | 906 | 王五 | | 907 | 王六 | +---------+-----------+ 2 rows in set (0.00 sec) 第六节 视图 视图是数据库中的一个对象，它是数据库管理系统提供给用户的以多种角度观察数据库中数据的一种重要机制。视图是从一个或多个表或者其他视图中通过查询语句导出的表，它也包含一系列带有名称的数据列和若干条数据行，并有自己的视图名，由此可见视图与基本表十分类似。然而，视图仍不同于数据库中真实存在的基本表，它们存在以下区别。 视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据库中真实表的查询基础上的。 视图的内容是由存储在数据库中进行查询操作的 SQL 语句来定义的，它的列数据与行数据均来自于定义视图的查询所引用的真实表，并且这些数据是在引用视图时动态生成的 视图不是以数据集的形式存储在数据库中，它所对应的数据实际上是存储在视图所引用的真实表（基本表）中。 视图是用来查看存储在别处的数据的一种虚拟表，而其自身并不存储数据。 尽管视图与数据库中的基本表存在着本质上的不同，但视图一经定义后，可以如同使用基本表一样，对视图进行查询、修改、删除和更新等操作，并且使用视图还具有如下一些优点。 集中分散数据。当用户所需的数据分散在数据库多个表中时，通过定义视图可以将这些数据集中在一起，以方使用户对分散数据的集中查询与处理。 简化查询语句。通过定义视图可为用户屏蔽数据库的复杂性，使其不必详细了解数据库中复杂的表结构和表连接，因而能简化用户对数据库的查询语句。例如，即便是底层数据库表发生了更改，也不会影响到上层用户对数据库的正常使用，只需数据库编程人员重新定义视图的内容即可。 重用 SQL 语句。视图提供的是一种对查询操作的封装，它本身不包含数据，其所呈现的数据是根据视图的定义从基本表中检索出来的，如若基本表中的数据被新增或更改，视图所呈现的则是更新后的数据。因此，通过定义视图，编写完所需查询后，可以方便地重用该视图，而不必了解它的具体查询细节。 保护数据安全。通过只授予用户使用视图的权限，而不具体指定使用表的权限，来保护基础数据的安全性。 共享所需数据。通过使用视图，每个用户不必都定义和存储自己所需的数据，可以共享数据库中的数据，从而同样的数据只需存储一次。 更改数据格式。通过使用视图，可以重新格式化检索出的数据，并组织输出到其他应用程序中去 4.6.1 创建视图 使用 CREATE VIEW语句来创建视图\n1 2 3 CREATE VIEW view_name[(column_list)] as select_statement [WITH[CASCADED|LOCAL]CHECK OPTION] view name用于指定视图的名称，且该名称在数据库中必须是唯一的，不能与其他表或视图同名。 column list是可选项，用于为视图中的每个列指定明确的名称，且列名的数目必须等于 select语句检索出的结果数据集的列数，同时每个列名间用逗号分隔。如若省略column list，则新建视图使用与基本表或源视图中相同的列名 select statement用于指定创建视图的 select语句。这个 select语句给出了视图的定义，它可用于查询多个基本表或源视图 WITH CHECK OPTION是可选项，用于指定在可更新视图上所进行的修改都需要符合 select statement中所指定的限制条件，这样可以确保数据修改后，仍可以通过视图看到修改后的数据。当视图是根据另一个视图定义时，关键字“ WITH CHECK OPTION”给出两个参数，即 CASCADED和 LOCAL，它们决定检查测试的范围。其中，关键字“ CASCADED”为选项默认值，它会对所有视图进行检查，而关键字“ LOCAL”则使 CHECK OPTION只对定义的视图进行检查。 例 4.44 在数据库 mysql test中创建视图 customers view，要求该视图包含客户信息表customers中所有男客户的信息，并且要求保证今后对该视图数据的修改都必须符合客户性别为男性这个条件。\n1 2 3 4 5 6 mysql\u0026gt; create VIEW customers_view -\u0026gt; as -\u0026gt; select *from test_db.customers -\u0026gt; where cust_sex=\u0026#39;M\u0026#39; -\u0026gt; WITH CHECK OPTION; Query OK, 0 rows affected (0.03 sec) 4.6.2 删除视图 使用 drop VIEW语句来删除视图\n1 2 3 DROPVIEW view_name[(cloumn_list)] as select_statement [WITH[CASCADED|LOCAL]CHECK OPTION] 4.6.3 修改视图定义 使用 alter VIEW语句来对已有视图的定义（结构）进行修改\n1 2 3 ALTERVIEW view_name[(column_list)] as select_statement [WITH[CASCADED|LOCAL]CHECK OPTION] 4.6.4 查看视图定义 使用 show create VIEW语句来查看已有视图的定义（结构）\n1 show create VIEW view_name 4.6.5 更新视图数据 使用 insert语句通过视图向基本表插入数据\n例 4.45 在数据库 test_db中，向视图 customers view插入下面一条记录\n1 2 3 mysql\u0026gt; insert into test_db.customers_view -\u0026gt; values(0,\u0026#39;周敏\u0026#39;,\u0026#39;M\u0026#39;,\u0026#39;武汉市\u0026#39;,\u0026#39;洪山区\u0026#39;,null); Query OK, 1 row affected (0.01 sec) 使用 update语句通过视图修改基本表的数据\n例 4.46 将视图 customers vicw中所有客户的 cust address列到更新为“上海市”。\n1 2 3 mysql\u0026gt; update test_db.customers_view -\u0026gt; set cust_address=\u0026#39;上海市\u0026#39;; Query OK, 4 rows affected (0.01 sec) 使用 delete语句通过视图删除基本表的数据\n例 4.47 删除视图 customers view中姓名为“周明”的客户信息。\n1 2 3 mysql\u0026gt; delete from test_db.customers_view -\u0026gt; where cust_name=\u0026#39;周敏\u0026#39;; Query OK, 1 row affected (0.01 sec) 4.6.6 查询视图数据 例 4.48 在视图 customers view中查找客户 id 号为 905 的客户姓名及其地址信息\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; select cust_name,cust_address -\u0026gt; from test_db.customers_view -\u0026gt; where cust_id=904; +-----------+--------------+ | cust_name | cust_address | +-----------+--------------+ | 李四 | 上海市 | +-----------+--------------+ 1 row in set (0.00 sec) 由于视图是一个虚拟表，所以通过插入、修改和删除等操作方法来更新视图中的数据，实质上是在更新视图所引用的基本表中的数据。\n第五章 数据库编程 第一节 数据库编程 5.1.1 存储过程的基本概念 存储过程是一组为了完成某项特定功能的SQL语句集，其本质是一段存储在数据库中的代码。 存储过程可由声明式sql语句和过程式sql语句组成。 使用存储过程通常具有以下一些好处： 可增强 SQL 语言的功能和灵活性，存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 良好的封装性，存储**过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码 高性能，存储过程执行一次后，其执行规划就驻留在高速缓冲存储器中，在以后的操作中，只需从高速缓冲存储器中调用已编译好的二进制代码执行即可，从而提高了系统性能。 可减少网络流量，由于存储过程是在服务器端运行，且执行速度快，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载 存储过程可作为一种安全机制来确保数据库的安全性和数据的完整性，使用存储过程可以完成所有数据库操作，并可通过编程方式控制这些数据库操作对数据库信息访问的权限。 5.1.2 创建存储过程 delimiter命令的使用语法格式是：\n1 delimiter $$ 其中，$$是用户定义的结束符，通常这个符号可以是一些特殊的符号，例如两个“#”或两个“￥”等； 另外，当使用 delimiter命令时，应该避免使用反斜杠（“/”）字符，因为它是 MySQL的转义字符。 例 5.1 将 MySQL结束符修改为两个感叹号“!!\n1 delimiter !! 换回默认的分号“；”作为结束标志\n1 delimiter ; 使用 create procedure语句来创建存储过程\n1 2 create procedure sp_name([proc_apramenter[,...]]) routine_body 语法项“ proc parameter”的语法格式是：\n1 [in|OUT|INOUT] param_name type 语法项“ sp name”用于指定存储过程的名称，且默认在当前数据库中创建。 语法项“ proc parameter”用于指定存储过程的参数列表。 其中，语法项“ param name”为参数名，语法项“type”为参数的类型（其可以是任何有效的 MySQL 数据类型）。 当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍须加上一对括号），也可以有一个或多个参数。 MySQL 存储过程支持三种类型的参数，即输入参数、输出参数和输入/输出参数，分用“in”“OUT”和“ INOUT”三个关键字标识。其中，输入参数是使数据可以传递给一个存储过程；输出参数用于存储过程需要返回一个操作结果的情形；而输入输出参数既可以充当输入参数也可以充当输出参数。 需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错消息，但是存储过程中的 SQL 语句会将参数名看作是列名，从而引发不可预知的结果。 语法项“ routine body”表示存储过程的主体部分，也称为存储过程体，其包含了在过程调用的时候必须执行的 SQL 语句。 这个部分是以关键字“ BEGIN”开始，以关键字“END”结束。 如若存储过程体中只有一条 SQL 语句时，可以省略 BEGIN…END标志。 另外，在存储过程体中，BEGN…END复合语句还可以嵌套使用。 例 5.2 在数据库 test_db中创建一个存储过程，用于实现给定表 customers中一个客户 id 号即可修改表 customers中该客户的性别为一个指定的性别。\n1 2 3 4 5 6 mysql\u0026gt; delimiter $$ mysql\u0026gt; create procedure sp_update_sex(in cid INT,in csex char(1)) -\u0026gt; BEGIN -\u0026gt; update customers set cust_sex=csex where cust_id=cid; -\u0026gt; END $$ Query OK, 0 rows affected (0.09 sec) 5.1.3 存储过程体 局部变量\n使用 declare语句来声明局部变量，并且同时还可以对该局部变量赋予一个初始值\n1 declare var_name[,...]type[default value] 语法项“ var name”用于指定局部变量的名称；语法项“type”用于声明局部变量的数据类型； default子句用于为局部变量指定一个默认值，若没有指定，则默认为null 例 5.3 声明一个整型局部变量cid。\n1 declare cid INT(10) 局部变量只能在存储过程体的 BEGIN…END语句块中声明。 局部变量必须在存储过程体的开头处声明。 局部变量的作用范围仅限于声明它的BEGN…END语句块，其他语句块中的语句不可以使用它。 局部变量不同于用户变量，两者间的区别是：局部变量声明时，在其前面没有使用@符号，并且它只能被声明它的 BEGIN…END语句块中的语句所使用；而用户变量在声明时，会在其名称前面使用@符号，同时已声明的用户变量存在于整个会话之中。 set 语句\n使用 set 语句为局部变量赋值\n1 set var_name=expr[,var_name=expr]... 例 5.4 为 例 5.3 中声明的局部变量cid赋予一个整数值 910\n1 set cid=910; SELECT…INTO 语句\n使用 SELECT…INTO语句把选定列的值直接存储到局部变量中\n1 select col_name[,...]into var_name[,...] table_expr 语法项“ col name”用于指定列名；语法项“ var name”用于指定要赋值的变量名； 语法项“ \u0026lsquo;table expr”表示 select语句中的from子句及后面的语法部分。 此外，需要注意的是：存储过程体中的 SELECT…INTO语句返回的结果集只能有一行数据 流程控制语句\n条件判断语句 常用的条件判断语句有IF…THEN…ELSE语句和case语句。它们的使用语法及方式类似于高级程序设计语言 1 2 3 if 条件 then 表达式1 else 表达式2 end if; 循环语句\n常用的循环语句有WHLE语句、 REPEAT语句和LOOP语句。 while 条件表达式 END while repeat 表达式 END repeat loop 表达式 END loop 游标\n游标是一个被 select语句检索出来的结果集。在存储游标后，游标相当于一个指针，它指向当前的一行数据。游标只能用于存储过程或存储函数，不能单独在查询操作中使用。\n声明游标, 使用 declare CURSOR语句创建游标\n1 declare cursor_name CURSOR FOR select_statement “ cursor name”用于指定要创建的游标的名称，其命名规则与表名相同 “ select statement”用于指定一个 select语句，其会返回一行或多行的数据，且需注意此处的 select语句不能有into子句。 打开游标\n在定义游标之后，必须打开该游标，才能使用。这个过程实际上是将游标连接到由select语句返回的结果集中。在 MSQL 中，可以使用 open 语句打开游标\n1 open cursor_name “ cursor name”用于指定要打开的游标在实际应用中， 一个游标可以被多次打开，由于其他用户或应用程序可能随时更新了数据表，因此每次打开游标的结果集可能会不同。 读取数据\n对于填有数据的游标，可根据需要取出数据。在 MySQL 中，可以使用 FETCH…INTO语句从中读取数据\n1 FETCH cursor_name into var_name[,var_name]... “ cursor name”用于指定已打开的游标；语法项“ var name”用于指定存放数据的变量名。 FETCH…NTO语句与 SELECT…INTO语句具有相同的意义， FETCH语句是将游标指向的一行数据赋给一些变量，这些变量的数目必须等于声明游标时 select子句中选择列的数目。 游标相当于一个指针，它指向当前的一行数据。 关闭游标\n在结束游标使用时，必须关闭游标。在 MySQL 中，可以使用 close 语句关闭游标\n1 close cursor_name “cursor name”用于要关闭的游标。 每个游标不再需要时都应该被关闭，使用 close语句将会释放游标所使用的全部资源。 在一个游标被关闭后，如果没有重新被打开，则不能被使用。 对于声明过的游标，则不需要再次声明，可直接使用open语句打开。 另外，如果没有明确关闭游标， MySQL将会在到达END语句时自动关闭它 例 5.5 在数据库 test_db中创建一个存储过程，用于计算表 customers中数据行的行数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 use test_db; delimiter $$ create procedure sp_sumofrow(OUT ROWS2 INT) BEGIN declare cid INT; declare FOUND BOOLEAN default TRUE; declare cur_cid CURSOR FOR select cust_id from customers; declare CONTINUE HANDLER FOR not FOUND set FOUND=FALSE; set ROWS2=0; open cur_cid; FETCH cur_cid into cid; WHILE FOUND DO set ROWS2=ROWS2+1; FETCH cur_cid into cid; END WHILE; close cur_cid; END$$ ROW 是关键字, 用 ROW2;\n对存储过程 sp sumofrow进行调用\n1 2 3 mysql\u0026gt; delimiter ; mysql\u0026gt; call sp_sumofrow(@rows2); Query OK, 0 rows affected (0.00 sec) 1 2 3 4 5 6 7 mysql\u0026gt; select @rows2; +--------+ | @rows2 | +--------+ | 6 | +--------+ 1 row in set (0.03 sec) 由此例可以看出：定义了一个 CONTINUE HANDLER句柄，它是在条件出现时被执行的代码，用于控制循环语句，以实现游标的下移； declare语句的使用存在特定的次序，即用 declare语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义，否则系统会出现错误消息。 试题：在使用游标的过程中，需要注意以下几点 游标只能用于存储过程或存储函数中，不能单独在查询操作中使用。 在存储过程或存储函数中可以定义多个游标，但是在一个BEGIN…END语句块中每个游标的名字必须是唯一的。 游标不是一条 select语句，是被 select语句检索出来的结果集。 5.1.4 调用存储过程体 创建好存储过程后，可以使用call语句在程序或者其他存储过程中调用它\n1 2 call sp_name([parameter[,...]]) call sp_name[()] 语法项“ sp name”用于指定被调用的存储过程的名称。如果要调用某个特定数据库的存储过程，则需要在前面加上该数据库的名称 语法项“ parameter”用于指定调用存储过程所要使用的参数。调用语句中参数的个数必须等于存储过程的参数个数。 当调用没有参数的存储过程时，使用 call sp_name()语句与使用 call sp_name语句是相同的 例 5.6 调用数据库 test_db中的存储过程 sp update sex，将客户 id 号 为 909 的客户性别修改为男性“M”\n1 2 mysql\u0026gt; call sp_update_sex(906,\u0026#39;M\u0026#39;); Query OK, 1 row affected (0.00 sec) 5.1.5 删除存储过程体 存储过程在被创建后，会被保存在服务器上以供使用，直至被删除。在 MySQL 中，可以使用 drop procedure语句删除数据库中已创建的存储过程\n1 drop procedure[if exists]sp_name “ sp name”用于指定要删除的存储过程的名称。需注意，它后面没有参数列表，也没有括号。在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。 此外，为防止因删除不存在的存储过程而引发的错误，在 drop procedure语句中添加关键字“ if exists”。 例 5.7 删除数据库 test_db中的存储过程 sp update sex\n1 2 mysql\u0026gt; drop procedure sp_update_sex; Query OK, 0 rows affected (0.04 sec) 第二节 存储函数 存储函数与存储过程的区别\n存储函数不能拥有输出参数，这是因为存储函数自身就是输出参数；而存储过程可以拥有输出参数。 可以直接对存储函数进行调用，且不需要使用 call 语句；而对存储过程的调用，需要使用 call 语句。 存储函数中必须包含一条 RETURN语句，而这条特殊的 SQL 语句不允许包含于存储过程中。 5.2.1 创建存储函数 使用 create function语句创建存储函数\n1 2 3 create function sp_name([func_parameter[,..]]) RETURNS type routine_body 语法项 “ func parameter”的语法格式是：\n1 param_name type 语法项“sp_name”用于指定存储函数的名称，需注意，存储函数不能与存储过程具有相同的名字。 语法项“ func parameter”用于指定存储函数的参数，这里的参数只有名称和类型，不能指定关键字“in”“OUT”和“ INOUT RETURNS子句用于声明存储函数返回值的数据类型，其中type用于指定返回值的数据类型。 语法项“ routine body”用于指定存储函数的主体部分，也称为存储函数体。所有在存储过程中使用的 SQL 语句在存储函数中同样也适用，包括前面所介绍的局部变量、set语句、流程控制语句、游标等。但是，存储函数体中还必须包含一个 return value语句, 其中value用于指定存储函数的返回值 例 5.8 在数据库 test_db中创建一个存储函数，要求该函数能根据给定的客户 id 号返回客户的性别，如果数据库中没有给定的客户 id 号，则返回“没有该客户”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 use test_db; delimiter $$ create function fn_search(cid INT) RETURNS char(2) DETERMINISTIC BEGIN declare SEX char(2); select cust_sex into SEX from customers where cust_id=cid; if SEX IS null then RETURN(select\u0026#39;没有该客户\u0026#39;); ELSE if SEX=\u0026#39;F\u0026#39; then RETURN(select\u0026#39;女\u0026#39;); ELSE RETURN(select\u0026#39;男\u0026#39;); END if; END if; END$$ delimiter ; 5.2.2 调用存储函数 可以如同调用系统内置函数一样，使用关键字 SELECT 对其进行调用\n1 select sp_name([func_parameter[,...]]) 例 5.9 调用数据库 test_db中的存储函数 fn search\n1 2 3 4 5 6 7 mysql\u0026gt; select fn_search(904); +----------------+ | fn_search(904) | +----------------+ | 男 | +----------------+ 1 row in set (0.00 sec) 5.2.3 删除存储函数 存储函数在被创建后，会被保存在服务器上以供使用，直至被删除。删除存储函数的方法与删除存储过程的方法基本一样。在 MySQL 中，可以使用 drop function语句来实现\n1 drop function [if exists] sp_name “ sp name”指定要删除的存储函数的名称。 注意，它后面没有参数列表，也没有括号。 在删除之前，必须确认该存储函数没有任何依赖关系，否则会导致其他与之关联的存储函数无法运行。 同样，为防止因删除不存在的存储函数而引发的错误，可在 drop function 语句中添加关键字“ if exists”。 例 5.10 删除数据库 test_db中的存储函数 fn search\n1 2 mysql\u0026gt; drop function if exists fn_search; Query OK, 0 rows affected (0.01 sec) 第六章 数据库安全与防护 第一节 数据库完整性 数据库完整性是指 数据库中数据的正确性和相容性。\n6.1.1 完整性约束条件的作用对象 完整性检查是围绕完整性约束条件进行的，因而完整性约束条件是完整性控制机制的核心。完整性约束条件的作用对象可以是列、元组和表。 列级约束主要指对列的类型、取值范围、精度等的约束 对数据类型的约束，其包括数据类型、长度、精度等。 例如，在 customers表中将客户地址的数据类型设定为定长字符型，且长度为 50。 对数据格式的约束。 例如，在学生信息表 tb student表中可将学号 studentNo字段的前四位规定为学生的入学年份，第 5 位规定为院系的编号等。 对取值范围或取值集合的约束。 例如，在学生成绩表 tb score 表中规定成绩 score 字段的取值范围为 0 到 100。 对空值的约束。 例如，在定义列时规定该列是否允许取空值。 元组约束指元组中各个字段之间的相互约束 例如某个活动的开始日期小于结束日期 表级约束指若干元组之间、关系之间的联系的约束。 例如，在学生成绩表 tb score 表中学号 studentNo字段的取值受学生信息表 tb student 表中学号 studentNo 字段取值的约束。 6.1.2 定义与实现完整性约束 实体完整性\n在 MSQL 中，实体完整性是通过主键约束和候选键约束来实现的\n主键约束\n主键可以是表中的某一列，也可以是表中多个列所构成的一个组合。其中，由多个列组合而成的主键也称为复合主键。\n每一个表只能定义一个主键。 主键的值必须能够唯一标志表中的每一行记录，且不能为null，即表中不同行在主键上不能具有相同的值。这是唯一性原则 复合主键不能包含不必要的多余列。即当从一个复合主键中删除一列后，如果剩下的列构成主键仍能满足唯一性原则，那么这个复合主键是不正确的。这是最小化规则。 一个列名在复合主键的列表中只能出现一次。 主键约束可以在 create table 或 alter table 语句中使用关键字“ primary key”来实现，其方式有两种。\n一种是作为列的完整性约束，此时只需在表中某个列的属性定义后加上关键字primary key”即可。 一种是作为表的完整性约束，需要在表中所有列的属性定义后添加一条 primary key(index col_name,...)格式的子句 候选键约束\n候选键可以是表可以是表中多个列所构成的一个组合，候选键的值必须是唯一的，且不能为null。候选键可以在 create table 或 alter table 语句中使用关键字“ unique”来定义 一个表中只能创建一个主键，但可以定义若干个候选键 定义主键约束时，系统会自动产生 primary key索引，而定义候选键约束时，系统自动产生 unique索引 参照完整性\n参照完整性是通过在创建表（ create table）或更新表（ alter table）的同时定义一个外键声明来实现的。\n在表中某个列的属性定义后直接加上“ reference_definition”语法项。\n在表中所有列的属性定义后添加“ foreign key(index_col_name,...) reference_definition”子句的语法项。\n这里列出 create table语句和 alter table 语句中“ reference definition”语法项的定义： 1 2 3 REFERENCES tbs_name(index_col_name,...) [on delete reference_option] [on update reference_option] index_col_name 语法格式\n1 col_name[(length)][asc|desc] reference_option 的语法格式\n1 restrict|CASXADE|set null|NO ACTION 由此可见，语法项“ reference definition”的语法定义主要包含外键所参照的表和列，以及参照动作的声明和实施策略等四部分内容。其中，相关语法说明如下\n“ tbl_name”指定外键所参照的表名。 这个表称为被参照表（或父表），而外键所在的表称作参照表（或子表）。 “ col_name”指定被参照的列名。 外键可以引用被参照表中的主键或候选键，也可以引用被参照表中某些列的一个组合，但这个组合不能是被参照表中随机的一组列，必须保证该组合的取值在被参照表中是唯一的。 外键中的所有列值在被参照表的列中必须全部存在，也就是通过外键来对参照表中某些列（外键）的取值进行限定与约束。 关键字“ on delete”或“ on update”指定参照动作相关的 SOL 语句。 这里可为每个外键指定的参照动作分别对应于 delete 语句和 UPDATE 语句。 语法项“ reference option”指定参照完整性约束的实现策略。 其中，当没有明确指定参照完整性的实现策略时，两个参照动作会默认使用 restrict。 关键字“ restrict”表示限制策略，即当要删除或更新被参照表中被参照列上，并在外键中出现的值时，系统拒绝对被参照表的删除或更新操作：关键字“ CASCADE”表示级联策略，即从被参照表中删除或更新记录行时，自动删除或更新参照表中匹配的记录行； 关键字“set null”表示置空策略，即当从被参照表中删除或更新记录行时，设置参照表中与之对应的外键列的值为null，这个策略需要被参照表中的外键列没有声明限定词 not null； 关键字“ NO ACTION”表示不采取实施策略，即当一个相关的外键值在被参照表中时，删除或更新被参照表中键值的动作不被允许，该策略的动作语义与 restrict相同。 例 6.1 在数据库 test_db中创建一个商品订单表oder，该表包含的订单信息有：订单号 oder id、订购商品名 order product、订购商品类型 order product type、订购客户 id 号 cust id、订购时间 order date、订购价格 order price、订购数量 order amount。要求商品订单表 orders中的所有订购客户信息均已在表 customers 中记录在册。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 use test_db; create table orders ( order_id INT not null AUTO_INCREMENT, order_product char(50) not null, order_product_type char(50) not null, cust_id INT not null, order_date DATETIME not null, order_price DOUBLE not null, order_amount INT not null, primary key(order_id), foreign key(cust_id) REFERENCES customers(cust_id) on delete restrict on update restrict ); 从 例 6.1 可以看到，其通过使用关键字“ primary key”定义了一个主键约束，与此同时，它还通过定义外键创建了一个参照完整性约束，其作用是确保 MySQL 随时检测插入到外键中的每一个非空值是否都已经在被参照表中作为主键出现了，具体而言就是，对于插入表 orders中的每一个订购客户 id 号都执行一次检测，查看这个订购客户 id 号是否已经出现在表 customers 的客户 id 号列（主键）中。 如若没有，数据将无法正常插入，且系统会返回如下错误提示：ERROR1452（23000：Cannot add or update a child row:a foreign key constraint fails。 这个过程也适用于使用 update语句更新表 orders中的 cust id列，即由 MySQL 确保表 orders中 cust_id列的内容总是表 customers中 cust id列的内容的个子集 指定一个外键的规则 被参照表必须已经用一条 create table话句创建了，或者必须是当前正在创建的表。如若是后一种情形，则被参照表与参照表是同一个表，这样的表称为自参照表（self referencing table），这种结构称为自参照完整性（ self-referential integrity） 必须为被参照表定义主键。 必须在被参照表的表名后面指定列名或列名的组合。这个列或列组合必须是这个被参照表的主键或候选键。 尽管主键是不能够包含空值的，但允许在外键中出现一个空值。这意味着，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的 外键中的列的数目必须和被参照表的主键中的列的数目相同 外键中的列的数据类型必须和被参照表的主键中的对应列的数据类型相同。 用户自定义的完整性\n非空约束: 在某个列定义后面，加上关键字“ not null”作为限定词，来约束该列的取值不能空。\nCHECK 约束: 与非空约束一样，根据用户的实际完整性要求来定义的。它可以分别对列或表实施 CHECK 约束\n1 CHECK(expr) 语法项“expr”是一个 SQL 表达式，用于指定需要检查的限定条件。在更新表数据时， MySQL 会检查更新后的数据行是否满足 CHECK 约束中的限定条件。 MQL 可以使用简单的表达式来实现 CHECK 约束，也允许使用复杂的表达式作为限定条件，例如，在限定条件中加入子查询。 若将 CHECK 约束子句置于表中某个列的定义之后，则这种约束也称为基于列的 CHECK约束； 若将 CHECK 约束子句置于表中所有列的定义以及主键约束和外键定义之后，则这种约束也称为基于表的 CHECK 约束，该约束可以同时对表中多个列设置限定条件 触发器\n6.1.3 命名完整性约束 在各种完整性约束的定义说明之前加上关键字“ constraint”和该约束的名字\n1 constraint [symbol] 其中，语法项“ symbol”是指定的约束名字，这个名字是在完整性约束说明的前面被定义，其在数据库里必须是唯一的。倘若没有明确给出约束的名字，则 MySQL 自动创建一个约束名字。 在定义完整性约束时，应当尽可能地为其指定名字，以便在需要对完整性约束进行修改或删除操作时，可以更加容易地引用它们。 需要注意的是，只能给基于表的完整性约束指定名字，而无法给基于列的完整性约束指定名字。因此，基于表的完整性约束比基于列的完整性约束更受欢迎 6.1.4 更新完整性约束 当对各种约束进行命名后，就可以使用 alter table语句来更新与列或表有关的各种约束。例如，若要添加约束，可在 alter table语句中使用 add constraint子句，实际上这也是定义约束的一种形式。此外，需要注意以下两点。 完整性约束不能直接被修改。若要修改某个约束，实际上是用 alter table语句先删除该约束，然后再增加一个与该约束同名的新约束。（先删除，再增加） 使用 alter table语句，可以独立地删除完整性约束，而不会删除表本身。若使用 drop table语句删除一个表，则表中所有的完整性约束都会自动被删除。 第二节 触发器(难点) 触发器（ Trigger）是用户定义在关系表上的一类由事件驱动的数据库对象，也是一种保证数据完整性的方法。 触发器一旦定义，无须用户调用，任何对表的修改操作均由数据库服务器自动激活相应的触发器。 每个表最多支持6个触发器。 例如，每当客户订购一个产品时，都从产品库存量中减去可订购的数量；每当删除客户基本信息表中一个客户的全部基本信息数据时，该客户所订购的未完成订单信息也应该被自动删除。 6.2.1 创建触发器 使用 create TRIGGER 语句创建触发器\n1 2 create TRIGGER trigger_name trigger_time trigger_event on tbl_name FOR EACH ROW trigger_body 语法项“ trigger_name”用于指定触发器的名称，触发器在当前数据库中必须具有唯的名称。 如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。 语法项“ trigger_time”用于指定触发器被触发的时刻，它有两个选项，即关键字“ BEFORE”和关键字“ after”，用于表示触发器是在激活它的语句之前或者之后触发。 如果希望验证新数据是否满足使用的限制，则使用 BEFORE选项； 如果希望在激活触发器的语句执行之后完成几个或更多的改变，通常使用 after选项。 语法项“ trigger_event”用于指定触发事件，即指定激活触发器的语句的种类，其可以是下述值之一： 关键字“ insert”，表示将新的数据行插入到表时激活触发器； 关键字“ update”，表示更改表中某一行数据时激活触发器； 关键字“ delete”，表示从表中删除某一行数据时激活触发器。 语法项“ tbl name”用于指定与触发器相关联的表名，必须引用永久性表，不能将触发器与临时表或视图关联起来，且同一个表不能拥有两个具有相同触发时刻和事件的触发器 关键字“ FOR EACH ROW”用于指定对于受触发事件影响的每一行都要激活触发器的动作。 例如，使用一条 insert 语句向一个表中插入多行数据时，触发器会对每一行数据的插入都执行相应触发器动作 语法项“ trigger body”用于指定触发器动作主体，即包含触发器激活时将要执行的 MySQL 语句。 如果要执行多个语句，可使用BFGN…END复合语句结构。 此外，需要注意的是，在触发器的创建中，每个表每个事件每次只允许一个触发器。因此，每个表最多支持 6 个触发器，即每条 insert、 update和 delete的“之前”与“之后”。单一触发器不能与多个事件或多个表关联，例如，需要一个对 NSERT 和 UPDATE 操作执行的触发器，则应该定义两个触发器。 例 6.2 在数据库 test_db的表 customers 中创建一个触发器 customers insert trigger用于每次向表插入一行数据时，将用户变量 str 的值设置为“ one customer added!”。\n1 2 create TRIGGER test_db.customers_insert_trigger after insert on test_db.customers FOR EACH ROW set @str=\u0026#39;one customer added!\u0026#39;; 在 MySQL 命令行客户端使用 insert语句向表 customers插入如下一行数据，并查询\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; insert into test_db.customers values(null,\u0026#39;万华\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;长沙市\u0026#39;,\u0026#39;芙蓉区\u0026#39;,null); Query OK, 1 row affected (0.01 sec) mysql\u0026gt; select @str; +-------------------+ | @str | +-------------------+ | one customer add! | +-------------------+ 1 row in set (0.00 sec) 6.2.2 删除触发器 使用 DROP 语句将触发器从数据库中删除\n1 drop TRIGGER[if exists][schema_name.]trigger_name 其中，关键字“ if exists”用于避免在没有触发器的情况下删除触发器； 语法项“schema_name”用于指定触发器所在的数据库的名称，若没有指定，则为当前默认数据库； 语法项“ trigger name”指定要删除的触发器名称 例 6.3 删除数据库 test_db 中的触发器 customers_insert_trigger\n1 drop TRIGGER if exists test_db.customers_insert_trigger; 当删除一个表的同时，也会自动地删除该表上的触发器，且触发器不能更新或覆盖，为了修改一个触发器，必须先删除它，然后再重新创建。 6.2.3 使用触发器 insert 触发器可在 insert 语句执行之前或之后执行。\n在 insert触发器代码内，可引用一个名为NEW的虚拟表，来访问被插入的行。 在 BEFORE insert触发器中，NEW中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。 对于 AUTO INCREMENT列，NEW在 insert执行之前包含的是 0 值，在 insert 执行之后将包含新的自动生成值。 例 6.4 在数据库 test_db的表 customers中重新创建触发器 customers insert trigger用于每次向表 customers插入一行数据时，将用户变量 str 的值设置为新插入客户的 id 号\n1 2 3 4 5 create TRIGGER test_db.customers_insert_trigger after insert on test_db.customers FOR EACH ROW set @str=NEW.cust_id; insert into test_db.customers values(null,\u0026#39;曾伟\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;长沙市\u0026#39;,\u0026#39;芙蓉区\u0026#39;,null); select @str; delete 触发器可在 delete语句执行之前或之后执行。\n在 delete触发器代码内，可以引用一个名为OLD的虚拟表，来访问被删除的行。 OLD中的值全部是只读的，不能被更新。 update 触发器在 update语句执行之前或之后执行。\n在 update触发器代码内，可以引用一个名为OLD的虚拟表访问以前（ update语句执行前）的值，也可以引用一个名为NEW的虚拟表访问新更新的值 在 BEFORE update触发器中，NEW中的值可能也被更新，即允许更改将要用于update语句中的值（只要具有对应的操作权限）。 OLD中的值全部是只读的，不能被更新。 当触发器涉及对触发表自身的更新操作时，只能使用 BEFORE update触发器，而after update触发器将不被允许 例 6.5 在数据库 test_db的表 customers中创建一个触发器 customers_update_trigger，用于每次更新表 customers时，将该表中 cust address列的值设置为 cust contact列的值\n1 2 3 4 5 6 7 create TRIGGER test_db.customers_update_trigger BEFORE update on test_db.customers FOR EACH ROW set NEW.cust_address=OLD.cust_contact; update test_db.customers set cust_address=\u0026#39;武汉市\u0026#39; where cust_name=\u0026#39;曾伟\u0026#39;; select cust_address from test_db.customers where cust_name=\u0026#39;曾伟\u0026#39;; 第三节 安全性与访问控制 数据库的安全性是指数据库以防止不合法的使用而造成数据泄露、更改或破坏。 安全性与访问性控制：身份验证、数据库用户权限确认\n6.3.1 用户账号管理 MySQL 的用户账号及相关信息都存储在一个名为 mysql 的 MySQL 数据库中，这个数据库里有一个名为 user的数据表，包含了所有用户账号，并且它用一个名为user 的列存储用户的登录名。\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; select user from mysql.user; +------------------+ | user | +------------------+ | mysql.infoschema | | mysql.session | | mysql.sys | | root | +------------------+ 4 rows in set (0.00 sec) 在 MySQL 的日常管理和实际操作中，为了避免恶意用户冒名使用 root账号操控数据库，通常需要创建一系列具备适当权限的账号，而尽可能地不用或少用 root账号登录系统，以此来确保数据的安全访问。\n使用 create user 语句来创建一个或多个 MySQL 账户，并设置相应的口令\n1 create user user[identified by[PASSWOED]\u0026#39;passwoed\u0026#39;] 语法项“user”指定创建用户账号，其格式为 user_name'@'host_name'。 其中，user name表示用户名， host name表示主机名，即用户连接 MySQL 时所在主机的名字。 如果在创建的过程中，只给出了账户中的用户名，而没指定主机名，则主机名会默认为是 “%”，其表示一组主机 语法项“ identified by子句”是可选项，用于指定用户账号对应的口令，若该用户账号无口令，则可省略此子句 关键字“ password”是可选项，用于指定散列口令，即若使用明文设置口令时，需忽略 password关键字； 如果不想以明文设置口令，且知道 password()函数返回给密码的散列值，则可以在此口令设置语句中指定此该散列值，但需要加上关键字 password 语法项“ password”指定用户账号的口令，其在 identified by 关键字或 password 关键字之后。 设定的口令值可以是只由字母和数字组成的明文，也可以是通过password()函数得到散列值 例 6.6 在 MySQL 服务器中添加两个新的用户，其用户名分别为 zhangsan和lisi，他们的主机名均为 localhost，用户 zhangsan的口令设置为明文123，用户lisi的口令设置为对明文456使用 password()函数加密返回的散列值。\n1 2 3 4 # password() 功能已在MySQL 8.0.11中删除。 select MD5(456); create user \u0026#39;张三\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123\u0026#39;, \u0026#39;李四\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;250cf8b51c773f3f8dc8b4be867a9a02\u0026#39;; 要使用 create user语句，必须拥有 MySQL 中 mysql 数据库的 insert 权限或全局 create user 权限。 使用 create user 语句创建一个用户账号后，会在系统自身的 mysql数据库的user表中添加一条新记录。如果创建的账户已经存在，则语句执行会出现错误 如果两个用户具有相同的用户名和不同的主机名， MySQL 会将他们视为不同的用户，并允许为这两个用户分配不同的权限集合。 如果在 create user 语句的使用中，没有为用户指定口令，那么 MySQL 允许该用户可以不使用口令登录系统，然而从安全的角度而言，不推荐这种做法。 新创建的用户拥有的权限很少。他们可以登录到 MySQL，只允许进行不需要权限的操作，比如使用show 语句查询所有存储引擎和字符集的列表等，不能使用 use 语句来让其他用户已经创建了的任何数据库成为当前数据库，因而无法访问那些数据库的表。 删除一个或多个用户账号以及相关的权限，可以使用 drop user 语句\n1 drop user user[,user]... 例 6.7 删除前面例子中的lisi用户。\n1 drop user \u0026#39;李四\u0026#39;@localhost; drop user 语句可用于删除一个或多个 MySQL 账户，并消除其权限。 要使用 drop user语句，必须拥有 MySQL 中 mysq 数据库的 delete 权限或全局 create user 权限 在 drop user 语句的使用中，如果没有明确地给出账户的主机名，则该主机名会默认为是 %。 用户的删除不会影响到他们之前所创建的表、索引或其他数据库对象，这是因为 MySQL 并没有记录是谁创建了这些对象。 使用 rename user 语句修改一个或多个已经存在的 MySQL 用户账号\n1 rename user old_user TO new_user[,old_user TO new_user]... 例 6.8 将前面例子中用户 张三的名字修改成 王五\n1 rename user \u0026#39;张三\u0026#39;@localhost TO \u0026#39;王五\u0026#39;@localhost; rename user 语句用于对原有 MySQL 账户进行重命名。 要使用 rename user语句，必须拥有 MySQL 中 mysq 数据库的 update 权限或全局 create user权限。 倘若系统中旧账户不存在或者新账户已存在，则语句执行会出现错误。 使用 set password 语句修改一个用户的登录口令\n1 2 3 4 5 set password [FOR user]= { password(\u0026#39;new_password\u0026#39;) |\u0026#39;encrypted password\u0026#39; } 语法项“FOR子句”为可选项，用于指定欲修改口令的用户；\n语法项“ password(new password)”表示使用函数 password() 设置新口令 new password，即新口令必须传递到函数 password() 中进行加密；\n语法项“ encrypted password”表示已被函数 password() 加密的口令值。\n例 6.9 将前面例子中用户 wangwu 的口令修改成明文hello对应的散列值。\n1 2 set password FOR \u0026#39;王五\u0026#39;@localhost =\u0026#39;5d41402abc4b2a76b9719d911017c592\u0026#39;; 若不加上 FOR 子句，表示修改当前用户的口令；\n若加上 FOR 子句，表示修改账户为user的用户口令，其中user的格式必须以 user name@ ahost name的格式给定， user name为账户的用户名， host name为账户所在的主机名。该账户必须在系统中存在，否则语句执行会出现错误。\n只能使用选项“ password(new password)”和“ encrypted password”中的一项，且必须使用其中的某一项。\n6.3.2 用户权限管理 成功创建用户账号后，需要为该用户分配访问适当的权限，因为新创建的用户账号没有访问权限，只能登录 MySQL 服务器，不能执行任何数据库操作。\n例如，使用show GRANTS FOR语句就可以查看前面新创建的用户 zhangsan的如下授权表\n1 show GRANTS FOR \u0026#39;王五\u0026#39;@localhost; 权限的授予\n1 2 3 4 5 6 grant priv_type[(column_list)] [,priv_type[(column_list)]]... on[object_type]priv_level TO user_specification[,user_specification]... [WITH grant OPTION] 语法项“ priv type”用于指定权限的名称，例如 select、 update、 delete等数据库操作。\n可选语法项“ column_list”用于指定权限要授予给表中哪些具体的列\n语法项“on”用于指定权限授予的对象和级别，例如可在关键字“on”后面给出要授予权限的数据库名或表名。\n可选项“ object_type”用于指定权限授予的对象类型，包括表、函数和存储过程分别用关键字“ table”“ function”和“ procedure”标识。\n语法项“ priv_level”：用于指定权限的级别，其可以授予的权限有这样几个：\n列权限、表权限、数据库权限和用户权限。 相应地，在 grant 语句中可用于指定权限级别的值有这样几类格式： “*”表示当前数据库中的所有表； “*.*”表示所有数据库中的所有表； “ db_name.*”表示某个数据库中的所有表， db_name指定数据库名； “ db_name.tbl_name”表示某个数据库中的某个表或视图， db_name指定数据库名， tbl_name指定表名或视图名； “ tbl_name”表示某个表或视图， tbl_name指定表名或视图名； “ db_name.routine_name”表示某个数据库中的某个存储过程或函数， routine_name指定存储过程名或函数名。 语法项“TO子句”用来设定用户的口令，以及指定被授予权限的用户user。\n若在TO子句中给系统中存在的用户指定口令，则新密码会将原密码覆盖； 如果权限被授予给个不存在的用户， MySQL 会自动执行一条 create user 语句来创建这个用户，但同时必须为该用户指定口令。 由此可见， grant 语句亦可以用于创建用户账号。 语法项“ user specification”是To子句中的具体描述部分，其常用的语法格式是：\n1 user [identified by [password] \u0026#39;password\u0026#39;] 语法项“WITH子句”为可选项，用于实现权限的转移或限制。\n例 6.10 授予用户 Zhangsan在数据库 test_db的表 customers上拥有对列 cust_id和列cust_name的 select权限\n1 2 3 grant select (cust_id,cust_name) on test_db.customers TO \u0026#39;王五\u0026#39;@localhost; 1 2 mysql\u0026gt; select * from test_db.customers; ERROR 1142 (42000): select command denied to user \u0026#39;wangwu\u0026#39;@\u0026#39;localhost\u0026#39; for table \u0026#39;customers\u0026#39; 例 6.11 当前系统中不存在用户 liming和用户 huang，要求创建这两个用户，并设置对应的系统登录口令，同时授予他们在数据库 test_db的表 customers上拥有 select和update的权限。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 create user \u0026#39;liming\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123\u0026#39;, \u0026#39;huang\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;234\u0026#39;; #查看更新权限 grant select,update on test_db.customers TO \u0026#39;liming\u0026#39;@\u0026#39;localhost\u0026#39;, \u0026#39;huang\u0026#39;@\u0026#39;localhost\u0026#39;; #数据库权限 grant ALL on test_db.* TO \u0026#39;wangwu\u0026#39;@\u0026#39;localhost\u0026#39;; #创建用户权限 grant ALL on *.* TO \u0026#39;wangwu\u0026#39;@\u0026#39;localhost\u0026#39;; 授予表权限时，语法项“ priv type”可以指定为以下值。 SELECT：表示授予用户可以使用 SELECT 语句访问特定表的权限。 INSERT：表示授予用户使用 insert 语句向一个特定表中添加数据行的权限。 DELETE：表示授予用户可以使用 delete 语句向一个特定表中删除数据行的权限 UPDATE：表示授予用户可以使用 UPDATE 语句修改特定数据表中值的权限。 REFERENCES：表示授予用户可以创建一个外键来参照特定数据表的权限 CREATE：表示授予用户可以使用特定的名字创建一个数据表的权限。 ALTER：表示授予用户可以使用 alter table 语句修改数据表的权限。 INDEX：表示授予用户可以在表上定义索引的权限。 DROP：表示授予用户可以删除数据表的权限。 ALL 或 ALL PRIVILEGES：表示所有的权限名。 授予列权限时，语法项“ priv type”的值只能指定为 SELECT、 insert 和 UPDATE，同时权限的后面需要加上列名列表 column list 授予数据库权限时，语法项“ priv type”可以指定为以下值。 SELECT：表示授予用户可以使用 select 语句访问特定数据库中所有表和视图的权限。 INSERT：表示授予用户可以使用 insert 语句向特定数据库中所有表添加数据行的权限 DELETE：表示授予用户可以使用 delete 语句删除特定数据库中所有表的数据行的权限。 UPDATE：表示授予用户可以使用 update 语句更新特定数据库中所有数据表的值的权限。 REFERENCES：表示授予用户可以创建指向特定的数据库中的表外键的权限。 CREATE：表示授予用户可以使用 create table 语句在特定数据库中创建新表的权限。 ALTER：表示授予用户可以使用 alter table 语句修改特定数据库中所有数据表的权限。 INDEX：表示授予用户可以在特定数据库中的所有数据表上定义和删除索引的权限。 DROP：表示授予用户可以删除特定数据库中所有表和视图的权限 create TEMPORARY TABLES：表示授予用户可以在特定数据库中创建临时表的权限。 create VIEW：表示授予用户可以在特定数据库中创建新的视图的权限。 show VIEW：表示授予用户可以查看特定数据库中已有视图的视图定义的权限 create ROUTINE：表示授予用户可以为特定的数据库创建存储过程和存储函数等权限。 alter ROUTINE：表示授予用户可以更新和删除数据库中已有的存储过程和存储函数等权限。 EXECUTE ROUTINE：表示授予用户可以调用特定数据库的存储过程和存储函数的权限。 LOCK TABLES：表示授予用户可以锁定特定数据库的已有数据表的权限 AL 或 ALL PRIVILEGES：表示以上所有的权限名。 最有效率的权限是用户权限。授予用户权限时，语法项“ priv type”除了可以指定为授予数据库权限时的所有值之外，还可以是下面这些值。 create USER：表示授予用户可以创建和删除新用户的权限。 show DATABASES：表示授予用户可以使用 show databases 语句查看所有已有的数据库的定义的权限。 权限的转移\n通过在 grant 语句中使用 WITH 子句来实现。\n例 6.14 授予当前系统中一个不存在的用户zhou在数据库 test_db的表 customers上拥有 select和 update的权限，并允许其可以将自身的这个权限授予给其他用户。\n1 2 3 4 5 create user \u0026#39;zhou\u0026#39;@localhost identified by\u0026#39;123\u0026#39;; grant select,update on test_db.customers TO \u0026#39;zhou\u0026#39;@\u0026#39;localhost\u0026#39; WITH grant OPTION; 权限的撤销\n1 2 3 4 5 revoke priv_type[(column_list)] [,priv_type[(column_list)]]... on [object_type]privl_evel from user[,user]... 回收特定用户的所有权限时\n1 revoke ALL PRIVILEGES,grant OPTION from user[,user]... 例 6.15 回收系统中已存在的用户zhou在数据库 test_db的表customers上的select权限。\n1 2 3 revoke select on test_db.customers from \u0026#39;zhou\u0026#39;@localhost; 第四节 事务与并发控制 （重点） 6.4.1 事务的概念(201810) 事务是用户定义的一个数据操作序列，这些操作可作为一个完整的工作单元，要么全部执行，要么全部不执行，是一个不可分割的工作单位。 在 SQL 中，用户显式定义事务的语句一般有这样三条：BEGIN TRANSACTION、 COMMIT 和 ROLLBACK，且事务通常是以 BEGIN TRANSACTION 语句开始，以 COMMIT 语句或 ROLLBACK 语句结束。 其中， COMMIT 语句表示提交，即提交事务的所有操作，具体地说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束； ROLLBACK 语句表示回滚，即在事务运行的过程中若发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态。事务中的操作一般是对数据的更新操作，包括增、删、改。 6.4.2 事务的特征(ACID) 原子性（ Atomicity） 事务的原子性保证事务包含的一组更新操作是原子不可分的，即事务是不可分割的最小工作单位，所包含的这些操作是一个整体。事务在执行时，要求遵守“要么全做，要么全不做”的原则。即使在系统崩溃之后，也能通过撤销系统崩溃时所处于活动状态的事务对数据库的影响，从而保证事务的原子性 一致性（ Consistency） 一致性要求事务必须满足数据库的完整性约束，且事务执行完毕后将数据库由一个一致性状态转变到另一个一致性状态。其中，数据库的一致性状态是一种以一致性规则为基础的逻辑属性。例如一个典型实例：在银行数据库系统中，通常有这样一个事务“从账户 A 转账 S 金额资金到账户 B”，此事务包含两个操作，即从账户 A 减去 S 金额资金，和在账户 B 中增加 S 金额资金，如果只执行其中一个操作，则数据库会处于不一致状态，那么就需要这两个操作成为一个整体，要么全做，要么全不做，否则不能成为事务。由此可见，一致性和原子性密切相关。 隔离性（ Isolation） 隔离性要求事务是彼此独立的、隔离的，即一个事务的执行不能被其他事务所干扰，个事务对数据库变更的结果必须在它 COMMIT 后，另一个事务才能存取。多个事务并发执行时，其结果应等价于它们的一种顺序执行的结果，就如同串行调度执行事务一般。这一特性也称为可串行性，即系统执行的任何交错操作调度实质上是一个串行调度，而串行调度是指每当调度一个事务，在该事务的所有操作没有结束之前其他的事务不能被执行。 持续性（ Durability） 持续性也称为永久性（ Permanence），是指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，且接下来的其他操作或故障不应该对其执行结果有任何影响。 例 6.16 依据事务的 ACID 特征，分析并编写银行数据库系统中的转账事务 T：从账户 A 转账 S 金额资金到账户 B。\n1 2 3 4 5 6 read(A); A=A-S; write(A); read(B); B=B+S; write(B); 在数据库执行上述所有操作执行的过程中，若某一时刻账户 A 已减去 S 金额的资金，而账户 B 尚未增加，这显然就会出现一种不一致的状态，因此需要将所有操作当作一个不可分割的整体，遵守“要么全做，要么全不做”的原则，保证事务的原子性 在数据库上述所有操作执行的过程中，要求数据库中账户 A 减去 S 金额资金的同时，账户 B 增加 S 金额资金，即账户 A 和账户 B 之和不变，维系数据库的一致性状态，保证事务的一致性。 在数据库上述所有操作执行的过程中，如若有其他操作插入进来修改账户 A 或账户 B 的金额，会导致错误数据的产生，因此需要隔离上述所有操作，保证事务的隔离性。 在数据库上述所有操作成功执行完毕后，系统需要确保以后任何故障都不会再引起与这次转账相关的数据的丢失，保证事务的持久性。 1 2 3 4 5 6 7 8 9 10 11 12 BEGIN TRANSACTION read(A); A=A-S; write(A); if(A\u0026lt;0)ROLLBACK; else { read(B); B=B+S; write(B); COMMIT; } 其中， ROLLBACK 语句表示在账户 A 扣款透支时拒绝该转账操作，执行回滚操作，数据库中相关数据的值恢复到这个事务的初始状态； COMMIT 语句表示转账操作顺利结束，数据库处于新的一致性状态。 6.4.3 并发操作问题 丢失更新\n设有两个事务 T1 和 T2 ，当它们同时读入同一数据并加以修改时，事务 T2 的提交结果会破坏事务 T1 提交的结果，由此导致事务 T1 的修改被丢失。这就是一种由于对数据的并发操作而带来的数据不一致性。 不可重复读\n设有两个事务 T1 和 T2 ，不可重复读是指事务 T1 读取数据后，事务 T2 执行更新操作，使事务 T1 无法再现前一次读取结果。通常，不可重复读包括三种情况。\n事务 T1 读取某一数据后，事务 T2 对其做了修改，当事务 T1 再次读该数据时，得到与前一次不同的值 事务 T1 按一定条件从数据库中读取了某些数据记录后，事务 T2 删除了其中部分记录，当事务 T1 再次按相同条件读取数据时，发现某些记录神秘地消失了 事务 T1 按一定条件从数据库中读取某些数据记录后，事务 T2 插入了一些记录，当事务 T1 再次按相同条件读取数据时，发现多了一些记录。 读“脏”数据\n设有两个事务 T1 和 T2 ，读“脏”数据是指，事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，事务 T1 由于某种原因被撤销，这时事务 T1 已修改过的数据恢复原值，事务 T2 读到的数据就与数据库中的数据不一致，则事务 T2 读到的数据就为 “脏”数据，即不正确的数据。 解决并发操作所带来的数据不一致性问题的方法有封锁、时间戳、乐观控制法和多版本并发控制等。本节接下来主要介绍封锁方法，这也是众多数据库产品采用的基本方法。\n6.4.4 封锁 是最常用的并发控制技术 锁\n一个锁实质上就是允许或阻止一个事务对一个数据对象的存取特权。 一个事务对一个对象加锁的结果是将别的事务“封锁”在该对象之外，特别是防止了其他事务对该对象的变更，而加锁的事务则可执行它所希望的处理并维持该对象的正确状态 确切的控制由封锁的类型决定。基本的封锁类型有两种： 排他锁（ Exclusive lock，Ⅹ 锁）和共享锁（ Shared Lock, S 锁）。 写操作要求排它锁（X 锁），读操作要求共享锁（S 锁） 用封锁进行并发控制\n若事务 T 对数据 D 加了 X 锁，则所有别的事务对数据 D 的锁请求都必须等待直到事务 T 释放锁 若事务 T 对数据 D 加了 S 锁，则别的事务还可对数据 D 请求 S 锁，而对数据 D 的 Ⅹ 锁请求必须等待直到事务 T 释放锁。 事务执行数据库操作时都要先请求相应的锁，即对读请求 S 锁，对更新（插入、删除、修改）请求 X 锁。这个过程一般是由 DBMS 在执行操作时自动隐含地进行。 事务一直占有获得的锁直到结束（ COMMIT 或 ROLLBACK）时释放。 因此，利用封锁机制可以解决上述并发操作所带来的三个不一致性问题。 封锁的粒度\n通常以粒度来描述封锁的数据单元的大小。DBMS 可以决定不同粒度的锁。 由最底层的数据元素到最高层的整个数据库，粒度越细，并发性就越大，但软件复杂性和系统开销也就越大。锁住整个数据库，DBMS 的管理与控制最简单，只需设置和测试一个锁，故系统开销也最小。 然而对数据的存取则只能顺序进行，因而系统的总体性能大大下降。反之，数据元素层锁将提供最高的并发性，但 DBMS 要设置大量的锁装置来标识那些当前被封锁的数据元素，同时还要大量的锁检测，影响了每一事务的服务性能，系统总体性能也因此而下降。 所以，大多数高性能系统都选择折中的锁粒度，至于哪一层最合适，则与应用环境下事务量、数据量及数据的易变性特征等都紧密相关 封锁的级别\n0 级封锁 封锁的事务不重写其他非 0 级封锁事务的未提交的更新数据。这种状态实际上实用价值不大。 1 级封 锁被封锁的事务不允许重写未提交的更新数据。这防止了丢失更新的发生。 2 级封锁 被封锁的事务既不重写也不读未提交的更新数据。这除了 1 级封锁的效果外还防止了读脏数据。 3 级封锁 被封锁的事务不读未提交的更新数据，不写任何（包括读操作的）未提交数据。显然这除了包含 2 级封锁外，还不写未提交的读数据，因而防止了不可重读的问题。这是严格的封锁，它保证了多个事务并发执行的“可串行化”。 活锁与死锁\n活锁：活锁的处理方案：先来先服务 死锁：活锁的预防方案\n一次性锁请求\n每一事务在处理时一次提出所有的锁请求，仅当这些请求全部满足时事务处理才进行否则让其等待，这样则不会出现死锁的情况。这种方法实现简单，但因系统的并行性降低事务处理的等待时间加长，所以系统性能将下降 锁请求排序\n将每个数据单元标以线性顺序，然后要求每一事务都按此顺序提出锁请求。这种方法也能防止死锁发生，但同样会降低系统的并行性 序列化处理\n通过应用设计为每一数据单元建立一个“主人”程序，对给定数据单元的所有请求都发送给“主人”，而“主人”以单道的形式运行。这样系统可以是多道运行，但由于任何两道都不请求相同的数据单元，因而可避免死锁发生，但系统性能、数据的完整性可能受到影响。 资源剥夺\n每当事务因锁请求不能满足而受阻时，强行令两个冲突的事务中的一个 ROLLBACK 释放所有的锁，以后再重新运行。使用这个方法必须注意防止活锁的发生 对待死锁的另一种办法是不去防止，而让其发生并随时进行检测，一旦检测到系统已发生了死锁再进行解除处理。死锁检测可以用图论的方法实现，并以正在执行的事务为结点\n可串行性\n一组事务的一个调度就是它们的基本操作的一种排序。若在一个调度中，对于任意两个事务 T1 和 T2 ，要么 T1 的所有操作都在 T2 所有操作之前，要么反之，则该调度是串行的，因而是正确的。\n若一个调度等价于某一串行高度，即它所产生的结果与某一串行调度的结果样，则说调度是可串行化的（ Serializable）。 其中，需要指出的是：“可串行化的”不是调度本身“已串行化了”，只是其结果与某个串行调度一样；另外，一组事务的串行调度不是唯一的，因而可串行化的调度也不是唯一的。 通常，在数据库系统中，可串行性就是并发执行的正确性准则，即当且仅当一组事务的并发执行调度是可串行化的，才认为它们是正确的\n两段封锁法（Two- Phase Locking，2PL） 两段封锁法是一种最简单而有效的保障封锁其调度是可串行性的方法。\n发展（ Growing）或加锁阶段 在此段期间，对任一数据对象进行任何操作之前，事务都要获得对该对象的一个相应的锁 收缩（ Shrinking）或释放锁阶段 一旦事务释放了一个锁，则标明它已进入了此阶段，此后它就不能再请求任何另外的锁。 此外，关于两段锁协议有如下定理成立\n定理 6.1：遵循两段锁协议的事务的任何并发调度都是可串行化的。 依据此定理，所有遵循 2PL 事务的任何并发执行的结果都是一致性的。需要指出的是，2PL是可串行化的充分条件，不是必要条件，即存在不全是2PL的事务的可串行化调度\n第五章 备份与恢复 数据备份是指通过导出数据或复制表文件的方式来制作数据库 的副本。 数据库恢复则是当数据库出现故障或遭到破坏时，将备份的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。数据库的恢复是以备份为基础的，它是与备份相对应的系统维护和管理操作。\n数据丢失 计算机硬件故障。 计算机软件故障。 病毒。 人为误操作。 自然灾害。 盗窃。 MySQL 中使用 SQL 语句备份与恢复数据库中表数据的方法，这种方法有一点不足，就是只能导出或导入数据的内容，而不包括表的结构 使用 select INTO… OUTFILE 语句备份数据\n1 2 select * into OUTFILE \u0026#39;file_name\u0026#39; export_option |into DUMPFILE \u0026#39;file_name\u0026#39; 语法项“ export options”的格式是：\n1 2 3 4 5 6 [FIELDS [TERMINATED by \u0026#39;string\u0026#39;] [[OPTIONALLY]ENCLOSED by \u0026#39;char\u0026#39;] [ESCAPED by \u0026#39;char\u0026#39;] ] [LINES TERMNIATED by \u0026#39;string\u0026#39;] 语法项\u0026quot; file name\u0026ldquo;指定数据备份文件的名称。 文件默认在服务器主机上创建，并且文件名不能是已经存在的，否则可能会将原文件覆盖。 如果要将该文件写入到一个特定的位置，则要在文件名前加上具体的路径。在文件中，导出的数据行会以一定的形式存储，其中空值是用\u0026quot;N\u0026quot;表示。 导出语句中使用关键字\u0026rdquo; OUTFILE\u0026ldquo;时，可以在语法项\u0026rdquo; export options\u0026ldquo;中加入以下两个自选的子句，即 FIELDS子句和LINES子句，它们的作用是决定数据行在备份文件中存储的格式。 如果 FIELDS和 LINES子句都不指定，则默认声明的是子句\u0026rdquo; FIELDS TERMINATED by '\\t' ENCLOSED by '' ESCAPED by '\\\\' LINES TERMINATED by '\\n' 语法项\u0026quot; FIELDS子句\u0026quot;中有三个亚子句，分别是\u0026quot; TERMINATED by子句” “[OPTIONALLY] ENCLOSED by子句\u0026quot; 和 \u0026quot; ESCAPED by子句\u0026quot;。 如果指定了 FIELDS子句，则这三个亚子句中至少要求指定一个。 其中， TERMINATED by子句用来指定字段值之间的符号，例如\u0026quot; TERMINATED by ','\u0026ldquo;指定逗号作为两个字段值之间的标志； ENCLOSED by子句用来指定包裹文件中字符值的符号，例如\u0026rdquo; ENCLOSED by '\u0026quot;'\u0026ldquo;表示文件中字符值放在双引号之间，若加上关键字\u0026rdquo; OPTIONALLY\u0026ldquo;则表示所有的值都放在双引号之间； ESCAPED by子句用来指定转义字符，例如\u0026rdquo; ESCAPED by '*'\u0026ldquo;将\u0026rdquo;*\u0026ldquo;指定为转义字符，取代\u0026quot;\\\u0026quot;，如空格将表示为\u0026rdquo;*N\u0026quot;。 在 LNES 子句中使用关键字\u0026quot; TERMINATED by\u0026ldquo;指定一个数据行结束的标志，如 \u0026quot; LINES TERMINATED by '?'表示一个数据行以\u0026rdquo;?\u0026ldquo;作为结束标志 导出语句中使用的是关键字\u0026rdquo; DUMPFILE\u0026quot;，而非\u0026quot; OUTFILE\u0026ldquo;时，导出的备份文件里面所有的数据行都会彼此紧挨着放置，即值和行之间没有任何标记。 使用 LOAD DATA… INFILE 语句恢复数据\n1 2 3 4 5 6 7 8 9 10 11 LOAD DATA INFILE \u0026#39;file_name.txt\u0026#39; into table tbl_name [FIELDS [TERMINATED by \u0026#39;string\u0026#39;] [[OPTIONALLY]ENCLOSED by \u0026#39;char\u0026#39;] [ESCAPED by \u0026#39;char\u0026#39;] ] [LINES [STARTING by \u0026#39;string\u0026#39;] [TERMINATED by \u0026#39;string\u0026#39;] ] 语法项“ file name”指定待导入的数据库备份文件名，文件中保存了待载入数据库的所有数据行。 输入文件可以手动创建，也可以使用其他的程序创建。 导入文件时可以指定文件的绝对路径，则服务器会根据该路径搜索文件；若不指定路径，则服务器在默认数据库的数据库目录中读取。 语法项“ tb name”指定需要导入数据的表名，该表在数据库中必须存在，表结构必须与导入文件的数据行一致。 此处的 FIELDS子句和 SELECT… .into OUTFILE语句中的 FIELDS子句类似，用于判断字段之间和数据行之间的符号。 语法项“LNES子句”中的 TERMINATED by亚子句用来指定一行结束的标志STARTING by亚子句则指定一个前缀，导入数据行时，忽略数据行中的该前缀和前缀之前的内容。如果某行不包括该前缀，则整个数据行被跳过。 例 6.17 备份数据库 test_db中表 customers的全部数据到 C 盘的 BACKUP 目录下个名为 backupfile. txt的文件中，要求字段值如果是字符则用双引号标注，字段值之间用逗号隔开，每行以问号为结束标志。然后，将备份后的数据导入到一个和 customers表结构相同的空表 customers copy中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 select*from test_db.customers into OUTFILE \u0026#39;D:/BACKUP/backupfile.txt\u0026#39; FIELDS TERMINATED by \u0026#39;,\u0026#39; OPTIONALLY ENCLOSED by \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED by \u0026#39;?\u0026#39;; select *from test_db.customers; select *from test_db.customers_copy; alter table test_db.customers drop column cust_city; create table customers_copy ( cust_id INT not null AUTO_INCREMENT, cust_name char(50) not null, cust_sex char(1) not null default 0, cust_address char(50) null, cust_contact char(50) null, primary key(cust_id) ); LOAD DATA INFILE \u0026#39;D:/BACKUP/backupfile.txt\u0026#39; into table test_db.customers_copy FIELDS TERMINATED by \u0026#39;,\u0026#39; OPTIONALLY ENCLOSED by \u0026#39;\u0026#34;\u0026#39; LINES TERMINATED by \u0026#39;?\u0026#39;; 在导入数据时需要特别注意，必须根据数据备份文件中数据行的格式来指定判断的符号。例如，在 backupfile. txt文件中字段值是以逗号隔开的，导入数据时就一定要使用TERMINATED BY；”子句指定逗号为字段值之间的分隔符，即与 SELECT…INTo OUTFILE语句相对应\nError Code] 1290 - The MySQL server is running with the \u0026ndash;secure-file-priv option 解决办法\n1.进入 mysql 查看 secure_file_prive 的值\n$mysql -u root -p\nmysql\u0026gt;show VARIABLES like \u0026ldquo;secure_file_priv\u0026rdquo;;\nsecure_file_prive=null \u0026ndash; 限制 mysqld 不允许导入导出\nsecure_file_priv=/tmp/ \u0026ndash; 限制 mysqld 的导入导出只能发生在/tmp/目录下\nsecure_file_priv=\u0026rsquo; \u0026rsquo; \u0026ndash; 不对 mysqld 的导入 导出做限制\n2.更改 secure_file_pri 的值\n找到 my.ini 配置文件，加入在 mysqld 目录下，secure_file_priv=\u0026rsquo;\u0026rsquo;，重启 mysql 服务器即可。\n另外需要注意的是，在多个用户同时使用 MySQL 数据库的情况下，为了得到一个一致的备份，需要在指定的表上使用 LOCK tables table name READ语句做一个读锁定，以防止在备份过程中表被其他用户更新；而当恢复数据时，则需要使用 LOCK tables table name WritE语句做一个写锁定，以避免发生数据冲突。在数据库备份或恢复完毕之后需要使用 UNLOCK tables语句对该表进行解锁。\n第七章 数据库应用设计与开发实例 第一节 需求描述与分析 结合某高校个性化课程在线选课的实际需求，给出一个简化的需求分析。 经过调研，得知选课系统的用户类型有教务管理员、学生和教师 7.1.1 功能性需求 管理员后台模块\n管理员后台是专门为教务管理员使用的，主要用于系统的数据管理，包括学生管理、教师管理、班级管理和课程管理，其具体的功能需求如下。\n学生信息管理用于对学生进行管理。 例如，若有学生信息发生变化时，管理员可及时补充或更正学生信息 教师信息管理用于对教师进行管理。 例如，当教师出现工作部门调动或职称变动等情况时，教务管理员需要及时修正教师信息。 课程信息管理用于管理个性化课程。 每一门个性化课程的信息都会在此模块中显示，如果遇到课程安排发生变动时，则要求管理员及时更正课程信息，以方便学生选课 班级信息管理用于对班级进行管理。 从建立一个班级开始，其信息已经基本固定下来，唯一有可能变化的就是班级人数。当有一名新学生加入班级时，学生人数自动加 1；相反，当有一名学生转专业、留级、休学或退学时，班级人数自动减 1。 学生使用模块\n学生是使用个性课程选课系统的主体，学生使用学号和初始密码登录，在主页可以浏览到所有的课程信息并进行选课。学生使用模块包含三个功能，具体功能需求如下。\n查询课程根据学生输入的检索条件和值，模糊查询满足条件的课程。 浏览所选课程显示该学生选的所有课程。 查询成绩学生可以査看本人所选课程的最终成绩。 教师使用模块\n此模块主要完成教师登分和查询本人开设课程的操作。教师使用工号和初始密码登录系统，在教师主页可以査看所有的课程。教师使用模块有两个功能，其功能需求如下。\n我的课程负责显示教师本人开设的所有课程。 登分通过此功能，每位教师可以为所有的选择自己开设课程的学生录入分数到本系统中，以供学生查询和教务管理员统计分数。 7.1.2 非功能性需求 作为一个基于网络的在线选课系统，本系统采用浏览器/服务器（BS）结构，即一种基于 Web 应用的客户服务器结构，因而对于客户端和服务器端，分别有不同的软、硬件环境需求。客户端要能在支持 IE 的浏览器上运行，并在客户机上安装了网卡；服务器要求部署 WAMP 环境，即使用 Windows 作为操作系统， Apache 作为 Web 服务器， MySQL 作为数据库管理系统，PHP 语言作为服务器端脚本解释器，同时要求具有 8GB 内存、2TB 磁盘容量、千兆带宽。\n此外，还需要考虑质量要求。有关选课系统质量需求描述如 表 7.1 所示\n第二节 系统设计 7.2.1 功能模块设计 登录验证模块\n此模块用于用户登录系统，只有当用户的身份信息被检验成功后，才可以进入系统，否则要重新登录。 管理员后台模块\n此模块有学生信息管理、教师信息管理、课程信息管理、班级信息管理的功能，主要用于教务管理员对系统数据的日常维护，向学生和教师提供数据支撑，如 图 7.2 所示。 学生使用模块\n学生模块可以査询课程、浏览已选课程、查询成绩和选/退课程，如 图 7.3 所示。 此模块主要用于学生自主选课，学生单击下拉菜单并选择课程类别、学分、教师、上课时间、上课地点、课程编号、课程名称等检索项并输入关键字来査询课程。例如，单击系统主页的课程编码可以査看课程细节并进行选课，如果想退选，则进入浏览已选课程模块单击课程编码进行退选，且当考试结束后，可查询成绩。\n教师使用模块\n如 图 7.4 所示，教师可以在所有课程中浏览到自己的课程，并能知道每门课程的上课时间和上课地点等相关课程信息。此模块还用于教师给学生登分，教师进入登分模块单击下拉菜单中的某门课程，依次把所有学生的分数输入到系统中，以便学生可以查询成绩 7.2.2 数据库设计 根据系统的功能模块设计结果，以及前期的需求分析，可首先明确本系统的数据库范围，然后可通过使用 ER 图作为数据库概念设计的描述工具，建立本系统所涉及的局部信息结构，再将各个局部信息结构合并成为一个优化的全局信息结构，最后将全局信息结构的 E R 图转换为关系模型，并依据关系数据库规范化理论进行优化。 确定实体\n学生实体 用于描述学生的基本信息，包括学号、姓名、性别、密码等信息。\n教师实体 用于描述教师的基本信息，包括教师工号、姓名、性别、年龄、职称、密码等信息\n课程实体 用于描述课程的基本信息，包括课程号、课程名、学分、时间、地点、类别、开课学院、限选人数等信息。\n院系实体 用于描述院系的基本信息，包括院系名称、办公地点、教师人数等信息。\n系统管理员实体 用于描述系统管理员的基本信息，包括姓名、ID 号、密码等信息\n需要注意的是：在数据库设计时，实体的描述信息可根据实际需求进行增加或删减，如果实体的属性较多，在构建 ER 模型时不一定需要把所有的属性都标识在 ER 模型上，可以另外用文字说明，这样也使得 ER 模型简明清晰，便于分析。\n局部信息结构\n学生课程 ER 图如 图 7.5 所示，其描述了学生实体与课程实体之间的联系。其中，学生实体与课程实体之间的联系命名为“选修”，它是一个多对多的联系（M:N），即每个生可以选修多门个性化课程，同时每门个性化课程也可以被多名学生所选修。\n教师课程 ER 图如 图 7.6 所示，其描述了教师实体与课程实体之间的联系。其中教师实体与课程实体之间的联系命名为“授课”，它是一个一对多的联系（1:N），即每位教师可以教授多门个性化课程，但每门个性化课程只能由一名教师来教授。\n教师-院系 E-R 图如 图 7.7 所示，其描述了教师实体与院系实体之间的联系。其中，院系实体与教师实体之间的联系命名为“属于”，它是一个一对多的联系（1:N），即每个院系可以拥有多位教师，但每位教师只能在一个院系里任职。\n学生院系 ER 图如图 7.8 所示，其描述了学生实体与院系实体之间的联系。其中院系实体与学生实体之间的联系命名为“属于”，它是一个一对多的联系（1:N），即每个院系可以包含多名学生，但每名学生只能在一个院系里就读。\n系统管理员学生 E-R 图如 图 7.9 所示，其描述了系统管理员实体与学生实体之间的联系。其中，系统管理员实体与学生实体之间的联系命名为“管理”，它是一个多对多的联系（M:N），即每个系统管理员可以管理多名学生的信息，同时每名学生的信息可以被多个系统管理员管理。\n系统管理员-教师 ER 图如 图 7.10 所示，其描述了系统管理员实体与教师实体之间的联系。其中，系统管理员实体与教师实体之间的联系命名为“管理”，它是一个多对多的联系（M:N），即每个系统管理员可以管理多位教师的信息，同时每位教师的信息可以被多个系统管理员管理。\n系统管理员-课程 E-R 图如 图 7.11 所示，其描述了系统管理员实体与课程实体之间的联系。其中，系统管理员实体与课程实体之间的联系命名为“管理”，它是一个多对多的联系（M:N），即每个系统管理员可以管理多门课程的信息，同时每门课程的信息可以被多个系统管理员管理\n系统管理员-院系 ER 图如 图 7.12 所示，其描述了系统管理员实体与院系实体之间的联系。其中，系统管理员实体与院系实体之间的联系命名为“管理”，它是一个多对多的联系（M:N），即每个系统管理员可以管理多个院系的信息，同时每个院系的信息可以被多个系统管理员管理。\n全局信息结构\n在构建出上述局部信息结构的基础上，通过采用逐步合并、进行累加的方式，以及消除可能存在的属性冲突、命名冲突和结构冲突，最终形成一个本系统的全局信息结构。\n首先将学生课程 ER 图、教师-课程 E-R 图、教师-院系 ER 图、学生-院系 ER 图合并成为一个较大的局部信息结构，即学生-教师-课程-院系 E-R 图，用于描述学生、教师、课程及院系四个实体之间的联系，如图 713 所示。其中，在教师院系 ER 图和学生院系 ER 图中均有同名的联系“属于”，但其实质内容是不同的，因而在合并这两个 ER 图时，应当为这两个同名的联系重新命名，分别是：“任职”和“从属”\n同样，再将系统管理员-学生 ER 图、系统管理员-教师 E-R 图、系统管理员-课程 E-R 图、系统管理员-院系 ER 图合并成为另一个较大的局部信息结构，即系统管理员学生-教师课程-院系 ER 图，用于描述系统管理员实体与学生、教师、课程及院系四个实体之间的联系，如图 7.14 所示。其中，在系统管理员学生 ER 图、系统管理员-教师 ER 图、系统管理员-课程 ER 图、系统管理员-院系 ER 图中均有同名的联系“管理”，但其实质内容是不同的，因而在合并这 4 个 ER 图时，应当为这 4 个同名的联系重新命名，分别是：“管理学生”“管理教师”“管理课程”“管理院系”\n最后，将学生-教师-课程院系 ER 图和系统管理员-学生-教师课程-院系 ER 图合并成为一个本系统的全局 ER 图，如 图 7.15 所示。\n逻辑结构与规范化设计\n形成本系统的全局 ER 模型之后，即可开展关系数据库的逻辑结构设计了，也就是设计本数据库应用软件的基本关系模式。根据第三章介绍的 ER 图向关系模型转换的原则，可将图 7.15 所示的全局 ER 图转换为如下一些关系模式，其中主码用下划线标识。 学生（学号、姓名、性别、登录密码、院系编号） 院系（院系编号、系名、学生人数、教师人数、办公地点） 教师（职工号、姓名、性别、年龄、职称、登录密码、院系编号） 课程（课程号、课程名称、课程类别、学分、上课时间、上课地点、开课学院、限选人数、职工号） 系统管理员（ID 号、姓名、登录密码） 选修（学号、课程号、成绩） 管理学生（管理员 ID 号、学号、操作时间） 管理院系（管理员 ID 号、院系编号、操作时间） 管理教师（管理员 ID 号、职工号、操作时间） 管理课程（管理员 ID 号、课程号、操作时间） 由此可见，上述转换是 将全局 ER 图中的 5 个实体直接转换成了 5 个对应的关系模式即“学生”“院系”“教师”“课程”和“系统管理员”； 而后将全局 E-R 图中 3 个一对多（1：N）联系分别与对应的关系模式进行了合并，即“学生”“教师”“课程”； 最后是将全局 ER 图中 5 个多对多（MN）联系分别转换成 5 个独立的关系模式，且各关系的码分别是各自联系两端的实体码的组合。 在将 ER 图转换为关系模式之后，还需要进一步分析各关系模式是否符合第三范式的要求。如若不符合，则通常需要将这些关系模式分解为符合第三范式要求的关系模式，从而实现数据库的规范化设计。 由此，根据第二章介绍的关系规范化理论，经分析发现： 在上述这些关系模式中，“学生”“教师”“系统管理员”“选修”“管理学生”“管理院系”“管理教师”“管理课程”等 8 个关系模式既不存在部分函数依赖，也不存在传递函数依赖，满足第三范式要求； 而“院系”尽管不存在部分函数依赖，满足第二范式要求，但存在着传递函数依赖，故需要进一步分解，以满足第三范式的要求，其可分解成关系模式“院系编码（院系编号、系名）”和关系模式“院系（院系编号、学生人数、教师人数、办公地点）”； 同样，“课程”也是尽管不存在部分函数依赖，满足第二范式要求，但存在着传递函数依赖，需要进一步分解，以满足第三范式的要求，其可分解成关系模式“课程编码（课程号、课程名称）”和关系模式“课程（课程号、课程类别、学分、上课时间、上课地点、开课学院、限选人数、职工号）”。 第三节 系统实现 按照数据库应用软件开发步骤的划分，在完成系统的数据库设计和功能设计之后，就可以采用相应的数据库管理系统和应用软件开发语言，分别实现系统的数据库和业务功能，即数据库实现和系统功能实现。这里，数据库实现是基于 MSQL 数据库来完成，系统的业务功能是采用 PP 语言来开发（关于使用 PHP 语言开发数据库应用的有关知识，读者可自行参阅本书附录 2）。 数据库的实现\n1 create database db_xuanke; 然后，根据本应用数据库逻辑结构设计所得出的关系模式，通过使用 MySQL 数据库的 create table 命名，在数据库 db xuanke 中创建 12 张数据表，并建立各表的主键，从而构成主键索引。\n这些表的结构定义分别如表 7.2-7.13 所示。 系统功能的实现\n实现数据库行为实现数据库行为是实现数据库行为设计的结果，主要是通过 SQL 语言完成与本应用功能相关的增、删、改、查等数据库操作，也包括为提髙数据库操作效率或保护数据库安全而创建的各种数据库对象，例如子査询、视图、触发器、存储过程或存储函数等。\n安全控制\n例如，为新来的教务管理人员金老师（用户名 jin）分配具备管理学生、院系、教师和课程的权限，可在数据库中编写如下 SQL 语句实现：\n1 2 3 grant select,update,insert,delete on db_xuanke.* TO \u0026#39;jin\u0026#39;@\u0026#39;localhost\u0026#39; 管理学生。 例如，教务管理人员金老师需要在学生管理功能中添加一名计算机学院的女生黄然同学时，可在数据库中编写如下 SQL 语句实现\n1 2 3 insert into db_xuanke.student set StuNo=20170922,StuName=\u0026#39;黄然\u0026#39;,StuSex=\u0026#39;女\u0026#39;,Pwd=default,DeptNo= select DeptNo from db_xuanke.deptcode where DeptName=\u0026#39;计算机学院\u0026#39;; 数据库保护。 例如，当每位教师进行登分操作时，系统需要根据教师所登分数值进行自动验证，判断该分数值是否位于 0~100 分区间，以此保护数据库中数据的正确性，因而可在数据库中编写如下 SQL 语句实现：\n1 2 3 4 5 6 create TRIGGER tri_test after insert on db_xuanke.electing FOR EACH ROW BEGIN if NEW.Score\u0026lt;0 and NEW.Score\u0026gt;100 then delete from db_xuanke.electing where Score=NEW.Score END if END; 事务与并发控制。 例如，教务管理人员金老师需要批量录入教师信息时，为防止其他操作对数据的影响可通过使用事务处理来维护数据库的完整性，因而可在数据库中编写如下 SQL 语句实现：\n1 2 3 4 5 BEGIN; #开始事务 insert into db_xuanke.teacher values(10021,\u0026#39;万明\u0026#39;,null,null,null,default,10); insert into db_xuanke.teacher values(10073,\u0026#39;黄新\u0026#39;,null,null,null,default,10); insert into db_xuanke.teacher values(11031,\u0026#39;徐丽\u0026#39;,null,null,null,default,11); COMMIT; #提交事务 数据查询与统计报表。 在数据库应用系统中，数据查询是最常用的功能，其应根据用户提出的查询条件实现相应的查询功能。其中，生成统计报表是很多数据库应用软件所提供的一个功能。例如，在本选课系统中，可以为教务管理人员提供统计每个学生选修课程总学分的报表，因而这个用户需求可以通过使用 SQL 语句定义如下视图来实现\n1 2 3 4 5 6 7 create VIEW v_score(StuNo,totlescore) as select student.Student.StuNo,SUM(course.Credit) from student JOIN electing on student.StuNo=electing.StuNo JOIN course on course.CourseNo=electing.CourseNo where electing.Scoure\u0026gt;=60 group by student.StuNo; 实现应用软件的业务逻辑\n这一阶段的开发工作主要是根据系统功能设计的结果，分别逐个实现各个功能模块。其中，各模块与底层数据库的交互操作，是通过应用软件的编程语言（如 PHP）进行封装的。 这里，以本系统的登录验证模块为例，简单描述其实现过程。 首先，使用网页设计语言 HTML/CSS 实现如 图 716 所示的系统登录验证页面 然后，通过使用 PHP 编程语言编写相应的服务器端代码，完成此登录验证页面与后台数据库的交互操作，具体包括建立与 MSQL 数据库服务器的连接，査询数据库表 student、 teacher administrator I 中是否存在通过登录验证页面表单采用 POST 方式传递到后台服务器的数据。 最后，后台服务器根据在数据库中进行查询操作的返回结果，向网络页面请求用户做出相应的反馈，即若查询操作返回存在数据的结果集，则用户正常登录系统，否则用户无法登录系统。 第四节 系统测试与维护 完成系统的实现工作之后，在正式交付用户使用之前，需要对所开发的系统进行必要的测试，验证其是否满足用户的功能要求，并根据测试的结果，以及用户的反馈意见，对该系统进行进一步的修改、完善和维护工作。例如，在本系统中，可以分别针对不同的功能模块制定相应的测试方案 登录验证功能测试\n管理员后台主要功能测试\n学生信息管理功能\n课程信息管理功能\n学生使用模块功能测试\n教师使用模块功能测试\n本章小结 第八章 数据管理技术的发展 第一节 数据库技术发展概述 数据模型是数据库系统的核心和基础。以数据模型的发展为主线，数据库技术可以相应地分为三个发展阶段，即第一代的网状、层次数据库系统，第二代的关系数据库系统，以及新一代的数据库系统 8.1.1 第一代数据库系统 第一代数据库系统有如下两类代表。 1969 年 IBM 公司研制的层次模型数据库管理系统 IMS 美国数据库系统语言研究会（ CODASYL）下属的数据库任务组（DBTG）对数据库方法进行了系统的研究和探讨，于 20 世纪 60 年代末 70 年代初提出了若干报告，称为 DBTG 报告。DBTG 报告确定并建立了数据库系统的许多概念、方法和技术。DBTG 所提议的方法是基于网状结构的，是网状模型数据库系统的典型代表。 这两类数据库系统具有以下几个共同特点。 支持三级模式（外模式、模式、内模式）的体系结构。 模式之间具有转换（或称为映射）功能。 用存取路径来表示数据之间的联系。 这是数据库系统和文件系统的主要区别之数据库不仅存储数据，而且存储数据之间的联系。数据之间的联系在层次和网状数据库系统中都是用存取路径来表示和实现的。 独立的数据定义语言。 层次数据库系统和网状数据库系统有独立的数据定义语言，用以描述数据库的三级模式以及相互映像。诸模式一经定义，就很难修改。 导航的数据操纵语言。 层次和网状数据库的数据查询和数据操纵语言是一次一个记录的导航式的过程化语言。这类语言通常嵌入某一种高级语言，例如 COBOL、 FORTRAN、C 语言中。 8.1.2 第二代数据库系统 （20世纪70年代，称为数据库时代） 把 20 世纪 70 年代称为数据库时代。20 世纪 80 年代几乎所有新开发的 DBMS 均是关系数据库系统。 关系数据库是以关系模型为基础的，而关系模型是由数据结构、关系操作和数据完整性三部分组成。 关系模型不仅简单、清晰，而且由关系代数作为语言模型，由关系数据理论作为理论基础。 因此，第二代关系数据库系统具有模型简单清晰、理论基础好、数据独立性强、数据库语言非过程化和标准化等特点。\n8.1.3 第三代数据库系统 第三代数据库系统应支持数据管理、对象管理和知识管理，除提供传统的数据管理服务外，第三代数据库系统将支持更加丰富的对象结构和规则，应该集数据管理、对象管理和知识管理为一体。《宣言》认为，无论该数据库系统支持何种复杂的、非传统的数据模型，它应该具有面向对象模型的基本特征。数据模型是划分数据库发展阶段的基本依据。因此，第三代数据库系统应该是以支持面向对象数据模型为主要特征的数据库系统。但是，只支持面向对象模型的系统不能称为第三代数据库系统。第三代数据库系统还应具备其他特征。\n第三代数据库系统必须保持或继承第二代数据库系统的技术，第三代数据库系统必须保持第二代数据库系统的非过程化数据存取方式和数据独立性应继承第二代数据库系统已有的技术。不仅能很好地支持对象管理和规则管理，而且能更好地支持原有的数据管理，支持多数用户需要的即席查询等。\n第三代数据库系统必须对其他系统开放数据库系统的开放性，表现在：支持数据库语言标准；在网络上支持标准网络协议；系统具有良好的可移植性、可连接性、可扩展性和互操作性等。这些新的数据库系统支持不同的数据模型，有扩展关系数据模型的对象关系数据库系统、面向对象模型的对象数据库系统、支持XML半结构化模型的XML数据库系统等。\n既然对于第三代数据库系统并没有形成一致的认识，因而通常把第二代以后的数据库系统称为新一代数据库系统。新一代数据库系统将是以更加丰富的数据模型和更强大的数据管理功能为特征，从而满足广泛更加复杂的新应用的要求。\n数据库技术与其他计算机技术相结合是数据库技术发展的一个显著特征。\n与分布式处理技术结合出现的分布式数据库系统 与并行处理技术相结合出现的并行数据库系统 与人工智能技术相结合出现的演绎数据库、知识和主动数据库系统等 与模糊技术想结合出现的模糊数据库系统 与Web技术相结合出现的Web数据库 第二节 数据仓库与数据挖掘 8.2.1 从数据库到数据仓库 数据库与数据仓库只有一字之差，似乎是一样的概念，但实际则不然。\n计算机系统中存在着两类不同的数据处理工作：\n一类是操作型处理，也称为联机事务处理（ Online Transaction Processing, OLTP），它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询和修改，用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题，传统的数据库系统作为数据管理的主要手段，主要用于操作型处理；\n另类是分析型处理，也称为联机分析处理（ Online Analytical Processing, OLAP），一般针对某些主题的历史数据进行分析，支持管理决策，它通常是对海量的历史数据查询和分析，如金融风险预测预警系统、证券股市违规分析系统等，这些系统要访问的数据量非常大，查询和分析的操作十分复杂。\n事务型处理数据和分析型处理数据的区别可如 表 8.1 所示。\nDTP 和 OLAP 两者之间的差异使得传统的数据库技术不能同时满足两类数据的处理要求，因此在 20 世纪 80 年代数据仓库（ Data Warehouse,pw）技术应运而生。数据仓库的建立将操作型处理和分析型处理区分开来。传统的数据库技术为操作型处理服务，数据仓库为分析型处理服务。二者各司其职，泾渭分明。越来越多的组织或企业认识到数据仓库的重要性，逐步在原有数据库基础上建立起自己的数据仓库系统 数据仓库是面向主题的、集成的、稳定的、随时间变化的数据集合，用以支持管理决策的过程。 数据仓库不是可以买到的产品，而是一种面向分析的数据存储方案。对于数据仓库的概念，可以从两个层次进行理解：首先，数据仓库用于支持决策，面向分析型数据处理，不同于提高业务效率的操作型数据库；其次，数据仓库对分布在组织或企业中的多个异构数据源集成，按照决策主题选择数据并以新的数据模型存储。此外，存储在数据仓库中的数据一般不能修改。相应地，数据仓库主要有以下特征。\n面向主题：数据仓库中的数据是按照各种主题来组织的。主题在数据仓库中的物理实现是一系列的相关表，这不同于面向应用环境。例如，保险公司按照应用组织可能是汽车保险、生命保险、伤亡保险，而数据仓库是按照客户、政策、保险金和索赔来组织数据。面向主题的数据组织方式可在较高层次上对分析对象的数据给出完整、一致的描述，能完整、统一地刻画各个分析对象所涉及的各项数据以及数据之间的联系，从而适应组织或企业各个部门的业务活动特点和数据的动态特征，从根本上实现数据与应用的分离。 集成性：数据仓库中的数据是从原有分散的源数据库中提取出来的，其每一个主题所对应的源数据在原有的数据库中有许多冗余和不一致，且与不同的应用逻辑相关。为了创建一个有效的主题域，必须将这些来自不同数据源的数据集成起来，使之遵循统一的编码规则 数据的非易失性：数据的非易失性主要是针对应用而言的。数据仓库的用户对数据的操作大多是数据查询或比较复杂的挖掘，一旦数据进入数据仓库以后，一般情况下都被较长时间的保留。数据仓库中一般有大量的查询操作，但修改和删除操作较少。因此，数据经加工和集成进入数据仓库后是极少更新的，通常只需要定期加载和更新。 数据的时变性：许多商业分析要求对发展趋势做出预测，对发展趋势的分析需要访问历史数据。因此数据仓库必须不断捕捉 OLTP 数据库中变化的数据，生成数据库的快照，经集成后增加到数据仓库中去：另外数据仓库还需要随时间的变化删去过期的、对分析没有帮助的数据，并且还需要按规定的时间段增加综合数据。 数据仓库具有三个常用的重要概念，即粒度、分割和维。\n粒度是指数据仓库的数据单位中保存数据的细化或综合程度的级别，细化程度越高，粒度级就越小，相反地，细化程度越低，粒度级就越大。 数据的粒度一直是一个设计问题。在早期建立的操作型系统中，粒度是用于访问授权的，当详细的数据被更新时，几乎总是把它存储在最低粒度级上。但在数据仓库环境中对粒度不做假设。在数据仓库环境中粒度之所以是主要的设计问题，是因为它深深地影响存储在数据仓库中的数据量的大小，同时影响数据仓库所能回答的查询类型。在数据仓库中的数据量大小与查询的详细程度之间要做出权衡。 分割是将数据分散到各自的物理单元中，以便能分别处理，以提高数据处理的效率。数据分割后的单元称为切片。数据分割的标准可以根据实际情况来确定，通常可按日期、地理分布、业务范围等进行分割，数据分割后较小单元的数据处理相对独立，使数据更易于重构、索引、恢复和监控，处理起来更快。 维是人们观察数据的特定角度，是考虑问题时的一类属性。此类属性的集合构成一个维度，例如时间维、产品维等。维可以有细节程度的不同描述方面，这些不同描述方面称为维的层次，维层次中维的一个取值称为维的一个成员，不同的多个维成员的组合组成了该维的不同维层次。最常用的维是时间维，时间维的维层次可以有日、周、月、季、年等。数据仓库中的数据按照不同的维组织起来形成了一个多维立方体。维的概念使用户能够从多个角度观察数据仓库中的数据，以便深入了解包含在数据中的信息。 此外，数据仓库有时也称为企业仓库。企业数据仓库可以在大型机、超级计算机服务器或并行结构平台上实现，但建设数据仓库是一项庞大的系统工程，需要广泛业务建模，其工作量大、代价和风险很高。为此，人们提出了数据集市（ Data Mart）体系结构的数据仓库概念。数据集市的基本思想是自下而上的数据仓库的开发方法。数据集市结构的数据仓库，又称为主题结构数据仓库，是按照主题进行构思所形成的数据仓库。数据集市结构一般只能对某个主题进行操作，如果用户希望对两个以上的主题进行操作，则必须对这两主题的数据结构都了解，否则无法实现多主题的操作，而多主题的数据仓库结构往往会产生大量的冗余。一般可以将数据集市分为独立的数据集市（ Independent Data Mart）和从属的数据集市（ Dependent Data Ma）或这两种数据集市的混合。\n8.2.2 数据挖掘技术 数据挖掘（ Data Mining）是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中发现并提取隐藏在其中的、人们事先不知道的、但又是潜在有用的信息和知识的一种技术。它又被称为数据库中的知识发现（ Knowledge Discovery in DataBase,KDD），其与数据库、数理统计、机器学习、模式识别、模糊数学等诸多技术相关。\nOLAP 是数据汇总/聚集工具，可帮助简化数据分析，OLAP 工具的目标是简化和支持交互式数据分析。\n数据挖掘是自动地发现隐藏在大量数据中的隐含模式和有趣知识，而数据挖掘工具的目标是尽可能自动处理。\n数据挖掘具备下列几种功能。\n概念描述：归纳总结出数据的某些特征。 关联分析：目的是找出数据库中数据项之间的相关性。关联规则表示了数据库中一组数据项间的相关性。关联可分为简单关联、时序关联、因果关联。常见的关联分析算法有 Apriori、FP growth 等。 分类与预测 ：分类是利用训练数据集通过一定的算法而求得分类规则，被用于规则描述和预测。根据不同类对象特征的描述可以得出辅助决策信息。常见的分类模型及算法有决策树模型、神经网络模型、线性回归模型等。 聚类：是把数据按照相似性归纳成若千类别。同一类中的数据彼此相似，不同类中的数据相异。聚类分析可以建立宏观的概念，发现数据的分布模式，以及可能的数据属性之间的相互关系。聚类的目的是使属于同一类别的对象之间的距离尽可能小，而不同类别的对象间的距离尽可能大。与分类方法不同的是，聚类没有预先的分类特征，而是根据一定的规则将对象归类，对分类后的对象类显式或隐式地描述其共同特征。常用的聚类算法有 K-Means、 GMM 等 孤立点检测：孤立点是指数据中与整体表现行为不一致的数据集合。这些数据虽然是一些特例，但往往在错误检查和特例分析中是非常有用的。 趋势和演变分析：可以描述行为随着时间变化的对象所遵循的规律或趋势 在实际使用中，数据挖掘的过程通常由以下六个步骤构成。\n确定业务对象。将用户需求和目标转换成一种数据挖掘的问题定义，设计出达到目标的一个初步计划。认清数据挖掘的目的是数据挖掘的重要一步，挖掘的最后结果是不可预测的，但要探索的问题应是有预见的，为了数据挖掘而数据挖掘带有盲目性，是不会成功的。 数据的选择。搜索所有与业务对象有关的内部和外部数据信息，并从中选择出适用于数据挖掘应用的数据。数据挖掘的数据主要有两种来源，即数据可以是从数据仓库中来的，也可以是直接从数据库中而来。 数据的预处理。实际应用数据往往是不完全的、有噪声的、模糊的、随机的，因此要根据不同的需求在挖掘之前进行预处理，即将最初的原始数据构造成最终适合建模工具处理的数据集，包括表、记录和属性的选择、数据转换和数据清洗等。其中，从数据仓库中直接得到数据挖掘的数据有许多好处，因为数据仓库的数据已经过了预处理，许多数据不一致的问题都较好地解决了，在数据挖掘时可大大减少清洗数据的工作量。 建模。选择和应用各种建模技术，并对模型参数选择合适的算法进行优化。 模型评估。对模型进行评价，并检査构建模型的每个步骤，确认其是否真正实现了预定的目的。 模型部署。创建完模型并不意味着工作结束，即使创建模型的目的是为了増加用户对数据的了解，所获得的知识也要用一种用户可以使用的方式来组织和表示，通常要将活动模型应用到决策制定的过程中。 第三节 大数据管理技术 8.3.1 大数据定义 目前大数据尚无统一的定义，通常被认为是数据量很大、数据形式多样化的数据。例如，EMC 公司认为“大”是指大型数据集，一般在 10TB 规模左右，同时这些数据来自多种数据源，以实时、迭代的方式实现。IBM 则是把大数据概括为 4 个 V，即大量化（ Volume）、多样化（ Variety）、快速化（ Velocity）和真实性（ Verity），强调大数据呈现价值稀疏性的特点。维基百科认为，大数据是指利用常用软件工具捕获、管理和处理数据所耗时间超过可忍时间的数据集。 大数据是指无法在可容忍的时间内用现有信息技术和软、硬件工具对其进行感知、获取、管理、处理的服务的数据集合，且其具有如下特征。 数据量巨大，即大量化（ Volume）。通过各种设备产生海量数据，数据规模庞大，数据量从 TB 级别，跃升到 PB 级别。IDC 的研究报告称，未来 10 年全球大数据将增加 50 倍，管理数据仓库的服务器数量将增加 10 倍。 数据种类繁多，即多样化（ Variety）。大数据种类繁多，在编码方式、数据格式和应用特征等多个方面存在差异性，多信息源并发形成大量的异构数据。相对于以往便于存储和分析的结构化数据，大数据的数据类型不再是单一的文本形式，网络日志、音频、视频、图片、地理位置信息等多类型的数据对数据的存储和处理能力提出了更高的要求。据统计，企业中 80%的数据是非结构化或半结构化的 处理速度快，即快速化（ Velocity）。大数据对实时处理有着较高的要求，在海量数据面前，处理数据的效率就是企业的竞争力 价值（ Value）密度低。价值密度的高低与数据总量的大小成反比。在现实应用中，数据量大的数据并不一定有很大的价值，不能被及时有效处理分析的数据也没有很大的应用价值。大数据的本质并非在于大，而在于其价值含量。 8.3.2 大数据管理技术典型代表 大数据存储 HDFS\nNOSQL 数据管理系统\nNOSQL 是以互联网大数据应用为背景发展起来的分布式数据管理系统。 NoSQL 有两种解释：一种是 Non- Relational，即非关系数据库；另一种是 Not Only SQL，即数据管理技术不仅仅是 SQL\nNOSQL 系统为了提高存储能力和并发读写能力采用了极其简单的数据模型，支持简单的查询操作，而将复杂操作留给应用层实现。该系统对数据进行划分，对各个数据分区进行备份，以应对结点可能的失败，提高系统可用性；通过大量结点的并行处理获得高性能，采用的是横向扩展的方式。它弥补了传统数据库由于事务等机制而带来的对海量数据高并发请求处理性能上的欠缺，采用一种非关系的方式来解决大数据存储和管理的问题\nNoSQL 系统支持的数据存储模型通常有键值（Key-vlue）模型、文档（ Document）模型、列（ Colum）模型和图（ Graph）模型等。\n键值（Key-alue）存储 Key-value 存储是 NOSQL 数据库采用最多的数据存储方式，它的数据是以 Key-ahue 的形式存储的。Key-aue 数据模型是一个映射，Key 是查找数据地址的唯一关键字，而 Value 是数据实际存储的内容。它采用这个弱关系的数据模型，使用哈希函数实现关键字到值的快速映射，从而提高数据的存储能力和并发读/写能力。虽然它的数据处理速度非常快，适合通过主键进行查询或遍历，但基本上只能通过 Key 的完全一致查询获取数据。常见的键值存储数据库包括 Tokyo Cabinet/Tyrant、 Redis 和 Oracle bDB 等。\n文档存储 不需要定义表结构，但可以像定义表结构一样使用。文档存储的存储格式可以多样化，适合存储系统日志等非结构化数据。与 Key-Vale 存储不同的是，它可以通过复杂的查询条件来获取数据。虽然它不具备关系数据库所具有的事务处理和 JON 的处理能力但基本上能实现除此之外的其他处理。常见的文档型数据库有 CouchDB、 MongoDB等。\n列存储 列存储是以列为单位来存储数据的，擅长以列为单位读入数据，比较适合对某一列进行随杋査询处理。采用列存储数据模型让数据库系统具有高扩展性，即使数据增加也不会降低相应的处理速度，因此列存储主要应用于需要处理大量数据的情况。常见的列存储数据库有 Cassandra、HBase 等。\n图存储 数据库是基于图理论构建的，使用结点、属性和边的概念。结点代表实体，属性保存与结点相关的信息，而边用来连接结点，表示两者关系。图数据库存储某些数据集非常快，可以把图直接映射到面向对象应用程序中。\nMapReduce 技术\nMapReduce 技术是（ Google 公司于 2004 年提出的大规模并行计算解决方案，主要应用于大规模廉价集群上的大数据并行处理。 MapReduce 以 Key/value 的分布式存储系统为基础，通过元数据集中存储、数据以chunk 为单位分布存储和数据 chunk 冗余复制来保证其高可用性。 MapReduce 是一种并行编程模型。它把计算过程分解为两个阶段，即 Map 阶段和 Reduce 阶段。具体执行过程是：首先，对输入的数据源进行分块，交给多个 Map 任务去执行，Map 任务执行 Map 函数，根据某种规则对数据分类，写入本地硬盘；然后，进入 Reduce 阶段，在该阶段由 Reduce 函数将 Map 阶段具有相同 Key 值的中间结果收集到相同的 Reduce 节点进行合并处理，并将结果写入本地磁盘。程序的最终结果可以通过合并所有 Reduce 任务的输出得到。其中，Map 函数和 Rduc 函数是用户根据应用的具体需求进行编写。 MapReduce 是一种简单易用的软件框架。基于它可以开发出运行在成千上万个结点上，并以容错的方式并行处理海量数据的算法和软件。通常，计算结点和存储结点是同一个节点，即 MapReduce 框架和 Hadoop 分布式文件系统运行于相同的结点集。 Last 数据库操作 创建数据库：\n1 2 mysql\u0026gt; create database testdb; Query OK, 1 row affected (0.00 sec) 删除数据库：\n1 2 mysql\u0026gt; drop database testdb; Query OK, 0 rows affected (0.01 sec) 查看指定数据库使用的字符集：show create database 数据库名;\n1 2 3 4 5 6 7 mysql\u0026gt; show create database lvsj; +----------+-----------------------------------------------------------------+ | Database | Create Database | +----------+-----------------------------------------------------------------+ | lvsj | CREATE DATABASE `lvsj` /*!40100 DEFAULT CHARACTER SET gb2312 */ | +----------+-----------------------------------------------------------------+ 1 row in set (0.01 sec) 数据库表操作 创建库表 1 2 3 4 5 6 7 mysql\u0026gt; create table user( -\u0026gt; user_id int not null AUTO_INCREMENT, -\u0026gt; user_name char(10) not null, -\u0026gt; user_age int not null, -\u0026gt; primary key(user_id) -\u0026gt; ); Query OK, 0 rows affected (0.03 sec) 插入数据 1 2 3 4 5 6 7 8 # 方法一 mysql\u0026gt; insert into lvsj.user(user_id,user_name,user_age,user_Address) -\u0026gt; values(1,\u0026#39;吕小布\u0026#39;,25,\u0026#39;bei jing\u0026#39;); # 方法二 mysql\u0026gt; insert into lvsj.course -\u0026gt; values(3,\u0026#39;语文\u0026#39;,95,2); Query OK, 1 row affected (0.01 sec) 使用 insert int ..set插入数据 1 2 3 mysql\u0026gt; insert into lvsj.user -\u0026gt; set user_name=\u0026#39;吕x布\u0026#39;,user_age=10; Query OK, 1 row affected (0.01 sec) 插入新列： alter \u0026hellip; add column 1 2 3 4 mysql\u0026gt; alter table lvsj.user -\u0026gt; add column user_hobby char(20) not null default \u0026#34;打游戏\u0026#34; after user_age; Query OK, 0 rows affected (0.09 sec) Records: 0 Duplicates: 0 Warnings: 0 删除数据 1 2 3 mysql\u0026gt; delete from lvsj.user -\u0026gt; where user_id = 11; Query OK, 1 row affected (0.01 sec) 更新数据 update \u0026hellip; set 1 2 3 4 5 6 7 8 9 mysql\u0026gt; update lvsj.user -\u0026gt; set user_name = \u0026#34;Lv Sijun\u0026#34; -\u0026gt; where user_id = 12; Query OK, 1 row affected (0.01 sec) Rows matched: 1 Changed: 1 Warnings: 0 mysql\u0026gt; update user set user_age = user_age*1.05; Query OK, 8 rows affected (0.01 sec) Rows matched: 8 Changed: 8 Warnings: 0 更新多个值用 , 分隔， 删除即设置为空;\n查看指定数据库表使用的字符集 1 2 3 4 5 6 7 8 9 10 11 12 13 mysql\u0026gt; show create table user; +-------+-------------------------------------------------------------------------------------------+ | Table | Create Table | +-------+-------------------------------------------------------------------------------------------+ | user | CREATE TABLE `user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `user_name` char(10) NOT NULL, `user_age` int(11) NOT NULL, `user_address` char(20) NOT NULL DEFAULT \u0026#39;jiangxi\u0026#39;, PRIMARY KEY (`user_id`) ) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=latin1 | +-------+-------------------------------------------------------------------------------------------+ 1 row in set (0.00 sec) 修改数据库表的字符集为 utf8 (解决插入中文数据报错的问题) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 语法 alter table 表名 convert to character set 字符集; # 示例，修改数据库表 user 的字符集为 utf8 mysql\u0026gt; alter table user convert to character set utf8; Query OK, 1 row affected (0.07 sec) Records: 1 Duplicates: 0 Warnings: 0 mysql\u0026gt; show create table user; +-------+-------------------------------------------------------------------------------------------+ | Table | Create Table | +-------+-------------------------------------------------------------------------------------------+ | user | CREATE TABLE `user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `user_name` char(10) NOT NULL, `user_age` int(11) NOT NULL, `user_address` char(20) NOT NULL DEFAULT \u0026#39;jiangxi\u0026#39;, PRIMARY KEY (`user_id`) ) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 | +-------+-------------------------------------------------------------------------------------------+ 1 row in set (0.01 sec) 数据查询 1 2 3 4 5 6 7 8 9 select [ALL|DISTINCT|DISTINCTROW] select_expr[,select_expr ...] from table_refrences [where where_condition] # 行级过滤 [group by{col_name|expr|position} # 聚合计算 [asc|desc],... [WITH ROLLUP]] [having where_condition] # 组级过滤 [order by {col_name|expr|position} # 排序 [asc|desc], ...] [limit {[offset,] row_count|row_count offset offset}] case when else end 1 2 3 4 5 6 7 8 9 10 11 12 13 mysql\u0026gt; select user_name, -\u0026gt; case -\u0026gt; when user_age \u0026gt;18 then \u0026#39;成年人\u0026#39; -\u0026gt; else \u0026#39;小朋友\u0026#39; -\u0026gt; end as 类别 from user; +-----------+-----------+ | user_name | 类别 | +-----------+-----------+ | 吕小布 | 成年人 | | 吕布 | 小朋友 | | Lv Sijun | 小朋友 | +-----------+-----------+ 3 rows in set (0.00 sec) case when then else end 条件 例 4.29 查询表 customers中客户的 cust_name、cust_sex, 要求判断结果集中 cust_ sex列的值, 如果该列的值为 M, 则显示输出\u0026quot;男\u0026rdquo;, 否则为\u0026quot;女\u0026quot;, 同时在结果集的显示中将 cust_sex列用别名\u0026quot;性别\u0026quot;标注\n1 2 3 4 5 6 mysql\u0026gt; select cust_name, -\u0026gt; case -\u0026gt; when cust_sex=\u0026#39;M\u0026#39; then\u0026#39;男\u0026#39; -\u0026gt; else \u0026#39;女\u0026#39; -\u0026gt; end as 性别 -\u0026gt; from test_db.customers; inner join 内连接 例 4.32 根据第二章描述的学生基本信息登记表 user和学生成绩表 course, 使用内连接查询每个学生及其选课成绩的详细信息;\n由于学生基本信息存储在 user表中, 学生选课成绩信息存储在 course表中, 所以这个查询涉及两张表, 这两张表之间进行连接的连接条件是两个表中的 id相等\n1 2 3 4 5 6 7 8 9 10 mysql\u0026gt; select * from user inner join course -\u0026gt; on user.user_id = course.student_id; +---------+-----------+----------+------------+--------------+-----------+-------------+--------------+------------+ | user_id | user_name | user_age | user_hobby | user_address | course_id | course_name | course_grade | student_id | +---------+-----------+----------+------------+--------------+-----------+-------------+--------------+------------+ | 1 | 吕小布 | 25 | 打游戏 | bei jing | 1 | 语文 | 95 | 1 | | 2 | 吕布 | 10 | 打游戏 | jiangxi | 2 | 语文 | 69 | 2 | | 2 | 吕布 | 10 | 打游戏 | jiangxi | 3 | 语文 | 95 | 2 | +---------+-----------+----------+------------+--------------+-----------+-------------+--------------+------------+ 3 rows in set (0.01 sec) 数据范围 between and / in 例 4.36 在数据库 test_db的表 customers中，查询客户 id 号分别为 903、906 和 908 个客户的信息。\n1 2 mysql\u0026gt; select * from test_db.customers -\u0026gt; where cust_id in(903,906,908); 例 4.35 在数据库 test_db 的表 customers中，查询客户 id 号在 903 至 912 之间的十个客户的信息。\n1 2 mysql\u0026gt; select *from test_db.customers -\u0026gt; where cust_id BETWEEN 903 AND 912; 例 4.38 根据第 2 章描述的学生基本信息登记表 tb student和学生成绩表 tb score，使用子査询的方式查询任意所选课程成绩高于 80 分的学生的学号和姓名信息。\n1 2 3 4 5 select 学号，姓名信息 from student where studentNo in (select studentNo from score where grade \u0026gt; 80) mysql\u0026gt; select studentNo,studentName -\u0026gt; from tb_student -\u0026gt; where studentNo in (select studentNo from tb_score where stScore\u0026gt;80); group by 子句与分组查询 在 select语句中，允许使用 group by子句，将结果集中的数据行根据选择列的值逻辑分组，以便能汇总表内容的子集，即实现对每个组的聚集计算。\n1 group by {col_name|expr|position} {asc|desc},...[WITH ROLLUP] 在表 user中获取一个数据结果集，要求该结果集中分别包含相同年龄的人数。\n1 2 3 4 5 6 7 8 9 mysql\u0026gt; select user_name,user_age,count(*) as \u0026#34;人数\u0026#34; from user -\u0026gt; group by user_age; +-----------+----------+--------+ | user_name | user_age | 人数 | +-----------+----------+--------+ | 吕布 | 10 | 2 | | 吕小布 | 25 | 1 | +-----------+----------+--------+ 2 rows in set (0.01 sec) having 用于过滤分组 1 2 3 4 5 6 7 mysql\u0026gt; select user_name,user_age,count(*) as \u0026#34;人数\u0026#34; from user group by user_age with rollup having count(*)\u0026gt;=3; +-----------+----------+--------+ | user_name | user_age | 人数 | +-----------+----------+--------+ | 吕小布 | NULL | 3 | +-----------+----------+--------+ 1 row in set (0.00 sec) 视图 1 2 3 4 5 6 7 CREATE VIEW view_name[(column_list)] as select_statement [ WITH [CASCADED|LOCAL] CHECK OPTION ] WITH CHECK OPTION 是可选项,用于指定在可更新视图上所进行的修改都需要符合 `select statement`中所指定的限制条件 关键字“ `CASCADED`”为选项默认值，它会对所有视图进行检查，而关键字“ `LOCAL`”则使 `CHECK OPTION`只对定义的视图进行检查。 创建视图 1 2 3 4 5 mysql\u0026gt; create view user_view -\u0026gt; as select * from user -\u0026gt; where user_age \u0026gt;15 -\u0026gt; with check option; Query OK, 0 rows affected (0.01 sec) 创建视图 只取部分参数 1 2 mysql\u0026gt; create view CVIEW(course_name,course_grade) as select course_name,course_grade from course where course_grade\u0026gt;80; Query OK, 0 rows affected (0.01 sec) 查询视图 1 2 3 4 5 6 7 mysql\u0026gt; select * from user_view; +---------+-----------+----------+------------+--------------+ | user_id | user_name | user_age | user_hobby | user_address | +---------+-----------+----------+------------+--------------+ | 1 | 吕小布 | 25 | 打游戏 | bei jing | +---------+-----------+----------+------------+--------------+ 1 row in set (0.00 sec) 插入数据 1 2 3 4 5 mysql\u0026gt; insert into user_view values(11,\u0026#39;李四\u0026#39;,10,\u0026#39;LOL\u0026#39;,\u0026#39;江西\u0026#39;); //错误示范 ERROR 1369 (HY000): CHECK OPTION failed \u0026#39;lvsj.user_view\u0026#39; mysql\u0026gt; insert into user_view values(13,\u0026#39;王五\u0026#39;,16,\u0026#39;DOAT\u0026#39;,\u0026#39;江西\u0026#39;); Query OK, 1 row affected (0.01 sec) 由于视图是一个虚拟表，所以通过插入、修改和删除等操作方法来更新视图中的数据，实质上是在更新视图所引用的表中的数据。\n","permalink":"https://bablvsj.github.io/posts/exams/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-04735/","summary":"最新自考笔记 : https://github.com/Eished/self-study-exam_notes https://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx 大纲 2018 版 题型 题数 * 得分 合计 单项选择题 15 题 x 2 分 30 分 填空题 10 题 x 1 分 10 分 设计题 5 题 x 4 分 20 分 简答题 5 题 x 6 分 30 分 综合题 1 题 x","title":"数据库系统原理"},{"content":"anti-:表示“反”，“反对”\nantisocial 反社会的\nauto-:表示“自己的”\nautobiography 自传\nbi-:表示“二”\nbieycle自行车\nbio-:表示“生物的”\nbiology生物学\nco-:表示“共同”\ncooperate 合作\ncounter-:表示“相反”“反对”\ncounterattack反击\nde-:表示“除去”\ndefrost 除霜\ndis-:表示“不”，“相反”\ndishonest 不诚实的\ne-:表示“因特网上的或使用因特网的”\ne-business 电子商务\nen-:表示“使”，“使处\u0026hellip;状态”\nenlarge扩大，endanger危及\nil-:表示否定(用于字母l前)\nillegal 非法的\nim-:表示否定(用于字母m,b或p前)\nimpossible 不可能的\nin-:表示否定\ninactive不活跃的\nir-:表示否定(用于字母r前)\nirregular 不规则的\ninter-:表示“\u0026hellip;.之间”“互相”\ninternational 国际的\nkilo-: 表示“千\nkilometre 干米\nmid-:表示“中间\nmidday 中午\nmini-:表示“极小的\u0026quot; ,“极短的\u0026quot;\nmimisknt恒伤\nmis-:表示销侯地\nmisunderstand 误解\nnon-:表示否定\nnonstop 不停顿的\npost-:表示“后”,“以后”\npostwar战后的\npre-:表示“在\u0026hellip;前”\nprewar战前的\nre-:表示“再”,“重新”\nrewrite 重写\nsub-:表示“在\u0026hellip;下面”\nsubway 地下铁路\nsuper-:表示“超级”\nsuperhero超级英雄\ntele-:表示“远距离的”\ntelescope望远镜\ntrans-:表示“横穿”，“横贯”\ntranspacific 横越太平洋的\ntri-:表示“三”\ntriangle 三角形\nun-:表示否定\nunimportant 不重要的\nunder-:表示“在\u0026hellip;.之下”，“不足”\nunderestimate低估\n二、常用后缀\n(一)名词后缀\n-age\npassage通过\n-ance, -ence\nassistance帮助，, dependence依赖\n-ancy ,-ency\nexpectancy期待, efciency效率\n-er,-or\nwriter作家, conductor导体\n-hood\nchildhood童年\n-ion,-tion, -ation\nconfession供认,ollection收集，observation观察\n-ion,-tion,-ation\nhistorian 历史学家,politician政治家\n-ist\nartist 艺术家, scientist科学家\n-ment\narrangement 安排，development发展\n-ness\nkindness 仁慈，happiness高兴\n-ology\nbiology生物学, psychology心理学\n-ship\nfriendship友谊, membership会员资格\n-ty,-ity\ncruelty残忍,purity纯净\n(二)动词后缀\n-en\nfasten系牢，shorten缩短\n-fy,-ify\nsatisfy满足，simplify简化\n-ize,-ise(英)\nmodermize使现代化, standardize使标准化\n(三)形容词后缀\n-able ,-ible ,-ble\nacceptable可接受的, divisible可分的\n-al\nenvironmental环境的，exceptional例外的\n-ful\nbeautiful漂亮的，useful有用的\n-ic ,-ical\natomice原子的,economical节俭的\n-ish\nbluish 带蓝色的，childish孩子气的\n-ive\nattractive 有吸引力的,ffctive有效的\n-less\ncareless粗心的,homeless无家可归的\n-ly\ndaily每天的, manly男子气概的\n-ous\ndangerous危险的，famous著名的\n-some\ntroublesome讨厌的\n-y\ndirty脏的，thirsty渴的\n(四)副词后缀\n-ly\ncompletely 完全地,really真正地\n-ward(s)\nbackward(s) 向后，afterward(s)后来\n-wise\nclockwise 顺时针地，likewise同样地\n","permalink":"https://bablvsj.github.io/posts/exams/english-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%B8%B8%E7%94%A8%E8%AF%8D%E7%BC%80/","summary":"anti-:表示“反”，“反对” antisocial 反社会的 auto-:表示“自己的” autobiography 自传 bi-:表示“二” bieycle自行车 bio-:表示“生物的” bi","title":"English 第一部分 常用词缀"},{"content":" compare v.比较;对比 compared with\u0026hellip; 与\u0026hellip;\u0026hellip;相比\ncompared to\u0026hellip; 比作\u0026hellip;\u0026hellip;\nbeyond compare无与伦比\nmess n.肮脏:杂乱:不整洁 be in a mess 乱七八糟，处境狼狈\nget into a mess 陷入困境，遇到麻烦\nmake a mess of\u0026hellip; 把\u0026hellip;\u0026hellip;弄糟搞得\nmessup 搞乱，弄脏，弄糟\nsacrifice n.牺牲;舍弃 at the sacrifice of 靠牺牲\u0026hellip;\u0026hellip;；以\u0026hellip;\u0026hellip;为代价\nfall a sacrifice to 成为\u0026hellip;\u0026hellip;的牺牲品\nmake all sacrifices 不惜牺牲一切\nessence n.本质;实质;精髓 be of the essence至关重要的\nin essence 本质上\nfaith n.信任;相信;信心 in good faith 真心实意地\nsore n.痛处;伤处;疮 a sore point with sb.令人恼怒的事;令人尴尬的事\nscene n.事件;场面;情景 make a scene发脾气;当众吵闹\nbehind the scenes秘密地;在幕后\non the scene在场;到场\nalert adj.警觉的;警惕的;戒备的 be alert to充分意识到\non the alert for 保持戒备\nblessing n.好事;有益之事 a blessing in disguise变相的幸福;塞翁失马，焉知非福\ncorn n.玉米 corm on the cob玉米棒\nbrick n.砖;砖块 hit a brick wall/come up against a brick wall碰壁\ncontribute B.增加;增进;添加(到某物) contribute to有助于\nexclude v.排斥在外防..进\u0026hellip;..参加 exclude sb. from拒(某人)于(某地、活动)之外;不包括\npassion n.强烈情感;激情 have a passion for酷爱\nsound adj. 明智的;合理的;正确的;可靠的 safe and sound安然无恙\nburden n. (义务、责任等的)重担，负担 bear a burden承受负担\ncast one\u0026rsquo;s burden on sb.把责任丢给某人\ndrop one\u0026rsquo;s burden卸下重相\nlay a burden on sb.给某人增加负担\nshare a bunder分担责任增加负担\ntake up a burden挑起重相\nbelief n.相信,信心 declare one\u0026rsquo;s belief 表明信仰\nhave belief in sb.信任某人\nrigid in one\u0026rsquo;s belief固执已见\nsecure in one’s beliefs坚守自己的信仰\nstick up for one\u0026rsquo;s beliefs捍卫自己的信仰\nshake one\u0026rsquo;s belief in sth. 动摇某人对某事的信念\naliction n.折磨，痛苦 eat the bread of afliction遭受痛苦\nspecies n.种,物种 strange species奇特的种类\nendangered species 濒临灭绝的物种\ndiscipline n.自制力;遵守纪律 class discipline班纪\nparty discipline 党纪\nschool discipline 校规\ncorrupt discipline败坏风纪\nkeep/observe discipline 遵守纪律\nmaintain discipline 维持纪律\nviolate the law and discipline违法乱纪\nconfront v.处理，解决(问题或困境) confrort\u0026hellip;with 使\u0026hellip;\u0026hellip;面对;使\u0026hellip;\u0026hellip;面临\ngrief n. (尤指由某人去世引起的)悲伤，伤痛,伤心 come to grief遭受不幸,失败，倒霉\ncontrol one\u0026rsquo;s grief抑制悲痛\ndivide grief 分担忧愁\nexpress/feel grief表示/感到悲伤\nin grief 感到悲伤\nweep with grief悲泣\ngrief at/for/over 对\u0026hellip;\u0026hellip;感到悲伤\na grief to sb.某人的伤心事\nanguish n.剧痛;极度痛苦;苦恼 be in anguish感到很痛苦\nthe anguish at 因\u0026hellip;\u0026hellip;而产生的痛苦\nthe anguish over 由\u0026hellip;\u0026hellip;起的痛苦\nthe anguish of failure失败的痛苦\nthe anguish of grief悲痛欲绝\ndespair n.绝望 in despair绝望地\ndrive sb. to despair使某人陷于绝望\ndespair of 对\u0026hellip;\u0026hellip;绝望\u0026hellip;\u0026hellip;感到担心\nequal v.比得上;敌得过 equal among 在\u0026hellip;\u0026hellip;中相等\nequal for 在\u0026hellip;\u0026hellip;方面平等\nequal in比得上，等于，在\u0026hellip;\u0026hellip;方面相等的\nconflict n.冲突;争执;争论 class conflict阶级对抗\nconfliet among/between \u0026hellip;\u0026hellip;之间的冲突\nconflict of \u0026hellip;\u0026hellip;的冲突\nconflict with与\u0026hellip;\u0026hellip;发生冲突\npose v.造成(威胁、问题等);引起;产生 pose an obstacle to 成为\u0026hellip;\u0026hellip;的障碍\npose a threat to对\u0026hellip;\u0026hellip;构成威胁\ndistinguish v.区分;辨别;分清 distinguish between\u0026hellip;将两者区分开\ndistinguish from把一种事物同另一种区别开\nwisdom n.智慧;才智;精明 cut one\u0026rsquo; s wisdom teeth 开始懂事\nconventional wisdom群众的意见\npractical wisdom世故\nbe a fount of wisdom有无穷智慧的，是智慧的源泉\ndesire v.渴望;期望 desire one’s approval期望得到某人的赞同\ndesire for希望得到某物\nchallenge n.挑战;艰巨任务 beyond challenge 无与伦比\nletter of challenge 挑战书\nunder challenge of处\u0026hellip;..局面\nwith challenge 挑衅\ndesperation n.绝望;拼命;铤而走险 in desperation拼死，无可奈何地\ndrive sb. to desperation 逼得某人走投无路\nvalue u.重视;珍视 value\u0026hellip;above\u0026hellip;把\u0026hellip;\u0026hellip;看得高于\u0026hellip;\u0026hellip;\nvalue\u0026hellip;at估价为\nvalue\u0026hellip;for.. \u0026hellip;而喜爱或高度评\u0026hellip;.\nquote v.引用，引述 quote from引自\u0026hellip;\u0026hellip;\nquote in full引用全文\nquote in part引用部分\nquote out of摘自\u0026hellip;\u0026hellip;\ninspiration n.鼓舞人心的人(或事物) on/with a sudden inspiration 灵机一动\nwithout an inspiration 没有灵感\ninspiration to 对\u0026hellip;\u0026hellip;的鼓舞\ncontact v.联系,联络 contact sb. about sth.与某人联系某事\ncontact sb. by telephone用电话联系某人\nimagine v.料想，认为 imagine as把\u0026hellip;\u0026hellip;当作\nimagine from根据\u0026hellip;\u0026hellip;想象\u0026hellip;\u0026hellip;\nrecovery n.恢复;痊愈 recovery from 从\u0026hellip;\u0026hellip;中恢复过来\na speedy recovery to health迅速恢复健康\nfare n.车费;船费;飞机票价 returm fare往返票价\nsectional fare 分段收费\nminimum fare 最低车费\nfare register计费器\ncombined fare 联运票价\ncarfare交通费\nthrough fare联运票价，直通票价\nexcursion fare旅游票价\nsingle fare单程票价\nfull fare全程票价\ndouble fare来回票价\nrecess n.课间休息 in recess在休会期间\nat recess在休息时间\nin the innermost recesses of the heart在内心深处\nallocate v.拨(给);划(给);分配(给) allocate among 在\u0026hellip;\u0026hellip;间分配\nallocate sb. to sth.分派某人到\u0026hellip;\u0026hellip;\nallocate sth. to sb.分配某物给某人\nopt v.选择;挑洗 opt out(of sth.)决定退出\nopt in (to sth.)决定参加\nopt in favour of作出选择\nconstraint n.限制.限定:约束 constraint on sth.对\u0026hellip;\u0026hellip;的约束\nbudget v.谨慎花钱;把\u0026hellip;\u0026hellip;编入预算 budget one\u0026rsquo;s incomes 做储蓄计划\nbudget one\u0026rsquo;s time安排目己的时间\nbudget for sth. 把\u0026hellip;\u0026hellip;列入预算\nmentality n.心态;思想状况;思想方法 business mentality 企业经营理念\ntranquilize the mind and promote mentality 宁神益智\nimpairment of mentality 伤志\nsiege mentality精神压抑\nindulge v.沉湎，沉迷，沉溺(于\u0026hellip;\u0026hellip;) indulge sb. with sth. 用\u0026hellip;.纵容某人\nindulge in任凭\u0026hellip;沉溺于\nrationing n.定量配给政策;配给制 food rationing食物(定量)配给\nrationing transaction配额交易\nexchange rationing system外汇配给制\noverall rationing system包干制\nprinciple n.观念;(行动、思想的)理由,信条 moral principle道德准则\nThree Prineiples of People三民主义\ndifferentiate v.区分;区别;辦别 differentiate between\u0026hellip; and\u0026hellip;区分两者\ndifferertiate\u0026hellip;from\u0026hellip;将\u0026hellip;\u0026hellip;与\u0026hellip;\u0026hellip;区分开\ndifferentiate into\u0026hellip;区分为\u0026hellip;\u0026hellip;种类\ninculcate v.反复灌输，谆谆教诲 inculcate sth. in/into sb.教导其人\u0026hellip;\u0026hellip;\ninculcate sb. with sth.教导某人\u0026hellip;\u0026hellip;\ntemptation n.引诱;诱惑 face/resist/overcome temptation面对/抵抗/战胜诱惑\nfall into the temptation受到诱惑\nscheme n.计划;方案;体系;体制 carry out a scheme实行计划\ndevise a scheme策划一个方案\nmature scheme成熟的计划\ntraitorous scheme奸计\ngreedy adj. 贪婪的;贪心的 be greedy of/for sth. 贪图某物\nbe greedy for迫切渴望\nabundant adj.大量的;丰盛的;充裕的 be abundant in富有,有很多\nbe abundant with富有,有很多,\u0026hellip;\u0026hellip;很丰富\ndonate v.(尤其指向慈善机构)捐赠，赠送 donate to\u0026hellip;. \u0026hellip;捐赠\ncharity n.慈善机构(或组织) accept charity 接受施舍\ncontribute to a charity向一家慈善机构进行捐助\ninternational charity 国际慈善机构\nopposite n.对立的人(或物) ;对立面;反面 opposite to与\u0026hellip;..面对面\neconomy n.经济;经济情况;经济结构 economy classes 经济舱\nagricultural economy农业经济\nlabel v. (尤指不公正地)把\u0026hellip;.称为 label sb./sth. as sth.将某人/某物归为\u0026hellip;..\nhesitation n.犹豫 have no hesitation in doing sth.毫不犹豫地做某事\nwonder v.想知道;想弄明白;琢磨 make sb. wonder让某人遐想\nwonder about 对\u0026hellip;\u0026hellip;感到奇怪;对\u0026hellip;\u0026hellip;感到疑惑\nprompt v.促使;导致;激起 prompt sb. to do sth.促使某人做某事\nroll v.(使)翻滚，滚动 roll to and fro来回滚动\nroll into卷成，使合为一体;滚进\nroll up卷起;累积;到达;袅袅上升;步履蹒跚\nroll down滚下\nwipe v. (用布、手等)擦干净,抹掉 wipe up擦干净;擦掉\nwipe sth. clean擦干净\nwipe out sth.彻底消灭或摧毁某物\naddress v.写(收信人)姓名地址;致函 address oneself to sth. 从事于\naddress sth. to sb.把某物寄给某人\nattach v. 把\u0026hellip;\u0026hellip;固定，把\u0026hellip;\u0026hellip;附(在\u0026hellip;\u0026hellip;上) attach to 依附,附属、加入、使依恋;把\u0026hellip;\u0026hellip;放在\nemotion n.强列的威情;情感;情绪 with emotion激动地:感动地\nenmotion quotient(EO)情商\noverwhelming adj.巨大的;压倒性的;无法抗拒的 overwhelming superiority 绝对优势\nscream v.高声喊，大声叫烟 scream for强列要求:为\u0026hellip;\u0026hellip;而尖叫\nscream out大叫;尖声喊叫\nfortune n.大笔的钱;巨款 good fortune 好财运，好运;顺境\nmake a fortune发财，赚大钱\na small fortune [口]一笔巨款;很多钱\nfame and fortune名声与财富\nradiate v.(使品质或感情)显出，流露 radiate from从\u0026hellip;\u0026hellip;发出，流露出\ninoculate v. (给\u0026hellip;\u0026hellip;)接种，打预防针 inoculate sb. against sth. 给\u0026hellip;\u0026hellip;接种，打预防针\ninoculate with灌输\ndistraught adj.心烦意乱的;心急如焚的 be distraught at .对\u0026hellip;.感到心烦意乱\nreception n.接待处 reception desk接待处(等于front desk)\nwrap v. 用\u0026hellip;\u0026hellip;缠绕(或围紧) wrap(sb.) up伪装;使全神贯注;穿暖和的衣服\nexplanation n.解释;说明 in explanation of .对\u0026hellip;..进行解释\nadapt v.适应(新情况) adapt to sth. (使)适合;(使)适应 adapt for调整，使适合于:;为\u0026hellip;\u0026hellip;改编\nfufill v.实现 fulfill oneself完全实现自己的抱负\ncease v.(便)停止，终止，结束 cease to be 不再是;停任\nwithout cease不停地,不断地\ncease from 停止\nobstacle n.障碍;阻碍;绊脚石 obstacle course超越障碍训练场\ntrick n.戏法;把戏 do the trick获得成功\ntrick or treat不招待就使坏(指万圣节孩子们挨家逐户要糖果等礼物，如不遂愿便恶作剧一番的风俗)\nhat trick帽子戏法(指连入三球),(板球)连中三柱\nplay a trick 搞恶作剧，捉弄\ndirty trick 卑鄙手段\ndefine v.阐明;明确;界定 define as解释为\nrecall v.记起;回忆起;回想起 beyond recall不可挽回;不能记起\nrecall from 从\u0026hellip;\u0026hellip;处召回\nrecall to mind回想起，回忆起，记得\npossession n.具有;拥有 in possession of sth. 拥有(或占有)某物\ntake possession of占有;占领\nin the possession of被某人占有;属于\u0026hellip;\u0026hellip;;为\u0026hellip;\u0026hellip;所有\ngive possession使完全占有;转交所有权;给予引渡\ncome into possession of占有某物，拥有\npunch n.拳打;以拳痛击 kick and punch拳打脚踢\ninstant adj.立刻的;立即的 instant food方便食品:即食食品;速溶食品\nintroduce U.推行;实施;采用 introduce into 引进\nnegative n.否定;拒绝;否定词 in the negative表示否定或拒绝的，否定的(一般用于正式的公文中)\npositive n.良好的;正面的;肯定的 make positive suggestions/proposals提出积极的意见/建议\ndespair n.绝望;失去希望;丧失信心 in despair在绝望之中\nout of despair出于绝望\nfall into despair陷入绝望\ndrive sb. to despair逼得某人走投无路\npetty adi.小的;琐碎的 petty oficial 小官吏\npetty minds 小心眼儿\nlane n.跑道,泳道 fast lane 快车道\nbus lane公共汽车专用车道\nspot n.地点;场所;处所 on the spot当即，当场,在现场\nhot spot热点\nsymbolize v.象征;是\u0026hellip;\u0026hellip;的象征;代表 symbolize sth./sb. (with/as sth. ) 用\u0026hellip;\u0026hellip;代表某事物/某人\ntough adj.艰苦的;艰难的;棘手的 have a tough time of it日子不好过\na tough game/assignment/journey艰苦的比赛/困难的任务/艰辛的旅程\narise v.发生;产生;出现 arise out of/arise from由\u0026hellip;\u0026hellip;而引起，由\u0026hellip;\u0026hellip;而产生;从\u0026hellip;\u0026hellip;中产生\nobstacle n.障碍;困难;阻碍 a serious obstacle to对\u0026hellip;..的严重阻碍\nthrow obstacles in sb\u0026rsquo;s way妨害，阻碍某人\nlost adj.不知所措的;一-筹莫展的 lost souls迷失的灵魂\na lost generation迷惘的一代\nyard n.码 by the yard大量地\nyard by yard一码一码地\ninch n.英寸，少量 inch by inch逐步地;一点一点地\nby inches差一点儿:几乎\nevery inch 整个地方\nstricken adj.受煎熬的;患病的;遭受挫折的 be stricken by/with sth. 经受\u0026hellip;.(指坏事，如疾病、悲痛)之苦的\nbe stricken with poverty受贫困的折磨\ntuck v.把\u0026hellip;\u0026hellip;塞进狭窄的空间;把\u0026hellip;\u0026hellip;藏人 tuck sth. into sth.把\u0026hellip;\u0026hellip;塞进/藏到\u0026hellip;\u0026hellip;里面\ntuck sth. in/up把东西藏好\ntuck in尽情吃\ntuck sth. away把\u0026hellip;.藏起来\nchin n.下巴 take it on the chin勇敢忍受不幸;坦然接受灾祸\nkeep one’s chin up(非正式)不气馁，不灰心\nproceed v.接着做;继续做 proceed to do sth.接着做某事\nproceed with sth.继续某事\nfigure v.认为,认定(某事将发生或属实) ;估计 figure on计划:指望\nfigure out弄明白;理解\noutburst n. (感情的)爆发，迸发 an outburst of laughter 一阵大笑\nan outburst of anger勃然大怒\napplause n.鼓掌;喝彩 a round of applause一阵掌声\nwin applause 赢得掌声\nshaky adj.不稳固的;不牢靠的;摇晃的 shaky hands 颤抖的手\na shaky voice颤抖的声音\nproclaim v.宣布;宣告;声明 proclaim sth.宣告某事\nproclaim that 声称\narrangement n.安排;筹备 make arrangement for为\u0026hellip;\u0026hellip;做安排，为\u0026hellip;\u0026hellip;做准备\nexpense n.费用;价钱 at someone\u0026rsquo;s expense由某人付费;由某人承担费用\nextra expense额外费用\nat the expense of 以\u0026hellip;\u0026hellip;为代价;忽视\nfixed expense 固定费用\ncommute n.上下班路程 a short commute to work很短的上班路程\ncommute to到某地去\ncommute from离开某地\ncommute between A and B往返于A、B两地\nswitch v. (使)改变,转变 switch to转换到\nswitch from\u0026hellip;to\u0026hellip;从\u0026hellip;\u0026hellip;变换/转移到\u0026hellip;\u0026hellip;\nmajority n.大部分;大多数 the majority of大多数\u0026hellip;..\nbe in the majority构成大部分，占大多数\nwean v.使逐渐戒除恶习(或避免依赖\u0026hellip;\u0026hellip;) wean sb. (away) from sth./doing sth. 使某人不继续做某事\ndependence n. 依靠依赖,依存 dependence on依靠,依赖\nexception n.例外的事物;规则的例外 exception to例外情况\nno exception毫无例外\nwithout exception毫无例外地，一律\nresource n.资源;财力 natural resources 自然资源\npool the resources集中资源\nease n.舒适;安逸;自在 with ease容易地;无困难地\n(be/feel) at one\u0026rsquo;s ease 轻松自在;舒适,无忧虑\nadvantage n.有利条件;有利因素;优势 have an advantage over胜过\nhave the advantage of由于\u0026hellip;\u0026hellip;处于有利条件\ntake advantage of利用\nto advantage有效地，出色地，使优点突出\nguts n.勇气;胆量;决心;毅力 have guts to do sth.有胆量去做某事\ntransit n.运输;运送;搬运;载运 in transit在运输中\ntransit trade转口贸易\nheed v.留心;注意;听从(劝告或警告) heed a warning注意警告\nvariety n. (同一事物的)不同种类，多种样式 a variety of种种，各种\nintimacy n.亲密，亲密关系 be on terms of intimacy亲密\nperceive v.将\u0026hellip;\u0026hellip;视为;认为: perceive sb. doing sth.觉察到某人正做某事\nvary v.相异;不同 vary with \u0026hellip;.变动\nvary from\u0026hellip;to\u0026hellip;从\u0026hellip;变成\u0026hellip;\nconvey v.表达,传递(思想、感情等) convey sth. to someplace把\u0026hellip;.运送到某处\nconvey one\u0026rsquo; s feelings表达情感\npolish v.修改;润饰;润色 polish up润色,改善\npolish awayv擦去国除掉\npolish off 干完;击倒;除掉\nintellect n.(尤指高等的)智力，思维逻辑领悟力 hava a giant intellect 才智过人\nappearance n.外貌，外表 by all appearances 从外表看来；显然\nkeep up appearances 装样子；撑场面\nintensity n.剧烈:紧张;强烈 go mad at the intensity of one\u0026rsquo;s grief因悲伤过度而发疯\nsuspect v.疑有，觉得(尤指坏事可能属实或发生) suspect sb. of doing sth.怀疑某人做某事\ndetermine v.决定 determine to do sth.决定做某事\nbe largely determined by很大程度上由\u0026hellip;\u0026hellip;决定\nextract v.选取;摘录;选录 extract sth. from a place从某地取出某物\nconfession n.认罪;供认;坦白 have a confession to make有\u0026hellip;\u0026hellip;要坦白\nevolve v. (使)逐渐形成，逐步发展 evolve from从\u0026hellip;\u0026hellip;演变而来\naccess n.通道;通路;入径 give access to接见;准许出入\nhave/ gain/ get/ obtain access to接近;进入;使用\noption n.可选择的事物 have no option but to ( do)除了\u0026hellip;\u0026hellip;以外没有他法，只好 leave one\u0026rsquo;s options open不做选择;不表态;不做承诺;留有回旋余地\nmake one\u0026rsquo; s option进行选择\nimpatient adj.不耐烦的，没有耐心的 get impatient about为某事烦躁\nbe impatient for急切地盼望\nevidence v.证明,表明 be evidenced by 被某事证明\nreliant adj.依赖性的:依常的 be wholly reliant on 完全依赖于\nshuffle v.拖着脚走 shuffle one\u0026rsquo;s feet along拖着脚步走\ncrack v.找到解决(难题等的)方法 crack on继续干;抓紧时间干\ncrack down采取严厉措施,制裁;打击\nrespite n.暂停;暂缓 give sb. a respite让某人稍事休息\nwithout respite 不停歇,持续\ngrateful adj.感激的;表示感谢的 be grateful to sb. for doing sth. 对某人做某事表示感谢\nextend one\u0026rsquo;s grateful thanks to sb.对某人致以衷心的感谢\nrefresh v.使恢复精力;使凉爽 refresh one\u0026rsquo;s memory使某人记起;唤起某人的记忆\nempower U.增加(某人的)自主权;使控制局势 empower sb. to do sth.给某人做某事的权力\njustify v. \u0026hellip;.作出解释;为\u0026hellip;..辩解(或辩护) justify oneself为某人自己辩解\njustify one\u0026rsquo;s claims为某人的要求辩解\njustify one\u0026rsquo;s actions为某人的行为辩解\njustify one\u0026rsquo;s behavior为某人的行为辩解\nawareness n.知道;认识;意识 have an awareness of doing sth.有做某事的意识\nincrease one\u0026rsquo;s awareness提高某人的意识\nadjust v.适应;习惯 adjust to适应\nworthwhile adj.重要的;令人愉快的;有趣的;值得花时间(或金钱、努力等)的 be worthwhile doing sth. 值得做某事\nprejudice n.偏见；成见 without prejudice to无损于;没有对\u0026hellip;\u0026hellip;造成不利;没有对\u0026hellip;\u0026hellip;带来改变\nhave a prejudice against 对\u0026hellip;\u0026hellip;有偏见\nindenendent adj.自立的；自食其力的 indenendent of 相互独立的；批次不关联的\ncapable adj. 有能力的:有才能的 be capable of doing sth.有能力做某事;能够做某事\n","permalink":"https://bablvsj.github.io/posts/exams/english-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E9%87%8D%E7%82%B9%E8%AF%8D%E8%AF%AD%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%90%AD%E9%85%8D/","summary":"compare v.比较;对比 compared with\u0026hellip; 与\u0026hellip;\u0026hellip;相比 compared to\u0026hellip; 比作\u0026hellip;\u0026hellip; beyond compare无与伦比 mess n.肮脏:杂乱:","title":"English 第二部分 重点词语及常用搭配"},{"content":" apply to使用;应用 The convention does not apply to us.这条惯例对我们不适用。\nHis project is concerned with applying the technology to practical business problems. 他的项目关系到将这项技术应用于实际的商务问题。\nput forth提出;产生 The sientist put forth the new theory of vluion.这位科学家提出了进化的新理论。\ntake...into account考虑到；顾及 Urban planners in practice have to take many interest groups in society into account. 城市规划人员在实际工作中必须把社会各种利益集团都考虑在内。\ncarry out完成(任务) They carried out their plan without difficulty.他们顺利完成了计划。\nPolice believe the attacks were carried out by nationalists. 警方认为袭击是民族主义分子发动的。\nbe up to取决于 It\u0026rsquo;s up to you to decide whether you go or not. 去还是不去，任你决定。\nhave an impact on/upon对\u0026hellip;\u0026hellip;产生巨大影响 The meeting will have a great impact on the future of the country.此次会议将对国家的未来产生巨大影响。\nbe in control of掌管;管理;控制 She may be old, but she\u0026rsquo;s still in control of all matters.尽管她已经老了,但是她仍掌管一切事情。\nin this manner用这种方式 Please do it in this manner.请按照这种方式来做。\nI wish you wouldn\u0026rsquo;t behave in this manner.我希望你不要以这种方式行事。\nset...apart from区别;使与众不同 Her bright red scarf set her apart from the other girls. 她那鲜红的围巾使她在其他女孩中间显得特别引人注目。\nfrom scratch从头开始;从零开始 Building a home from scratch can be both exciting and challenging.从头开始创建家园既让人兴奋又富于挑战。\nHong Kong\u0026rsquo;s manufacturing industry did not start from scratch in the post-war period. 战后,香港制造业的兴起并非从零开始。\nrun out of用完;耗尽 He has run out of food;his children are hungry.他家揭不开锅了，孩子们都饿了。\nstay up熬夜 I am going to stay up late to finish my paper. 为了完成报告我打算熬夜。\nstick by坚持忠于;不离不弃(某人) He is the kind of fiends who stuck by me during the difeut times.他是那种在困难时继续支持我的朋友。\nI made my deision then and stuck by it我当时做了决定，而且坚持这个决定。\nthrough thick and thin不畏艰难险阻 I\u0026rsquo;ll always stand by you through thick and thin.在任何情况下我都与你同甘共苦。 15. lead to导致，造成(后果)\nHeart failure led to her father\u0026rsquo;s death.心力衰竭导致她父亲死亡。\nToo much work and too ltte rest often lead to ilness过量的工作和过少的休息会引发疾病。\na multitude of众多的;大量的 Although businesses fail for a multitude of reasons, the underlying issues are surprisingly common.虽然公司的失败会有众多原因，不过其根本问题却惊人地相似。\nA multitude of people gathered at the gate of the exhibition hall一大群人聚集在展览大厅的门口。\nengage in (使)从事，参加 Politicians should not engage in business affairs that might affect their political judgment.政治家不应该参与那些可能会影响其政治判断力的商业事务。\nI don\u0026rsquo;t engage myself in such affairs.我不参与这种事情。\nin essence本质上 He is in essence a reclusive sort.他本质上具有一种隐土的气质。\nThe two things are the same in outward form but difterent in essence.那两样东西在外表上相同,但在本质上不同。\nturn against背叛 The minister has tumed against his former colleagues. 该部长和他过去的同事反目成仇了。\nEven those who are once for him begin to tum against him.连那些原来支持他的人也开始反对他了。\nbe prone to易于 He was prone to anger.他易发怒\nWithout enough stress,you\u0026rsquo;re unlikely to give your full effort and you may also be prone to make mistakes.如果压力不够,你就不会付出百分百的努力,而且也很可能会犯错误。\nstand by支持;帮助;忠于 I wouldn\u0026rsquo; t break the law for a friend,but I would stand by her if she did.我不会为朋友而违法,但如果她犯了法我会继续支持她。\nfall to pieces崩溃;倒塌;解体 Likewise, some tents last for a long time whereas others fall to pieces rapidly.同样,有些帐篷能维持很久,而另一些则很快倒塌破碎。\nbring in赚得;挣 I have three prtime jobs，which bring in about $24,000 a yer.我有3份兼职工作，一年能赚大约2.4万美元。\neke out a living竭力维持生计;勉强度日 North Koreans certainly struggle to eke out a living ,but they are not starving. 朝鲜人毫无疑问是在挣扎着生存,但是,他们并非正在被饿死。\nIn old China workers and peasants could hardly eke out a living , let alone send their children to school.在旧中国,工人和农民连生活都难以维持，更谈不上送子女上学了。\nsink in被完全理解;被充分意识到 The implication took a while to sink in.这个含意过了一会儿才被领会。\nEvervbody laughed at the joke but Joe;it took a moment for it to sink in before he laughed too.除了乔每个人都被这笑话逗乐了,过了一会儿他完全理解过来便也笑了。\nlook forward to (高兴地)盼望；期待 He was looking forward to working with the new manager.他很期待和新经理一起工作。\nover and over again多次;反复地;一再 Vary your routes and work-outs,so you\u0026rsquo;re not doing the same runs over and over again.改变你的路线和训练,那样你就不会一遍又一遍地做着相同的事情。\nThey sing it over and over again in the parade there and they talk about it.他们在游行队伍里一遍又一遍地唱这首歌，并且处处谈论它。\nbe prepared for准备好;有所准备 The doctor had to warn her, she must be prepared for the worst.医生不得不警告她，她必须做最坏的准备。\nWe must be prepared for all contingencies.我们要做好各种准备，以防意外。\nbelieve in认为某事好(对或可接受) I believe in fresh air and exercise for my health.我相信新鲜空气和锻炼对我身体有益。\nlie in存在;在于 Its virtue resides in its clarity and brevity. 它的优点在于清晰、简洁\nThe cure for stress lies in learning to relax.消除紧张的方法在于学会放松。\nbargain for预料到;料想到 The effects of this policy were more than the goverment had bargained for.这项政策的影响超出了政府的预料\nI did not bargain for John arriving so soon.我没想到约翰会这么快到达。\nbe/feel privileged to do 荣幸地做某事 \u0026ldquo;I feel privileged to have hung out Band worked with Michel,\u0026rdquo; he said.他说:“我很荣幸曾和迈克尔相处、共事。”\nI\u0026rsquo;ll be privileged to finish my career at Liverpool.我将有机会在利物浦结束我的职业生涯。\nbring...to the table带来好处 The new manager has a lot of international experience to bring to the table. 新任的经理可以提供许多国际性的经验。\nat/in/to the forefront of...处在最前列;进入重要地位 Shenhua is once again at the forefront of development.申花再次站在了发展的最前线。\nPresently,we\u0026rsquo;re at the forefront of high technology. 现在，我们处于高科技的最前沿。\nin plain sight显而易见 The past is filled with incredible mysteries. The clues to solving them are all around hidden in plain sight.过去充满难以置信的秘密,而解开它们所需的线索就在我们周围，隐藏在显而易见的事实当中。\nBulks of plastic bags are in plain sight in stark defiance to the ban, giving shoppers an easy choice.大量塑料袋完全被放在显而易见的地方,这是公然对抗禁令,给顾客一个必然的选择。\nget...up安排;组织 The church is gtting up a sale to collect money for the homeless children.教堂正在筹划一次义卖，为无家可归的孩子筹款。\nseek out寻求 Now it is time for local companies to seek out business opportunities in Europe.现在是当地公司在欧洲寻求商机的时候了。\nSeek out those new problems，and set your mind free in search of new solutions.找出那些新问题，解放思想，探索新的解决办法。\nin place在工作;准备就绪 The arrangements for the concert next Saturday are all in place.下周六的音乐会已经准备就绪。\napply for (通常以书面形式)申请，请求 She applied to the manager tor a Job as clerk.她向经理申请一份办事员的工作。\nHe applied for a fllowship. 他申请入会。\nmoan about抱怨 He moaned about his misfortunes to anyone who would listen.他向每一个愿意听的人抱怨他的不幸\nWhat is he moaning about?他在发什么牢骚?\na series of一系列;连续 This event is part of a series of Developrment Debates designed by the World Bank Institute.此次研讨会是世界银行学院设计的“发展大辩论”的系列活动之一。\nThe theory is based on a series of wrong assumptions.这一理论 是以一系列错误的设想为依据的。\nbecause of因为 Many motorists were forced to stop over in that town because of floods.由于发大水,许多开车旅游的人被迫停留在那个镇上了。\nlove you not because of who you are,but because of whoI am when I am with you.我爱你，不是因为你是一个怎样的人，而是因为我喜欢与你在一起时的感觉。\nas well as除\u0026hellip;\u0026hellip;之外 He as well as I is responsible for it.不但是我，他对这件事也有责任。\nA teacher should entertain as well as teach.教师不仅要教书，也要引起学生的兴趣。\ncutting edge(处于某事物发展的)尖端，最前沿，领先阶段 This shipyard is at the cutting edge of world shipbuilding technology.该造船厂的造船技术处于世界最前沿。\ncall forth引起;使产生 The shopping centre has called forth an angry response from loccal residents. 这个购物中心已经引起了当地居民的愤怒的反应。\nstart over重新开始 If everything in my life exploded，what kind of life would I have if I had to start over?若我失去了生活中的每件东西,在重新开始时我会选择怎样的生活呢?\non one’s feet (陷人困境后)恢复,完全复原;(病后)痊愈 This medicine will help to set you on your feet.这种药能帮你恢复健康。\nSadness does not disappear overmight;it takes time to get back on one\u0026rsquo;s feet.悲伤不是一夜之间就能消失不见的，重新振作起来需要时间。\nstruggle with斗争;抗争 The old man has been struggling with ilness. 这位老人一直与病魔斗争。 Some people never really master the art of being patient, and at times，all of us struggle with being patient.有些人并没有真正地掌握忍耐的艺术,我们所有人都在努力变得有耐心。\nwalk out on遗弃，抛弃，离开(某人) You can\u0026rsquo; I just walk out on us like this. 你不能就这样丢下我们就走了。\nbring about导致;引起 What brought about the change in his atiude?是什么使他改变了态度?\nfight back奋力抵抗;还击 I gave an impassioned plea for the Democrats to fight back in the face of Republican attack ads.我热烈地呼吁民主党人要对共和党人的攻击性广告发起回击。\nWhen you feel that someone is threatening your existence,you fight back to save yourself.当你感觉有人威胁到你的生存时，你会反击以拯救自己。\non a daily basis每日地 Studies show that the average person experiences paranoia on a daily basis.研究表明普通人每天都会有一些胡思乱想的体验。\nHe gets paid on a daily basis. 他的工资按日结算。\nresult in导致 When you do something with faith, it will result in success.当你有信心地去做某事时，你就会成功。\npay off付清;偿清 If you only pay minimum payments every time,you will be old and gray before you pay off the debt.如果你每次只偿还最低量，那你直到老的时候才会还清所有的债务。\nWill the investment of time and effort pay off?时间和精力方面的投人能否得到回报?\nwithin one’s means量入为出 Balancing accounts by always keeping expenditures within our means is an important principle we should follow in our economic work.坚持财政收支平衡和量人为出，是经济工作应当遵循的重要原则。\nstand...in good stead (需要时)对某人有用,对某人有利 Some work experience will stand you in good stead. 积累点工作经验对你有好处。\ndeep down实际上;在心底 Deep down,she was stil a rebel. 她实质上仍是个叛逆者。\nShe seems indifferent, but deep down she’s very pleased. 她貌似无动于衷，其实心里非常高兴。\nopen up (使某事物)成为可能可得到，可达到 They decided to open up the island for cultivation.他们决定开发这个岛来耕种。\nThe book wil open up to reades new vistas 0n eonomie hinking 这本书将为读者展现经济思想的新远景。\nout of context脱离上下文，断章取义 His heart bled over certain phrases taken out of context. 这几句断章取义的话好像很伤他的心。\ngo with the flow随波逐流,顺其自然 Sometimes you just can\u0026rsquo;t go with the flow and jump on the wagon.有时候你就是不能随波逐流，跟着大家走。\nbreak down失败 Why did the peace talks break down?为什么和谈失败了?\nIn complex, dynamic environments such as software development ，this approach tends to breakdown.像在软件开发这样复杂的动态环境下，这种方式容易失败。\ncome up with找到(答案等) How do you come up with your jokes?你是怎么想出那些笑话来的?\nAs a professor ,you could come up with absolute solutions.作为名教师,你可以想出彻底的解决方案。\nin desperation在绝望中;走投无路 In desperation，he decided to go back to London.在绝望中，他决定还是回伦敦去。\nShe cried at lengh,in desperation,her large eyes staring at him like those of a wild animal. 她终于喊叫起来，在绝望之中，她的一双大眼睛就像野兽的眼睛一样，直直地瞪着他。\ncare about sb.关心;关怀 We often pardon our beloveds\u0026rsquo; faults because we care about them.我们经常因为对爱人在意而原谅他们的缺点。\nPeople don\u0026rsquo;t care about you if you only care about youself.你如果只关心自己，那你就很难得到人们的关心。\ntake a chance冒险 If you find yourself avoiding new opportunities and disregarding problems,it\u0026rsquo;s time to take a chance.如果你发现自己正在回避新的机遇，或逃避问题，这时就该冒险了。\nSometimes you just have to take a chance , and correct your mistakes as you go along.有时候你必须冒险一试，有错误则边发现边改正。\nmake a difference有作用;产生影响 Eating habit makes a difference to your everyday life. 饮食习惯对你每天的生活有影响。\nYour support will certainly make a diference in my cause.你的支持肯定对我的事业很有影响。\nmake a hit给(某人)留下很好的第一印象;使(某人)二见钟情 You really make a hit in the sports meeting.你在运动会上的表现给大家留下了很好的第一印象。\nThe fist and foremost thing is to let people make a hit on the city at first sight, atteting them by its unique image.首先要着手做的第一件事，也是最重要的事情就是让人们对这个城市一见钟情,以城市自己独特的形象吸引他们。\nas luck would have it碰巧;偶然;幸而 As luck would have it,some skater shoved me ,so I ended up pushing Carl.碰巧有个溜冰的人撞到我，结果使我推了卡尔一把。\nAs luck would have it,no one was in the building when the explosion happened.真幸运,发生爆炸时大楼里刚巧没有人。\nbe characteristic of典型的;独特的;特有的 It\u0026rsquo;s characteristic of her that she never complained.从不发牢骚是她的特性。\nIsabel was a tall girl with the oval face,straight nose,fine eyes and full mouth that appeared to be characteristic of the family. 伊莎贝尔是个身材高挑、椭圆脸、直鼻梁、眉清目秀、嘴巴丰满的姑娘。这一切看来都是她家族的特征。\nstrike up(和某人)建立友谊，开始来往，交淡起来 The mere subject of the book or magazine might help strike up conversation. 哪怕是关于书本或杂志的微小话题，也可能帮助大家打开话匣子。\nCheck out their websites \u0026ndash;even strike up a conversation with the author if you feel like it.去作者的网站看看，如果你愿意的话，甚至还可以和作者聊一聊。\njoin in参加，加入(活动) I like to watch a group or acivity for a while before I join in.在我加入某群人或某项活动之前，我会先站到一边看一会儿。\nOnce you start doing something，then others will likely join in and you\u0026rsquo; II be amazed at how your efforts will snowball.旦你开始做某事,其他人就可能会加入你，而你会惊讶于自己的努力像雪球一样 越滚越大。\ncontver...into (使)转变,转换，转化 The results may pave the way for the development of new therapies to“convert cancer into a cortollabl chronic disease\u0026quot;，wite the researchers.研究人员称，该结果可能为研究新疗法铺平道路,将“使癌症转变成业种可控制的慢性疾病”\nSoil amelioration and ample supply of nutrients in the form of fertilizers are needed to convert poor soils into produective agicultural land.要使这些贫瘠的土壤转变成具有农业生产力的土壤需要进行土壤改良并施加足够的肥料。\na walk of life行业;职业;地位;阶层 She did not want her son to mary a girl in a diferete walk of life. 她不希望儿子和一个门当户不对的姑娘结婚。\nDuring my twenty yeas\u0026rsquo; work,I met people from all walks of life. 20年的职业生涯中,我接触了各行各业的人。\nmajor in主修 I major in engineering,but this machine is hard to handlefor me.虽然我学的是机电专业,但这机器对我来说，还是很难操作。\nEven today，more men major in math than do women.即便在今天,学数学的男生还是多于女生。\nstress the importance of强调\u0026hellip;\u0026hellip;的重要性 There is no need for me to stress the importance of self esteem here. 在这儿我没有必要强调自尊的重要性。\nThe policy document does stress the importance of dialogue between Seoul and Pyongyang.这份政策文件的确强调了首尔与平壤对话的重要性。\nat one's disposal任某人处理;供某人任意使用 One of the downfalls of being in a field that has so many resources available online is that it\u0026rsquo;s easy to forget about all of the great ofline resources at your disposal.做这行一个不好的地方就是,网上有太多的资源以致忘记了网下还有丰富的资源任你使用。\nThere\u0026rsquo;s no way of representing architectural structures directly using the technologies we have at our disposal.我们手头的技术还不能直接地展示建筑结构。\npoke fun at拿\u0026hellip;\u0026hellip;开心:奚落;嘲笑 You shouldn\u0026rsquo; t poke fun at him just because he can’t ride a bicycle.你不应该只是因为他不会骑车就取笑他。\nWe all poke fun at her because she wears such a strange hat.我们大家都笑她戴这么一顶古怪的帽子。\nshow off炫耀;卖弄 He shows off but only shows up his ignorance.他的卖弄只不过暴露了他自己的无知。\nShe did a quick twirl show of her dress她轻快地一转身,炫罐自己所穿的衣服。\nbiological mother生母 He was eager to know who was his biological mother.他迫切想知道他的生母是谁。\nJobs and Simpson first met in 1986, after 31-year-old Jobs reunited with his biological mother.31岁的乔布斯和生母重聚后，又和辛普森在1986年首次见面。\nmeet one’s expectations 符合某人的期望 If these deals meet KKR’s expectations，at least one industry watcher thinks they\u0026rsquo;ll be exceptions.至少有一位行业观察人士认为，即使上述交易的投资回报符合KKR的预期，那也只是特例。\nShe has a strong tendency to blame herself and to try and meet everyone else\u0026rsquo; s expectations，which is one reason she is so depressed.她有很强烈的自责倾向，并且总是努力想要满足所有人的期望，这也是导致她如此沮丧的原因之一\ndrop out退学;辍学 The boys lived，but the ilness induced by their exposure to poison gas forced them to drop out of school.这些男孩活了下来,但是毒气造成的疾病让他们被迫退学。\nSome of them drop out，rejecting any social responsibility，leading a parasitic life.他们当中的有些人脱离传统的社会活动,拒绝承担任何社会责任,过着颓废的寄生生活。\nin memory of作为对\u0026hellip;\u0026hellip;的纪念 The museum was built in memory of the famous scientist. 这个博物馆是为了纪念那位著名的科学家而建立的。\nShe set up an educational fund in memory of her mother.她为了纪念她母亲而设立了一个教育基金会。\ndwell on老是想着(尤指最好忘记的事) High achievers dwell on what they can do well\u0026ndash;and spend very little time evaluating themselves and their performances.成功人士会细想他们能做好什么一并 且花很少的时间去评价自己和自己的表现。\nturn out原来是;证明是;结果是 Unfortunately they do not turn out to be more creative; they only feel that way.不幸的是，他们最终并没有更具创造力；那只是他们的感觉而已。\nIf Spain falls into crisis, then all current mechanisms for dealing with the crisis will turn out be inadequate.如果西班牙陷入危机，那么所有当前的危机处理机制都是不够的。\nend up最终成为;最后处于 If you continue to steal you\u0026rsquo;ll end up in prison. 你要是继续行窃终归得进监狱。\nAt fist he refused to accepl any responsibility but he ended up apologizing.最初他拒不承认有任何责任，到头来还是道了歉。\nkeep up with (与\u0026hellip;\u0026hellip;)齐步前进;并驾齐驱;跟上 Workers\u0026rsquo; incomes are not keeping up with inflation. 工人的收人赶不上通货膨胀。\nShe likes to keep up with the latest fashion.她喜欢紧跟时尚。\nget over解决:克服:控制 \u0026ldquo;How would they get over that problem?\u0026rdquo; he wondered. “他们会怎 么解决那个问题?”他寻思着。\nI hope you\u0026rsquo;ll get over being angry.我希望你克制住,不要生气。\nwear out使疲乏;使筋疲力尽;使厌烦 The effect of the continuous attacks has been to waar out his troops.接连不断的攻击就是要拖垮他的军队。\nIt is better to wear out than rust out.与其懒死，不如累死。\nwith ease轻而易举地 They gained the game with ease.他们很轻松地赢得了这场比赛。\nThey are expected to win the election with ease.预计他们在竞选中能够轻易获胜。\nmake it获得成功；做到 He\u0026rsquo;s never really made it as an actor.他当演员从未有所成就。\nHe poured in every ounce of power but couldn\u0026rsquo;t make it. 他竭尽了全力却无济于事\nfall over被\u0026hellip;\u0026hellip;绊倒;几乎被\u0026hellip;\u0026hellip;绊倒 He ran up the top of the hill,only to fall over the rock. 他跑向山顶，却被那块岩石绊倒在地。\nHe began to fall over his own feet.他开始踉跄地摔倒。\nlook back on回首往事;回忆;回顾 I still shudder when I look back on the past. 想起过去，我仍然不寒而栗。\nShe cean look back on her life with great saifaction.她回顾自己的生活觉得心满意足。\nwith the aid of在\u0026hellip;\u0026hellip;的帮助下 With the aid of a compass the traveler can find his bearings.借助罗盘，旅行者可以找到自己所处的方位。\nHe walkls with the aid of a heavy stick. 他靠着一根笨重的手杖走路。\nmake one's way去;前往;到\u0026hellip;\u0026hellip;地方去 I\u0026rsquo;ll make my way home now.我要回家了。\nHe tries to make his way in life.他尽力在生活中有所成就。\ngo off突然发出巨响 The freeracker didn\u0026rsquo; t go off.爆竹没响。\nThen the fire alarm went off.I just grabbed my clothes and ran out.当时火险警报器响了，我一把捉起衣服就往外跑。\nat one point在某个时刻 He became very depressed and even got suicidal at one point.他变得十分消沉，甚至一度想自杀。\nAt one point, it seemed that the plane would fall apart in the shaking.在某个时刻，飞机看来就要被震碎了。\nall of a sudden突然;猛地 All of a sudden he turned about and saw me.他突然转过身来看见了我。\nThe wind dropped all of a sudden.风突然停了下来\ngo wrong出毛病，发生故障;遇到麻烦 The television has gone wrong again.电视机又出毛病了。\nSurely you won\u0026rsquo;t go wrong if you follow his advice.听他的话，你就肯定不会出错。\nbend down弯腰,俯身 Can you bend down and touch your toes without bending your knees?你能弯下腰,不屈膝摸着你的足趾吗?\nI bend down one more time to say good-bye. 我再次俯下身来道别。\nbask in晒太阳;取暖 Turtles like to bask in the sun.海龟喜欢晒太阳。\naccount for (数量上、比例上)占 These products, in total, account for about 80% of all our sale.这些产品总共约占我们全部销售额的80%。\nComputers account for 5% of the country\u0026rsquo;s commercial electricity consumption.计算机用电占去该国商业用电的5%。\nbe reliant upon依赖;依靠 These people are not wholly reliant upon/on Western chariy.这些人并非完全依赖西方慈善团体。\nThe service has become hevily reliant on/upon govemment support.这项服务变得高度依赖政府扶持。\nbe attributed to把\u0026hellip;\u0026hellip;归因于;认为\u0026hellip;..是由于 The car accident was attributed to faulty brakes. 这次车祸被认为是刹车失灵造成的，\nHer success was attributed to hard work and a bit of luck.她的成功归功于勤奋加一点儿运气。\nsave up攒钱;储存钱 You\u0026rsquo;d better save up some money for your old age.你最好积蓍些钱以防老。\nI\u0026rsquo;l1 have to get something else and save up.我得找些别的事情做，攒起钱来。\npick up让人乘车;搭载 I\u0026rsquo;ll pick you up at 7 o\u0026rsquo;clock.七点钟我开车来接你。\nHe picked up a hitch-hiker.他中途让一个搭便车的人上了车。\nby and large大体上;总体上 By and large，women can bear pain better than men.一般来说，女人比男人更能忍受痛苦\nThis practice is not good by and large.一般说来,这种做法并不太好。\nconduct oneself举止;表现 How did the prisoner conduct himself? 那个犯人表现得如何?\nNo matter in what place or at what time ,it is all the most important to conduct oneself.不管在什么地方，什么时候，做人都是最重要的\nin public公开地;在别人(尤指生人)面前 It\u0026rsquo;s bad manners to pick one\u0026rsquo;s teeth in public.在公共场合剔牙很失礼。\nThe man showed off his wealth in public那人公开炫耀自己的财富。\nsave on节省；节约 I think shopping at the supermarket can save (on) time and money. 我认为在超级市场采购可以省时省钱。\nIf we all go in one car,we\u0026rsquo;ll save on petrol. 如果我们大家挤在一辆车里，就可以节省汽油。\nkeep tabs on监视;密切注视 Some of Europe S top clubs will send their scouts to keep tabs on the international player.一些欧洲豪门俱乐部会派遣他们的球探密切关注这位国际球员。\nLet\u0026rsquo;s keep close tabs on expenditures.让我们密切注意开支情况。\nGod/Heaven/Lord forbid (that)但愿这事不发生 God forbid that I should ever have to work with him again.但愿我不必再与他共事。\nGod forbid that he should injure you!但愿他不会伤害你!\nhead over heels in love深深地爱着某人;迷恋 Tom was soon head over heels in love with her. 汤姆很快就爱上了她,而且为之倾倒。\nI have been head over heels in love with a wonderful woman.我已不能自拔地爱上了一个出色的女人。\nbutterflies in the stomach心里七上八下 When he was assiened to interriew the President,he had butterflies in his stomach.当被安排采访总统时，他心里七上八下的。\nI could feel the butterflies in my stomach as I waited.在等待的时候我非常紧张。\ndeprive...of...剥夺;使丧失的 The accident deprived her of her life. 那场事故夺去了她的生命。\nThat law deprived me of my most basic rights.那条法律把我最基本的权利都剥夺了。\nbecome accustomed to...习惯于\u0026hellip;. The panda has long become accustomed to the huge crowds of visitors.大熊猫对人山人海的参观者已经习以为常了。\nHis new office lacked the spaciousness that he had become accustomed to.他的新办公室没有他已经习惯的那种宽敞的空间。\ntake up占去 The job took up most of Sunday.这项工作占用了大半个星期天，\nThe entire memo took up all of two pages.整个备忘录写了满满两页纸。\nin this respect在这方面 We have had many lessons in this respect.这方面我们有过不少教训。\nWe have suffered some setbacks in this respect. 在这一方面我们遭受了一些挫折。\nbring...to light揭露;披露;揭发 An old saying goes that time will bring to light whatever is hdden俗话说得好，时间自会让隐藏的一切水落石出。\nI will bring the truth to light. 我要揭露真相。\npile up堆积:积压 Mail was still piling up at the office.办公室里的邮件仍在往上堆。\nHe piled up huge debts. 他债台高筑\ncome down with患,得，染上(小病) The boy has come down with influenza.这个男孩得了流行性感冒。\nWe come down with ilneses more easily when under stress. 在有压力的情况下,我们更容易生病。\nslip away消失;消亡;死去 I hope we can slip away before she notices. 我希望我们在她未见到我们之前就悄悄地离开这儿。\nAha you can\u0026rsquo;t slip away this time.哈哈，这回你溜不掉了。\nrespond to作出反馈;响应 The woman conductor kindly responded to my question. 女列车员亲切地回答了我的问题\nThe teacher responded afirmatively to the question that student put forward.老师对那个学生的问题作了肯定的回答\ncare for照顾，照料(病、老、幼者等) The mother cared for the sick child day and night.母亲日夜照料着生病的孩子。\nI am glad to see that you are being well cared for. 看到你得到很好的照料，我很高兴。\ntend to照料;照管;护理 In our culture,girls are brought up to tend to the needs of others.在我们的文化里,女孩从小就学着照料别人。\nShe hurried away to pour more coffee and tend to the grill.她匆忙走开，去添加咖啡和照看烤架。\nput..down使(当众)出丑;使出洋相;让某人现眼 She learned to stop puting herself down and comparing herself to others.她学会了不再自我贬低，拿自己与别人相比。\nI know that I do ptple down occasionally.我知道我确实偶尔会奚落别人。\ngo through经历:遭受 South Africa was going through a period of irreversible change.南非正在经历一场不可逆转的变革。\nHe was going through a very difcult time.他正处于非常艰难的时期。\nbe linked to与\u0026hellip;有联系 About two billion dollars in loans would be linked to progress in government reforms. 近20亿美元贷款将与政府改革的进展情况联系起来。\nShe says the findings do not explain why belly fat may be linked to dementia.她说研究结果尚不能解释腹部脂肪为什么可能与痴呆相联系。\nfill out膨胀;扩张;长胖;长肥 The underweight child has begun to fill out after regular exercises. 这个偏瘦的孩子在进行了二段有规律的锻炼后开始长壮了。\nHer cheeks began to fill out after she\u0026rsquo;d been in the convalescent hospital for a couple of months.在疗养院养了两个月以后，她的脸渐渐变圆了。\nfeel good感到愉快（或有信心灯） Music makes me feel good.音乐让我感觉好极了。\nWhat makes you feel good?什么使你感到高兴\nkeep track of了解的情况(或动态)。 How do you keep track of it all?你怎么搞清状况？\nAs a doctor,Brooks has to keep track of the latest developments in medicine.作为一名医生,布鲁克斯必须了解医学的最新发展动态。\n","permalink":"https://bablvsj.github.io/posts/exams/english-%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86-%E6%A0%B8%E5%BF%83%E7%9F%AD%E8%AF%AD/","summary":"apply to使用;应用 The convention does not apply to us.这条惯例对我们不适用。 His project is concerned with applying the technology to practical business problems. 他的项目关系到将这项技术应用于实际的商务问题。 put forth提","title":"English 第三部分 核心短语"},{"content":"一、万能句子\n关于\u0026hellip;\u0026hellip;人们有不同的观点。一些人认为\u0026hellip;\u0026hellip; There are different opinions among people as to ______.Some people suggest that ______.\n俗话说(常言道)\u0026hellip;\u0026hellip;它是我们前辈的经历，但是，即使在今天，它在许多场合仍然适用。 There is an old saying ______.It\u0026rsquo;s the experience of our forefathers,however,it is correct in many cases even today.\n现在\u0026hellip; ,它们给我们的日常生活带来了许多危害。首先，.其次，\u0026hellip;\u0026hellip;更为槽糕的是 Today,,which have brought a lot of harms in our daily life.First,,Second,.What makes things worse is that.\n现在，很普遍,许多人喜欢\u0026hellip;\u0026hellip;因为\u0026hellip;\u0026hellip;另外(而且)\u0026hellip;\u0026hellip; Nowadays,it is common to______. Many people like______ because______.Besides,______.\n任何事物都有两面性，\u0026hellip;\u0026hellip;也不例外。它既有有利的一面,也有不利的一面。 Everything has two sides and ______ is not an exception,it has both advantages and disadvantages.\n关于\u0026hellip;\u0026hellip;人们的观点各不相同，一些人认为（说）\u0026hellip;\u0026hellip;，在他们看来，\u0026hellip;\u0026hellip; People\u0026rsquo;s opinions about ______ vary from person to person.Some perple say that______.To them,______.\n人类正面临着一个严重的问题\u0026hellip;\u0026hellip;，这个问题变得越来越严重。 Man is now facing a big problem______ which is becoming more and more serious.\n\u0026hellip;\u0026hellip;已成为人的关注的热门话题，特别是在年轻人当中，将引发激烈的辩论。 ______has become a hot topic among people,especially among the young and heated debates are right on their way.\n\u0026hellip;\u0026hellip;在我们的日常生活中起着越来越重要的作用，它给我们带来了许多好处，但同时也引发一些严重的问题。 ______has been playing an increasingly important role in our day-to-day life.It has brought us a lot of benefits but has created some serious problems as well.\n根据表格/图表/条形图/线形图中的数字/统计数字/表格中的百分比可以看出\u0026hellip;\u0026hellip;。很显然\u0026hellip;\u0026hellip;，但是为什么呢？ According to the figure/number/statistics/percentages in the table/chart/bar graph/line graph,it can be seen that______.Obviously,______,but why?\n(二)中间段落句\n相反，有一些人赞成\u0026hellip;\u0026hellip;他们相信\u0026hellip;\u0026hellip;，而且，他们认为\u0026hellip;\u0026hellip; On the contrary, there are some people in favor of______.At the same time, they say______.\n但是，我认为这不是解决\u0026hellip;\u0026hellip;的好方法，比如\u0026hellip;\u0026hellip;。最糟糕的是\u0026hellip;\u0026hellip; But I don\u0026rsquo;t think it is a very good way to solve______.For example,.Worst of all,.\n\u0026hellip;\u0026hellip;对我们国家的发展和建设是必不可少的,(也是)非常重要的。首先，\u0026hellip;\u0026hellip;。而且\u0026hellip;\u0026hellip;，最重要的是\u0026hellip; is necessary and important to our country\u0026rsquo;s development and construction.First,.What\u0026rsquo;s more,.Above all,.\n有几个可供我们采纳的方法。首先，我们可以\u0026hellip;\u0026hellip; There are several measures for us to adopt. First,we can______.\n面临\u0026hellip;\u0026hellip;,我们应该采取一系列行之有效的方法来\u0026hellip;\u0026hellip;。一方面，另一方面,\u0026hellip;\u0026hellip; Confronted with______,we should take a series of effective measures to______.For one thing,_For another,\n早就应该拿出行动了。比如说\u0026hellip;\u0026hellip;，另外\u0026hellip;\u0026hellip;。所有这些方法肯定会\u0026hellip;\u0026hellip; It is high time that something was done about it.For example,.In addition,.All these measures will certainly______.\n为什么\u0026hellip;\u0026hellip;？第一个原因是\u0026hellip;\u0026hellip;；第二个原因是\u0026hellip;\u0026hellip;;第三个原因是\u0026hellip;\u0026hellip;。总的来说，\u0026hellip;\u0026hellip;的主要原因是\u0026hellip;\u0026hellip; Why______?The first reason is that .The second reason is that.The third is that______.For all these,is mainly due to.\n然而，正如任何事物都有好坏两个方面一样，\u0026hellip;\u0026hellip;也有他的不利的一面，像\u0026hellip;\u0026hellip; However,just like everything has both its good and bad sides,also has its own disadvantages,such as.\n尽管如此，我相信\u0026hellip;\u0026hellip;更有利。 Nonetheless,I believe that______is more advantageous.\n完全同意\u0026hellip;\u0026hellip;这种观点，主要理由如下： I fully agree with the statement that______because______.\n(三)结尾句\n至于我,在某种程度上我同意后面的观点，我认为\u0026hellip; As far as I am concerned, I agree with the latter opinion to some extent.I think that______.\n总而言之，整个社会应该密切关注\u0026hellip;\u0026hellip;这个问题。只有这样，我们才能在将来\u0026hellip;\u0026hellip; In a word，the whole society should pay close attention to the problem of______.Only in this way can we______in the future.\n但是,\u0026hellip;\u0026hellip;和\u0026hellip;\u0026hellip;都有它们各自的优势(好处)。例如,\u0026hellip;\u0026hellip;,而\u0026hellip;\u0026hellip;。然而,把这两者相比较,我更倾向于(喜欢）\u0026hellip;\u0026hellip; But______and______have their own advantages. For example,,while.Comparing this with that，however,I prefer to______.\n就我个人而言，我相信\u0026hellip;\u0026hellip;,因此,我坚信美好的未来正等着我们。因为\u0026hellip;. Personally,I believe that______.Consequently, I\u0026rsquo;m confident that a bright future is awaiting us because______.\n随着社会的发展，\u0026hellip;\u0026hellip;。因此，迫切需要\u0026hellip;\u0026hellip;。如果每个人都愿为社会贡献自己的一份力量,这个社会将会变得越来越好。 With the development of society,.So it\u0026rsquo;s urgent and necessary to.If every member is willing to contribute himself to the society,it will be better and better.\n至于我(对我来说，就我而言)，我认为\u0026hellip;\u0026hellip;更合理。只有这样，我们才能\u0026hellip;\u0026hellip; For my part,I think it reasonable to______.Only in this way can we______.\n依我看，有必要\u0026hellip;\u0026hellip;。原因如下:第一\u0026hellip;\u0026hellip;;第二,\u0026hellip;\u0026hellip;最后但同样重要的是\u0026hellip;\u0026hellip; In my opinion, it is necessary to______.The reasons are as follows. First,.Second,.Last but not least,______.\n在总体上很难说\u0026hellip;\u0026hellip;是好还是坏,因为它在很大程度上取决于\u0026hellip;\u0026hellip;的形势。然而，就我个人而言,我发现\u0026hellip;\u0026hellip; It is difcult to say whether______ is good or not in general as it depends very much on the situation of______.However,from a personal point of view,I find______.\n综上所述，我们可以清楚地得出结论\u0026hellip;\u0026hellip; From what has been discussed above, we may reasonably arive at. the conclusion that______.\n如果我们不采取有效的方法，就可能控制不了这种趋势，就会出现一些意想不到的不良后果，所以,我们应该做的\u0026hellip;\u0026hellip; If we don\u0026rsquo;t take useful means , we may not be able to control this trend, and some undesirable result may come out unexpectedly，so what we should do is______.\n二、写作模板\n(一)英语书信的常见写作模板\n开头部分:\nHow nice to hear from you again.\nLet me tell you something about the activity.\nI\u0026rsquo;m glad to have received your letter of Apr.9th.\nI\u0026rsquo;m pleased to hear that you’re coming to China for a visit.\nI\u0026rsquo;m writing to thank you for your help during my stay in America.\n结尾部分:\nWith best wishes.\nI\u0026rsquo;m looking forward to your reply.\nI\u0026rsquo;d appreiate it if you could reply earlier.\n(二)口头通知常见写作模板\n呼语及开场白部分:\nLadies and gentlemen , May I have your attention , please? I have an announcement to make.\n正文部分:\nAll the teachers and students are required to attend it.\nPlease take your notebooks and make notes.\nPlease listen carefully and we\u0026rsquo; 11 have a discussion in groups.\nPlease come on time and don\u0026rsquo;t be late.\n结束语部分:\nPlease come and join in it.\nEverybody is welcome to attend it.\nI hope you\u0026rsquo;ll have a nice time here.\nThat\u0026rsquo;s all. Thank you.\n(三)议论文模板\n正反观点式议论文模板 导入：\n第1段: Recently we\u0026rsquo; ve had a discussion about whether we should..(导入话题)\nOur opinions are divided on this topic. (观点有分歧)\n正文\n第2段: Most of the students are in favour of it. (正方观点)\nHere are the reasons. Firt\u0026hellip;Second\u0026hellip;Finally\u0026hellip;(列出2~3个赞成的理由)\n第3段:However,the others are strongly against it. (反方观点)\nTheir reasons are as follows. In the first place\u0026hellip; What\u0026rsquo;s more\u0026hellip; In addition\u0026hellip;(列出2~3个反对的理由)\n结论：\n第4段: Personally speaking ，the advantages overweigh the disadvantages ,for it will do us more good than harm,s0 I support it. (个人观点)\n“A或者B\u0026quot;类议论文模板 导入:\n第1段:Some people hold the opinion that A is superior to B in many ways. Others，however，argue that B is much better. Personally,I would prefer A because I think A has more advantages.\n正文：\n第2:段:There are many reasons why I prefer A. The main reason is that.. Another reason is that\u0026hellip;(赞同A的原因)\n第3段:Of course,B also has advantages to some extent\u0026hellip;(列出1~2个B的优势)\n结论:\n第4段: But if all these factors are considered, A is much better than B. From what has been discussed above，we may finally draw the conclusion that\u0026hellip;( 得出结论)\n观点论述类议论文模板 导入：\n第1段:提出一种现象或某个决定作为议论的话题\nAs a student,I am strongly in favour of the decision. (亮明自己的观点是赞成还是反对)\nThe reasons for this may be listed as follows. (过渡句,承上启下)\n正文：\n第2段:First of all\u0026hellip;Secondly\u0026hellip;Besides\u0026hellip;列出2 ~3个赞成或反对的理由)\n第3段:In conclusion,I believe that\u0026hellip;(照应第1段,构成“总-分-总”结构)\n“How to”类议论文模板 导入：\n第1段:提出一种现象或某种困难作为议论的话题\n正文:\n第2段:Many ways can help to solve this serious problem, but the following may be more effective. First of all\u0026hellip; Another way to solve the problem s..Finally\u0026hellip;(列出2 ~3个解决此类问题的办法)\n结论：\n第3段:These are not the best but only two/three measures we can take. But it should be noted that we should take action t\u0026hellip;(强调解决此类问题的根本方法)\n(四)图表作文写作模板\nThe chart gives us an overall picture of the(图表主题). The first thing we notice is that(图表最大特点). This means that as (进步说明).\nWe can see from the statistics given that(图表细节一). After v-ing(细节一中的第一个变化),thev-ed+幅度+时间(紧跟着的变化).The figures also tell us that(图表细节二).In the column, we can see that accounts for (进一步描述)\nJudging from these figures，we can draw the conclusion that (结论). The reason for this, as far as I am concerned is that(给出原因)./It is high time that we(发出倡议).\n(五)图画类写作模板\n开头：\nLook at this picture. /The picture shows that\u0026hellip;/From this picture, we can see\u0026hellip;/As is shown in the picture\u0026hellip;/ As is seen in the picture\u0026hellip;\n衔接句:\nAs we all know,\u0026hellip;/ As is known to all,\u0026hellip;It is well known that\u0026hellip;/In my opinion,\u0026hellip;/As far as I am concerned,\u0026hellip;/This sight reminds me of something in my daily life.\n结尾句:\nIn conclusin\u0026hellip;/In brief\u0026hellip;/On the whole\u0026hellip;/In short\u0026hellip;/In a word\u0026hellip;/Generally speaking\u0026hellip;/As has been stated\u0026hellip;\n","permalink":"https://bablvsj.github.io/posts/exams/english-%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86-%E4%B8%87%E8%83%BD%E5%8F%A5%E5%AD%90%E5%92%8C%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF/","summary":"一、万能句子 关于\u0026hellip;\u0026hellip;人们有不同的观点。一些人认为\u0026hellip;\u0026hellip; There are different opinions among people as to ______.Some people suggest that ______. 俗话说","title":"English 第四部分 万能句子和写作模板"},{"content":" 计算机信息管理专业课程\n自考笔记在线更新地址 : https://github.com/Eished/self-study-exam_notes\n配套代码：https://github.com/Eished/C-CPP\n大纲 (2019版) 考试题型 单选题 1分x20题 = 20分 填空题 1分x15题 = 15分 程序填空题 4分x5题 = 20分 程序分析题 5分x6题 = 30分 程序设计题 5分x1题 = 5分 10分x1题 = 10分 IDE 书本推荐：Dev C++ 5.11\n本人使用：VScode\n配置文件在附录\nVScode 执行完会自动关闭终端, return 前设置断点\n或者修改 launch.json 文件为 \u0026quot;externalConsole\u0026quot;: false, 内置终端支持 utf-8 使用外置终端，utf-8 中文乱码问题, 在 vs code 修改代码的打开和保存方式\n直接就将代码保存为 gb2312。在 vs code 右下角可以看到当前文件编码方式，点击utf-8 修改打开和保存方式为 gb2312。\n学习建议 先大概看一遍全书，有整体概念，做习题时再去细看不懂的地方，重点都在内容小结部分。 习题代码写一遍，遇到不懂的再翻书或去网上查，例题代码一般不用写看懂就行。 学习本课程之前需具备较好的C语言基础（如基本的语法知识和三大程序结构等） C语言基础 标识符可以由3种字符组成：字母、下划线、数字，并且不能以数字开头，不能是C++的关键字。\n语句以分号;结束\n第一章 C++ 语言简介 C++发展历史，与C语言的异同 C++是C的一个超集，进一步扩充和完善了C，C++比C更安全。 C++是一种编译式、通用式、大小写敏感的编程语言，完全支持面向对象程序设计。 掌握C++ 程序结构，正确使用头文件及命名空间 基本输入/输出 函数声明和传参 函数重载概念 理解 const ，指针，引用，动态内存分配和释放 string 类基本功能 第一节 C++发展简史 低级语言：机器语言，汇编语言 中级语言：C语言 高级语言：面向用户，易懂、通用。 第二节 C++特点 编译式、通用、大小写敏感，支持面向对象 特点 继承和兼容C 语言，简洁高效 面向对象 一、基本输入/输出 标准输入 1 cin \u0026gt;\u0026gt; 变量1 \u0026gt;\u0026gt; 变量2 \u0026gt;\u0026gt;... \u0026gt;\u0026gt; 变量n; 标准输出 1 cout \u0026lt;\u0026lt; 表达式1 \u0026lt;\u0026lt; 表达式2 \u0026lt;\u0026lt; ...\u0026lt;\u0026lt; 表达式n; 头文件 1 2 #include \u0026lt;iostream\u0026gt; // 头文件：输入输出流 using namespace std; // 使用命名空间 换行操作 1 用语句 cout \u0026lt;\u0026lt; endl; 或 cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 运算符重载后才可以使用 输入：空格、TAB、ENTER 作为分隔符\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 1, b = 2; cin \u0026gt;\u0026gt; a \u0026gt;\u0026gt; b; cout \u0026lt;\u0026lt; \u0026#34;Hello Vscode\\n\u0026#34; \u0026lt;\u0026lt; a * b \u0026lt;\u0026lt; endl; return 0; } 输入/输出示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { int oneInt1, oneInt2; char strArray[20]; string str; double oneDouble; char oneChar = \u0026#39;a\u0026#39;; cout \u0026lt;\u0026lt; \u0026#34;输入两个整型值，一个字符，一个字符串，一个浮点值,\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;以空格、tab、enter 键分割\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; oneInt1 \u0026gt;\u0026gt; oneInt2 \u0026gt;\u0026gt; oneChar \u0026gt;\u0026gt; strArray \u0026gt;\u0026gt; oneDouble; str = strArray; cout \u0026lt;\u0026lt; \u0026#34;输入的数据是:\u0026#34; \u0026lt;\u0026lt; endl; //endl 是换行 cout \u0026lt;\u0026lt; \u0026#34;字符串:\\t\\t\u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl //\\t是制表符 \u0026lt;\u0026lt; \u0026#34;两个整型值:\\t\u0026#34; \u0026lt;\u0026lt; oneInt1 \u0026lt;\u0026lt; \u0026#34;和\\t\u0026#34; \u0026lt;\u0026lt; oneInt2 \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;字符:\\t\\t\u0026#34; \u0026lt;\u0026lt; oneChar \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; //\u0026#34;\\n\u0026#34;是换行符,与endl相同 \u0026lt;\u0026lt; \u0026#34;浮点值:\\t\\t\u0026#34; \u0026lt;\u0026lt; oneDouble \u0026lt;\u0026lt; endl; return 0; } cin 实现键盘输入，输入字符类型时根据变量类型自动提取相应长度字节, 数值类型数据需要分隔\ngetchar(): 获取 space\\tab\\enter 等特殊字符\n1 2 cout \u0026lt;\u0026lt;\u0026#34;1234\\ //\u0026#34;\\\u0026#34; 用于连接换行的内容 566785\u0026#34;\u0026lt;\u0026lt;endl; cout 自动识别输出类型 指针运算法* ，为取元素的内容\n二、头文件和命名空间 1.头文件 是用户应用程序和函数库之间的桥梁和纽带。作为一种包含功能函数、数据接口声明的载体文件，主要用于保存程序的声明，而定义文件用于保存程序的实现。\n头文件保存程序中用到的声明，如函数声明、常量定义等，需要使用预处理命名包含头文件#include 常用的头文件 标准输入输出流: \u0026lt;iostream\u0026gt; 标准文件流: \u0026lt;fstream\u0026gt; 标准字符串处理函数: \u0026lt;string\u0026gt; 标准数学函数: \u0026lt;cmath\u0026gt; 自定义头文件 \u0026lt;\u0026gt;: 系统设定目录寻找, 未找到再去指定目录找 “”: 用户当前目录或指定目录找 #include \u0026quot;e:\\myprog\\ex1.h\u0026quot; 2.命名空间 namespace 命名空间是一种将程序库名称封装起来的方法，提高了程序的性能和可靠性，可消除同名引起的冲突。 标准程序库的命名空间 using namespace std;\n1 2 3 4 namespace 命名空间名 { 命名空间内各种声明(函数声明\\类声明) } 引用命名空间标识符\n不引用命名空间, 则使用全称: 命名空间名::标识符名 1 2 using 命名空间名::标识符; // 单独引用 using namespace 命名空间名; // 引用整个命名空间 3.强制类型转换 将一种数据类型转换成另一种数据类型 1 2 3 4 5 6 7 stati_cast\u0026lt;类型名\u0026gt;(表达式); 下面四种方式，强制转换都是可以的 oneint2 = static_cast\u0026lt;int\u0026gt;(oneDouble); oneint2 = int(oneDouble); oneint2 = (int)oneDouble; // 圆括号 oneint2 = oneDouble // 自动类型转换 例子：强制类型转换\n1 2 3 4 5 6 int b; float fa = 30.45; b = static_cast\u0026lt;int\u0026gt;(fa); b = int(fa); b = (int)fa; // 旧有强制转换的形式 b = fa; // 自动类型转换 stati_cast\u0026lt;类型名\u0026gt;(表达式); 功能： 将常量指针转化成非常量的指针，并且仍然指向原来的对象； 将常量引用转换成非常量的引用，并且仍然指向原来的对象。 1 2 3 4 5 6 7 8 9 10 int a = 10,*q; const int ca = 30; const int *p = \u0026amp;a; // 不能使用常量指针p修改a的值 q = const_cast\u0026lt;int *\u0026gt;(p); // 不能q=p *q = 20; // 变量a的值变为20，不能形成*碰= 20； p = \u0026amp;ca; // ca的值不能修改 q = const_cast\u0026lt;int *\u0026gt;(p); // 不能 q=p *q = 40; // *q的值为40，*p的值变成40，变量ca的值仍然是30 三、函数的应用 1.函数参数的默认值 默认参数就是不要求设定参数，未设置参数时有赋默认值。 默认参数是在函数原型中说明的，默认参数可以多于1个，但必须放在参数序列的末尾。 声明函数时为形参指定默认值\n默认值可以写在函数声明或函数定义的地方, 但不能都写 void 声明无返回值 默认值不能是局部变量，调用函数可以用局部变量 默认值的形参必须从右至左提供, 有形参的必须在最后\n调用时实参为从左至右连续排列，不给则后面取默认值 函数原型中, 可省略形参名字, 只给出类型和默认值\n1 2 void defaultvalue1(int = 2,double = 3.0 ) void defaultvalue1(int a,double b = 3.0) 2.引用和函数参数的传递 2.1 引用 引用相当于给变量取了一个别名，对应同一个内存地址。\n引用的定义格式：类型名 \u0026amp;引用名 = 同类型的某变量名\n1 2 3 4 5 6 7 8 9 10 11 12 13 int oneInt = 9; int \u0026amp;aname = oneInt; //声明引用, aname 是引用名 // aname 就是x的一个引用，可以有多个引用 ``` - 引用的规则 - **对象在被引用前必须先初始化** - 声明中符号“\u0026amp;”的位置无关紧要 ```c++ 以下情况等效 int\u0026amp; a = x; int \u0026amp; a = x; int \u0026amp;a = x; 只能引用已经初始化的变量 不能用常量初始化引用 不能声明引用的引用 不能用表达式初始化引用, 除非表达式返回值是引用 同一个变量可有多个引用 2.2 常引用 在定义前加 const 表示 “常引用”\n不能通过常引用修改其引用的变量, 普通引用可以修改变量的值 变量可以初始化常量(常引用), 常量(常引用)不能初始化变量 1 2 3 4 5 6 7 8 9 10 int oneInt = 10; const int \u0026amp;cname = oneInt; int \u0026amp;a = oneInt; // a 是 oneInt的一个普通引用 const int \u0026amp;b = oneInt; // b 是 oneInt的一个常引用 a = 20; // 则 oneInt = 20, b =20 oneInt = 30; // a = 30，b = 30; b = 40; // 错误 1 const T\u0026amp; 和 T\u0026amp;是不同的类型 类型转换: 1 2 3 4 const int cInt = 30; const int \u0026amp; rc1 = cInt; //CT\u0026amp;←CT, CT\u0026amp; 表示类型 T 的常引用 int \u0026amp;r2 = (int \u0026amp;) rc1; //T\u0026amp;←CT\u0026amp; 强制类型转换 int \u0026amp;r3 = (int \u0026amp;) cInt; //T\u0026amp;←CT 强制类型换换 T 表示类型 CT 表示常量类型 T\u0026amp; 表示 T 类型的引用 CT\u0026amp; 表示 T 类型的常引用 2.3 引用在函数中使用 引用作为函数的参数, 也可作为函数的返回值 函数参数的传递方式 传值：传递对象的值，形参是实参的副本，形参的改变不会影响实参。 传引用： 传递对象的首地址值(等同于指针)，形参的改变意味着实参的改变。\n变量、指针、引用都可以作为赋值语句的左值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u0026lt;iostream\u0026gt; using namespace std; void SwapValue(int a, int b) //形参 { int tmp; tmp = a; a = b; b = tmp; cout \u0026lt;\u0026lt; \u0026#34;在SwapValue()函数中:\\t\\ta=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return; } void SwapRef(int \u0026amp;a, int \u0026amp;b) //a,b 实参引用地址的值互换 { int tmp; tmp = a; a = b; b = tmp; cout \u0026lt;\u0026lt; \u0026#34;在SwapRef()函数中:\\t\\ta=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; return; } int main() { int a = 10; int b = 20; cout \u0026lt;\u0026lt; \u0026#34;数据交换前:\\t\\ta=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; SwapValue(a, b); cout \u0026lt;\u0026lt; \u0026#34;SwapValue后:\\t\\ta=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; a = 10; b = 20; SwapRef(a, b); cout \u0026lt;\u0026lt; \u0026#34;SwapRef后:\\t\\ta=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34;, b=\u0026#34; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; return 0; } 引用作为函数的返回值 赋值语句左边的叫左值, 右边的叫右值 - 变量\\指针\\引用 可作左值 - 表达式作右值\n格式 数据类型 \u0026amp; 函数名(参数列表) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include \u0026lt;iostream\u0026gt; using namespace std; int oneX = 10; int oneY = 20; int \u0026amp;refValue(int \u0026amp;x) //返回值是引用,可作左值 { return x; } int main() { refValue(oneX) = 30; //返回值是引用,可作左值 cout \u0026lt;\u0026lt; \u0026#34;oneX=\u0026#34; \u0026lt;\u0026lt; oneX \u0026lt;\u0026lt; endl; //输出 oneX=30 refValue(oneY) = 40; //返回值是引用的函数调用表达式,可作左值使用 cout \u0026lt;\u0026lt; \u0026#34;oneY=\u0026#34; \u0026lt;\u0026lt; oneY \u0026lt;\u0026lt; endl; //输出oneY=40 return 0; } 函数返回值也可以是指针\n类型标识符 * 函数名(实参列表) 3.内联函数 inline （常考） 作用：避免频繁调用与返回，以空间消耗节省时间开销，降低函数调用的开销。 内联函数一般仅适用于只有几条语句的小函数 如果函数体中有循环或switch语句，通常不定义为内联函数\n函数可以减少程序代码, 实现代码共享, 提高开发效率和可维护性\n在编译时内嵌到主函数中\n格式\n1 2 3 4 inline 返回值类型 函数名(形参表) { 函数体 } 只在声明函数原型时加 inline 不能内联, 看编译器的选择\n4.函数的重载（必考） 函数重载可以使一个函数名具有多种功能，即具有“多种形态”，称为多态性。 重载的条件：参数个数不同、参数类型不同、不同类型参数的次序不同。 返回值类型、引用参数都不能区分重载。 程序的同一范围内声明几个功能类似的同名函数 1 2 3 int bigger(int a,int b){} float bigger(float a,float b){} double bigger(double a,double b){} 错误的重载函数\n返回值类型不同 函数不能重载\n1 2 double bigger(double a,double b){} int bigger(double a,double b){} // ERROR 引用参数 函数不能重载\n1 2 void bigger(double){} void bigger(double \u0026amp;){} // ERROR 参数个数不同, 多一个默认值时, 产生二义性，不能采用函数重载\n1 2 void bigger(int a,int b,int c=0){} void bigger(int a,int b){} // ERROR 5.const 与指针共同使用 const 修饰指针变量时，优先匹配左侧 唯一的const 位于 * 左侧，表示指针所指数据为常量，数据不能通过本指针改变,; 但指针本身是变量, 可以指向其它内存单元。（数据不能改，指针指向能改） 指针是变量、数据是常量，常量不可变，数据可以变。\n1 2 3 4 5 6 int a1=10,a2=20,*pa1=\u0026amp;a1; *pa1=30; // 正确，a1 变成 30 const int *pa2 = \u0026amp;a2; // pa2所指的是常量 *pa2 = 40; // ERROR pa2 = \u0026amp;a1; // 正确 唯一的const 位于 * 右侧，表示指针本身是常量，不能让该指针指向其他内存地址，指针所指的数据可以通过本指针进行修改。（指针不能改，指针所指数据能改） 1 2 3 4 int a1=10,a2=20; int * const pa2= \u0026amp;a2; // 指针变量pa2是常量 pa2 = \u0026amp;a1; // ERROR *pa2 = 40; // 正确 在 * 左右各一个 const 时, 表示指针和所指数据都是常量, 都不能改变。 1 2 3 4 5 6 7 8 int a1 = 10,a2 = 20; const int * const pa1 = \u0026amp;a1; //指针和所指数据都是常量 pa1 = \u0026amp;a2; // ERROR *pa1 = 30; // ERROR int const * const pa2 = \u0026amp;a2; //指针和所指数据都是常量 pa2 = \u0026amp;a1; // ERROR *pa2 = 40p; // ERROR 记住const的修饰规则：\n如果const是本行的第一个标识符，则它修饰其右侧的内容。\n1 2 3 4 5 const int *pa2 = \u0026amp;a2; // pa2所指的常量 int * const pa2 = \u0026amp;a2; // 指针变量pa2是常量 const int * const pa1 = \u0026amp;a1; //指针和所指数据都是常量 int const * const pa2 = \u0026amp;a2; //指针和所指数据都是常量 调用时变量前加 \u0026ldquo;\u0026amp;\u0026rdquo; \u0026mdash;\u0026mdash;-返回该变量的地址 声明时变量前加 \u0026ldquo;基本类型 \u0026rdquo; \u0026mdash;\u0026mdash;-该指针变量表示另一个普通变量的地址 eg:int 或 char * 调用时变量前加 \u0026ldquo;*\u0026rdquo;\u0026mdash;\u0026mdash;-表示取该地址的内容 声明时变量前加 \u0026ldquo;基本类型 **\u0026rdquo;\u0026mdash;\u0026mdash;-该二级指针变量表示另一个一级\u0026quot;基本类型 *\u0026ldquo;指针变量地址\n6.指针和动态内存分配 6.1 指针 即指针变量，储存的是一个内存地址，是该指针所指对象的首地址。\n1 2 int a = 100,*pa = \u0026amp;a; int s[10],ps = s; // 指针ps指向数组s的首地址 6.2 动态内存分配 （常考） C++ 不允许定义不确定元素个数的数组 动态分配内存一般格式为：\n1 2 指针名 = new 类型名; // 分配 delete 指针名； // 释放 使用关键字 new 运算符实现动态内存分配 T *p = new T; 分配大小为sizeof(T)字节的内存空间 1 2 3 int *p; p = new int; // 分配4字节空间,p指向首地址 *p = 5; T *p = new T[N]; 实现动态分配任意大小的数组，N为数组元素个数，T为数组类型 1 2 3 4 5 int *pArray; int i = 5; pArray = new int[i*20]; // 分配100个元素的整型数组 pArray[0] = 20; pArray[99] = 30; 当不再使用这个空间时，必须使用 delete 释放空间\n忘记 delete [] 时, 导致数组不完全释放 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; using namespace std; int *A = new int[5]; int main() { for (int i = 0; i \u0026lt; 5; i++) { A[i] = i + 1; cout \u0026lt;\u0026lt; A[i] \u0026lt;\u0026lt; endl; } // delete[] A; //释放空间 delete A; for (int i = 0; i \u0026lt; 5; i++) { cout \u0026lt;\u0026lt; A[i] \u0026lt;\u0026lt; endl; } delete []A; //释放空间 return 0; } delete 数组：\n1 delete []指针; //释放数组元素 7.用 string 对象处理字符串 使用 string ：#include\u0026lt;string\u0026gt;\n声明 string 对象 ：string 变量名 1 2 3 4 5 6 7 8 9 string str1; // 值为空 string city = \u0026#34;ganzhou\u0026#34;; // 声明对象并初始化 string str2 = city; // 使用字符串变量进行赋值 // 字符数组 char name[] = \u0026#34;C++程序\u0026#34;; string str3 = name; // 使用字符数组对string变量进行初始化 string citys[] = {\u0026#34;Beijing\u0026#34;,\u0026#34;Shanghai\u0026#34;,\u0026#34;jing\u0026#34;}; // 声明string对象数组，每个数组元素都是字符串 sizeof(对象/数组) 元素个数\nsizeof(string) 在32位系统是4,64位是8\nstring 对象操作 string对象可以使用cin和cout进行输入和输出\n1 2 3 string s1,s2; cin \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; 2; cout \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt;\u0026#34;,\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt;endl; string对象之间可以互相赋值，也可用字符串常量和字符数组对string对象进行赋值。\n1 2 3 string s1,s2 = \u0026#34;OK\u0026#34;; s1 = \u0026#34;China\u0026#34;; s2 = s1; 支持运算符(ASCII)\n支持“+” 拼接字符串\nstring 对象用法示例 函数 功能 const char *c_str() const; 返回一个指向字符串的指针, 内容与原 string 相同, 用于转换为 const char * int size() const;` 返回当前字符串大小 int length() const; 返回当前字符串长度 bool empty() const; 返回当前字符串是否为空 size_type find(const char * str , size_type index); 返回 str 在字符串中第一次出现的位置, 从 index 开始查找, 没有返回-1 size_type find( char ch , size_type index); 返回 ch 在字符串中第一次出现的位置, 从 index 开始查找, 没有返回-1 string \u0026amp;insert(int p, const string \u0026amp;s); 在 p 位置插入字符串 s string \u0026amp;append(const char *s); 将字符串 s 拼接到当前字符串结尾 string substr(int pos=0, int n=npos) const; 返回从 pos 开始的 n 个字符组成的字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; int main() { string str; if (str.empty()) { cout \u0026lt;\u0026lt; \u0026#34;str is null,\u0026#34; \u0026lt;\u0026lt; \u0026#34;length=\u0026#34; \u0026lt;\u0026lt; str.length() \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;str Not null\u0026#34; \u0026lt;\u0026lt; endl; } str = str.append(\u0026#34;sadfgflk\u0026#34;); cout \u0026lt;\u0026lt; \u0026#34;str is \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; \u0026#34;,size=\u0026#34; \u0026lt;\u0026lt; str.size() \u0026lt;\u0026lt; endl; const char *p = str.c_str(); cout \u0026lt;\u0026lt; \u0026#34;p=\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;find:\u0026#34; \u0026lt;\u0026lt; str.find(\u0026#34;ad\u0026#34;, 0) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;find:\u0026#34; \u0026lt;\u0026lt; str.find(\u0026#34;de\u0026#34;, 4) \u0026lt;\u0026lt; endl; string str1 = str.insert(4, \u0026#34;123\u0026#34;); cout \u0026lt;\u0026lt; str1 \u0026lt;\u0026lt; endl; return 0; } 五、 C++程序结构 主程序 main .cpp 文件格式\n有且一个主函数 main() , 程序从主函数开始执行\n主函数可以调用其他函数, 其他函数不能调用主函数\n主函数结束\n主函数中遇到 return 执行到主函数后面 } 注释风格\n1 2 3 4 5 6 /* 多行注释 多行注释 */ // 单行注释 三、强制类型转换运算符 不同类型量混合运算时, 系统自动执行类型转换, 也可使用 强制类型转换运算符 static_cast 或 const_cast 进行转换\n1 2 3 4 5 6 static_cast\u0026lt;类型名\u0026gt;(表达式); //static_cast 可以省略 oneInt2=static_cast\u0026lt;int\u0026gt;(oneDouble); //强制类型转换 oneInt2=int(oneDouble); //强制类型转换运算符的新形式 oneInt2=(int)oneDouble; //强制类型转换运算符的旧形式 oneInt2=oneDouble; //自动类型转换 1 const_cast\u0026lt;类型名\u0026gt;(表达式); 用于去除指针和引用的常量性,不能去除变量的常量性\n常量指针转化为非常量指针, 任指向原对象(const int *p=\u0026gt; int *p)\n常量引用转化为非常量引用, 任指向原对象\n指针的教程: https://www.imooc.com/video/7858\n指针的本质就是内存地址 示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a = 10; const int *p = \u0026amp;a; //不能使用常量指针p修改a的值,\u0026#34;\u0026amp;\u0026#34;取地址符,\u0026#34;*\u0026#34;从地址取值 const int ca = 30; //被const修饰 int *q; cout \u0026lt;\u0026lt; \u0026#34;a的内存地址为:\\t\u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; \u0026#34;\\t a的值为:\\t\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p指向的地址为:\\t\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\t *p的值为:\\t\u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; q = const_cast\u0026lt;int *\u0026gt;(p); //去除p的常量性赋给q,如果写q=p;会报错 *q = 20; //如果写*p=20;是错误的 cout \u0026lt;\u0026lt; \u0026#34;a的内存地址为:\\t\u0026#34; \u0026lt;\u0026lt; \u0026amp;a \u0026lt;\u0026lt; \u0026#34;\\t a的值为:\\t\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p指向的地址为:\\t\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\t *p的值为:\\t\u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;q指向的地址为:\\t\u0026#34; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026#34;\\t *q的值为:\\t\u0026#34; \u0026lt;\u0026lt; *q \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;分界线\u0026#34; \u0026lt;\u0026lt; endl; p = \u0026amp;ca; //ca的值不能修改 q = const_cast\u0026lt;int *\u0026gt;(p); //去除p的常量性赋给q,如果写q=p;会报错 *q = 40; //如果写*p=40;是错误的 cout \u0026lt;\u0026lt; \u0026#34;ca的内存地址为:\\t\u0026#34; \u0026lt;\u0026lt; \u0026amp;ca \u0026lt;\u0026lt; \u0026#34;\\t ca的值为:\\t\u0026#34; \u0026lt;\u0026lt; ca \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;p指向的地址为:\\t\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; \u0026#34;\\t *p的值为:\\t\u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;q指向的地址为:\\t\u0026#34; \u0026lt;\u0026lt; q \u0026lt;\u0026lt; \u0026#34;\\t *q的值为:\\t\u0026#34; \u0026lt;\u0026lt; *q \u0026lt;\u0026lt; endl; return 0; } 疑问: 常量的非常量指针修改内存地址内的值, 内存地址相同, 值不同\n第二章 面向对象的基本概念 结构化程序设计方法和局限性 面对对象程序设计，并对比结构化。理解抽象、封装、继承和多态 类定义方法，成员变量，成员函数 类定义中访问范围说明符 对象 指针，引用访问类成员的方法 第一节 结构化程序设计 将复杂功能模块化, 化繁为简, 从高层到底层 三种基本控制结构: 顺序/选择/循环 数据结构+算法=程序 复杂, 难以维护, 难以复用 第二节 面向对象思想 1.面向对象基础知识 面向对象的程序设计方式更接近于人们看待真实世界。 对象的特性 状态（属性）: 对象本身的信息，属性用变量来表示 行为（操作）: 对对象的操作,操作用函数来实现 类：对现实客观事物的抽象，找出同一类对象的共同属性(静态特征)和行为(动态特征) 对象是类的实例（具体化），类是对象的抽象 类是模板，一个类可以产生多个对象。 2.面向对象程序设计的特点 封装: 对象的属性和操作结合, 可将对象的部分属性和函数隐藏起来，对外不可见；将另外一部分对外可见，提供操作的接口。 继承: 编写新类时, 以现有类为基础派生, 达到代码扩充和复用的目的。 多态: 不同种类的对象都具有名字相同的行为, 而具体行为的实现方式有所不同。 第三节 类的初步知识 1.类的定义 面向对象方法中的类，是对具有相同属性和行为的同一类对象的抽象描述，其内部包括属性（本类的成员变量）和行为（本类的成员函数）两个部分。类是用户自定义的数据类型。\n基本数据类型\nbool 布尔型 char 字符型 int 整型 float 浮点型 double 双精度浮点型 C++ 中类时用户自定义的数据类型\n先定义类型 声明基本数据类型(对象) 格式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class 类名 { 访问范围说明符: 成员变量1 成员变量2 ... 成员函数声明1 成员函数声明2 ... 访问范围说明符: 更多成员变量 更多成员函数声明 ... }; 类名不能重复\n类定义以“;”结束\n访问范围说明符: public(公有)、private(私有)、protected(保护)\n定义类时系统不分配内存, 而是把类看成模板 按功能划分: 成员变量和成员函数 成员变量私有, 类外不可访问, 为每个成员变量定义一对访问函数, 设置函数和获取函数 成员函数可以重载, 可以设定默认值 按权限划分: 公有成员/私有成员/保护成员 类中的成员变量不能在声明时进行初始化。成员函数定义在类体内部，则默认为内联函数，也可在类体内部声明函数，并加上inline，然后在类体外给出函数的定义，这样也是内联函数。\n成员函数在类体外定义：类体内必须有函数原型，类体外函数定义前必须用 “类名::” 作用域运算符，表明它后面的成员函数是用于类名标识的这个类的。\n不属于任何类的函数: 全局函数\n在类外定义成员函数\ninline 内联\n类内有函数原型\n1 2 3 4 返回值类型 类名::成员函数名(参数列表) { 成员函数的函数体 } 2.类的定义示例 myDate\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class myDate { public: myDate(); //构造函数 myDate(int, int, int); //构造函数 void setDate(int, int, int); //设置日期 void setDate(myDate); //设置日期 myDate getDate(); //获取日期 void setYear(int); //设置年 int getMonth(); //获取月 void printDate() const; //打印日期 private: int year, month, day; //成员变量,年月日 }; //类体外定义成员函数 myDate::myDate() { year = 1970, month = 1, day = 1; } myDate::myDate(int y, int m, int d) { year = y; month = m; day = d; } void myDate::setDate(int y, int m, int d) { year = y; month = m; day = d; return; } void myDate::setDate(myDate oneD) { year = oneD.year; month = oneD.month; day = oneD.day; return; } myDate myDate::getDate() { return *this; } void myDate::setYear(int y) { year = y; return; } int myDate::getMonth() { return month; } void myDate::printDate() const { cout \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; day; return; } Student\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Student { public: void setStudent(string, myDate); //设置学生信息 void setName(string); //设置姓名 string getName(); //获取姓名 void setBirthday(myDate); //设置生日 myDate getBirthday(); //获取生日 void printStudent() const; //打印信息 private: string name; //姓名 myDate birthday; //生日 }; //类体外定义成员函数 void Student::setStudent(string s, myDate d) { name = s; birthday.setDate(d); return; } void Student::setName(string n) { name = n; return; } string Student::getName() { return name; } void Student::setBirthday(myDate d) { birthday.setDate(d); return; } myDate Student::getBirthday() { return birthday; } void Student::printStudent() const { cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\\t生日:\u0026#34;; birthday.printDate(); //调用类myDate 的成员函数 cout \u0026lt;\u0026lt; endl; } 第四节 类成员的访问 1.成员变量和成员函数的定义 一个完整的C++程序包括：主函数main、用户定义的任意个类及全局函数、全局说明、注释、头文件 成员变量一般定义为私有访问权限，仅在本类中访问。 在类体外定义成员函数时，要指明类的名称。因函数体代码较长，在类体内仅给出成员函数的原型，在类体外给出对应的函数体。如在函数体定义在类体内，系统将视为内联函数。 类中定义的成员函数允许重载。成员函数在内存中只有一份，每个对象共享。 2.定义对象的两种方法 方法一，对象是类的实例 1 2 3 4 5 类名 对象名; // 多个对象可用逗号隔开一起定义 类名 对象名(参数); 类名 对象名 = 类名(参数); 类名 对象名1, 对象名2,...; 类名 对象名1(参数),对象名2(参数),...; 方法二，用 new 创建对象时返回的是一个对象的指针, 必须用 delete 来撤销\n1 2 3 类名 *对象指针名 = new 类名; //成员变量不初始化 类名 *对象指针名 = new 类名(); //成员变量初始化，构造函数进行初始化 类名 *对象指针名 = new 类名(参数); 声明对象引用, 即别名\n1 2 3 类名 \u0026amp;对象引用名 = 对象; 类名 *对象指针名 = 对象的地址; 类名 对象数组名[数组大小]; 同类型对象之间可以相互赋值, 对象和对象指针都可以用作函数参数, 函数返回值可以使对象或指针\n1 2 3 4 C a1, b1; //定义了C类的对象a1,b1 C *p = \u0026amp;a1; //指向对象a1的C类指针p C \u0026amp;R = b1; //C类对象b1的引用R C A[3]; //C类对象的数组A,含三个元素 3.使用对象访问成员变量与调用成员函数 调用格式\n对象名.成员变量名 对象名.成员函数名(参数) 私有成员在类的外部不可以直接调用 验证 Student 的操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class myDate { public: myDate(); //构造函数 myDate(int, int, int); //构造函数 void setDate(int, int, int); //设置日期 void setDate(myDate); //设置日期 myDate getDate(); //获取日期 void setYear(int); //设置年 int getMonth(); //获取月 void printDate() const; //打印日期 private: int year, month, day; //成员变量,年月日 }; //类体外定义成员函数 myDate::myDate() { year = 1970, month = 1, day = 1; } myDate::myDate(int y, int m, int d) { year = y; month = m; day = d; } void myDate::setDate(int y, int m, int d) { year = y; month = m; day = d; return; } void myDate::setDate(myDate oneD) { year = oneD.year; month = oneD.month; day = oneD.day; return; } myDate myDate::getDate() { return *this; } void myDate::setYear(int y) { year = y; return; } int myDate::getMonth() { return month; } void myDate::printDate() const { cout \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; day; return; } class Student { public: void setStudent(string, myDate); //设置学生信息 void setName(string); //设置姓名 string getName(); //获取姓名 void setBirthday(myDate); //设置生日 myDate getBirthday(); //获取生日 void printStudent() const; //打印信息 private: string name; //姓名 myDate birthday; //生日 }; //类体外定义成员函数 void Student::setStudent(string s, myDate d) { name = s; birthday.setDate(d); return; } void Student::setName(string n) { name = n; return; } string Student::getName() { return name; } void Student::setBirthday(myDate d) { birthday.setDate(d); return; } myDate Student::getBirthday() { return birthday; } void Student::printStudent() const { cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\\t生日:\u0026#34;; birthday.printDate(); //调用类myDate 的成员函数 cout \u0026lt;\u0026lt; endl; } int main() { Student ss; int y, m, d; string name_; cout \u0026lt;\u0026lt; \u0026#34;请输入学生的姓名和生日, 生日以\\\u0026#34;年 月 日\\\u0026#34;的次序输入:\u0026#34;; cin \u0026gt;\u0026gt; name_ \u0026gt;\u0026gt; y \u0026gt;\u0026gt; m \u0026gt;\u0026gt; d; ss.setStudent(name_, myDate(y, m, d)); ss.printStudent(); return 0; } 使用指针访问对象的成员\n使用指针对象名.成员变量名 变成 指针-\u0026gt;成员变量名 使用引用访问对象的成员\n引用名.成员名 4.类成员的可访问范围 访问范围说明符的含义\npublic: 公有, 任何地方可以访问 private: 私有, 仅能在本类（或友元函数）中被访问 protected: 允许本类及子类中被访问 如果某个成员没有范围修饰符，默认为私有成员\n第三章 类和对象进阶 构造函数、析构函数、复制构造函数 特殊成员，包括静态成员、常量成员、常引用成员 类成员的生存期及作用域 封闭类的概念，定义封闭类 友元函数 this 指针 第一节 构造函数 构造函数的作用\n对象初始化, 成员变量赋初值 构造函数的定义\n构造函数名字与类名相同, 无返回值, 一个类可以有多个构造函数(参数不能相同), 允许重载\n类名(形参1,形参2,...形参n);\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 类外定义构造函数 // 成员变量 x1,x2,...,xn; // 形式1 类名::类名(形参1,形参2,...形参n):x1(形参1),x2(形参2),...,xn(形参n){} // 形式2 类名::类名(形参1,形参2,...,形参n) { x1 = 形参1; x2 = 形参2; ... xn = 形参n; } // 形式3 类名::类名() { x1 = 初始化表达值1; x2 = 初始化表达值2; ... xn = 初始化表达值n; } 构造函数的使用\n创建对象时根据调用语句中所带实参数量确定使用哪个构造函数\n当程序创建一个对象时，系统自动调用构造函数来初始化对象。\n如果创建对象提供了实参，则使用实参为对象成员变量赋值；如果没有提供实参，则使用默认值为对象的成员变量赋值。\n使用构造函数创建对象指针\n1 2 MyDate *pd = new MyDate(); MyDate *pd1 = new MyDate; 使用 new 创建对象指针\nmyDate *p = new myDate; 括号可加可不加 加括号, 系统分配内存时，成员变量初始化为 0 不加括号时, 成员变量的值不进行内存分配，是随机值。 声明对象数组, 每一个元素都是对象, 一定要为对象所属定义一个无参的构造函数，每一个数组元素都要调用构造函数。 如 类MyDate为例：\n1 MyDate a[3]; // 此时调用无参的构造函数3次，为数组A的3个元素进行初始化。 特例, 声明数组时给各元素赋初值, 不用无参构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int main() { Student stud; stud.printStudent(); //输出默认值 stud.setName(\u0026#34;111\u0026#34;); //姓名改为111 stud.printStudent(); //输出修改后的值 111 Student *spointer[2] = {new Student(), \u0026amp;stud}; //初始化 Student sy[2] = {Student(), stud}; //初始化 分配新的内存地址 for (int i = 0; i \u0026lt; 2; i++) //使用指针输出指针指向的对象的值 spointer[i]-\u0026gt;printStudent(); //姓名111 for (int i = 0; i \u0026lt; 2; i++) //使用点运算符输出各值 sy[i].printStudent(); //姓名111 stud.setName(\u0026#34;222\u0026#34;); //姓名222 for (int i = 0; i \u0026lt; 2; i++) //sp[1]指向的对象的值改变 spointer[i]-\u0026gt;printStudent(); //姓名222 spointer[0]-\u0026gt;setName(\u0026#34;333\u0026#34;); //影响student的值 spointer[1]-\u0026gt;setName(\u0026#34;444\u0026#34;); //影响stud的值 for (int i = 0; i \u0026lt; 2; i++) //指向对象的值都改变 spointer[i]-\u0026gt;printStudent(); // 姓名444 stud.printStudent(); //值变成 姓名444 生日1970 for (int i = 0; i \u0026lt; 2; i++) sy[i].printStudent(); //值不变 // 姓名NoName 生日1970 // 姓名111 生日1970 return 0; } 复制构造函数与类型转换构造函数\n也叫拷贝构造函数，作用：使用已有对象来建立一个新对象\n复制构造函数只有一个参数，参数是引用类自己的对象，形参是本类对象的引用\n对于类 A ，复制构造函数的原型如下\n1 2 A::A(const A\u0026amp;); A::A(A\u0026amp;); 声明和实现复制构造函数的格式\n1 2 3 4 5 6 7 8 9 10 11 class 类名 { public: 类名(参数表);\t//构造函数 类名(类名 \u0026amp; 对象名);\t//复制构造函数 ... }; 类名::类名(类名 \u0026amp; 对象名) //复制构造函数的实现 { 函数体 } 调用复制构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class myDate { public: myDate(); //构造函数 myDate(int, int, int); //构造函数 void setDate(int, int, int); //设置日期 void setDate(myDate); //设置日期 myDate getDate(); //获取日期 void setYear(int); //设置年 int getMonth(); //获取月 void printDate() const; //打印日期 private: int year, month, day; //成员变量,年月日 }; //类体外定义成员函数 myDate::myDate() { year = 1970, month = 1, day = 1; } myDate::myDate(int y, int m, int d) { year = y; month = m; day = d; } void myDate::setDate(int y, int m, int d) { year = y; month = m; day = d; return; } void myDate::setDate(myDate oneD) { year = oneD.year; month = oneD.month; day = oneD.day; return; } myDate myDate::getDate() { return *this; } void myDate::setYear(int y) { year = y; return; } int myDate::getMonth() { return month; } void myDate::printDate() const { cout \u0026lt;\u0026lt; year \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; month \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; day; return; } class Student { public: Student(); //构造函数,无参数 Student(string); //构造函数,带一个参数 void setStudent(string, myDate); //设置学生信息 void setName(string); //设置姓名 string getName(); //获取姓名 void setBirthday(myDate); //设置生日 myDate getBirthday(); //获取生日 void printStudent() const; //打印信息 Student(const Student \u0026amp;s); //声明复制构造函数 private: string name; //姓名 myDate birthday; //生日 }; //定义构造函数 Student::Student() : name(\u0026#34;NoName\u0026#34;), birthday(myDate()){}; //添加,不带参数 Student::Student(string n) : name(n), birthday(myDate()){}; //添加,带一个参数 //类体外定义成员函数 Student::Student(const Student \u0026amp;s) //自定义复制构造函数 { name = \u0026#34;Copy\u0026#34; + s.name; birthday = s.birthday; } void Student::setStudent(string s, myDate d) { name = s; birthday.setDate(d); return; } void Student::setName(string n) { name = n; return; } string Student::getName() { return name; } void Student::setBirthday(myDate d) { birthday.setDate(d); return; } myDate Student::getBirthday() { return birthday; } void Student::printStudent() const { cout \u0026lt;\u0026lt; \u0026#34;姓名:\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;\\t生日:\u0026#34;; birthday.printDate(); //调用类myDate 的成员函数 cout \u0026lt;\u0026lt; endl; } int main() { Student stud; stud.setName(\u0026#34;444\u0026#34;); //姓名改为444 Student ss[2] = {stud, Student()}; stud.printStudent(); stud.setName(\u0026#34;111\u0026#34;); ss[0] = Student(stud); //调用复制构造函数 ss[1] = Student(); stud.printStudent(); ss[0].printStudent(); //姓名 Copy111 ss[1].printStudent(); //默认新对象 return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 - 自动调用复制函数的三种情况 1. 用一个对象去初始化本类另一个对象 ```C++ 类名 对象名2(对象名1); 类名 对象名2 = 对象名1; ``` 2. 如果函数F 的参数是类A 的对象, 调用F 时, 会调用类 A 的复制构造函数 3. 如果函数返回值是类A 的对象, 函数返回时会调用类 A 的复制构造函数 注意: 复制构造函数的参数表中加上 const 更好 **类型转换构造函数** - 如果构造函数只有一个参数, 则可以看做类型转换构造函数, 作用是进行类型自动转换 ```C++ #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Demo { int id; public: Demo(int i) { id = i; cout \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void printDemo(); ~Demo() { cout \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; \u0026#34;析构函数\u0026#34; \u0026lt;\u0026lt; endl; //下节介绍 } }; void Demo::printDemo() { cout \u0026lt;\u0026lt; \u0026#34;id=\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; endl; } int main() { Demo d4(4); //主函数内定义 d4.printDemo(); d4 = 6; //可看作是将整型数6 转为Demo 对象 d4.printDemo(); return 0; } 第二节 析构函数 成员函数的一种\n名字与类名相同 类名前加 ~ 无参数, 无返回值，不能重载 一个类仅有一个析构函数，对象在消亡时自动调用析构函数，析构函数的作用是处理一些善后工作，如释放占用的空间。 没有定义则自动生成 用于释放内存\n对象数组与 delete 语句\n1 2 Student *ss = new Student[2]; delete []ss; 指针数组与 delete 语句\n1 2 3 Student *ss[2] = {new Student(),new Student()}; delete ss[0]; delete ss[1]; 程序填空题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Samp { public: void Setij(int a, int b) { i = a; j = b; cout \u0026lt;\u0026lt; \u0026#34;i=\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;构造函数\u0026#34; \u0026lt;\u0026lt; endl; } void printDemo(); ~Samp() { cout \u0026lt;\u0026lt; \u0026#34;i=\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;析构函数\u0026#34; \u0026lt;\u0026lt; endl; } int GetMuti() { return i * j; } protected: int i; int j; }; int main() { Samp *p; p = new Samp[5]; if (!p) { cout \u0026lt;\u0026lt; \u0026#34;内存分配错误\\n\u0026#34;; return 1; } for (int j = 0; j \u0026lt; 5; j++) p[j].Setij(j, j); for (int k = 0; k \u0026lt; 5; k++) cout \u0026lt;\u0026lt; \u0026#34;Muti[\u0026#34; \u0026lt;\u0026lt; k \u0026lt;\u0026lt; \u0026#34;] 值是:\u0026#34; \u0026lt;\u0026lt; p[k].GetMuti() \u0026lt;\u0026lt; endl; delete[] p; return 0; } 第三节 类的静态成员（常考） 静态变量\nstatic 说明自动变量\n静态全局变量 静态局部变量 静态变量只执行一次初始化，如果未显示初始化值，则初始为0\n自动变量和静态变量的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; static int glos = 100; void f() { int a = 1; static int fs = 1; cout \u0026lt;\u0026lt; \u0026#34;在f中:a(自动变量)=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; fs(静态)\u0026#34; \u0026lt;\u0026lt; fs \u0026lt;\u0026lt; \u0026#34; glos(静态)=\u0026#34; \u0026lt;\u0026lt; glos \u0026lt;\u0026lt; endl; a += 2; fs += 2; glos += 10; cout \u0026lt;\u0026lt; \u0026#34;在f中:a(自动变量)=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026#34; fs(静态)\u0026#34; \u0026lt;\u0026lt; fs \u0026lt;\u0026lt; \u0026#34; glos(静态)=\u0026#34; \u0026lt;\u0026lt; glos \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } int main() { static int ms = 10; for (int i = 1; i \u0026lt;= 3; i++) f(); cout \u0026lt;\u0026lt; \u0026#34;ms=\u0026#34; \u0026lt;\u0026lt; ms \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;glos=\u0026#34; \u0026lt;\u0026lt; glos \u0026lt;\u0026lt; endl; return 0; } 类的静态成员\n在类体内定义类的成员时，在前面添加 static 关键字。\n静态成员变量\n类的静态成员被类的所有成员共享，不论有多少对象，静态成员都只有一份保存在公用内存中。\n在类定义中声明静态成员变量, 必须在类体外定义成员静态变量的初值，不能在类体内赋值。\n类型 类名::静态成员变量 = 初值; //在类体外给静态成员赋初值 前面不能加static\n访问静态成员\n类名::静态成员名 对象名.静态成员名 对象指针-\u0026gt;静态成员名 静态成员函数\n类的静态成员函数没有 this 指针, 不能在静态成员函数内访问非静态成员 静态成员函数只能处理静态成员变量 程序填空题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class Test { public: static int x; Test(int i = 10) { x = i + x; } int Getnum() { return Test::x + 7; } }; int Test::x = 83; int main() { Test test; cout \u0026lt;\u0026lt; test.Getnum() \u0026lt;\u0026lt; endl; return 0; } 第四节 变量及对象的生存期和作用域 变量的生存期和作用域\n生存期\n分配内存到释放内存 作用域\n变量的有效范围 全局域 程序作用域 多文件作用域, extern 说明的外部变量和外部函数 文件作用域 单文件作用域, 文件内函数外的变量/函数 局部域 类作用域 函数作用域 块作用域 函数原型作用域 不是定义函数, 而是声明函数, 函数原型形参作用域只在声明中 所以通常只要声明形参的个数和类型, 省略参数名 重名标识符，不同作用域允许重名\n无包含关系，互不影响 有包含关系，在哪定义在哪有效 类对象的生存期和作用域\n类对象生成时调用构造函数, 销毁时调用析构函数 作用域越大的越晚销毁 第五节 常量成员和常引用成员 3.5.1 const 修饰的各种情况 使用 const 修饰的量称为常量\n常量函数\n常量对象\n常量成员变量：const修饰的类的数据成员变量，必须在构造函数的成员初始化列表中进行初始化 格式：const 数据类型 常量名 = 表达式;\n常量函数：使用const 修饰的函数\n常量对象：定义类的对象时使用 const 修饰 格式：类型说明符 函数名(参数表) const;\n常量对象只能调用常用常量，常量对象各属性值不能修改。\n常量对象只能调用常量函数\n常量成员变量及常量成员函数的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class constClass { const int conMbr; //类中的常量成员变量 int Mbr; //普通成员变量 public: constClass() : conMbr(0), Mbr(100) {} //初始化列表处给初始值 constClass(int i) : conMbr(i) //初始化列表处给初始值 { Mbr = 200; } void printConst() { cout \u0026lt;\u0026lt; \u0026#34;conMbr=\u0026#34; \u0026lt;\u0026lt; conMbr \u0026lt;\u0026lt; \u0026#34;,Mbr\u0026#34; \u0026lt;\u0026lt; Mbr \u0026lt;\u0026lt; endl; } int getConst() { cout \u0026lt;\u0026lt; \u0026#34;调用非常量函数\u0026#34; \u0026lt;\u0026lt; endl; return conMbr; } int getConst() const { cout \u0026lt;\u0026lt; \u0026#34;调用常量函数\u0026#34; \u0026lt;\u0026lt; endl; return conMbr; } int getValue() { return Mbr; } void processConst() { cout \u0026lt;\u0026lt; \u0026#34;--在processConst函数中 非常量--\u0026#34; \u0026lt;\u0026lt; endl; int x = 2 * conMbr + 1; cout \u0026lt;\u0026lt; \u0026#34;x=2*conMbr+1=\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; //可以读取 conMbr //conMbr++; //错误, 不能更改常量成员变量 conMbr的值 Mbr++; //可以修改非常量成员 Mbr的值 cout \u0026lt;\u0026lt; \u0026#34;Mbr=\u0026#34; \u0026lt;\u0026lt; Mbr \u0026lt;\u0026lt; endl; } void processConst() const { cout \u0026lt;\u0026lt; \u0026#34;--在processConst函数中 常量--\u0026#34; \u0026lt;\u0026lt; endl; int x = conMbr + 1; cout \u0026lt;\u0026lt; \u0026#34;x=conMbr+1=\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; //可以读取 conMbr //conMbr++; //错误, 不能更改常量成员变量 conMbr的值 // Mbr++; //不能修改非常量成员 Mbr的值 cout \u0026lt;\u0026lt; \u0026#34;Mbr=\u0026#34; \u0026lt;\u0026lt; Mbr \u0026lt;\u0026lt; endl; } }; int main() { constClass ob1(123), ob2; ob1.printConst(); cout \u0026lt;\u0026lt; \u0026#34;ob2.getConst()=\u0026#34; \u0026lt;\u0026lt; ob2.getConst() \u0026lt;\u0026lt; endl; ob2.processConst(); const constClass ob3(20); cout \u0026lt;\u0026lt; \u0026#34;ob3.getConst()=\u0026#34; \u0026lt;\u0026lt; ob3.getConst() \u0026lt;\u0026lt; endl; ob3.processConst(); return 0; } 3.5.2 const修饰指针变量 唯一的 const 位于* 左侧，表示指针所指数据是常量，数据不能通过指针改变，但指针本身是常量 1 int const *p 唯一的 const 位于* 右侧，表示指针本身是常量，指针不能指向其他内存地址，但指针所指的数据可以通过指针修改 1 int * const p 左右各一个const，表示指针和指向都是常量，指向的值和指针都不能修改。 第六节 成员对象和封闭类 一个类的成员变量如果是另一个类的对象, 称该变量为成员对象， 包含成员对象的类叫做封闭类。\n封闭类构造函数和初始化列表\n定义封闭类的的构造函数时, 需要添加初始化列表, 指明要调用成员对象的那个构造函数\n对于成员对象，初始化列表的“参数表”中列出的成员对象构造函数（指明了该成员对象如何初始化）\n生成封闭类对象时\n先执行成员对象的构造函数，再执行封闭类的构造函数; 销毁时先执行封闭类析构函数, 再执行成员对象的析构函数； 成员对象构造函数的执行顺序与成员对象在类定义中的说明顺序相同，析构函数的调用则相反。 谁先构造，后析构，后构造先析构。 生成封闭类对象的语句要说明对象中包含的成员对象是如何初始化的，不说明则用默认构造函数或者参数全部省略的构造函数初始化 添加初始化列表格式\n封闭类名::构造函数名(参数表):成员变量1(参数表),成员变量2(参数表),... {...} 封闭类的复制构造函数\n如果封闭类的对象是用默认复制构造函数初始化的, 那么它包含的成员对象也会用复制构造函数初始化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; using namespace std; class A { public: A() { cout \u0026lt;\u0026lt; \u0026#34;default\u0026#34; \u0026lt;\u0026lt; endl; } A(A \u0026amp;a) { cout \u0026lt;\u0026lt; \u0026#34;copy\u0026#34; \u0026lt;\u0026lt; endl; } }; class B { A a; }; int main() { B b1, b2(b1); return 0; } 第七节 友元 友元 一个类里的私有成员和保护成员只能由类内部的成员函数访问，外部不能通过对象直接访问。但为了提高编程效率，需要允许一个函数或类访问另一个类中的私有成员或保护成员，这时可将这些类或函数声明为类的友元。\n兼顾C 语言程序设计的习惯与 C++ 信息隐藏的特点, 而增加的功能 是一种类成员的访问权限 破坏了类的封装性和信息隐藏, 但有助于数据共享, 能够提高程序运行效率 friend 友元函数\n全局函数声明为本类友元函数的格式如下\nfriend 返回值类型 函数名(参数表); 有某类A 定义后, 将类 A 的成员函数说明为友元函数的格式如下\nfriend 返回值类型 类A::类A的成员函数名(参数名); 不能把其他类的私有成员函数声明为友元函数 友元函数不是类的成员函数,但允许访问类的所有成员\n在函数体中访问对象成员 对象名.对象成员名 不受访问权限关键词限制 类成员函数实现复数类操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; using namespace std; class myComplex //复数类 { private: double real, imag; //复数的实部和虚部 public: myComplex(); myComplex(double r, double i); myComplex addCom(myComplex c); //成员函数, 调用者对象与参数对象c相加 void outCom(); //成员函数, 输出调用者对象的有关数据 }; myComplex::myComplex(double r, double i) { real = r; imag = i; } myComplex::myComplex() { real = 0; imag = 0; } myComplex myComplex::addCom(myComplex c) { return myComplex(real + c.real, imag + c.imag); } void myComplex::outCom() { cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; imag \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } int main() { myComplex c1(1, 2), c2(3, 4), res; res = c1.addCom(c2); //调用成员函数必须通过类对象 c1.outCom(); cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34;; c2.outCom(); cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;; res.outCom(); cout \u0026lt;\u0026lt; endl; return 0; } 友元函数实现复数操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include \u0026lt;iostream\u0026gt; using namespace std; class myComplex //复数类 { private: double real, imag; //复数的实部和虚部 public: myComplex(); myComplex(double r, double i); friend myComplex addCom(myComplex c1, myComplex c2); //友元函数, 两个参数对象相加 friend void outCom(myComplex c); //友元函数, 输惨参数对象数据 }; myComplex::myComplex(double r, double i) { real = r; imag = i; } myComplex::myComplex() { real = 0; imag = 0; } myComplex addCom(myComplex c1, myComplex c2) //定义函数 { return myComplex(c1.real + c2.real, c1.imag + c2.imag); } void outCom(myComplex c) //定义函数 { cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } int main() { myComplex c1(1, 2), c2(3, 4), res; res = addCom(c1, c2); //调用成员函数必须通过类对象 outCom(c1); cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34;; outCom(c2); cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;; outCom(res); cout \u0026lt;\u0026lt; endl; return 0; } 友元类\nfriend class 类名;\n类友元关系是单向的, 不能传递, 非必要时不用类友元\n类友元示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; using namespace std; class myComplex //复数类 { private: double real, imag; //复数的实部和虚部 public: myComplex(); myComplex(double r, double i); friend class oper; //友元类 }; myComplex::myComplex(double r, double i) { real = r; imag = i; } myComplex::myComplex() { real = 0; imag = 0; } class oper { public: myComplex addCom(myComplex c1, myComplex c2); //友元函数, 两个参数对象相加 void outCom(myComplex c); //友元函数, 输惨参数对象数据 }; myComplex oper::addCom(myComplex c1, myComplex c2) //定义函数 { return myComplex(c1.real + c2.real, c1.imag + c2.imag); } void oper::outCom(myComplex c) //定义函数 { cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } int main() { myComplex c1(1, 2), c2(3, 4), res; oper o; res = o.addCom(c1, c2); //调用成员函数必须通过类对象 o.outCom(c1); cout \u0026lt;\u0026lt; \u0026#34;+\u0026#34;; o.outCom(c2); cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;; o.outCom(res); cout \u0026lt;\u0026lt; endl; return 0; } 程序填空题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; using namespace std; class Point { private: double x, y; friend class Line; public: Point(double i = 0, double j = 0) { x = i; y = j; } Point(Point \u0026amp;p) { x = p.x; y = p.y; } }; class Line { private: Point p1, p2; public: Line(Point \u0026amp;xp1, Point \u0026amp;xp2) : p1(xp1), p2(xp2) {} double GetLength(); }; double Line::GetLength() { double dx = p2.x - p1.x; double dy = p2.y - p1.y; return sqrt(dx * dx + dy * dy); } int main() { Point p1, p2(6, 8); Line L1(p1, p2); cout \u0026lt;\u0026lt; L1.GetLength() \u0026lt;\u0026lt; endl; return 0; } 第八节 this 指针 被调用函数的内存首地址\nthis指针始终指向调用成员函数的对象\n每个当前对象都含有一个指向该对象的this指针 this指针只能在类的成员函数中使用 静态成员函数不能够有this指针。 this -\u0026gt;成员变量 = 形参; 1 2 3 4 5 6 myDate :: myDate(int year,int month,int day){ this -\u0026gt; year = year; this -\u0026gt; month = month; this -\u0026gt; day = day; } this 指针的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; using namespace std; class myComplex { public: double real, imag; myComplex() : real(0), imag(0) {} myComplex(double, double); myComplex AddRealOne(); myComplex AddImagOne(); void outCom(); //成员函数, 输出调用者对象的有关数据 }; myComplex::myComplex(double real, double imag) { this-\u0026gt;real = real; this-\u0026gt;imag = imag; } void myComplex::outCom() { cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; imag \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } myComplex myComplex::AddRealOne() { this-\u0026gt;real++; return *this; // 返回对象本身 } myComplex myComplex::AddImagOne() { this-\u0026gt;imag++; return *this; // 返回对象本身 } int main() { myComplex c1(1, 1), c2, c3; c1.outCom(); c2.outCom(); c3.outCom(); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;分界线\u0026#34; \u0026lt;\u0026lt; endl; c2 = c1.AddRealOne(); c1.outCom(); c3 = c1.AddImagOne(); c2.outCom(); c3.outCom(); cout \u0026lt;\u0026lt; endl; return 0; } 第四章 运算符重载 运算重载符 运算重载符作为成员函数和友元函数的两种方式 对自己定义的类重载运算符 对特定类重载前置和后置异同 浅拷贝和深拷贝 第一节 运算符重载的概念 重载运算符的概念\n已有的运算符赋予多重含义, 使同一个运算符作用于不同类型的数据时产生不同的行为\n可重载的运算符\n运算符重载的目的是使得运算符能够用来操作对象\n运算符 举例 双目算术运算符 +, -, *, /, % 关系运算符 ==, !=, \u0026lt;, \u0026gt;, \u0026lt;=, \u0026gt;= 逻辑运算符 ` 单目运算符 +(正), -(负), *(指针), \u0026amp;(取地址) 自增自减运算符 ++, -- 位运算符 ` 赋值运算符 `=, +=, -=, *=, /=, %=, \u0026amp;=(按位与赋值), 空间申请与释放 new, delete, new[], delete[] 其他运算符 ()(函数调用), -\u0026gt;(成员访问), ,(逗号), [](下标) 不可重载的运算符和符号 成员访问运算符 . 成员指针访问运算符 .* , -\u0026gt;* 域运算符 :: 长度运算符 sizeof 条件运算符 ?: 预处理符号 # 用于类运算的运算符通常都要重载, 系统提供了两个重载运算符\n=, \u0026amp; 复制和地址 运算符重载的实质是编写以运算符为名称的函数\n使用运算符的表达式就被解释为对重载函数的调用 格式：\t返回值类型 operator 运算符(形参表){函数体} ``` - 可以是全局函数, 成员函数 运算符重载函数：成员函数\n传递的参数比运算符的操作数少一个，因为调用者本身也参与运算，this 可省略\n使用重载运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include \u0026lt;iostream\u0026gt; using namespace std; class myComplex //复数类 { private: double real, imag; //复数的实部和虚部 public: myComplex(); myComplex(double r, double i); myComplex addCom(myComplex c); //成员函数, 调用者对象与参数对象c相加 void outCom(); //成员函数, 输出调用者对象的有关数据 myComplex operator-(const myComplex \u0026amp;c); //成员 重载函数 friend myComplex operator+(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2); //友元 重载函数 }; myComplex::myComplex(double r, double i) { real = r; imag = i; } myComplex::myComplex() { real = 0; imag = 0; } myComplex myComplex::addCom(myComplex c) { return myComplex(real + c.real, imag + c.imag); } void myComplex::outCom() { cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; imag \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } myComplex myComplex::operator-(const myComplex \u0026amp;c) { return myComplex(this-\u0026gt;real - c.real, this-\u0026gt;imag - c.imag); //返回一个临时对象 } myComplex operator+(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2) { return myComplex(c1.real + c2.real, c1.imag + c2.imag); //返回一个临时对象 } int main() { myComplex c1(1, 2), c2(3, 4), res; c1.outCom(); cout \u0026lt;\u0026lt; \u0026#34;operator+\u0026#34;; c2.outCom(); cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;; res = c1 + c2; res.outCom(); cout \u0026lt;\u0026lt; endl; c1.outCom(); cout \u0026lt;\u0026lt; \u0026#34;operator-\u0026#34;; c2.outCom(); cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;; res = c1 - c2; res.outCom(); cout \u0026lt;\u0026lt; endl; return 0; } 运算符重载函数：友元函数\n重载运算符作为友元函数时,参数个数为运算符的操作数个数\n重载作为友元函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 #include \u0026lt;iostream\u0026gt; using namespace std; class myComplex //复数类 { private: double real, imag; //复数的实部和虚部 public: myComplex(); myComplex(double r, double i); myComplex addCom(myComplex c); //成员函数, 调用者对象与参数对象c相加 void outCom(); //成员函数, 输出调用者对象的有关数据 myComplex operator-(const myComplex \u0026amp;c); //成员 重载函数 friend myComplex operator+(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2); //友元 重载函数 friend myComplex operator-(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2); //友元 重载函数 friend myComplex operator-(const myComplex \u0026amp;c1, double r); //友元 重载函数 friend myComplex operator-(double r, const myComplex \u0026amp;c1); //友元 重载函数 }; myComplex::myComplex(double r, double i) { real = r; imag = i; } myComplex::myComplex() { real = 0; imag = 0; } myComplex myComplex::addCom(myComplex c) { return myComplex(real + c.real, imag + c.imag); } void myComplex::outCom() { cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; imag \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } myComplex myComplex::operator-(const myComplex \u0026amp;c) { return myComplex(this-\u0026gt;real - c.real, this-\u0026gt;imag - c.imag); //返回一个临时对象 } myComplex operator+(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2) //c1+c2 { return myComplex(c1.real + c2.real, c1.imag + c2.imag); //返回一个临时对象 } myComplex operator-(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2) //c1-c2 { return myComplex(c1.real - c2.real, c1.imag - c2.imag); //返回一个临时对象 } myComplex operator-(const myComplex \u0026amp;c1, double r) //c1-r { return myComplex(c1.real - r, c1.imag); //返回一个临时对象 } myComplex operator-(double r, const myComplex \u0026amp;c1) //r-c1 { return myComplex(r + c1.real, -c1.imag); //返回一个临时对象 } int main() { myComplex c1(1, 2), c2(3, 4), res; c1.outCom(); cout \u0026lt;\u0026lt; \u0026#34;operator+\u0026#34;; c2.outCom(); cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;; res = c1 + c2; res.outCom(); cout \u0026lt;\u0026lt; endl; c1.outCom(); cout \u0026lt;\u0026lt; \u0026#34;operator-\u0026#34;; c2.outCom(); cout \u0026lt;\u0026lt; \u0026#34;=\u0026#34;; res = c1 - c2; res.outCom(); cout \u0026lt;\u0026lt; endl; res = c1 - c2; res.outCom(); res = c1 - 5; res.outCom(); res = 5 - c1; res.outCom(); return 0; } 重载运算符的规则\n重载后含义应符合原有用法习惯 不能改变运算符原有的语义, 包括优先级和结合性 运算符重载不能改变运算符操作的个数和语法结构 不能创建新的运算符 (), [], -\u0026gt;, = 只能重载为成员函数, 不能重载为全局函数 运算符重载不能改变该运算符用于基本数据类型对象的含义 增加一个无用 int 类型形参的版本，用于区分重载的前置或后置运算符。\n第二节 重载赋值运算符 重载赋值运算符\n= 只能重载为成员函数\n重载后被解释为函数调用的形式\ns1.operator = (s2); 为类 myComplex 重载赋值运算符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 #include \u0026lt;iostream\u0026gt; using namespace std; class myComplex //复数类 { private: double real, imag; //复数的实部和虚部 public: myComplex(); myComplex(double r, double i); ~myComplex() {} //不能有分号 myComplex addCom(myComplex c1); //成员函数, 调用者对象与参数对象c相加 void outCom(); //成员函数, 输出调用者对象的有关数据 void outCom(string s); //成员函数, 输出调用者对象的有关数据 void changeReal(double r); //成员函数 myComplex operator-(const myComplex \u0026amp;c); //成员 重载函数 friend myComplex operator+(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2); //友元 重载函数 c1+c2 friend myComplex operator+(const myComplex \u0026amp;c1, double r); //友元 重载函数 c1+r friend myComplex operator+(double r, const myComplex \u0026amp;c1); //友元 重载函数 r+c1 friend myComplex operator-(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2); //友元 重载函数 friend myComplex operator-(const myComplex \u0026amp;c1, double r); //友元 重载函数 friend myComplex operator-(double r, const myComplex \u0026amp;c1); //友元 重载函数 myComplex \u0026amp;operator=(const myComplex \u0026amp;c); //成员函数 myComplex \u0026amp;operator=(double); //成员函数 }; myComplex::myComplex(double r, double i) { real = r; imag = i; } myComplex::myComplex() { real = 0; imag = 0; } myComplex myComplex::addCom(myComplex c1) { return myComplex(this-\u0026gt;real + c1.real, this-\u0026gt;imag + c1.imag); } void myComplex::outCom() { cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; imag \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } void myComplex::outCom(string s) { cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; imag \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } void myComplex::changeReal(double r) { this-\u0026gt;real = r; } // myComplex myComplex::operator-(const myComplex \u0026amp;c) // { // return myComplex(this-\u0026gt;real - c.real, this-\u0026gt;imag - c.imag); //返回一个临时对象 // } myComplex operator+(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2) //c1+c2 { return myComplex(c1.real + c2.real, c1.imag + c2.imag); //返回一个临时对象 } myComplex operator+(const myComplex \u0026amp;c1, double r) //c1+r { return myComplex(c1.real + r, c1.imag); //返回一个临时对象 } myComplex operator+(double r, const myComplex \u0026amp;c1) //r+c2 { return myComplex(r + c1.real, c1.imag); //返回一个临时对象 } myComplex operator-(const myComplex \u0026amp;c1, const myComplex \u0026amp;c2) //c1-c2 { return myComplex(c1.real - c2.real, c1.imag - c2.imag); //返回一个临时对象 } myComplex operator-(const myComplex \u0026amp;c1, double r) //c1-r { return myComplex(c1.real - r, c1.imag); //返回一个临时对象 } myComplex operator-(double r, const myComplex \u0026amp;c1) //r-c1 { return myComplex(r + c1.real, -c1.imag); //返回一个临时对象 } myComplex \u0026amp;myComplex::operator=(const myComplex \u0026amp;c1) { this-\u0026gt;real = c1.real; this-\u0026gt;imag = c1.imag; return *this; } myComplex \u0026amp;myComplex::operator=(double r) { this-\u0026gt;real = r; this-\u0026gt;imag = 0; return *this; } int main() { myComplex c1(1, 2), c2(3, 4), res; c1.outCom(\u0026#34;\\t\\t\\tc1\u0026#34;); c2.outCom(\u0026#34;\\t\\t\\tc2\u0026#34;); res = c1 + c2; res.outCom(\u0026#34;执行 res = c1 + c2 →\\tres\u0026#34;); res = c1.addCom(c2); res.outCom(\u0026#34;执行 res = c1.addCom(c2) →\\tres\u0026#34;); res = c1 + 5; res.outCom(\u0026#34;执行 res = c1 + 5 →\\tres\u0026#34;); res = 5 + c1; res.outCom(\u0026#34;执行 res = 5 + c1 →\\tres\u0026#34;); res = c1; c1.outCom(\u0026#34;\\t\\t\\tc1\u0026#34;); res.outCom(\u0026#34;执行 res = c1 →\\tres\u0026#34;); c1.changeReal(-3); c1.outCom(\u0026#34;执行 changeReal(-3) →\\tc1\u0026#34;); res.outCom(\u0026#34;\\t\\t\\tres\u0026#34;); res = c1; res.outCom(\u0026#34;res = c1 →\\tres\u0026#34;); res = 7; res.outCom(\u0026#34;res = 7 →\\tres\u0026#34;); res = 7 + 8; res.outCom(\u0026#34;res = 7 + 8; →\\tres\u0026#34;); res = c1 = c2; c1.outCom(\u0026#34;\\t\\t\\tc1\u0026#34;); c2.outCom(\u0026#34;\\t\\t\\tc2\u0026#34;); res.outCom(\u0026#34;res = c1 = c2 →\\tres\u0026#34;); return 0; } 浅拷贝和深拷贝\n浅拷贝\n赋值号左侧对象的值一一赋值给左侧对象 如果值得对象涉及指针或引用, 它们之间值相互关联, 因为指向同一个内存地址 深拷贝\n自定义复制构造函数 原复制构造函数，值和指针指向地址都被复制 新复制构造函数，只复制值到新的指针指向的地址 重载赋值运算符 赋值语句是，将一个对象中指针成员变量指向的内容，复制到另一个对象中指针成员变量指向的地方 delete 指针; 释放原指针的内存再保存到新的指针指向的内存地址 深拷贝的实现(4-4)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 #include \u0026lt;iostream\u0026gt; using namespace std; class pointer { public: int a; int *p; pointer() { a = 100; p = new int(10); //初始化内存 *p = 11; //向内存赋值 } pointer(const pointer \u0026amp;temp) //复制构造函数 { if (this != \u0026amp;temp) { a = temp.a; // a 是局部变量，内存跟随对象 p = temp.p; // p 是指针变量，内存固定，需要深度复制 cout \u0026lt;\u0026lt; \u0026#34;*p=\u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \u0026#34;,p=\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; // delete p; //删除指针，新指针的地址还是原来的地址，不能删除 p = new int(*temp.p + 1); //把指针 temp.p 的值赋值给 指针 p *p = *temp.p + 10; //加10更好分辨 *p cout \u0026lt;\u0026lt; \u0026#34;*p=\u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \u0026#34;,p=\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; } } ~pointer() //析构函数 { if (p != NULL) delete p; } pointer operator=(pointer \u0026amp;a) //成员函数 重载赋值运算符 { if (this == \u0026amp;a) return *this; else { delete p; this-\u0026gt;p = new int(*a.p); cout \u0026lt;\u0026lt; \u0026#34;*p3=\u0026#34; \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; \u0026#34;,p3=\u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; return *this; } } }; int main() { pointer p1; pointer p2(p1); pointer p3; p3 = p1; p1.a = 123; *p1.p = 234; cout \u0026lt;\u0026lt; p1.a \u0026lt;\u0026lt; \u0026#34;,p1=\u0026#34; \u0026lt;\u0026lt; *p1.p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p2.a \u0026lt;\u0026lt; \u0026#34;,p2=\u0026#34; \u0026lt;\u0026lt; *p2.p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; p3.a \u0026lt;\u0026lt; \u0026#34;,p3=\u0026#34; \u0026lt;\u0026lt; *p3.p \u0026lt;\u0026lt; endl; return 0; } 第三节 重载流插入运算符和流提取运算符 流插入运算符\n左移运算符 \u0026lt;\u0026lt; 和 cout 一起用于输出, 称为 “流插入运算符” 流提取运算符\n左移运算符 \u0026gt;\u0026gt; 和 cin 一起用于输出, 称为 “流插入运算符” C++ 类库提供的头文件对 \u0026lt;\u0026lt; \u0026gt;\u0026gt; 进行了重载\ncout \u0026lt;\u0026lt; 是 ostream 的对象 cin \u0026gt;\u0026gt; 是 istream 的对象 在头文件 iostream 中声明, 所以要用 #include\u0026lt;iostream\u0026gt; 重载流运算符\n操作符右边是流对象的别名, 不是操作对象\n运算符接在流对象后面, 直接访问类的私有数据 流只能继承不能修改, 重载函数不能是流类库中的成员, 必须重载为类的友元 重载流插入运算符\n1 2 3 4 5 ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp; output, 类名\u0026amp;对象名) { ... return output; } 重载流提取运算符\n1 2 3 4 5 istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp; input, 类名\u0026amp;对象名) { ... return input; } input是 istream 对象的引用, 是 cin 的别名: istream \u0026amp; input = cin; 流插入运算符和流提取运算符重载为友元\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class myComplex { private: double real, imag; public: myComplex() : real(0), imag(0) {} myComplex(double r, double i) : real(r), imag(i) {} friend ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const myComplex \u0026amp;c); //友元,插入 friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is, myComplex \u0026amp;c); //友元,提取 }; ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os, const myComplex \u0026amp;c) { if (c.imag \u0026gt;= 0) { os \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; c.imag \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; //以 a+bi 的形式输入 } else { os \u0026lt;\u0026lt; c.real \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; -c.imag \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; } return os; } istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is, myComplex \u0026amp;c) { string s; is \u0026gt;\u0026gt; s; //将a+bi 作为字符串读入,a+bi中间不能有空格 int pos = s.find(\u0026#34;+\u0026#34;, 0); //查找虚部 if (pos == -1) pos = s.find(\u0026#34;-\u0026#34;, 1); //虚部为负数时 string sReal = s.substr(0, pos); //分离出代表实部的字符串 c.real = atof(sReal.c_str()); //atof() 能将参数内容转换成浮点数 sReal = s.substr(pos, s.length() - pos - 1); //分离出代表虚部的字符串 c.imag = atof(sReal.c_str()); return is; } int main() { myComplex c, c1; int n; cout \u0026lt;\u0026lt; \u0026#34;请输入两个复数([-]a±bi)和一个整数, 以空格分隔\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; n; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; c1; return 0; } 流插入运算符重载为成员函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class myComplex { private: double real, imag; public: myComplex() : real(0), imag(0) {} myComplex(double r, double i) : real(r), imag(i) {} ostream \u0026amp;operator\u0026lt;\u0026lt;(ostream \u0026amp;os); //成员函数 ,插入 friend istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is, myComplex \u0026amp;c); //友元,提取 }; ostream \u0026amp;myComplex::operator\u0026lt;\u0026lt;(ostream \u0026amp;os) { if (this-\u0026gt;imag \u0026gt;= 0) { os \u0026lt;\u0026lt; this-\u0026gt;real \u0026lt;\u0026lt; \u0026#34;+\u0026#34; \u0026lt;\u0026lt; this-\u0026gt;imag \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; //以 a+bi 的形式输入 } else { os \u0026lt;\u0026lt; this-\u0026gt;real \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; -this-\u0026gt;imag \u0026lt;\u0026lt; \u0026#34;i\u0026#34;; } return os; } istream \u0026amp;operator\u0026gt;\u0026gt;(istream \u0026amp;is, myComplex \u0026amp;c) { string s; is \u0026gt;\u0026gt; s; //将a+bi 作为字符串读入,a+bi中间不能有空格 int pos = s.find(\u0026#34;+\u0026#34;, 0); //查找虚部 if (pos == -1) pos = s.find(\u0026#34;-\u0026#34;, 1); //虚部为负数时 string sReal = s.substr(0, pos); //分离出代表实部的字符串 c.real = atof(sReal.c_str()); //atof() 能将参数内容转换成浮点数 sReal = s.substr(pos, s.length() - pos - 1); //分离出代表虚部的字符串 c.imag = atof(sReal.c_str()); return is; } int main() { myComplex c, c1; int n; cout \u0026lt;\u0026lt; \u0026#34;请输入两个复数([-]a±bi)和一个整数, 以空格分隔\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; c \u0026gt;\u0026gt; c1 \u0026gt;\u0026gt; n; c1 \u0026lt;\u0026lt; (c \u0026lt;\u0026lt; cout \u0026lt;\u0026lt; \u0026#34;,\u0026#34;) \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; n; //注意调用形式 return 0; } 第四节 重载强制类型转换运算符 (重要) 类的名字本身也是运算符, 强制类型转换运算符\n是单目运算符, 也可以重载, 但只能重载为成员函数, 不能重载为全局函数\n类型名 对象 重载后等价于 对象.operator 类型名()\n重载强制类型转换运算符 double\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include \u0026lt;iostream\u0026gt; #include \u0026lt;cstdlib\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class myComplex { private: double real, imag; public: myComplex(double r = 0, double i = 0) : real(r), imag(i){}; //成员函数 operator double() //重载强制类型转换运算符 double { return real; } }; int main() { myComplex c(1.2, -3.4); cout \u0026lt;\u0026lt; (double)c \u0026lt;\u0026lt; endl; // c.operator double() 输出1.2 double n = 12 + c; //等价于 double n=12+c.operator double() cout \u0026lt;\u0026lt; n; return 0; } 第五节 重载自增、自减运算符 有前置 后置之分\n允许写一个增加无用int 类型形参的版本, 处理前置时调用参数个数正常的重载函数 处理后置 表达式时, 调用多出一个参数的重载函数 前置 ++，-- 优先级高于赋值，后置自增自减运算优先级低于赋值 自增作为成员函数 自减作为友元\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; using namespace std; class Demo { private: int n; public: Demo(int i = 0) : n(i) {} Demo \u0026amp;operator++(); //用于前置 Demo operator++(int); //用于后置 operator int() { return n; } friend Demo \u0026amp;operator--(Demo \u0026amp;); friend Demo operator--(Demo \u0026amp;, int); }; Demo \u0026amp;Demo::operator++() //前置++ { n++; return *this; } Demo Demo::operator++(int k) //后置++ { Demo tmp(*this); //记录修改前的对象 n++; return tmp; //返回修改前对象 } Demo \u0026amp;operator--(Demo \u0026amp;d) //前置-- { d.n--; return d; } Demo operator--(Demo \u0026amp;d, int) //后置-- { Demo tmp(d); d.n--; return tmp; } int main() { Demo d(10); cout \u0026lt;\u0026lt; (d++) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // d.operator++(0) cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; (++d) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // d.operator++() cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; (d--) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // d.operator--(d,0) cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; (--d) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // d.operator--(d) cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; return 0; } 都作为成员函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; using namespace std; class Demo { private: int n; public: Demo(int i = 0) : n(i) {} Demo \u0026amp;operator++(); //用于前置 Demo operator++(int); //用于后置 operator int() { return n; } Demo \u0026amp;operator--(); Demo operator--(int); }; Demo \u0026amp;Demo::operator++() //前置++ { n++; return *this; } Demo Demo::operator++(int k) //后置++ { Demo tmp(*this); //记录修改前的对象 n++; return tmp; //返回修改前对象 } Demo \u0026amp;Demo::operator--() //前置-- { n--; return *this; } Demo Demo::operator--(int k) //后置-- { Demo tmp(*this); n--; return tmp; } int main() { Demo d(10); cout \u0026lt;\u0026lt; (d++) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // d.operator++(0) cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; (++d) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // d.operator++() cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; (d--) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // d.operator--(d,0) cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; cout \u0026lt;\u0026lt; (--d) \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; // d.operator--(d) cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;,\u0026#34;; return 0; } 第五章 类的继承与派生 类的继承与派生 继承关系中友元和静态成员变量的派生特点 单重继承与多重继承，派生层次 权限控制符，基类和派生类之间的访问形式 派生类的构造函数和析构函数 类之间的关系 类与派生类指针 第一节 类的继承与类的派生 继承的概念\n通过已有的类建立新类的过程, 叫做派生;\n原来的类叫基类, 也叫父类或一般类; 新类称为派生类/ 子类/ 特殊类 除构造函数和析构函数外, 基类所有成员派生为子类成员\n子类中可以增加/修改成员和权限 覆盖\n派生类成员覆盖基类同名成员, 也称为重定义/ 重写/ 同名隐藏 派生类的定义与大小\n格式\n1 2 3 4 class 派生类名:继承方式说明符 基类名 { 类名 }; 继承方式说明符指明基类成员在派生类中的访问属性, 一般用 public 派生类的大小\n派生类大小 = 基类成员变量大小 + 派生类对象自身成员变量大小 对象的大小只与普通成员变量有关 字节补齐原则 char 变量占 1字节, 补齐为 4 字节 空类的大小是1 32位系统 指针 4 字节, 64 位系统指针 8 字节 继承关系的特殊性\n基类的 友元类/友元函数, 派生类不继承 友元类/友元函数\n基类/成员是 某类的友元函数, 派生类继承友元关系\n如果基类中的成员是静态的，派生类中也是静态的，静态属性可继承(5-4)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { private: float x; public: static int staV; Base() { staV++; } }; int Base::staV = 0; class Derived : public Base { private: float y; public: Derived() { staV++; } }; int main() { Base a; cout \u0026lt;\u0026lt; a.staV \u0026lt;\u0026lt; endl; Derived d; cout \u0026lt;\u0026lt; d.staV \u0026lt;\u0026lt; endl; return 0; } 有继承关系的类之间的访问\n如果派生类声明了与基类成员函数同名函数, 即使参数表不同, 继承的同名函数会被隐藏\n访问被隐藏的成员, 使用基类名和作用域分辨符来限定 访问基类和派生类成员的方式(5-5)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #include \u0026lt;iostream\u0026gt; using namespace std; class CB { public: int a; CB(int x) { a = x; } void showa() { cout \u0026lt;\u0026lt; \u0026#34;Class Cb--a=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } }; class CD : public CB { public: int a; //与基类同名 CD(int x, int y) : CB(x) //x 初始化基类的成员变量a { a = y; } void showa() //基类同名函数 { cout \u0026lt;\u0026lt; \u0026#34;Class CD--a\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; } void print2a() { cout \u0026lt;\u0026lt; \u0026#34;a=\u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; //访问派生类a cout \u0026lt;\u0026lt; \u0026#34;CB::a=\u0026#34; \u0026lt;\u0026lt; CB::a \u0026lt;\u0026lt; endl; //访问基类a } }; int main() { CB CBobj(12); CBobj.showa(); CD CDobj(48, 999); CDobj.showa(); //访问派生类的showa() CDobj.CB::showa(); //访问基类的showa() cout \u0026lt;\u0026lt; \u0026#34;CDobj.a\u0026#34; \u0026lt;\u0026lt; CDobj.a \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;CDobj.CB::a=\u0026#34; \u0026lt;\u0026lt; CDobj.CB::a \u0026lt;\u0026lt; endl; return 0; } 类之间的访问示例(5-6)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class CStudent //基类 { private: string name; //姓名 string id; //学号 char gender; //性别,\u0026#39;F\u0026#39;代表女生, \u0026#39;M\u0026#39;代表男生 int age; //年龄 public: void PrintInfo(); void SetInfo(const string \u0026amp;, const string \u0026amp;, int, char); void SetName(string); string GetName(); void SetId(string); string GetId(); }; void CStudent::PrintInfo() { cout \u0026lt;\u0026lt; \u0026#34;姓名:\\t\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;学号:\\t\u0026#34; \u0026lt;\u0026lt; id \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;年龄:\\t\u0026#34; \u0026lt;\u0026lt; age \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;性别:\\t\u0026#34; \u0026lt;\u0026lt; gender \u0026lt;\u0026lt; endl; } void CStudent::SetInfo(const string \u0026amp;name_, const string \u0026amp;id_, int age_, char gender_) { name = name_; id = id_; age = age_; gender = gender_; } void CStudent::SetName(string name) { this-\u0026gt;name = name; } string CStudent::GetName() { return name; } void CStudent::SetId(string id) { this-\u0026gt;id = id; } string CStudent::GetId() { return id; } class CUndergraduateStudent : public CStudent //本科生类, 继承于类 CStudent { private: string department; //学生所属的系名 public: void PrintInfo(); void SetInfo(const string \u0026amp;, const string \u0026amp;, int, char, const string \u0026amp;); }; void CUndergraduateStudent::PrintInfo() { CStudent::PrintInfo(); cout \u0026lt;\u0026lt; \u0026#34;院系:\\t\u0026#34; \u0026lt;\u0026lt; department \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; endl; } void CUndergraduateStudent::SetInfo(const string \u0026amp;name_, const string \u0026amp;id_, int age_, char gender_, const string \u0026amp;department_) { CStudent::SetInfo(name_, id_, age_, gender_); department = department_; } class CGraduatedStudent : public CStudent //研究生类 { private: string department; //学生所属的系名 string advisor; //导师 public: void PrintInfo(); void SetInfo(const string \u0026amp;name_, const string \u0026amp;id_, int age_, char gender_, const string \u0026amp;department_, const string \u0026amp;advisor_); }; void CGraduatedStudent::PrintInfo() { CStudent::PrintInfo(); cout \u0026lt;\u0026lt; \u0026#34;院系:\\t\u0026#34; \u0026lt;\u0026lt; department \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;导师:\\t\u0026#34; \u0026lt;\u0026lt; advisor \u0026lt;\u0026lt; endl; } void CGraduatedStudent::SetInfo(const string \u0026amp;name_, const string \u0026amp;id_, int age_, char gender_, const string \u0026amp;department_, const string \u0026amp;advisor_) { CStudent::SetInfo(name_, id_, age_, gender_); department = department_; advisor = advisor_; } int main() { CStudent s1; CUndergraduateStudent s2; CGraduatedStudent s3; s2.SetInfo(\u0026#34;张三\u0026#34;, \u0026#34;2020-6-2-4\u0026#34;, 19, \u0026#39;M\u0026#39;, \u0026#34;数学系\u0026#34;); s3.SetInfo(\u0026#34;李四\u0026#34;, \u0026#34;M2021-12\u0026#34;, 19, \u0026#39;F\u0026#39;, \u0026#34;计算机系\u0026#34;, \u0026#34;罗教授\u0026#34;); s2.PrintInfo(); s3.PrintInfo(); cout \u0026lt;\u0026lt; s2.GetName() \u0026lt;\u0026lt; endl; s2.SetName(\u0026#34;王五\u0026#34;); s2.PrintInfo(); cout \u0026lt;\u0026lt; s2.GetName() \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; s2.GetId() \u0026lt;\u0026lt; endl; return 0; } 类之间的访问(5-7)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class employee //基类 { short age; float salary; protected: string name; public: employee(short ag, float sa, string na) { age = ag; salary = sa; name = na; }; void print() { cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;:\\t\u0026#34;; cout \u0026lt;\u0026lt; age \u0026lt;\u0026lt; \u0026#34;:\\t\u0026#34;; cout \u0026lt;\u0026lt; salary; }; ~employee() {} }; class manager : public employee //派生类 { int level; public: manager(short ag, float sa, string na, int lev) : employee(ag, sa, na) //初始化基类 { level = lev; } void print() { employee::print(); cout \u0026lt;\u0026lt; \u0026#34;\\tlevel:\u0026#34; \u0026lt;\u0026lt; level; } }; class engineer : public employee // { char speciality, adegree; public: engineer(short ag, float sa, string na, char spe, char ade) : employee(ag, sa, na) //初始化基类 { speciality = spe; adegree = ade; } void print() { employee::print(); cout \u0026lt;\u0026lt; \u0026#34;\\tspeciality:\u0026#34; \u0026lt;\u0026lt; speciality; cout \u0026lt;\u0026lt; \u0026#34;\\tadegree:\u0026#34; \u0026lt;\u0026lt; adegree; } }; enum ptitle { PS, GM, VPS, VGM }; class director : public manager { ptitle post; public: director(short ag, float sa, string na, int le, ptitle po) : manager(ag, sa, na, le) //初始化基类 { post = po; } void print() { manager::print(); cout \u0026lt;\u0026lt; \u0026#34;\\tpost:\u0026#34; \u0026lt;\u0026lt; post \u0026lt;\u0026lt; endl; } }; int main() { employee emp1(23, 610.5, \u0026#34;wang\u0026#34;), emp2(27, 824.75, \u0026#34;li\u0026#34;); manager man1(32, 812.45, \u0026#34;zhang\u0026#34;, 11), man2(34, 1200.5, \u0026#34;chen\u0026#34;, 7); engineer eng(26, 1420.10, \u0026#34;sun\u0026#34;, \u0026#39;E\u0026#39;, \u0026#39;M\u0026#39;); director dir(38, 1800.2, \u0026#34;liu\u0026#34;, 2, VPS); emp1.print(); emp2.print(); man1.print(); man2.employee::print(); eng.print(); dir.print(); return 0; } protected 访问范围说明符\n保护成员访问范围比私有成员大, 基类的保护成员可以被派生类成员函数访问 基类需要隐藏的成员一般设置为保护成员, 方便派生类成员访问 多重继承\n一个类同时有多个基类\n格式\n1 2 3 4 class 派生类名:继承方式说明符 基类名1, 继承方式说明符 基类名2, ... ,继承方式说明符 基类名n { 类体 } 派生类继承了所有成员变量和成员函数, 和普通继承一样 如果多个基类成员重名\n对派生类而言, 不加类名限定时默认访问的是派生类成员; 访问基类成员时, 加对应类名限定; 如果重名成员继承到派生类中, 不加限定访问会产生二义性问题 多重继承(5-11)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;iostream\u0026gt; using namespace std; class BaseClass1 //基类 { public: int v1, v2; BaseClass1(); BaseClass1(int, int); ~BaseClass1(); }; BaseClass1::BaseClass1() { cout \u0026lt;\u0026lt; \u0026#34;BaseClass1 No parameter\u0026#34; \u0026lt;\u0026lt; endl; } BaseClass1::BaseClass1(int m, int n) : v1(m), v2(n) { cout \u0026lt;\u0026lt; \u0026#34;BaseClass1 Two parameter\u0026#34; \u0026lt;\u0026lt; endl; } BaseClass1::~BaseClass1() { cout \u0026lt;\u0026lt; \u0026#34;BaseClass1 Destroy\u0026#34; \u0026lt;\u0026lt; endl; } class BaseClass2 { public: int v1, v4; BaseClass2(); BaseClass2(int, int); ~BaseClass2(); }; BaseClass2::BaseClass2() { cout \u0026lt;\u0026lt; \u0026#34;BaseClass2 No parameter\u0026#34; \u0026lt;\u0026lt; endl; } BaseClass2::BaseClass2(int m, int n) : v1(m), v4(n) { cout \u0026lt;\u0026lt; \u0026#34;BaseClass2 Two parameter\u0026#34; \u0026lt;\u0026lt; endl; } BaseClass2::~BaseClass2() { cout \u0026lt;\u0026lt; \u0026#34;BaseClass2 Destroy\u0026#34; \u0026lt;\u0026lt; endl; } class DerivedClasss : public BaseClass1, public BaseClass2 { public: int v3; public: DerivedClasss(); DerivedClasss(int); DerivedClasss(int, int, int, int); ~DerivedClasss(); }; DerivedClasss::DerivedClasss() { cout \u0026lt;\u0026lt; \u0026#34;DerivedClasss No parameter\u0026#34; \u0026lt;\u0026lt; endl; } DerivedClasss::DerivedClasss(int k) : v3(k) { cout \u0026lt;\u0026lt; \u0026#34;DerivedClasss One parameter\u0026#34; \u0026lt;\u0026lt; endl; } DerivedClasss::DerivedClasss(int m, int n, int k, int t) : BaseClass1(m, n), BaseClass2(m, t), v3(k) { cout \u0026lt;\u0026lt; \u0026#34;DerivedClasss Four parameter\u0026#34; \u0026lt;\u0026lt; endl; } DerivedClasss::~DerivedClasss() { cout \u0026lt;\u0026lt; \u0026#34;DerivedClasss Destroy\u0026#34; \u0026lt;\u0026lt; endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34; create object with parameter\u0026#34; \u0026lt;\u0026lt; endl; DerivedClasss derivedCla1(1000, 2000, 3000, 4000); cout \u0026lt;\u0026lt; \u0026#34;v1=\u0026#34; \u0026lt;\u0026lt; derivedCla1.BaseClass1::v1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v2=\u0026#34; \u0026lt;\u0026lt; derivedCla1.v2 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v1=\u0026#34; \u0026lt;\u0026lt; derivedCla1.BaseClass2::v1 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v4=\u0026#34; \u0026lt;\u0026lt; derivedCla1.v4 \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;v3=\u0026#34; \u0026lt;\u0026lt; derivedCla1.v3 \u0026lt;\u0026lt; endl; return 0; } 第二节 访问控制 公有控制\n基类的公有成员和保护成员的访问属性在派生类中不变, 而基类的私有成员在基类外不可直接访问, 派生类不能访问私有成员\n公有继承访问控制\n各成员 派生类中 基类与派生类外 基类的公有成员 直接访问 直接访问 基类的保护成员 直接访问 调用共有函数访问 基类的私有成员 调用共有函数访问 调用共有函数访问 从基类继承的公有成员 直接访问 直接访问 从基类继承的保护成员 直接访问 调用共有函数访问 从基类继承的私有成员 调用共有函数访问 调用共有函数访问 派生类中定义的公有成员 直接访问 直接访问 派生类中定义的保护成员 直接访问 调用共有函数访问 派生类中定义的私有成员 直接访问 调用共有函数访问 方便统一处理, 提高程序效率\n函数的形参为基类的对象/引用/指针时, 实参可以使派生类的对象/指针, 不用为每个类设计单独的模块 类型兼容规则\n任何需要基类对象的地方, 都可以用公有派生类的对象来替代, 也称为 赋值兼容规则\n派生类的对象可以赋值给基类对象 派生类对象可以用来初始化基类引用 派生类对象的地址可以赋值给基类指针, 即派生类的指针可以赋值给基类的指针 此规则反过来不成立\n验证类型兼容规则输出的结果(5-14)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; using namespace std; class A //基类 { int an; public: A() {} A(int n) { an = n; } void print() { cout \u0026lt;\u0026lt; \u0026#34;A 的对象:\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;an:\u0026#34; \u0026lt;\u0026lt; an; } void print(int k) { cout \u0026lt;\u0026lt; \u0026#34;an:\u0026#34; \u0026lt;\u0026lt; an; } }; class B : public A { int bn; public: B(int n) : A(2 * n) { bn = n; } void print() { cout \u0026lt;\u0026lt; \u0026#34;\\nB 的对象:\u0026#34;; A::print(1); cout \u0026lt;\u0026lt; \u0026#34;, bn=\u0026#34; \u0026lt;\u0026lt; bn \u0026lt;\u0026lt; endl; } }; int main() { A a(10); B b(20); a.print(); b.print(); a = b; a.print(); b.print(); return 0; } 私有继承\n基类中的公有成员和保护成员都以私有成员身份出现在派生类中, 基类的私有成员在派生类中不可直接访问 第一级派生中 第二级派生中 基类与派生类外 基类的公有成员 直接访问 不可访问 不可访问 基类的保护成员 直接访问 不可访问 不可访问 基类的私有成员 调用公有函数访问 不可访问 不可访问 保护继承\n基类中公有成员和保护成员都以保护成员继承到派生类中, 私有成员不可直接访问 第三节 派生类的构造函数和析构函数 构造函数与析构函数\n派生类不继承构造函数, 需要在派生类的构造函数中调用基类的构造函数, 已完成继承成员的初始化\n执行派生类构造函数前, 总是先执行基类的构造函数, 调用顺序为派生继承时的基类声明顺序 派生对象销毁时, 析构函数反之, 先执行派生类的析构函数, 在执行基类析构函数 派生类在构造函数中添加初始化列表, 说明基类成员变量如何初始化\n只要基类不是默认构造函数, 都要显式给出基类名和参数表\n基类定义了带有形参的构造函数, 派生类就应当定义构造函数\n格式\n1 2 3 4 派生类名::派生类名(参数表):基类名1(基类1 初始化参数表), ... ,基类名m (基类m 初始化参数表), 成员对象名1(成员对象1 初始化参数表), ... ,成员对象名n (成员对象n 初始化参数表) { 派生类构造函数函数体 //其它初始化操作 } 基类和派生类的构造/解析函数(5-15)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 #include \u0026lt;iostream\u0026gt; using namespace std; class BaseClass { protected: int v1, v2; public: BaseClass(); BaseClass(int, int); ~BaseClass(); }; BaseClass::BaseClass() { cout \u0026lt;\u0026lt; \u0026#34;BaseClass No parameter\u0026#34; \u0026lt;\u0026lt; endl; } BaseClass::BaseClass(int m, int n) { v1 = m; v2 = n; cout \u0026lt;\u0026lt; \u0026#34;BaseClass Two parameter\u0026#34; \u0026lt;\u0026lt; endl; } BaseClass::~BaseClass() { cout \u0026lt;\u0026lt; \u0026#34;BaseClass Destroy\u0026#34; \u0026lt;\u0026lt; endl; } class DerivedClass : public BaseClass { int v3; public: DerivedClass(); DerivedClass(int); DerivedClass(int, int, int); ~DerivedClass(); }; DerivedClass::DerivedClass() { cout \u0026lt;\u0026lt; \u0026#34;DerivedClass No parameter\u0026#34; \u0026lt;\u0026lt; endl; } DerivedClass::DerivedClass(int k) : v3(k) { cout \u0026lt;\u0026lt; \u0026#34;DerivedClass One parameter\u0026#34; \u0026lt;\u0026lt; endl; } DerivedClass::DerivedClass(int m, int n, int k) : BaseClass(m, n), v3(k) { cout \u0026lt;\u0026lt; \u0026#34;DerivedClass Three parameter\u0026#34; \u0026lt;\u0026lt; endl; } DerivedClass::~DerivedClass() { cout \u0026lt;\u0026lt; \u0026#34;DerivedClass Destroy\u0026#34; \u0026lt;\u0026lt; endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;create no parameter object\u0026#34; \u0026lt;\u0026lt; endl; BaseClass baseCla; DerivedClass derivedCla; cout \u0026lt;\u0026lt; \u0026#34;create with parameter object\u0026#34; \u0026lt;\u0026lt; endl; BaseClass baseCla1(10, 20); DerivedClass derivedCla1(30); return 0; } 派生类函数执行的一般次序\n调用基类构造函数, 调用顺序按照被继承时声明的顺序(从左至右) 对派生类新增成员变量的初始化, 调用顺序按照类中的声明顺序 执行派生类的构造函数体中的内容 调用基类和派生类的构造函数/析构函数和成员函数(5-16)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include \u0026lt;iostream\u0026gt; using namespace std; class Base //基类 { private: int Y; public: Base(int y = 0) { Y = y; cout \u0026lt;\u0026lt; \u0026#34;Base(\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } ~Base() { cout \u0026lt;\u0026lt; \u0026#34;~Base()\u0026#34; \u0026lt;\u0026lt; endl; } void print() { cout \u0026lt;\u0026lt; Y \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } }; class Derived : public Base { private: int Z; public: Derived(int y, int z) : Base(y) { Z = z; cout \u0026lt;\u0026lt; \u0026#34;Derived(\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } ~Derived() { cout \u0026lt;\u0026lt; \u0026#34;~Derived()\u0026#34; \u0026lt;\u0026lt; endl; } void print() { Base::print(); cout \u0026lt;\u0026lt; Z \u0026lt;\u0026lt; endl; } }; int main() { Derived d(10, 20); d.print(); return 0; } 复制构造函数\n一个类, 自动生成复制构造函数或自定义\n默认的复制构造函数自动调用基类的复制构造函数, 对派生类新增的成员对象复制 派生类中的复制构造函数(5-17)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include \u0026lt;iostream\u0026gt; using namespace std; class A //基类 { public: A() { i = 100; cout \u0026lt;\u0026lt; \u0026#34;class A default construct function\u0026#34; \u0026lt;\u0026lt; endl; } A(const A \u0026amp;s) { i = s.i; cout \u0026lt;\u0026lt; \u0026#34;calss A copy construct funciton\u0026#34; \u0026lt;\u0026lt; endl; } int getValue(); void setValue(int); private: int i; }; int A::getValue() { return i; } void A::setValue(int k) { i = k; } class B : public A { private: float f; public: B() { f = 20.1; cout \u0026lt;\u0026lt; \u0026#34;class B default construct function\u0026#34; \u0026lt;\u0026lt; endl; } B(const B \u0026amp;v) : A::A(v), f(v.f) { cout \u0026lt;\u0026lt; \u0026#34;class B copy construct function\u0026#34; \u0026lt;\u0026lt; endl; } float getValue(); int getValue1() { return A::getValue(); } }; float B::getValue() { return f; } int main() { A a; B b; B bb(b); //调用类A 复制构造函数、类B 赋值构造函数 return 0; } 赋值运算符的重载及使用(5-18)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: Base() {} Base(Base \u0026amp;c) { cout \u0026lt;\u0026lt; \u0026#34;Base 复制构造函数\u0026#34; \u0026lt;\u0026lt; endl; } Base operator=(const Base \u0026amp;b) { cout \u0026lt;\u0026lt; \u0026#34;Base::operator=\u0026#34; \u0026lt;\u0026lt; endl; return *this; } }; class Derived : public Base { public: Derived() { cout \u0026lt;\u0026lt; \u0026#34;Derived::构造函数\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Derived d1, d2; Derived d3(d1); // d3 初始化过程中会调用类 Base 的复制构造函数 d2 = d1; // 会调用类 Base 的重载运算符“=”运算符 return 0; } 多重继承的构造函数与析构函数\nDerived::Derived() : Base(0, 0), Base2(0,0), v3(0) //派生类构造函数参数表的默认参数决定基类调用的构造函数参数，不应该为空 class Derived : public Base, public Base2 多重继承类定义时间接类的声明顺序就是初始化顺序\n多重继承(5-19) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 #include \u0026lt;iostream\u0026gt; using namespace std; class Base //基类 { protected: int v1, v2; public: Base(); Base(int, int); ~Base(); void SetValue(int, int); void PrintValue(); }; Base::Base() : v1(0), v2(0) //无参数时初始化成员变量 { cout \u0026lt;\u0026lt; \u0026#34;Base 无参构造函数\u0026#34; \u0026lt;\u0026lt; endl; } Base::Base(int m, int n) : v1(m), v2(n) { v1 = m; v2 = n; cout \u0026lt;\u0026lt; \u0026#34;Base 带2个参数构造函数, \u0026#34; \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; v2 \u0026lt;\u0026lt; endl; } Base::~Base() { cout \u0026lt;\u0026lt; \u0026#34;Base 析构函数\u0026#34; \u0026lt;\u0026lt; endl; } void Base::SetValue(int m, int n) { v1 = m; v2 = n; } void Base::PrintValue() { cout \u0026lt;\u0026lt; \u0026#34;v1=\u0026#34; \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026#34;\\tv2=\u0026#34; \u0026lt;\u0026lt; v2 \u0026lt;\u0026lt; endl; } class Base2 //基类 { protected: int v1, v4; public: Base2(); Base2(int, int); ~Base2(); void SetValue(int, int); void PrintValue(); }; Base2::Base2() : v1(0), v4(0) //无参数时初始化成员变量 { cout \u0026lt;\u0026lt; \u0026#34;Base2 无参构造函数\u0026#34; \u0026lt;\u0026lt; endl; } Base2::Base2(int m, int n) : v1(m), v4(n) { v1 = m; v4 = n; cout \u0026lt;\u0026lt; \u0026#34;Base2 带2个参数构造函数, \u0026#34; \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; v4 \u0026lt;\u0026lt; endl; } Base2::~Base2() { cout \u0026lt;\u0026lt; \u0026#34;Base2 析构函数\u0026#34; \u0026lt;\u0026lt; endl; } void Base2::SetValue(int m, int n) { v1 = m; v4 = n; } void Base2::PrintValue() { cout \u0026lt;\u0026lt; \u0026#34;v1=\u0026#34; \u0026lt;\u0026lt; v1 \u0026lt;\u0026lt; \u0026#34;\\tv4=\u0026#34; \u0026lt;\u0026lt; v4 \u0026lt;\u0026lt; endl; } class Derived : public Base, public Base2 { public: int v3; public: Derived(); Derived(int); Derived(int, int, int, int); ~Derived(); void SetValue(int m, int n, int k, int h) { Base::SetValue(m, n); Base2::SetValue(2 * m, h); v3 = k; } void SetValue(int m, int n, int k) { Base::SetValue(m, n); Base2::SetValue(2 * m, 2 * n); v3 = k; } void SetValue(int m, int n) { Base::SetValue(m, n); Base2::SetValue(-1, -1); v3 = -1; } void PrintValue(); }; Derived::Derived() : Base(0, 0), Base2(), v3(0) //此处默认参数决定基类调用的构造函数参数 { cout \u0026lt;\u0026lt; \u0026#34;Derived 无参构造函数\u0026#34; \u0026lt;\u0026lt; endl; } Derived::Derived(int k) { v3 = k; cout \u0026lt;\u0026lt; \u0026#34;带1个参数构造函数\u0026#34; \u0026lt;\u0026lt; endl; } Derived::Derived(int m, int n, int k, int t) : Base(m, n), Base2(m, t), v3(k) { cout \u0026lt;\u0026lt; \u0026#34;带4个参数构造函数\u0026#34; \u0026lt;\u0026lt; endl; } Derived::~Derived() { cout \u0026lt;\u0026lt; \u0026#34;Derived 析构函数\u0026#34; \u0026lt;\u0026lt; endl; } void Derived::PrintValue() { Base::PrintValue(); cout \u0026lt;\u0026lt; \u0026#34;\\tv3=\u0026#34; \u0026lt;\u0026lt; v3 \u0026lt;\u0026lt; endl; Base2::PrintValue(); cout \u0026lt;\u0026lt; endl; } int main() { cout \u0026lt;\u0026lt; \u0026#34;带4个参数对象的创建\u0026#34; \u0026lt;\u0026lt; endl; Derived derived(1000, 2000, 3000, 4000); derived.PrintValue(); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;不带参数对象的创建\u0026#34; \u0026lt;\u0026lt; endl; Derived derived2; derived2.PrintValue(); cout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; \u0026#34;带1个参数对象的创建\u0026#34; \u0026lt;\u0026lt; endl; Derived derived3(111); derived3.PrintValue(); return 0; } ``` 第四节 类之间的关系 类与类之间的关系\n使用已有类编写新类的两种方式 继承 “is a” 和组合 “has a” 继承关系和组合关系(包含关系) 封闭类的派生\n一个类的成员变量是另一个类的对象, 称为封闭类\n定义封闭类构造函数的一般形式:\n1 2 3 4 类名::类名(形参表): 内嵌对象1(形参表),内前对象2(形参表), ... { 类体 } 内嵌对象1(形参表),内前对象2(形参表), ... 是初始化列表, 对内嵌对象进行初始化 封闭类的构造函数(5-20)\n互包含关系的类\n两个类相互引用, 称为循环依赖的类\n1 2 3 4 5 6 7 8 9 10 class A //类 A 的定义 { public: void f(B b); //以类B对象为参数的成员函数 }; class B //定义类 B { public: void g(A a); //以类A对象为参数的成员函数 } 会编译错误 向前引用声明\n引用未定义的类之前, 将该类的名字告诉编译器, 完整类的定义可以写在其他地方 在提供一个完整的类定义之前, 不能定义该类的对象, 也不能内联成员函数中使用该类的对象 相互包含的类(5-21)\n第五节 多层次的派生 类之间的继承关系具有传递性\n派生类成员包括\n派生类自己定义的成员 直接基类中定义的成员 间接基类中定义的全部成员 生成派生类对象时, 会依次执行所有基类的构造函数, 最后执行派生类的构造函数; 析构反之\n初始化列表中，从右往左执行构造函数 一个类可以是多个类的直接基类, 只能说明一次\n一个类可以多次成为某个派生类的间接基类 多级派生时构造函数的调用(5-22)\n第六节 基类与派生类指针的相互转换 公有派生时, 派生类对象也是基类对象, 所以派生类对象可以赋值给基类对象\n使用指针指向派生类对象, 或派生类指针赋值给基类指针 不能通过基类指针访问基类没有而派生类有的成员函数 派生类指针赋值给基类指针 即使基类指针指向派生类对象, 不能通过基类指针访问派生类中定义的函数 当派生类指针指向基类对象时, 必须要将基类对象强制类型转换, 才能赋值给派生类指针 基类指针不能直接赋值给派生类指针 通过强制类型转换,可以将基类指针强制转换成派生类指针后再赋值给派生类指针 下面的代码演示了基类和派生类指针的互相转换：(5-23)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include \u0026lt;iostream\u0026gt; using namespace std; class CBase { protected: int n; public: CBase(int i) :n(i) { } void Print() { cout \u0026lt;\u0026lt; \u0026#34;CBase:n=\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; } }; class CDerived :public CBase { public: int v; CDerived(int i) :CBase(i), v(2 * i) { } void Func() { }; void Print() { cout \u0026lt;\u0026lt; \u0026#34;CDerived:n=\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;CDerived:v=\u0026#34; \u0026lt;\u0026lt; v \u0026lt;\u0026lt; endl; } }; int main() { CDerived objDerived(3); CBase objBase(5); CBase * pBase = \u0026amp;objDerived; // 使得基类指针指向派生类对象 //pBase-\u0026gt;Func(); //错, CBase类没有Func()成员函数 //pBase-\u0026gt;v = 5; //错 CBase类没有v成员变量 pBase-\u0026gt;Print(); cout \u0026lt;\u0026lt; \u0026#34;1)------------\u0026#34; \u0026lt;\u0026lt; endl; //CDerived * pDerived = \u0026amp; objBase; //错，不能将基类指针赋值给派生类指针 CDerived * pDerived = (CDerived *)(\u0026amp;objBase); //等同于 CDerived *pDerived = static_cast\u0026lt;CDerived *\u0026gt;(\u0026amp;objBase); pDerived-\u0026gt;Print(); //慎用，可能出现不可预期的错误 cout \u0026lt;\u0026lt; \u0026#34;2)------------\u0026#34; \u0026lt;\u0026lt; endl; objDerived.Print(); cout \u0026lt;\u0026lt; \u0026#34;3)------------\u0026#34; \u0026lt;\u0026lt; endl; pDerived-\u0026gt;v = 128; //往别人的空间里写入数据，会有问题 objDerived.Print(); return 0; } 基类引用也可以强制类型转换为派生类引用\n强制转换都存在安全隐患\ndynamic_cast 强制类型转换运算符, 判断转换是否安全 (指针或引用是否真的指向派生类对象) 各种类型转换示例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { int n; public: Base() //没有方法内容会报错 { cout \u0026lt;\u0026lt; \u0026#34;基类\u0026#34; \u0026lt;\u0026lt; endl; } void Print() { cout \u0026lt;\u0026lt; \u0026#34;基类打印\u0026#34; \u0026lt;\u0026lt; endl; } }; class Derived : public Base { public: Derived() { cout \u0026lt;\u0026lt; \u0026#34;派生类\u0026#34; \u0026lt;\u0026lt; endl; } void Print() { cout \u0026lt;\u0026lt; \u0026#34;派生类打印\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { Base b; Derived der; cout \u0026lt;\u0026lt; \u0026#34;-----基类指针指向派生类对象-------\u0026#34; \u0026lt;\u0026lt; endl; Base *pBase = \u0026amp;der; //基类指针指向派生类对象 pBase-\u0026gt;Print(); //基类 Print 函数 cout \u0026lt;\u0026lt; \u0026#34;-------基类指针指向基类对象-----\u0026#34; \u0026lt;\u0026lt; endl; pBase = \u0026amp;b; //基类指针指向基类对象 pBase-\u0026gt;Print(); //基类 Print 函数 cout \u0026lt;\u0026lt; \u0026#34;-------派生类对象转换为基类对象-----\u0026#34; \u0026lt;\u0026lt; endl; ((Base)der).Print(); //指针或对象是什么类型就调用什么类型的函数 // ((Derived)b).Print(); //基类对象无法转换为派生类对象 cout \u0026lt;\u0026lt; \u0026#34;------派生类指针指向派生类对象------\u0026#34; \u0026lt;\u0026lt; endl; Derived *pDer = \u0026amp;der; //派生类指针指向派生类对象 pDer-\u0026gt;Print(); //派生类 Print 函数 cout \u0026lt;\u0026lt; \u0026#34;-----派生类指针指向基类指针转换成派生类指针-------\u0026#34; \u0026lt;\u0026lt; endl; pDer = (Derived *)(pBase); //基类指针转换成派生类指针赋值给派生类指针 pDer-\u0026gt;Print(); //派生类 Print 函数 cout \u0026lt;\u0026lt; \u0026#34;-----派生类指针指向转换成派生类型的基类对象-------\u0026#34; \u0026lt;\u0026lt; endl; pDer = (Derived *)(\u0026amp;b); //派生类指针指向转换成派生类型的基类对象 pDer-\u0026gt;Print(); //派生类 Print 函数 cout \u0026lt;\u0026lt; \u0026#34;-----派生类指针转换成基类指针-------\u0026#34; \u0026lt;\u0026lt; endl; pBase = ((Base *)(pDer)); //派生类指针转换成基类指针 pBase-\u0026gt;Print(); //基类 Print 函数 cout \u0026lt;\u0026lt; \u0026#34;-----函数调用-------\u0026#34; \u0026lt;\u0026lt; endl; pDer-\u0026gt;Base::Print(); //派生类指针调用基类函数 pBase-\u0026gt;Base::Print(); //基类指针调用基类函数 ((Derived *)(pBase))-\u0026gt;Print(); //基类指针转换派生指针调用派生类函数 pBase-\u0026gt;Print(); pDer-\u0026gt;Print(); return 0; } 第六章 多态与虚函数 多态原理 虚析构函数 纯虚函数 第一节 多态的基本概念 面对对象程序设计语言有封装/继承/多态三种机制\n多态\n编译时多态\n根据实参确定调用哪个函数 运行时多态\n继承/虚函数 函数调用与代码入口地址的绑定需要在运行时刻再能确定, 称为动态联编/ 动态绑定 类之间满足赋值兼容的前提下, 实现动态绑定必须满足两个条件\n必须声明虚函数 通过基类类型的引用或者指针调用虚函数 虚函数\nvirtual 关键字只在类定义中的成员函数声明处使用, 不能在类外部成员写函数体时使用 静态成员函数不能是虚函数 包含虚函数的类称为“多态类” virtual 函数返回值类型 函数名(形参表); 注意 虽然虚函数声明为内联不会引起错误, 但因为内联函数是在编译阶段进行动态处理的, 而对虚函数的调用是动态绑定的, 所以虚函数一般不声明为内联函数 派生类重写基类的虚函数实现多态, 要求函数名/参数列表及返回值类型要完全相同 基类中定义了虚函数, 在派生类中该函数始终个保持虚函数的特性 只有类的非静态成员函数才能定义为虚函数, 静态成员函数和友元函数不能定义为虚函数 如果虚函数的定义是在类体外, 则只需在声明函数时添加 virtual 关键字, 定义时不加 virtual 关键字 构造函数不能定义为虚函数, operator= 容易混淆, 也不要定义为虚函数 不要在构造函数和析构函数中调用虚函数, 构造/析构函数中, 对象不完整 最好将基类的析构函数声明为虚函数 全局函数不属于类, 没有继承关系, 无法覆盖, 不能使用多态 通过基类指针实现多态\n声明虚函数后, 派生类对象的地址可以赋值给基类指针, 基类指针可以指向派生类对象\n调用基类指针时, 指针指向基类对象则执行基类的虚函数, 指向派生类对象则执行派生类的虚函数\n通过基类指针实现多态示例(6-1)\n用基类指针访问基类对象及派生类对象\n通过基类引用实现多态\n引用等同于指针\n基类引用实现多态(6-3)\n多态的实现原理\n多态的关键在于通过指针/引用调用一个虚函数时, 编译阶段不能确定到底调用的是基类还是派生类的函数, 运行时才能确定\n多态机制下对象储存空间的大小(6-4)\n类A中每个对象都保存自己的虚函数表的地址, 这是实现多态的关键\n每个虚函数的类都有一个虚函数表, 编译器生成, 程序运行时载入 第二节 多态实例 使用多态处理图形示例\n第三节 多态的使用 在成员函数中调用虚函数(6-6)\n在构造函数和析构函数中调用虚函数(6-7)\n多态与非多态的对比(6-8)\n第四节 虚析构函数 只调用基类的析构函数, 只会完成该析构函数内的空间释放, 不会涉及派生类析构函数内的空间, 造成内存泄漏\n虚析构函数\nvirtual ~类名(); 没有返回值类型, 没有参数 如果一个类的析构函数是虚函数, 则它的派生函数的析构函数都是虚函数\n不使用虚析构函数的情况(6-9)\n构造函数不能是虚函数 第五节 纯虚函数和抽象类 纯虚函数\n基类中某个虚函数不用给出确切的定义, 可以将它声明为纯虚函数 相当于一个统一的接口形式 基类中声明 只有函数名, 不具备函数功能, 不能在基类中调用 格式 virtual 函数类型 函数名(参数表)=0; 参数表要写 =0 表示函数体, 派生类中必须重写这个函数 抽象类\n包含纯虚函数的类称为抽象类\n抽象类中有未完成的函数定义, 不能实例化对象 抽象类的派生类中, 如果没有给出全部纯虚函数的定义, 派生类继续是抽象类, 直到派生类中给出纯虚函数定义后, 才不是抽象类 可以定义抽象类的指针和引用, 指针访问派生类的成员, 具有多态性 抽象类实例(6-10)\n虚基类\n为了避免二义性, C++ 提供虚基类机制, 派生类中继承同一个间接基类的成员仅保留一个版本\n定义虚基类的格式\n1 2 3 4 class 派生类名 : virtual 派生方式 基类名 { 派生类体 }; 虚基类(6-11)\n第七章 输入/输出流 cin cout 重定向 格式控制 常见成员函数 第一节 流类简介 C++ 没有输入输出语句\nC++ 标准库中面向对象的 I/O 流类库，输入输出均通过流完成。流是 I/O 流类的核心概念。 数据传输称为流\n读操作称为提取 写操作称为插入 输入输出的相关类称为流类 常用 I/O 流类列表\n类名 关键字 说明 包含文件 抽象流基类 ios 流基类 ios 输入流类 istream 通用输入流基类和其它输入流基类，cin 是该类对象 istream 输入流类 ifstream 文件输入流类，用于从文件读取数据 ifstream 输出流类 ostream 通用输出流基类和其它输出流基类，cout 是该类对象 ostream 输出流类 ofstream 文件输出流类，用于向其他文件写数据 fstream 输入输出流类 iostream 通用输入输出流基类和其它输入输出流类基类 iostream 输入输出流类 fstream 文件输入输出流类，读取和写入文件 fstream 第二节 标准流对象 标准流对象（也称为标准流），为用户提供外设与内存之间的通信通道，对数据进行解释和传输，和必要的数据缓冲等\n四个标准流对象\ncin ：标准输入流 关联输入设备（键盘），可以重定向为从文件读取数据 cout：标准输出流 关联输出设备（显示器），可以重定向为向文件写入数据 cerr：非缓冲错误输出流 关联标准错误信息输出设备（显示器），非缓冲，不能重定向 clog：缓冲错误输出流 关联标准错误信息输出设备（显示器），缓冲，不能重定向 重定向函数 freopen 的原型如下\nFILE *freopen(const char *path, const char *mode, FILE *stream); freopen() 将 stream 按 mode 指定的模式重定向到路径 path 指向的文件，如果错误则关闭 stream 返回 NULL 将标准输出 cout 重定向到文件(7-1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x, y; cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; freopen(\u0026#34;test.txt\u0026#34;, \u0026#34;w\u0026#34;, stdout); if (y == 0) cerr \u0026lt;\u0026lt; \u0026#34;error.\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; x / y \u0026lt;\u0026lt; endl; return 0; } 标准输入重定向为文件(7-2)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x, count, sum = 0; freopen(\u0026#34;input.dat\u0026#34;, \u0026#34;r\u0026#34;, stdin); //标准输入定向到文件 for (count = 0; count \u0026lt; 10; count++) { cin \u0026gt;\u0026gt; x; sum += x; } cout \u0026lt;\u0026lt; \u0026#34;前\u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;个整数的平均值 = \u0026#34; \u0026lt;\u0026lt; 1.0 * sum / count \u0026lt;\u0026lt; endl; return 0; } ios 中错误状态字 标识常量 值 含义 goodbit 0X00 流状态正常 eofbit 0X01 文件结束符 failbit 0X02 I/O 操作失败,数据未丢失,可恢复 badbit 0X04 非法操作,数据丢失,不可恢复 ios 中流相关的成员函数, 可直接使用 返回流是否结束\nint eof() const; 是否遇到文件尾, 是则返回1, 否则返回0 Ctrl+Z 表示输入流结束 返回流是否处于正常状态\nint fail() const; 判断流是否正常\n1 2 3 4 5 int good() const; int operator void *(); ``` - `eofbit failbit badbit` 是否为0，否则返回1 返回流是否处于失败状态\n1 2 int bad() const; int operator void !(); eofbit failbit badbit 是否为1，否则返回0 返回状态字\nint rdstate() const; 恢复状态字\nvoid clear(int nStata = 0 ); 标准输入重定向为文件并判断文件状态(7-3)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int x, count, sum = 0; freopen(\u0026#34;input.dat\u0026#34;, \u0026#34;r\u0026#34;, stdin); //标准输入定向到文件 for (count = 0; count \u0026lt; 10; count++) { cin \u0026gt;\u0026gt; x; if (cin.eof()) { cout \u0026lt;\u0026lt; cin.eof() \u0026lt;\u0026lt; \u0026#34;结束\u0026#34; \u0026lt;\u0026lt; endl; break; } else { cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl; sum += x; } } // 遇到输出中文失败，程序不输出结果，代码编码问题，GB2312改为 UTF-8即可。 cout \u0026lt;\u0026lt; \u0026#34;前\u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026#34;个整数的平均值 = \u0026#34; \u0026lt;\u0026lt; 1.0 * sum / count \u0026lt;\u0026lt; endl; return 0; } 将键盘输入的数据累加(7-4)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { char ch; int x, count = 0, sum = 0; cout \u0026lt;\u0026lt; \u0026#34;请输入整数 Ctrl+Z 退出\u0026#34; \u0026lt;\u0026lt; endl; do { while (cin \u0026gt;\u0026gt; x) { sum += x; count++; } cout \u0026lt;\u0026lt; \u0026#34;确认退出请输入 Q\u0026#34;; cin.clear(); cin \u0026gt;\u0026gt; ch; } while (toupper(ch) != \u0026#39;Q\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;sum=\u0026#34; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; \u0026#34;,count=\u0026#34; \u0026lt;\u0026lt; count \u0026lt;\u0026lt; endl; return 0; } 第三节 控制 IO 格式 流操纵符\nC++ 中常见数据类型的默认 I/O 格式\nI/O 的数据类型 默认的输入格式 默认的输出格式 short/int/long(signed / unsigned) 与整数型常数相同 一般整数形式，复数前面有负号 float/double/long/double 与浮点数相同 浮点或指数格式，取决于哪个更短 char *(signed/unsigned) 从第一个空白字符（空格、\\t、\\n)开始到下个空白字符 字符序列（无引号） char *(signed/unsigned) 第一个非空白字符 字符序列（无引号） void* 无前缀的十六进制数 无前缀的十六进制数 Bool 将true或 1 识别为true，或反过来 1或0 iostream 中常用流操纵符\n流操纵符 作用 输入/输出 endl 输出一个新行符，并清空流 O ends 输出字符串结束，并清空流 O flush 清空流缓冲区 O dec* 以十进制形式输入输出整数 I/O hex 以十六进制形式输入输出整数 I/O oct 以八进制形式输入输出整数 I/O ws 提取空白字符 O * 表示默认设置，不属于操纵符的一部分 常用的用于格式控制的流操纵符\n流操纵符 作用 fixed 普通小数形式输出浮点数 scientific 科学计数法形式输出浮点数 left 左对齐，宽度不足时填充字符到右边 right * 右对齐，宽度不足时填充字符到左边 setbase(int b) 设置输出整数时的进制，b为8、10、16 setw(int w) 指定输出宽度为 w 个字符，或输入字符串时读入w个字符。一次有效 setfill(int c) 指定输出宽度，宽度不足时用ASCII码为c的字符填充（默认空格） setpercision(int n) 设置浮点数精度 n, 默认 n 为有效数字位数，fixed/scientific后n是小数点后保留位数 setiosflags(fmtfalgs f) 通用操作符。将格式标志f对应的格式标志位置为1 resetiosflags(fmtfalgs f) 通用操作符。将格式标志f对应的格式标志位置为0（清除） boolapha 把true 和 false 输出为字符串 noboolalpha * 把true 和 false 输出为1和0 showbase 输出表示数值进制的前缀 noshowbase * 不输出表示数值进制的前缀 showpoint 总是输出小数点 noshowpoint * 只有当小数部分存在时输出小数点 showpos 非负数值中显示+ noshowpos * 非负数值中不显示+ skipws * 输入时跳过空白字符 noskipws 输入时不跳过空白字符 uppercase 十六进制数中使用 A-E。若输出前缀，为0X，科学计数法输出 E no uppercase* 十六进制数中使用 a-e。若输出前缀，为0x，科学计数法输出 e internal 数值的符号（正负号）指定宽度内左对齐，数值右对齐，中间填充字符 使用流操纵符控制整数输出(7-5)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { int n = 65535, m = 20; //分别输出一个整数的十进制 十六进制 八进制 cout \u0026lt;\u0026lt; \u0026#34;十进制：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; oct \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; //使用 setbase 分别输出一个整数的十进制、十六进制和八进制 cout \u0026lt;\u0026lt; \u0026#34;\u0026#34; \u0026lt;\u0026lt; setbase(10) \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; setbase(16) \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; setbase(8) \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; //使用 showbase 和 setbase 分别输出一个整数 十进制、十六进制、八进制 cout \u0026lt;\u0026lt; showbase; cout \u0026lt;\u0026lt; setbase(10) \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; setbase(16) \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34;=\u0026#34; \u0026lt;\u0026lt; setbase(8) \u0026lt;\u0026lt; m \u0026lt;\u0026lt; endl; return 0; } 使用流操纵符控制浮点数输出(7-6)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double x = 1234567.89, y = 1.23456789; //无格式控制 cout \u0026lt;\u0026lt; \u0026#34;无格式控制：\\t\\t x=(\u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;),y=(\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; //保留5位有效数字 cout \u0026lt;\u0026lt; \u0026#34;保留5位有效数字：\\t\\t x=(\u0026#34; \u0026lt;\u0026lt; setprecision(5) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;),y=(\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; //保留小数点后5位 cout \u0026lt;\u0026lt; \u0026#34;保留小数点后5位：\\t\\t x=(\u0026#34; \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setprecision(5) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;),y=(\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; //科学计数法，保留小数点后5位 cout \u0026lt;\u0026lt; \u0026#34;科学计数法，保留小数点后5位：\\t\\t x=(\u0026#34; \u0026lt;\u0026lt; scientific \u0026lt;\u0026lt; setprecision(5) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;),y=(\u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; \u0026#34;)\\n\u0026#34;; //非负数显示正号，输出宽度为12字符，宽度不足时用‘*’填补 cout \u0026lt;\u0026lt; \u0026#34;非负数显示正号：\\t\\t \u0026#34; \u0026lt;\u0026lt; showpos \u0026lt;\u0026lt; fixed \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; //非负数不显示正号，输出宽度为12字符，宽度不足时右边用填充字符填充 cout \u0026lt;\u0026lt; \u0026#34;不显示正号，右边用填充字符填充：\\t\\t \u0026#34; \u0026lt;\u0026lt; noshowpos \u0026lt;\u0026lt; left \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; //输出宽度为12字符，宽度不足时左边用填充字符填充 cout \u0026lt;\u0026lt; \u0026#34;左边用填充字符填充：\\t\\t \u0026#34; \u0026lt;\u0026lt; showpos \u0026lt;\u0026lt; right \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; y \u0026lt;\u0026lt; endl; //宽度不足时，负号和数值分列左右，中间用填充字符填充 cout \u0026lt;\u0026lt; \u0026#34;中间用填充字符填充：\\t\\t \u0026#34; \u0026lt;\u0026lt; showpos \u0026lt;\u0026lt; internal \u0026lt;\u0026lt; setw(12) \u0026lt;\u0026lt; -y \u0026lt;\u0026lt; endl; } 通过 setw() 控制输入格式(7-7)\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { string s1, s2; cin \u0026gt;\u0026gt; setw(5) \u0026gt;\u0026gt; s1 \u0026gt;\u0026gt; setw(3) \u0026gt;\u0026gt; s2; cout \u0026lt;\u0026lt; \u0026#34;s1=\u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34;,s2=\u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; endl; return 0; } 标志字\n常见格式标志常量及含义\n标志常量名 值 含义 输入/输出 ios::skipws 0X0001 跳过输入中的空白 I ios::left 0X0002 按输出左对齐，填充字符右边 O ios::right 0X0004 按输出右对齐，填充字符左边 O ios::internal 0X0008 在符号位或基数指示符后填入字符 O ios::dec * 0X0010 转换为十进制基数形式 I/O ios::oct 0X0020 转换为八进制基数形式 I/O ios::hex 0X0040 转换为十六进制基数形式 I/O ios::showbase 0X0080 在输出中显示基数指示符 O ios::showpoint 0X0100 在输出浮点数时必须带小数点和尾部的 0 O ios::uppercase 0X0200 以大写字母表示十六进制数，科学计数法使用大写字母 E O ios::showpos 0X0400 正数前加 + 号 O ios::scentific 0X0800 科学计数法显示浮点数 O ios::fixed 0X1000 定点法表示浮点数 O ios::unitbuf 0X2000 插入操作后立即刷新流 O 标志常量实际是在一个整数中仅将某一个二进制位设为 1，其它清零。 设置多个标志，用位或 | 运算符连接 流格式标志每一位表示一种格式，会有相互制约；矛盾时清除原来的标志 清除同类互斥位\nios::basefield 值为 dec | oct | hex\nios::adjustifield 值为 left | right | internal\nios::floatfield 值为 scientific | fixed\n1 cout setf(ios::oct,ios::basefield);//示例，标准流为八进制基数形式插入 通过 setiosflags() 设置标志字进行格式控制(7-8)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double x = 12.34; cout \u0026lt;\u0026lt; \u0026#34;1)\u0026#34; \u0026lt;\u0026lt; setiosflags(ios::scientific | ios::showpos) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;2)\u0026#34; \u0026lt;\u0026lt; resetiosflags(ios::scientific | ios::showpos) \u0026lt;\u0026lt; setiosflags(ios::showbase) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;3)\u0026#34; \u0026lt;\u0026lt; resetiosflags(ios::fixed) \u0026lt;\u0026lt; setiosflags(ios::scientific | ios::showpos) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;4)\u0026#34; \u0026lt;\u0026lt; resetiosflags(ios::showpos) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;5)\u0026#34; \u0026lt;\u0026lt; resetiosflags(ios::scientific) \u0026lt;\u0026lt; setiosflags(ios::fixed) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; endl; return 0; } 第四节 调用 cout 的成员函数 常见用于控制格式的成员函数原型如下\n设置和返回标志字 long flag(long 1Flags); 使用参数 1Flags 设置（替换）标志字，返回设置前标志字 long flag() const; 返回当前标志字 设置标志位 long setf(long 1Flags); 使用参数 1Flags 置位标志字，返回置位前标志字 long setf(long 1Flags, long 1Mask); 1Mask 指定标志位清零，设置 1Flags 标志位，返回更新前标志字 清除标志位 long unsetf(long 1Flags); 清除参数 1Flags 指定的标志位，返回清除前的标志字 标志位与 setiosflags() 用到的参数相同 设置和返回输出宽度 int width(int nw); 将下一个输出项的显示宽度设置为 nw。如果nw 大于数据所需宽度，则右对齐。如果nw 小于数据所需宽度，则 nw 无效。一次性有效。 int width() const; 返回值为当前的输出宽度值 设置填充字符 char fill(char cFill); 设置宽度大于数据所需宽度时，参数 cFill 填充空白。 char fill() const; 返回当前使用的填充符 设置数据显示精度 int percision(int np); 用参数np 设置数据显示精度。浮点数 np 表示小数点后的数字位数。科学计数法np 表示尾数精度位数（包括小数点）。 int precision() const; 返回当前数据显示精度。 ostream 类的成员函数及作用相同的流操作符\n成员函数 作用相同的流操作符 precision(int p) setprecision(np) width(int nw) setw(nw) fill(char cFill) setfill(cFill) setf(long IFlags) setiosflags(IFlags) unsetf(long IFlags) resetioslags(IFlags) 使用 cout 中的函数控制输出格式(7-9)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { double values[] = {1.23, 20.3456, 300.4567, 4000.56789, 50000.1234567}; cout.fill(\u0026#39;*\u0026#39;); //填充* for (int i = 0; i \u0026lt; sizeof(values) / sizeof(double); i++) { cout \u0026lt;\u0026lt; \u0026#34;values[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;]=(\u0026#34;; cout.width(10); //设置宽度 cout \u0026lt;\u0026lt; values[i] \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } cout.fill(\u0026#39; \u0026#39;); //填充空格 for (int i = 0; i \u0026lt; sizeof(values) / sizeof(double); i++) { cout \u0026lt;\u0026lt; \u0026#34;values[\u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;]=(\u0026#34;; cout.width(10); //设置宽度 cout.precision(i + 3); //设置保留有效数字 cout \u0026lt;\u0026lt; values[i] \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } return 0; } 使用 cout() 函数(7-10)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { char c = \u0026#39;a\u0026#39;, str[80] = \u0026#34;1234567890abcdefghijklmn\u0026#34;; int x = 65; cout \u0026lt;\u0026lt; \u0026#34;cout.put(\u0026#39;a\u0026#39;):\u0026#34;; cout.put(\u0026#39;a\u0026#39;); cout \u0026lt;\u0026lt; \u0026#34;\\ncout.put(c+25):\u0026#34;; cout.put(c + 25); //字母转换成整数再相加 cout \u0026lt;\u0026lt; \u0026#34;\\ncout.put(x):\u0026#34;; cout.put(x); cout \u0026lt;\u0026lt; \u0026#34;\\ncout.put(str,20):\u0026#34;; cout.write(str, 20); //将str的前20个字节输入到流中 return 0; } 第五节 调用 cin 的成员函数 get() 函数，只介绍常用的\nint get()\n从输入流中读入一个字符（包括空白），返回值就是该字符的ASII 码。如果碰到输入结束符，则返回值为系统常量 EOF（End Of File，文件结束标记）。\n采用 EOF 判断输入是否结束(7-11)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { int n = 0; char ch; while (ch = cin.get() != EOF) //遇到结束符才推出 { cout.put(ch); n++; } cout \u0026lt;\u0026lt; \u0026#34;输入字符统计：\u0026#34; \u0026lt;\u0026lt; n \u0026lt;\u0026lt; endl; return 0; } Ctrl + Z 和 Enter 键代表文件结束 getline() 函数\nistream \u0026amp; getline(char * buf, int bufSize);\n从输入流中的当前字符开始读取 bufSize-1 个字符到缓冲区 buf ，或读到 \\n 为止。函数会在 buf 中读入数据的结尾自动添加串结束标记 \\0。 istream \u0026amp; getline(char * buf, int bufSize, char delim);\n从输入流中的当前字符开始读取 bufSize-1 个字符到缓冲区 buf ，或读到字符 delim 为止。函数会在 buf 中读入数据的结尾自动添加串结束标记 \\0。 getline() 函数功能演示(7-12)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { char buf[10]; int i = 0; while (cin.getline(buf, 10)) //输入超过九个就会出错 { cout \u0026lt;\u0026lt; ++i \u0026lt;\u0026lt; \u0026#34;:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;last:\u0026#34; \u0026lt;\u0026lt; buf \u0026lt;\u0026lt; endl; } return 0; } eof() 函数\nbool eof();\n用于判断输入流是否已经结束，返回 ture 表示结束 ignore() 函数\nistream \u0026amp; ignore(int n=1, int delim = EOF);\n跳过输入流中的 n 个字符，或跳过 delim 之前的所有字符。默认跳过一个字符 从输入的字符串中提取电话号码(7-13)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; int main() { char str[30]; while (!+cin.eof()) //当输入流没有结束时继续循环 { cin.ignore(10, \u0026#39;:\u0026#39;); //在cin流中跳过\u0026#39;:\u0026#39;之前的全部字符 if (!cin.eof()) //输入流没有结束 { cin \u0026gt;\u0026gt; str; //输入电话号码 cout \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } } return 0; } peek() 函数\nint peek();\n返回输入流中的当前字符，只读不操作 日期格式转换(7-14)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; using namespace std; string Months[13] = {\u0026#34;\u0026#34;, \u0026#34;Jan\u0026#34;, \u0026#34;Feb\u0026#34;, \u0026#34;Mar\u0026#34;, \u0026#34;Apr\u0026#34;, \u0026#34;May\u0026#34;, \u0026#34;Jun\u0026#34;, \u0026#34;Jul\u0026#34;, \u0026#34;Aug\u0026#34;, \u0026#34;Sep\u0026#34;, \u0026#34;Oct\u0026#34;, \u0026#34;Nov\u0026#34;, \u0026#34;Dec\u0026#34;}; //西文格式的月份 int main() { char ch; int year, month, day; while ((ch = cin.peek()) != EOF) //取输入流的第一个字符查看 { if (ch \u0026gt; +\u0026#39;A\u0026#39; \u0026amp;\u0026amp; ch \u0026lt; \u0026#39;Z\u0026#39;) //处理西文格式 { string sMonth; cin \u0026gt;\u0026gt; sMonth \u0026gt;\u0026gt; day \u0026gt;\u0026gt; year; //接收：月、日、年 // 查找月份完成转换 for (month = 0; month \u0026lt; 12 \u0026amp;\u0026amp; sMonth != Months[month]; ++month) ; } else { cin \u0026gt;\u0026gt; year; cin.ignore() \u0026gt;\u0026gt; month; cin.ignore() \u0026gt;\u0026gt; day; // 以上三条语句等价于 cin\u0026gt;\u0026gt;year\u0026gt;\u0026gt;ch\u0026gt;\u0026gt;month\u0026gt;\u0026gt;ch\u0026gt;\u0026gt;day; } cin.ignore(); cout \u0026lt;\u0026lt; setfill(\u0026#39;0\u0026#39;) \u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; month; cout \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; setw(2) \u0026lt;\u0026lt; day \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; setw(4) \u0026lt;\u0026lt; year \u0026lt;\u0026lt; endl; } return 0; } 第八章 文件操作 文件 ifstream、ofstream、fstream 顺序访问和随机访问，文件读写指针和移动文件指针 第一节 文件基本概念和文件流类 文件的概念\n编码方式 文本文件 二进制文件 存储方式 顺序存储文件 随机存储文件 基本操作 读文件（输入） 写文件（输出） 本质都是二进制文件 C++ 文件流类\n文件是物理概念，流是逻辑概念 标准库内三个流类可用于文件操作，统称为文件流类 ifstream：用于文件中读取数据 ofstream：用于向文件中写入数据 fstream：既可用于读取，也可写入 第二节 打开和关闭文件 打开文件\n打开方式\n建立流对象，调用 open() 函数连接外部文件\n1 2 流类名 对象名; 对象名.open(文件名, 模式); 调用流类带参数的构造函数，在建立流对象的同时连接外部文件\n流类名 对象名(文件名, 模式) 流类：文件流类\n文件名：外部文件名\n模式：类 ios 定义的打开模式的标记常量，表示打开方式\n文件打开模式标记\n模式标记 适用对象 作用 ios::in ifstream; fstream 读方式打开文件，如果不存在则报错 ios::out ofstream; fstream 写方式打开，不存在则新建；已存在则清空原内容 ios::app ofstream 追加方式打开，不存在则新建 ios::ate ofstream 打开已有文件，将指针指向文件末尾；不存在则报错 ios::trunc ofstream 删除文件现有内容，单独使用时同 ios::out ios::binary ifstream;ofstream; fstream 以二级制打开文件；不指定则默认文本方式打开 `ios::in ios::out` fstream `ios::in ios::out` ofstream `ios::in ios::out ios::trunc` 打开文件示例\n读取当前文件夹中 data.txt 的文件\n1 2 istream inFile; inFile.open(\u0026#34;data.txt\u0026#34;,ios::in); //ios::in 是默认参数可省略 或者\n1 ifstream inFile(\u0026#34;data.txt\u0026#34;,ios::in); 2019文件夹中创建文件 newfile 的二进制文件\n1 2 ifstream outFile; outFile.open(\u0026#34;c:\\\\2019\\\\newfile\u0026#34;,ios::out|ios::binary); 或者\n1 ifstream outFile(\u0026#34;c:\\\\2019\\\\newfile\u0026#34;,ios::out|ios::binary); 关闭文件\n发出关闭文件指令后，系统会将缓冲区中的数据完整地写入文件，同时添加文件结束标记，切断流对象与外部文件的连接\n格式示例\n1 2 3 4 5 6 ifstream inFile; inFile.open(\u0026#34;file.txt\u0026#34;,ios::in); // 打开成功则进行读文件，省略 inFile.close();//关闭文件 //inFile 与 file.txt 断开连接，可用于其他文件 inFile.open(\u0026#34;file.data\u0026#34;,ios::in);//连接另一个文件 建立流对象，调用 open() 函数连接外部文件(8-1)\n调用流类带参数的构造函数打开文件(8-2)\n第三节 文件读写操作 读写文本文件\nC++ 将文件看成顺序排列的无结构的字节流。\n对于长度 n 的文件来说，字节号从 0 ~ n-1 ，最后一位是文件结束标识符EOF 0x1A 对文本文件 score.txt 进行输入/输出(8-3)\n读入学生成绩文件 score.txt 并显示内容(8-4)\n读入文本文件，加上行号后显示内容(8-5)\n对文本文件的内容进行排序，将结果输出到另一个文件(8-6)\n读写二进制文件\n用 ostream::write() 成员函数写文件\nostream \u0026amp; write(char *buffer, int nCount);\n用二进制保存学生信息(8-7)\n向二进制文件中追加数据(8-8)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; class CStudent { public: char szName[20]; int age; }; int main() { CStudent s; ofstream outFile(\u0026#34;students.dat\u0026#34;, ios::out | ios::binary); while (cin \u0026gt;\u0026gt; s.szName \u0026gt;\u0026gt; s.age) outFile.write((char*)\u0026amp;s, sizeof(s)); outFile.close(); return 0; } Tom 60↙ Jack 80↙ Jane 40↙ ^Z↙ 用 istream::read() 成员函数读文件\nistream \u0026amp;read(char * buffer, int nCount); 从文件读取 nCount 个字节的内容，存放到 buffer 指向的内存缓冲区，返回作用对象的引用 非格式化操作，读取内容不处理，直接存入缓冲，由程序的类型定义解释 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;iostream\u0026gt; #include \u0026lt;fstream\u0026gt; using namespace std; class CStudent { public: char szName[20]; int age; }; int main() { CStudent s; ifstream inFile(\u0026#34;students.dat\u0026#34;,ios::in|ios::binary); //二进制读方式打开 if(!inFile) { cout \u0026lt;\u0026lt; \u0026#34;error\u0026#34; \u0026lt;\u0026lt;endl; return 0; } while(inFile.read((char *)\u0026amp;s, sizeof(s))) { //一直读到文件结束 cout \u0026lt;\u0026lt; s.szName \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; s.age \u0026lt;\u0026lt; endl; } inFile.close(); return 0; } Tom 60 Jack 80 Jane 40 用 ostream::gcount() 成员函数得到读取字节数\nint gcount();\n从二进制文件中读取数据(8-9)\n用成员函数 put() 和 get() 读写文件\nget() 的三种主要形式\nint get();\n不带参数，从指定输入流中提取一个字符（包含空白），返回该字符。遇到文件尾则返回文件尾 istream \u0026amp; get(char \u0026amp;rch);\n从指定输入流中提取一个字符（包含空白），将该字符作为 rch 引用的对象。遇到文件尾返回0；否则返回对 istream 对象的引用 istream \u0026amp; get(char *pch, int nCount, char delim='\\n');\n从流的当前字符开始，读取 nCount-1 个字符，或遇到指定分隔符 delim 结束。 把读取的字符（不包含分隔符）写入数组 pch ，并增加结束符 ‘\\0’ put() 函数\nostream\u0026amp; put(char ch); 向输出流中插入一个字节 文件复制(8-10)\n文本文件与二进制文件的异同\nWindows 中，以文本方式打开文件，系统会对文本文件中字符 \\r\\n（俗称回车换行）进行专门处理 读文件，\\r\\n 转化成 \\n ； 写文件， \\n 转化成 \\r\\n 再写入 第四节 随机访问文件 顺序文件，只能顺序存取\n键盘、显示器 随机文件，任意存取\n磁盘 流指针，文件操作的位置指针\nistream 中与位置指针相关的函数\n移动读指针函数 返回读指针当前位置值的函数 ostream 中与位置指针相关的函数\n移动指针函数 返回写指针当前位置值的函数 修改程序 8-7 ，观察文件读操作中位置指针的变化(8-11)\n读取程序 8-7 中 student.dat ，在文件中查找最高分和最低分并显示学生信息。若同时获得最高分只显示第一个\n第九章 函数模板与类模板 函数模板 类模板 模板与继承 第一节 函数模板 函数模板概念\n使用虚拟的类型参数。\n实际的类型来实例化函数时，将函数模板与某个具体的数据类型连用。编译器将以此产生模板函数。 这个过程叫函数模板实例化。 定义函数模板格式\n1 2 3 4 5 template \u0026lt;模板参数列表\u0026gt; 返回值类型名 函数模板名(参数表) { 函数具体定义 } 类型 参数名可以是\nclass 标识符 类型说明符 标识符 函数模板示例\n定义求绝对值的函数模板,并进行不同的调用(9-1)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; //T 是占位符 T abs(T x) //调用函数时自动判断类型 int abs(int n); { return x \u0026lt; 0 ? -x : x; } int main() { int n = -5; int m = 10; double d = -5; float f = 3.2; cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34;的绝对值：\u0026#34; \u0026lt;\u0026lt; abs(n) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; m \u0026lt;\u0026lt; \u0026#34;的绝对值：\u0026#34; \u0026lt;\u0026lt; abs(m) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; d \u0026lt;\u0026lt; \u0026#34;的绝对值：\u0026#34; \u0026lt;\u0026lt; abs(d) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; f \u0026lt;\u0026lt; \u0026#34;的绝对值：\u0026#34; \u0026lt;\u0026lt; abs(f) \u0026lt;\u0026lt; endl; return 0; } 定义对象交换的函数模板(9-2)\n对象排序程序(9-3)\n函数或函数模板调用语句的匹配顺序\n函数模板可以重载，只要形参不同\n重载函数模板(9-4)\n函数与函数模板名相同，一条函数调用语句该匹配哪个函数或模板？\n先找参数完全匹配的普通函数（不是由模板实例化得到的模板函数） 再找参数完全匹配的模板函数 找实参经过自动类型转换后能够匹配的普通函数 报错 函数调用匹配顺序(9-5)\n第二节 类模板 类模板概念\n编译器通过类模板可以自动生成多个面向不同数据类型的类\n泛型数据替代实际的数据类型来说明变量，从而定义一个泛型类。\n声明类模板\n1 2 3 4 5 template \u0026lt;模板参数表\u0026gt; class 类模板名 { 类体定义 } 类模板以外定义函数成员\n1 2 3 4 5 template \u0026lt;模板参数表\u0026gt; 返回类型名 类模板名 \u0026lt;模板参数标识符列表\u0026gt;::成员函数名(参数表) { 类体定义 } 使用类模板创建对象, 给出 类型形参/普通形参/实参\n类模板名 \u0026lt;模板参数表\u0026gt; 对象名1, ... ,对象名n; 类模板名 \u0026lt;模板参数表\u0026gt; 对象名1(构造函数实参), ... ,对象名n(构造函数实参)； 由类模板实例化的类叫模板类 类模板示例\n二元数组类模板(9-6)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include \u0026lt;iostream\u0026gt; using namespace std; template \u0026lt;class T1, class T2\u0026gt; class Pair { public: T1 first; T2 second; Pair(T1 k, T2 v) : first(k), second(v) {} bool operator\u0026lt;(const Pair\u0026lt;T1, T2\u0026gt; \u0026amp;p) const; }; template \u0026lt;class T1, class T2\u0026gt; bool Pair\u0026lt;T1, T2\u0026gt;::operator\u0026lt;(const Pair\u0026lt;T1, T2\u0026gt; \u0026amp;p) const { return first \u0026lt; p.first; } int main() { Pair\u0026lt;string, int\u0026gt; student1(\u0026#34;Tom\u0026#34;, 19); // Pair\u0026lt;string, int\u0026gt; student2(\u0026#34;Jim\u0026#34;, 21); // Pair\u0026lt;string, string\u0026gt; dic(\u0026#34;word\u0026#34;, \u0026#34;danci\u0026#34;); Pair\u0026lt;int, int\u0026gt; coordinate(10, 20); cout \u0026lt;\u0026lt; \u0026#34;学生：\u0026#34; \u0026lt;\u0026lt; student1.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; student1.second \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;学生：\u0026#34; \u0026lt;\u0026lt; student2.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; student2.second \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;坐标：\u0026#34; \u0026lt;\u0026lt; coordinate.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; coordinate.second \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;学生：\u0026#34; \u0026lt;\u0026lt; dic.first \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; dic.second \u0026lt;\u0026lt; endl; bool a = student1 \u0026lt; student2; if (a == 0) cout \u0026lt;\u0026lt; student1.first \u0026lt;\u0026lt; \u0026#34;位于\u0026#34; \u0026lt;\u0026lt; student2.first \u0026lt;\u0026lt; \u0026#34;之后\u0026#34; \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; student1.first \u0026lt;\u0026lt; \u0026#34;位于\u0026#34; \u0026lt;\u0026lt; student2.first \u0026lt;\u0026lt; \u0026#34;之前\u0026#34; \u0026lt;\u0026lt; endl; return 0; } 类模板(9-7)\n在类模板中使用模板函数\n类模板中使用静态成员\n使用普通函数的类模板\n类模板与继承\n类模板和类模板之间、类模板和类之间可以相互继承，派生关系的四种情况\n普通类继承模板类\n类模板继承普通类\n类模板继承类模板\n类模板继承模板类\n根据类模板实例化的类即是模板类。\n附录 VScode 配置文件 编译环境 TDM-GCC c_cpp_properties.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Win32\u0026#34;, \u0026#34;includePath\u0026#34;: [ \u0026#34;${workspaceFolder}/**\u0026#34; ], \u0026#34;defines\u0026#34;: [ \u0026#34;_DEBUG\u0026#34;, \u0026#34;UNICODE\u0026#34;, \u0026#34;_UNICODE\u0026#34; ], \u0026#34;intelliSenseMode\u0026#34;: \u0026#34;msvc-x64\u0026#34; } ], \u0026#34;version\u0026#34;: 4 } launch.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;(gdb) Launch\u0026#34;, // 配置名称，将会在启动配置的下拉菜单中显示 \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, // 配置类型，这里只能为cppdbg \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, // 请求配置类型，可以为launch（启动）或attach（附加） \u0026#34;program\u0026#34;: \u0026#34;${workspaceRoot}/${fileBasenameNoExtension}.exe\u0026#34;, // 将要进行调试的程序的路径 \u0026#34;args\u0026#34;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可 \u0026#34;stopAtEntry\u0026#34;: false, // 设为true时程序将暂停在程序入口处，一般设置为false \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceRoot}\u0026#34;, // 调试程序时的工作目录，一般为${workspaceRoot}即代码所在目录 \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, // 调试时是否显示控制台窗口，一般设置为true显示控制台 \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;C:\\\\TDM-GCC-64\\\\bin\\\\gdb64.exe\u0026#34;, // miDebugger的路径，注意这里要与MinGw的路径对应 \u0026#34;preLaunchTask\u0026#34;: \u0026#34;g++\u0026#34;, // 调试会话开始前执行的任务，一般为编译程序，c++为g++, c为gcc \u0026#34;setupCommands\u0026#34;: [{ \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true }] } ] } tasks.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [{ \u0026#34;label\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;g++\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;-g\u0026#34;, \u0026#34;${file}\u0026#34;, \u0026#34;-o\u0026#34;, \u0026#34;${fileDirname}/${fileBasenameNoExtension}.exe\u0026#34; ], \u0026#34;problemMatcher\u0026#34;: { \u0026#34;owner\u0026#34;: \u0026#34;cpp\u0026#34;, \u0026#34;fileLocation\u0026#34;: [ \u0026#34;relative\u0026#34;, \u0026#34;${workspaceRoot}\u0026#34; ], \u0026#34;pattern\u0026#34;: { \u0026#34;regexp\u0026#34;: \u0026#34;^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\u0026#34;, \u0026#34;file\u0026#34;: 1, \u0026#34;line\u0026#34;: 2, \u0026#34;column\u0026#34;: 3, \u0026#34;severity\u0026#34;: 4, \u0026#34;message\u0026#34;: 5 } }, \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true } }] } 附录 基本数据类型 基本的内置类型 C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：\n类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 到 18,446,744,073,709,551,615 float 4 个字节 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) double 8 个字节 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) long double 16 个字节 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 wchar_t 2 或 4 个字节 1 个宽字符 type: size** bool: 所占字节数：1 最大值：1 最小值：0 char: 所占字节数：1 最大值： 最小值： signed char: 所占字节数：1 最大值： 最小值： unsigned char: 所占字节数：1 最大值： 最小值： wchar_t: 所占字节数：2 最大值：65535 最小值：0 short: 所占字节数：2 最大值：32767 最小值：-32768 int: 所占字节数：4 最大值：2147483647 最小值：-2147483648 unsigned: 所占字节数：4 最大值：4294967295 最小值：0 long: 所占字节数：4 最大值：2147483647 最小值：-2147483648 unsigned long: 所占字节数：4 最大值：4294967295 最小值：0 double: 所占字节数：8 最大值：1.79769e+308 最小值：2.22507e-308 long double: 所占字节数：16 最大值：1.18973e+4932 最小值：3.3621e-4932 float: 所占字节数：4 最大值：3.40282e+38 最小值：1.17549e-38 size_t: 所占字节数：8 最大值：18446744073709551615 最小值：0 string: 所占字节数：32 type: size**\ntypedef 声明 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法：\n1 typedef type newname; 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称：\n1 typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance：\n1 feet distance; 枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。\n如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\u0026quot;枚举\u0026quot;是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。\n创建枚举，需要使用关键字 enum。枚举类型的一般形式为：\n1 2 3 4 5 6 7 enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; 如果枚举没有初始化, 即省掉\u0026rdquo;=整型常数\u0026quot;时, 则从第一个标识符开始。\n例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 \u0026ldquo;blue\u0026rdquo;。\n1 2 enum color { red, green, blue } c; c = blue; 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。\n1 enum color { red, green=5, blue }; 在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。\n附录 cmath 常用函数： 取绝对值 fabs(double)\n1 2 3 4 5 6 7 8 9 10 11 #include\u0026lt;iostream\u0026gt; #include\u0026lt;math.h\u0026gt; using namespace std; int main() { double a=-12.1; a=fabs(a); cout\u0026lt;\u0026lt;a; } 12345678910 结果返回double类型：\n1 2 12.1 1 向上取整和向下取整 floor（double）和ceil（double）\n1 2 3 4 5 6 7 8 9 10 11 12 #include\u0026lt;iostream\u0026gt; #include\u0026lt;math.h\u0026gt; using namespace std; int main() { double a=-12.1,b,c; b=floor(a);//向下取整 c=ceil(a);//向上取整 cout\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; } 1234567891011 结果返回double类型：\n1 2 3 -13 -12 12 次方函数 pow（double a，double b）\n返回a的b次方，double类型。\n开平方根函数 sqrt（double x）\n返回根号a，double类型。\nlog函数 log（double x）\n返回以自然对数为底的对数。\n三角函数 1 2 3 4 5 6 7 8 9 10 11 12 13 #include\u0026lt;iostream\u0026gt; #include\u0026lt;math.h\u0026gt; using namespace std; int main() { double pi=acos(-1); double a=sin(pi*45/180); double b=cos(pi*45/180); double c=tan(pi*45/180); cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;b\u0026lt;\u0026lt;endl\u0026lt;\u0026lt;c; } 123456789101112 pi是圆周率的精确定义，注意这里用的是弧度制，而不是角度制，返回：\n1 2 3 4 -0.707107 -0.707107 1.000000 123 四舍五入函数 round（double x）\n返回x的四舍五入，double类型\n附录 转义字符 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) 009 \\v 垂直制表(VT) 011 \\' 单引号 039 \\\u0026quot; 双引号 034 \\\\ 反斜杠 092 \\n和\\t是最常用的两个转义字符：\n\\n用来换行，让文本从下一行的开头输出，前面的章节中已经多次使用； \\t用来占位，一般相当于四个空格，或者 tab 键的功能。 单引号、双引号、反斜杠是特殊的字符，不能直接表示：\n单引号是字符类型的开头和结尾，要使用\\'表示，也即'\\''； 双引号是字符串的开头和结尾，要使用\\\u0026quot;表示，也即\u0026quot;abc\\\u0026quot;123\u0026quot;； 反斜杠是转义字符的开头，要使用\\\\表示，也即'\\\\'，或者\u0026quot;abc\\\\123\u0026quot;。 附录 运算符结合性 一些容易出错的优先级问题 上表中，优先级同为1 的几种运算符如果同时出现，那怎么确定表达式的优先级呢？这是很多初学者迷糊的地方。下表就整理了这些容易出错的情况：\n这些容易出错的情况，希望读者好好在编译器上调试调试，这样印象会深一些。一定要多调试，光靠看代码，水平是很难提上来的。调试代码才是最长水平的。\n","permalink":"https://bablvsj.github.io/posts/exams/c++/","summary":"计算机信息管理专业课程 自考笔记在线更新地址 : https://github.com/Eished/self-study-exam_notes 配套代码：https://github.com/Eished/C-CPP 大纲 (2019版) 考试","title":"C++"},{"content":"HTML的概述 HTML的概念 HTML 全称为 HyperText Markup Language，译为超文本标记语言。\nHTML 不是一种编程语言，是一种描述性的标记语言。\n作用：HTML是负责描述文档语义的语言。\n概念：超文本 所谓的超文本，有两层含义：\n（1）图片、音频、视频、动画、多媒体等内容，成为超文本，因为它们超出了文本的限制。\n（2）可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。\n概念：标记语言 HTML 不是一种编程语言，是一种描述性的标记语言。这主要有两层含义：\n（1）标记语言是一套标记标签。比如：标签\u0026lt;a\u0026gt;表示超链接、标签\u0026lt;img\u0026gt;表示图片、标签\u0026lt;h1\u0026gt;表示一级标题等等，它们都是属于 HTML 标签。\n（2）编程语言是有编译过程的，而标记语言没有编译过程，HTML标签是直接由浏览器解析执行。\nHTML是负责描述文档语义的语言 HTML 格式的文件是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述语义，这些标签在浏览器页面上是无法直观看到的，所以称之为“超文本标记语言”。\nHTML的历史 其中，我们专门来对XHTML做一个介绍。\nXHTML介绍： XHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。 XHTML的主要目的是为了取代HTML，也可以理解为HTML的升级版。 HTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。 XHTML与HTML4.0的标记基本上一样。 XHTML是严格的、纯净的HTML。\nHTML的专有名词 网页 ：由各种标记组成的一个页面就叫网页。 主页(首页) : 一个网站的起始页面或者导航页面。 标记： 比如\u0026lt;p\u0026gt;称为开始标记 ，\u0026lt;/p\u0026gt;称为结束标记，也叫标签。每个标签都规定好了特殊的含义。 元素：比如\u0026lt;p\u0026gt;内容\u0026lt;/p\u0026gt;称为元素. 属性：给每一个标签所做的辅助信息。 XHTML：符合XML语法标准的HTML。 DHTML：dynamic，动态的。javascript + css + html合起来的页面就是一个 DHTML。 HTTP：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，FTP：文件传输协议。 书写第一个 HTML 页面 打开 VS Code 软件，新建一个文件，名叫test.html（注意，文件名是test，后缀名是html），保存到本地。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面的内容，就是 html 页面的骨架。我们在此基础之上，新增几个标签，完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;我是三级标题\u0026lt;/h3\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://www.jd.com\u0026#34;\u0026gt;我是超链接，可以点击一下\u0026lt;/a\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 标签写完之后，我们用 chrome 浏览器打开上面这个test.html文件，看看页面效果：\n到此，第一个简单的 HTML 页面就写完了。是不是很有成就感？\nHTML结构详解 HTML标签通常是成对出现的（双边标记），比如 \u0026lt;div\u0026gt; 和 \u0026lt;/div\u0026gt;；也有少部分单标签（单边标记），如：\u0026lt;br /\u0026gt;、\u0026lt;hr /\u0026gt;和\u0026lt;img src=\u0026quot;images/1.jpg\u0026quot; /\u0026gt;等。\n属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。\nhtml骨架标签分类 标签名 定义 说明 \u0026lt;html\u0026gt;\u0026lt;/html\u0026gt; HTML标签 页面中最大的标签，我们成为根标签 \u0026lt;head\u0026gt;\u0026lt;/head\u0026gt; 文档的头部 注意在head标签中我们必须要设置的标签是title \u0026lt;titile\u0026gt;\u0026lt;/title\u0026gt; 文档的标题 让页面拥有一个属于自己的网页标题 \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; 文档的主体 元素包含文档的所有内容，页面内容 基本都是放到body里面的 1、文档声明头 任何一个标准的HTML页面，第一行一定是一个以\u0026lt;!DOCTYPE ……\u0026gt;开头的语句。这一行，就是文档声明头，即 DocType Declaration，简称DTD。\nDTD可告知浏览器文档使用哪种 HTML 或 XHTML 规范。\nHTML4.01有哪些规范呢？ HTML4.01这个版本是IE6开始兼容的。HTML5是IE9开始兼容的。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。\n说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。\nHTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下图）。\nHTML4.01里面规定了普通和XHTML两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？\u0026lt;H1\u0026gt;\u0026lt;/H1\u0026gt;所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。\n总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况：\nXHTML\n1 2 3 4 5 6 7 8 9 \u0026lt;!DOCTYPE html PUBLIC \u0026#34;-//W3C//DTD XHTML 1.0 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\u0026#34;\u0026gt; \u0026lt;html xmlns=\u0026#34;http://www.w3.org/1999/xhtml\u0026#34; xml:lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html;charset=UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了。HTML5的DTD（文档声明头）如下：\n1 \u0026lt;!DOCTYPE html\u0026gt; 2、页面语言 lang 下面这行标签，用于指定页面的语言类型：\n1 \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; 最常见的语言类型有两种：\nen：定义页面语言为英语。\nzh-CN：定义页面语言为中文。\n3、头标签 head html5 的比较完整的骨架： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html;charset=UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;Author\u0026#34; content=\u0026#34;\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;Keywords\u0026#34; content=\u0026#34;厉害很厉害\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;Description\u0026#34; content=\u0026#34;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 头标签内部的常见标签如下：\n\u0026lt;title\u0026gt;：指定整个网页的标题，在浏览器最上方显示。 \u0026lt;base\u0026gt;：为页面上的所有链接规定默认地址或默认目标。 \u0026lt;meta\u0026gt;：提供有关页面的基本信息 \u0026lt;body\u0026gt;：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。 \u0026lt;link\u0026gt;：定义文档与外部资源的关系。 面试题：\n问：网页的head标签里面，表示的是页面的配置，有什么配置？ 答：字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等。 meta 标签：\nmeta表示“元”。“元”配置，就是表示基本的配置项目。\n常见的几种 meta 标签如下：\n（1）字符集 charset：\n1 \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html;charset=UTF-8\u0026#34;\u0026gt; charset就是character set（即“字符集”），即网页的编码方式。 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk、gb2312等。\n（2）视口 viewport：\n1 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; width=device-width ：表示视口宽度等于屏幕宽度。\n（3）定义“关键词”：\n1 \u0026lt;meta name=\u0026#34;Keywords\u0026#34; content=\u0026#34;网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信\u0026#34; /\u0026gt; 这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。\n（4）定义“页面描述”：\nmeta除了可以设置字符集，还可以设置关键字和页面描述。\n设置Description页面描述，用于SEO（search engine optimization，搜索引擎优化）。\n设置页面描述的举例：\n1 \u0026lt;meta name=\u0026#34;Description\u0026#34; content=\u0026#34;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。\u0026#34; /\u0026gt; 效果如下：\n3秒之后，自动跳转到百度页面\n1 \u0026lt;meta http-equiv=\u0026#34;refresh\u0026#34; content=\u0026#34;3;http://www.baidu.com\u0026#34;\u0026gt; title 标签: 用于设置网页标题：\n1 \u0026lt;title\u0026gt;网页的标题\u0026lt;/title\u0026gt; title标签也是有助于SEO搜索引擎优化的。\nbase标签：\n1 \u0026lt;base href=\u0026#34;/\u0026#34;\u0026gt; base 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。\n4、\u0026lt;body\u0026gt;标签 \u0026lt;body\u0026gt;标签的属性有：\nbgcolor：设置整个网页的背景颜色。 background：设置整个网页的背景图片。 text：设置网页中的文本颜色。 leftmargin：网页的左边距。IE浏览器默认是8个像素。 topmargin：网页的上边距。 rightmargin：网页的右边距。 bottommargin：网页的下边距。 \u0026lt;body\u0026gt;标签另外还有一些属性，这里用个例子来解释：\n上方代码中，当我们对点我点我这几个字使用超链时，link属性表示默认显示的颜色、alink属性表示鼠标点击但是还没有松开时的颜色、vlink属性表示点击完成之后显示的颜色。效果如下：\nHTML的规范 HTML不区分大小写，但HTML的标签名、类名、标签属性、大部分属性值建议统一用小写。 HTML页面的后缀名是html或者htm(有一些系统不支持后缀名长度超过3个字符，比如dos系统) 1、编写XHTML的规范： （1）所有标记元素都要正确的嵌套，不能交叉嵌套。正确写法举例：\u0026lt;h1\u0026gt;\u0026lt;font\u0026gt;\u0026lt;/font\u0026gt;\u0026lt;/h1\u0026gt;\n（2）所有的标记都必须小写。\n（3）所有的标签都必须闭合。\n双标签：\u0026lt;span\u0026gt;\u0026lt;/span\u0026gt;\n单标签：\u0026lt;br\u0026gt; 建议写成 \u0026lt;br /\u0026gt; \u0026lt;hr\u0026gt; 建议转成 \u0026lt;hr /\u0026gt;，还有\u0026lt;img src=“URL” /\u0026gt;\n（4）所有的属性值必须加引号。\u0026lt;font color=\u0026quot;red\u0026quot;\u0026gt;\u0026lt;/font\u0026gt;\n（5）所有的属性必须有值。\u0026lt;hr noshade=\u0026quot;noshade\u0026quot;\u0026gt;、\u0026lt;input type=\u0026quot;radio\u0026quot; checked=\u0026quot;checked\u0026quot; /\u0026gt;\n（6）XHTML文档开头必须要有DTD文档类型定义。\n2、HTML的基本语法特性 （1）HTML对换行不敏感，对tab不敏感 如下图所示：\n（2）空白折叠现象 HTML中所有的文字之间，如果有空格、换行、tab都将被折叠为一个空格显示。 （3）标签要严格封闭 标签不封闭的结果是灾难性的。\n计算机编码介绍 计算机，不能直接存储文字，存储的是编码。\n计算机只能处理二进制的数据，其它数据，比如：0-9、a-z、A-Z，这些字符，我们可以定义一套规则来表示。假如：A用110表示，B用111表示等。\nASCII码： 美国发布的，用1个字节(8位二进制)来表示一个字符，共可以表示2^8=256个字符。 美国的国家语言是英语，只要能表示0-9、a-z、A-Z、特殊符号。\nANSI编码： 每个国家为了显示本国的语言，都对ASCII码进行了扩展。用2个字节(16位二进制)来表示一个汉字，共可以表示2^16＝65536个汉字。例如： 中国的ANSI编码是GB2312编码(简体)，对6763汉字进行编码，含600多特殊字符。另外还有GBK(简体)。 日本的ANSI编码是JIS编码。 台湾的ANSI编码是BIG5编码（繁体）。\nGBK： 对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了2.1万左右。并提供了1890个汉字码位。K的含义就是“扩展”。\nUnicode编码(统一编码)： 用4个字节(32位二进制)来表示一个字符，想法不错，但效率太低。例如，字母A用ASCII表示的话一个字节就够，可用Unicode编码的话，得用4个字节表示，造成了空间的极大浪费。A的Unicode编码是0000 0000 0000 0000 0000 0000 0100 0000\nUTF-8(Unicode Transform Format)编码： 根据字符的不同，选择其编码的长度。比如：一个字符A用1个字节表示，一个汉字用2个字节表示。\n毫无疑问，开发中，都用UTF-8编码吧，准没错。\n中文能够使用的字符集两种：\n第一种：UTF-8。UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、鸟语……\n第二种：GBK（对GB2312进行了扩展）。gb2312 是国标，是中国的字库，里面仅涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。\n字库规模： UTF-8（字很全） \u0026gt; gb2312（只有汉字）\n重点1：避免乱码\n我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型一样，否则乱码（重点）。\n拿 sublime编辑器举例，当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： 文件→ set File Encoding to → Chinese Simplified(GBK)。VS Code 的道理一样。\n重点2：UTF-8和gb2312的比较\n保存大小：UTF-8（更臃肿、加载更慢） \u0026gt; gb2312 （更小巧，加载更快）\n总结：\nUTF-8：字多，有各种国家的语言，但是保存尺寸大，文件臃肿； gb2312：字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。 列出2个使用情形：\n1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。 2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。\n我们亲测：\nqq网、网易、搜狐都是使用gb2312。这些公司，都追求显示速度。 新华网藏语频道，使用的是UTF-8，保证字符集的数量。 我们是怎么查看网页的编码方式的呢？在浏览器中打开网页，右键，选择“查看网页源代码”，找到meta标签中的charset属性即可。\n那么，我们为什么可以查看网页的源代码呢？因为这个打开的html网页已经存到我的临时文件夹里了，临时文件夹里的html是纯文本文件，纯文本文件自然可以查看网页的源代码。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/01-html/03-%E5%88%9D%E8%AF%86html/","summary":"HTML的概述 HTML的概念 HTML 全称为 HyperText Markup Language，译为超文本标记语言。 HTML 不是一种编程语言，是一种描述性的标记语言。 作用：HTML是负","title":"初识HTML"},{"content":"1、TypeScript + Vue 泛型，interface和type有什么区别 交叉类型(\u0026amp;)与联合类型(|) 、可索引类型（数组） 类型申明文件与配置文件配置（最基础但最难理解） 2、前端工程化 webpack / vit\n3、node\n4、react\n5、git\n6、Serverless、微前端仍会稳步发展，未来将会大规模落地\n2022 python、Devops Serverless即“无服务器”架构，他试图帮助开发者摆脱运行后端应用程序所需的服务器设备的设置和管理工作，它由第三方云计算供应商负责后端基础结构的维护，同时以服务的方式为开发者提供所需的功能，例如数据库、消息、身份验证等。目前腾讯云、阿里云、aws等都在发力Serverless，一部分公司也开始将Serverless实施落地，让前端开发更加注重业务逻辑的开发。\n微前端的概念类似于微服务，它将前端应用拆分成一个个更小的更简单的能够独立开发、测试、部署的小块，在用户看来它依旧是一个独立的产品。前端业务在发展到一定规模后，需要一种能将业务化繁为简的架构。常用的微前端解决方案有single-spa、qiankun以及阿里的icestark\n2023 AR、VR、3D建模、IoT、5G\n5G应用的普及，新的交互方式、图形化内容的需求增加。\n5G应用已逐步走入大众生活，每一G的变化都会给整个社会带来翻天覆地的变化，同样，5G的大面积应用，也会给前端开发带来新的机遇与挑战。5G高速低延时的特性将实现传统的单页面的秒开，人们开始追求新的动画效果以及新的交互方式，前端页面将实现更酷炫的动画效果，同时AR、VR、3D建模等场景将重新崛起，图形内容的展示将更加丰富，未来将会有一部分前端工程师将会投入到专门开发动画场景、3D场景的工作中去，这就要求前端工程师要具备更高的图形化开发能力。\n","permalink":"https://bablvsj.github.io/posts/thinks/20210701-half/","summary":"1、TypeScript + Vue 泛型，interface和type有什么区别 交叉类型(\u0026amp;)与联合类型(|) 、可索引类型（数组） 类型申明文","title":"2021年中"},{"content":"1、《百年孤独》 无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。\n2、《被讨厌的勇气》 我们终其一生就是要摆脱他人的期待，找到真正的自己；\n经历本身不会决定什么，我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活。。。\n3、《社会契约论》 人生而自由，却又时时处在枷锁之中。自认为主宰一切，反而更像是一切的奴隶；\n人们能够争取自由，却永远无法恢复自由。\n4、《论人类不平等的起源和基础》 教育不仅使受教育的人之间产生差异，而且也使那些受教育的人在文化成熟方面产生差异。要知道：当巨人与矮子同时行走在一条道路上时，他们每多走一步，巨人相对矮子的优势就越大。\n5、《那不勒斯四部曲》 我的整个生命，只是一场为了提升社会地位的低俗斗争；\n假如一个人想一直做庶民，那他的孩子、孙子，都会命若草芥，不值一提。\n6、《活出生命的意义》 人所拥有的任何东西，都可以被剥夺，唯独人性最后的自由，——也就是在任何境遇中选择一己态度和生活方式的自由——不能被剥夺。\n7、《财富自由》 财富不是你快乐的理由，学会从通往财富的旅途中收获幸福才是。等到哪一天，消费再也无法控制你，你成了生活的主人时，生活自此也就充满了喜悦。\n伟大的博弈\n宏观经济学原理 微观经济学原理 货币银行学\n稳定不稳定经济\n明斯基时刻\n商：《低风险创业》 心：《空谷幽兰》 文：《你永远无法叫醒一个装睡的人》 ","permalink":"https://bablvsj.github.io/posts/thinks/20210501-book/","summary":"1、《百年孤独》 无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底","title":"一些闲书"},{"content":"JavaScript JavaScript的组成\nJavaScript 由以下三部分组成： ECMAScript（核心）：JavaScript 语言基础 DOM（文档对象模型）：规定了访问HTML和XML的接口 BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法 JS的基本数据类型和引用数据类型\n基本数据类型：undefined、null、boolean、number、string、symbol 引用数据类型：object、array、function 检测浏览器版本版本有哪些方式？\n根据 navigator.userAgent // UA.toLowerCase().indexOf(\u0026lsquo;chrome\u0026rsquo;) 根据 window 对象的成员 // \u0026lsquo;ActiveXObject\u0026rsquo; in window 介绍JS有哪些内置对象？\n数据封装类对象：Object、Array、Boolean、Number、String 其他对象：Function、Arguments、Math、Date、RegExp、Error ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect 说几条写JavaScript的基本规范？\n代码缩进，建议使用“四个空格”缩进 代码段使用花括号{}包裹 语句结束使用分号; 变量和函数在使用前进行声明 以大写字母开头命名构造函数，全大写命名常量 规范定义JSON对象，补全双引号 用{}和[]声明对象和数组 如何编写高性能的JavaScript？\n遵循严格模式：\u0026ldquo;use strict\u0026rdquo;; 将js脚本放在页面底部，加快渲染页面 将js脚本将脚本成组打包，减少请求 使用非阻塞方式下载js脚本 尽量使用局部变量来保存全局变量 尽量减少使用闭包 使用 window 对象属性方法时，省略 window 尽量减少对象成员嵌套 缓存 DOM 节点的访问 通过避免使用 eval() 和 Function() 构造器 给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数 尽量使用直接量创建对象和数组 最小化重绘(repaint)和回流(reflow) 描述浏览器的渲染过程，DOM树和渲染树的区别？\n浏览器的渲染过程：\n解析HTML构建 DOM(DOM树)，并行请求 css/image/js CSS 文件下载完成，开始构建 CSSOM(CSS树) CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树) 布局(Layout)：计算出每个节点在屏幕中的位置 显示(Painting)：通过显卡把页面画到屏幕上 DOM树 和 渲染树 的区别：\nDOM树与HTML标签一一对应，包括head和隐藏元素 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性 重绘和回流（重排）的区别和关系？\n重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流 注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值 回流必将引起重绘，而重绘不一定会引起回流 如何最小化重绘(repaint)和回流(reflow)？\n需要要对元素进行复杂的操作时，可以先隐藏(display:\u0026ldquo;none\u0026rdquo;)，操作完成后再显示 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document 缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流） 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面） 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx script 的位置是否会影响首屏显示时间？\n在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。 浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则 因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间 解释JavaScript中的作用域与变量声明提升？\nJavaScript作用域：\n在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域； 而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。 JavaScript变量声明提升：\n在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。 声明语句中的赋值部分并不会被提升，只有名称被提升 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数 介绍JavaScript的原型，原型链？有什么特点？\n原型：\nJavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型 JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。 原型链：\n当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找 如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链” 原型特点：\nJavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 JavaScript有几种类型的值？，你能画一下他们的内存图吗\n原始数据类型（Undefined，Null，Boolean，Number、String）\u0026ndash; 栈 引用数据类型（对象、数组和函数）\u0026ndash; 堆 两种类型的区别是：存储位置不同： 原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据； 引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 JavaScript如何实现一个类，怎么实例化这个类？\n构造函数法（this + prototype） \u0026ndash; 用 new 关键字 生成实例对象 缺点：用到了 this 和 prototype，编写复杂，可读性差 1 2 3 4 5 6 7 8 9 function Mobile(name, price){ this.name = name; this.price = price; } Mobile.prototype.sell = function(){ alert(this.name + \u0026#34;，售价 $\u0026#34; + this.price); } var iPhone7 = new Mobile(\u0026#34;iPhone7\u0026#34;, 1000); iPhone7.sell(); Object.create 法 \u0026ndash; 用 Object.create() 生成实例对象 缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var Person = { firstname: \u0026#34;Mark\u0026#34;, lastname: \u0026#34;Yun\u0026#34;, age: 25, introduce: function(){ alert(\u0026#39;I am \u0026#39; + Person.firstname + \u0026#39; \u0026#39; + Person.lastname); } }; var person = Object.create(Person); person.introduce(); // Object.create 要求 IE9+，低版本浏览器可以自行部署： if (!Object.create) { Object.create = function (o) { function F() {} F.prototype = o; return new F(); }; } 极简主义法（消除 this 和 prototype） \u0026ndash; 调用 createNew() 得到实例对象 优点：容易理解，结构清晰优雅，符合传统的\u0026quot;面向对象编程\u0026quot;的构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var Cat = { age: 3, // 共享数据 -- 定义在类对象内，createNew() 外 createNew: function () { var cat = {}; // var cat = Animal.createNew(); // 继承 Animal 类 cat.name = \u0026#34;小咪\u0026#34;; var sound = \u0026#34;喵喵喵\u0026#34;; // 私有属性--定义在 createNew() 内，输出对象外 cat.makeSound = function () { alert(sound); // 暴露私有属性 }; cat.changeAge = function(num){ Cat.age = num; // 修改共享数据 }; return cat; // 输出对象 } }; var cat = Cat.createNew(); cat.makeSound(); ES6 语法糖 class \u0026ndash; 用 new 关键字 生成实例对象 1 2 3 4 5 6 7 8 9 10 11 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; } } var point = new Point(2, 3); Javascript如何实现继承？\n构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上 1 2 3 4 5 function Cat(name,color){ Animal.apply(this, arguments); this.name = name; this.color = color; } 实例继承：将子对象的 prototype 指向父对象的一个实例 1 2 Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象 1 2 3 4 5 6 7 8 function extend(Child, Parent) { var p = Parent.prototype; var c = Child.prototype; for (var i in p) { c[i] = p[i]; } c.uber = p; } 原型继承：将子对象的 prototype 指向父对象的 prototype 1 2 3 4 5 6 7 function extend(Child, Parent) { var F = function(){}; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype; } ES6 语法糖 extends：class ColorPoint extends Point {} 1 2 3 4 5 6 7 8 9 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + \u0026#39; \u0026#39; + super.toString(); // 调用父类的toString() } } Javascript作用链域?\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链 谈谈this对象的理解\nthis 总是指向函数的直接调用者 如果有 new 关键字，this 指向 new 出来的实例对象 在事件中，this指向触发这个事件的对象 IE下 attachEvent 中的this总是指向全局对象Window eval是做什么的？\neval的功能是把对应的字符串解析成JS代码并运行\n应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行） 由JSON字符串转换为JSON对象的时候可以用 eval(\u0026rsquo;(\u0026rsquo;+ str +\u0026rsquo;)\u0026rsquo;); 什么是 Window 对象? 什么是 Document 对象?\nWindow 对象表示当前浏览器的窗口，是JavaScript的顶级对象。 我们创建的所有对象、函数、变量都是 Window 对象的成员。 Window 对象的方法和属性是在全局范围内有效的。 Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点） Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问 Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问 介绍 DOM 的发展\nDOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关 DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[\u0026rsquo;login\u0026rsquo;] DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象 DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo) DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator 介绍DOM0，DOM2，DOM3事件处理方式区别\nDOM0级事件处理方式： btn.onclick = func; btn.onclick = null; DOM2级事件处理方式： btn.addEventListener('click', func, false); btn.removeEventListener('click', func, false); btn.attachEvent(\u0026quot;onclick\u0026quot;, func); btn.detachEvent(\u0026quot;onclick\u0026quot;, func); DOM3级事件处理方式： eventUtil.addListener(input, \u0026quot;textInput\u0026quot;, func); eventUtil 是自定义对象，textInput 是DOM3级事件 事件的三个阶段\n捕获、目标、冒泡 介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？\n按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数 注意1：前提是事件被确实触发 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖” 事件执行顺序：判断的关键是否目标元素 非目标元素：根据W3C的标准执行：捕获-\u0026gt;目标元素-\u0026gt;冒泡（不依据事件绑定顺序） 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准） 最终顺序：父元素捕获-\u0026gt;目标元素事件1-\u0026gt;目标元素事件2-\u0026gt;子元素捕获-\u0026gt;子元素冒泡-\u0026gt;父元素冒泡 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\n该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数） 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 事件的代理/委托\n事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件 优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上 缺点： 使用不当会造成事件在不应该触发时触发 示例： 1 2 3 4 5 6 ulEl.addEventListener(\u0026#39;click\u0026#39;, function(e){ var target = event.target || event.srcElement; if(!!target \u0026amp;\u0026amp; target.nodeName.toUpperCase() === \u0026#34;LI\u0026#34;){ console.log(target.innerHTML); } }, false); IE与火狐的事件机制有什么区别？ 如何阻止冒泡？\nIE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获 IE的事件处理和W3C的事件处理有哪些区别？\n绑定事件\nW3C: targetEl.addEventListener(\u0026lsquo;click\u0026rsquo;, handler, false); IE: targetEl.attachEvent(\u0026lsquo;onclick\u0026rsquo;, handler); 删除事件\nW3C: targetEl.removeEventListener(\u0026lsquo;click\u0026rsquo;, handler, false); IE: targetEl.detachEvent(event, handler); 事件对象\nW3C: var e = arguments.callee.caller.arguments[0] IE: window.event 事件目标\nW3C: e.target IE: window.event.srcElement 阻止事件默认行为\nW3C: e.preventDefault() IE: window.event.returnValue = false 阻止事件传播\nW3C: e.stopPropagation() IE: window.event.cancelBubble = true W3C事件的 target 与 currentTarget 的区别？\ntarget 只会出现在事件流的目标阶段 currentTarget 可能出现在事件流的任何阶段 当事件流处在目标阶段时，二者的指向相同 当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级) 如何派发事件(dispatchEvent)？（如何进行事件广播？）\nW3C: 使用 dispatchEvent 方法 IE: 使用 fireEvent 方法 1 2 3 4 5 6 7 8 9 10 var fireEvent = function(element, event){ if (document.createEventObject){ var mockEvent = document.createEventObject(); return element.fireEvent(\u0026#39;on\u0026#39; + event, mockEvent) }else{ var mockEvent = document.createEvent(\u0026#39;HTMLEvents\u0026#39;); mockEvent.initEvent(event, true, true); return !element.dispatchEvent(mockEvent); } } 什么是函数节流？介绍一下应用场景和原理？\n函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）\n函数节流用于 onresize, onscroll 等短时间内会多次触发的事件\n函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器， 再 setTimeout 一个新的定时器重复以上流程。\n函数节流简单实现：\n1 2 3 4 5 6 7 8 9 10 function throttle(method, context) { clearTimeout(methor.tId); method.tId = setTimeout(function(){ method.call(context); }， 100); // 两次调用至少间隔 100ms } // 调用 window.onresize = function(){ throttle(myFunc, window); } 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？\n客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY) 页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY) 屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY) 如何获得一个DOM元素的绝对位置？\nelem.offsetLeft：返回元素相对于其定位父级左侧的距离 elem.offsetTop：返回元素相对于其定位父级顶部的距离 elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素 分析 [\u0026lsquo;1\u0026rsquo;, \u0026lsquo;2\u0026rsquo;, \u0026lsquo;3\u0026rsquo;].map(parseInt) 答案是多少？\n答案:[1, NaN, NaN] parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析 map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引 因此，map 遍历 [\u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;3\u0026rdquo;]，相应 parseInt 接收参数如下 1 2 3 parseInt(\u0026#39;1\u0026#39;, 0); // 1 parseInt(\u0026#39;2\u0026#39;, 1); // NaN parseInt(\u0026#39;3\u0026#39;, 2); // NaN 所以，parseInt 参数 radix 不合法，导致返回值为 NaN new 操作符具体干了什么？\n创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 用原生JavaScript的实现过什么功能吗？\n封装选择器、调用第三方API、设置和获取样式 解释一下这段代码的意思吗？\n1 2 3 [].forEach.call($$(\u0026#34;*\u0026#34;), function(el){ el.style.outline = \u0026#34;1px solid #\u0026#34; + (~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16); }) 解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓outline 1 2 3 4 5 6 7 1. `$$(sel)` // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel) 2. `[].forEach.call(NodeLists)` // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表 3. `el.style.outline = \u0026#34;1px solid #333\u0026#34;` // 样式 outline 位于盒模型之外，不影响元素布局位置 4. `(1\u0026lt;\u0026lt;24)` // parseInt(\u0026#34;ffffff\u0026#34;, 16) == 16777215 == 2^24 - 1 // 1\u0026lt;\u0026lt;24 == 2^24 == 16777216 5. `Math.random()*(1\u0026lt;\u0026lt;24)` // 表示一个位于 0 到 16777216 之间的随机浮点数 6. `~~Math.random()*(1\u0026lt;\u0026lt;24)` // `~~` 作用相当于 parseInt 取整 7. `(~~(Math.random()*(1\u0026lt;\u0026lt;24))).toString(16)` // 转换为一个十六进制- ** JavaScript实现异步编程的方法？**\n回调函数 事件监听 发布/订阅 Promises对象 Async函数[ES7] web开发中会话跟踪的方法有哪些\ncookie session url重写 隐藏input ip地址 介绍js的基本数据类型\nUndefined、Null、Boolean、Number、String 介绍js有哪些内置对象？\nObject 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 说几条写JavaScript的基本规范？\n不要在同一行声明多个变量 请使用 ===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 函数不应该有时候有返回值，有时候没有返回值 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 JavaScript原型，原型链 ? 有什么特点？\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时\n如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念\n关系：instance.constructor.prototype = instance.__proto__\n特点：\nJavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的\n就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象\nJavaScript有几种类型的值？，你能画一下他们的内存图吗？\n栈：原始数据类型（Undefined，Null，Boolean，Number、String）\n堆：引用数据类型（对象、数组和函数）\n两种类型的区别是：存储位置不同；\n原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\n在栈中的地址，取得地址后从堆中获得实体\nJavascript如何实现继承？\n构造继承\n原型继承\n实例继承\n拷贝继承\n原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 function Parent(){ this.name = \u0026#39;wang\u0026#39;; } function Child(){ this.age = 28; } Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 } javascript创建对象的几种方式？\njavascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用\n对象字面量的方式 1 person={firstname:\u0026#34;Mark\u0026#34;,lastname:\u0026#34;Yun\u0026#34;,age:25,eyecolor:\u0026#34;black\u0026#34;}; 用function来模拟无参的构造函数 1 2 3 4 5 6 7 8 function Person(){} var person=new Person();//定义一个function，如果使用new\u0026#34;实例化\u0026#34;,该function可以看作是一个Class person.name=\u0026#34;Mark\u0026#34;; person.age=\u0026#34;25\u0026#34;; person.work=function(){ alert(person.name+\u0026#34; hello...\u0026#34;); } person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） 1 2 3 4 5 6 7 8 9 10 function Pet(name,age,hobby){ this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function(){ alert(\u0026#34;我叫\u0026#34;+this.name+\u0026#34;,我喜欢\u0026#34;+this.hobby+\u0026#34;,是个程序员\u0026#34;); } } var maidou =new Pet(\u0026#34;麦兜\u0026#34;,25,\u0026#34;coding\u0026#34;);//实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） 1 2 3 4 5 6 7 var wcDog =new Object(); wcDog.name=\u0026#34;旺财\u0026#34;; wcDog.age=3; wcDog.work=function(){ alert(\u0026#34;我是\u0026#34;+wcDog.name+\u0026#34;,汪汪汪......\u0026#34;); } wcDog.work(); 用原型方式来创建 1 2 3 4 5 6 7 8 9 function Dog(){ } Dog.prototype.name=\u0026#34;旺财\u0026#34;; Dog.prototype.eat=function(){ alert(this.name+\u0026#34;是个吃货\u0026#34;); } var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建 1 2 3 4 5 6 7 8 9 function Car(name,price){ this.name=name; this.price=price; } Car.prototype.sell=function(){ alert(\u0026#34;我是\u0026#34;+this.name+\u0026#34;，我现在卖\u0026#34;+this.price+\u0026#34;万元\u0026#34;); } var camry =new Car(\u0026#34;凯美瑞\u0026#34;,27); camry.sell(); Javascript作用链域?\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找 直至全局函数，这种组织形式就是作用域链 谈谈This对象的理解\nthis总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window eval是做什么的？\n它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(\u0026rsquo;(\u0026rsquo;+ str +\u0026rsquo;)\u0026rsquo;) null，undefined 的区别？\nundefined 表示不存在这个值。\nundefined :是一个表示\u0026quot;无\u0026quot;的原始值或者说表示\u0026quot;缺少值\u0026quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined\n例如变量被声明了，但没有赋值时，就等于undefined\nnull 表示一个对象被定义了，值为“空值”\nnull : 是一个对象(空对象, 没有任何属性和方法)\n例如作为函数的参数，表示该函数的参数不是对象；\n在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined\n写一个通用的事件侦听器函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // event(事件)工具集，来源：github.com/markyun markyun.Event = { // 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != \u0026#39;function\u0026#39;) { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); }; } }, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(\u0026#39;on\u0026#39; + type, function() { handler.call(element); }); } else { element[\u0026#39;on\u0026#39; + type] = handler; } }, // 移除事件 removeEvent : function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.datachEvent) { element.detachEvent(\u0026#39;on\u0026#39; + type, handler); } else { element[\u0026#39;on\u0026#39; + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; } }, // 取消事件的默认行为 preventDefault : function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev \u0026amp;\u0026amp; Event == ev.constructor) { break; } c = c.caller; } } return ev; } }; [\u0026ldquo;1\u0026rdquo;, \u0026ldquo;2\u0026rdquo;, \u0026ldquo;3\u0026rdquo;].map(parseInt) 答案是多少？\n[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。 map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？\n我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件 ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 什么是闭包（closure），为什么要用它？\n闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\n闭包的特性：\n函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 javascript 代码中的\u0026quot;use strict\u0026quot;;是什么意思 ? 使用它区别是什么？\nuse strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 如何判断一个对象是否属于某个类？\n1 2 3 4 // 使用instanceof （待完善） if(a instanceof Person){ alert(\u0026#39;yes\u0026#39;); } new操作符具体干了什么呢?\n创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 1 2 3 var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); js延迟加载的方式有哪些？\ndefer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax 是什么? 如何创建一个Ajax？\najax的全称：Asynchronous Javascript And XML\n异步传输+js+xml\n所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验\n创建XMLHttpRequest对象,也就是创建一个异步调用对象\n建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n设置响应HTTP请求状态变化的函数\n发送HTTP请求\n获取异步调用返回的数据\n用JavaScript和DOM实现局部刷新\n同步和异步的区别?\n同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 异步加载JS的方式有哪些？\ndefer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack documen.write和 innerHTML的区别\ndocument.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点?\n（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 那些操作会造成内存泄漏？\n内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 渐进增强和优雅降级\n渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容\nJavascript垃圾回收方法\n标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting)\n在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间\njs继承方式及其优缺点\n原型链继承的缺点\n一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承）\n借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承\n组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 defer和async\ndefer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 用过哪些设计模式？\n工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例 1 2 3 4 5 6 7 8 9 10 function createObject(name,age,profession){//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () { return this.name + \u0026#39; at \u0026#39; + this.age + \u0026#39; engaged in \u0026#39; + this.profession; }; return obj; } var test1 = createObject(\u0026#39;trigkit4\u0026#39;,22,\u0026#39;programmer\u0026#39;);//第一个实例var test2 = createObject(\u0026#39;mike\u0026#39;,25,\u0026#39;engineer\u0026#39;);//第二个实例 构造函数模式\n使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 构造函数方法没有显示的创建对象 (new Object());\n直接将属性和方法赋值给 this 对象;\n没有 renturn 语句\n说说你对闭包的理解\n使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念\n闭包有三个特性：\n1.函数嵌套函数\n2.函数内部可以引用外部的参数和变量\n3.参数和变量不会被垃圾回收机制回收\n请解释一下 JavaScript 的同源策略\n概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 指一段脚本只能读取来自同一来源的窗口和文档的属性 为什么要有同源限制？\n我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点 现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制\n1 2 3 4 5 6 7 8 9 10 11 12 13 Object.prototype.clone = function(){ var o = this.constructor === Array ? [] : {}; for(var e in this){ o[e] = typeof this[e] === \u0026#34;object\u0026#34; ? this[e].clone() : this[e]; } return o; } 说说严格模式的限制\n严格模式主要有以下限制：\n变量必须声明后再使用\n函数的参数不能有同名属性，否则报错\n不能使用with语句\n不能对只读属性赋值，否则报错\n不能使用前缀0表示八进制数，否则报错\n不能删除不可删除的属性，否则报错\n不能删除变量delete prop，会报错，只能删除属性delete global[prop]\neval不会在它的外层作用域引入变量\neval和arguments不能被重新赋值\narguments不会自动反映函数参数的变化\n不能使用arguments.callee\n不能使用arguments.caller\n禁止this指向全局对象\n不能使用fn.caller和fn.arguments获取函数调用的堆栈\n增加了保留字（比如protected、static和interface）\n如何删除一个cookie\n将时间设为当前时间往前一点 1 2 3 var date = new Date(); date.setDate(date.getDate() - 1);//真正的删除 setDate()方法用于设置一个月的某一天\nexpires的设置 1 document.cookie = \u0026#39;user=\u0026#39;+ encodeURIComponent(\u0026#39;name\u0026#39;) + \u0026#39;;expires = \u0026#39; + new Date(0) 编写一个方法 求一个字符串的字节长度\n假设：一个英文字符占用一个字节，一个中文字符占用两个字节 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function GetBytes(str){ var len = str.length; var bytes = len; for(var i=0; i\u0026lt;len; i++){ if (str.charCodeAt(i) \u0026gt; 255) bytes++; } return bytes; } alert(GetBytes(\u0026#34;你好,as\u0026#34;)); 请解释什么是事件代理\n事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能 attribute和property的区别是什么？\nattribute是dom元素在文档中作为html标签拥有的属性；\nproperty就是dom元素在js中作为对象拥有的属性。\n对于html的标准属性来说，attribute和property是同步的，是会自动更新的\n但是对于自定义的属性来说，他们是不同步的\n页面编码和被请求的资源编码如果不一致如何处理？\n后端响应头设置 charset 前端页面\u0026lt;meta\u0026gt;设置 charset 把\u0026lt;script\u0026gt;放在\u0026lt;/body\u0026gt;之前和之后有什么区别？浏览器会如何解析它们？\n按照HTML标准，在\u0026lt;/body\u0026gt;结束后出现\u0026lt;script\u0026gt;或任何元素的开始标签，都是解析错误 虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在\u0026lt;/body\u0026gt;之前没有区别 浏览器的容错机制会忽略script之前的\u0026lt;/body\u0026gt;，视作\u0026lt;script\u0026gt;仍在 body 体内。省略\u0026lt;/body\u0026gt;和\u0026lt;/html\u0026gt;闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容 延迟加载JS的方式有哪些？\n设置\u0026lt;script\u0026gt;属性 defer=\u0026ldquo;defer\u0026rdquo; （脚本将在页面完成解析时执行） 动态创建 script DOM：document.createElement(\u0026lsquo;script\u0026rsquo;); XmlHttpRequest 脚本注入 延迟加载工具 LazyLoad 异步加载JS的方式有哪些？\n设置\u0026lt;script\u0026gt;属性 async=\u0026ldquo;async\u0026rdquo; （一旦脚本可用，则会异步执行） 动态创建 script DOM：document.createElement(\u0026lsquo;script\u0026rsquo;); XmlHttpRequest 脚本注入 异步加载库 LABjs 模块加载器 Sea.js JavaScript 中，调用函数有哪几种方式？\n方法调用模式 Foo.foo(arg1, arg2); 函数调用模式 foo(arg1, arg2); 构造器调用模式 (new Foo())(arg1, arg2); call/applay调用模式 Foo.foo.call(that, arg1, arg2); bind调用模式 Foo.foo.bind(that)(arg1, arg2)(); 简单实现 Function.bind 函数？\n1 2 3 4 5 6 7 8 9 10 11 12 13 if (!Function.prototype.bind) { Function.prototype.bind = function(that) { var func = this, args = arguments; return function() { return func.apply(that, Array.prototype.slice.call(args, 1)); } } } // 只支持 bind 阶段的默认参数： func.bind(that, arg1, arg2)(); // 不支持以下调用阶段传入的参数： func.bind(that)(arg1, arg2); ** 列举一下JavaScript数组和对象有哪些原生方法 **\n数组：\narr.concat(arr1, arr2, arrn); arr.join(\u0026quot;,\u0026quot;); arr.sort(func); arr.pop(); arr.push(e1, e2, en); arr.shift(); unshift(e1, e2, en); arr.reverse(); arr.slice(start, end); arr.splice(index, count, e1, e2, en); arr.indexOf(el); arr.includes(el); // ES6 对象：\nobject.hasOwnProperty(prop); object.propertyIsEnumerable(prop); object.valueOf(); object.toString(); object.toLocaleString(); Class.prototype.isPropertyOf(object); Array.splice() 与 Array.splice() 的区别？\nslice \u0026ndash; “读取”数组指定的元素，不会对原数组进行修改\n语法：arr.slice(start, end) start 指定选取开始位置（含） end 指定选取结束位置（不含） splice\n“操作”数组指定的元素，会修改原数组，返回被删除的元素 语法：arr.splice(index, count, [insert Elements]) index 是操作的起始位置 count = 0 插入元素，count \u0026gt; 0 删除元素 [insert Elements] 向数组新插入的元素 JavaScript 对象生命周期的理解？\n当创建一个对象时，JavaScript 会自动为该对象分配适当的内存 垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量 如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收 哪些操作会造成内存泄漏？\nJavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收\n未使用 var 声明的全局变量\n闭包函数(Closures)\n循环引用(两个对象相互引用)\n控制台日志(console.log)\n移除存在绑定事件的DOM元素(IE)\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/javascript/","summary":"JavaScript JavaScript的组成 JavaScript 由以下三部分组成： ECMAScript（核心）：JavaScript 语言基础 DOM（文档对象模型）：规定了访问","title":"JavaScript"},{"content":"手写事件侦听器，并要求兼容浏览器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 var eventUtil = { getEvent: function(event) { return event || window.event; }, getTarget: function(event) { return event.target || event.srcElement; }, addListener: function(element, type, hander) { if (element.addEventListener) { element.addEventListener(type, hander, false); } else if (element.attachEvent) { element.attachEvent(\u0026#39;on\u0026#39; + type, hander); } else { element[\u0026#39;on\u0026#39; + type] = hander; } }, removeListener: function(element, type, hander) { if (element.removeEventListener) { element.removeEventListener(type, hander, false); } else if (element.deattachEvent) { element.detachEvent(type, hander); } else { element[\u0026#39;on\u0026#39; + type] = null; } }, preventDefault: function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, stopPropagation: function(event) { if (event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } } }; // 调用 (function() { var btn = document.getElementById(\u0026#34;btn\u0026#34;); var link = document.getElementsByTagName(\u0026#34;a\u0026#34;)[0]; eventUtil.addListener(btn, \u0026#34;click\u0026#34;, function(event) { var event = eventUtil.getEvent(event); var target = eventUtil.getTarget(event); alert(event.type); alert(target); eventUtil.stopPropagation(event); }); eventUtil.addListener(link, \u0026#34;click\u0026#34;, function(event) { alert(\u0026#34;prevent default event\u0026#34;); var event = eventUtil.getEvent(event); eventUtil.preventDefault(event); }); eventUtil.addListener(document.body, \u0026#34;click\u0026#34;, function() { alert(\u0026#34;click body\u0026#34;); }); })(); 手写事件模型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 var Event = (function () { var list = {}, bind, trigger, remove; bind = function (key, fn) { if (!list[key]) { list[key] = []; } list[key].push(fn); }; trigger = function () { var key = Array.prototype.shift.call(arguments); var fns = list[key]; if (!fns || fns.length === 0) { return false; } for (var i = 0, fn; fn = fns[i++];) { fn.apply(this, arguments); } }; remove = function (key, fn) { var fns = list[key]; if (!fns) { return false; } if (!fn) { fns \u0026amp; (fns.length = 0); } else { for (var i = fns.length - 1; i \u0026gt;= 0; i--) { var _fn = fns[i]; if (_fn === fn) { fns.splice(i, 1); } } } }; return { bind: bind, trigger: trigger, remove: remove } })(); // 调用 Event.bind(\u0026#39;Hit\u0026#39;, function(){ console.log(\u0026#39;bind event\u0026#39;); }); // 绑定事件 Event.trigger(\u0026#34;Hit\u0026#34;, function(){ console.log(\u0026#39;trigger event\u0026#39;); }); // 触发事件 手写事件代理，并要求兼容浏览器\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 function delegateEvent(parentEl, selector, type, fn) { var handler = function(e){ var e = e || window.event; var target = e.target || e.srcElement; if (matchSelector(target, selector)) { if(fn) { fn.call(target, e); } } }; if(parentEl.addEventListener){ parentEl.addEventListener(type, handler); }else{ parentEl.attachEvent(\u0026#34;on\u0026#34; + type, handler); } } /** * support #id, tagName, .className */ function matchSelector(ele, selector) { // if use id if (selector.charAt(0) === \u0026#34;#\u0026#34;) { return ele.id === selector.slice(1); } // if use class if (selector.charAt(0) === \u0026#34;.\u0026#34;) { return (\u0026#34; \u0026#34; + ele.className + \u0026#34; \u0026#34;).indexOf(\u0026#34; \u0026#34; + selector.slice(1) + \u0026#34; \u0026#34;) != -1; } // if use tagName return ele.tagName.toLowerCase() === selector.toLowerCase(); } // 调用 var box = document.getElementById(\u0026#34;box\u0026#34;); delegateEvent(box, \u0026#34;a\u0026#34;, \u0026#34;click\u0026#34;, function(){ console.log(this.href); }) 手写事件触发器，并要求兼容浏览器\n1 2 3 4 5 6 7 8 9 10 var fireEvent = function(element, event){ if (document.createEventObject){ var mockEvent = document.createEventObject(); return element.fireEvent(\u0026#39;on\u0026#39; + event, mockEvent) }else{ var mockEvent = document.createEvent(\u0026#39;HTMLEvents\u0026#39;); mockEvent.initEvent(event, true, true); return element.dispatchEvent(mockEvent); } } 手写 Function.bind 函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 if (!Function.prototype.bind) { Function.prototype.bind = function (oThis) { if (typeof this !== \u0026#34;function\u0026#34;) { throw new TypeError(\u0026#34;\u0026#39;this\u0026#39; is not function\u0026#34;); } // bind\u0026#39;s default arguments, array without first element // first part arguments for the function var aBindArgs = Array.prototype.slice.call(arguments, 1); var fToBind = this; // the function will be binding var fNOP = function () {}; var fBound = function () { // target this will be binding var oThis = this instanceof fNOP ? this : oThis || this; // last part arguments for the function var aCallArgs = Array.prototype.slice.call(arguments); // complete arguments for the function var aFuncArgs = aBindArgs.concat(aCallArgs); return fToBind.apply(oThis, aFuncArgs); }; // fBound extends fToBind fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; }; } // 调用 var add = function(a, b, c){ return a + b + c;}; var newAdd = add.bind(null, 1, 2); var result = newAdd(3); 手写数组快速排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var quickSort = function(arr) { if (arr.length \u0026lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0, len = arr.length; i \u0026lt; len; i++){ if (arr[i] \u0026lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return quickSort(left).concat([pivot], quickSort(right)); }; // 调用 quickSort([9, 4, 2, 8, 1, 5, 3, 7]); 手写数组冒泡排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var bubble = function(arr){ var maxIndex = arr.length - 1, temp, flag; for (var i = maxIndex; i \u0026gt; 0; i--) { flag = true for (var j = 0; j \u0026lt; i; j++) { if (arr[j] \u0026gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; } } if(! flag){ break; } } return arr; } // 调用 var arr = bubble([13, 69, 28, 93, 55, 75, 34]); 手写数组去重\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 Array.prototype.unique = function() { return [...new Set(this)];}; // 调用 [1, 2, 3, 3, 2, 1].unique(); function unique1(arr){ var hash = {}, result = []; for(var i=0, len=arr.length; i\u0026lt;len; i++){ if(! hash[arr[i]]){ result.push(arr[i]); hash[arr[i]] = true; } } return result; } // 调用 unique1([1, 2, 3, 3, 2, 1]); Array.prototype.unique2 = function(){ this.sort(); var result = [this[0]]; var len = this.length; for(var i = 0; i \u0026lt; len; i++){ if(this[i] !== result[result.length - 1]){ result.push(this[i]); } } return result; } // 调用 [1, 2, 3, 3, 2, 1].unique2(); function unique3(arr){ var result = []; for(var i=0; i\u0026lt;arr.length; i++){ if(result.indexOf(arr[i]) == -1){ result.push(arr[i]); } } return result; } // 调用 unique3([1, 2, 3, 3, 2, 1]); 将url的查询参数解析成字典对象\n1 2 3 4 5 6 7 8 9 10 11 12 13 function parseQuery(url) { url = url == null ? window.location.href : url; var search = url.substring(url.lastIndexOf(\u0026#34;?\u0026#34;) + 1); var hash = {}; var reg = /([^?\u0026amp;=]+)=([^?\u0026amp;=]*)/g; search.replace(reg, function (match, $1, $2) { var name = decodeURIComponent($1); var val = decodeURIComponent($2); hash[name] = String(val); return match; }); return hash; } 封装函数节流函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var throttle = function(fn, delay, mustRunDelay){ var timer = null; var t_start; return function(){ var context = this, args = arguments, t_curr = +new Date(); clearTimeout(timer); if(!t_start){ t_start = t_curr; } if(t_curr - t_start \u0026gt;= mustRunDelay){ fn.apply(context, args); t_start = t_curr; } else { timer = setTimeout(function(){ fn.apply(context, args); }, delay); } }; }; // 调用（两次间隔50ms内连续触发不执行，但每累计100ms至少执行一次 window.onresize = throttle(myFunc, 50, 100); 用JS实现千位分隔符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function test1(num){ var str = (+ num) + \u0026#39;\u0026#39;; var len = str.length; if(len \u0026lt;= 3) return str; num = \u0026#39;\u0026#39;; while(len \u0026gt; 3){ len -= 3; num = \u0026#39;,\u0026#39; + str.substr(len, 3) + num; } return str.substr(0, len) + num; } function test2(num){ // ?= 正向匹配:匹配位置 // ?! 正向不匹配:排除位置 var str = (+num).toString(); var reg = /(?=(?!\\b)(\\d{3})+$)/g; return str.replace(reg, \u0026#39;,\u0026#39;); } ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/202308-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/","summary":"手写事件侦听器，并要求兼容浏览器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54","title":"手写代码"},{"content":"egg-sequelize 连接多个数据库如何配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 config.sequelize = { datasources: [ { delegate: \u0026#39;model\u0026#39;, // 加载所有的模型到 app.model and ctx.model baseDir: \u0026#39;model\u0026#39;, // 要加载的模型目录`app/model/*.js` dialect: \u0026#39;mysql\u0026#39;, host: \u0026#39;10.52.18.8\u0026#39;, port: 3306, username: \u0026#39;root\u0026#39;, // 用户名 password: \u0026#39;root\u0026#39;, // 用户密码 database: \u0026#39;crt_crland_screen\u0026#39;, // 数据库名 dateStrings: true, // 解决时间格式 pool: { max: 20, min: 0, idle: 10000, }, }, { delegate: \u0026#39;appModel\u0026#39;, // 加载所有的模型到 app.logModel and ctx.logModel baseDir: \u0026#39;model_app\u0026#39;, // 要加载的模型目录 `app/model_log/*.js` // local dialect: \u0026#39;mysql\u0026#39;, host: \u0026#39;10.52.18.8\u0026#39;, port: 3306, username: \u0026#39;root\u0026#39;, // 用户名 password: \u0026#39;root\u0026#39;, // 用户密码 database: \u0026#39;hotel_report\u0026#39;, // 数据库名 dateStrings: true, // 解决时间格式 pool: { max: 20, min: 0, idle: 10000, }, }, ], }; 注意事项：\n很多人担心 controller 、service 、 model 需要怎么编写\ncontroller \\ service 正常编写\nmodel 需要注意 后续添加的数据库指定了baseDir（新的model 目录）\n配置的delegate 属性 ==\u0026gt; app.appModel / ctx.appModel （连接表 / 服务时记得把model 换成配置的 delegate ）\n​\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/egg.js/","summary":"egg-sequelize 连接多个数据库如何配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 config.sequelize = { datasources: [ { delegate: \u0026#39;model\u0026#39;, // 加载所有的模型到 app.model and ctx.model baseDir:","title":"egg.js"},{"content":"前言 一面要讲的内容：\nHTTP协议的主要特点\nHTTP报文的组成部分\nHTTP方法\nget 和 post的区别\nHTTP状态码\n什么是持久连接\n什么是管线化\n二面要讲的内容；\n缓存\nCSRF攻击\nHTTP协议的主要特点 简单快速：每个资源（比如图片、页面）都通过 url 来定位，想访问什么资源，直接输入url即可。\n灵活 : http协议的头部有一个数据类型，通过http协议，就可以完成不同数据类型的传输。\n无连接 : 连接一次，就会断开，不会继续保持连接。\n无状态 :\n客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。\n有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。\nHTTP报文的组成部分 在回答此问题时，我们要按照顺序回答：\n先回答的是，http报文包括：请求报文和响应报文。\n再回答的是，每个报文包含什么部分。\n最后回答，每个部分的内容是什么\n请求报文包括： 请求行：包括请求方法、请求的url、http协议及版本。 请求头：一大堆的键值对。 空行指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。 请求体：数据部分。 响应报文包括： 状态行：http协议及版本、状态码及状态描述。 响应头 空行 响应体 HTTP方法 包括：\nGET：获取资源 POST：传输资源 PUT：更新资源 DELETE：删除资源 HEAD：获得报文首部 HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。 get 和 post 比较常见。 put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。\nget 和 post的区别 get是相对不隐私的，而post是相对隐私的。\n1、浏览器在回退时，get不会重新请求，但是post会重新请求。【重要】 2、get请求会被浏览器主动缓存，而post不会。【重要】 3、get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。 4、get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有限制。 5、get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。\nhttp状态码 206的应用：range指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。\n301：重定向（永久）。\n302：重定向（临时）。\n304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。\n401 请求未授权\n403 请求被拒绝\n404 请求资源不存在\n500 服务器错误\n503 请求未完成，服务器宕机/过载\n持久链接/http长连接 轮询：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。\n长连接：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。\n注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/04-http%E5%8D%8F%E8%AE%AE/","summary":"前言 一面要讲的内容： HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的区别 HTTP状态码 什么是持久连接 什么是管线化 二面要","title":"HTTP协议"},{"content":"JS的异步和单线程 题目一：异步 现有如下代码：\n1 2 3 4 5 6 7 console.log(1); setTimeout(function () { console.log(2); }, 1000); console.log(3); console.log(4); // 我们很容易知道，打印的顺序是`1，3，4，2` 可如果我把延时的时间从1000改成0：\n1 2 3 4 5 6 console.log(1); setTimeout(function () { console.log(2); }, 0); console.log(3); console.log(4); 上方代码中，打印的顺序仍然是1，3，4，2。这是为什么呢？我们来分析一下。\n总结：\njs 是单线程（同一时间只能做一件事），而且有一个任务队列：全部的同步任务执行完毕后，再来执行异步任务。第一行代码和最后一行代码是同步任务；但是 setTimeout是异步任务。\n于是，执行的顺序是：\n先执行同步任务console.log(1) 遇到异步任务setTimeout，要挂起 执行同步任务console.log(3) 全部的同步任务执行完毕后，再来执行异步任务console.log(2)。 注意上面那句话：同步任务执行完毕后，再来执行异步任务。如果同步任务没有执行完，异步任务是不会执行的。\n题目二：异步 现有如下代码：\n1 2 3 console.log(\u0026#39;A\u0026#39;); while (1) {} console.log(\u0026#39;B\u0026#39;); 我们很容易想到，上方代码的打印结果是A，因为while是同步任务，代码会陷入死循环里出不来，自然也就无法打印B。可如果我把代码改成下面的样子：\n1 2 3 4 5 6 console.log(\u0026#39;A\u0026#39;); setTimeout(function () { console.log(\u0026#39;B\u0026#39;); }) while (1) {} 上方代码的打印结果仍然是 A，因为while是同步任务，setTimeout是异步任务，如果同步任务没有执行完，队列里的异步任务是不会执行的。\n题目三：同步 1 2 3 console.log(\u0026#39;A\u0026#39;); alert(\u0026#39;haha\u0026#39;); //1秒之后点击确认 console.log(\u0026#39;B\u0026#39;); alert函数是同步任务，我只有点击了确认，才会继续打印B。\n同步和异步的对比 【重要】 因为setTimeout是异步任务，所以程序并不会卡在那里，而是继续向下执行（即使settimeout设置了倒计时一万秒）；但是alert函数是同步任务，程序会卡在那里，如果它没有执行，后面的也不会执行（卡在那里，自然也就造成了阻塞）。\n前端使用异步的场景 什么时候需要等待，就什么时候用异步。\n定时任务：setTimeout（定时炸弹）、setInterval（循环执行） 网络请求：ajax请求、动态\u0026lt;img\u0026gt;加载 事件绑定 ES6中的Promise 代码举例：\n1 2 3 4 5 6 7 console.log(\u0026#39;start\u0026#39;); var img = document.createElement(\u0026#39;img\u0026#39;); img.onload = function () { console.log(\u0026#39;loaded\u0026#39;); } img.src = \u0026#39;/xxx.png\u0026#39;; console.log(\u0026#39;end\u0026#39;); 上图中，先打印start，然后执行img.src = '/xxx.png'，然后打印end，最后打印loaded。\n任务队列和Event Loop（事件循环） 任务队列 所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。 同步任务 指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。 异步任务 指的是，不进入主线程、而进入\u0026quot;任务队列\u0026quot;（task queue）的任务，只有\u0026quot;任务队列\u0026quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。\n总结：只要主线程空了，就会去读取\u0026quot;任务队列\u0026quot;，这就是JavaScript的运行机制。【重要】\nEvent Loop 主线程从\u0026quot;任务队列\u0026quot;中读取事件，这个过程是循环不断的，所以整个的运行机制又称为Event Loop（事件循环）。\n在理解Event Loop时，要理解两句话：\n理解哪些语句会放入异步任务队列\n理解语句放入异步任务队列的时机\n容易答错的题目 1 2 3 4 5 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function () { console.log(i); }, 1000); } 很多人以为上面的题目，答案是0,1,2,3。其实，正确的答案是：3,3,3,3。\n分析：for 循环是同步任务，setTimeout是异步任务。for循环每次遍历的时候，遇到settimeout，就先暂留着，等同步任务全部执行完毕（此时，i已经等于3了），再执行异步任务。\n我们把上面的题目再加一行代码。最终代码如下：\n1 2 3 4 5 6 for (var i = 0; i \u0026lt; 3; i++) { setTimeout(function () { console.log(i); }, 1000); } console.log(i); //3 -\u0026gt; 3,3,3 如果我们约定，用箭头表示其前后的两次输出之间有 1 秒的时间间隔，而逗号表示其前后的两次输出之间的时间间隔可以忽略，代码实际运行的结果该如何描述？可能会有两种答案：\nA. 60% 的人会描述为：3 -\u0026gt; 3 -\u0026gt; 3 -\u0026gt; 3，即每个 3 之间都有 1 秒的时间间隔；\nB. 40% 的人会描述为：3 -\u0026gt; 3,3,3，即第 1 个 3 直接输出，1 秒之后，连续输出 3 个 3。\n循环执行过程中，几乎同时设置了 3 个定时器，这些定时器都会在 1 秒之后触发，而循环完的输出是立即执行的，显而易见，正确的描述是 B。\n上面这个题目的参考链接：\n深入浅出Javascript事件循环机制(上) 深入浅出Javascript事件循环机制(下) ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/09-js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B/","summary":"JS的异步和单线程 题目一：异步 现有如下代码： 1 2 3 4 5 6 7 console.log(1); setTimeout(function () { console.log(2); }, 1000); console.log(3); console.log(4); // 我们很容易知道，打印的顺序是`1，3，4，2` 可如果我把延时的","title":"js运行机制：异步和单线程"},{"content":"征服JavaScript面试系列 | 众城翻译 征服 JavaScript 面试：什么是闭包？\n征服 JavaScript 面试：什么是函数组合\n征服JavaScript面试系列：类继承和原型继承的区别\n征服 JavaScript 面试：什么是纯函数\n征服 JavaScript 面试: 什么是函数式编程？\n征服 JavaScript 面试: 什么是 Promise？\nHTTP最强资料大全\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/z-%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/","summary":"征服JavaScript面试系列 | 众城翻译 征服 JavaScript 面试：什么是闭包？ 征服 JavaScript 面试：什么是函数组合 征服JavaScript面试系列：类继承和原型继","title":"z-推荐文章"},{"content":"CSRF 基本概念、缩写、全称 CSRF（Cross-site request forgery）：跨站请求伪造。 PS：中文名一定要记住\nCSRF的攻击原理 用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。\n从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：\n（1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）\n（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。\n我们在讲CSRF时，一定要把上面的两点说清楚。\n温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。\n举个例子，前段时间里，微博网站有个api接口有漏洞，导致很多用户的粉丝暴增。\nCSRF如何防御 方法一、Token 验证：（用的最多） （1）服务器发送给客户端一个token； （2）客户端提交的表单中带着这个token。 （3）如果这个 token 不合法，那么服务器拒绝这个请求。\n方法二：隐藏令牌： 把 token 隐藏在 http 的 head头中。\n方法三、Referer 验证： Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。\n方法四 表单统一用post\nXSS XSS的基本概念 XSS（Cross Site Scripting）：跨域脚本攻击。\nXSS的攻击原理 XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。\n最后导致的结果可能是：\n盗用Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss攻击 XSS的攻击方式 1、反射型XSS 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。\n2、存储型XSS 存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。 XSS的防范措施（encode + 过滤） Vue中的防御措施 不论使用模板还是渲染函数，Vue都会将插值的内容都会自动转义 通过转义\u0026lt;为\u0026amp;lt以及\u0026gt;为\u0026amp;gt来实现防御HTML节点内容 要在模板内避免渲染 style 标签: CSRF 和 XSS 的区别 面试官还可能喜欢问二者的区别。\n区别一：\nCSRF：需要用户先登录网站A，获取 cookie。 XSS：不需要登录。 区别二：（原理的区别）\nCSRF：是利用网站A本身的漏洞，去请求网站A的api。 XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。 XSS文章推荐 http://html5sec.org/ 里面列出了很多XSS的例子，可以长见识。如果你专门研究XSS，可以看看。\nFreeBuf网站上的专栏作者：Black-Hole 比如，他的第一篇文章就讲到了XSS的原理分析与解剖。有句话摘抄如下：弹窗只是测试xss的存在性和使用性。\n比如，这个人还有篇文章写自动化检测CSRF（第一章）。大公司做网站，一般会做嗅探服务（比如自动化工具做CSRF的检测、自动化的方式控制安全风险）。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/07-%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98csrf%E5%92%8Cxss/","summary":"CSRF 基本概念、缩写、全称 CSRF（Cross-site request forgery）：跨站请求伪造。 PS：中文名一定要记住 CSRF的攻击原理 用户是网站A的","title":"安全问题：CSRF和XSS"},{"content":"排序 上面的排序这么多，我们要记住下面这三个：\n快速排序：https://segmentfault.com/a/1190000009426421 选择排序：https://segmentfault.com/a/1190000009366805 希尔排序：https://segmentfault.com/a/1190000009461832 如果你还要学一个，那就是冒泡排序。\n堆栈、队列、链表 堆栈：先进后出。\n数组、队列、链表 递归 参考链接：\nJavaScript中的递归 递归理解起来不难，但是用的时候很难，因为你没抓住他的本质。 递归的终止条件是什么？参数是怎么传递的？一定要搞清楚。\n波兰式和逆波兰式 推荐链接：\n理论：http://www.cnblogs.com/chenying99/p/3675876.html 源码：https://github.com/Tairraos/rpn.js/blob/master/rpn.js ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/08-%E7%AE%97%E6%B3%95%E9%97%AE%E9%A2%98/","summary":"排序 上面的排序这么多，我们要记住下面这三个： 快速排序：https://segmentfault.com/a/1190000009426421","title":"算法问题"},{"content":"同源策略的概念和具体限制 同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。（来自MDN官方的解释）\n具体解释：\n（1）源包括三个部分：协议、域名、端口（http协议的默认端口是80）。如果有任何一个部分不同，则源不同，那就是跨域了。\n（2）限制：这个源的文档没有权利去操作另一个源的文档。这个限制体现在：（要记住）\nCookie、LocalStorage和IndexDB无法获取。\n无法获取和操作DOM。\n不能发送Ajax请求。我们要注意，Ajax只适合同源的通信。\n前后端如何通信 主要有以下几种方式：\nAjax：不支持跨域。\nWebSocket：不受同源策略的限制，支持跨域。\nCORS：不受同源策略的限制，支持跨域。一种新的通信协议标准。可以理解成是：同时支持同源和跨域的Ajax\nAjax 的推荐链接：https://segmentfault.com/a/1190000006669043\n跨域通信的几种方式 方式如下：\n1、JSONP 2、WebSocket 3、CORS 4、Nginx 反向代理 1、WebSocket WebSocket的用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // var ws = new WebSocket(\u0026#39;wss://echo.websocket.org\u0026#39;); //创建WebSocket的对象。 //把请求发出去 ws.onopen = function (evt) { console.log(\u0026#39;Connection open ...\u0026#39;); ws.send(\u0026#39;Hello WebSockets!\u0026#39;); }; //对方发消息过来时，我接收 ws.onmessage = function (evt) { console.log(\u0026#39;Received Message: \u0026#39;, evt.data); ws.close(); }; //关闭连接 ws.onclose = function (evt) { console.log(\u0026#39;Connection closed.\u0026#39;); }; Websocket的推荐链接：http://www.ruanyifeng.com/blog/2017/05/websocket.html\n2、跨域资源共享 CORS CORS 可以理解成是既可以同步、也可以异步的Ajax。\n3、Nginx 反向代理 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/06-%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/","summary":"同源策略的概念和具体限制 同源策略：限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制","title":"跨域通信类"},{"content":"基础知识主要包含以下几个方面：\n基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECMAScript、CSS、TypeScript、HTML、Node.js 等语法的了解和使用 框架：React、Vue、Egg、Koa、Express、Webpack 等原理的了解和使用 工程：编译工具、格式工具、Git、NPM、单元测试、Nginx、PM2、CI / CD 了解和使用 网络：HTTP、TCP、UDP、WebSocket、Cookie、Session、跨域、缓存、协议的了解 性能：编译性能、监控、白屏检测、SEO、Service Worker 等了解 插件：Chrome 、Vue CLI 、Webpack 等插件设计思路的理解 系统：Mac、Windows、Linux 系统配置的实践 后端：Redis 缓存、数据库、Graphql、SSR、模板引擎等了解和使用 基础 1、列举你所了解的计算机存储设备类型？ 现代计算机以存储器为中心，主要由 CPU、I / O 设备以及主存储器三大部分组成。各个部分之间通过总线进行连接通信，具体如下图所示： 上图是一种多总线结构的示意图，CPU、主存以及 I / O 设备之间的所有数据都是通过总线进行并行传输，使用局部总线是为了提高 CPU 的吞吐量（CPU 不需要直接跟 I / O 设备通信），而使用高速总线（更贴近 CPU）和 DMA 总线则是为了提升高速 I / O 设备（外设存储器、局域网以及多媒体等）的执行效率。\n主存包括随机存储器 RAM 和只读存储器 ROM，其中 ROM 又可以分为 MROM（一次性）、PROM、EPROM、EEPROM 。ROM 中存储的程序（例如启动程序、固化程序）和数据（例如常量数据）在断电后不会丢失。RAM 主要分为静态 RAM（SRAM） 和动态 RAM（DRAM） 两种类型（DRAM 种类很多，包括 SDRAM、RDRAM、CDRAM 等），断电后数据会丢失，主要用于存储临时程序或者临时变量数据。DRAM 一般访问速度相对较慢。由于现代 CPU 读取速度要求相对较高，因此在 CPU 内核中都会设计 L1、L2 以及 L3 级别的多级高速缓存，这些缓存基本是由 SRAM 构成，一般访问速度较快。\n2、一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？ 高级程序设计语言不能直接被计算机理解并执行，需要通过翻译程序将其转换成特定处理器上可执行的指令，计算机 CPU 的简单工作原理如下所示： CPU 主要由控制单元、运算单元和存储单元组成（注意忽略了中断系统），各自的作用如下：\n控制单元：在节拍脉冲的作用下，将程序计数器（Program Counter，PC）指向的主存或者多级高速缓存中的指令地址送到地址总线，接着获取指令地址所对应的指令并放入指令寄存器 （Instruction Register，IR）中，然后通过指令译码器（Instruction Decoder，ID）分析指令需要进行的操作，最后通过操作控制器（Operation Controller，OC）向其他设备发出微操作控制信号。 运算单元：如果控制单元发出的控制信号存在算术运算（加、减、乘、除、增 1、减 1、取反等）或者逻辑运算（与、或、非、异或），那么需要通过运算单元获取存储单元的计算数据进行处理。 存储单元：包括片内缓存和寄存器组，是 CPU 中临时数据的存储地方。CPU 直接访问主存数据大概需要花费数百个机器周期，而访问寄存器或者片内缓存只需要若干个或者几十个机器周期，因此会使用内部寄存器或缓存来存储和获取临时数据（即将被运算或者运算之后的数据），从而提高 CPU 的运行效率。 除此之外，计算机系统执行程序指令时需要花费时间，其中取出一条指令并执行这条指令的时间叫指令周期。指令周期可以分为若干个阶段（取指周期、间址周期、执行周期和中断周期），每个阶段主要完成一项基本操作，完成基本操作的时间叫机器周期。机器周期是时钟周期的分频，例如最经典的 8051 单片机的机器周期为 12 个时钟周期。时钟周期是 CPU 工作的基本时间单位，也可以称为节拍脉冲或 T 周期（CPU 主频的倒数） 。假设 CPU 的主频是 1 GHz（1 Hz 表示每秒运行 1 次），那么表示时钟周期为 1 / 109 s。理论上 CPU 的主频越高，程序指令执行的速度越快。\n3、什么是指令和指令集？ 上图右侧主存中的指令是 CPU 可以支持的处理命令，一般包含算术指令（加和减）、逻辑指令（与、或和非）、数据指令（移动、输入、删除、加载和存储）、流程控制指令以及程序结束指令等，由于 CPU 只能识别二进制码，因此指令是由二进制码组成。除此之外，指令的集合称为指令集（例如汇编语言就是指令集的一种表现形式），常见的指令集有精简指令集（ARM）和复杂指令集（Inter X86）。一般指令集决定了 CPU 处理器的硬件架构，规定了处理器的相应操作。\n4、复杂指令集和精简指令集有什么区别？ 5、JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？ 早期的计算机只有机器语言时，程序设计必须用二进制数（0 和 1）来编写程序，并且要求程序员对计算机硬件和指令集非常了解，编程的难度较大，操作极易出错。为了解决机器语言的编程问题，慢慢开始出现了符号式的汇编语言（采用 ADD、SUB、MUL、DIV 等符号代表加减乘除）。为了使得计算机可以识别汇编语言，需要将汇编语言翻译成机器能够识别的机器语言（处理器的指令集）： 由于每一种机器的指令系统不同，需要不同的汇编语言程序与之匹配，因此程序员往往需要针对不同的机器了解其硬件结构和指令系统。为了可以抹平不同机器的指令系统，使得程序员可以更加关注程序设计本身，先后出现了各种面向问题的高级程序设计语言，例如 BASIC 和 C，具体过程如下图所示： 高级程序语言会先翻译成汇编语言或者其他中间语言，然后再根据不同的机器翻译成机器语言进行执行。除此之外，汇编语言虚拟机和机器语言机器之间还存在一层操作系统虚拟机，主要用于控制和管理操作系统的全部硬件和软件资源（随着超大规模集成电路技术的不断发展，一些操作系统的软件功能逐步由硬件来替换，例如目前的操作系统已经实现了部分程序的固化，简称固件，将程序永久性的存储在 ROM 中）。机器语言机器还可以继续分解成微程序机器，将每一条机器指令翻译成一组微指令（微程序）进行执行。\n上述虚拟机所提供的语言转换程序被称为编译器，主要作用是将某种语言编写的源程序转换成一个等价的机器语言程序，编译器的作用如下图所示： 例如 C 语言，可以先通过 gcc 编译器生成 Linux 和 Windows 下的目标 .o 和 .obj 文件（object 文件，即目标文件），然后将目标文件与底层系统库文件、应用程序库文件以及启动文件链接成可执行文件在目标机器上执行。\n温馨提示：感兴趣的同学可以了解一下 ARM 芯片的程序运行原理，包括使用 IDE 进行程序的编译（IDE 内置编译器，主流编译器包含 ARMCC、IAR 以及 GCC FOR ARM 等，其中一些编译器仅仅随着 IDE 进行捆绑发布，不提供独立使用的能力，而一些编译器则随着 IDE 进行发布的同时，还提供命令行接口的独立使用方式）、通过串口进行程序下载（下载到芯片的代码区初始启动地址映射的存储空间地址）、启动的存储空间地址映射（包括系统存储器、闪存 FLASH、内置 SRAM 等）、芯片的程序启动模式引脚 BOOT 的设置（例如调试代码时常常选择内置 SRAM、真正程序运行的时候选择闪存 FLASH）等。\n如果某种高级语言或者应用语言（例如用于人工智能的计算机设计语言）转换的目标语言不是特定计算机的汇编语言，而是面向另一种高级程序语言（很多研究性的编译器将 C 作为目标语言），那么还需要将目标高级程序语言再进行一次额外的编译才能得到最终的目标程序，这种编译器可称为源到源的转换器。\n除此之外，有些程序设计语言将编译的过程和最终转换成目标程序进行执行的过程混合在一起，这种语言转换程序通常被称为解释器，主要作用是将某种语言编写的源程序作为输入，将该源程序执行的结果作为输出，解释器的作用如下图所示：\nimage.png\n解释器和编译器有很多相似之处，都需要对源程序进行分析，并转换成目标机器可识别的机器语言进行执行。只是解释器是在转换源程序的同时立马执行对应的机器语言（转换和执行的过程不分离），而编译器得先把源程序全部转换成机器语言并产生目标文件，然后将目标文件写入相应的程序存储器进行执行（转换和执行的过程分离）。例如 Perl、Scheme、APL 使用解释器进行转换， C、C++ 则使用编译器进行转换，而 Java 和 JavaScript 的转换既包含了编译过程，也包含了解释过程。\n6、简单描述一下 Babel 的编译过程？ 7、JavaScript 中的数组和函数在内存中是如何存储的？ JavaScript 中的数组存储大致需要分为两种情况：\n同种类型数据的数组分配连续的内存空间 存在非同种类型数据的数组使用哈希映射分配内存空间 温馨提示：可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）。\n8、浏览器和 Node.js 中的事件循环机制有什么区别？ 阅读链接：面试分享：两年工作经验成功面试阿里P6总结**[2]** - 了解 Event Loop 吗？\n9、ES6 Modules 相对于 CommonJS 的优势是什么？ 10、高级程序设计语言是如何编译成机器语言的？ 11、编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？ 12、编译过程中虚拟机的作用是什么？ 13、什么是中间代码（IR），它的作用是什么？ 14、什么是交叉编译？ 编译器的设计是一个非常庞大和复杂的软件系统设计，在真正设计的时候需要解决两个相对重要的问题：\n如何分析不同高级程序语言设计的源程序 如何将源程序的功能等价映射到不同指令系统的目标机器 为了解决上述两项问题，编译器的设计最终被分解成前端（注意这里所说的不是 Web 前端）和后端两个编译阶段，前端用于解决第一个问题，而后端用于解决第二个问题，具体如下图所示： 上图中的中间表示（Intermediate Representation，IR）是程序结构的一种表现方式，它会比 AST（后续讲解）更加接近汇编语言或者指令集，同时也会保留源程序中的一些高级信息，除此之外 ，它的种类很多，包括三地址码（Three Address Code, TAC）****[3]、**静态单赋值形式（Static Single Assignment Form, SSA）****[4]**以及基于栈的 IR 等，具体作用包括：\n靠近前端部分主要适配不同的源程序，靠近后端部分主要适配不同的指令集，更易于编译器的错误调试，容易识别是 IR 之前还是之后出问题 如下左图所示，如果没有 IR，那么源程序到指令集之间需要进行一一适配，而有了中间表示，则可以使得编译器的职责更加分离，源程序的编译更多关注如何转换成 IR，而不是去适配不同的指令集 IR 本身可以做到多趟迭代从而优化源程序，在每一趟迭代的过程中可以研究代码并记录优化的细节，方便后续的迭代查找并利用这些优化信息，最终可以高效输出更优的目标程序 由于 IR 可以进行多趟迭代进行程序优化，因此在编译器中可插入一个新的优化阶段，如下图所示： 优化器可以对 IR 处理一遍或者多遍，从而生成更快执行速度（例如找到循环中不变的计算并对其进行优化从而减少运算次数）或者更小体积的目标程序，也可能用于产生更少异常或者更低功耗的目标程序。除此之外，前端和后端内部还可以细分为多个处理步骤，具体如下图所示： 优化器中的每一遍优化处理都可以使用一个或多个优化技术来改进代码，每一趟处理最终都是读写 IR 的操作，这样不仅仅可以使得优化可以更加高效，同时也可以降低优化的复杂度，还提高了优化的灵活性，可以使得编译器配置不同的优化选项，达到组合优化的效果。\n15、发布 / 订阅模式和观察者模式的区别是什么？ 阅读链接：基于Vue实现一个简易MVVM**[5]** - 观察者模式和发布/订阅模式\n16、装饰器模式一般会在什么场合使用？ 17、谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？ 18、列举你所了解的编程范式？ 编程范式（Programming paradigm）是指计算机编程的基本风格或者典型模式，可以简单理解为编程学科中实践出来的具有哲学和理论依据的一些经典原型。常见的编程范式有：\n面向过程（Process Oriented Programming，POP） 面向对象（Object Oriented Programming，OOP） 面向接口（Interface Oriented Programming， IOP） 面向切面（Aspect Oriented Programming，AOP） 函数式（Funtional Programming，FP） 响应式（Reactive Programming，RP） 函数响应式（Functional Reactive Programming，FRP） 阅读链接：：如果你对于编程范式的定义相对模糊，可以继续阅读 What is the precise definition of programming paradigm?****[6] 了解更多。\n不同的语言可以支持多种不同的编程范式，例如 C 语言支持 POP 范式，C++ 和 Java 语言支持 OOP 范式，Swift 语言则可以支持 FP 范式，而 Web 前端中的 JavaScript 可以支持上述列出的所有编程范式。\n19、什么是面向切面（AOP）的编程？ 20、什么是函数式编程？ 顾名思义，函数式编程是使用函数来进行高效处理数据或数据流的一种编程方式。在数学中，函数的三要素是定义域、值域和**对应关系。假设 A、B 是非空数集，对于集合 A 中的任意一个数 x，在集合 B 中都有唯一确定的数 f(x) 和它对应，那么可以将 f 称为从 A 到 B 的一个函数，记作：y = f(x)。在函数式编程中函数的概念和数学函数的概念类似，主要是描述形参 x 和返回值 y 之间的对应关系，**如下图所示：\n温馨提示：图片来自于简明 JavaScript 函数式编程——入门篇****[7]。\n在实际的编程中，可以将各种明确对应关系的函数进行传递、组合从而达到处理数据的最终目的。在此过程中，我们的关注点不在于如何去实现**对应关系，**而在于如何将各种已有的对应关系进行高效联动，从而可快速进行数据转换，达到最终的数据处理目的，提供开发效率。\n简单示例\n尽管你对函数式编程的概念有所了解，但是你仍然不知道函数式编程到底有什么特点。这里我们仍然拿 OOP 编程范式来举例，假设希望通过 OOP 编程来解决数学的加减乘除问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MathObject { constructor(private value: number) {} public add(num: number): MathObject { this.value += num; return this; } public multiply(num: number): MathObject { this.value *= num; return this; } public getValue(): number { return this.value; } } const a = new MathObject(1); a.add(1).multiply(2).add(a.multiply(2).getValue()); 复制代码 我们希望通过上述程序来解决 (1 + 2) * 2 + 1 * 2 的问题，但实际上计算出来的结果是 24，因为在代码内部有一个 this.value 的状态值需要跟踪，这会使得结果不符合预期。接下来我们采用函数式编程的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function add(a: number, b: number): number { return a + b; } function multiply(a: number, b: number): number { return a * b; } const a: number = 1; const b: number = 2; add(multiply(add(a, b), b), multiply(a, b)); 复制代码 以上程序计算的结果是 8，完全符合预期。我们知道了 add 和 multiply 两个函数的实际对应关系，通过将对应关系进行有效的组合和传递，达到了最终的计算结果。除此之外，这两个函数还可以根据数学定律得出更优雅的组合方式：\n1 2 3 4 5 6 7 8 add(multiply(add(a, b), b), multiply(a, b)); // 根据数学定律分配律：a * b + a * c = a * (b + c)，得出： // (a + b) * b + a * b = (2a + b) * b // 简化上述函数的组合方式 multiply(add(add(a, a), b), b); 复制代码 我们完全不需要追踪类似于 OOP 编程范式中可能存在的内部状态数据，事实上对于数学定律中的结合律、交换律、同一律以及分配律，上述的函数式编程代码足可以胜任。\n原则\n通过上述简单的例子可以发现，要实现高可复用的函数**（对应关系）**，一定要遵循某些特定的原则，否则在使用的时候可能无法进行高效的传递和组合，例如\n高内聚低耦合 最小意外原则 单一职责原则 \u0026hellip; 如果你之前经常进行无原则性的代码设计，那么在设计过程中可能会出现各种出乎意料的问题（这是为什么新手老是出现一些稀奇古怪问题的主要原因）。函数式编程可以有效的通过一些原则性的约束使你设计出更加健壮和优雅的代码，并且在不断的实践过程中进行经验式叠加，从而提高开发效率。\n特点\n虽然我们在使用函数的过程中更多的不再关注函数如何实现（对应关系），但是真正在使用和设计函数的时候需要注意以下一些特点：\n声明式（Declarative Programming） 一等公民（First Class Function） 纯函数（Pure Function） 无状态和数据不可变（Statelessness and Immutable Data） \u0026hellip; 声明式\n我们以前设计的代码通常是命令式编程方式，这种编程方式往往注重具体的实现的过程（对应关系），而函数式编程则采用声明式的编程方式，往往注重如何去组合已有的**对应关系。**简单举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 命令式 const array = [0.8, 1.7, 2.5, 3.4]; const filterArray = []; for (let i = 0; i \u0026lt; array.length; i++) { const integer = Math.floor(array[i]); if (integer \u0026lt; 2) { continue; } filterArray.push(integer); } // 声明式 // map 和 filter 不会修改原有数组，而是产生新的数组返回 [0.8, 1.7, 2.5, 3.4].map((item) =\u0026gt; Math.floor(item)).filter((item) =\u0026gt; item \u0026gt; 1); 复制代码 命令式代码一步一步的告诉计算机需要执行哪些语句，需要关心变量的实例化情况、循环的具体过程以及跟踪变量状态的变化过程。声明式代码更多的不再关心代码的具体执行过程，而是采用表达式的组合变换去处理问题，不再强调怎么做，而是指明**做什么。**声明式编程方式可以将我们设计代码的关注点彻底从过程式解放出来，从而提高开发效率。\n一等公民\n在 JavaScript 中，函数的使用非常灵活，例如可以对函数进行以下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 interface IHello { (name: string): string; key?: string; arr?: number[]; fn?(name: string): string; } // 函数声明提升 console.log(hello instanceof Object); // true // 函数声明提升 // hello 和其他引用类型的对象一样，都有属性和方法 hello.key = \u0026#39;key\u0026#39;; hello.arr = [1, 2]; hello.fn = function (name: string) { return `hello.fn, ${name}`; }; // 函数声明提升 // 注意函数表达式不能在声明前执行，例如不能在这里使用 helloCopy(\u0026#39;world\u0026#39;) hello(\u0026#39;world\u0026#39;); // 函数 // 创建新的函数对象，将函数的引用指向变量 hello // hello 仅仅是变量的名称 function hello(name: string): string { return `hello, ${name}`; } console.log(hello.key); // key console.log(hello.arr); // [1,2] console.log(hello.name); // hello // 函数表达式 const helloCopy: IHello = hello; helloCopy(\u0026#39;world\u0026#39;); function transferHello(name: string, hello: Hello) { return hello(\u0026#39;world\u0026#39;); } // 把函数对象当作实参传递 transferHello(\u0026#39;world\u0026#39;, helloCopy); // 把匿名函数当作实参传递 transferHello(\u0026#39;world\u0026#39;, function (name: string) { return `hello, ${name}`; }); 复制代码 通过以上示例可以看出，函数继承至对象并拥有对象的特性。在 JavaScript 中可以对函数进行参数传递、变量赋值或数组操作等等，因此把函数称为一等公民。函数式编程的核心就是对函数进行组合或传递，JavaScript 中函数这种灵活的特性是满足函数式编程的重要条件。\n纯函数\n纯函数是是指在相同的参数调用下，函数的返回值唯一不变。这跟数学中函数的映射关系类似，同样的 x 不可能映射多个不同的 y。使用函数式编程会使得函数的调用非常稳定，从而降低 Bug 产生的机率。当然要实现纯函数的这种特性，需要函数不能包含以下一些副作用：\n操作 Http 请求 可变数据（包括在函数内部改变输入参数） DOM 操作 打印日志 访问系统状态 操作文件系统 操作数据库 \u0026hellip; 从以上常见的一些副作用可以看出，纯函数的实现需要遵循最小意外原则，为了确保函数的稳定唯一的输入和输出，尽量应该避免与函数外部的环境进行任何交互行为，从而防止外部环境对函数内部产生无法预料的影响。纯函数的实现应该自给自足，举几个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 如果使用 const 声明 min 变量（基本数据类型），则可以保证以下函数的纯粹性 let min: number = 1; // 非纯函数 // 依赖外部环境变量 min，一旦 min 发生变化则输入和返回不唯一 function isEqual(num: number): boolean { return num === min; } // 纯函数 function isEqual(num: number): boolean { return num === 1; } // 非纯函数 function request\u0026lt;T, S\u0026gt;(url: string, params: T): Promise\u0026lt;S\u0026gt; { // 会产生请求成功和请求失败两种结果，返回的结果可能不唯一 return $.getJson(url, params); } // 纯函数 function request\u0026lt;T, S\u0026gt;(url: string, params: T) : () =\u0026gt; Promise\u0026lt;S\u0026gt; { return function() { return $.getJson(url, params); } } 复制代码 纯函数的特性使得函数式编程具备以下特性：\n可缓存性（Cacheable） 可移植性（Portable） 可测试性（Testable） 可缓存性和可测试性基于纯函数输入输出唯一不变的特性，可移植性则主要基于纯函数不依赖外部环境的特性。这里举一个可缓存的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 interface ICache\u0026lt;T\u0026gt; { [arg: string]: T; } interface ISquare\u0026lt;T\u0026gt; { (x: T): T; } // 简单的缓存函数（忽略通用性和健壮性） function memoize\u0026lt;T\u0026gt;(fn: ISquare\u0026lt;T\u0026gt;): ISquare\u0026lt;T\u0026gt; { const cache: ICache\u0026lt;T\u0026gt; = {}; return function (x: T) { const arg: string = JSON.stringify(x); cache[arg] = cache[arg] || fn.call(fn, x); return cache[arg]; }; } // 纯函数 function square(x: number): number { return x * x; } const memoSquare = memoize\u0026lt;number\u0026gt;(square); memoSquare(4); // 不会再次调用纯函数 square，而是直接从缓存中获取值 // 由于输入和输出的唯一性，获取缓存结果可靠稳定 // 提升代码的运行效率 memoSquare(4); 复制代码 无状态和数据不可变\n在函数式编程的简单示例中已经可以清晰的感受到函数式编程绝对不能依赖内部状态，而在纯函数中则说明了函数式编程不能依赖外部的环境或状态，因为一旦依赖的状态变化，不能保证函数根据对应关系所计算的返回值因为状态的变化仍然保持不变。\n这里单独讲解一下数据不可变，在 JavaScript 中有很多数组操作的方法，举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 const arr = [1, 2, 3]; console.log(arr.slice(0, 2)); // [1, 2] console.log(arr); // [1, 2, 3] console.log(arr.slice(0, 2)); // [1, 2] console.log(arr); // [1, 2, 3] console.log(arr.splice(0, 1)); // [1] console.log(arr); // [2, 3] console.log(arr.splice(0, 1)); // [2] console.log(arr); // [3] 复制代码 这里的 slice 方法多次调用都不会改变原有数组，且会产生相同的输出。而 splice 每次调用都在修改原数组，且产生的输出也不相同。在函数式编程中，这种会改变原有数据的函数已经不再是纯函数，应该尽量避免使用。\n阅读链接：如果想要了解更深入的函数式编程知识点，可以额外阅读函数式编程指北****[8]。\n21、响应式编程的使用场景有哪些？ 响应式编程是一种基于观察者（发布 / 订阅）模式并且面向异步（Asynchronous）数据流（Data Stream）和变化传播的声明式编程范式。响应式编程主要适用的场景包含：\n用户和系统发起的连续事件处理，例如鼠标的点击、键盘的按键或者通信设备发起的信号等 非可靠的网络或者通信处理（例如 HTTP 网络的请求重试） 连续的异步 IO 处理 复杂的继发事务处理（例如一次事件涉及到多个继发的网络请求） 高并发的消息处理（例如 IM 聊天） \u0026hellip; 语法 22、如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应? 23、如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip? 24、如何让 CSS 元素左侧自动溢出（\u0026hellip; 溢出在左侧）？ The direction CSS property sets the direction of text, table columns, and horizontal overflow. Use rtl for languages written from right to left (like Hebrew or Arabic), and ltr for those written from left to right (like English and most other languages).\n具体查看：developer.mozilla.org/en-US/docs/…****[9]\n25、什么是沙箱？浏览器的沙箱有什么作用？ 26、如何处理浏览器中表单项的密码自动填充问题？ 27、Hash 和 History 路由的区别和优缺点？ 28、JavaScript 中对象的属性描述符有哪些？分别有什么作用？ 29、JavaScript 中 console 有哪些 api ? The console object provides access to the browser\u0026rsquo;s debugging console (e.g. the Web console**[10]** in Firefox). The specifics of how it works varies from browser to browser, but there is a de facto set of features that are typically provided.\n这里列出一些我常用的 API:\nconsole.log console.error console.time console.timeEnd console.group 具体查看：developer.mozilla.org/en-US/docs/…****[11]\n30、 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？ 在 JavaScript 中利用事件循环机制****[12]（Event Loop）可以在单线程中实现非阻塞式、异步的操作。例如\nNode.js 中的 Callback、EventEmitter**[13]、Stream**[14] ES6 中的 Promise**[15]、Generator**[16] ES2017 中的 Async**[17]** 三方库 RxJS、Q**[18]** 、Co、****[19]Bluebird[20] 我们重点来看一下常用的几种编程方式（Callback、Promise、Generator、Async）在语法糖上带来的优劣对比。\nCallback\nCallback（回调函数）是在 Web 前端开发中经常会使用的编程方式。这里举一个常用的定时器示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 export interface IObj { value: string; deferExec(): void; deferExecAnonymous(): void; console(): void; } export const obj: IObj = { value: \u0026#39;hello\u0026#39;, deferExecBind() { // 使用箭头函数可达到一样的效果 setTimeout(this.console.bind(this), 1000); }, deferExec() { setTimeout(this.console, 1000); }, console() { console.log(this.value); }, }; obj.deferExecBind(); // hello obj.deferExec(); // undefined 复制代码 回调函数经常会因为调用环境的变化而导致 this 的指向性变化。除此之外，使用回调函数来处理多个继发的异步任务时容易导致回调地狱（Callback Hell）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fs.readFile(fileA, \u0026#39;utf-8\u0026#39;, function (err, data) { fs.readFile(fileB, \u0026#39;utf-8\u0026#39;, function (err, data) { fs.readFile(fileC, \u0026#39;utf-8\u0026#39;, function (err, data) { fs.readFile(fileD, \u0026#39;utf-8\u0026#39;, function (err, data) { // 假设在业务中 fileD 的读写依次依赖 fileA、fileB 和 fileC // 或者经常也可以在业务中看到多个 HTTP 请求的操作有前后依赖（继发 HTTP 请求） // 这些异步任务之间纵向嵌套强耦合，无法进行横向复用 // 如果某个异步发生变化，那它的所有上层或下层回调可能都需要跟着变化（比如 fileA 和 fileB 的依赖关系倒置） // 因此称这种现象为 回调地狱 // .... }); }); }); }); 复制代码 回调函数不能通过 return 返回数据，比如我们希望调用带有回调参数的函数并返回异步执行的结果时，只能通过再次回调的方式进行参数传递：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 希望延迟 3s 后执行并拿到结果 function getAsyncResult(result: number) { setTimeout(() =\u0026gt; { return result * 3; }, 1000); } // 尽管这是常规的编程思维方式 const result = getAsyncResult(3000); // 但是打印 undefined console.log(\u0026#39;result: \u0026#39;, result); function getAsyncResultWithCb(result: number, cb: (result: number) =\u0026gt; void) { setTimeout(() =\u0026gt; { cb(result * 3); }, 1000); } // 通过回调的形式获取结果 getAsyncResultWithCb(3000, (result) =\u0026gt; { console.log(\u0026#39;result: \u0026#39;, result); // 9000 }); 复制代码 对于 JavaScript 中标准的异步 API 可能无法通过在外部进行 try...catch... 的方式进行错误捕获：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try { setTimeout(() =\u0026gt; { // 下述是异常代码 // 你可以在回调函数的内部进行 try...catch... console.log(a.b.c) }, 1000) } catch(err) { // 这里不会执行 // 进程会被终止 console.error(err) } 复制代码 上述示例讲述的都是 JavaScript 中标准的异步 API ，如果使用一些三方的异步 API 并且提供了回调能力时，这些 API 可能是非受信的，在真正使用的时候会因为执行反转（回调函数的执行权在三方库中）导致以下一些问题：\n使用者的回调函数设计没有进行错误捕获，而恰恰三方库进行了错误捕获却没有抛出错误处理信息，此时使用者很难感知到自己设计的回调函数是否有错误 使用者难以感知到三方库的回调时机和回调次数，这个回调函数执行的权利控制在三方库手中 使用者无法更改三方库提供的回调参数，回调参数可能无法满足使用者的诉求 \u0026hellip; 举个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 interface ILib\u0026lt;T\u0026gt; { params: T; emit(params: T): void; on(callback: (params: T) =\u0026gt; void): void; } // 假设以下是一个三方库，并发布成了npm 包 export const lib: ILib\u0026lt;string\u0026gt; = { params: \u0026#39;\u0026#39;, emit(params) { this.params = params; }, on(callback) { try { // callback 回调执行权在 lib 上 // lib 库可以决定回调执行多次 callback(this.params); callback(this.params); callback(this.params); // lib 库甚至可以决定回调延迟执行 // 异步执行回调函数 setTimeout(() =\u0026gt; { callback(this.params); }, 3000); } catch (err) { // 假设 lib 库的捕获没有抛出任何异常信息 } }, }; // 开发者引入 lib 库开始使用 lib.emit(\u0026#39;hello\u0026#39;); lib.on((value) =\u0026gt; { // 使用者希望 on 里的回调只执行一次 // 这里的回调函数的执行时机是由三方库 lib 决定 // 实际上打印四次，并且其中一次是异步执行 console.log(value); }); lib.on((value) =\u0026gt; { // 下述是异常代码 // 但是执行下述代码不会抛出任何异常信息 // 开发者无法感知自己的代码设计错误 console.log(value.a.b.c) }); 复制代码 Promise\nCallback 的异步操作形式除了会造成回调地狱，还会造成难以测试的问题。ES6 中的 Promise （基于 Promise A +****[21] 规范的异步编程解决方案）利用**有限状态机****[22]**的原理来解决异步的处理问题，Promise 对象提供了统一的异步编程 API，它的特点如下：\nPromise 对象的执行状态不受外界影响。Promise 对象的异步操作有三种状态： pending（进行中）、 fulfilled（已成功）和 rejected（已失败） ，只有 Promise 对象本身的异步操作结果可以决定当前的执行状态，任何其他的操作无法改变状态的结果 Promise 对象的执行状态不可变。Promise 的状态只有两种变化可能：从 pending（进行中）变为 fulfilled（已成功）或从 pending（进行中）变为 rejected（已失败） 温馨提示：有限状态机提供了一种优雅的解决方式，异步的处理本身可以通过异步状态的变化来触发相应的操作，这会比回调函数在逻辑上的处理更加合理，也可以降低代码的复杂度。\nPromise 对象的执行状态不可变示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const promise = new Promise\u0026lt;number\u0026gt;((resolve, reject) =\u0026gt; { // 状态变更为 fulfilled 并返回结果 1 后不会再变更状态 resolve(1); // 不会变更状态 reject(4); }); promise .then((result) =\u0026gt; { // 在 ES 6 中 Promise 的 then 回调执行是异步执行（微任务） // 在当前 then 被调用的那轮事件循环（Event Loop）的末尾执行 console.log(\u0026#39;result: \u0026#39;, result); }) .catch((error) =\u0026gt; { // 不执行 console.error(\u0026#39;error: \u0026#39;, error); }); 复制代码 假设要实现两个继发的 HTTP 请求，第一个请求接口返回的数据是第二个请求接口的参数，使用回调函数的实现方式如下所示（这里使用 setTimeout 来指代异步请求）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 回调地狱 const doubble = (result: number, callback: (finallResult: number) =\u0026gt; void) =\u0026gt; { // Mock 第一个异步请求 setTimeout(() =\u0026gt; { // Mock 第二个异步请求（假设第二个请求的参数依赖第一个请求的返回结果） setTimeout(() =\u0026gt; { callback(result * 2); }, 2000); }, 1000); }; doubble(1000, (result) =\u0026gt; { console.log(\u0026#39;result: \u0026#39;, result); }); 复制代码 温馨提示：继发请求的依赖关系非常常见，例如人员基本信息管理系统的开发中，经常需要先展示组织树结构，并默认加载第一个组织下的人员列表信息。\n如果采用 Promise 的处理方式则可以规避上述常见的回调地狱问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 // 将 resolve 改成 reject 会被 catch 捕获 setTimeout(() =\u0026gt; resolve(result), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 // 将 resolve 改成 reject 会被 catch 捕获 setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u0026gt; { return nextPromise(result); }) .then((result) =\u0026gt; { // 2s 后打印 2000 console.log(\u0026#39;result: \u0026#39;, result); }) // 任何一个 Promise 到达 rejected 状态都能被 catch 捕获 .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); }); 复制代码 Promise 的错误回调可以同时捕获 firstPromise 和 nextPromise 两个函数的 rejected 状态。接下来考虑以下调用场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 setTimeout(() =\u0026gt; resolve(result), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u0026gt; { nextPromise(result).then((result) =\u0026gt; { // 后打印 console.log(\u0026#39;nextPromise result: \u0026#39;, result); }); }) .then((result) =\u0026gt; { // 先打印 // 由于上一个 then 没有返回值，这里打印 undefined console.log(\u0026#39;firstPromise result: \u0026#39;, result); }) .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); }); 复制代码 首先 Promise 可以注册多个 then（放在一个执行队列里），并且这些 then 会根据上一次返回值的结果依次执行。除此之外，各个 Promise 的 then 执行互不干扰。我们将示例进行简单的变换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 setTimeout(() =\u0026gt; resolve(result), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Mock 异步请求 setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u0026gt; { // 返回了 nextPromise 的 then 执行后的结果 return nextPromise(result).then((result) =\u0026gt; { return result; }); }) // 接着 nextPromise 的 then 执行的返回结果继续执行 .then((result) =\u0026gt; { // 2s 后打印 2000 console.log(\u0026#39;nextPromise result: \u0026#39;, result); }) .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); }); 复制代码 上述例子中的执行结果是因为 then 的执行会返回一个新的 Promise 对象，并且如果 then 执行后返回的仍然是 Promise 对象，那么下一个 then 的链式调用会等待该 Promise 对象的状态发生变化后才会调用（能得到这个 Promise 处理的结果）。接下来重点看下 Promise 的错误处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const promise = new Promise\u0026lt;string\u0026gt;((resolve, reject) =\u0026gt; { // 下述是异常代码 console.log(a.b.c); resolve(\u0026#39;hello\u0026#39;); }); promise .then((result) =\u0026gt; { console.log(\u0026#39;result: \u0026#39;, result); }) // 去掉 catch 仍然会抛出错误，但不会退出进程终止脚本执行 .catch((err) =\u0026gt; { // 执行 // ReferenceError: a is not defined console.error(err); }); setTimeout(() =\u0026gt; { // 继续执行 console.log(\u0026#39;hello world!\u0026#39;); }, 2000); 复制代码 从上述示例可以看出 Promise 的错误不会影响其他代码的执行，只会影响 Promise 内部的代码本身，因为Promise 会在内部对错误进行异常捕获，从而保证整体代码执行的稳定性。Promise 还提供了其他的一些 API 方便多任务的执行，包括\nPromise.all：适合多个异步任务并发执行但不允许其中任何一个任务失败 Promise.race ：适合多个异步任务抢占式执行 Promise.allSettled ：适合多个异步任务并发执行但允许某些任务失败 Promise 相对于 Callback 对于异步的处理更加优雅，并且能力也更加强大， 但是也存在一些自身的缺点：\n无法取消 Promise 的执行 无法在 Promise 外部通过 try...catch... 的形式进行错误捕获（Promise 内部捕获了错误） 状态单一，每次决断只能产生一种状态结果，需要不停的进行链式调用 温馨提示：手写 Promise 是面试官非常喜欢的一道笔试题，本质是希望面试者能够通过底层的设计正确了解 Promise 的使用方式，如果你对 Promise 的设计原理不熟悉，可以深入了解一下或者手动设计一个。\nGenerator\nPromise 解决了 Callback 的回调地狱问题，但也造成了代码冗余，如果一些异步任务不支持 Promise 语法，就需要进行一层 Promise 封装。Generator 将 JavaScript 的异步编程带入了一个全新的阶段，它使得异步代码的设计和执行看起来和同步代码一致。Generator 使用的简单示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; // 在 Generator 函数里执行的异步代码看起来和同步代码一致 function* gen(result: number): Generator\u0026lt;Promise\u0026lt;number\u0026gt;, Promise\u0026lt;number\u0026gt;, number\u0026gt; { // 异步代码 const firstResult = yield firstPromise(result) console.log(\u0026#39;firstResult: \u0026#39;, firstResult) // 2 // 异步代码 const nextResult = yield nextPromise(firstResult) console.log(\u0026#39;nextResult: \u0026#39;, nextResult) // 6 return nextPromise(firstResult) } const g = gen(1) // 手动执行 Generator 函数 g.next().value.then((res: number) =\u0026gt; { // 将 firstPromise 的返回值传递给第一个 yield 表单式对应的 firstResult return g.next(res).value }).then((res: number) =\u0026gt; { // 将 nextPromise 的返回值传递给第二个 yield 表单式对应的 nextResult return g.next(res).value }) 复制代码 通过上述代码，可以看出 Generator 相对于 Promise 具有以下优势：\n丰富了状态类型，Generator 通过 next 可以产生不同的状态信息，也可以通过 return 结束函数的执行状态，相对于 Promise 的 resolve 不可变状态更加丰富 Generator 函数内部的异步代码执行看起来和同步代码执行一致，非常利于代码的维护 Generator 函数内部的执行逻辑和相应的状态变化逻辑解耦，降低了代码的复杂度 next 可以不停的改变状态使得 yield 得以继续执行的代码可以变得非常有规律，例如从上述的手动执行 Generator 函数可以看出，完全可以将其封装成一个自动执行的执行器，具体如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; type Gen = Generator\u0026lt;Promise\u0026lt;number\u0026gt;, Promise\u0026lt;number\u0026gt;, number\u0026gt; function* gen(): Gen { const firstResult = yield firstPromise(1) console.log(\u0026#39;firstResult: \u0026#39;, firstResult) // 2 const nextResult = yield nextPromise(firstResult) console.log(\u0026#39;nextResult: \u0026#39;, nextResult) // 6 return nextPromise(firstResult) } // Generator 自动执行器 function co(gen: () =\u0026gt; Gen) { const g = gen() function next(data: number) { const result = g.next(data) if(result.done) { return result.value } result.value.then(data =\u0026gt; { // 通过递归的方式处理相同的逻辑 next(data) }) } // 第一次调用 next 主要用于启动 Generator 函数 // 内部指针会从函数头部开始执行，直到遇到第一个 yield 表达式 // 因此第一次 next 传递的参数没有任何含义（这里传递只是为了防止 TS 报错） next(0) } co(gen) 复制代码 温馨提示：TJ Holowaychuk**[23]** 设计了一个 Generator 自动执行器 Co**[24]，使用 Co 的前提是 yield 命令后必须是 Promise 对象或者 Thunk 函数。Co 还可以支持并发的异步处理，具体可查看官方的 API 文档**[25]。\n需要注意的是 Generator 函数的返回值是一个 Iterator 遍历器对象，具体如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; type Gen = Generator\u0026lt;Promise\u0026lt;number\u0026gt;\u0026gt;; function* gen(): Gen { yield firstPromise(1); yield nextPromise(2); } // 注意使用 next 是继发执行，而这里是并发执行 Promise.all([...gen()]).then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); }); for (const promise of gen()) { promise.then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); }); } 复制代码 Generator 函数的错误处理相对复杂一些，极端情况下需要对执行和 Generator 函数进行双重错误捕获，具体如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // 需要注意这里的reject 没有被捕获 setTimeout(() =\u0026gt; reject(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; type Gen = Generator\u0026lt;Promise\u0026lt;number\u0026gt;\u0026gt;; function* gen(): Gen { try { yield firstPromise(1); yield nextPromise(2); } catch (err) { console.error(\u0026#39;Generator 函数错误捕获: \u0026#39;, err); } } try { const g = gen(); g.next(); // 返回 Promise 后还需要通过 Promise.prototype.catch 进行错误捕获 g.next(); // Generator 函数错误捕获 g.throw(\u0026#39;err\u0026#39;); // 执行器错误捕获 g.throw(\u0026#39;err\u0026#39;); } catch (err) { console.error(\u0026#39;执行错误捕获: \u0026#39;, err); } 复制代码 在使用 g.throw 的时候还需要注意以下一些事项：\n如果 Generator 函数本身没有捕获错误，那么 Generator 函数内部抛出的错误可以在执行处进行错误捕获 如果 Generator 函数内部和执行处都没有进行错误捕获，则终止进程并抛出错误信息 如果没有执行过 g.next，则 g.throw 不会在 Gererator 函数中被捕获（因为执行指针没有启动 Generator 函数的执行），此时可以在执行处进行执行错误捕获 Async\nAsync 是 Generator 函数的语法糖，相对于 Generator 而言 Async 的特性如下：\n内置执行器：Generator 函数需要设计手动执行器或者通用执行器（例如 Co 执行器）进行执行，Async 语法则内置了自动执行器，设计代码时无须关心执行步骤 yield 命令无约束：在 Generator 中使用 Co 执行器时 yield 后必须是 Promise 对象或者 Thunk 函数，而 Async 语法中的 await 后可以是 Promise 对象或者原始数据类型对象、数字、字符串、布尔值等（此时会对其进行 Promise.resolve() 包装处理） 返回 Promise： async 函数的返回值是 Promise 对象（返回原始数据类型会被 Promise 进行封装）， 因此还可以作为 await 的命令参数，相对于 Generator 返回 Iterator 遍历器更加简洁实用 举个简单的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { const firstResult = await firstPromise(1); // 1s 后打印 2 console.log(\u0026#39;firstResult: \u0026#39;, firstResult); // 等待 firstPromise 的状态发生变化后执行 const nextResult = await nextPromise(firstResult); // 2s 后打印 6 console.log(\u0026#39;nextResult: \u0026#39;, nextResult); return nextResult; } co(); co().then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); // 6 }); 复制代码 通过上述示例可以看出，async 函数的特性如下：\n调用 async 函数后返回的是一个 Promise 对象，通过 then 回调可以拿到 async 函数内部 return 语句的返回值 调用 async 函数后返回的 Promise 对象必须等待内部所有 await 对应的 Promise 执行完（这使得 async 函数可能是阻塞式执行）后才会发生状态变化，除非中途遇到了 return 语句 await 命令后如果是 Promise 对象，则返回 Promise 对象处理后的结果，如果是原始数据类型，则直接返回原始数据类型 上述代码是阻塞式执行，nextPromise 需要等待 firstPromise 执行完成后才能继续执行，如果希望两者能够并发执行，则可以进行下述设计：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { return await Promise.all([firstPromise(1), nextPromise(1)]); } co().then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); // [2,3] }); 复制代码 除了使用 Promise 自带的并发执行 API，也可以通过让所有的 Promise 提前并发执行来处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;firstPromise\u0026#39;); setTimeout(() =\u0026gt; resolve(result * 2), 10000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { console.log(\u0026#39;nextPromise\u0026#39;); setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { // 执行 firstPromise const first = firstPromise(1); // 和 firstPromise 同时执行 nextPromise const next = nextPromise(1); // 等待 firstPromise 结果回来 const firstResult = await first; console.log(\u0026#39;firstResult: \u0026#39;, firstResult); // 等待 nextPromise 结果回来 const nextResult = await next; console.log(\u0026#39;nextResult: \u0026#39;, nextResult); return nextResult; } co().then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); // 3 }); 复制代码 Async 的错误处理相对于 Generator 会更加简单，具体示例如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Promise 决断错误 setTimeout(() =\u0026gt; reject(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { const firstResult = await firstPromise(1); console.log(\u0026#39;firstResult: \u0026#39;, firstResult); const nextResult = await nextPromise(1); console.log(\u0026#39;nextResult: \u0026#39;, nextResult); return nextResult; } co() .then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); }) .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); // err: 2 }); 复制代码 async 函数内部抛出的错误，会导致函数返回的 Promise 对象变为 rejected 状态，从而可以通过 catch 捕获， 上述代码只是一个粗粒度的容错处理，如果希望 firstPromise 错误后可以继续执行 nextPromise，则可以通过 try...catch... 在 async 函数里进行局部错误捕获：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 const firstPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { // Promise 决断错误 setTimeout(() =\u0026gt; reject(result * 2), 1000); }); }; const nextPromise = (result: number): Promise\u0026lt;number\u0026gt; =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; resolve(result * 3), 1000); }); }; async function co() { try { await firstPromise(1); } catch (err) { console.error(\u0026#39;err: \u0026#39;, err); // err: 2 } // nextPromise 继续执行 const nextResult = await nextPromise(1); return nextResult; } co() .then((res) =\u0026gt; { console.log(\u0026#39;res: \u0026#39;, res); // res: 3 }) .catch((err) =\u0026gt; { console.error(\u0026#39;err: \u0026#39;, err); }); 复制代码 温馨提示：Callback 是 Node.js 中经常使用的编程方式，Node.js 中很多原生的 API 都是采用 Callback 的形式进行异步设计，早期的 Node.js 经常会有 Callback 和 Promise 混用的情况，并且在很长一段时间里都没有很好的支持 Async 语法。如果你对 Node.js 和它的替代品 Deno 感兴趣，可以观看 Ryan Dahl 在 TS Conf 2019 中的经典演讲 Deno is a New Way to JavaScript**[26]**。\n31、 Object.defineProperty 有哪几个参数？各自都有什么作用？ 32、 Object.defineProperty 和 ES6 的 Proxy 有什么区别？ 33、 ES6 中 Symbol、Map、Decorator 的使用场景有哪些？或者你在哪些库的源码里见过这些 API 的使用？ 34、 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？ 35、 TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？ 36、 TypeScript 中 any 类型的作用是什么？ 37、 TypeScript 中 any、never、unknown 和 void 有什么区别？ 38、 TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？ 39、 TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？ 40、 TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？ 41、 TypeScript 中使用 Unions 时有哪些注意事项？ 42、 TypeScript 如何设计 Class 的声明？ 43、 TypeScript 中如何联合枚举类型的 Key? 44、 TypeScript 中 ?.、??、!.、_、** 等符号的含义？ 45、 TypeScript 中预定义的有条件类型有哪些？ 46、 简单介绍一下 TypeScript 模块的加载机制？ 47、 简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？ 48、 TypeScript 中对象展开会有什么副作用吗？ 49、 TypeScript 中 interface、type、enum 声明有作用域的功能吗？ 50、 TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？ 51、 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？ 52、 TypeScript 的 tsconfig.json 中有哪些配置项信息？ 53、 TypeScript 中如何设置模块导入的路径别名？ 框架 54、 React Class 组件有哪些周期函数？分别有什么作用？ 55、 React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？ 56、 React Class 组件和 React Hook 的区别有哪些？ 57、 React 中高阶函数和自定义 Hook 的优缺点？ 58、 简要说明 React Hook 中 useState 和 useEffect 的运行原理？ 59、 React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？ 60、 React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？ 61、 React 的 useEffect 是如何监听数组依赖项的变化的？ 62、 React Hook 和闭包有什么关联关系？ 63、 React 中 useState 是如何做数据初始化的？ 64、 列举你常用的 React 性能优化技巧？ 65、 Vue 2.x 模板中的指令是如何解析实现的？ 66、 简要说明 Vue 2.x 的全链路运作机制？ 67、 简单介绍一下 Element UI 的框架设计？ 68、 如何理解 Vue 是一个渐进式框架？ 69、 Vue 里实现跨组件通信的方式有哪些？ 70、 Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？ 71、 MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、 72、 什么是 MVVM 框架？ 工程 73、Vue CLI 3.x 有哪些功能？Vue CLI 3.x 的插件系统了解？ 74、Vue CLI 3.x 中的 Webpack 是如何组装处理的？ 75、Vue 2.x 如何支持 TypeScript 语法？ 76、如何配置环境使得 JavaScript 项目可以支持 TypeScript 语法？ 77、如何对 TypeScript 进行 Lint 校验？ESLint 和 TSLint 有什么区别？ 78、Node.js 如何支持 TypeScript 语法？ 79、TypeScript 如何自动生成库包的声明文件？ 80、Babel 对于 TypeScript 的支持有哪些限制？ 81、Webpack 中 Loader 和 Plugin 的区别是什么？ 82、在 Webpack 中是如何做到支持类似于 JSX 语法的 Sourcemap 定位？ 83、发布 Npm 包如何指定引入地址？ 84、如何发布开发项目的特定文件夹为 Npm 包的根目录？ 85、如何发布一个支持 Tree Shaking 机制的 Npm 包？ 86、Npm 包中 peerDependencies 的作用是什么？ 87、如何优雅的调试需要发布的 Npm 包？ 88、在设计一些库包时如何生成版本日志？ 89、了解 Git （Submodule）子模块吗？简单介绍一下 Git 子模块的作用？ 90、Git 如何修改已经提交的 Commit 信息？ 91、Git 如何撤销 Commit 并保存之前的修改？ 92、Git 如何 ignore 被 commit 过的文件？ 93、在使用 Git 的时候如何规范 Git 的提交说明（Commit 信息）？ 94、简述符合 Angular 规范的提交说明的结构组成？ 95、Commit 信息如何和 Github Issues 关联？ 96、Git Hook 在项目中哪些作用？ 97、Git Hook 中客户端和服务端钩子各自用于什么作用？ 98、Git Hook 中常用的钩子有哪些？ 99、pre-commit 和 commit-msg 钩子的区别是什么？各自可用于做什么？ 100、husky 以及 ghook 等工具制作 Git Hook 的原理是什么？ 101、如何设计一个通用的 Git Hook ？ 102、Git Hook 可以采用 Node 脚本进行设计吗？如何做到？ 103、如何确保别人上传的代码没有 Lint 错误？如何确保代码构建没有 Lint 错误？ 104、如何在 Vs Code 中进行 Lint 校验提示？如何在 Vs Code 中进行 Lint 保存格式化？ 105、ESLint 和 Prettier 的区别是什么？两者在一起工作时会产生问题吗？ 106、如何有效的识别 ESLint 和 Prettier 可能产生冲突的格式规则？如何解决此类规则冲突问题？ 107、在通常的脚手架项目中进行热更新（hot module replacement）时如何做到 ESLint 实时打印校验错误信息？ 108、谈谈你对 SourceMap 的了解？ 109、如何调试 Node.js 代码？如何调试 Node.js TypeScript 代码？在浏览器中如何调试 Node.js 代码？ 110、列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？ 111、VS Code 配置中的用户和工作区有什么区别？ 112、VS Code 的插件可以只对当前项目生效吗？ 113、你所知道的测试有哪些测试类型？ 114、你所知道的测试框架有哪些？ 115、什么是 e2e 测试？有哪些 e2e 的测试框架？ 116、假设现在有一个插入排序算法，如何对该算法进行单元测试？ 网络 117、CDN 服务如何实现网络加速？ 118、WebSocket 使用的是 TCP 还是 UDP 协议？ 119、什么是单工、半双工和全双工通信？ 120、简单描述 HTTP 协议发送一个带域名的 URL 请求的协议传输过程？（DNS、TCP、IP、链路） 121、什么是正向代理？什么是反向代理？ 122、Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？ 123、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？ 124、设置 Cookie 时候如何防止 XSS 攻击？ 125、简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？ 126、HTTP 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？ 127、传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？ 128、什么是代理？什么是网关？代理和网关的作用是什么？ 129、HTTPS 相比 HTTP 为什么更加安全可靠？ 130、什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？ 131、你觉得 HTTP 协议目前存在哪些缺点？ 性能 133、在 React 中如何识别一个表单项里的表单做到了最小粒度 / 代价的渲染？ 134、在 React 的开发的过程中你能想到哪些控制渲染成本的方法？ 插件 135、Vue CLI 3.x 的插件系统是如何设计的？ 136、Webpack 中的插件机制是如何设计的？ 系统 137、\\r\\n（CRLF） 和 \\n （LF）的区别是什么？(Vs Code 的右下角可以切换) 138、/dev/null 的作用是啥？ 139、如何在 Mac 的终端中设置一个命令的别名？ 140、如何在 Windows 中设置环境变量？ 141、Mac 的文件操作系统默认区分文件路径的大小写吗？ 142、编写 Shell 脚本时如何设置文件的绝对路径？ 后端 143、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？ 144、如何部署 Node.js 应用？如何处理负载均衡中 Session 的一致性问题？ 145、如何提升 Node.js 代码的运行稳定性？ 146、GraphQL 与 Restful 的区别，它有什么优点？ 147、Vue SSR 的工作原理？Vuex 的数据如何同构渲染？ 148、SSR 技术和 SPA 技术的各自的优缺点是什么？ 149、如何处理 Node.js 渲染 HTML 压力过大问题？ 业务思考 业务思考更多的是结合基础知识的广度和深度进行的具体业务实践，主要包含以下几个方面：\n工程化：代码部署、CI / CD 流程设计、Jenkins、Gitlab、Docker 等 通用性：脚手架、SDK、组件库等框架设计 应用框架：Hybrid 混合、微前端、BFF、Monorepo 可视化： 低代码：通用表单设计、通用布局设计、通用页面设计、JSON Schema 协议设计等 测试：E2E 测试、单元测试、测试覆盖率、测试报告等 业务：数据、体验、复杂度、监控 工程化 150、你所知道的 CI / CD 工具有哪些？在项目中有接触过类似的流程吗？ 151、如果让你实现一个 Web 前端的 CI / CD 工程研发平台，你会如何设计？ 152、如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？ 153、如何使用 Vue CLI 3.x 定制一个脚手架？比如内部自动集成了 i18n、 axios、Element UI、路由守卫等？ 154、Jenkins 如何配合 Node.js 脚本进行 CI / CD 设计？ 通用性 155、如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？ 156、如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？ 157、假设你自己实现的 React 或 Vue 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？ 158、在设计工具库包的时候你是如何设计 API 文档的？ 应用框架 159、谈谈 Electron、Nw.js、CEF、Flutter 和原生开发的理解？ 160、谈谈桌面端应用中 HotFix 的理解？ 161、你觉得什么样的场景需要使用微前端框架？ 业务 162、什么是单点登录？如何做单点登录？ 163、如何做一个项目的国际化方案？ 164、如何做一个项目的监控和埋点方案？ 165、如何建设项目的稳定性（监控、灰度、错误降级、回滚\u0026hellip;）？ 166、一般管理后台型的应用需要考虑哪些性能方面的优化？ 167、简述一些提升项目体验的案例和技术方案（骨架屏、Loading 处理、缓存、错误降级、请求重试\u0026hellip;）？ 168、假设需要对页面设计一个水印方案，你会如何设计？ 低代码 169、如何设计一个通用的 JSON Schema 协议使其可以动态渲染一个通用的联动表单？ 170、一般的低代码平台需要具备哪些能力？ 笔试实践 笔试更多的是考验应聘者的逻辑思维能力和代码书写风格，主要包含以下几个方面：\n正则表达式 算法 数据结构 设计模式 框架的部分原理实现 TypeScript 语法 模板解析 数据结构 171、使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 扁平数据 [{ name: \u0026#39;文本1\u0026#39;, parent: null, id: 1, }, { name: \u0026#39;文本2\u0026#39;, id: 2, parent: 1 }, { name: \u0026#39;文本3\u0026#39;, parent: 2, id: 3, }] // 树状数据 [{ name: \u0026#39;文本1\u0026#39;, id: 1, children: [{ name: \u0026#39;文本2\u0026#39;, id: 2, children: [{ name: \u0026#39;文本3\u0026#39;, id: 3 }] }] }] 复制代码 模板解析 172、实现一个简易的模板引擎 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const template = \u0026#39;嗨，{{ info.name.value }}您好，今天是星期 {{ day.value }}\u0026#39;; const data = { info: { name: { value: \u0026#39;张三\u0026#39; } }, day: { value: \u0026#39;三\u0026#39; } }; render(template, data); // 嗨，张三您好，今天是星期三 复制代码 设计模式 173、简单实现一个发布 / 订阅模式 正则表达式 174、匹配出字符串中 const a = require(\u0026lsquo;xxx\u0026rsquo;) 中的 xxx ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%92%89%E9%92%89%E9%9D%A2%E8%AF%95/","summary":"基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECM","title":"钉钉面试"},{"content":"前言 类与实例：\n类的声明\n生成实例\n类与继承：\n如何实现继承：继承的本质就是原型链\n继承的几种方式\n类的定义、实例化 类的定义/类的声明 方式一：用构造函数模拟类（传统写法）\n1 2 3 function Animal1() { this.name = \u0026#39;smyhvae\u0026#39;; //通过this，表明这是一个构造函数 } 方式二：用 class 声明（ES6的写法）\n1 2 3 4 5 class Animal2 { constructor() { //可以在构造函数里写属性 this.name = name; } } 控制台的效果：\n实例化 类的实例化很简单，直接 new 出来即可。\n1 console.log(new Animal1(),new Animal2()); //实例化。如果括号里没有参数，则括号可以省略 继承的几种方式 继承的本质就是原型链。\n继承的方式有几种？每种形式的优缺点是？这些问题必问的。其实就是考察你对原型链的掌握程度。\n方式一：借助构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function Parent1() { this.name = \u0026#39;parent1 的属性\u0026#39;; } function Child1() { Parent1.apply(this) this.type = \u0026#39;child1 的属性\u0026#39;; } function Boss() { Child1.call(this) this.title = \u0026#39;我是boss\u0026#39;; } console.log(new Child1) // Child1 {name: \u0026#39;parent1 的属性\u0026#39;, type: \u0026#39;child1 的属性\u0026#39;} console.log(new Boss); //Boss {name: \u0026#39;parent1 的属性\u0026#39;, type: \u0026#39;child1 的属性\u0026#39;, title: \u0026#39;我是boss\u0026#39;} 【重要】Parent1.call(this) :让Parent的构造函数在child的构造函数中执行。改变this的指向，parent的实例 \u0026ndash;\u0026gt; 改为指向child的实例。导致 parent的实例的属性挂在到了child的实例上，这就实现了继承。\n分析：\n这种方式虽然改变了 this 的指向，但是Child1 无法继承 Parent1 的原型。也就是说，如果我给 Parent1 的原型增加一个方法，这个方法是无法被 Child1 继承的，如下：\n1 2 Parent1.prototype.say = function () { }; 方法二：通过原型链实现继承 1 2 3 4 5 6 7 8 function Parent() { this.name = \u0026#39;Parent 的属性\u0026#39;; } function Child() { this.type = \u0026#39;Child 的属性\u0026#39;; } Child.prototype = new Parent(); //【重要】 console.log(new Child()); // 打印结果：\n【重要】每个函数都有prototype属性，我们把Parent的实例赋值给了Child的prototype，从而实现继承。此时，Child构造函数、Parent的实例、Child的实例构成一个三角关系。于是：\nnew Child.__proto__ === new Parent()的结果为true 分析：\n这种继承方式，Child 可以继承 Parent 的原型 缺点是：如果修改 child1实例的name属性，child2实例中的name属性也会跟着改变。 如下：\n上面的代码中， child1修改了arr属性，却发现，child2的arr属性也跟着改变了。这显然不太好，在业务中，两个子模块应该隔离才对。如果改了一个对象，另一个对象却发生了改变，就不太好。\n造成这种缺点的原因是：child1和child2共用原型。即：chi1d1.__proto__ === child2__proto__是严格相同。而 arr方法是在 Parent 的实例上（即 Child实例的原型）的。\n方式三：组合的方式：构造函数 + 原型链 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 组合方式实现继承：构造函数、原型链 */ function Parent3() { this.name = \u0026#39;Parent 的属性\u0026#39;; this.arr = [1, 2, 3]; } function Child3() { Parent3.call(this); //【重要1】执行 parent方法 this.type = \u0026#39;Child 的属性\u0026#39;; } Child3.prototype = new Parent3(); //【重要2】第二次执行parent方法 var child = new Child3(); 优点：既可以继承父类原型的内容，也不会造成原型里属性的修改。 缺点：让Parent的构造方法执行了两次。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/05-02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","summary":"前言 类与实例： 类的声明 生成实例 类与继承： 如何实现继承：继承的本质就是原型链 继承的几种方式 类的定义、实例化 类的定义/类的声明 方式一：用构造函数","title":"面向对象：类的定义和继承的几种方式"},{"content":" 有时在面试时，我都替候选人着急——候选人完全可以在面试前准备\n转眼人到中年：前端老程序员无法忘怀的一次百度电话面试\n八年前的面经，咋记得这么清楚？\n16年毕业的前端er在杭州求职ing\n2018秋招前端总结\n前端开发面试题(CSS)\n超过20家的前端面试题\n来聊聊前端工程师的面试套路\n我的前端进阶之路（面试题）\n这几个链接里讲到了 less。听说面试爱问 less 和 Sass的区别。\n记录前端的面试日常(持续更新)\n我遇到的前端面试题2017\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E7%BB%8F%E9%93%BE%E6%8E%A5%E6%8E%A8%E8%8D%90/","summary":"有时在面试时，我都替候选人着急——候选人完全可以在面试前准备 转眼人到中年：前端老程序员无法忘怀的一次百度电话面试 八年前的面经，咋记得这么清楚","title":"面经链接推荐"},{"content":"写简历的注意事项 最多可以写“深入了解”，但不要写“精通”。 遇到不知道的问题，该怎么回答 这块儿我没了解过，准备回去看一下。\n这块儿我没研究过，您有没有好的资料，我可以补充一下细节。\n写不出详细的代码，但是知道思路。\n项目经历 面试要体现项目的设计思路、方案设计等 模块化思维 （1）模块化设计的关键词：封装、继承；把通用的模块先抽象，后具体，达到复用。【面试记住】\n比如，panel、按钮、轮播图、列表等等，都可以提取为抽象的组件，复用。\n（2）页面有哪几个模块\n（3）每个模块分成不同的文件，然后在index页面中import。\nES6新特性 let、const\n函数扩展：参数默认值、箭头函数、扩展运算符...\nfor of 循环\nmap\n模块化\n薪资 面试官；\u0026ldquo;你要求多少薪资？\u0026rdquo;\n我：“能给个范围吗？”\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7/","summary":"写简历的注意事项 最多可以写“深入了解”，但不要写“精通”。 遇到不知道的问题，该怎么回答 这块儿我没了解过，准备回去看一下。 这块儿我没研究过，您","title":"面试技巧"},{"content":"1、http 和 https 的基本概念 http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。\nhttps:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。\nhttp 明文传输，数据未加密，安全性较差，https（http+ssl）数据传输过程是加密的，安全性较好。 http 的连接很简单，是无状态的。https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10%~20%的耗电。 https 缓存不如 http 高效，会增加数据开销。 Https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高。 SSL 证书需要绑定 IP，不能再同一个 IP 上绑定多个域名，IPV4 资源支持不了这种消耗。 2、http 请求跨域问题 同源：如果两个页面的域名、协议、端口都相同，则两个页面具有相同的源。 同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能。也就是说浏览器只允许访问同一个源下的服务器资源，限制访问不同源下的资源，以防止潜在的恶意文件。\n如果非同源，共有三种行为受到限制： 1）Cookie、LocalStorage 和 IndexDB 无法读取。 2）DOM 无法获得。 3）Ajax请求不能发送\n解决方案：\nnginx反向代理 CORS CORS(Cross-origin resource sharing)跨域资源共享，服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求。 JSONP 3、TCP和UDP的区别 TCP 是面向连接的、可靠的流协议，UDP是面向无连接、不稳定的流协议。流就是指不间断的数据结构 TCP仅支持单播传输，UDP 提供了单播，多播，广播的功能（一对多，多对多，多对一）。 TCP的三次握手保证了连接的可靠性; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。 UDP的头部开销比TCP的更小，数据传输速率更高，实时性更好。 区别 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持单播、多播、广播的功能（一对一、一对多、多对一、多对多）交互通信 只能是单播通信，全双工 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅8字节 首部最小20字节，最大60字节 适用场景 无连接 面向连接 是否连接 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 4、TCP连接需要三次握手 第一次握手，客户端向服务端发送连接请求报文段 SYN，客户端便进入 SYN-SENT 状态。 第二次握手，服务器端接收后，如同意连接，返回报文SYN + ACK，发送完成后进入 SYN-RECEIVED 状态。 第三次握手，当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e31a7d17a013430faf01a4830bd7fda3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\n为什么 TCP 建立连接需要三次握手，而不是两次？这是因为这是为了防止出现失效的连接请求报文段被服务端接收的情况，从而产生错误。 5、TCP断开链接需要四次握手 第一次握手，客户端A认为数据发送完成，向服务器端B发送连接释放请求。 第二次握手，B收到连接释放请求后，会告诉应用层释放TCP链接，然后发送ACK包，并进入CLOSE_WAIT状态，此时A到B的连接已经释放，不再接受A发的数据。因为TCP连接是双向的，所以B仍旧可以发送数据给A 第三次握手，B此时如有未发完数据会继续发送，完毕后会向A发送连接释放请求，并进入LAST_ACK状态。 第四次握手，A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃）时间 ，若该时间段内没有 B 的重发请求的话，就进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态。 6、cookie、sessionStorage、localStorage的区别 cookie 可以设置过期时间，sessionStorage 当前浏览器窗口关闭后自动删除，localStorage 永久存储本地（需主动清除） cookie大小4k，sessionStorage和localStorage大小5M cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地 7、从输入URL到页面加载的全过程 首先在浏览器输入URL 查找缓存：浏览器查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如有则显示页面内容，反之则进行下一步。 浏览器缓存：浏览器会记录DNS一段时间，因此，这是第一个地方解析DNS请求； 操作系统缓存 路由器缓存 ISP缓存 DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。 建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接。 发起HTTP请求：将TCP三次握手的第三次请求报文作为的发送给服务器 服务器响应请求并返回结果：把对应的html文件发送给浏览器 关闭TCP连接：通过四次挥手释放TCP连接 浏览器渲染：客户端解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为： 构建DOM树 构建CSS规则树 构建render树 布局 绘制 JS引擎解析过程 创建window对象 加载文件 预编译 解释执行 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/1.%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93/","summary":"1、http 和 https 的基本概念 http: 是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地浏览器的超文本传输协议。 http","title":"面试题库"},{"content":"JavaScript 存储相关：请描述以下cookie、localStorage、sessionStorage的区别 在H5之前，cookie一直都是本地存储的一个重要的方法。直到后面的两个出现了， 就开始用后面的两个做本地存储。\n1、cookie：\n本身用于客户端和服务器端的通信。\n但是它有本地存储的功能，于是就被“借用”。\n我们可以通过document.cookie获取和修改cookie，获取到的其实就是一个字符串。\ncookie用于存储时的缺点：\n存储量太小，只有4kb\n所有http请求都带着，会影响获取资源的效率\napi简单，需要封装才能用。document.cookie = ...\nfor each、for in、for of的区别 foreach用于遍历数组，是数组的一个方法。不支持 return。\nfor in获取对象里属性的键。\nfor of获取对象里属性的值。\n网络相关 浏览器输入url到显示内容，有哪些过程 （1）浏览器解析url。包括：协议、域名、端口号、资源路径、参数查询\n（2）DNS解析\n（3）TCP握手\n（4）HTTP请求\n（5）服务器处理请求\n（6）浏览器渲染：DOM tree、CSS rule tree、render tree。\n（7）display\n参考链接：\n笔记：阿里、网易、滴滴共十次前端面试碰到的问题\nwhat-happens-when-zh_CN\n码农翻身 | 小白科普：从输入网址到最后浏览器呈现页面内容，中间发生了什么？\n从输入URL到页面加载发生了什么：https://segmentfault.com/a/1190000006879700\nGitHub [荐]面试题和答案：https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers\n面试题和答案：https://github.com/qiu-deqing/FE-interview\n有个题是，浏览器输入url，有哪些过程\n讲到了Cookie和session\n这个也很全：https://github.com/gnipbao/Front-end-Interview-questions\nhttps://github.com/giscafer/front-end-manual/issues/3\nweb前端面试题汇总：https://www.jianshu.com/p/2f7eb1ad7174\n2017前端面试题及答案总结：https://yeaseonzhang.github.io/2017/09/17/2017%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88%E6%80%BB%E7%BB%93/\n今日头条一面笔试面试题！！！！！完整\nCommonJS、RequireJS(AMD) SeaJS（CMD）区别 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/","summary":"JavaScript 存储相关：请描述以下cookie、localStorage、sessionStorage的区别 在H5之前，cookie一直都是本地存储的一","title":"面试题整理"},{"content":"sass sass变量 $variablename: value;\n示例代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $myFont: Helvetica, sans-serif; $myColor: red; $myFontSize: 18px; $myWidth: 680px; body { font-family: $myFont; font-size: $myFontSize; color: $myColor; } #container { width: $myWidth; } sass作用域 Sass 变量的作用域只能在当前的层级上有效果\n1 2 3 4 5 6 7 8 9 10 $myColor: red; h1 { $myColor: green; // 只在 h1 里头有用，局部作用域 color: $myColor; //green } p { color: $myColor; //red } sass !global !global 关键词来设置变量是全局的\n1 2 3 4 5 6 7 8 9 10 $myColor: red; h1 { $myColor: green !global; // 全局作用域 color: $myColor; // green } p { color: $myColor; // green } sass嵌套规则 1 2 3 4 5 6 7 8 9 10 nav { ul {} li {} a {} } //类似于 nav ul{} nav li{} nav a{} sass嵌套属性 1 2 3 4 5 6 7 8 9 10 font:{ family: Helvetica, sans-serif; size:16px; weight:bold; } //类似于 font-family: Helvetica, sans-serif; font-size: 18px; font-weight: bold; @import Sass @import 指令语法如下： @import filename;\n在 standard.scss 文件中使用 @import 指令导入 reset.scss 文件：\n1 @import \u0026#34;reset\u0026#34;; //将会合并两个文件的css sass Partials 如不希望将一个 Sass 的代码文件编译到一个 CSS 文件，将sass文件名开头加上下划线 _filename;\n创建一个 _colors.scss 的文件，但是不会编译成 _colors.css 文件\n1 2 3 4 // colors.scss $myPink: #EE82EE; $myBlue: #4169E1; $myGreen: #8FBC8F; 要导入该文件，则不需要使用下划线\n1 @import \u0026#34;colors\u0026#34;; **注意：请不要将带下划线与不带下划线的同名文件放置在同一个目录下，否则带下划线的文件将会被忽略。比如，_colors.scss 和 colors.scss 不能同时存在于同一个目录下，_colors.css文件会被忽略。\n@minxin和 @include @mixin 指令允许我们定义一个可以在整个样式表中重复使用的样式。 @include 指令可以将混入（mixin）引入到文档中。\n控制指令 条件语句（ @if ） 当 @if 的表达式返回值不是 false 或者 null 时，条件成立，输出 {} 内的代码：\n1 2 3 4 5 p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 \u0026lt; 3 { border: 2px dotted; } @if null { border: 3px double; } } 编译为\n1 2 3 p { border: 1px solid; } @if 声明后面可以跟多个 @else if 声明，或者一个 @else 声明。 如果 @if 声明失败，Sass 将逐条执行 @else if 声明，如果全部失败，最后执行 @else 声明。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @mixin txt($weight) { color: white; @if $weight == bold { font-weight: bold; } @else if $weight == light { font-weight: 100; } @else { font-weight: normal; } } .txt1 { @include txt(bold); } 编译为\n1 2 3 4 .txt1 { color: white; font-weight: bold; } 4.2 循环语句 @for @for 指令可在限制的范围内重复输出格式，每次按要求输出结果做出变动。 包含两种格式：@for $var from \u0026lt;start\u0026gt; through \u0026lt;end\u0026gt;，或 @for $var from\u0026lt;start\u0026gt; to \u0026lt;end\u0026gt;； 区别： through 与 to 的含义：当使用 through 时，条件范围包含 \u0026lt;start\u0026gt; 与 \u0026lt;end\u0026gt; 的值， 而使用 to 时条件范围只包含 \u0026lt;start\u0026gt; 的值不包含 \u0026lt;end\u0026gt; 的值。 另外，$var 可以是任何变量，如 $i；\u0026lt;start\u0026gt; 和 \u0026lt;end\u0026gt; 必须是整数值。\n1 2 3 @for $i from 1 through 3 { .item-#{$i} { width: 2em * $i; } } 编译为\n1 2 3 4 5 6 7 8 9 .item-1 { width: 2em; } .item-2 { width: 4em; } .item-3 { width: 6em; } @while @while 指令重复输出格式直到表达式返回结果为 false。这样可以实现比 @for 更复杂的循环，只是很少会用到。\n1 2 3 4 5 $i: 6; @while $i \u0026gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } 编译为\n1 2 3 4 5 6 7 8 9 .item-6 { width: 12em; } .item-4 { width: 8em; } .item-2 { width: 4em; } @each @each 指令的格式是 $var in \u0026lt;list\u0026gt;, $var 可以是任何变量名。如 $length 或 $name，而 \u0026lt;list\u0026gt; 是一连串的值，也就是值列表。 @each 将变量 $var 作用于值列表中的每一个项目，然后输出结果。\n1 2 3 4 5 @each $animal in puma, sea-slug, egret, salamander { .#{$animal}-icon { background-image: url(\u0026#39;/images/#{$animal}.png\u0026#39;); } } 编译为\n1 2 3 4 5 6 7 8 9 10 11 12 .puma-icon { background-image: url(\u0026#39;/images/puma.png\u0026#39;); } .sea-slug-icon { background-image: url(\u0026#39;/images/sea-slug.png\u0026#39;); } .egret-icon { background-image: url(\u0026#39;/images/egret.png\u0026#39;); } .salamander-icon { background-image: url(\u0026#39;/images/salamander.png\u0026#39;); } ","permalink":"https://bablvsj.github.io/posts/interview/css/css---sasslessscss/","summary":"sass sass变量 $variablename: value; 示例代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $myFont: Helvetica, sans-serif; $myColor: red; $myFontSize: 18px; $myWidth: 680px; body { font-family: $myFont; font-size: $myFontSize; color: $myColor; } #container { width: $myWidth; } sass作用域 Sass 变量的作用域只能在当前的","title":"css---sass、less、scss"},{"content":"lazyload 用的最多的场景是：\n图片lazyload\n组件lazyload\n现在一般都单独做css的lazyload或者js的lazyload，因为这种方式，其实还是要加载图片和组件。\n图片lazyload 图片一般是页面最大的资源，所以非首屏延迟加载很重要（让首屏尽快显示）。\n防抖动（Debouncing）和节流阀（Throtting） 参考链接：\n实例解析防抖动（Debouncing）和节流阀（Throttling） ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/lazyload%E9%98%B2%E6%8A%96%E5%8A%A8%E5%92%8C%E8%8A%82%E6%B5%81%E9%98%80/","summary":"lazyload 用的最多的场景是： 图片lazyload 组件lazyload 现在一般都单独做css的lazyload或者js的lazyload，因为这种方式","title":"lazyload\u0026防抖动和节流阀"},{"content":"前端性能优化认知 什么是前端性能优化 通常来讲，前端性能优化是指：从用户开始访问网站到整个页面完整地展现出来的过程中，通过各种优化策略和优化方法，让页面加载得更快，让用户的操作相应更及时，给用户更好的使用体验。\n优化是在做什么：\n如上图所示，优化工作是围绕前端的基本工作原理展开的，包括：客户端和服务器端建立连接、加载资源、解析资源并渲染。\n上方图片的来源：\nThe Cost Of JavaScript [译]JavaScript 的时间消耗 性能优化的重要性（程序员角度） 当领导问：“为什么网页访问这么慢？”我们不能只是回答“网络不好”这么简单，网络不可能一直都不好。\n每个程序员如果想要成长，就不能回避“性能优化”这个话题。很多人写了多年的代码，一直在构建样式、写业务逻辑。但是平凡的程序员之路，何时才是尽头？前端职业发展的瓶颈在哪儿？怎么才能从团队中脱颖而出？如何区分出平凡程序员/大牛程序员/架构师的分水岭？\n职场晋升时，我们也要想一想：大部分人都在写业务代码，和别人相比，我的核心竞争力在哪里？除了技术深度、前端工程化、综合素质之外，还有其他的吗？性能优化，绝对是不能忽视的一方面。而且它是贯穿于开发和维护的的全过程。\n前端工程化是侧重于提效，具体包括编译打包发布流程、物料中心、组件化等；而前端性能优化是侧重于体验。\n公司评价一个程序员的价值，不是加班越多越好，也不是代码量越多越好，而是看他是否能解决其他人解决不了的一些技术难题或者瓶颈。\n大家都知道性能优化很重要，但是落实到具体，怎么去优化？这就需要我们深入去了解前端技术背后的原理，学习一些主流的前端性能优化技术方案，掌握性能优化技术，提升Web性能，才能总结出相应的优化方案，而且需要多年的经验积累；进而到达前端技术圈的上游，提高自己的核心竞争力。\n前端性能优化面试 性能优化是前端面试的必考问题，面试者在回答这个问题时，大致情况如下：\n70% 的人上来就说减少合并资源、减少请求、数据缓存这些优化手段。\n15% 的人会提到需要在 DevTools 下先看看首屏时间，可以先围绕首屏来做优化。\n10%的人会提到需要接入一个性能平台来看看现状，诊断一下。\n而只有 5% 的人会从前端性能体系来系统考虑性能优化。\n面试官期待的是你在什么场景下，遇到了什么性能问题，围绕什么样的性能指标，采取了哪些性能优化手段，最后取得了什么样的结果，而不仅仅是直接说采取了哪些优化手段。\n比如说，“为什么首页打开慢？”\t面试官期待的是，前端能和后端一样，通过查日志和数据就能定位问题，而不是停留在猜测层面。但在实际当中，能做到这点的前端同学并不多。\n那么，前端有没有这样的工具呢？有，那就是性能监控平台。平台上面有各个业务的性能指标及其对应场景下的性能标准，一旦遇到性能问题，就能直接判断当前性能数据有没有问题，然后提示问题是出在前端、后端，还是网络层。\n性能优化的意义 1、随着互联网的发展，网页的内容越来越丰富，功能越来越强大，页面也越做越漂亮；带来的问题是，访问速度和体验会收到影响。只有对网站进行持续不断的优化，才能保证网页的访问速度可以跟得上用户体验的需求。\n2、高性能可以带来更高的用户参与度、用户留存，进而带来更高的转化率和SEO排名，更好的用户体验，最终带来更高的业务收益。\n随着时间的推移，如果一个网站由于各种原因导致心梗越来越差，以至于用户每打开一个页面都要等待很长时间，甚至出现加载失败的情况，那么，不仅新用户不会沉淀下来，老用户也会纷纷离去，最终导致产品的加速衰败。\n而且网站的加载快慢，最产品收入有着直接的影响。有数据表明：网页加载时间在5秒内的网站比加载时间为19秒的网站，广告收入会增加近一倍。也就是说，网站或者App的性能直接关系到产品的用户增长和收入增长。\n正因为如此，我们才需要通过性能优化的技巧，并结合其他的技术手段来不断提高网站和App的用户体验，从而助力公司的业务增长；同时，我们也可以借此提升自己的技术实力，这对个人的职业成长也会以后很大的帮助。\n3、只要产品上线了，随着业务规模量和用户访问量的扩大，性能优化就是不可回避的话题。在遇到性能问题时，有些人的解决办法是：用一些粗糙的手段把问题绕过去，但却给后面的人埋下了坑。这些人常说的依据口头禅是：\n相关案例 Amazon发现每100ms延迟导致1%的销量损失。\n歌地图首页文件从100KB减少到70KB，流量在第一周涨了10%，在接下来的三周涨了25%。\n腾讯根据长期数据监控发现，页面一秒钟延迟会造成页面访问量下降9.4%，跳出率增加8.3%，转化率下降3.5%。\n如何学习性能优化 学习难点 我们在网上找到的文章，有很多都只是对CSS、JS技术本身的优化，一旦涉及到App、后端、网络等不是很熟悉的领域，学习起来就比较困难了。结合具体业务开发的应用场景时，却不知从何下手。因此，我们需要要由点及面，学习全链路前端性能优化的知识体系和解决方案。\n在实际工作当中，前端性能优化往往比较繁杂，学习难点主要体现在以下几个方面：todo\n优化标准 我们在做优化时，需要有一个量化标准，比如：\nloading 要做到什么效果、动画要达到什么效果才是好的？\n所有的事件处理，要在什么时间内完成，才能给用户良好的体验？\n技术储备前提 掌握前端基础知识。\n具备Web开发实战经验。\n寻找性能瓶颈 了解性能指标，多快才算快。\n利用测量工具和API\n优化问题，重新测量。持续迭代。\n移动端挑战多 移动端的硬件不如PC端，且网络不稳定。\n屏幕尺寸和交互方式都是挑战。\n移动端用户更佳缺乏耐心。而且，很多用户是利用碎片化时间访问网页。数据参考： \u0026gt;3秒的加载时间，导致 53%的跳出率（bounce rate）。\n持续增长的移动端用户和电商业务。现在很多事情都是在移动端做的。\n收获 由浅入深：解读优化技术内幕。\n流行+经典：了解技术背后的设计思想。\n了解性能优化的关键环节，升级知识储备。\n理论+实践：掌握前端业界的流行且成熟的多种性能优化技术，脱颖而出。\n了解大厂正在用的生产环境级别的高性能解决方案。\n前端性能优化全过程 1、静态资源优化 静态资源优化包括html、css、js、图片等资源的性能优化。包括：\n图片的应用场景和使用\nhtml、css、js的具体优化策略\n资源文件的优化：比如文件压缩合并策略、打包方案、版本号更新方案\n前端工程化工具等。\n2、页面渲染架构设计及相关的技术方案选型 按照技术方案的分类，包括：\n前后端分离技术\nSPA单页应用\nBigPipe\n同构直出\nPWA\n页面加载策略\n接口服务调优、接口缓存策略\n大型网站背后的实际性能优化案例\n前端组件化、模块化，加速业务开发\n3、原生App优化、混合开发优化 浏览器的整体优化方案。比如导航条、登录态、滚动条优化等。\n前端缓存策略和优化\nH5静态资源请求代理的技术原理\nH5离线技术，达到页面秒开的目标\n混合式开发解决方案\nRN、小程序、flutter等\n4、服务端与网络优化 CDN 和 DNS 优化\n如何减少 http 请求数、减少cookie大小\nnginx缓存配置和优化\n开启和配置 gzip 压缩\n如何开启全站 https\n升级 Http2.0 的好处和方法\n5、研发流程优化 技术调用的方法\n前后端接口约定、加快前后端接口联调\n前端自动化测试\n自动化部署和上线\n从研发的整体流程层面梳理出提升研发效率的方式和方法。\n6、全链路质量监控体系建设 主要是对性能优化的结果进行衡量、打分、考核：\n上线前，页面质量及时检测\n上线后，页面性能和错误监控\n线上运行时，页面的可用性监控\n愿生App的性能和错误监控\n前端性能优化包括哪些方面 1、性能优化指标与测量工具 行业标准\n优化模型\n性能测量工具：了解性能情况，并对比\n性能相关APIs\n2、渲染优化 现代浏览器的渲染原理\n可优化的渲染环节和方法\n3、代码优化 JS优化：了解JS的开销、解析、优化方案，以及如何配合V8引擎做更有效的优化。\nhtml优化\ncss优化\n4、资源优化 压缩合并\n图片格式\n图片加载\n字体优化\n5、构建优化 webpack 优化配置\n代码拆分\n代码压缩\n持久化缓存\n监测与分析\n按需加载\n6、传输和加载优化 gZip\nKeepAlive\nHTTP缓存\nService Worker\nHTTP/2\nSSR 服务端渲染\nNginx\n7、更多主流优化方案 SVG 优化图标\nFlexBox 布局\n预加载\n预渲染\n窗口化提高列表性能\n骨架屏\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/00-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E8%AE%A4%E7%9F%A5/","summary":"前端性能优化认知 什么是前端性能优化 通常来讲，前端性能优化是指：从用户开始访问网站到整个页面完整地展现出来的过程中，通过各种优化策略和优化方法","title":"前端性能优化认知"},{"content":"性能指标和优化目标之：加载 性能指标：我们在性能优化过程中可以参考的标准。这些标准都是业界或者前人总结出来的指导性经验。我们可以参考这些指标，去指导我们自己的优化。\n打开网站的初体验 我们以淘宝网站为例，按下F12打开浏览器的调试模式。\n上图中，鼠标右键点击“刷新”图标（或者鼠标长按刷新图标，松开鼠标后），会弹出三个选项，我们选择最后一个选项“清空缓存并硬性重新加载”。\n补充：这三个选项都是在调试模式下（按下F12弹出调试面板）才会出现的。\n浏览器的DevTools初印象：\n上图中，打开 chrome 调试工具，点开「设置」icon，下面的四个选项中，除了“Group by frame”之外，其他的三个选项都可以勾选上。\n我们可以看到淘宝网站的一些指标：\n总资源量是 1.3M。 DOM加载完成时间（DOMContentLoaded）：511ms。这是一个很关键的指标。 其他资源的总加载时间是 1.05秒。 我们再来对比一下京东的：\n保存快照 network里的信息挺多，我们可以将其保存下来，留着以后做分析、做对照。\n如上图所示，我们可以在 network 的空白处右键，选择“Save all as HAR with content”，将 network 信息保存为 HAR文件格式。\nHAR是一种标准的Web格式，用户保存性能测试的结果。里面的数据是json格式。\n我们可以使用第三方的 HAR 分析软件来打开 HAR 文件，比如：\nGoogle 提供的 HAR 分析器\nFiddler 抓包工具\n注意，HAR 文件包含了一些敏感信息：\n瀑布图 Waterfall 瀑布图可以非常直观地把网站的加载过程，用自上而下的方式表达出来，就像瀑布一样。\n瀑布图有两中解读方式：一种是横向看，一种是纵向看。\n1、横向看：\n横向看的是具体的资源，每一行代表某个资源的加载信息。里面有一些色块来表达加载的过程，每个块的颜色不同。也就是说资源的下载不是单一的过程，而是经历了很多环节。\n为了了解资源的具体加载过程，我们把鼠标悬浮在第一个资源的色块上，可以看见一个详情列表：\n（1）等待：\nQueueing：排队。浏览器会对资源的请求做优先级排序。 （2）连接：\nDNS Lookup：DNS域名解析。每个资源都有域名，对域名做DNS解析，然后找到对应服务器的IP地址。\ninitial connection：客户端和服务器之间建立TCP连接。\nSSL证书：该网站为了保证安全性，使用了 https 协议，启用了SSL证书。启用之后，需要做安全认证（SSL协商），这个过程也会耗时。到这里位置，我们可以看到，在请求资源之前，有很多的前置步骤。\n（3）请求和响应：\nRequest sent：到这一步，真正开始请求资源。\nWaiting（TTFB）：资源从请求到响应，有一个等待的时间。\nContent Download：收到响应后，资源的下载时间。如果值越大，表明下载时间越长。有些同步加载的资源会造成阻塞，导致网页的整体加载时间过长，让用户等待太久。\nTTFB 是一个很重要的指标，它表示的是：请求发出到响应，到底要经历多久。TTFB 可以给我们一个很直观的感受，我们网站的请求和响应到底是快还是慢，很大程度上是由 TTFB 决定。\n影响 TTFB 的因素是什么呢？比如：\n后台的处理能力的响应速度。\n网络状况：是否有网络延迟。\n2、纵向看：（主要看两点）\n（1）看资源与资源之间的联系：如果发生阻塞，说明资源可能是串行地按顺序加载。可以按需要适当调整为并行。\n（2）看关键的时间节点。Waterfall 中有两根时间线：蓝色的线是 DOM 加载完成的时间，红色的线是所有资源加载完成的时间。\n性能指标和优化目标之：交互 上面的内容讲的是加载的性能，还有一个需要关注的性能指标是交互。也就是网站加载完成后，用户真正开始使用这个网站过程中的的交互体验。\n关于交互体验的性能，我们需要关注的是：\n交互动作的响应时间要短：比如点击按钮后的弹窗、在搜索框里输入关键字后的搜索结果。\n页面滚动要流畅：可以查看 FPS 帧率。\n异步请求接口的完成时间要短：比如关注/取关主播的响应、领取红包的操作。\nFPS帧率、FRS 这里首先科普两个概念：\n刷新率：显示器每秒有多少帧画面。大多数显示器的刷新率是60帧/秒（即60hz）。 帧率（FPS：frames per second）：视频或者动画的内容本身，每秒有多少帧。由显卡输出帧率。 上面的两个参数中，不要把「刷新率」和「帧率」弄混了。「刷新率」是屏幕的参数，「帧率」是图像、视频等内容的参数。人眼最终看到的效果，是以最低的参数为准的。\n目前，市场主流手机和电脑屏幕的刷新率基本都是60Hz，即每秒显示60帧画面。也就是说，当我们在使用手机的时候，本质上是手机在连续播放一张张静态图片，每秒播放60张，让肉眼误认为眼前的画面在动。\n持续滑动的过程中，如果页面输出到显示器的帧率低于60帧/秒，则人眼会感觉卡顿。\n那么，在浏览器中如何实时显示内容的 FPS 参数呢？打开浏览器的控制台后，按住快捷键「Cmd + Shift + P」，然后输入 frame，选择Show frames per second（FPS） meter。如下：\n温馨提示： 从 2020年7月起，chrome 官方已经取消了 fps参数的显示，改为了 FRS：\nFRS参数观察的是丢帧率： Chrome官方给我们提供了下面这个网站，用于观察 FPS 效果：\nhttp://googlesamples.github.io/web-fundamentals/tools/chrome-devtools/rendering-tools/forcedsync.html 如果实在想要看fps，我们可以借助第三方的 chrome 插件来查看 fps参数。\n用 RAIL 模型测量性能 RAIL 模型是Google提出的可以量化性能的测量标准。我们做性能优化时，要尽可能到这个标准。\n在做性能优化的时候，我们需要有人告诉我们：做到多好才算好？有没有一些通用的标准？而 RAIL 模型 可以给我们带来量化的指标。\nRAIL 模型包括四个方面：\nResponse：响应\nAnimation：动画\nIdle：空闲时间\nload：加载\n参考链接：\n[Web翻译]用RAIL模型测量性能\nhttps://web.dev/rail/\nRAIL 的目标：\n让良好的用户体验成为性能优化的目标 接下来，我们再看看看 RAIL 的评估标准。\n1、响应 目标：处理用户发起的响应，应该在 50ms 内完成。\n准则：\n在50毫秒内处理用户输入事件。这适用于大多数输入，如点击按钮、切换表单控件或启动动画。这不适用于触摸拖动或滚动。\n对于需要超过50毫秒才能完成的操作，需要提供反馈。\n如上图所示，Google经过大量研究发现，用户能够接受的最高延时是100ms。所以，从用户发起交互请求（输入任务）后，前端最好能在100ms内给出反馈。\n但是我们的预算只有50毫秒。因为应用程序在接收到输入任务的时候，不一定会马上着手处理，它可能还有其他工作正在进行，这意味着当前的输入任务可能需要排队50ms左右。所以我们真正能处理这个请求的时间，并没有100ms。\n2、动画 目标：在10毫秒或更短的时间内制作出动画中的每一帧。（即：100帧/秒。）\n我们知道，当动画的帧率是 \u0026gt;= 60帧/秒 的时候，人眼才不会觉得卡顿。此时的理论值为 1000毫秒/60帧 = 16.6 毫秒/帧。\n10毫秒和16毫秒之间，隔了6秒。这6秒是什么呢？因为浏览器需要大约6毫秒的时间来渲染每一帧，所以，每一帧的准则建议是10毫秒，而不是 16.6毫秒。\n假设动画本身是60帧/秒，那么，最终渲染出来的效果可能只有 45帧/秒。\n广义的动画：\n动画不仅仅是花哨的UI效果。每一种交互都被认为是动画。比如：\n视觉动画\n滚动\n拖动、平移元素、放大图片等。\n3、空闲时间 目标：最大化闲置时间，增加页面在50毫秒内响应用户输入的几率。\n这个空闲时间，是和上面的第一点“响应”是结合在一起的。只有空闲足够多，当用户的交互来的时候，我们才能有足够的时间进行处理。\n准则：\n利用空闲时间做延迟加载。例如，页面在初始化的时候，尽可能少的加载数据，然后利用空闲时间加载其余部分。\n在空闲时间内处理任务，时间不能超过50毫秒。否则，就阻塞了用户做其他的输入请求，导致卡顿。\n如果用户在闲置时间工作期间与页面进行交互，那么这个交互应始终处于最高优先级，并中断闲置时间工作。\n4、加载 目标：在5秒或更短的时间内加载页面并可以交互。\n准则：\n这里的5秒包括：加载、解析、渲染，并确保用户可以交互。\n加载的过程中，可以使用loading框、进度条、骨架屏等方式缓解用户焦虑。\n使用Chrome DevTools 分析性能 现在主流的性能测量工具：\nChrome DevTools：开发调试、分析性能。\nLighthouse 网站整体质量评估。\nWebPageTest：给网站提供多个地点的测试，以及全面的性能报告。\n这一段，我们先来讲一讲 Chrome DevTools 。\n大家平时在用 Chrome DevTools 的时候，一般使用来开发调试、查看 DOM、css、接口请求等，但其实，这个工具非常强大。\nsize：文件大小分析 可以把size从到小排序，看看哪个资源的文件较大。\n另外，上图中的横线处说明：该文件在网络传输的时候会做压缩（125kb），拿到资源之后再解压还原（526kb）。\nperformance：性能表现 preformance的两个作用：\nRecord button：记录页面加载、用户交互等全过程，直到我们手动点击停止按钮。 Reload button：记录页面从刷新到资源加载完成的过程。会自动停止记录。 参数解读：\nTiming：关键的时间节点。\nMain：主线程做了哪些任务，以及调用关系。\nTiming参数中，尤其注意看DCL（DOMContentLoaded），即DOM加载完成的时间节点。我们可以通过Main参数看看DOM在加载完成之前，都做了些什么事情。很有可能就是这些事情导致 DCL的时间过晚。\n我们可以翻到Main里的最后一行（即最终调用的位置），往往这个位置就是我们自己写的代码。\nDiable cache 上图中的Diable cache是一个很重要的设置选项。\n勾选Diable cache：\n不走缓存，相当于页面初次访问。 如果你希望改的代码立即生效，就一定要勾选上。 不勾选Diable cache：\n走缓存，相当于页面二次、三次访问。 很多时候，我们需要关心用户在第二次、第三次访问时候，他的访问速度如何、性能如何、我们设置的缓存有没有生效。此时就不要勾选上。 模拟网络情况 模拟网络状况（自定义参数）：\nPerformance monitor 快捷键ESC 按住快捷键ESC，会列出其他常用的功能菜单：\n使用LightHouse分析性能 我们之所以使用不同的性能测量工具，是因为他们都有不同的特点。这一段要讲的 lighthouse 既可以帮我们生成简易的测试报告，还可以给出一些针对性的优化建议。后面要讲的 WebPageTest 可以帮我们生成详细的性能测试报告。\n我们先来看看 Lighthouse。\nLighthouse 介绍 lighthouse 是 chrome 浏览器的一个性能测量工具。我们先来看看它的性能指标，至于它具体使用，后续的内容再详细介绍。\n淘宝跑分举例：\n京东跑分举例：\nLighthouse 跑分里，最重要的两个指标如下：\nFirst Contentful Paint（白屏时间）：**从白屏到第一次出现内容的时间。**我们可以看到，上面提供了一些加载过程的截图，10屏里如果只有1到2屏是白屏，说明体验还是可以的。\nSpeed Index：速度指数。\n我们不需要关心这个指数是怎么来的，因为背后涉及一套很复杂的公式，我们暂时只需关注这个数值。\nSpeed Index 标准为4秒（超过4秒算比较慢的），我们测的淘宝的 speed index 是0.5s，很快了。但我们要结合网站本身的业务来权衡。并不是分数越高性能越高，比如百度这样的网站，页面上的内容很少，测出来的分数肯定很完美。而淘宝需要展示很多内容给用户看。所以，这个指标只是一个指导作用，并不一定能够达到最优的数值。\nLighthouse 的分析结果里，也给出了颜色标注：\n红色：比较严重的性能问题 黄色：需要做适当优化 绿色：说明性能表现很好。 另外，Lighthouse 还会给出一些优化建议：\nOpportunities:优化建议。\nDiagnostics：问题诊断。\nPassed audits：表示这部分没有问题。\n举例：确认某个JS 是否必须在首屏加载 就拿B站来举例，来看看它的lighthouse报告：\n上图中给出了一个优化建议：有些JS文件不是首屏加载必须的。\n我们随便拿一个JS文件来测试（比如上图中，Header标签里的JS文件）。做法如下：\n如上图所示，在 chrome 控制台输入快捷键「Cmd + Shift + P」，然后输入文本block，选择Show Network request blocking：\n按照上面的步骤添加规则，点击add后，效果如下：\n然后，我们切换到控制台的 network面板，并刷新页面：\n然后观察这个js资源是不是首屏加载所必须的。但我们也不能就此定论说这个资源一定可以延迟加载，也许它就是想让页面在一开始loading的时候就捕获日志。\n对于我们自己的网站，这个资源是首屏加载必须的吗？一定要在第一时间加载吗？需要根据特定的业务做衡量。\n通过npm运行 Lighthouse工具 1 2 3 4 5 6 7 8 9 # 安装 npm install -g lighthouse # 执行 lighthouse https://www.jd.com # 输出性能检测报告 Generating results... html output witten to /Users/smyh/Documents/wpt-mac-agent/www.jd.com._2021-01-16_09-00-00.html 使用 WebPageTest 评估网站性能 程序员经常说的有句话是：“我这儿能打开啊。我这儿不报错呀。”大家应该都懂这个梗，这就是为什么，我们要借助第三方的测试工具，而不仅仅只是自己电脑上访问正常就ok了。\n我们需要借助 WebPageTest 这样的第三方测试工具，去模拟各种用户的真实场景。\nWebPageTest 使用 网址：https://www.webpagetest.org\nWebPageTest 在世界各地提供了非常多的服务器，在每个服务器上部署了不同的浏览器，可以让我们有针对性的做测试。如果你做的是一款国际化网站，那更有必要使用一下了。\n我们以JD网站举例：\n按照上面的选项配置完成后，点击右侧的「Start Test」即可开始测试。然后等待：\nWebPageTest 报告分析 淘宝网站性能测试报告：\n2020年6月：https://webpagetest.org/result/200616_JK_78eebda338285ffe0c2e154ca5032839/\n2021年1月：https://www.webpagetest.org/result/210115_DiCB_f1344d732760365151755e89765b2d37/\nJD网站性能测试报告：\n2021年1月：https://www.webpagetest.org/result/210115_DiGT_8d7370e91230b7d077e40b7aafb485a5/ 拿到 WebPageTest 报告之后，我们来看看报告里的几个重点指标。\n1、摘要里的参数：（如上图）\nFirst Byte：第一个请求的响应时间。可以反映后台的处理能力，以及网络回路的情况。 Start Render：从白屏到首次渲染的时间。 Speed Index：速度指数。 Total Blocking Time：页面被阻塞，导致用户不能交互的累计时间。 2、详情里的参数：First View。\nFirst View展示的是：首次访问时，总的加载时间。这里面提供的瀑布图，比 chrome DevTools里提供的更为详细。\n点击进入 First View 的详情之后，可以看到：所有的资源请求，都会在这里列出来。如下：\npage is Interactive：页面在加载的过程中，大部分时间段，用户都是可以交互的。这是非常有用的一个指标。 Brower Main thread：浏览器主线程的占用情况。可以看看空闲的时间多不多。 CPU Utilization：CPU的使用情况。 多张图片的资源请求。 上图中，我们可以看到：多张图片的开始请求时间都是相同的。也就是说，如果让资源做并行加载，我们就可以加大地减少加载时间，最终所消耗的时间就由最大的图片来决定。这是一个很好的优化技巧，至于具体是怎么实现的，可以自行了解。\n另外，我们看到，有一部分的请求，被高亮出来了：\n上面这张图的意思是：302表示重定向，也就是说，这个资源已经不在原来请求的位置了，需要重定向才能找到真实的位置。这个地方其实可以做一个优化：\n不需要去访问之前的无效的资源，可以直接去访问重定向后的那个资源。\n局域网部署 WebPageTest 工具 如果我们开发的页面，还没有上线，公网则无法访问。这个时候我们也想通过WebPageTest看看网站的性能，那要怎么办呢？\n我们可以在局域网部署 WebPageTest 工具，具体方法可自行研究。\nchrome插件：PageSpeed Insights 另外，google官方也有一个网址：https://developers.google.com/speed/pagespeed/insights/?hl=zh-cn\n但是这个网站在使用时，经常挂掉。\n这个插件是2018年的，已经好几年没更新了。大家参考即可。\n实时动态测量性能的API Chrome DevTools能够检测各种性能参数，其实也是调用了一些性能相关的标准API。我们自己也可以直接在代码里调用这些api。\n通过 performance对象提供的API，我们可以实时的、精细化、自定义测量性能，获取相应的参数。也可以把这些性能参数，打印到控制台，或者实时上报给后台监控系统。\nperformance：获取常见性能参数 常见性能参数，计算公式如下：\n时间戳1减去时间戳2，得到的差值，就是我们想要看到的耗时。\nDNS 解析耗时: domainLookupEnd - domainLookupStart\nTCP 连接耗时: connectEnd - connectStart\nSSL 安全连接耗时: connectEnd - secureConnectionStart\n网络请求耗时 (TTFB): responseStart - requestStart\n数据传输耗时: responseEnd - responseStart\nDOM 解析耗时: domInteractive - responseEnd\n资源加载耗时: loadEventStart - domContentLoadedEventEnd\nFirst Byte时间: responseStart - domainLookupStart\n白屏时间: responseEnd - fetchStart\n首次可交互时间（TTI）: domInteractive - fetchStart\nDOM Ready 时间: domContentLoadEventEnd - fetchStart\n页面完全加载时间: loadEventStart - fetchStart\nhttp 头部大小： transferSize - encodedBodySize\n重定向次数：performance.navigation.redirectCount\n重定向耗时: redirectEnd - redirectStart\n比如说，如果我们想要获取 TTI参数，代码可以这样写：\n1 2 3 4 5 6 7 8 9 10 // 计算一些关键的性能指标 window.addEventListener(\u0026#39;load\u0026#39;, (event) =\u0026gt; { // Time to Interactive let timing = performance.getEntriesByType(\u0026#39;navigation\u0026#39;)[0]; console.log(timing.domInteractive); console.log(timing.fetchStart); let diff = timing.domInteractive - timing.fetchStart; console.log(\u0026#34;TTI: \u0026#34; + diff); // 打印 TTI 参数 }) 观察长任务 1 2 3 4 5 6 7 const observer = new PerformanceObserver((list) =\u0026gt; { for (const entry of list.getEntries()) { console.log(entry) } }) observer.observe({entryTypes: [\u0026#39;longtask\u0026#39;]}) 页面可见性的状态监听 使用场景举例：\n比如说，我们正在做一个视频网站（或者游戏页面）。如果用户当前没有在看这个视频，而是切换别的页面了。此时，我们可以对视频做节流等处理，避免造成性能的浪费。等用户再回到当前页面之后，再恢复之前的状态。 当设备进入待机模式时（用户按下电源键关闭屏幕），网站想要关闭设备声音。 针对这种场景，我们可以使用visibilitychange进行监听：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 见面可见性的状态监听 let vEvent = \u0026#39;visibilitychange\u0026#39;; if (document.webkitHidden != undefined) { // webkit prefix detected vEvent = \u0026#39;webkitvisibilitychange\u0026#39;; } function visibilityChanged() { if (document.hidden || document.webkitHidden) { console.log(\u0026#34;Web page is hidden.\u0026#34;) } else { console.log(\u0026#34;Web page is visible.\u0026#34;) } } document.addEventListener(vEvent, visibilityChanged, false); 网络状况监听 使用场景举例：\n高清图片按需加载：如果用户的网络条件较好，就加载高清图片资源；如果网络条件不好，就加载文件较小的图片资源。 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 var connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection; var type = connection.effectiveType; function updateConnectionStatus() { // type是之前的网络状态，connection.effectiveType是当前最新的网络状态 console.log(\u0026#34;Connection type changed from \u0026#34; + type + \u0026#34; to \u0026#34; + connection.effectiveType); type = connection.effectiveType; } connection.addEventListener(\u0026#39;change\u0026#39;, updateConnectionStatus); 打印结果举例：\n1 Connection type changed from 4g to 3g 检测元素的可见状态，做曝光埋点 我们可以通过IntersectionObserver：这个API来检测元素的可见状态：\n做曝光上报的埋点：判断某个DOM（或者某个楼层）是否出现在视窗中，出现了就收集数据上报给服务端。\n本质就是要计算某一元素和另一元素（视窗）的相对位置/相对可视状态，然后进行一些操作（一般是上报给服务端）。\n参考：\n前端埋点之曝光实现 点击埋点和曝光卖点的封装 ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/01-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8C%87%E6%A0%87/","summary":"性能指标和优化目标之：加载 性能指标：我们在性能优化过程中可以参考的标准。这些标准都是业界或者前人总结出来的指导性经验。我们可以参考这些指标，","title":"前端性能分析工具和指标"},{"content":"前言 渲染机制包括的内容：\n什么是DOCTYPE及作用\n浏览器渲染过程。面试经常会问：在浏览器中输入url，发生了哪些事情。其中有一部就是浏览器的渲染过程。\nReflow：重排。面试官问完了渲染机制，一般会紧接着问重排Reflow，你可千万别说你没听过。\nRepaint：重绘\nLayout：布局。这里的Layout指的是浏览器的Layout。\n什么是DOCTYPE及作用 定义 DTD（Document Type Definition）：文档类型定义。\n是一系列的语法规则，用来定义XML或者(X)HTML文件类型。浏览器会使用DTD来判断文本类型，决定使用何种协议来解析，以及切换浏览器模式。（说白了就是：DTD就是告诉浏览器，我是什么文档类型，你要用什么协议来解析我）\nDOCTYPE：用来声明DTD规范。\n一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出现一些差错。（说白了，DOCTYPE就是用来声明DTD的）\n常见的DOCTYPE声明有几种 面试官紧接着会问，常见的 DOCTYPE 有哪些，以及 HTML5 的 DOCTYPE 怎么写。\n1、HTML 4.01 Strict：（严格的）\n1 \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 4.01//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/strict.dtd\u0026#34;\u0026gt; PS：该DTD包含所有的HTML元素和属性，但不包括展示性的和弃用的元素（比如 font、u下划线等，这些是被废弃了的）。\n2、HTML 4.01 Transitional：（传统的）\n1 \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 4.01 Transitional//EN\u0026#34; \u0026#34;http://www.w3.org/TR/html4/loose.dtd\u0026#34;\u0026gt; PS：该DTD包含所有的HTML元素和属性，但包括展示性的和弃用的元素（比如 font、u下划线等）。\n3、HTML 5：\n1 \u0026lt;!DOCTYPE html\u0026gt; 总结：\n面试时，不会让你写出 HTML 4.01的写法，因为大家都记不住。但是要记住 HTML 5 的写法，别看它简单，知道的人还真不多。\n面试时，可以这样回答： HTML 4.01 中有两种写法，一种是严格的，一种是传统的；并且答出二者的区别。 HTML 5的写法是\u0026lt;!DOCTYPE html\u0026gt;。\n浏览器的渲染过程 渲染树 上方图片的来源：Google 官方 | 渲染树构建、布局及绘制\n渲染树包含了网页中有哪些节点、节点的从属关系、以及节点的CSS样式（大小、颜色等）。\n浏览器下载完html文档之后，第一步是先将其解析成文本。而html标签是由一对一对的尖括号表述的，可以被浏览器解析为有含义的标记。这些标记被翻译成节点对象，存放到链型数据结构中。这些节点被称之为DOM对象，这个链型数据结构就是渲染树。\n渲染过程（重要） 浏览器的渲染过程非常复杂，面试时找重点说就行，不然太耗时间。如何快速简洁地描述清楚，是关键。来看看下面这张图。\n渲染过程中，涉及到以下几个概念：\nDOM树（DOM Tree）：浏览器将HTML标签解析成树形的数据结构。DOM树包含了有哪些节点，以及节点之间的从属关系（嵌套关系）。\nCSSOM（CSS Rule Tree）：浏览器将CSS解析成树形的数据结构。CSSOM包含了节点的CSS样式（大小、颜色等）。\n渲染树（Render Tree）: DOM 树与 CSSOM 树合并后形成渲染树。渲染树只包含渲染网页所需的节点（但并不知道位置）。\n布局（Layout）: 计算出每个节点在屏幕中的位置和大小。\n绘制（Painting）：按照算出来的规则，通过显卡，把内容画出来。\ncomposite：合成。浏览器在绘制的时候，一开始不会把所有的内容都画在同一层上。需要把这些内容画在不同的曾上，最终合并到一起，并显示在屏幕上。\n参考链接：\n浏览器渲染原理及流程 关键渲染路径 说到渲染，就不得不提到“关键渲染路径”，它描述的是渲染从触发到绘制的过程。浏览器渲染经历了五个阶段：\nJavaScript/CSS \u0026ndash;\u0026gt; Style \u0026ndash;\u0026gt; Layout \u0026ndash;\u0026gt; Paint \u0026ndash;\u0026gt; Composite\n上方图片的来源：https://developers.google.com/web/fundamentals/performance/rendering\n关键渲染路径描述的是渲染从触发到绘制的全过程，一共经历了五个阶段：\n（1）触发视觉的变化：通过JS、CSS代码来触发页面上的视觉变化。比如通过 jQuery添加节点、通过CSS添加动画，都可以触发视觉上的变化。\n（2）Style：浏览器对样式进行计算。匹配选择器，计算哪些CSS受到了影响。\n（3）layout：同上一段。\n（4）painting：同上一段。\n（5）conmposite：同上一段。\n理论上，上面的五个步骤都是必须要经历的。布局和绘制是关键渲染路径中，最重要、开销最高的两个步骤。\n但是，有些样式并不会影响布局，也不会影响绘制。所以，浏览器对这方面的性能进行了优化，并不一定要经历布局和绘制这两个过程。这就需要我们先了解一下「重排」和「重绘」这两个概念。详见下一段。\n布局/回流/重排 定义 布局 layout：\n渲染对象在创建完成并添加到渲染树时，是将DOM节点和它对应的样式结合起来，并不包含位置和大小信息。\n我们还需要通过 Layout 布局阶段，来计算它们在设备视口(viewport)内的确切位置和大小，计算这些值的过程称为回流、布局或重排（Reflow）。\n参考链接：\n从浏览器渲染原理，浅谈回流重绘与性能优化\n你真的了解回流和重绘吗\n什么时候会触发布局 DOM元素的大小和位置发生变化的时候，会触发布局。\n增加、删除DOM元素\ndisplay: none\n移动元素位置，或是增加动画\n修改CSS样式时（宽高、display 为none等，都是通过css样式来修改的）\noffsetLeft、scrollTop、clientWidth\n修改浏览器窗口大小时（即Resize窗口，移动端没有这个问题），或是滚动的时候，有可能会触发（具体要看浏览器的规则）。\n修改网页的默认字体时（这个很消耗性能）。\n面试总结：\n首先要答出 Reflow 定义；其次，什么时候触发，至少要答出两条。更进一步，面试官可能还会问你怎么避免reflow，这个可以自己去查查。\n绘制/重绘 定义 绘制 paint：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程也称之为 Repaint（重绘制）。\n说白了，页面要呈现的内容，统统画在屏幕上，这就叫 Repaint。\n什么时候触发绘制 DOM改动\nCSS改动\n其实，就是判断当视觉上是否发生变化（无论这个变化是通过DOM改动还是CSS改动）。只要页面显示的内容不一样了，肯定要 Repaint。\n面试总结：\n面试官经常会问：“如何尽量减少Repaint的频率？”\n注意， reflow是问“怎么避免”，repaint是问“怎么减少”。Repaint是无法避免的，否则就成了静态页面了。\n答案：\n（1）如果需要创建多个DOM节点，可以使用DocumentFragment创建完，然后一次性地加入document。（加一个节点，就repaint一次，不太好）\n（2）将元素的display设置为”none”，完成修改后再把display修改为原来的值。\n参考链接：如何减少浏览器repaint和reflow ?\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/02-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/","summary":"前言 渲染机制包括的内容： 什么是DOCTYPE及作用 浏览器渲染过程。面试经常会问：在浏览器中输入url，发生了哪些事情。其中有一部就是浏览器的","title":"浏览器渲染机制"},{"content":"浏览器的渲染机制 我们需要先理解浏览器的渲染经历了哪些过程，才能有针对性的进行相关优化。\n掌握浏览器的渲染优化，可以说是前端工程师的一个分水岭。如果想要具备架构师的思维，需要达到什么样的能力？不光是要解决当下的问题，还需要掌握基本的原理，将来在遇到新问题时也能解决，即“预测问题”。\n有一个经典的面试题是：“在浏览器的地址栏输入url，回车后，经历了哪些过程？”这个问题并不简单，根据你回答的详细程度，可以看出你对前后端知识的掌握程度。你能否答出“浏览器的渲染机制”？如果不能，说明你对浏览器渲染的性能优化，不够了解。\n关于浏览器的渲染机制，可以看本教程的另外一篇文章：\n《前端面试/面试必看/浏览器渲染机制.md》\n关键渲染路径举例：\n避免布局抖动（layout thrashing） 1、尽量避免 重排：\n比如说，如果想改变一个元素的位置，很多人可能会使用相对布局的left、top属性，但是这个属性会引起重排。我们可以使用 transfrom:translate让元素做位移，这个属性既不会触发重排，也不会触发 重绘，只会触发 conmposite。\n再比如说，vue、react这样的框架，采用了虚拟DOM，它会把涉及到DOM修改的操作积攒起来，然后统一计算，批量处理，最后应用到真正的DOM上。\n2、读写分离。建议先批量读（获取位置等信息），然后再批量做写操作（修改位置）。\n补充：\n如果你的页面经常需要做重排、重绘，就很容易导致“页面抖动”。\n很多时候，我们知道原理和解决方案。但是在工程化实践的时候，往往时间很紧，没有时间去做这些事情。我们希望有一些拿来就可以用的、而且经过测试没有问题的工具，来帮我们解决问题。\nFastDom是用于做防抖的一个比较流行的解决方案。\n减少重绘（repaint） 防抖（Debounce）：降低事件的触发频率 我们可以针对高频事件做防抖。\n高频事件处理函数：有很多事件的触发频率非常高，甚至超过了屏幕的刷新率（60帧/秒）。比如页面滚动、鼠标移动、移动端的touch事件。\n如果我们不对这些事件做处理，就会频繁导致浏览器做重排、重绘，影响性能，导致页面卡顿，也就是“抖动”。因此需要对这些高频事件处理函数做防抖处理，降低它们的触发频率。\n比如说滚动事件：我其实并不关心滚动中间的过程，我只关心最终滚动到了哪里。\nrequestAnimationFrame 这个api可以做防抖。\n参考文章：\n防抖与节流：https://juejin.cn/post/6885250789825052679 代码优化 JS的开销 静态资源有很多种：js、图片、css、字体等。这些资源都有可能会很大，但是JS的开销仍然是最昂贵的，因为JS除了加载资源之外，还需要经历解析\u0026amp;编译、执行的过程。\n如何缩短JS的解析事件 Web loading is a Journey V8引擎 补充 首屏尽快打开，剩下的内容延迟加载，减少初次加载的资源量。首屏的内容是可以确定的。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/03-%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/","summary":"浏览器的渲染机制 我们需要先理解浏览器的渲染经历了哪些过程，才能有针对性的进行相关优化。 掌握浏览器的渲染优化，可以说是前端工程师的一个分水岭。","title":"渲染优化"},{"content":"图片格式和应用场景 JPEG 格式 JPEG（Joint Photographic Experts Group）是一种针对彩色照片而广泛使用的有损压缩图形格式，属于位图。\n常用文件扩展名为.jpg，也有 .jpeg和.jpe。JPEG 在互联网上常被应用于存储和传输照片。\n适合：颜色丰富的照片、彩色图大焦点图、通栏 banner 图；结构不规则的图形。\n不适合：线条图形和文字、图标图形，因为它的压缩算法不太这些类型的图形；并且不支持透明度。\nPNG 格式 PNG（Portable Network Graphics）是一种无损压缩的位图图形格式，支持索引、灰度、RGB 三种颜色方案以及 Alpha 通道等特性。\nPNG 最初是作为替代 GIF 来设计的，能够显示 256 色，文件比 JPEG 或者 GIF 大，但是 PNG 非常好的保留了图像质量。支持 Alpha 通道的半透明和透明特性。最高支持 24 位彩色图像（PNG-24）和 8 位灰度图像（PNG-8）。\n适合：纯色、透明、线条绘图，图标；边缘清晰、有大块相同颜色区域；需要带半透明的图片。\n适合：由于是无损存储，所以不太适合体积太大的彩色图像\n比如说，如果你需要带透明背景的图片，此时就可以用 png 格式的图。\nGIF 格式 GIF（Graphics Interchange Format）是一种位图图形格式，以 8 位色（即 256 种颜色）重现真彩色的图像，采用 LZW 压缩算法进行编码。\n支持 256 色；仅支持完全透明和完全不透明；如果需要带动画效果的图片，GIF 是比较通用的选择。\n适合：动画，图标。\n不适合：每个像素只有 8 比特，不适合存储彩色图片。\nWebp 格式 Webp 是一种现代图像格式，可为图像提供无损压缩和有损压缩，这使得它非常灵活。由 Google 在购买 On2 Technologies 后发展出来，以 BSD 授权条款发布。\nWebp的优秀算法能同时保证图像质量和较小体积；可以插入多帧，实现动画效果；可以设置透明度；采用 8 位压缩算法。\n无损的 Webp 比 PNG 小 26%，有损的 Webp 比 JPEG 小 25-34％，比 GIF 有更好的动画。\n适合：适用于图形和半透明图像。 总结 banner图、大图，可以用 jpg、webp格式。\n图标、带透明背景的图，可以用 png 格式。\n带动画效果的图，可以用 gif 格式。\n图片优化的常见方法 1、用工具压缩图片 压缩 PNG 图片：\n工具：node-pngquant-native\n介绍：跨平台、压缩比特别高，压缩png24非常好。\n安装方法：\n1 npm install node-pngquant-native 压缩 JPEG 图片：\n工具：jpegtran\n官网：https://www.npmjs.com/package/jpegtran\n介绍：跨平台，但压缩的比率只有80-90%。\n安装方法：\n1 npm install –g jpegtran 使用方法：\n1 jpegtran -copy none -optimize -outfile output_file.jpg input_file.jpg 压缩 GIF 图：\n工具：Gifsicle\n官网（含安装方法）：https://www.lcdf.org/gifsicle/\n介绍：Gifsicle 通过改变每帧比例，减小 gif文件大小，同时可以使用透明来达到更小的文件大小，是目前公认的最好的解决方案。\n使用方法：\n1 2 3 4 5 # 压缩命令。注意，这里是将压缩级别设置为3。如果将压缩级别设置为1或者2，则基本不压缩。 gifsicle --optimize=3 -o out_file.gif in_file.gif # 裁掉透明部分 gifsicle --optimize=3 --crop-transparency -o out_file.gif in_file.gif 2、将图片尺寸跟随网络环境进行变化 具体方案：不同网络环境（Wifi/4G/3G）下，加载不同尺寸和像素的图片，通过在图片 URL 中添加参数来改变。\n图片 url 举例1：（图片的原始url链接）\n1 https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg 图片 url 举例2：（通过图片的url参数，将这张图的尺寸设置为200px）\n1 https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg 3、响应式图片 方法1：通过 JavaScript 绑定事件，检测窗口大小，以此设置图片大小。\n方法2：CSS媒体查询。\n代码举例：（在 640px的窗口大小里，设置图片的尺寸为640px）\n1 2 3 4 5 @media screen and (max-width:640px) { my_image{ width:640px; } } 方法3：img标签的 srcset 属性。这个是 H5的新特性。\n代码举例：\n1 2 \u0026lt;img srcset=\u0026#34;img-320w.jpg, img-640w.jpg 2x, img-960w.jpg 3x\u0026#34; src=“img-960w.jpg” alt=“img”\u0026gt; （x 描述符：表示图像的设备像素） 4、逐步加载图像：lazyload、LQIP、LQIP 方法1、使用统一占位符。俗称图片的懒加载（lazyload）。\n方法2、使用 LQIP 的图片加载方式。也就是说，在大图没有完全加载出来的情况下，先这张图对应的的低质量图片进行占位。\nLQIP（Low Quality Image Placeholders）：低质量图像占位符。这种技术背后的想法是，在网络环境较差的情况下，你可以尽快向用户展示完全可用的网页，为他们提供更好的体验。即使在更好的网络连接上，这仍然为用户提供了更快的可用页面，并且改善了体验。\n安装 LQIP 工具：npm install lqip\nGitHub源码：https://github.com/zouhir/lqip-loader\n代码举例：（将目标图片转换为 LQIP 形式的图）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const lqip = require(\u0026#39;lqip\u0026#39;); //文件路径 const file = \u0026#39;./in.png\u0026#39;; //将输入的图片转为base64 lqip.base64(file).then(res =\u0026gt; { // 色值 console.log(res); }); lqip.palette(file).then(res =\u0026gt; { //这里输出的是base64的图片地址 console.log(res); }); 另外，我们还可以使用 SQIP 的图片加载方式。\nSQIP（SVG Quality Image Placeholders）： SVG 格式的图像占位符。\n安装 SQIP 工具：npm install sqip\nGitHub 源码：https://github.com/axe312ger/sqip\n代码举例：（将目标图片转换为 SQIP 形式的图）\n1 2 3 4 5 6 7 8 const sqip = require(\u0026#39;sqip\u0026#39;); const result = sqip({ filename: \u0026#39;./input_file.png\u0026#39;, numberOfPrimitives: 10 //可根据不同应用场景设置大小 }); console.log(result.final_svg); 5、雪碧图（Image spriting） 雪碧图是比较常见的图片优化方式，也就是把多张小图合并成一张大图。这样的话，就只需做一次网络请求，减少图片的 http 请求次数。\n读者们可以自行查阅。\n6、有些场景下，并不需要图片文件 有些场景下，并不需要图片，我们可以用其他的方式来代替图片。\n举例：\nWeb Font 代替图片\n使用 Data URI 代替图片。base64就是属于 Data URI的方式。\n7、在服务器端进行图片自动优化 图片服务器自动化优化是可以在图片 URL 链接上增加不同特殊参数，服务器自动化生成。通过这些参数，可以设置图片的不同格式、大小、质量。\n常见处理方式：\n图片裁剪：按长边、短边、填充、拉伸等缩放。\n图片格式转换：支持 JPG，GIF，PNG，WebP 等，支持不同的图片压缩率。\n图片处理：添加图片水印、高斯模糊、重心处理、裁剪边框等。\nAI 能力：鉴黄、涉政、智能抠图、智能排版、智能配色、智能合成等 AI 功能。\n图片举例：\n比如JD公司的图片链接，就会在服务器端做优化处理。通过修改图片链接中的参数，就能自动达到相应的优化效果。\n原始图片链接：\n1 https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg 将图片压缩为 200*150：\n1 https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg 将图片转换为 webp 格式：\n1 https://img12.360buyimg.com/img/s200x200_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.webp 将图片质量压缩至10%：\n1 https://img12.360buyimg.com/img/s3866x3866_jfs/t1/149913/14/18648/719436/5fd8b9b5Eb697b825/7c23f3028aff8e2b.jpg.q10 HTML优化 1、精简 HTML 代码 减少 HTML 的嵌套。\n减少 DOM 节点数。\n减少无语义代码（比如: 消除浮动，其实可以用css来处理）。\n删除 http 或者 https：如果URL的协议头和当前页面的协议头一致的，或者此 URL 在多个协议头都是可用的，则可以考虑删除协议头。\n删除多余的空格、换行符、缩进和不必要的注释。\n省略冗余标签和属性。\n使用相对路径的 URL。\n2、文件放在合适位置 CSS 样式文件链接尽量放在页面头部。 CSS 加载不会阻塞 DOM tree 解析，但是会阻塞 DOM Tree 渲染，也会阻塞后面 JS 执行。\n任何 body 元素之前，可以确保在文档部分中解析了所有 CSS 样式（内联和外联），从而减少了浏览器必须重排文档的次数。\n如果放置页面底部，就要等待最后一个 CSS 文件下载完成，此时会出现\u0026quot;白屏\u0026quot;，影响用户体验。\nJS 引用放在 HTML 底部 防止 JS 在加载、解析、执行时，阻塞了页面后续元素的正常渲染。\n4、增强用户体验 设置 favicon.ico 网站如果不设置 favicon.ico，控制台会报错。另外页面加载过程中如果没有图标，则会出现 loading 过程，也不利于记忆网站品牌，建议统一添加。\n增加首屏必要的 CSS 和 JS 页面如果需要等待所的依赖的 JS 和 CSS 加载完成才显示，则在渲染过程中页面会一直显示空白，影响用户体验，建议在首屏增加必要的 CSS 和 JS，比如页面框架背景图片或者loading 图标，内联在 HTML 页面中。这样做，首屏能快速显示出来，缓解用户焦虑。现在很多网页在初始化的时候，流行做骨架屏，小伙伴们也可以研究下。\nCSS优化 1、提升 CSS 渲染性能 谨慎使用 expensive 属性，这类属性比较耗浏览器的性能。比如：nth-child 伪类；position: fixed 定位。\n尽量减少样式的层级数。\n比如：div ul li span i {color: blue;}这样的层级就太深了。建议给 i 标签设置 class属性，然后通过class直接设置样式属性，可以提升浏览器的查询效率。\n尽量避免使用占用过多 CPU 和内存的属性。比如：text-indnt:-99999px。\n尽量少使用耗电量大的属性。比如：CSS3 3D transforms、CSS3 transitions、Opacity 这样的属性会消耗GPU。\n2、合适使用 CSS 选择器 尽量避免使用 CSS 表达式。 比如 background-color: expression( (new Date()).getHours()%2 ? \u0026quot;#FFF\u0026quot; : \u0026quot;#000\u0026quot; );这个属性的意思是，每间隔两小时，改变白景色。\n尽量避免使用通配选择器。 比如 body \u0026gt; a {font-weight:blod;}这样的属性，可能会把 body 里所有的标签遍历一遍，才找到 a 标签，比较耗时。\n尽量避免类正则的属性选择器：*=， |=， ^=， $= 3、提升 CSS 文件加载性能 使用外链的 CSS。 我们知道，内联的 css 是在html 内部写的。相比之下，外链的 CSS文件是放在CDN上的，可以缓存，既能减少 html 页面的体积大小，也能利用缓存减少资源的请求。\n尽量避免使用 @import 方法 整个CSS加载完成后，浏览器会把 import 中所有依赖的文件全部加载完成后，浏览器才会接着往下渲染。这个过程会阻塞CSS文件的加载过程。\n4、精简 CSS 代码 使用缩写语句 删除不必要的零。比如 0.2 可以写成 .2 删除不必要的单位，比如 0px 可以写成 0 删除过多的空格；注释言简意赅 尽量减少样式表的大小 5、合理使用 Web Fonts 将字体文件部署在 CDN 上。 或者将字体以 base64 形式保存在 CSS 中并通过 localStorage 进行缓存 Google 字体库因为某些不可抗拒原因，应该使用国内托管服务 6、CSS 动画优化 尽量避免同时出现过多动画。 延迟动画初始化：让其他的重要的CSS样式优先渲染。 结合 SVG。 JavaScript 总体优化 JavaScript 变量和函数优化 尽量使用 id 选择器 尽量避免使用 eval 使用事件节流函数 使用事件委托 JavaScript 动画优化 避免添加大量 JavaScript 动画\n尽量使用 CSS3 动画\n尽量使用 Canvas 动画\n合理使用 requestAnimationFrame 动画代替 setTimeout、setInterval\nrequestAnimationFrame可以在正确的时间进行渲染，setTimeout（callback）和setInterval（callback）无法保证 callback 回调函数的执行时机。\n合理使用缓存 合理缓存 DOM 对象\n缓存列表长度\n使用可缓存的 Ajax\nJavaScript 缓存优化 Cookie 通常由浏览器存储，然后将 Cookie 与每个后续请求一起发送到同一服务器。收到HTTP 请求时，服务器可以发送带有 Cookie 的 header 头。可以给 Cookie 设置有效时间。\n应用：\n会话管理：登录名，购物车商品，游戏得分或服务器应要记录的其他任何内容\n个性化：用户首选项，主题或其他设置\n跟踪：记录和分析用户行为，比如visitkey\nsessionStorage 创建一个本地存储的键/值对。\n应用：\n缓存。\n页面应用页面之间传值。\nLocalStorage 本地存储。\n应用于：\n缓存静态文件内容 JavaScript /CSS（比如百度M站首页） 缓存不常变更的 API 接口数据 储存地理位置信息 浏览在页面的具体位置 JavaScript 模块化加载方案和选型 CommonJS 旨在 Web 浏览器之外为 JavaScript 建立模块生态系统。Node.js 模块化方案受 CommonJS。\nAMD (Asynchronous Module Definition)（异步模块定义）规范。 RequireJS 模块化加载器：基于 AMD API 实现。\nCMD（ Common Module Definition）（通用模块定义）规范。 SeaJS 模块化加载器：遵循 CMD API 编写。\nES6 import。 减少回流和重绘重要举措 CSS 避免过多样式嵌套\n避免使用 CSS 表达式\n使用绝对定位，可以让动画元素脱离文档流\n避免使用 table 布局\n尽量不使用 float 布局\n图片最好设置好 width 和 height\n尽量简化浏览器不必要的任务，减少页面重新布局\n使用 Viewport 设置屏幕缩放级别\n避免频繁设置样式，最好把新 style 属性设置完成后，进行一次性更改\n避免使用引起回流/重绘的属性，最好把相应变量缓存起来\nJavaScript 最小化回流和重排：为了减少回流发生次数，避免频繁或操作 DOM，可以合并多次对 DOM 修改，然后一次性批量处理。\n控制绘制过程和绘制区域：绘制过程开销比较大的属性设置应该尽量避免减少使用；同时，减少绘制区域范围。\nDOM 编程优化的⽅式方法 控制 DOM 大小 众所周知，页面交互卡顿和流畅度很大一部分原因就是页面有大量 DOM 元素。想象一下，从一个上万节点的 DOM 树上，使用 querySelectorAll 或 getElementByTagName 方法查找某一个节点，是非常耗时的。另外元素绑定事件，事件冒泡和事件捕获的执行也会相对耗时。\n通常控制 DOM 大小的技巧包括：\n合理的业务逻辑\n延迟加载即将呈现的内容\n简化 DOM 操作 对DOM节点的操作统一处理后，再统一插入到 DOM Tree中。\n可以使用 fragment，尽量不在页面 DOM Tree 里直接操作。\n现在流行的框架 Angular、React、Vue 都在使用虚拟 DOM 技术，通过 diff 算法简化和减少 DOM 操作。\n静态文件压缩工具介绍 HTML 压缩工具：\nhtml-minifier：https://www.npmjs.com/package/html-minifier CSS 压缩工具：\nclean-css：https://www.npmjs.com/package/clean-css JavaScript 压缩工具：\nuglify-js：https://www.npmjs.com/package/uglify-js\n使用方法：uglifyjs in.js -o out.js\n静态⽂文件打包⽅方案 公共组件拆分\n压缩： JavaScript /CSS/图片\n合并： JavaScript /CSS 文件合并，CSS Sprite\nCombo： JavaScript /CSS 文件\n静态⽂文件版本号更新策略 缓存更新：CDN 或 ng 后台刷新文件路径，更新文件header头。\n文件 name.v1-v100.js：\n大功能迭代每次新增一个大版本，比如由 v1 到 v2\n小功能迭代新增加 0.0.1 或者 0.1.0，比如从 v1.0.0 至 v1.0.1\n年末 ng 统一配置所有版本 302 至最新版\n时间戳.文件 name.js：以每次上线时间点做差异。\nhash.文件。以文件内容 hash 值做 key。\n前端构建工具介绍和选型建议 常用构建工具 Gulp：通过流（Stream）来简化多个任务间的配置和输出，配置代码相对较少。\nWebpack：预编译，中间文件在内存中处理，支持多种模块化，配置相对很简单。\nFIS\nwebpack 打包优化 定位体积大的模块\n删除没有使用的依赖\n生产模式进行公共依赖包抽离\n开发模式进行 DLL \u0026amp; DllReference 方式优化\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E4%BC%98%E5%8C%96/","summary":"图片格式和应用场景 JPEG 格式 JPEG（Joint Photographic Experts Group）是一种针对彩色照片而广泛使用的有损压缩图形格式，属于位图。 常用文件扩展名为.jp","title":"静态资源优化"},{"content":"浏览器渲染过程 浏览器解析 HTML，生成 DOM Tree（Parse HTML）。\n浏览器解析 CSS，生成 CSSOM（CSS Object Model）Tree。\nJavaScript 会通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree，浏览器将 DOM Tree 和 CSSOM Tree 合成渲染树（Render Tree）。\n布局（Layout）：根据生成的 Render Tree，进行回流，以计算每个节点的几何信息（位置、大小、字体样式等等）。\n绘制（Painting）：根据渲染树和回流得到的几何信息，得到每个节点的绝对像素。\n展示（Display）：将像素发送给图形处理器（GPU），展示在页面上。\n页面渲染技术方案总览 服务端渲染：\n后端同步渲染、同构直出、BigPipe。 客户端渲染：\nJavaScript 渲染：静态化、前后端分离、单页面应用\nWeb App：React、Vue、PWA\nHybrid App：PhoneGap 、AppCan 等\n跨平台开发：RN 、Flutter 、小程序等。\n原生 App：iOS 、Android\n建议：\n依赖业务形式、依赖团队规模、依赖技术水平。 静态化技术方案 静态化是使动态化的网站生成静态 HTML 页面以供用户更好访问的技术，一般分为纯动态化和伪动态化。\n技术优势：\n提高了页面访问速度，降低了服务器的负担，因为访问页面时不需要每次去访问数据库。\n提高网站内容被搜索引擎搜索到的几率，因为搜索引擎更喜欢静态页面。\n网站更稳定，如果后端程序、数据库出现问题，会直接影响网站的正常访问，而静态化页面有缓存，更不容易出现问题。\n技术不足：\n服务器存储占用问题，因为页面量级在增加，要占用大量硬盘空间。\n静态页面中的链接更新问题会有死链或者错误链接问题。\n技术实现：\n跑定时任务，将已有的动态内容进行重定，生成静态的 HTML 页面。\n利用模板技术，将模板引擎中模板字符替换为从数据库字段中取出来的值， 同时生成 HTML 文件。\n协作方式：\n前端统一写好带有交互的完整静态页面。\n后端拆分出静态页面文件，并嵌套在后端模板文件中。\n选型建议：后端研发人员充分，又需要考虑用户体验、服务器负载的业务。\n前后端分离技术与实现 前后端分离是指研发人员分离、业务代码分离、后端实现业务接口，前端渲染页面。\n技术实现：\n后端只负责功能接口实现，提供按照约定的数据格式并封装好的 API 接口。\n前端负责业务具体实现，获取到 API 接口数据后，进行页面模板拼接和渲染，独立上线。\n协作方式：\n前端负责实现页面前端交互，根据后端 API 接口拼装前端模板。\n后端专注于业务功能实现和 API 接口封装。\n技术优势：\n团队更加专注\n提升了开发效率\n增加代码可维护性\n技术架构：\n后端架构：Java、C++、PHP、 + Nginx，使用微服务（比如 Dubbo 等）等实现业务的解耦，所有的服务使用某种协议提供不同的服务（比如 JSF 等） 。\n前端架构：使用 Angular、React、Vue 前端框架并部署页面至 CDN。\n前端架构 2：使用 Angular、React、Vue 前端框架并部署在 Node Server。\n技术不足：\n因为前端需要负责一大部分业务逻辑实现，和服务端同步、静态化，需要前端人力非常多。\n页面数据异步渲染，不利于 SEO，搜索引擎更喜欢纯静态页面。\n选型建议：\n这是大型互联网公司正在采用的开发模式，一句话，如果考虑用户体验，以及前端人力够用，就可以积极采用。 单页面应用技术方案 单页应用（single-page application，缩写 SPA），通过动态重写当前页面，来与用户交互，而非传统的从服务器重新加载整个新页面。这种方法在使用过程中不需要重新加载页面，避免了页面之间切换打断用户体验，使应用程序更像一个桌面应用程序。\n技术优点：\n不错的加载速度：用户往往感觉页面加载非常快，因为一进入页面就能看到页面元素；\n良好的交互体验：进行局部渲染，避免不必要的页面间跳转和重复渲染；\n前后端职责分离：前端进行页面交互逻辑，后端负责业务逻辑；\n减轻服务器负载：服务器只处理数据接口输出，不用考虑页面模板渲染和 HTML 展示。\n技术缺点：\n开发成本相对较高\n首次页面加载时间过多\nSEO 难度比较大\n技术实现：\n使用 React、Vue 框架可以很好的。 BigPipe 简介和工作模式 BigPipe 通过将页面加载到称为 Pagelet 的小部件中，来加快页面渲染速度，并允许浏览器在 PHB 服务器呈现页面的同时，一直请求页面不同区块的结构，类似一个“流”传输管道。\n技术实现：\n浏览器从服务器请求页面。\nServer 迅速呈现一个包含 标记的页面框架，以及一个包含空 div 元素的主体，这些元素充当 Pagelet 的容器。由于该页面尚未完成，因此与浏览器的 HTTP 连接保持打开状态。\n浏览器将开始下载 bigpipe.js 文件，然后它将开始呈现页面。\nPHP 服务器进程仍在执行，并且一次构建每个 Pagelet 。Pagelet 完成后，其结果将在\u0026lt;script\u0026gt; BigPipe.onArrive（…）\u0026lt;/ script\u0026gt; 标记内发送到浏览器。\n浏览器将收到的 html 代码注入正确的位置。如果小页面需要任何 CSS 资源，则也将下载这些 CSS 资源。\n接收完所有的页面集之后，浏览器将开始加载那些页面集所需的所有外部 JavaScript 文件。\n下载 JavaScript 后，浏览器将执行所有内联 JavaScript。\n同构直出技术方案 一套代码既可以在服务端运行又可以在客户端运行，这就是同构（Universal）。\n技术优势：\n性能: 降低首屏渲染时间\nSEO: 服务端渲染对搜索引擎的爬取有着天然的优势\n兼容性: 有效规避客户端兼容性问题，比如白屏\n代码同构：直接上线两个版本，利于灾备。\n技术实现：\nnext.js：服务器端渲染 React 组件框架（参考查看：https://nextjs.org/）, React 采用 ReactDOMServer 调用 renderToString() 方法。\ngatsbyjs：服务端 React 渲染框架（参考查看： https://www.gatsbyjs.org/）。\nnuxt.js：服务器端渲染 Vue 组件框架（参考查看：https://nuxtjs.org/）, Vue 采用 vue-server-renderer 调用 renderToString() 方法。\n协作方式：\n后端专注于业务功能实现和 API 接口封装。\n前端负责实现页面前端交互，根据后端 API 接口拼装前端模板，页面渲染，以及服务器维护。\n选型建议：\n前端要处理 Node server 的机器环境、代码部署、日志、容灾、监控等以往后端人员需要具备运维知识，前端人员的综合能力要求会比以往要高。\n前端项目开发周期变长了，需要事先和产品、运营沟通排期问题。\nPWA 技术方案和实现思路 Progressive Web App，简称 PWA，PWA 应用是使用特定技术和标准模式来开发的 Web 应用，这将同时赋予它们 Web 应用和原生应用的特性。\n技术优势：\n用户可以用手机屏幕启动应用，即使在离线状态或者弱网下，通过事先缓存的资源，也可正常加载运行当前应用，可以完全消除对网络的依赖，从而给用户非常可靠的体验。\n因为预先缓存了资源，部分资源无须经过网络，即秒开页面。\n和移动设备上的原生应用一样，具有沉浸式的用户体验。\n可以给用户发送离线推送消息。\n技术实现：\n全站改造成 HTTPS，没有 HTTPS 就没有 Service Worker。\n应用 Service Worker 技术提升性能，离线提供静态资源文件，提升首屏用户体验。\n使用 App Manifest。\n最后可以考虑离线消息推送等功能。\n浏览器兼容性：\nServiceWorkerGlobalScope API：88%\nWeb App Manifest 83%\n页面加载策略优化 懒加载\n预加载\n预渲染\n按需加载\n下面具体展开讲讲。\n懒加载 懒加载也叫延迟加载，指的是长网页中延迟加载特定元素（可以是图片，也可以是 JS/CSS 文件，当然也可以是 JavaScript 的特定函数和方法，以下简称“懒加载元素”）。\n好处：可以减少当前屏无效资源的加载。\n技术实现举例：把页面上“懒加载元素”src 属性设置为空字符，把真实的 src 属性写在 data-lazy 属性中，当页面滚动的时候监听 scroll 事件，如果“懒加载元素”在可视区域内，就把图片的 src 属性或者文件 URL 路径设置成 data-lazy 属性值。\n预加载 可以使用预加载让浏览器来预先加载某些资源（比如图片、JS/CSS/模板），而这些资源是在将来才会被使用到的。简单来说，就是将所需资源提前加载到浏览器本地，这样后面在需要使用的时候就可以直接从浏览器缓存中取了，而不用再重新开始加载。\n使用场景：如果你希望这个资源能尽快显示给用户，就可以使用预加载。\n好处：减少用户后续加载资源等待的时间。\n技术实现举例：\nHTML 标签： 1 \u0026lt;img src=\u0026#34;https://xxx.jpg\u0026#34; style=\u0026#34;display: none\u0026#34; /\u0026gt; 2、使用 Image 对象：\n1 2 3 const image = new Image(); image.src = \u0026#39;https://xxx.jpg\u0026#39;; 3、使用 preload、prefetch 和 preconnect：\n1 2 3 4 5 6 7 \u0026lt;link rel=“preload” href=“src/style.css” as=“style”\u0026gt; \u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;scr/image.png\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;https://my.com\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;preconnect\u0026#34; href=\u0026#34;https://my.com\u0026#34; crossorigin /\u0026gt; 预渲染 有一种预加载组件的方式就是提前渲染它。在页面中渲染组件，但是并不在页面中展示。也就是渲染完成后，先隐藏起来，用的时候再展示。\n实现举例：\n1 \u0026lt;link rel=\u0026#34;prerender\u0026#34; href=\u0026#34;https://my.com\u0026#34; /\u0026gt; 按需加载 常规按需加载（如 JS 原生、jQuery）\n不同 App 按需加载（如 JS-SDK 脚本文件）\n不同设备按需加载（如 PC 端和 HTML5 端样式文件）\n不同分辨率按需加载（CSS Media Query）\nReact 异步加载举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 const componentA = (location, callback) =\u0026gt; { require.ensure( [], (require) =\u0026gt; { callback(null, require(\u0026#39;modules/componentA\u0026#39;)); }, \u0026#39;componentA\u0026#39; ); }; const componentB = (location, callback) =\u0026gt; { require.ensure( [], (require) =\u0026gt; { callback(null, require(\u0026#39;modules/componentB\u0026#39;)); }, \u0026#39;componentB\u0026#39; ); }; \u0026lt;Router history={history}\u0026gt; \u0026lt;Route path=\u0026#34;/\u0026#34; component={App}\u0026gt; \u0026lt;Route path=\u0026#34;componentA\u0026#34; getComponent={componentA}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;Route path=\u0026#34;componentB\u0026#34; getComponent={componentB}\u0026gt;\u0026lt;/Route\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Router\u0026gt;; Vue 异步加载举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import Vue from \u0026#39;vue\u0026#39;; import App from \u0026#39;./App.vue\u0026#39;; import VueRouter from \u0026#39;vue-router\u0026#39;; Vue.use(VueRouter); const componentA = resolve =\u0026gt; require([\u0026#39;src/a.vue\u0026#39; ], resolve); const componentB = resolve =\u0026gt; require([\u0026#39;src/b.vue\u0026#39; ], resolve); const router = new VueRouter({ routes: [{path:\u0026#34;a”,name:\u0026#34;/a”,component:componentA}, {path:\u0026#34;b”,name:\u0026#34;/b”,component:componentB}] }) new Vue({ el: \u0026#39;#app\u0026#39;, router: router, render: h =\u0026gt; h(App) }) 接口服务调用优化 1、接口合并：一个页面的众多业务接口和依赖的第三方接口，合并为一个部署在集群的接口统一调用，以减少页面接口请求数。\n2、接口上 CDN：主要基于接口性能考虑，我们可以把不需要实时更新的接口同步至 CDN，等此接口内容变更之后自动同步至 CDN 集群上。如果一定时间内未请求到数据，会用源站接口再次请求。\n3、接口域名上 CDN：增强可用性、稳定性。\n4、接口降级：核心接口进行降级用基础接口进行业务实现，比如千人千面的推荐接口，在大促时间点可以直接运营编辑的数据。另外如果接口无访问，建议使用兜底数据。\n5、接口监控：监控接口成功率，不只是常说的 TP99，也包括弱网、超时、网络异常、网络切换等一段情况的监控情况。排查出来问题后，需要联合后端、运维、网络岗位人员一并解决。\n接口缓存策略优化 1、Ajax/fetch 缓存：前端请求时候带上 cache，依赖浏览器本身缓存机制。\n2、本地缓存：异步接口数据优先使用本地 localStorage 中的缓存数据。\n3、多次请求：接口数据本地无 localStorage 缓存数据，重新再次发出 ajax 请求。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","summary":"浏览器渲染过程 浏览器解析 HTML，生成 DOM Tree（Parse HTML）。 浏览器解析 CSS，生成 CSSOM（CSS Object Model）Tree。 JavaScript 会","title":"页面渲染性能优化"},{"content":"ES6 模块与 CommonJS 模块有什么异同？\nES6 Module 和 CommonJS 模块的区别：\nCommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变，类似 const； import 的接⼝是 read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS 对重新赋值（改变指针指向），但是对 ES6 Module 赋值会编译报错。\nES6 Module 和 CommonJS 模块的共同点：\nCommonJS 和 ES6 Module 都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。\n四、ES6 Module ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。\n1 2 3 4 5 6 7 8 9 10 11 12 /** 定义模块 math.js **/ var basicNum = 0; var add = function (a, b) { return a + b; }; export { basicNum, add }; /** 引用模块 **/ import { basicNum, add } from \u0026#39;./math\u0026#39;; function test(ele) { ele.textContent = add(99 + basicNum); } 如上例所示，使用import命令的时候，用户需要知道所要加载的变量名或函数名。其实ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号。这也更趋近于ADM的引用写法。\n1 2 3 4 5 6 7 8 /** export default **/ //定义输出 export default { basicNum, add }; //引入 import math from \u0026#39;./math\u0026#39;; function test(ele) { ele.textContent = math.add(99 + math.basicNum); } ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。\nAMD\nexport.defaults={} require(\u0026lsquo;xxxx\u0026rsquo;)\nES6\nexport default { aaaa， bbbb }\nimport xxxx form \u0026ldquo;xxxx文件\u0026rdquo;\nxxxx.aaaa() xxxx.bbbb()\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/common.js-%E4%B8%8E-es6-module/","summary":"ES6 模块与 CommonJS 模块有什么异同？ ES6 Module 和 CommonJS 模块的区别： CommonJS 是对模块的浅拷⻉，ES6 Module 是对模块的引⽤，即 ES6 Module 只存只读，不能改变其值，也就是指针指向不能变","title":"Common.js 与 ES6 Module"},{"content":"js执行机制 说出结果并说出why 这道题考察的是，js的任务执行流程，对宏任务和微任务的理解\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 console.log(\u0026#34;start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;setTimeout1\u0026#34;); //入宏任务1 }, 0); (async function foo() { console.log(\u0026#34;async 1\u0026#34;); await asyncFunction(); console.log(\u0026#34;async2\u0026#34;); // 入微任务2 })().then(console.log(\u0026#34;foo.then\u0026#34;)); async function asyncFunction() { console.log(\u0026#34;asyncFunction\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;setTimeout2\u0026#34;); // 入宏任务2 }, 0); new Promise((res) =\u0026gt; { console.log(\u0026#34;promise1\u0026#34;); res(\u0026#34;promise2\u0026#34;); }).then(console.log); //// 入微任务1 } console.log(\u0026#34;end\u0026#34;); start =\u0026gt; async 1 =\u0026gt; asyncFunction =\u0026gt; promise1 =\u0026gt; foo.then =\u0026gt; end =\u0026gt; promise2 =\u0026gt; async2 =\u0026gt; setTimeout1 =\u0026gt; setTimeout2 提示：\nscript标签算一个宏任务所以最开始就执行了 async await 在await之后的代码都会被放到微任务队列中去 开始执行：\n最开始碰到 console.log(\u0026ldquo;start\u0026rdquo;); 直接执行并打印出 start 往下走，遇到一个 setTimeout1 就放到宏任务队列 碰到立即执行函数 foo， 打印出 async 1 遇到 await 堵塞队列，先 执行await的函数 执行 asyncFunction 函数， 打印出 asyncFunction 遇到第二个 setTimeout2， 放到宏任务队列 new Promise 立即执行，打印出 promise1 执行到 res(\u0026ldquo;promise2\u0026rdquo;) 函数调用，就是Promise.then。放到微任务队列 asyncFunction函数就执行完毕， 把后面的打印 async2 会放到微任务队列 然后打印出立即执行函数的then方法 foo.then 最后执行打印 end 开始执行微任务的队列 打印出第一个 promise2 然后打印第二个 async2 微任务执行完毕，执行宏任务 打印第一个 setTimeout1 执行第二个宏任务 打印 setTimeout2、 就此，函数执行完毕 ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/js-%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%BE%AE%E4%BB%BB%E5%8A%A1/","summary":"js执行机制 说出结果并说出why 这道题考察的是，js的任务执行流程，对宏任务和微任务的理解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25","title":"js 执行机制 宏任务微任务"},{"content":"1. this指向问题 1.1 this永远指向最后调用它的那个对象 1 2 3 4 5 6 7 8 9 10 严格模式下 var name = \u0026#34;windowsName\u0026#34;; function a() { var name = \u0026#34;Cherry\u0026#34;; console.log(this.name); // windowsName console.log(\u0026#34;inner:\u0026#34; + this); // inner: Window } a(); //类似于 window.a() console.log(\u0026#34;outer:\u0026#34; + this) // outer: Window 1.2 匿名函数this永远指向window对象 2. 如何改变 this 指向 2.1 箭头函数 箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var name = \u0026#34;windowsName\u0026#34;; var a = { name : \u0026#34;Cherry\u0026#34;, func1: function () { console.log(this.name) }, func2: function () { setTimeout( () =\u0026gt; { //这里使用箭头函数 this.func1() },100); } }; a.func2() // Cherry 2.2 that / _this 先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var name = \u0026#34;windowsName\u0026#34;; var a = { name : \u0026#34;Cherry\u0026#34;, func1: function () { console.log(this.name) }, func2: function () { var _this = this; //通过_this替换 this指向 setTimeout( function() { _this.func1() },100); } }; a.func2() // Cherry 2.3 call、apply、bind apply 和 call 的区别 其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。\n1 2 3 4 5 fun.call(thisArg[, arg1[, arg2[, ...]]]) fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。\n1 2 3 4 5 6 7 8 9 10 11 12 var a ={ name : \u0026#34;Cherry\u0026#34;, fn : function (a,b) { console.log( a + b) } } var b = a.fn; b.call(a,1,2) // 3 b.apply(a,[1,2]) // 3 bind bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。\n1 2 3 4 5 6 7 8 9 10 var a ={ name : \u0026#34;Cherry\u0026#34;, fn : function (a,b) { console.log( a + b) } } var b = a.fn; b.bind(a,1,2) //没有输出 b.bind(a,2,3)() //3 //因为bind创建一个新的函数，需要手动调用 拓展： 没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的\n1 2 3 4 5 6 7 8 9 10 11 var name = \u0026#34;windowsName\u0026#34;; function fn() { var name = \u0026#39;Cherry\u0026#39;; innerFunction(); function innerFunction() { console.log(this.name); // windowsName } } fn() //this 指向 window 匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。 其次虽然匿名函数不能被其他对象调用，但是可以被其他函数调用，比如例 7 中的 setTimeout。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var name = \u0026#34;windowsName\u0026#34;; var a = { name : \u0026#34;Cherry\u0026#34;, func1: function () { console.log(this.name) }, func2: function () { setTimeout( function () { this.func1() },100 ); } }; a.func2() // this.func1 is not a function ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/4-this%E6%8C%87%E5%90%91applycallbind/","summary":"1. this指向问题 1.1 this永远指向最后调用它的那个对象 1 2 3 4 5 6 7 8 9 10 严格模式下 var name = \u0026#34;windowsName\u0026#34;; function a() { var name = \u0026#34;Cherry\u0026#34;; console.log(this.name); // windowsName console.log(\u0026#34;inner:\u0026#34; + this); // inner: Window } a(); //类似于","title":"this指向、apply、call、bind"},{"content":"什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。\n广义的跨域：\n1 2 3 1.) 资源跳转： A链接、重定向、表单提交 2.) 资源嵌入： \u0026lt;link\u0026gt;、\u0026lt;script\u0026gt;、\u0026lt;img\u0026gt;、\u0026lt;frame\u0026gt;等dom标签，还有样式中background:url()、@font-face()等文件外链 3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 什么是同源策略？ 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指\u0026quot;协议+域名+端口\u0026quot;三者相同，即便两个不同的域名指向同一个ip地址，也非同源。\n1 2 3 Cookie、LocalStorage 和 IndexDB 无法读取 2.) DOM 和 Js对象无法获得 3.) AJAX 请求不能发送 常见跨域场景 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 URL 说明 是否允许通信 http://www.domain.com/a.js http://www.domain.com/b.js 同一域名，不同文件或路径 允许 http://www.domain.com/lab/c.js http://www.domain.com:8000/a.js http://www.domain.com/b.js 同一域名，不同端口 不允许 http://www.domain.com/a.js https://www.domain.com/b.js 同一域名，不同协议 不允许 http://www.domain.com/a.js http://192.168.4.12/b.js 域名和域名对应相同ip 不允许 http://www.domain.com/a.js http://x.domain.com/b.js 主域相同，子域不同 不允许 http://domain.com/c.js http://www.domain1.com/a.js http://www.domain2.com/b.js 不同域名 不允许 各跨域方案区别 1 2 3 4 5 jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源； CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求； Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，适合前后端分离的前端项目调后端接口。 document.domain+iframe适合主域名相同，子域名不同的跨域请求。 postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+。 1、jsonp （ 缺点：只能实现get一种请求） 1.）jquery ajax：\n1 2 3 4 5 6 7 $.ajax({ url: \u0026#39;http://www.domain2.com:8080/login\u0026#39;, type: \u0026#39;get\u0026#39;, dataType: \u0026#39;jsonp\u0026#39;, // 请求方式为jsonp jsonpCallback: \u0026#34;handleCallback\u0026#34;, // 自定义回调函数名 data: {} }); 2.）vue.js：\n1 2 3 4 5 6 this.$http.jsonp(\u0026#39;http://www.domain2.com:8080/login\u0026#39;, { params: {}, jsonp: \u0026#39;handleCallback\u0026#39; }).then((res) =\u0026gt; { console.log(res); }) 2、跨域资源共享（CORS） 设置Access-Control-Allow-Origin 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。\n需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。\n1）、 前端设置： 原生ajax\n1 2 // 前端设置是否带cookie xhr.withCredentials = true; 示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookie xhr.withCredentials = true; xhr.open(\u0026#39;post\u0026#39;, \u0026#39;http://www.domain2.com:8080/login\u0026#39;, true); xhr.setRequestHeader(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/x-www-form-urlencoded\u0026#39;); xhr.send(\u0026#39;user=admin\u0026#39;); xhr.onreadystatechange = function() { if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { alert(xhr.responseText); } }; 2）、 服务端设置： 若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。\n1.）Java后台：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */ // 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加\u0026#39;/\u0026#39; response.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;http://www.domain1.com\u0026#34;); // 允许前端带认证cookie：启用此项后，上面的域名不能为\u0026#39;*\u0026#39;，必须指定具体的域名，否则浏览器会提示 response.setHeader(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头 response.setHeader(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;Content-Type,X-Requested-With\u0026#34;); 2.）Nodejs后台示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 var http = require(\u0026#39;http\u0026#39;); var server = http.createServer(); var qs = require(\u0026#39;querystring\u0026#39;); server.on(\u0026#39;request\u0026#39;, function(req, res) { var postData = \u0026#39;\u0026#39;; // 数据块接收中 req.addListener(\u0026#39;data\u0026#39;, function(chunk) { postData += chunk; }); // 数据接收完毕 req.addListener(\u0026#39;end\u0026#39;, function() { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { \u0026#39;Access-Control-Allow-Credentials\u0026#39;: \u0026#39;true\u0026#39;, // 后端允许发送Cookie \u0026#39;Access-Control-Allow-Origin\u0026#39;: \u0026#39;http://www.domain1.com\u0026#39;, // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ \u0026#39;Set-Cookie\u0026#39;: \u0026#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly\u0026#39; // HttpOnly的 3、nginx反向代理接口跨域 1）、 nginx配置解决iconfont跨域 浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。\n1 2 3 location / { add_header Access-Control-Allow-Origin *; } 2）、nginx反向代理接口跨域 跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。\n实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server { listen\t80 #监听80端口，访问域名为www.123.com，不加端口号时默认为80端口 listen *:80 | *:8080 #监听所有80端口和8080端口 listen IP_address\t#监听指定ip地址所有端口 listen port #监听该端口的所有IP连接 server_name www.123.com www.baidu.com; #多个用空格隔开 #访问该域名时会跳转到127.0.0.1:8080路径 #通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端 server_name *.123.com www.123.* #正则表达式，用“~”作为正则表达式字符串的开始标记 #server_name ~^www\\d+\\.123\\.com$; #“~”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个0~9之间的数字，再紧跟“.123.co”，最后跟着“m”($表示结尾) #基于 IP 地址的虚拟主机配置 == 域名匹配 （不考虑通配符和正则表达式） server_name 192.168.1.1 匹配顺序： ①、准确匹配 server_name ②、通配符在开始时匹配 server_name 成功 ③、通配符在结尾时匹配 server_name 成功 ④、正则表达式匹配 server_name 成功 location / { #用于匹配 URL proxy_pass http:127.0.0.1:8080; #用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式 index index.html index.htm index.jsp; #用于设置网站的默认首页 可有多个用空格隔开 index.html index.jsp } } 4、 vue框架的跨域（vue.config.js文件配置） 利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: \u0026#39;/login\u0026#39;, target: \u0026#39;http://www.domain2.com:8080\u0026#39;, // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: \u0026#39;www.domain1.com\u0026#39; // 可以为false，表示不修改 }], noInfo: true } } 扩展知识： nginx 正向代理 代理客户端，反向代理 代理服务器。 1、nginx 正向代理 2、nginx反向代理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 server { listen\t80 #监听80端口，访问域名为www.123.com，不加端口号时默认为80端口 listen *:80 | *:8080 #监听所有80端口和8080端口 listen IP_address\t#监听指定ip地址所有端口 listen port #监听该端口的所有IP连接 server_name www.123.com www.baidu.com; #多个用空格隔开 #访问该域名时会跳转到127.0.0.1:8080路径 #通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端 server_name *.123.com www.123.* #正则表达式，用“~”作为正则表达式字符串的开始标记 #server_name ~^www\\d+\\.123\\.com$; #“~”表示匹配正则表达式，以www开头（“^”表示开头），紧跟着一个0~9之间的数字，再紧跟“.123.co”，最后跟着“m”($表示结尾) #基于 IP 地址的虚拟主机配置 == 域名匹配 （不考虑通配符和正则表达式） server_name 192.168.1.1 匹配顺序： ①、准确匹配 server_name ②、通配符在开始时匹配 server_name 成功 ③、通配符在结尾时匹配 server_name 成功 ④、正则表达式匹配 server_name 成功 location / { #用于匹配 URL proxy_pass http:127.0.0.1:8080; #用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式 index index.html index.htm index.jsp; #用于设置网站的默认首页 可有多个用空格隔开 index.html index.jsp } } Nginx完整配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 user nginx; worker_processes 1; error_log /var/log/nginx/error.log warn; pid /var/run/nginx.pid; events { worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; # include /etc/nginx/conf.d/*.conf; # 引入default.conf配置文件 server { listen 80; server_name www.zhengqing520.com;# 服务器地址或绑定域名 #charset koi8-r; #access_log /var/log/nginx/host.access.log main; # start ------------------------------------------------------------------------------------ location / { root /usr/share/nginx/html; try_files $uri $uri/ @router; index index.html index.htm; # proxy_pass http://zhengqingya.gitee.io; # 代理的ip地址和端口号 # proxy_connect_timeout 600; #代理的连接超时时间（单位：毫秒） # proxy_read_timeout 600; #代理的读取资源超时时间（单位：毫秒） } location @router { rewrite ^.*$ /index.html last; } location ^~ /api { # ^~/api/表示匹配前缀为api的请求 proxy_pass http://www.zhengqing520.com:9528/api/; # 注：proxy_pass的结尾有/， -\u0026gt; 效果：会在请求时将/api/*后面的路径直接拼接到后面 # proxy_set_header作用：设置发送到后端服务器(上面proxy_pass)的请求头值 # 【当Host设置为 $http_host 时，则不改变请求头的值; # 当Host设置为 $proxy_host 时，则会重新设置请求头中的Host信息; # 当为$host变量时，它的值在请求包含Host请求头时为Host字段的值，在请求未携带Host请求头时为虚拟主机的主域名; # 当为$host:$proxy_port时，即携带端口发送 ex: $host:8080 】 proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; # 在web服务器端获得用户的真实ip 需配置条件\t① 【 $remote_addr值 = 用户ip 】 proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; # 在web服务器端获得用户的真实ip 需配置条件② proxy_set_header REMOTE-HOST $remote_addr; # proxy_set_header X-Forwarded-For $http_x_forwarded_for; # $http_x_forwarded_for变量 = X-Forwarded-For变量 } location ^~ /blog/ { # ^~/blog/ 表示匹配前缀为blog/后的请求 proxy_pass http://zhengqingya.gitee.io/blog/; proxy_set_header Host $proxy_host; # 改变请求头值 -\u0026gt; 转发到码云才会成功 proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-NginX-Proxy true; } # end --------------------------------------------------------------------------------------------- #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } } } ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/2-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9Fnginxcors/","summary":"什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1 2 3 1.) 资源跳转： A链接、重定向、表单提交","title":"前端跨域Nginx、CORS"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 任何一个对象都有 _proto_ 属性 ,#这个属性会指向该对象的原型 构造函数 _proto_ 属性下 有contructor 属性 per.__proto__.constructor === per.constructor per.constructor.__proto__ __proto__和constructor ，属性值是当前实例所属类的原型(prototype)。原型对象中有一个属性constructor, 它指向函数对象。 function Person() {} var person = new Person() console.log(person.__proto__ === Person.prototype)//true console.log(Person.prototype.constructor===Person)//true //顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 一、原型 proto 每一个对象数据类型(普通的对象、实例、prototype\u0026hellip;\u0026hellip;)也天生自带一个属性____proto__，除非未赋值\n1、对象的属性__proto__ === 当前实例所属类的原型prototype 对象的属性__proto__ === 当前实例所属类的原型对象（prototype）\nperson.proto === Person.prototype\n2、原型对象中constructor属性 指向函数对象 Person.prototype.constructor === Person\n二、原型链 当我们访问对象的一个属性或方法时，它会先在对象自身中寻找，如果有则直接使用，如果没有则会去原型对象中寻找，如果找到则直接使用。如果没有则去原型的原型中寻找,直到找到Object对象的原型，Object对象的原型没有原型，如果在Object原型中依然没有找到，则返回undefined。\n原型、构造函数、实例，以及原型链 PS：任何一个函数，如果在前面加了new，那就是构造函数。\n原型、构造函数、实例三者之间的关系 1、构造函数通过 new 生成实例\n2、构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性）\n3、原型对象中有 constructor，指向该原型的构造函数。\n上面的三行，代码演示：\n1 2 3 4 5 var Foo = function (name) { this.name = name; } var foo = new Foo(\u0026#39;smyhvae\u0026#39;); 上面的代码中，Foo.prototype.constructor === Foo的结果是true：\n4、实例的__proto__指向原型。也就是说，foo.__proto__ === Foo.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。\nFoo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。\n原型链 原型链的基本原理：任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。\nObject是原型链的顶端。\n原型可以起到继承的作用。原型里的方法都可以被不同的实例共享：\n1 2 3 4 //给Foo的原型添加 say 函数 Foo.prototype.say = function () { console.log(\u0026#39;\u0026#39;); } 原型链的关键：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。\ninstanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。\ninstanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。\n注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。\n注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。\n比如说：\nfoo instance of Foo的结果为true，因为foo.__proto__ === Foo.prototype为true。\nfoo instance of Objecet的结果也为true，因为Foo.prototype.__proto__ === Object.prototype为true。\n但我们不能轻易的说：foo 一定是 由Object创建的实例。这句话是错误的。我们来看下一个问题就明白了。\n分析一个问题 问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？\n分析：这就要用到原型的constructor属性了。\nfoo.__proto__.constructor === Foo的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 任何一个对象都有 _proto_ 属性 ,#这个属性会指向该对象的原型 构造函数 _proto_ 属性下 有contructor 属性 per.__proto__.constructor === per.constructor per.constructor.__proto__ __pr","title":"原型、原型链"},{"content":"同源和跨域 同源 同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。\n跨域问题的解决方案 从我自己的网站访问别人网站的内容，就叫跨域。\n出于安全性考虑，浏览器不允许ajax跨域获取数据。\niframe：处于安全性考虑，浏览器的开发厂商已经禁止了这种方式。\nJSONP：script 标签的 src 属性传递数据。\nJSONP JSONP(JSON with Padding)：带补丁的 json，本质是利用了 \u0026lt;script src=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;标签具有可跨域的特性，由服务端返回一个预先定义好的JS函数的调用，并且将服务器数据以该函数参数的形式传递过来。此方法需要前后端配合完成。\n我们知道， html标签的 src 属性是支持跨域的：\n1 \u0026lt;img src=\u0026#34;http://img.smyhvae.com/2016040101.jpg\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; jsonp 就是利用这个特性实现的跨域，但用的是 script 标签。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- jsonp 就是 利用 src，实现的跨域 用的是 script标签 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#39;http://192.168.141.137/2018-02-28/myData.php\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方那一行的代码，意思是：刷新A服务器上的index页面后，会去请求 B 服务器上的 myData.php 这个页面。而且请求的方式是 get 请求。\n但是 B 服务器上的页面不是你想请求就可以请求的，大家一起配合才可以。\n具体实现步骤：\n需要首先声明的是，jsonp 只能通过 GET 方式进行请求。\n（1）A客户端的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 定义 eatFood()方法 function fn(data) { console.log(\u0026#39;我被调用了哦\u0026#39;); console.log(data); } \u0026lt;/script\u0026gt; \u0026lt;!-- 使用 script标签 发送了 get请求 去到了一个 php页面 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#39;http://192.168.141.137/01.php?callback1=fn\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; 我们来分析上方代码中的最后一行的那个url：A 客户端请求的是 B服务器上的 01.php页面。url里有个callback1=fn，意思是：callback1是A和B 之间的约定，约定后，将执行方法 fn。\n其实，fn方法已经在最后一行代码中执行了。只不过，fn方法里的data数据，是从 B 服务器中获取的。\n（2）B服务器端的代码：\n1 2 3 4 5 6 7 \u0026lt;?php $mycallBack = $_GET[\u0026#39;callback1\u0026#39;]; $arr = array(\u0026#34;zhangsan\u0026#34;,\u0026#34;lisi\u0026#34;,\u0026#34;zhaoliu\u0026#34;); echo $mycallBack.`(`.json_encode($arr).`)`; //字符串拼接 ?\u0026gt; 代码解释：\n第一行的callback1 是A和B之间的约定，二者必须一致。\necho语句中输出的内容，即使要返回给A客户端的内容，此内容会保存在 A 客户端的fn方法的data里。 data[0]指的是 zhangsan。\njson_encode指的是，将php对象转化为 json。\n刷新A页面，输出结果为：\n1 mycallBack([\u0026#34;zhangsan\u0026#34;,\u0026#34;lisi\u0026#34;,\u0026#34;zhaoliu\u0026#34;]) jQuery 中的 JSONP 我们知道，jQuery 中发送 Ajax 请求，格式是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $(\u0026#34;#btn\u0026#34;).click(function(){ $.ajax({ url:\u0026#34;./data.php?callback1=fn\u0026#34;, dataType:\u0026#34;jsonp\u0026#34;, type:\u0026#34;get\u0026#34;, //jsonp:\u0026#34;callback1\u0026#34;, //传递给B服务器的回调函数的名字（默认为 callback） //jsonCallBack:\u0026#34;fn\u0026#34; //自定义的函数名称。默认为 jQuery 自动生成的随机函数名 success:function(data){ alert(data); //$(\u0026#34;#showInfo\u0026#34;).html(data); }, error:function(e){ console.log(e); } }); }); 那如果数据是 JSONP，上方代码则改为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 $(\u0026#34;#btn\u0026#34;).click(function(){ $.ajax({ url:\u0026#34;./data.php?fn\u0026#34;, dataType:\u0026#34;text\u0026#34;, type:\u0026#34;get\u0026#34;, success:function(data){ alert(data); //$(\u0026#34;#showInfo\u0026#34;).html(data); }, error:function(e){ console.log(e); } }); }); 参考链接 参考链接：https://www.cnblogs.com/2050/p/3191744.html\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/04-%E5%90%8C%E6%BA%90%E5%92%8C%E8%B7%A8%E5%9F%9F/","summary":"同源和跨域 同源 同源策略是浏览器的一种安全策略，所谓同源是指，域名，协议，端口完全相同。 跨域问题的解决方案 从我自己的网站访问别人网站的内容，就","title":"同源和跨域"},{"content":"解决方案： 1、媒体查询 百度分辨率统计 ：https://tongji.baidu.com/research/site?source=index#screen\npc端：1920 * 1080\t| 1366 * 768 | 1440 * 900 | 1536 * 864 | 1280 * 720 |\t1600 * 900\n移动端： 360 * 640 414 * 736 375 * 667\n从大到小\n1 2 3 4 5 6 7 8 /*分辨率1400-1600*/ @media screen and (max-width: 1600px){} /*分辨率在1200-1400之间*/ @media screen and (max-width: 1400px){} /*分辨率在900-1200之间*/ @media screen and (max-width: 1200px){} /*分辨率小于900*/ @media screen and (max-width: 900px){} 从小到大\n1 2 3 4 5 6 7 8 9 10 11 12 /*分辨率在300-720之间*/ @media screen and (min-width: 300px){} /*分辨率在720-960之间*/ @media screen and (min-width: 720px){} /*分辨率在960-1024之间*/ @media screen and (min-width: 960px){} /*分辨率在1024-1280之间*/ @media screen and (min-width: 1024px){} /*分辨率在1280-1366之间*/ @media screen and (min-width: 1280px) {} /*分辨率大于1366*/ @media screen and (min-width: 1366px) {} 2、栅格布局 3、配合 vw / % / rem 4、移动端 meta viewport viewport可以优化移动端浏览器的显示。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,initial-scale=1.0,maximum-scale=1.0, user-scalable=no\u0026#34;/\u0026gt; width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素） height：高度（数值 / device-height）（范围从223 到10,000） initial-scale：初始的缩放比例 （范围从\u0026gt;0 到10） minimum-scale：允许用户缩放到的最小比例 maximum-scale：允许用户缩放到的最大比例 user-scalable：用户是否可以手动缩 (no,yes) minimal-ui：可以在页面加载时最小化上下状态栏。（已弃用） 注意，很多人使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果和initial-scale=1同时使用user-scalable=no或maximum-scale=1，则用户将不能放大/缩小网页来看到全部的内容。 补充知识 px、rpx、em、rem 、vw/vh、百分比的区别 1、px 也常被称为 CSS 像素 一个像素表示了计算机屏幕所能显示的最小区域，像素分为两种类型：\n​\tCSS 像素：为 Web 开发者提供，在 CSS 中使用的一个抽象单位，根据屏幕分辨率动态变化\n​\t物理像素：只与设备的硬件密度有关，任何设备的物理像素都是固定的\n​\t转换公式： css像素 = 物理像素 / 分辨率\n1 2 pc端 :1920 * 1080\t设计稿 :1920 * 1080px = 1920 / 1920 =1\t1个css像素（px）= 1个物理像素 ios :375 * 667\t设计稿 :750 * 1334px = 750 / 375 = 2 1个css像素（px）= 2个物理像素 不同的移动设备分辨率不同，1个CSS像素可以表示的物理像素是也不同的。\n2、rpx是微信小程序独有的、解决屏幕自适应的尺寸单位 ​\t可以根据屏幕宽度进行自适应，不论大小屏幕，规定屏幕宽为 750rpx\n3、em 是相对于当前元素的父元素的 font-size 进行计算 相对长度单位，em 是相对于当前元素的父元素的 font-size 进行计算,如果当前元素未设置则相对于浏览器的默认字体尺寸。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div class=\u0026#34;a\u0026#34;\u0026gt;A \u0026lt;div class=\u0026#34;b\u0026#34;\u0026gt;B \u0026lt;div class=\u0026#34;c\u0026#34;\u0026gt;C\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .a{ font-size:16px;} .b{ font-size:2em;} /* 相当于32px */ .c{ font-size:1em;} /* 相当于32px */ \u0026lt;/style\u0026gt; 4、rem 是相对于根元素（html）的 font-size 进行计算 ​\tCSS3 新增的一个相对单位，rem 是相对于根元素（html）的 font-size 进行计算，rem 不仅可设置字体大小，也可以设置元素宽高属性。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;div class=\u0026#34;a\u0026#34;\u0026gt;A \u0026lt;div class=\u0026#34;b\u0026#34;\u0026gt;B \u0026lt;div class=\u0026#34;c\u0026#34;\u0026gt;C\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; html{ font-size:16px;} .a{ font-size:3rem;} /* 相当于48px */ .b{ font-size:2rem;} /* 相当于32px */ .c{ font-size:1rem;} /* 相当于16px */ \u0026lt;/style\u0026gt; 5、vw / vh 相对于视窗的宽度/高度的百分比，视窗是指浏览器内部的可视区域大小 ​\tCSS3 特性 vh 和 vw：\nvh 相对于视窗的高度，视窗高度是100vh vw 相对于视窗的宽度，视窗宽度是100vw 视窗指的是浏览器内部的可视区域大小，即 window.innerWidth/window.innerHeight 大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。\n6、% 相对于直接父元素高度宽度百分比 1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;a\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;b\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;style\u0026gt; .a{ width:200px; height:100px; background-color: aqua; } .b{ width:50%; height:50%; background-color: blueviolet; } \u0026lt;/style\u0026gt; 需要注意的是，如果设置了top、margin、padding等：\n子元素的 top 和 bottom 如果设置百分比，则相对于直接非 static 定位(默认定位)的父元素的高度 子元素的 left 和 right 如果设置百分比，则相对于直接非 static 定位(默认定位的)父元素的宽度 子元素的 padding/margin 如果设置百分比，不论是垂直方向或者是水平方向，都相对于直接父亲元素的 padding/margin ，而与父元素的 height 无关。 总结 px、rpx、em、rem 、vw/vh、百分比的区别？ px：绝对长度单位，来描述一个元素的宽高以及定位信息 rpx：微信小程序独有的、解决屏幕自适应的尺寸单位 em：相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算（浏览器默认16px）em作为字体单位，相对于父元素字体大小；em作为行高单位时，相对于自身字体大小，整个页面内 1em 不是一个固定的值。 rem：相对单位，可理解为”root em”，相对根节点html的字体大小来计算，CSS3新加属性，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小。rem布局的本质是等比缩放，一般是基于宽度，试想一下如果UE图能够等比缩放，那该多么美好啊 vw/vh：viewpoint width / viewpoint height，vw 相对于视窗的宽度，vh 相对于视窗的高度，1vw等于视窗宽度的1% 百分比：1% 对不同属性有不同的含义。font-size: 200% 和font-size: 2em 一样，表示字体大小是默认（继承自父亲）字体大小的2倍。line-height: 200% 表示行高是自己字体大小的 2 倍。width: 100%表示自己 content 的宽度等于父亲 content 宽度的1倍 ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/1-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%80%82%E9%85%8D/","summary":"解决方案： 1、媒体查询 百度分辨率统计 ：https://tongji.baidu.com/research/site?source=index","title":"浏览器兼容适配"},{"content":"浅拷贝（复制数据内存地址，赋值会改变原数据） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var p = { \u0026#34;id\u0026#34;:\u0026#34;007\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;刘德华\u0026#34;, \u0026#34;books\u0026#34;:new Array(\u0026#34;三国演义\u0026#34;,\u0026#34;红楼梦\u0026#34;,\u0026#34;水浒传\u0026#34;)//这是引用类型 } var p2 = {}; for(let key in p){ p2[key] = p[key];\t} p2.books[0] =\u0026#34;四国\u0026#34;; console.log(p2); //books: (3) [\u0026#34;四国\u0026#34;, \u0026#34;红楼梦\u0026#34;, \u0026#34;水浒传\u0026#34;] //id: \u0026#34;007\u0026#34; //name: \u0026#34;刘德华\u0026#34; console.log(p);\t//books: (3) [\u0026#34;四国\u0026#34;, \u0026#34;红楼梦\u0026#34;, \u0026#34;水浒传\u0026#34;] //id: \u0026#34;007\u0026#34; //name: \u0026#34;刘德华\u0026#34; 深拷贝 （复制数据，生成新的内存地址，改变新数据不改变原数据） 1 2 3 4 5 6 7 8 9 10 11 var p3 ={}; for(let key in p){ if(typeof p[key] == \u0026#34;Object\u0026#34;){ p3[key=[]] for(ket q in p[key]){ p3[key][q] = p[key][q] } }else{ p3[key] = p[key] } } 深拷贝封装函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function copy(data){ let tempData = {} for(let key in data){ if(typeof data[key] == \u0026#34;Object\u0026#34;){ tempData[key] = copy(data[key]) }else{ tempData[key] = data[key] } } return tempData } const isObj = (val) =\u0026gt; typeof val === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; val !== null; // 写法1 function deepClone(obj) { // 通过 instanceof 去判断你要拷贝的变量它是否是数组（如果不是数组则对象）。 // 1. 准备你想返回的变量（新地址）。 const newObj = obj instanceof Array ? [] : {}; // 核心代码。 // 2. 做拷贝；简单数据类型只需要赋值，复杂数据类型就再次进入进行深拷贝，直到所找到的数据为简单数据类型为止。 for (const key in obj) { const item = obj[key]; newObj[key] = isObj(item) ? deepClone(item) : item; } // 3. 返回拷贝的变量。 return newObj; } ","permalink":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/3-%E8%B5%8B%E5%80%BC%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/","summary":"浅拷贝（复制数据内存地址，赋值会改变原数据） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var p = { \u0026#34;id\u0026#34;:\u0026#34;007\u0026#34;, \u0026#34;name\u0026#34;:\u0026#34;刘德华\u0026#34","title":"赋值、深拷贝、浅拷贝"},{"content":"MVVM模式 Model：负责数据存储\nView：负责页面展示\nView Model：负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示\n关于框架 为什么要学习流行框架 1、企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱；企业中，使用框架，能够提高开发的效率。\n提高开发效率的发展历程：\n原生JS -\u0026gt; Jquery之类的类库 -\u0026gt; 前端模板引擎 -\u0026gt; Angular.js / Vue.js（能够帮助我们减少不必要的DOM操作；提高渲染效率；双向数据绑定的概念）\n2、在Vue中，一个核心的概念就是：数据驱动，避免手动操作DOM元素。这样的话，可以让前端程序员可以更多的时间去关注数据的业务逻辑，而不是关心 DOM 是如何渲染的了。\n框架和库的区别 框架：\n框架是一套完整的解决方案。\n对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。但是优点也很明显：功能完善、提供了一整套的解决方案。\n库（插件）：\n只是提供某一个小功能。\n对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。\n举例：\n从Jquery 切换到 Zepto\n从 EJS 切换到 art-template\n前端的各种框架 Vue 和 React 的相同点 利用虚拟DOM实现快速渲染\n轻量级\n响应式组件\n支持服务器端渲染\n易于集成路由工具、打包工具以及状态管理工具\nPS：Vue 在国内很受欢迎；React 在国内和国外都很受欢迎，适合做大型网站。\n什么是虚拟 DOM 传统的web开发，是利用 jQuery操作DOM，这是非常耗资源的。\n我们可以在 JS 的内存里构建类似于DOM的对象，去拼装数据，拼装完整后，把数据整体解析，一次性插入到html里去。这就形成了虚拟 DOM。\nVue1.0没有虚拟DOM，Vue2.0改成了基于虚拟DOM。\n前端框架回顾 Vue框架中，没有控制器。\nVue 框架 发展历史 2013年底作为尤雨溪个人实验项目开始开发\n2014年2月公开发布。\n2014年11月发布0.11版本\n2016年10月发布2.0版本。\n相关网址 中文官网\nvuejs官方论坛\nGitHub地址：https://github.com/vuejs/vue\nVue1.0 在线文档：http://v1-cn.vuejs.org/guide/\nVue2.x 在线文档：https://cn.vuejs.org/v2/guide/\nVue1下载地址：http://v1-cn.vuejs.org/js/vue.js\nVue2下载地址：https://cdn.jsdelivr.net/npm/vue/\n上方截图的时间：2018-03-02。\n介绍 Vue 本身并不是一个框架，Vue结合周边生态构成一个灵活的、渐进式的框架。\nVue 以及大型 Vue 项目所需的周边技术，构成了生态。\n渐进式框架图：\nVue框架的特点 模板渲染：基于 html 的模板语法，学习成本低。\n响应式的更新机制：数据改变之后，视图会自动刷新。【重要】\n渐进式框架\n组件化/模块化\n轻量：开启 gzip压缩后，可以达到 20kb 大小。（React 达到 35kb，AngularJS 达到60kb）。\nVue 的环境搭建 我们首先要安装好 NVM、Node.js环境，然后再来做下面的操作。\n常见的插件 Webpack：代码模块化构建打包工具。\nGulp：基于流的自动化构建工具。\nBabel：使用最新的 规范来编写 js。\nVue：构建数据驱动的Web界面的渐进式框架\nExpress：基于 Node.js 平台，快速、开放、极简的 Web 开发框架。\n以上这些包，都可以通过 NPM 这个包管理工具来安装。\n引用 Vue.js 文件 1、方式一：（CDN的方式进行引用）\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2、方式二：（下载 vue.js 文件）\n去网站 https://cdn.jsdelivr.net/npm/vue/ 下载 vue.js 文件，直接放到工程文件里，然后引用。\n3、方式三：（NPM的方式安装vue）\n1 2 # 最新稳定版 $ npm install vue 如果网络不稳定，可以采用下面的方式安装：\n1 cnpm i vue --save 然后在代码中通过下面这种方式进行引用：\n1 import Vue from \u0026#39;vue\u0026#39; 利用 vue-cli 新建一个空的项目 Vue 提供一个官方命令行工具，可用于快速搭建大型单页应用。该工具为现代化的前端开发工作流提供了开箱即用的构建配置。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目。\n官方代码参考 1 2 3 4 5 6 7 npm install -g @vue/cli vue create my-app cd my-app npm run serve 我们根据上方的参考代码，来看看“利用 vue-cli 新建一个空的项目”的步骤。\n安装 vue-cli（命令行工具） 安装命令如下：\n1 2 # 全局安装 vue-cli $ npm install -g @vue/cli 初始化一个 simple 项目 （1）首先执行：\n1 vue create my-app 输入上方命令后，会弹出一个选项：\n如果是初学者，直接选default就行。之后会自动生成一个空的初始化项目，包含了项目目录、以及项目依赖的脚本。\n这个空项目的工程文件如下：（请务必仔细研究这个项目的写法和目录结构）\n2019-06-21-vue-my-app.zip 我们可以看到这个项目的结构：\nsrc：项目源码\n.babelrc：ES6编译插件的配置\nindex.html：单页面的入口\n上方截图中，npm install指的是下载各种依赖包，npm run dev指的是打开发包，npm run build指的是打生产包。\n（2）本地运行项目：\n1 2 3 cd my-app npm run serve 浏览器输入http://localhost:8080/，就可以让这个空的项目在本地跑起来：\n备注：我们在 GitHub上下载的任何Vue有关的项目，第一步都是要首先执行 npm install，安装依赖的 mode_modules，然后再运行。我们发给同事的工程文件，建议不要包含 node_modules。\n构建一个 非 simple 项目 构建一个空的项目，首先执行：\n1 vue create vuedemo2 上图中，选择 Manually select features，然后根据提示依次输入：\nproject name：要求小写。\ndescription：默认即可。\nvue-router：需要。\nESlint：语法检查，初学者可以暂时不需要。\n单元测试：暂时也不需要。\ne2e test：不需要。\n选择 eslint 的配置：\n然后让这个空的项目就可以在浏览器上跑起来。\nvue 项目结构分析 buid：打包配置的文件夹\nconfig：webpack对应的配置\nsrc：开发项目的源码\nApp.vue：入口组件。.vue文件都是组件。 main.js：项目入口文件。 static：存放静态资源\n.babelrc：解析ES6的配置文件\n.editorcofnig：编辑器的配置\n.postcssrc.js：html添加前缀的配置\nindex.html：单页面的入口。通过 webpack打包后，会把 src 源码进行编译，插入到这个 html 里面来。\npackage.json：项目的基础配置，包含版本号、脚本命令、项目依赖库、开发依赖库、引擎等。\n图片的base64编码 默认是10k以下，建议都通过 base64编码。在配置文件webpack.base.conf.js中进行修改：\n1 2 3 4 5 6 7 { test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, loader: \u0026#39;url-loader\u0026#39;, options: { limit: 10000, name: utils.assetsPath(\u0026#39;img/[name].[hash:7].[ext]\u0026#39;) } ","permalink":"https://bablvsj.github.io/posts/tech/wait/11-vue%E5%9F%BA%E7%A1%80/00-vue%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8Cvue-cli/","summary":"MVVM模式 Model：负责数据存储 View：负责页面展示 View Model：负责业务逻辑处理（比如Ajax请求等），对数据进行加工后交给视图展示","title":"00-Vue的介绍和vue-cli"},{"content":"v-on的按键修饰符 Vue 内置的按键修饰符 通俗一点讲，指的是：监听键盘输入的事件。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符。如下：\nVue内置的按键修饰符：\n1 2 3 4 5 6 7 8 9 10 .enter .tab .delete (捕获 “删除” 和 “退格” 键) .esc .space .up .down .left .right 1.0.8+版本：支持单字母的按键别名。 比如说，keyup指的是：键盘（任何键位）抬起时的监听事件。.enter指的是：按enter键的按键修饰符。我们把这两个结合起来看看。\n@keyup.enter举例：按enter键后的监听事件\n@keyup.enter=\u0026quot;addData\u0026quot;表示：按住enter键后，执行addData()方法。全称是v-on:key.enter=\u0026quot;addData\u0026quot;。\n我们还是拿01-04这篇文章中的列表功能来举例。之前是点击“添加”按钮后，列表中会添加一个item。现在要求：在输入框中按enter键后，也能添加一个item。\n核心代码如下：\n1 \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;formData.name\u0026#34; @keyup.enter=\u0026#34;addData\u0026#34;\u0026gt; 注意，如果写成@keyup=\u0026quot;addData\u0026quot;，效果却是：只要键盘的任何键位打了字（还没来得及按enter键），就会执行addData()方法，这种效果显然不是我们想要的。所以要加上修饰符.enter，表示只针对enter键。\n自定义的按键修饰符 如果我们直接在代码的\u0026lt;input\u0026gt;标签里写@keyup.f2=\u0026quot;addData\u0026quot;，那么，按住「F2键」后，是没有效果的，因为「F2键」不是内置的按键修饰符（如果F2不能验证，你可以试一下F7）。\n我们知道，每个按键都有一个键盘码。参考链接：\njs 里面的键盘事件对应的键码 通过查阅，我们知道了「F2键」的键盘码为113，那代码可以这样写：（按住F2键后，执行 addData 方法）\n1 \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;formData.name\u0026#34; @keyup.113=\u0026#34;addData\u0026#34;\u0026gt; 虽然键盘码很全，但是不好记呀。于是，接下来，我们给键盘码定义别名。\n自定义全局按键修饰符：\n1 2 //自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113; 上方代码的书写位置，与自定义全局过滤器的位置，是并列的。\n然后，我们就可以使用键盘码的别名了。\n自定义全局指令 自定义全局指令的举例1 举例1：让指定文本框自动获取焦点\n如果我们想实现这个例子，原生js的写法是：\n1 2 //原生js写法：网页一打开，就让指定的输入框自动获取焦点 document.getElementById(\u0026#39;search\u0026#39;).focus() 代码的位置：\n但我们不建议这样做。我们可以通过Vue中的自定义指令来实现这个例子。步骤如下。\n（1）使用Vue.directive()自定义全局指令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //自定义全局指令 v-focus：让文本框自动获取焦点 //参数1：指令的名称。注意，在定义的时候，指令的名称前面，不需要加 v- 前缀；但是：在`调用`的时候，必须在指令名称前 加上 v- 前缀 //参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive(\u0026#39;focus\u0026#39;, { //在每个函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象（DOM对象） bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，放置 JS行为不生效 }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 } }) 上方的代码中，如果我们把el.focus()这行代码写在bind方法里，是没有效果的（但不会报错）。没有效果是因为，在执行到bind方法的时候，元素还没有插入到dom中去。\n由此可以看看出：bind、inserted、updated这三个钩子函数的执行时机不同，且执行的次数有区别。\n（2）在指定的文本框上加``：\n1 \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search\u0026#34; v-model=\u0026#34;keywords\u0026#34; v-focus\u0026gt; 完整版代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;vue2.5.16.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 搜索框： \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search\u0026#34; v-model=\u0026#34;name\u0026#34; v-focus\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //自定义全局指令 v-focus，让文本框自动获取焦点 //参数1：指令的名称。注意，在定义的时候，指令的名称前面，不需要加 v- 前缀；但是：在`调用`的时候，必须在指令名称前 加上 v- 前缀 //参数2：是一个对象，这个对象身上，有一些指令相关的函数，这些函数可以在特定的阶段，执行相关的操作 Vue.directive(\u0026#39;focus\u0026#39;, { //在每个函数中，第一个参数，永远是 el ，表示 被绑定了指令的那个元素，这个 el 参数，是一个原生的JS对象（DOM对象） bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 // 在元素 刚绑定了指令的时候，还没有 插入到 DOM中去，这时候，调用 focus 方法没有作用 // 因为，一个元素，只有插入DOM之后，才能获取焦点 // el.focus() }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 el.focus() // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 } }) new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;smyhvae\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 自定义全局指令：使用钩子函数的第二个binding参数拿到传递的值 举例2：设置DOM元素的color样式\n参考举例1中的写法，我们可能会这样给DOM元素设置样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;vue2.5.16.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 搜索框： \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search\u0026#34; v-model=\u0026#34;name\u0026#34; v-color\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //自定义全局指令 v-color：设置DOM元素的color属性 Vue.directive(\u0026#39;color\u0026#39;, { bind: function (el) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 el.style.color = \u0026#39;red\u0026#39;; }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 //el.focus() }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 } }) new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如上方代码所示，我们自定义了一个指令v-color，然后在input标签中用上了这个指令，就给元素设置了color属性。但是这个代码有个弊端是：color的属性值在定义指令的时候，被写死了。如何完善呢？我们可以在DOM元素中传参。一起来看看。\n代码如下：【荐】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;vue2.5.16.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; 搜索框1： \u0026lt;input type=\u0026#34;text\u0026#34; id=\u0026#34;search\u0026#34; v-model=\u0026#34;name\u0026#34; v-color=\u0026#34;\u0026#39;green\u0026#39;\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //自定义全局指令 v-color：设置DOM元素的color属性 Vue.directive(\u0026#39;color\u0026#39;, { // 样式，只要通过指令绑定给了元素，不管这个元素有没有被插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 // 意思是说，我们可以把样式的代码写到bind中去（即使这个时候，dom元素还没有被创建） bind: function (el, binding) { // 每当指令绑定到元素上的时候，会立即执行这个 bind 函数，【只执行一次】 console.log(binding.name); //打印结果：color console.log(binding.value); //打印结果：green console.log(binding.expression); //\u0026#39;green\u0026#39; el.style.color = binding.value// 通过bining拿到v-color中传递过来的值 }, inserted: function (el) { // inserted 表示元素 插入到DOM中的时候，会执行 inserted 函数【触发1次】 // 和JS行为有关的操作，最好在 inserted 中去执行，防止 JS行为不生效 //el.focus() }, updated: function (el) { // 当VNode更新的时候，会执行 updated， 【可能会触发多次】 } }) new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;smyhvae\u0026#39; } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中,bind方法里传递的第二个参数binding，可以拿到DOM元素中v-color里填的值。注意，v-color=\u0026quot;'green'\u0026quot;，这里面写的是字符串常量；如果去掉单引号，就成了变量，不是我们想要的。\n效果：\n自定义全局指令的简写形式：\n在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如上面的代码中，我们可以写成简写形式：\n1 2 3 Vue.directive(\u0026#39;color\u0026#39;, function (el, binding) { //注意，这个function等同于把代码写到了 bind 和 update 中去 el.style.color = binding.value }) 自定义私有指令 自定义私有指令：在某一个 vue 对象内部自定义的指令称之为私有指令。这种指令只有在当前vue对象的el指定的监管区域有用。\n代码举例：（设置文字的font-weight属性）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;vue2.5.16.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;span v-fontweight=\u0026#34;600\u0026#34;\u0026gt;生命壹号\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#app\u0026#39;, data: { name: \u0026#39;smyhvae\u0026#39; }, //自定义私有指令 directives: { \u0026#39;fontweight\u0026#39;: { bind: function (el, binding) { el.style.fontWeight = binding.value; } } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n注意， el.style.fontWeight设置属性值，至少要600，否则看不到加粗的效果。\n自定义私有指令的简写形式：\n在很多时候，你可能想在 bind 和 update 时触发相同行为，而不关心其它的钩子。比如上面的代码中，我们可以写成简写形式：\n1 2 3 4 5 6 //自定义私有指令（简写形式） directives: { \u0026#39;fontweight\u0026#39;: function (el, binding) { //注意，这个function等同于把代码写到了 bind 和 update 中去 el.style.fontWeight = binding.value; } } ","permalink":"https://bablvsj.github.io/posts/tech/wait/11-vue%E5%9F%BA%E7%A1%80/01-06.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%89%E9%94%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/","summary":"v-on的按键修饰符 Vue 内置的按键修饰符 通俗一点讲，指的是：监听键盘输入的事件。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符。如下： Vue内置","title":"01-06.自定义按键修饰符\u0026自定义指令"},{"content":"GitHub 排名统计 GitHub 中文排行榜、高分优秀中文项目：https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts\nGitHub 全球排名：https://gitstar-ranking.com/\n这个排名很权威。如果你的项目超过 10k star，就能上榜，跻身全球 GitHub 项目前1000名。\nGitHub trending（官网推荐）：https://github.com/trending 你的项目要是能上 GitHub trending，绝对火得一塌糊涂。\nGitHub 中国区排名：https://githuber.cn/search?language=JavaScript 这个网站虽然比较小众，但排名还是相对比较准的。\nGitHub 中国区排名：http://githubrank.com/ 这个排名很久没更新了，早就不准了；而且还经常打不开。\n资讯 36氪：https://36kr.com/\n虎嗅网：https://www.huxiu.com/\n利器：https://liqi.io/\n采访优秀的创造者，邀请他们来分享工作时所使用的工具。\n湾区日报：https://wanqu.co/ 每天推送 5 篇优质英文文章。\nSolidot：https://www.solidot.org/\n品玩：https://www.pingwest.com/\n极客公园：http://www.geekpark.net/\n框架 Vue.js：https://cn.vuejs.org/\nReact：https://reactjs.org/\nAngular：https://angular.cn/\nAngularJS：https://angularjs.org/\nKoa：https://koa.bootcss.com/\n基于 Node.js 平台的下一代 Web 开发框架。\nExpress：http://www.expressjs.com.cn/ 基于 Node.js 平台，快速、开放、极简的 Web 开发框架。\nEgg：https://eggjs.org/zh-cn/ Egg 继承于 Koa。\nKoa 是一个非常优秀的框架，然而对于企业级应用来说，它还比较基础。而 Egg 选择了 Koa 作为其基础框架，在它的模型基础上，进一步对它进行了一些增强。\nElectron：https://www.electronjs.cn/ Electron（原名为Atom Shell）是GitHub开发的一个开源js框架。 它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。\n也就是说，我们可以用 js 语言开发客户端软件了。其实呢，VS Code 这个客户端软件就是用 js 语言写的。\nRedux：https://www.redux.org.cn/ Redux 是 JavaScript 状态容器，提供可预测化的状态管理。\nReactNative：https://reactnative.cn/ 使用JavaScript编写原生移动应用。\nmpvue：http://mpvue.com/ 基于 Vue.js 的小程序开发框架。\nUI框架 ElementUI：http://element-cn.eleme.io/ 基于 Vue.js 的组件库。\niView：https://www.iviewui.com/ 一套基于 Vue.js 的高质量 UI 组件库。\nAnt Design：https://ant.design 基于 React 的 UI 组件库，主要用于研发企业级中后台产品。官网推出了 Ant Design pro 作为示例，可以看看。\nAnt Design Mobile：https://mobile.ant.design/ 一个基于 Preact / React / React Native 的 移动端 UI 组件库。\nAnt Design of Vue：https://vue.ant.design/docs/vue/introduce-cn/ Ant Design 的 Vue 实现，开发和服务于企业级后台产品。\n类库 jQuery：http://jquery.com/\nZepto.js：https://zeptojs.com/\n可以理解成是移动端的 jQuery。\nECharts：https://echarts.baidu.com/ 使用 JavaScript 实现的开源可视化库。\nCSS Sass：https://sass-lang.com/ Sass 是成熟、稳定、强大的 CSS 扩展语言。入门文档可以看：http://sass.bootcss.com/\nLess：http://lesscss.org/ 给 CSS 加点料。入门文档可以看：https://less.bootcss.com/\nStylus：http://stylus-lang.com/ 构建 NPM：https://www.npmjs.com/\nYarn：https://yarnpkg.com/zh-Hans/\nWebpack：https://webpack.js.org/\nGulp：https://www.gulpjs.com.cn/\nBabel：https://babeljs.io/\nESLint：https://cn.eslint.org/\n可组装的JavaScript和JSX检查工具。\nPostCSS：https://www.postcss.com.cn/ 用 JavaScript 工具和插件转换 CSS 代码的工具\n调试抓包 whistle：https://wproxy.org/whistle/ 代理抓包工具，很好很强大。\nFiddler：https://www.telerik.com/fiddler 代理抓包工具。\nMock数据 Easy Mock：https://www.easy-mock.com 编辑器 \u0026amp;\u0026amp; IDE VS Code：https://code.visualstudio.com/\nSublime Text：https://www.sublimetext.com/\nWebStorm：https://www.jetbrains.com/webstorm/\nAtom：https://atom.io/\n编码规范 Bootstrap编码规范：https://codeguide.bootcss.com/\nes6编程风格：http://es6.ruanyifeng.com/#docs/style\nAirbnb Javascript Style Guide：https://github.com/airbnb/javascript\n静态站点搭建工具 Hexo：https://hexo.io/zh-cn/\nVuePress：https://www.vuepress.cn/\nGitBook：https://www.gitbook.com/\n设计工具 墨刀：原型设计工具。网址：https://modao.cc/\n蓝湖：一款产品文档和设计图的在线协作平台。网址：https://lanhuapp.com\nPxCook（像素大厨）：高效易用的自动标注工具。软件下载链接：https://www.fancynode.com.cn/pxcook\n图标 Font Awesome：http://www.fontawesome.com.cn/\nIconfont：https://www.iconfont.cn/\nicomoon：https://icomoon.io/\nEasyIcon：https://www.easyicon.net/\nicons8：https://icons8.cn/\nIconStore：https://iconstore.co/\niconninja：http://www.iconninja.com/\n设计素材 设优 SHEUI：http://www.sheui.com/Contact/ 工具 综合类 CanIUse：https://caniuse.com/ 浏览器兼容性查询。前端同学必须要知道。\n国家企业信用信息公示系统：http://www.gsxt.gov.cn 通过这个网站，我们可以查到任何一家公司的基本信息（成立时间、法定代表人等）。如果你在这个网站上没有找到某公司的信息，放心吧，这个公司一定是个骗子。\nProcessOn：https://www.processon.com/ 在线制作流程图。推荐。\n幕布：https://mubu.com 极简大纲笔记、一键生成思维导图。非常好用。\nJSON格式化：http://www.bejson.com/\n草料二维码：https://cli.im/\n短链生成：http://www.sina.lt\nGitHub短网址：https://git.io/\n图片压缩：https://tinypng.com/\n熊猫压缩。压缩后图片清晰度不会有太大变化。\n图片压缩：https://www.yasuotu.com/\n在线PS：https://www.photopea.com/\n图片在线裁剪：https://www.asqql.com/gifc/\n多数据源IP地址查询：https://haoip.cn/\nGif添加字幕：http://www.yingjingtu.com/\nPhotoshop的投影参数转换为 CSS代码：https://psd2css.mezw.com/\n将Photoshop设计文件图层中的混合选项参数快速转换为CSS3代码，以节省前端开发人员的时间和精力。\nGet Emoji：https://emoji.svend.cc/\n图片转Ascii：http://picascii.com/\n视频转GIF：https://github.com/vvo/gifify\nOCR文字识别：https://app.xunjiepdf.com/ocr\n图片类 图片转base64：http://imgbase64.duoshitong.com/ 前端周刊 WecTeam 前端周刊：https://github.com/wecteam/weekly\nJs中文网周刊：https://www.javascriptc.com/category/javascript-weekly\n政采云 前端周刊：https://weekly.zoo.team/\n团队 腾讯AlloyTeam：http://www.alloyteam.com/\n腾讯社交用户体验ISUX：https://isux.tencent.com/\n淘宝FED | 淘宝前端团队：http://taobaofed.org/\n阿里巴巴国际UED：http://www.aliued.com/\n京东 | 凹凸实验室：https://aotu.io/\n饿了么前端:https://zhuanlan.zhihu.com/ElemeFE\n百度前端研发部FEX：http://fex.baidu.com/\n360 | 奇舞团：https://75team.com/\n知道创宇FED：https://knownsec-fed.com/\n前端大牛 阮一峰（蚂蚁金服） GitHub：https://github.com/ruanyf\n博客：http://www.ruanyifeng.com/blog/\n尤雨溪 GitHub：https://github.com/yyx990803\n博客：http://blog.evanyou.me/\n知乎：https://www.zhihu.com/people/evanyou\n玉伯 GitHub：https://github.com/lifesinger\n博客：https://github.com/lifesinger/blog\n知乎：https://www.zhihu.com/people/lifesinger\n司徒正美（去哪儿） GitHub：https://github.com/RubyLouvre\n博客：http://www.cnblogs.com/rubylouvre/\n知乎：https://www.zhihu.com/people/si-tu-zheng-mei\n张鑫旭（腾讯） GitHub：https://github.com/zhangxinxu\n博客：https://www.zhangxinxu.com/\n知乎：https://www.zhihu.com/people/iamzhangxinxu\n迷渡 GitHub：https://github.com/justjavac\n知乎：https://www.zhihu.com/people/justjavac.com\n羡辙 | Ovilia GitHub：https://github.com/Ovilia\n知乎：https://www.zhihu.com/people/ovilia\n云谦（陈成） GitHub：https://github.com/sorrycc\n博客：https://sorrycc.com/\n云谦装了啥：https://github.com/sorrycc/awesome-tools\n偏右 GitHub：https://github.com/afc163\n知乎：https://www.zhihu.com/people/afc163\n黄峰达/Phodal Huang（ThoughtWorks） GitHub：https://github.com/phodal\n博客：https://www.phodal.com/\n知乎：https://www.zhihu.com/people/phodal\n贺师俊/Hax（百姓网） GitHub：https://github.com/hax\n博客：http://johnhax.net/\n知乎：https://www.zhihu.com/people/he-shi-jun\n大漠 链接：\nGitHub：https://github.com/airen 大漠的GitHub上没啥东西。\n博客：https://www.w3cplus.com\n知乎：https://www.zhihu.com/people/w3cplus\n介绍：\n常用昵称“大漠”，W3CPlus创始人，目前就职于淘宝。对HTML5、CSS3和CSS处理器等前端脚本语言有非常深入的认识和丰富的实践经验，尤其专注对CSS3和动画的研究，是国内最早研究和使用CSS3和CSS处理器技术的一批人。现在主要在探讨学习JavaScript、React和Vue相关技术知识。CSS、CSS处理器和Web动画中国布道者。2014年出版《图解CSS3：核心技术与案例实战》。\nEGOIST 博客：https://egoist.sh/\nGitHub：https://github.com/egoist\n冴羽 链接：\nGitHub：https://github.com/mqyqingfeng\n博客：https://github.com/mqyqingfeng/Blog\n知乎：https://www.zhihu.com/people/qing-feng-yi-yang\n李靖/小胡子哥（淘宝网） GitHub：https://github.com/barretlee\n博客：https://www.barretlee.com/\n知乎：https://www.zhihu.com/people/barretlee/\ncangdu GitHub：https://github.com/bailicangdu Jackson Tian GitHub：https://github.com/JacksonTian\n博客：http://jacksontian.org/\n题叶（饿了么、前 Teambition） GitHub：https://github.com/jiyinyiyong\n博客：http://tiye.me/\n杨健（今日头条） GitHub：https://github.com/hardfist\n知乎：https://www.zhihu.com/people/hardfist\n流形 （阿里巴巴数据技术与产品部前端团队负责人）\n知乎：https://www.zhihu.com/people/arcthur/ GitHub 作者推荐 晴小篆 GitHub：https://github.com/yanlele MuYunyun GitHub：https://github.com/MuYunyun ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/01-2020%E5%B9%B4web%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E5%AF%BC%E8%88%AA/","summary":"GitHub 排名统计 GitHub 中文排行榜、高分优秀中文项目：https://github.com/kon9chunkit/GitHub-Chinese-Top","title":"01-2020年Web前端最新导航"},{"content":"todo rpc 和 Node.js 的关系\n《吊打面试官》系列 Node.js 全栈秒杀系统\n前言 Node 的重要性已经不言而喻，很多互联网公司都已经有大量的高性能系统运行在 Node 之上。Node 凭借其单线程、异步等举措实现了极高的性能基准。此外，目前最为流行的 Web 开发模式是前后端分离的形式，即前端开发者与后端开发者在自己喜欢的 IDE 上独立进行开发，然后通过 HTTP 或是 RPC 等方式实现数据与流程的交互。这种开发模式在 Node 的强大功能的引领下变得越来越高效，也越来越受到各个互联网公司的青睐。\n前端同学为什么要学习后端/后端同学为什么要学习前端 了解前后端交互流程。\n前端同学能够和后台开发的程序员更佳紧密地结合、更顺畅地沟通。\n当网站的业务逻辑需要前置时，前端人员需要学习一些后台开发的技术，以完成相应的任务；；反过来也一样。\n拓宽知识视野和技术栈，能够站在全局的角度审视整个项目。\n前端同学为什么要学 Node.js 1、Node.js 使用 JavaScript 语言开发服务器端应用，便于前端同学上手（一些公司甚至要求前端工程师掌握 Node.js 开发）。\n2、实现了前后端的语法统一，有利于和前端代码整合，甚至共用部分代码。\n比如说，针对接口返回的各种字段，前后端都必须要做校验。此时，如果用 Node.js 来做后台开发的话，前后端可以共用校验的代码。\n3、Node.js 性能高、生态系统活跃，提供了大量的开源库。\n4、Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。 Jeff Atwood 是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n后端同学为什么要学 Node.js 因为前端同学在学 Node.js。\n什么是 Node.js 官方定义 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O的模型，使其轻量又高效。Node.js 的包管理工具 npm 是全球最大的开源库生态系统。\nNode.js 不是一门语言，也不是 JavaScript 的框架，也不是像Nginx一样的Web服务器 ，Node.js 是 JavaScript 在服务器端的运行环境（平台）。\nNode.js 的组成 在 Node.js 里运行 JavaScript，跟在 Chrome 里运行 JavaScript 有什么不同？\n二者采用的是同样的 JS 引擎。在 Node.js 里写 JS，和在前端写 JS，几乎没有不同。在写法上的区别在于：Node.js 没有浏览器、页面标签相关的 API，但是新增了一些 Node.js 相关的 API。通俗来说，对于开发者而言，在前端写 JS 是用于控制浏览器；而 Node.js 环境写 JS 可以控制整个计算机。\n我们知道，JavaScript 的组成分为三个部分：\nECMAScript\nDOM：标签元素相关的API\nBOM：浏览器相关的API\nECMAScript 是 JS 的语法；DOM 和 BOM 浏览器端为 JS 提供的 API。\n而 Node.js 的组成分为：\nECMAScript。ECMAScript 的所有语法在 Node 环境中都可以使用。\nNode 环境提供的一些附加 API(包括文件、网络等相关的 API)。\n如下图所示：\n补充 与 PHP、JSP、Python、Perl、Ruby 的“既是语言，也是平台”不同，Node.js 的使用 JavaScript 进行编程，运行在 Chrome 的 V8 引擎上。\n与 PHP、JSP 等相比（PHP、JSP、.net 都需要运行在服务器程序上，Apache、Nginx、Tomcat、IIS。 ），Node.js 跳过了 Apache、Naginx、IIS 等 HTTP 服务器，它自己不用建设在任何服务器软件之上。Node.js 的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js 没有 web 容器。\nJS 语言非常灵活，使得它在严谨性方面不如 Java 等传统的静态语言。JS 是一门动态语言，而且融合了面向对象和函数式编程这两种编程范式。\n随着 ES6、ES7 等 JS 语法规范的出现，以及浏览器对这些规范的支持，使得我们可以用更为现代化的 JS 语言特性，来编写现代化的应用。\nNode.js 的架构和依赖 Node.js 的架构如下：\nNode.js 内部采用 Google Chrome 的 V8 引擎，作为 JavaScript 语言解释器；同时结合自行开发的 libuv 库，扩展了 JS 在后端的能力（比如 I/O 操作、文件读写、数据库操作等）。使得 JS 既可以在前端进行 DOM 操作（浏览器前端），又可以在后端调用操作系统资源，是目前最简单的全栈式语言。\n其次，Node 生态系统活跃，提供了大量的开源库，使得 JavaScript 语言能与操作系统进行更多的交互。\nNode.js 运行环境的核心：V8 引擎 和 libuv 库 Node.js 是 JavaScript 在服务器端的运行环境，在这个意义上，Node.js 的地位其实就是 JavaScript 在服务器端的虚拟机，类似于 Java 语言中的 Java 虚拟机。\nV8 引擎 ：编译和执行 JS 代码、管理内存、垃圾回收。V8 给 JS 提供了运行环境，可以说是 JS 的虚拟机。V8 引擎本身是用 C++ 写的。\nlibuv： libuv 是一个专注于异步 I/O 的跨平台类库，目前主要在 Node.js 上使用。它是 Node.js 最初的作者 Ryan Dahl 为 Node.js 写的底层类库，也可以称之为虚拟机。libuv 本身是用 C 写的。\nJava 虚拟机和 V8 引擎，是由同一人开发 Chrome 浏览器成功的背后，离不开 JS 的 V8 引擎。作为虚拟机，V8 的性能表现优异，它的开发者是 Lars Bak。在 Lars 的工作履历里，绝大部分都是与虚拟机相关的工作。在开发 V8 之前，他曾经在 Sun 公司工作，担任 HotSpot 团队的技术领导，主要致力于开发高性能的 Java 虚拟机。在这之前，他也曾为 Self、Smalltalk 语言开发过高性能虚拟机。这些无与伦比的经历让 V8 一出世就超越了当时所有的 JS 虚拟机。\nV8 的性能优势使得用 JavaScript 写高性能后台服务程序成为可能。在这样的契机下，Ryan Dahl 选择了 JavaScript，选择了 V8，在事件驱动、非阻塞 I/O 模型的设计下实现了 Node。\nV8 的内存限制 在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4GB，32 位系统下约为 0.7GB）。在这样的限制下，将会导致 Node 无法直接操作大内存对象。\n造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。V8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在 Node 中，这却限制了开发者随心所欲使用大内存的想法。\nNode 的发展历史 2008 年左右，随着 Ajax 的逐渐普及，Web 开发逐渐走向复杂化，系统化；\nNode.js 诞生于 2009 年，由 Joyent 的员工 Ryan Dahl 开发而成。2009 年 5 月，Ryan Dahl 在 GitHub 中开源了 Node 的最初版本，同年 11 月，在 JSConf 大会上展示了 Node 项目；\n2010 年 1 月，NPM 包管理工具诞生，使得程序员能够更方便地发布和分享 Node.js 的第三方库。\nNode.js 最初只支持 Linux 和 Mac OS 操作系统。2011 年 7 月，微软参与合作，Node.js 终于支持了 Windows 平台。PS：不过，node 的生产环境基本是在 Linux 下。\n目前官网最新版本已经更新到 14.x.x 版本，最新稳定的是 12.18.0。\n据 Node.js 创始人 Ryan Dahl 回忆，他最初希望采用 Ruby，但是 Ruby 的虚拟机效率不行。\n注意：是 Node 选择了 JavaScript，不是 JavaScript 发展出来了一个 Node。\nNode.js 的应用 Node.js 拥有强大的开发者社区，现在已经发展出比较成熟的技术体系，以及庞大的生态。它被广泛地应用在 Web 服务、开发工作流、客户端应用等诸多领域。其中，在 Web 服务领域，业界对 Node.js 的接受程度最高。\n1、BFF 中间层 BFF，即 Backend For Frontend（服务于前端的后端）。玉伯在《从前端技术进化到体验科技》这篇文章中点出了 BFF 层的概念：\nBFF 模式下，整体分工很清晰，后端通过 Java/C++ 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。\n在 Web 服务里，搭建一个中间层，前端访问中间层的接口，中间层再访问后台的 Java/C++ 服务。这类服务的特点是不需要太强的服务器运算能力，但对程序的灵活性有较高的要求。这两个特点，正好和 Node.js 的优势相吻合。Node.js 非常适合用来做 BFF 层，优势如下：\n对于前端来说：让前端有能力自由组装后台数据，这样可以减少大量的业务沟通成本，加快业务的迭代速度；并且，前端同学能够自主决定与后台的通讯方式。\n对于后台和运维来说，好处是：安全性（不会把主服务器暴露在外面）、降低主服务器的复杂度等。\n2、服务端渲染 客户端渲染（CSR / Client side render）：前端通过一大堆接口请求数据，然后通过 JS 动态处理和生成页面结构和展示。优点是前后端分离、减小服务器压力、局部刷新。缺点是不利于 SEO（如果你的页面然后通过 Ajax 异步获取内容，抓取工具并不会等待异步完成后再行抓取页面内容）、首屏渲染慢。\n服务端渲染（SSR / Server Side Render）：服务器返回的不是接口数据，而是一整个页面（或整个楼层）的 HTML 字符串，浏览器直接显示即可。也就是说，在服务器端直接就渲染好了，然后一次性打包返回给前端。优点是有利于 SEO、首屏渲染很快。\n总结： 搜索引擎优化 + 首屏速度优化 = 服务端渲染。\n备注：这里的「服务端渲染」只是让 Node.js 做中间层，不会替代后端的，后台同学请放心。\n参考链接：\nVue 服务端渲染的概念\nhttps://blog.csdn.net/u012036171/article/details/88833200\nhttps://juejin.im/post/5c068fd8f265da61524d2abc\n方应杭\n历史回顾：\n（1）一开始，页面很简单，html 是后端渲染的（比如PHP、ASP、JSP等方式）。后端发现页面中的 js 好麻烦（虽然简单，但是坑多），于是让公司招聘专门写 js 的人，简称「前端切图仔」。\n（2）随着 Node.js 和前端 MVC 的兴起，以及前端越来越复杂，慢慢演变成了「前后端分离」。\n（3）前端的 SPA 应用流行之后，发现 SEO 问题很大，而且首屏渲染速度很慢，但是自己选的路再难走也要走下去，于是用 Node.js 在服务端渲染被看成是一条出路。\n（4）以前在一起的时候，是后端做部分前端的工作；现在在一起的时候，是前端做部分后端的工作。\n3、做小型服务、小型网站的后端（基于 Express、Koa 框架） 现在很多公司的后台管理系统，都是用 Node.js 来开发接口，毕竟，后台管理系统对性能和并发的要求不是太高。有了 Node.js 之后，通过 JS 直接操作 DB，做增删改查，生成接口，极大降低了前端同学的学习门槛。\n当然，有时候做 Node.js 开发，是因为：后台人力不够，所以把后台开发的一部分工作量，转移给前端同学。\n4、做项目构建工具 前端正在广泛使用的构建工具 gulp、Webpack，就是基于 Node.js 来实现的。\n5、 做 PC 端的软件（基于 Electron 框架） Electron 框架就是基于 Node.js 的。也可以说：Electron 是 Node.js 在PC客户端的技术。\n有一点你可能会感到惊讶：程序员们都在用的代码编辑器 VS Code 软件， 就是用 JS 语言实现的。\n还有一个例子是：电子游戏直播网站 Twitch，号称是国外游戏直播的鼻祖，它在 PC 端的客户端软件，就是用 Electron 框架的。你会发现，Twitch 的网站视觉，和 PC 端的视觉，几乎是一样的。如果两端都采用 JS 语言，就可以极大的复用现有的工程。\n知名度较高的 Node.js 开源项目 express：Node.js 中著名的 web 服务框架。\nKoa：下一代的 Node.js 的 Web 服务框架。所谓的“下一代”是相对于 Express 而言的。\nEgg：2016 年，阿里巴巴研发了知名的 Egg.js 开源项目，号称企业级 Web 服务框架。Egg.js 是基于 Koa 开发的。\nmocha：是现在最流行的 JavaScript 测试框架，在浏览器和 Node 环境都可以使用。\nPM2：node 多进程管理。\njade：非常优秀的模板引擎，不仅限于 js 语言。\nCoffeeScript：用简洁的方式展示 JavaScript 优秀的部分。\nAtom：编辑器。\nVS Code：最酷炫的编辑器。\nsocket.io：实时通信框架。\n总结 或许，能用 Node.js 做的后台应用，Java/C++ 也能做；但是 Node.js 可以让我们多一种选择。\n短期来看，Node.js 很难像 Java/C++ 那样，成为后台的主力开发语言。这并非是因为 Node.js 的性能问题，主要是因为，Node.js 还比较年轻，经验积累太少，框架的支持度不够。搞企业级服务，Node.js 敌不过 Java/C++，所以目前只能搞「轻量级」；但未来可期。\n限制语言能力的不是语言本身，而是生态。\n最后一段：前端同学会 Node.js 就真的全栈了吗？ 一个人的精力是有限的，既擅长前端、又精通后端的人，毕竟是极少数。\n林肯说过：“你可以在所有的时间欺骗一部分人，也可以在一段时间欺骗所有的人，但你不可能在所有的时间欺骗所有的人”。\n同样的，我也说过：“你可以在这一段时间擅长前端技术，也可以在另一段时间擅长后台技术，但你不可能在同一段时间同时擅长前端和后台，更不可能在所有的时间同时擅长前端和后台。”\n所谓的全栈，只是一个伪命题。个人不一定需要全栈，企业和项目也不强制要求全栈，分工协作，才最高效。\n对于个人而言，虽然全栈很难，但是 Node.js 的出现，让 JS 语言实现了前后端语法的统一，让 JS 语言的技术栈更佳全面。\n涉及到后台开发相关的技术，无论如何，也绕不开框架设计、开发调试、数据库操作、高并发处理、大规模存储、性能优化、容灾方案、RPC 调用、进程管理、操作系统调度、网络安全、系统运维、日常维护、甚至是 Linux 内核、驱动开发等过硬的知识技能和经验积累。等你亲身经历过这些，才算明白：语言只是一种工具。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/01-node.js%E4%BB%8B%E7%BB%8D/","summary":"todo rpc 和 Node.js 的关系 《吊打面试官》系列 Node.js 全栈秒杀系统 前言 Node 的重要性已经不言而喻，很多互联网公司都已经有大量的高性能系统运行在 Node 之上。Node 凭借其","title":"01-Node.js介绍"},{"content":"虚拟DOM和diff算法 在学习 React 之前，我们需要先了解两个概念：虚拟DOM、diff算法。\n虚拟DOM 问题描述：\n假设我们的数据发生一点点的变化，也会被强制重建整颗DOM树，这么做，会涉及到很多元素的重绘和重排，导致性能浪费严重。\n解决上述问题的思路：\n实现按需更新页面上的元素即可。也就是说，把 需要修改的元素，所对应的 DOM 元素重新构建；其他没有变化的数据，所对应的 DOM 节点不需要被强制更新。\n具体实现方案：（如何按需更新页面上的元素）\n只需要拿到 页面更新前的 内存中的DOM树，同时再拿到 页面更新前的 新渲染出来的 内存DOM树；然后，对比这两颗新旧DOM树，找到那些需要被重新创建和修改的元素即可。这样就能实现 DOM 的按需更新。\n如何拿到这两棵DOM树：（即：如何从浏览器的内存住哪个获取到 浏览器私有的那两颗DOM树？）\n如果要拿到浏览器私有的DOM树，那我们必须调用浏览器提供的相关JS的API才行。但是问题来了，浏览器并没有提供这样的API。既然如此，那我们可以自己模拟这两颗 新旧DOM树。\n如何自己模拟这两颗 新旧DOM树：（即：如何自己模拟一个DOM节点？）\n这里涉及到手动模拟DOM树的原理：使用 JS 创建一个对象，用和这个对象来模拟每一个DOM节点；然后在每个DOM节点中，又提供了类似于 children 这样的属性来描述当前DOM的子节点。这样的话，当DOM节点形成了嵌套关系，就模拟出了一颗 DOM 树。\n总结：\n虚拟DOM的本质：使用 JS 对象模拟DOM树。\n虚拟DOM的目的：为了实现 DOM 节点的高效更新。\nReact内部已经帮我们实现了虚拟DOM，初学者掌握如何调用即可。\ndiff算法 怎么实现 两颗新旧DOM树的对比 呢？这里就涉及到了 diff算法。常见的 diff算法如下：\ntree diff：新旧DOM树，逐层对比的方式，就叫做 tree diff。每当我们从前到后，把所有层的节点对比完后，必然能够找到那些 需要被更新的元素。\ncomponent diff：在对比每一层的时候，组件之间的对比，叫做 component diff。当对比组件的时候，如果两个组件的类型相同，则暂时认为这个组件不需要被更新，如果组件的类型不同，则立即将旧组件移除，新建一个组件，替换到被移除的位置。\nelement diff：在组件中，每个元素之间也要进行对比，那么，元素级别的对比，叫做 element diff。\nkey：key这个属性，可以把 页面上的 DOM节点 和 虚拟DOM中的对象，做一层关联关系。\nReact 介绍 React 是什么 Facebook 开源的一个JS库。\n一个用于动态构建用户界面的JS库。\nReact 的特点 Declarative（声明式编码）\nComponent-Based（组件化编码）\nLearn Once, Write Anywhere（支持客户端、服务器端渲染）\n高效的DOM Diff算法，最小化页面重绘\n单向数据流\nReact高效的原因 虚拟(virtual)DOM，不总是直接操作DOM\n高效的DOM Diff算法，最小化页面重绘（即“局部渲染”）。\n虚拟DOM指的是：在真实DOM的上一层映射一层虚拟DOM。我们操作的是映射关系，而不是真实的DOM。假设页面的样式做了修改（比如新增了一个标签），此时修改的是虚拟DOM的样式，真实的DOM并未发生变化。那什么时候，真实的DOM会发生变化呢？ 当我把所有的内容操作完之后，转化为真实的DOM，此时要打包统一的渲染页面，于是真实的DOM发生变化，然后渲染一次。 这样做的话，可以减少页面的渲染次数。\n相关网址 官网：https://reactjs.org/\nGitHub 地址：https://github.com/facebook/react 截至2019-02-08，React项目已经有 121k 的star。\n官网截图：\n20190208_1057.png\n上方截图中，有一个特性是“Learn Once, Write Anywhere”。这里的 “Anywhere” 其实指的是两个地方：一个是浏览器端，一个是服务器端。后者指的是，React支持在服务器端渲染页面。\n生态介绍 Vue生态：Vue + Vue-Router + Vuex + Axios + Babel + Webpack\nReact生态：React + React-Router + Redux + Axios + Babel + Webpack\nReact 模块化、组件化 模块 理解：向外提供特定功能的js程序, 一般就是一个js文件\n理由：js代码更多更复杂\n作用：简化js的编写，阅读，提高运行效率\n组件 理解：用来实现特定功能效果的代码集合(html/css/js)\n理由：一个界面的功能更复杂\n作用：复用，简化项目编码，提高运行效率\n模块化与组件化 模块化：当应用的js都以模块来编写的, 这个应用就是一个模块化的应用\n组件化：当应用是以多组件的方式实现功能, 这上应用就是一个组件化的应用\n面相对象与面向过程的区别 面向对象编程：\n重点是对象\n更加关心的是干活的人\n面向过程编程：\n更加关心的是干活的过程\n谁去干活儿不关心\nReact 环境搭建：写第一个Hello World react.js 和 react-dom.js 为了通过 React 写一个Hello World程序，我们需要先安装几个包：\nreact.js: React的核心库。这个包，是专门用来创建React组件、组件生命周期等。\nreact-dom.js: 操作DOM的扩展库。这个包，主要封装了和 DOM 操作相关的包（比如，把组件渲染到页面上）。\nbabel.min.js: 将 JSX语法 解析为 纯JS语法代码。\n方式一：本地引入相关的js库 入门的时候，我们建议采取方式一。\n如果是本地引入的话，可以这样写：\n1 2 3 4 \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 如果是通过CDN的方式引入的话，可以使用网站 https://www.bootcdn.cn/ 提供的CDN链接。\n完整代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;myContainer\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; //页面中的真实容器元素 var containDiv = document.getElementById(\u0026#34;myContainer\u0026#34;); //1、创建虚拟DOM对象 var vDom = \u0026lt;div\u0026gt;Hello, React!\u0026lt;/div\u0026gt;; // 不是字符串, 不能加引号 //2、渲染虚拟DOM对象（将虚拟DOM对象渲染到页面元素中） ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 代码运行后，页面上的DOM结构如下：\n1 2 3 \u0026lt;div id=\u0026#34;myContainer\u0026#34;\u0026gt; \u0026lt;div\u0026gt;Hello, React!\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 代码解释：\nrender的中文含义是“渲染”。render 方法的语法如下：\n1 ReactDOM.render(要渲染的虚拟DOM对象, 容器 container：要渲染到页面上的哪个位置); 【工程文件下载】\n2019-02-08-ReactDemo.zip 方式二：npm install 实际开发中，我们一般都是通过 npm install 的方式来安装 react 相关的包。\n首先，新建一个空的文件夹2019-02-08-ReactDemo，作为项目的根目录。然后在根目录下执行如下命令，进行项目初始化：\n1 npm init --yes 上方命令执行完成后，会生成package.json文件。\n然后继续执行如下命令，安装 react.js 和 react-dom.js 这两个包：\n1 npm i react react-dom 完整代码举例：\nindex.html:\nmain.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // JS打包入口文件 import React from \u0026#39;react\u0026#39; import ReactDOM from \u0026#39;react-dom\u0026#39; // 在 react 中，如要要创建 DOM 元素，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素 // React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数 // 参数1： 是个字符串类型的参数，表示要创建的元素类型 // 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性 // 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点 // \u0026lt;div title=\u0026#34;this is a div\u0026#34; id=\u0026#34;mydiv\u0026#34;\u0026gt;这是一个div\u0026lt;/div\u0026gt; var myDiv = React.createElement(\u0026#39;div\u0026#39;, { title: \u0026#39;this is a div\u0026#39;, id: \u0026#39;mydiv\u0026#39; }, \u0026#39;这是一个div\u0026#39;); // ReactDOM.render(\u0026#39;要渲染的虚拟DOM元素\u0026#39;, \u0026#39;要渲染到页面上的哪个位置\u0026#39;); ReactDOM.render(myDiv, document.getElementById(\u0026#39;app\u0026#39;)); 上方代码中，createElement()方法介绍如下：\n1 React.createElement(需要创建的元素类型, 有哪些属性, 子节点) 【工程文件下载】\n2019-02-09-ReactDemo.zip ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/01-react%E4%BB%8B%E7%BB%8D/","summary":"虚拟DOM和diff算法 在学习 React 之前，我们需要先了解两个概念：虚拟DOM、diff算法。 虚拟DOM 问题描述： 假设我们的数据发生一点点的变化，","title":"01-React介绍"},{"content":"WebStorm的简单设置 1、主题修改： 可能大家会觉得软件的界面不太好看，我们可以换一下主题。选择菜单栏“File\u0026ndash;settings\u0026ndash;appearance\u0026ndash;theme”，主题选择 Dracula：\n2、导入第三方主题： 系统提供的两种主题可能都不太好看，我们可以进入网站http://color-themes.com/来获取第三方主题，这里推荐两个主题，大家二选一即可：\nSublime\nMaterial\n上图中，在网站http://color-themes.com/中将主题下载之后，是一个jar包。那怎么导入到WebStorm呢？\n别着急，回到WebStorm，选择菜单栏“ File-Import Settings”，将下载好的jar包导入即可。\n3、代码字体修改： 选择菜单栏“File\u0026ndash;settings\u0026ndash;Editor\u0026ndash;Font”：\n上图中，点击红框部分，然后弹出如下界面：\n我们在上图中修改代码的字体。\n修改完之后发现 WebStorm 的一些默认字体（比如侧边栏的工程目录的字体）并没有发生变化，如果想改的话，也可以改（我个人一般是不改的）。\n4、关闭更新： 如下图所示：\n5、快捷键习惯的修改： 7、配置代码的自动提示： 14、修改文件编码为UTF-8： WebStorm 2017.3.3版本的默认编码方式是 GBK，我们还是统一设置为UTF-8吧，不要坑队友哦：\n新建一个空的项目 配置完成后，可以开始新建一个项目文件夹（站点），项目通常包含如下内容：\n首页：index.html\n样式：css文件夹\nindex.css 相同样式：全局样式、公共样式。起名为：base.css（基本样式）或者 global.css (全局样式) 图片：images文件夹、文件\n特效：js文件夹、js文件\n步骤如下：\n（1）新建一个空的项目： （2）然后新建一个html文件：\n（3）新建一个空的文件夹，命名为css：\n然后在这个css文件夹中，新建样式表：（比如index.css\\base.css）\n（4）最后新建一个images文件夹，用于存放土片。这样的话，一个基本的项目结构就搭建好了：\n接下来，开始运用起你们的前端知识吧。\n（5）如果要新建JS文件的话，操作如下：\n使用技巧 多光标编辑 我们可以按住鼠标不松手，选中多个光标，然后同时编辑：\n随时在浏览器中看代码效果 20180118_1658.png\n如上图所示，我们可以点击右上角的浏览器图标，在各个浏览器中看效果。\n实时查看颜色 写代码时如果想输入颜色，会自动提示颜色的预览。\n点击最左侧的颜色预览，还能弹出调色板：\n代码的自动补齐 （1）在html文档中，输入div*10，按tab键后，弹出的效果如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; （2）在html文档中，输入如下部分：\n1 .search-logo+.search-input+.search-car+.search-moreA 按tab键后，弹出的效果如下：\n1 2 3 4 \u0026lt;div class=\u0026#34;search-logo\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;search-input\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;search-car\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;search-moreA\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 你看，京东的搜索框就包含了这几个div：\n20180122_1045.png\n（3）方法的注释：\n方法写完之后（注意，一定要先写完整），我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。\n比如：\n1 2 3 4 5 6 7 8 9 /** * 功能：给定元素查找他的第一个元素子节点，并返回 * @param ele * @returns {Element|*|Node} */ function getFirstNode(ele){ var node = ele.firstElementChild || ele.firstChild; return node; } 常用快捷键 标签环绕 输入一段字符后，按住Ctrl + Alt + T，可以用标签将这段字符环绕：\n选中正行中的文本 比如下面这行：\n1 text-align: center; /*让 li 里面的文本水平方向居中*/ 如果直接按 【ctrl+C】的话，复制的是整行的内容，把前面的空格也包含进去了。如果不想复制空格，有另外一个办法：将光标放在行尾，然后按住【shift+home】，就能选中你想要的内容了。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/01-webstorm%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"WebStorm的简单设置 1、主题修改： 可能大家会觉得软件的界面不太好看，我们可以换一下主题。选择菜单栏“File\u0026ndash;settin","title":"01-WebStorm的使用"},{"content":"数据库的概念 数据库：database（DB），是一种存储数据的仓库。具有如下特性：\n数据库是根据数据结构组织、存储和管理数据。 数据库能够长期、高效的管理和存储数据。 数据库的目的就是能够存储（写）和提供（读）数据。 数据库分类 数据库分为两类：\n关系型数据库：把复杂的数据结构归结为简单的二元关系，即二维表格形式（二维表）。注重数据存储的持久性。\n非关系型数据库：没有具体模型的数据结构。英文简称 NoSQL（Not Only SQL )，意为\u0026quot;不仅仅是SQL\u0026quot;。注重数据读取的效率。\n我们具体来看看。\n1、关系型数据库 关系型数据库：把复杂的数据结构归结为简单的二元关系，即二维表格形式（二维表）。\n关系型数据库有四层结构：\n数据库管理系统（DBMS）：DataBase Management System。\n数据库（DB）：数据存储的管理者。\n数据表（Table）：数据关系管理者。\n数据字段（Field）：实际数据存储者。\n常见的关系型数据库产品：\n大型：Oracle\n中型：MySQL、SQL Server\n小型：Sybase、Access\n2、非关系型数据库 非关系型数据库：没有具体模型的数据结构。英文简称 NoSQL（Not Only SQL )，意为\u0026quot;不仅仅是SQL\u0026quot;。\n常见的非关系型数据库产品：MongoDB、Redis、Memcached。\nSQL 的介绍 SQL：全称 Structured Query Language，译为结构化查询语言。\nSQL：是一种针对关系型数据库的标准化编程语言，能够实现用户数据库的查询和程序设计。\n通俗来讲，SQL 是关系型数据库的操作指令。\n根据操作类型不同，SQL 可分为几类：\nDQL：Data Query Language，数据查询语言，用于查询和检索数据 DML：Data Manipulation Language，数据操作语言，用于数据的写操作（增删改） DDL：Data Definition Language，数据定义语言，用于创建数据结构 DCL：Data Control Language，数据控制语言，用于用户权限管理 TPL：Transaction Process Language，事务处理语言，辅助DML进行事务操作（因此也归属于DML） 补充：\nSQL 虽然是编程语言，但通常只用来进行数据管理，逻辑部分交给其他编程语言。\nSQL 是针对关系型数据库的通用语言，所有关系型数据库都是基于SQL进行数据操作；而不同的数据库产品，在 SQL 操作指令上略有差异。\nMySQL 的介绍 MySQL 数据库介绍 MySQL 是很有名的 关系型数据库产品，由瑞典MySQL AB 公司开发，现在属于 Oracle 旗下产品。\nMySQL 在 2008 年被 Sun 公司以10亿美金所收购，而 Sun 公司在2009年被 Oracle 甲骨文公司收购。\nMySQL 开源免费。\nMySQL 访问原理 MySQL是一种C/S结构的软件，因此我们需要安装 MySQL 的客户端来访问远程的服务端。也就是说，数据是存放在服务器上的，客户端通过执行 sql 指令来操作服务端的数据。\n具体步骤是：\n（1）客户端通过 主机（host） + 端口号（port） 服务端。\n（2）输入 username 和 password 验证身份。\n（3）客户端和服务端连接成功，通过 sql 指令开始操作数据库。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/01-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"数据库的概念 数据库：database（DB），是一种存储数据的仓库。具有如下特性： 数据库是根据数据结构组织、存储和管理数据。 数据库能够长期、","title":"01-数据库的基础知识"},{"content":"ES的几个重要版本 ES5 : 09年发布。\nES6(ES2015) : 2015年发布，也称为ECMA2015。\nES7(ES2016) : 2016年发布，也称为ECMA2016 (变化不大)。\n严格模式的理解 概念 理解：除了正常运行模式(混杂模式)，ES5添加了第二种运行模式：\u0026ldquo;严格模式\u0026rdquo;（strict mode）。\n顾名思义，这种模式使得Javascript在更严格的语法条件下运行。\n目的：\n消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为\n消除代码运行的一些不安全之处，为代码的安全运行保驾护航\n为未来新版本的Javascript做好铺垫\n使用 针对整个脚本文件：将use strict放在脚本文件的第一行，则整个脚本文件将以严格模式运行。\n针对单个函数：将use strict放在函数体的第一行，则整个函数以严格模式运行。\nPS：如果浏览器不支持，则这句话只解析为一条简单的语句, 没有任何副作用。\n脚本文件的变通写法：因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。\n语法和行为改变 必须用var声明变量\n禁止自定义的函数中的this指向window\n创建eval作用域\n对象不能有重名的属性\n严格模式和普通模式的区别 下面列举几条严格模式的内容。\n全局变量显式声明 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。\n禁止this关键字指向全局对象： 1 2 3 4 5 var foo = function () { console.log(this); } foo(); 上方代码中，普通模式打印的是window。严格模式下打印的是undefined。\n创设eval作用域 禁止使用with语句 因为with语句无法在编译时就确定，属性到底归属哪个对象。\n构造函数必须通过new实例化对象 构造函数必须通过new实例化对象，否则报错。因为this为undefined，此时无法设置属性。\n比如说：\n1 2 3 4 5 var Cat = function (name) { this.name = name; } Cat(\u0026#39;haha\u0026#39;); 上方代码中，如果在严格模式下，则会报错。\n为了让代码更安全，禁止函数内部遍历调用栈 严格模式下无法删除变量 属性相关 普通模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。\n严格模式下，对禁止扩展的对象添加新属性，会报错。\n普通模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。\n普通模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，多个重名的参数属于语法错误。\n比如下面这样的代码：\n1 2 3 4 var obj = { username: \u0026#39;smyh\u0026#39;; username: \u0026#39;vae\u0026#39; } 上面的代码，在严格模式下属于语法错误，因为有重名的属性。\n函数必须声明在顶层 将来Javascript的新版本会引入\u0026quot;块级作用域\u0026quot;。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。\n新增关键字 为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。\n总结 至少要能答出四五条。\n参考链接：\n阮一峰 | Javascript 严格模式详解 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/02-es5%E4%B8%AD%E7%9A%84%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F/","summary":"ES的几个重要版本 ES5 : 09年发布。 ES6(ES2015) : 2015年发布，也称为ECMA2015。 ES7(ES2016) : 2016年发布，也称为ECMA2016 (变化不大)。 严格模","title":"02-ES5中的严格模式"},{"content":"CSS CSS Inspiration，在这里找到写 CSS 的灵感：https://github.com/chokcoco/CSS-Inspiration\nCSS 常用样式：https://github.com/QiShaoXuan/css_tricks\nJavaScript 优秀的JS代码规范：https://github.com/ryanmcdermott/clean-code-javascript\n据说这个项目，是宝藏：https://github.com/dexteryy/spellbook-of-modern-webdev\nTS TypeScript 教程：https://github.com/xcatliu/typescript-tutorial Node.js Node.js学习：https://blog.poetries.top/node-learning-notes/\n算法类 数据结构和算法：https://github.com/trekhleb/javascript-algorithms\nleetcode解题之路：https://github.com/azl397985856/leetcode\n五分钟学算法：https://github.com/MisterBooo/LeetCodeAnimation\nLeetCode 攻略 - 2019 年 8 月上半月汇总（109 题攻略）：https://juejin.im/post/5d522f7cf265da03c926ede5\n极客时间 App 的《数据结构与算法之美》\nVue 教程 你也许不知道的 Vuejs：https://github.com/yugasun/You-May-Not-Know-Vuejs 综合类 前端精读周刊 其他 单元测试：https://github.com/goldbergyoni/javascript-testing-best-practices 前端面试 前端面试常考问题整理，按模块知识点分类：https://blog.poetries.top/FE-Interview-Questions/\n前端开发面试题: https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions\nweb前端面试宝典：https://github.com/h5bp/Front-end-Developer-Interview-Questions/\n掘金前端面试题合集：https://github.com/shfshanyue/blog/blob/master/post/juejin-interview.md\n综合面试 反向面试（反问面试官的问题）：https://github.com/yifeikong/reverse-interview-zh 博客 收集优质的中文前端博客：https://github.com/FrankFang/best-chinese-front-end-blogs\n前端博客：https://github.com/laizimo/zimo-article\n讲得比较详细。比如说这篇：CSS布局说——可能是最全的\n文档类 中文博客排版指南：https://github.com/qianguyihao/document-guide\n中国程序员容易发音错误的单词：https://github.com/shimohq/chinese-programmer-wrong-pronunciation\n学会提问 https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/02-github%E9%A1%B9%E7%9B%AE%E6%8E%A8%E8%8D%90/","summary":"CSS CSS Inspiration，在这里找到写 CSS 的灵感：https://github.com/chokcoco/CSS-Inspiration CSS 常","title":"02-GitHub项目推荐"},{"content":"JSX介绍 JSX的引入 如果直接让用户通过 JS 代码手动创建DOM元素，肯定是非常麻烦的。\n于是，React 官方就提出了一套 JSX 语法规范，能够让我们在 JS 文件中，书写类似于 HTML 那样的代码，快速定义虚拟DOM结构。\nJSX的全称 JSX：JavaScript XML，一种类似于XML的JS扩展语法。也可以理解成：符合 XML 规范的 JS 语法。\n需要注意的是，哪怕你在 JS 中写的是 JSX 语法（即JSX这样的标签），但是，JSX内部在运行的时候，并不是直接把 我们的 HTML 标签渲染到页面上；而是先把 类似于HTML 这样的标签代码，转换成 React.createElement 这样的JS代码，再渲染到页面中。\n从这一点我们可以看出，JSX是一个对程序员友好的语法糖。\nJSX语法的本质：以 React.createElement 的形式来实现的，并没有直接把 用户写的 HTML代码，渲染到页面上。\nbabel转换工具 如果要直接使用 JSX 语法，需要先安装相关的 语法转换工具：\n1 运行 cnpm i babel-preset-react -D 这个babel包的作用是：将 JSX语法 转换为 JS语法。\n安装完成后，就可以开始使用JSX语法了。\n完整代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; //页面中的真实容器元素 var containDiv = document.getElementById(\u0026#34;app\u0026#34;); //1、使用JSX语法 创建虚拟DOM对象 var vDom = ( \u0026lt;div\u0026gt; Hello, React! \u0026lt;h2\u0026gt;这是标题\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); //2、渲染虚拟DOM对象（将虚拟DOM对象渲染到页面元素中） ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; JSX的基本语法 （1）在 JSX内部 写 JS代码：如果要在 JSX 语法内部，书写 JS 代码，那么，所有的JS代码必须写到 {} 的内部。在{}内部，可以写任何符合JS规范的代码。\n例如：\n1 2 3 4 5 6 7 8 9 var myTitle = \u0026#39;这是使用变量定义的 tilte 值\u0026#39; // 使用JSX语法 创建虚拟DOM对象 var vDom = ( \u0026lt;div\u0026gt; Hello, React! \u0026lt;h2 title={myTitle + \u0026#39;vae\u0026#39;}\u0026gt;这是标题\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); （2）当编译引擎在编译JSX代码的时候，如果遇到了\u0026lt;，会把它当作 HTML代码 去编译；如果遇到了 {}， 会把方括号里面的代码当作 普通JS代码 去编译。\n（3）在JSX中，如果要为元素添加class属性，则必须写成className，因为 class在ES6中是一个关键字；和class类似，label标签的 for 属性需要替换为 htmlFor。\n代码举例：\n1 2 3 4 5 6 7 8 // 使用JSX语法 创建虚拟DOM对象 var vDom = ( \u0026lt;div\u0026gt; Hello, React! \u0026lt;p className=\u0026#34;qianguyihao\u0026#34;\u0026gt;lvbu\u0026lt;/p\u0026gt; \u0026lt;label htmlFor=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; ); （4）在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹。\n（5）如果要写注释，注释必须放到 {} 内部。例如：\n1 2 3 4 5 6 7 8 9 // 使用JSX语法 创建虚拟DOM对象 var vDom = ( // 这一行是注释 \u0026lt;div\u0026gt; Hello, React! \u0026lt;p className=\u0026#34;qianguyihao\u0026#34;\u0026gt;lvbu\u0026lt;/p\u0026gt; {/*这一行也是注释 */} \u0026lt;/div\u0026gt; ); 最后，再举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; //页面中的真实容器元素 var containDiv = document.getElementById(\u0026#34;app\u0026#34;); var arr = [] for (var i = 0; i \u0026lt; 6; i++) { var p = \u0026lt;p className=\u0026#34;myp\u0026#34; key={i}\u0026gt;这个是p标签\u0026lt;/p\u0026gt; // 注意这个地方的写法： key = {i} arr.push(p) } //1、使用JSX语法 创建虚拟DOM对象 var vDom = ( \u0026lt;div\u0026gt; Hello, React! {arr} \u0026lt;/div\u0026gt; ); //2、渲染虚拟DOM对象 ReactDOM.render(vDom, containDiv); // 参数1：虚拟DOM对象；参数2：页面中的容器 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行结果：\n20190210_1501.png\n创建组件的第一种方式 创建组件 在React中，构造函数就是一个最基本的组件。\n如果想要把组件放到页面中，可以把构造函数的名称当作组件的名称，以 HTML标签形式引入页面中即可。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; // 这个构造函数，就相当于一个 组件 function Hello() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Hello组件 中定义的元素\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;Hello\u0026gt; \u0026lt;/Hello\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 运行结果：\n20190210_1510.png\n需要注意的是：\nReact在解析所有标签的时候，是以标签的首字母来区分的：如果标签的首字母是小写，就按照普通的 HTML 标签来解析；如果首字母是大写，则按照 组件的形式来解析。\n比如上方代码中，如果把大写的 Hello 改成小写的 hello，运行会报错，无法看到预期的结果。\n结论：组件的首字母必须大写。\n父组件传值给子组件 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; // 父组件中的数据 var person = { name: \u0026#34;qianguyihao\u0026#34;, age: 27, gender: \u0026#34;男\u0026#34;, address: \u0026#34;深圳\u0026#34; }; // 在子组件中，如果想要使用外部传递过来的数据，必须显示的在 构造函数参数列表中，定义 props 属性来接收 // 通过 props 得到的任何数据都是只读的，不能重新赋值 function Hello(props) { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Hello子组件 中定义的元素： {props.name}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } ReactDOM.render( \u0026lt;!-- 注意：这里的 ...Obj 语法，是 ES6中的属性扩散，表示：把这个对象上的所有属性，展开了，放到这个位置 --\u0026gt; \u0026lt;div\u0026gt; \u0026lt;Hello {...person}\u0026gt; \u0026lt;/Hello\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中，我们是想把整个person对象传递给子组件，所以采用了...Obj 语法语法。传递给子组件后，子组件获取的数据仅仅只是可读的。\nclass 关键字的介绍 面向对象语言的三个特性：封装、继承、多态。多态 和 接口、虚拟方法有关。\nclass的基本用法：使用class创建对象 myclass.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 以前学习的：使用构造函数创建对象 function Person(name, age) { this.name = name; this.age = age; } Person.prototype.say = function() { console.log(\u0026#34;呵呵哒\u0026#34;); }; Person.info = 123; var p1 = new Person(\u0026#34;zs\u0026#34;, 20); // 本次需要学习的：class 后面跟上类名，类名后面，不需要加 () ，直接上 {} class Per { // 在每个class类内部，都有一个 constructor 构造器， 如果没有显示定义 构造器，那么类内部默认都有个看不见的 constructor // constructor 的作用，就好比 咱们之前的 function Person(){ } // 每当，使用 new 关键字创建 class 类实例的时候，必然会优先调用 constructor 构造器 // constructor(){} constructor(name, age) { this.name = name; this.age = age; } // 这是实例方法，必须通过 new 出来的对象调用 say() { console.log(\u0026#34;ok a \u0026#34;); } static info = 123; static sayHello() { console.log(\u0026#34;这是静态方法\u0026#34;); } } var p2 = new Per(\u0026#34;壹号\u0026#34;, 26); console.log(p2); console.log(Per.info); console.log(Per.sayHello()); 使用 class 实现 JS 中的继承 myclass2.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Person { constructor(name, age) { console.log(3); this.name = name; this.age = age; } say() { console.log(\u0026#34;这是 Person中的 say 方法\u0026#34;); } static info = 123; } // 使用 extends 实现继承，extends的前面的是子类，后面的是父类 class Chinese extends Person { constructor(name, age, color, language) { console.log(1); // 注意： 当使用 extends 关键字实现了继承， 子类的 constructor 构造函数中，必须显示调用 super() 方法，这个 super 表示父类中 constructor 的引用 super(name, age); this.color = color; this.language = language; console.log(2); } } var c1 = new Chinese(\u0026#34;张三\u0026#34;, 22, \u0026#34;yellow\u0026#34;, \u0026#34;汉语\u0026#34;); console.log(c1); // 父类中任何东西，子类都能继承到 c1.say(); 注意上方 constructor处的注释：当使用 extends 关键字实现了继承， 子类的 constructor 构造函数中，必须显示调用 super() 方法，这个 super 表示父类中 constructor 的引用。也就是说，在子类当中，要么不写 constructor，如果写了 constructor，就一定要把 super()也加上。\n为啥我们要引入 class这个功能？就是因为， class里，永远都存在着一个 constructor。我们可以利用 constructor做很多事情。\n创建组件的第二种方式：使用 class 关键字 使用 class 创建的类，通过 extends 关键字，继承 React.Component 之后，这个类，就是一个组件的模板了。如果想要引用这个组件，可以把类的名称以标签的形式，导入到 JSX 中使用。\n在 class 实现的组件内部，必须定义一个 render 函数。在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null。\n代码举例：\nindex.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; // 使用 class 创建的类，通过 extends 关键字，继承 `React.Component` 之后，这个类，就是一个组件的模板了。 // 如果想要引用这个组件，可以把类的名称以**标签的形式**，导入到 JSX 中使用。 class Hello2 extends React.Component { // 在 class 实现的组件内部，必须定义一个 render 函数 render() { // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是使用 class 类创建的组件 \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } } ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;Hello2\u0026gt; \u0026lt;/Hello2\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 父组件传值给子组件 代码举例：\nindex.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入React相关的js库 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/react-dom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;./libs/babel.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- 注意，这一行的 type 是写 \u0026#34;text/babel\u0026#34;，而不是 \u0026#34;text/javascript\u0026#34; --\u0026gt; \u0026lt;script type=\u0026#34;text/babel\u0026#34;\u0026gt; // 使用 class 创建的类，通过 extends 关键字，继承 `React.Component` 之后，这个类，就是一个组件的模板了。 // 如果想要引用这个组件，可以把类的名称以**标签的形式**，导入到 JSX 中使用。 class Hello2 extends React.Component { constructor(props) { super(props); console.log(props.name); // 注意：`this.state` 是固定写法，表示当前组件实例的私有数据对象，就好比 vue 中，组件实例身上的 data(){ return {} } 函数 // 如果想要使用 组件中 state 上的数据，直接通过 this.state.*** 来访问即可 this.state = { msg: \u0026#34;这是 Hello2 组件的私有msg数据\u0026#34;, info: \u0026#34;永不止步\u0026#34; }; } // 在 class 实现的组件内部，必须定义一个 render 函数 render() { // 在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是使用 class 类创建的组件 \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } } ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;Hello2 name=\u0026#34;qianguyihao\u0026#34;\u0026gt; \u0026lt;/Hello2\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 方式一和方式二的对比 上面的内容里，我们使用了两种方式创建组件。这两种方式，有着本质的区别，我们来对比一下。\n对比：\n方式一：通过 function构造函数 创建组件。内部没有 state 私有数据，只有 一个 props 来接收外界传递过来的数据。\n方式二：通过 class 创建子组件。内部除了有 this.props 这个只读属性之外，还有一个专门用于 存放自己私有数据的 this.state 属性，这个 state 是可读可写的。\n基于上面的区别，我们可以为这两种创建组件的方式下定义： 使用 function 创建的组件，叫做【无状态组件】；使用 class 创建的组件，叫做【有状态组件】。\n本质区别：\n有状态组件和无状态组件，最本质的区别，就是有无 state 属性。同时， class 创建的组件，有自己的生命周期函数，但是，function 创建的 组件，没有自己的生命周期函数。\n什么时候使用 有状态组件，什么时候使用无状态组件：\n（1）如果一个组件需要存放自己的私有数据，或者需要在组件的不同阶段执行不同的业务逻辑，此时，非常适合用 class 创建出来的有状态组件。\n（2）如果一个组件，只需要根据外界传递过来的 props，渲染固定的页面结构即可的话，此时，非常适合使用 function 创建出来的无状态组件。（使用无状态组件的小小好处： 由于剔除了组件的生命周期，所以，运行速度会相对快一点点）。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/02-jsx%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/","summary":"JSX介绍 JSX的引入 如果直接让用户通过 JS 代码手动创建DOM元素，肯定是非常麻烦的。 于是，React 官方就提出了一套 JSX 语法规范，能够让我们在","title":"02-JSX语法介绍"},{"content":"MySQL 安装 MySQL（Mac版） 步骤1、下载安装包并安装： MySQL 下载地址：https://dev.mysql.com/downloads/mysql/\n步骤2、配置环境变量 打开 ~/.bash_profile 文件，在文件的末尾，添加如下内容，即可配置环境变量：\n1 2 3 4 5 # mysql export PATH=${PATH}:/usr/local/mysql/bin #快速启动、结束MySQL服务, 可以使用alias命令 alias mysqlstart=\u0026#39;sudo /usr/local/mysql/support-files/mysql.server start\u0026#39; alias mysqlstop=\u0026#39;sudo /usr/local/mysql/support-files/mysql.server stop\u0026#39; 配置好环境变量后，在终端输入 source ~/.bash_profile 命令，让配置生效。\n在终端的任何位置，输入如下命令，即可进入 mysql 命令的执行窗口：\n1 mysql -u root -p 参考链接：\nMySQL安装（Mac版） 步骤3、继续配置环境变量 在 ~/.bash_profile 中配置好环境变量后，发现每次重启终端后，配置都会失效，需要重新执行 source ~/.bash_profile 命令。\n原因是，zsh加载的是 ~/.zshrc文件，而 .zshrc 文件中并没有定义任务环境变量。\n解决办法：打开 ~/.zshrc 文件，在文件的末尾，添加如下内容即可：\n1 source ~/.bash_profile 参考链接：https://blog.csdn.net/science_Lee/article/details/79214127\nNavicat Premium 软件初体验 Navicat Premium 软件是一种数据库管理的GUI软件，采用可视化的方式来查看和操作数据库，非常方便。支持的数据库有： MySQL、MongoDB、SQL Server、SQLite、Oracle 及 PostgreSQL等。\n安装好 Navicat Premium 软件之后，我们来看看这个软件是怎么用的。\n新建表和数据 1、新建连接：\n打开 Navicat Premium 软件，选择菜单栏「文件-新建连接-mysql」，然后选择如下配置，即可在本地新建一个数据库连接：\n2、选中连接后，右键新建数据库：\n3、选中数据库之后，新建表 qiangu_student_table：\n4、在表中添加字段：\n5、字段建好后，开始在表中插入数据：\n导入外部 sql 文件 在 Navicat中，选中当前 database 之后，右键选择“运行sql文件”，即可导入外部sql文件。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/02-mysql%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8Cnavicat%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/","summary":"MySQL 安装 MySQL（Mac版） 步骤1、下载安装包并安装： MySQL 下载地址：https://dev.mysql.com/downloads/mysql","title":"02-MySQL的安装和Navicat软件使用"},{"content":"Node.js 的特点 异步、非阻塞 IO 模型\n事件循环\n单线程\n总结：轻量和高效\nNode.js 的性能和效率非常高。\n传统的 Java 语言是一个请求开启一个线程，当请求处理完毕后就关闭这个线程。而 Node.js 则完全没有采用这种模型，它本质上就是一个单线程。\n你可能会疑问：一个线程如何服务于大量的请求、如何处理高并发的呢？这是因为，Node.js 采用的是异步的、非阻塞的模型。\n这里所谓的“单线程”，指的是 Node 的主线程只有一个。为了确保主线程不被阻塞，主线程是用于接收客户端请求。但不会处理具体的任务。而 Node 的背后还有一个线程池，线程池会处理长时间运行的任务（比如 IO 操作、网络操作）。线程池里的任务是通过队列和事件循环的机制来执行。\n使用 Node.js 时的劣势 程序运行不稳定，可能会出现服务不可用的情况\n程序运行效率较低，每秒的请求数维持在一个较低的水平\n前端同学对服务器端的技术不太熟悉。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/02-node.js%E7%9A%84%E7%89%B9%E7%82%B9/","summary":"Node.js 的特点 异步、非阻塞 IO 模型 事件循环 单线程 总结：轻量和高效 Node.js 的性能和效率非常高。 传统的 Java 语言是一个请求开启一个线程，当请求处理完毕后就关闭这个","title":"02-Node.js的特点"},{"content":"对象赋值 用 Object.assgin() 实现浅拷贝 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, desc: \u0026#39;hello world\u0026#39;, }; const obj2 = { name: \u0026#39;许嵩\u0026#39;, sex: \u0026#39;男\u0026#39;, }; // 【关键代码】浅拷贝：把 obj1 赋值给 obj2。这行代码的返回值也是 obj2 Object.assign(obj2, obj1); console.log(JSON.stringify(obj2)); 打印结果：\n1 {\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;sex\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;desc\u0026#34;:\u0026#34;hello world\u0026#34;} 注意，上面这行代码在实际开发中，会经常遇到，一定要掌握。它的作用是：将 obj1 的值追加到 obj2 中。如果两个对象里的属性名相同，则 obj12 中的值会被 obj2 中的值覆盖。\n数组赋值 扩展运算符 1 arr2 = arr1; 上方代码中，其实是让 arr2 指向 arr1 的地址。也就是说，二者指向的是同一个内存地址。\n如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做：\n1 let arr2 = [...arr1]; //arr2 会开辟新的内存地址 参考链接：\njavaScript中浅拷贝和深拷贝的实现 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/02-%E6%95%B0%E6%8D%AE%E7%9A%84%E8%B5%8B%E5%80%BC/","summary":"对象赋值 用 Object.assgin() 实现浅拷贝 代码举例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, desc: \u0026#39;hello world\u0026#39;, }; const obj2 = { name: \u0026#39;许嵩\u0026#39;, sex: \u0026#39;男\u0026#","title":"02-数据的赋值"},{"content":"JSON 对象 1、js对象(数组) \u0026ndash;\u0026gt; json对象(数组)：\n1 JSON.stringify(obj/arr) 2、json对象(数组) \u0026ndash;\u0026gt; js对象(数组)：\n1 JSON.parse(json) 上面这两个方法是ES5中提供的。\n我们要记住，我们通常说的“json字符串”，只有两种：json对象、json数组。\ntypeof json字符串的返回结果是string。\nObject的扩展 ES5给Object扩展了一些静态方法，常用的有2个，我们接下来讲解。\n方法一 1 Object.create(prototype, [descriptors]) 作用: 以指定对象为原型，创建新的对象。同时，第二个参数可以为为新的对象添加新的属性，并对此属性进行描述。\n举例1：（没有第二个参数时）\n1 2 3 4 5 var obj1 = {username: \u0026#39;smyhvae\u0026#39;, age: 26}; var obj2 = {address:\u0026#39;shenzhen\u0026#39;}; obj2 = Object.create(obj1); console.log(obj2); 打印结果：\n1 2 3 4 5 {} [[Prototype]]: Object age: 26 username: \u0026#34;smyhvae\u0026#34; [[Prototype]]: Object 我们发现，obj1成为了obj2的原型。\n举例2：（有第二个参数时）\n第二个参数可以给新的对象添加新的属性。我们修改上面的代码，尝试给obj2添加新属性sex：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var obj1 = {username: \u0026#39;smyhvae\u0026#39;, age: 26}; var obj2 = {address: \u0026#39;shenzhen\u0026#39;}; obj2 = Object.create(obj1, { sex: {//给obj2添加新的属性`sex`。注意，这一行的冒号不要漏掉 value: \u0026#39;男\u0026#39;, //通过value关键字设置sex的属性值 writable: false, configurable: true, enumerable: true } }); console.log(obj2); 上方代码中，我们通过第5行的sex给obj2设置了一个新的属性sex，但是要通过value来设置属性值（第6行）。\n设置完属性值后，这个属性值默认是不可修改的，要通过writable来设置。总而言之，这几个关键字的解释如下：\nvalue：设置属性值。\nwritable：标识当前属性值是否可修改。如果不写的话，默认为false，不可修改。\nconfigurable：标识当前属性是否可以被删除。默认为false，不可删除。\nenumerable：标识当前属性是否能用 for in 枚举。 默认为false，不可。\n方法二 1 Object.defineProperties(object, descriptors) 作用：为指定对象定义扩展多个属性。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var obj2 = { firstName : \u0026#39;smyh\u0026#39;, lastName : \u0026#39;vae\u0026#39; }; Object.defineProperties(obj2, { fullName : { get : function () { return this.firstName + \u0026#39;-\u0026#39; + this.lastName }, set : function (data) { //监听扩展属性，当扩展属性发生变化的时候自动调用，自动调用后将变化的值作为实参注入到set函数 var names = data.split(\u0026#39;-\u0026#39;); this.firstName = names[0]; this.lastName = names[1]; } } }); console.log(obj2.fullName); obj2.firstName = \u0026#39;tim\u0026#39;; obj2.lastName = \u0026#39;duncan\u0026#39;; console.log(obj2.fullName); obj2.fullName = \u0026#39;kobe-bryant\u0026#39;; console.log(obj2.fullName); get ：用来获取当前属性值的回调函数 set ：修改当前属性值得触发的回调函数，并且实参即为修改后的值 存取器属性：setter,getter一个用来存值，一个用来取值。\n数组的扩展 方法1：\n1 Array.prototype.indexOf(value) 作用：获取 value 在数组中的第一个下标。\n方法2：\n1 Array.prototype.lastIndexOf(value) 作用：获取 value 在数组中的最后一个下标。\n方法3：遍历数组\n1 Array.prototype.forEach(function(item, index){}) 方法4：\n1 Array.prototype.map(function(item, index){}) 作用：遍历数组返回一个新的数组，返回的是加工之后的新数组。\n方法5：\n1 Array.prototype.filter(function(item, index){}) 作用：遍历过滤出一个新的子数组，返回条件为true的值。\n函数function的扩展：bind() ES5中新增了bind()函数来改变this的指向。\n1 Function.prototype.bind(obj) 作用：将函数内的this绑定为obj, 并将函数返回。\n面试题: call()、apply()和bind()的区别：\n都能改变this的指向 call()/apply()是立即调用函数 bind()：绑定完this后，不会立即调用当前函数，而是将函数返回，因此后面还需要再加()才能调用。 PS：bind()传参的方式和call()一样。\n分析：\n为什么ES5中要加入bind()方法来改变this的指向呢？因为bind()不会立即调用当前函数。\nbind()通常使用在回调函数中，因为回调函数并不会立即调用。如果你希望在回调函数中改变this，不妨使用bind()。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/03-es5%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%89%A9%E5%B1%95/","summary":"JSON 对象 1、js对象(数组) \u0026ndash;\u0026gt; json对象(数组)： 1 JSON.stringify(obj/arr) 2、json对象(数组) \u0026ndash;\u0026gt; js对象(数组)： 1 JSON.parse(json) 上面这两个方法是ES5中提供的。 我们要","title":"03-ES5中的一些扩展"},{"content":"常见操作 全局配置用户信息 1 2 git config --global user.name \u0026#34;lvsijun\u0026#34; git config --global user.email \u0026#34;lvsijun@163.com\u0026#34; 分支的合并 场景：基于master分支的代码，开发一个新的特性，给每个特性都单独建一个的新的分支。 比如说，我专门给特性1建一个分支branch_one。具体做法如下：\n（1）基于master分支，创建一个新的分支，起名为branch_one：\n1 2 $ git checkout -b branch_one Switched to a new branch \u0026#39;branch_one\u0026#39; 上面这行命令，相当于：\n1 2 $ git branch feature_item_recommend // 创建新的分支 $ git checkout feature_item_recommend //切换到新的分支 （2）在新的分支branch_one上，完成开发工作，并 commit 、push。\n（3）将分支branch_one上的开发进度合并到master分支：\n1 2 $ git checkout master //切换到master分支 $ git merge branch_one //将分支 branch_one 的开发进度合并到 master 分支 合并之后，master分支和branch_one分支会指向同一个位置。\n（3）删除分支branch_one：\n既然 特性1 开发完了，也放心地提交到master了，那我们就可以将这个分支删除了。\n1 git branch -d branch_one 注意，我们当前是处于master分支的位置，来删除branch_one分支。如果当前是处于branch_one分支，是没办法删除它自己的。\n同理，当我转身去开发特性2的时候，也是采用同样的步骤。\n合并分支时，如果存在分叉 比如说上面这张图中，最早的时候，master分支是位于C2节点。我基于C2节点，new出一个新的分支iss53，我在iss53上提交了好几个commit。\n现在，我准备把iss53上的几个commit合并到master上，此时发现，master分支已经前进到C4了。那该怎么合并呢？\n合并的命令仍然是：\n1 2 $ git checkout master $ git merge iss53 日常操作积累 修改密码（曲线救国） 1 2 # 设置当前仓库的用户名为空 git config user.name \u0026#34;\u0026#34; 我们还要输入如下命令，还原当前仓库的用户名：\n1 git config user.name \u0026#34;smyhvae\u0026#34; 修改已经push的某次commit的作者信息 已经push的记录，如果要修改作者信息的话，只能通过\u0026ndash;force命令。\n参考链接：\ngit 修改已提交的某一次的邮箱和用户信息\n修改 git repo 历史提交的 author\n将 branch1的某个commit1合并到branch2当中 切换到branch2中，然后执行如下命令：\n1 git cherry-pick commit1 将Git 项目迁移到另一个仓库 我们假设旧仓库的项目名称叫old-repository，新仓库的项目名称叫new-repository。操作如下：\n（1）创建旧仓库的裸克隆：\n1 git clone --bare https://github.com/exampleuser/old-repository.git 执行上述命令后，会在本地生成一个名叫 old-repository.git的文件夹。\n（2）迁移到新仓库：\n1 2 3 cd old-repository.git git push --mirror https://github.com/exampleuser/new-repository.git 注意，我们不需要手动新建一个空的新仓库，当我们执行上述命令之后，新仓库就已经自动创建好了。\n参考链接：\n复制仓库\nGit 本地仓库和裸仓库\ngit客户端推荐 Sourcetree\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/03-git%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"常见操作 全局配置用户信息 1 2 git config --global user.name \u0026#34;lvsijun\u0026#34; git config --global user.email \u0026#34;lvsijun@163.com\u0026#34; 分支的合并 场景：基于master分支的代码，开发一个新的特性，给每个特性都单独建一个的新的分","title":"03-Git的使用"},{"content":"SQL 的一些简单语法规则 结束符 SQL 指令需要语句结束符，默认是英文分号;。\n当然，还有另外两个结束符：\n\\g 与英文分号;等效。\n\\G：将查到的结构旋转90度变成纵向。\n反引号`` SQL语句中如果用到了关键字或者保留字，需要使用反引号``（Tab键上面的符号）来包裹，让系统忽略。\nMySQL 数据库的操作分类 根据数据库的对象层级，可以将SQL的基础操作分为四类：\n数据库（DB）操作。\n数据表（Table）操作。\n数据字段（Field）操作。\n数据操作。\n下面来详细讲一讲。\n一、数据库（DB）的基本操作 在终端的任何位置，输入如下命令，即可进入 mysql 命令的执行窗口：\n1 mysql -u root -p 1、创建数据库 语法格式：\n1 create database 数据库名称 [数据库选项]; 数据库名称的命名规范：\n由数字、字母和下划线组成。 不区分大小写。 不能以数字开头。 建议使用下划线法创建复杂的数据库名字。比如 db_qianguyihao。 举例：\n创建一个名为 db_qianguyihao1 的数据库：\n1 create database db_qianguyihao1; 创建一个指定字符集的数据库：\n1 create database db_qianguyihao2 charset utf8MB4; 创建一个指定校对集的数据库：\n1 create database db_qianguyihao3 charset utf8MB4 collate utf8mb4_general_ci 2、查看数据库 查看有哪些数据库：(显示所有的数据库列表)\n1 show databases; 查看 db_qianguyihao1 这个数据库的具体创建指令是怎样的：\n1 show create database db_qianguyihao1; 备注：由于系统会加工，所以看到的结果不一定是真实的创建指令。\n3、使用指定的数据库 使用指定的数据库：（也可以理解成：进入指定的数据库）\n1 2 3 4 5 # 语法格式 use database_xxx; # 举例 use db_qianguyihao; 假设当前服务器连接中有很多个数据库（db_qianguyihao1、db_qianguyihao2），此时，我输入 use db_qianguyihao2则代表我想使用 db_qianguyihao2 这个数据库。\n4、修改数据库的参数 我们一般很少修改数据库的名称，一般是去修改数据库的一些选项，比如：\n修改字符集\n修改校对集\n语法格式：\n1 alter database 数据库名称 [库选项] 举例1、修改数据库的字符集为gbk：\n1 alter database db_qianguyihao1 charset gbk; 举例2、修改数据库的校对集：\n1 alter database db_qianguyihao2 charset gbk collate gbk_chinese_ci; 备注：因为校对集是和字符集有关的，所以上方指令是在修改字符集的同时，修改校对集。\n5、删除指定的数据库 语法格式：\n1 drop database 数据库名称; 备注：删除数据库时，会清空当前数据库里的所有数据表，所以删除数据库的操作一定要谨慎。\n二、数据表（Table）的基本操作 注意，我们最好先通过 use xxx_database 命令进入指定的数据库（DB），然后在当前数据库下，进行数据表（Table）的操作。\n1、创建数据表 语法格式：\n1 2 3 4 5 6 create table [数据库名].[表名] ( 字段名1 字段类型, ... ... 字段名2 字段类型 ) 表选项; 举例：\n1、在当前数据库中创建数据表 table_qiangu1，并新增主键 id 字段：\n1 2 3 CREATE TABLE table_qiangu1 ( id int NOT NULL AUTO_INCREMENT PRIMARY KEY ); 2、在当前数据库中创建数据表 t_student1，并新增 name、age这连个字段：\n1 2 3 4 create table t_student1( name varchar(255), age int ); 3、在指定的数据库 db_2 中创建数据表 t_student2：\n1 2 3 4 create table db_2.t_student2( name varchar(255), age int ); 4、在当前数据库中创建数据表 t_student3（含表选项）：\n1 2 3 4 create table t_student3( name varchar(255), age int )engine Innodb charset utf8MB4; 举例4中的代码涉及到存储引擎，这里解释一下：\n存储引擎是指数据存储和管理的方式，MySQL中提供了多种存储引擎，一般使用默认存储引擎 InnoDB。\nInnoDB：默认存储引擎；支持事务处理和外键；数据统一管理。\nMyIsam：不支持事务和外键；数据、表结构、索引独立管理；MySQL5.6以后不再维护。\n6、扩展：如果想创建一个与已有表一样的数据表，MySQL提供了一种便捷的复制模式\n2、复制数据表 如果想创建一个与已有表一样的数据表，MySQL提供了一种便捷的复制模式。\n语法格式：（复制现有的表 table_xx1 到 table_xx2）\n1 create table table_xx1 like 数据库名.table_xx2; 注意，这种复制模式，table_xx2 只会复制表 table_xx1 中的字段，不会复制表table_xx1中的数据。\n举例：\n1 2 3 4 5 # 在当前数据库下，复制现有的表`t_qianguyihao1` 到表 `t_qianguyihao2` create table t_qianguyihao1 like t_qianguyihao2; # 复制现有的表`t_qianguyihao1` 到表 `t_qianguyihao2`，是复制到 `db2`这个数据库中 create table t_qianguyihao1 like db2.t_qianguyihao2; 3、显示数据表的名称 在当前数据库下，显示所有的数据表：\n1 show tables; 在指定的数据库中，显示所有的数据表：\n1 show tables from db_qianguyihao1; 显示数据表的创建指令：(查看 t_qianguyihao1 这个数据表的具体创建指令是怎样的)\n1 show create table t_qianguyihao1; # 备注：由于系统会加工，所以看到的结果不一定是真实的创建指令。 4、查询（查找）数据表的名称 根据 表名称 查询数据表，也可以理解成：按条件显示部分数据表。\n根据数据表的表名称查找数据表时，需要用到关键词like，而且还要涉及到两个符号：\n% 表示匹配任意多个字符。\n_ 表示匹配任意一个字符（固定位置）。\n上面这两个模糊查询的符号，大家要牢记。我们来看看具体的例子。\n语法举例：\n1 show tables like \u0026#39;%like_\u0026#39;;\t# _表示匹配一个字符（固定位置），%表示匹配N个字符 % 符号举例：\n1 2 3 4 5 # 查询表名称中，包含 “qiangu” 这个关键字的表（“qiangu”这个关键字的前后可能都有内容） show tables like \u0026#39;%qiangu%\u0026#39;; # 查询表名称以“qiangu”开头的表（这个命令应该很实用） show tables like \u0026#39;qiangu%\u0026#39;; _符号举例：\n1 2 # 根据 表名称 来查询表，查询条件是：表名称以“qiangu”开头，而且要确保 qiangu 的后面有三个字符（因为我在 qiangu 的后面写了三个下划线）。 show tables like \u0026#39;qiangu___\u0026#39;; 5、desc：查看数据表的表结构 查看数据表的表结构，就是查看这张表中定义了哪些字段，以及这些字段是如何定义的。通过这种方式，我们可以清晰地了解数据的存储形式。\n项目开发中，领导在检查我们的工作时，首先看的就是我们的表中定义了哪些字段。所以说，这种方式，还是很实用的。\n语法格式：\n1 2 3 4 5 6 7 8 # 方式1 desc 表名称; # 方式2 describe 表名称; # 方式3 show columns from 表名称; 上面的三种方式，效果都一样，三选一即可。\n6、修改数据表的表名称和表选项 修改数据表的表名称：\n在当前数据库下，修改数据表的表名称：\n1 rename table 原表名 to 新表名; 指定某个数据库，然后修改数据表的表名称：\n1 rename table 数据库名.原表名 to 数据库名.新表名; 修改数据表的表名称：\n1 alter table table1 charset gbk; 7、删除数据表 语法格式：\n1 drop table 数据表名称; 三、字段（Field）的基本操作 数据表 table 创建好了之后，我们就可以开始在这张表中新增字段了。\n1、新增字段 语法格式：\n1 alter table 表名 add [column] 字段名 字段类型 [字段属性] [字段位置]; 注意事项：\n新增字段时，必须制指定字段类型。\n[column]、 [字段属性]、[字段位置] 这几个都是选填，其他是必填。\n追加字段时，这个字段的顺序默认排在最后。\n举例：\n新增字段 name:\n1 alter table table_qiangu1 add name varchar(255); 新增字段 age：\n1 alter table table_qiangu1 add age int; 2、新增字段时，设置字段的位置（顺序） 在新增字段时，它的顺序是默认放在最后面的，当然，我们也可以人工指定它的顺序。\n在修改字段的位置时，我们可以用到下面这两个关键字：\nfirst 放到最前面\nafter 放到某个字段的后面\n语法格式：\n1 alter table 表名 add 新字段名 字段类型 字段位置; 举例1：\n在 name字段的后面，新增一个 sex 字段：\n1 alter table t_qiangu1 add sex varchar(255) default null comment \u0026#39;性别\u0026#39; after name; 注意，上方举例中，如果是新建 varchar 类型的字段，一定要指定 varchar 的长度（比如255），否则报错。\n举例2：\n新增一个 id 字段，放到最前面：\n1 alter table t_qiangu1 add id int first; 3、change：修改现有字段的字段名 修改现有字段的字段名，是通过 change 关键字，不是通过 modify 关键字（后者会报错，执行失败）。\n语法格式：\n1 2 3 4 5 # 格式1（精简版） alter table 表名 change 原字段名 新字段名 字段类型; # 格式2（完整版） alter table 表名 change 原字段名 新字段名 字段类型 [字段属性] [位置]; 注意：\n修改字段名时，一定要设置新字段的字段类型。\n虽然 change 关键字也可以修改现有字段的字段属性、字段位置，但我们一般是通过 modify 关键字来做（下面会讲）。\n举例：\n修改字段名 sex 为 sexy：\n1 alter table t_qiangu2 change sex sexy varchar(255); 4、modify：修改现有字段的的字段类型、字段位置、字段属性 语法格式：\n1 alter table 表名 modify 现有字段的字段名 现有字段的字段类型 [字段属性] [位置]； 举例1、针对现有的字段 name 和 age，更换这两个字段的顺序：\n1 2 # 注意，这里的 age 后面一定要跟上它的字段类型，否则执行失败 alter table t_qiangu1 modify age int after name; 修改字段的默认值 1 2 3 4 5 # 若本身存在默认值，则先删除 alter table 表名 alter column 字段名 drop default; # 若本身不存在则可以直接设定 alter table 表名 alter column 字段名 set default 默认值; 5、删除字段 删除字段的同时，会删除字段对应的数据。删除字段的操作不可逆，请谨慎操作。\n语法格式：\n1 alter table 表名 drop 字段名; 举例：（删除 t_qiangu1 表中的 age 这个字段）\n1 alter table t_qiangu1 drop age; 四、数据的基本操作 1、新增数据 方式1、全字段插入：\n语法格式：\n1 insert into 表名 values(值1, 值2, ... 最后一个值); 解释：\n值的顺序必须与所有字段的顺序一致。 值的数据类型也必须与字段定义的数据类型一致。 举例（给 t_qiangu1 这个表中插入一条完整的数据）：\n1 insert into t_qiangu1 values(3, \u0026#39;qianguyihao\u0026#39;, 28); 方式1、部分字段插入：\n语法格式：\n1 insert into 表名 (字段1, 字段2, 字段3) values(值1, 值2, 值3); 解释：\n-字段的顺序可以随意，但值的顺序必须要与前面的字段顺序一一对应，数据类型也要一致。\n举例（给 t_qiangu1 这个表中的指定字段插入数据）：\n1 insert into t_qiangu1 (id, name) values(4, \u0026#39;xusong\u0026#39;); 2、查询数据 查询数据的操作，占sql日常操作的95%以上。\n语法格式：\n1 select xxx from 表名; 举例：\n查询表中的所有数据：\n1 select * from t_qiangu1; 查询表中 name、age 这两个字段的数据：\n1 select name, age from t_qiangu2; 查询表中 id=2 的数据：\n1 select * from t_qiangu3 where id = 2; 3、修改数据 语法格式：\n1 update 表名 set (字段1 = 新值1, 字段2 = 新值2) [where 条件筛选]; 解释：\n我们通常是结合 where 条件语句来修改数据。\n修改数据之前，要先保证表里面有数据。如果这张表是空表，那么，执行这个命令后，等于没执行。\n举例：\n将表中，name 这个字段的值全部修改为lvbu：\n1 update t_qiangu1 set name = \u0026#39;lvbu\u0026#39;; id = 3 的这条记录中，修改 name 和 age 这两个字段的值：\n1 update t_qiangu1 set name = \u0026#39;许嵩\u0026#39;, age = \u0026#39;34\u0026#39; where id = 3; 4、删除数据 删除字段的操作不可逆，请谨慎操作。\n语法格式：\n1 delete from 表名 [where 条件]; 解释：\n执行删除操作之后，匹配到的整条记录，都会删除。\n删除数据之前，要先保证表里面有数据。如果这张表是空表，那么，执行这个命令后，等于没执行。\n举例：\n删除表中id = 2的记录：\n1 delete from t_qiangu1 where id = 2; ","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/03-mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"SQL 的一些简单语法规则 结束符 SQL 指令需要语句结束符，默认是英文分号;。 当然，还有另外两个结束符： \\g 与英文分号;等效。 \\G：将查到的结构旋转90度","title":"03-MySQL的基本操作"},{"content":"Node.js 运行环境配置：通过 Node.js 安装包（不推荐） 去 Node.js 的官网下载安装包：\n我们也可以在https://nodejs.org/en/download/releases/ 里下载历史版本。\n注意，我们以一定要用偶数版（V4、V6 等)，不要用奇数版（比如 V5），因为奇数版不稳定。\n后续如果需要安装其他版本，可以这样做：重新下载最新的安装包，覆盖安装即可。\n但我们并不推荐直接采用 Node.js.msi（windows）或者 Node.js.pkg（Mac） 安装包进行安装，因为会产生如下问题。\n通过 Node.js 安装包产生的问题：\n安装新版本时，需要覆盖就版本；而且以前版本安装的很多全局工具包，需要重新安装。\n无法回滚到之前的旧版本。\n无法在多个版本之间切换（很多时候，不同的项目需要使用特定版本。或者，我想临时尝鲜一下新版本的特性）\n因此，我们暂时先不用安装 Node.js，稍后用 NVM 的方式来安装 Node.js。通过 NVM 的方式，可以让多个版本的 Node.js 共存，并灵活切换。\nNode.js 版本常识 偶数版本为稳定版（0.6.x ，0.8.x ，8.10.x）\n奇数版本为非稳定版（0.7.x ，0.9.x ，9.11.x）\nLTS（Long Term Support）\n参考链接：node.js 中 LTS 和 Current 的区别\nNode.js 运行环境安装：通过 NVM（推荐） NVM：node.js version manager，用来管理 node 的版本。\n我们可以先安装 NVM，然后通过 NVM 安装 Node.js。这是官方推荐的做法。\nWindows 和 Mac 下安装的 Node.js 的步骤如下。\nWindows 系统安装 Node.js 1、安装 NVM：\n（1）我们去 https://github.com/coreybutler/nvm-windows/releases 下载 NVM 的安装包：\n下载下来后，直接解压到 D:\\web目录下：\n（2）在上面的目录中，新建一个settings.txt文件，里面的内容填充如下：\n1 2 3 4 root: D:\\web\\nvm path: D:\\web\\nodejs arch: 64 proxy 上方内容的解释：\nroot 配置为：当前 nvm.exe 所在的目录\npath 配置为：node 快捷方式所在的目录\narch 配置为：当前操作系统的位数（32/64）\nproxy 不用配置\n（3）配置环境变量：\nNVM_HOME = D:\\web\\nvm（当前 nvm.exe 所在目录）\nNVM_SYMLINK = D:\\web\\nodejs （node 快捷方式所在的目录）\nPATH += ;%NVM_HOME%;%NVM_SYMLINK%\n配置成功后，重启资源管理器。\n2、验证：(在 cmd 命令行中输入命令)\n（1）输入nvm命令查看环境变量是否配置成功：\n（2）输入 nvm ls，查看已安装的所有 node 版本。\n（3）输入 nvm -v，查看 已安装的 nvm 版本。\n（4）输入 node -v，查看正在使用的 node 版本。\n如果 Node 安装失败，可以参考上面这个链接。\n3、安装指定版本的 Node.js：\n1 2 3 4 nvm install 版本号 # 举例 nvm install 8.10.0 输入 node -v，查看当前使用的 node 版本。\n关于 NVM 的常用命令，详见下一段。\n补充：\n如果 Node 安装失败，可以在上方的 settings.txt文件中，新增如下两行，修改镜像源：\n1 2 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 参考链接：安装 npm，nvm，node Mac 系统安装 Node.js 1、安装 NVM：\n（1）打开 终端.app，输入：\n1 curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 安装成功的界面：\n完成后，nvm 就被安装在了~/.nvm下。\n如果发现安装失败：\n原因：Xcode 软件进行过更新。\n解决办法：打开 Xcode 软件，同意相关内容即可。\n（2）配置环境变量：\n编辑器打开~/.bash_profile文件，如果不会就输入open ~/.bash_profile。\n（补充：如果你的 Mac 电脑里找不到~/.bash_profile文件，那就找找有没有~/.profile文件，或者~/.bashrc文件，或者~/.zshrc文件。如果还是没有，那你就手动创建一个~/.bash_profile文件）。\n在最后一行输入：\n1 2 export NVM_DIR=\u0026#34;$HOME/.nvm\u0026#34; [ -s \u0026#34;$NVM_DIR/nvm.sh\u0026#34; ] \u0026amp;\u0026amp; . \u0026#34;$NVM_DIR/nvm.sh\u0026#34; # This loads nvm 如果你发现文件中已经存在了上面这行代码，就不用往里面加了。这一步的作用是每次新打开一个 bash，nvm 都会被自动添加到环境变量中。\n最后，输入 source ~/.bash_profile重启环境变量的配置。\nPS：NVM 现在已经不支持 Homebrew 的方式来安装了。\n参考链接：https://www.jianshu.com/p/a3f8778bc0a1\n2、验证：(在 终端命令行中输入命令)\n（1）输入 nvm 命令查看环境变量是否配置成功：\n（2）输入 nvm ls，查看已安装的所有 node 版本。\n（3）输入 nvm -v，查看 已安装的 nvm 版本。\n（4）输入 node -v，查看正在使用的 node 版本。\n3、安装指定版本的 Node.js：\n和 Windows 下一样，也是执行如下命令：\n1 2 3 4 nvm install 版本号 # 举例 nvm install 8.10.0 网速有点慢，要稍等。\n输入 node -v，查看当前使用的 node 版本。\n安装好 Node 之后，npm 也会自动安装的，输入 npm -v，查看 npm 的版本。\n关于 NVM 的常用命令，详见下一段。\nNVM 的常用命令 注意，这一段说的是 NVM 的常用命令，不是 Node 的常用命令。\n查看当前使用的 nvm 版本：\n1 nvm --version 查看本地安装的所有的 Node.js 版本：\n1 2 3 4 5 # 方式1 nvm ls # 方式2 nvm list 安装指定版本的 Node.js：\n1 2 3 4 nvm install 版本号 # 举例 nvm install 8.10.0 卸载指定版本 Node.js：\n1 nvm uninstall 版本号 切换使用指定版本的 node：\n1 nvm use 版本号 设置node的默认版本：\n1 nvm alias default 版本号 查看全局npm包的安装路径：\n1 npm root -g 查看远程服务器端的所有 Node 版本：\n1 nvm ls-remote 执行上面的命令后，在列出的版本清单中，凡是用 Latest LTS标注的版本，则表明是长期维护的版本。我们在安装时，建议安装这些版本。当然，我们也可以在网址 https://nodejs.org/en/download/releases/ 查看 LTS 的历史版本。\nNode.js 的常用命令 查看 node 的版本：\n1 $ node -v 执行脚本字符串：\n1 $ node -e \u0026#39;console.log(\u0026#34;Hello World\u0026#34;)\u0026#39; 运行脚本文件：\n1 2 3 4 5 $ node index.js $ node path/index.js $ node path/index 查看帮助：\n1 $ node --help 进入 REPL 环境：\n1 $ node REPL 的全称：Read、Eval、 Print、Loop。类似于浏览器的控制台。\n如果要退出 REPL 环境，可以输入.exit 或 process.exit()。\n在 VS Code 里，我们可以在菜单栏选择“帮助-\u0026gt;切换开发人员工具”，打开 console 控制台。\n包和 NPM 什么是包 由于 Node 是一套轻内核的平台，虽然提供了一系列的内置模块，但是不足以满足开发者的需求，于是乎出现了包（package）的概念： 与核心模块类似，就是将一些预先设计好的功能或者说 API 封装到一个文件夹，提供给开发者使用。\nNode 本身并没有太多的功能性 API，所以市面上涌现出大量的第三方人员开发出来的 Package。\n包的加载机制 如果 Node 中自带的包和第三方的包名冲突了，该怎么处理呢？原则是：\n先在系统核心（优先级最高）的模块中找；\n然后到当前项目中 node_modules 目录中找。\n比如说：\n1 requiere(`fs`); 那加载的肯定是系统的包。所以，我们尽量不要创建一些和现有的包重名的包。\nNPM 的概念 NPM：Node Package Manager。官方链接： https://www.npmjs.com/\nNode.js 发展到现在，已经形成了一个非常庞大的生态圈。包的生态圈一旦繁荣起来，就必须有工具去来管理这些包。NPM 应运而生。\n举个例子，当我们在使用 Java 语言做开发时，需要用到 JDK 提供的内置库，以及第三方库。同样，在使用 JS 做开发时，我们可以使用 NPM 包管理器，方便地使用成熟的、优秀的第三方框架，融合到我们自己的项目中，极大地加速日常开发的构建过程。\n随着时间的发展，NPM 出现了两层概念：\n一层含义是 Node 的开放式模块登记和管理系统，亦可以说是一个生态圈，一个社区。\n另一层含义是 Node 默认的模块管理器，是一个命令行下的软件，用来安装和管理 Node 模块。\nNPM 的安装（不需要单独安装） NPM 不需要单独安装。默认在安装 Node 的时候，会连带一起安装 NPM：\nNVM、Node、NPM 安装之后，目录分布如下：\n输入 npm -v，查看 npm 的版本：\n如果上方命令无效，可能是之前的 node 并没有完全安装成功。解决办法：https://segmentfault.com/a/1190000011114680\n另外，Node 附带的 NPM 可能不是最新版本，可以用下面的命令，更新到最新版本：\n1 $ npm install npm -g 配置 NPM 的全局目录（暂略） NPM 默认安装到当前正在使用 Node 版本所在目录下。我们建议重新配置 NPM 的全局目录。\n输入npm config ls，查看：\nNPM 的常用命令 查看 npm 当前版本：\n1 npm -v 更新 npm：\n1 npm install npm@latest -g 项目初始化：（执行完成后，会生成package.json文件）\n1 2 3 4 npm init # 快速跳过问答式界面，选择默认配置 npm init --yes 只在当前工程下安装指定的包：\n1 npm install [package] 在全局安装指定的包：\n1 npm install -g [package] 安装的包只用于开发环境，不用于生产环境：（会出现在 package.json 文件中的 devDependencies 属性中）\n1 2 3 4 npm install [package] --save-dev # 或者 npm install [package] -D 安装的包需要发布到生产环境：（会出现在 package.json 文件中的 dependencies 属性中）\n1 2 3 4 npm install [package] --save # 或者 npm install [package] -S 查看当前目录下已安装的 node 包：\n1 npm list 查看全局已经安装的 node 包：\n1 npm list -g 查看 npm 帮助命令：\n1 npm --help 查看指定命令的帮助：\n1 npm [指定命令] --help 更新指定的包：\n1 npm update [package] 卸载指定的包：\n1 npm uninstall [package] 查看配置信息：\n1 npm config list 查看本地安装的指定包的信息，没有则显示 empty：\n1 npm ls [package] 查看全局安装的指定包的信息，没有则显示 empty：\n1 npm ls [package] -g 查看远程 npm 上指定包的所有版本信息：\n1 npm info [package] 查看当前包的安装路径：\n1 npm root 查看全局包的安装路径：\n1 npm root -g 配置 npm 镜像源 由于 npm 默认的下载地址在国外（npmjs.com），有时候会被墙，导致无法下载或者下载很慢。因此，我们可以尝试切换成，从其他的镜像源下载 npm 包。\n切换镜像源，有下面这几种方式：\n方式 1：临时切换镜像源。\n方式 2：切换镜像源\n方式 3：通过 NRM 切换镜像源（最为推荐的方式）。\n方式 4：cnpm。\n下面来分别讲一下。\n方式 1：临时切换镜像源 安装指定包的时候，通过追加 --registry参数即可。格式如下：\n1 2 3 4 5 # 格式 npm install [package] --registry [https://xxx] # 举例：在下载安装 express 这个包的时候，临时指定镜像源为 https://registry.npm.taobao.org npm install express --registry https://registry.npm.taobao.org 方式 2：切换镜像源 1 npm config set registry https://registry.npm.taobao.org 执行上述命令后，以后下载所有 npm 包的时候，都会改为使用淘宝的镜像源。\n方式 3：通过 NRM 切换镜像源（推荐） NRM：Node Registry Manager。作用是：切换和管理 npm 包的镜像源。\n项目地址：https://www.npmjs.com/package/nrm\nGitHub 地址： https://github.com/Pana/nrm\n安装 NRM：\n1 npm install -g nrm NRM 的常用命令：\n1 2 3 4 5 # 显示全部的镜像 nrm ls # 使用淘宝的镜像 nrm use taobao 效果如下：\n推荐的国内加速镜像淘宝：https://npm.taobao.org/\n方式 4：安装 cnpm 项目地址：https://npm.taobao.org/ 安装cnpm替换 npm（npm 由于源服务器在国外，下载包的速度较慢，cnpm 会使用国内镜像）：\n1 npm install -g cnpm --registry=https://registry.npm.taobao.org 以后我们就可以通过 cnpm 命令去安装一个包。举例如下：\n1 2 # 安装 vue 这个包 cnpm install vue 这里的单词 install 可以简写成 i。\nNode.js 的简单使用 我们可以输入node命令，然后在里面写 js 的代码。\n或者，也可以 通过 node 运行 指定的 js 文件。比如，编写好一个 js 文件01.js，然后在命令行输入：\n1 node 01.js 就可以执行这个 js 程序，直接在命令行查看运行结果。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/03-node.js%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/","summary":"Node.js 运行环境配置：通过 Node.js 安装包（不推荐） 去 Node.js 的官网下载安装包： 我们也可以在https://nodejs.org/en/download/rel","title":"03-Node.js开发环境安装"},{"content":"组件的生命周期 在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件统称为组件的生命周期。\n生命周期的阶段 组件生命周期分为三个阶段，下面分别来讲解。\n1、组件创建阶段 组件创建阶段的生命周期函数，有一个显著的特点：创建阶段的生命周期函数，在组件的一辈子中，只执行一次。\ngetDefaultProps 初始化 props 属性默认值。\ngetInitialState 初始化组件的私有数据。因为 state 是定义在组件的 constructor 构造器当中的，只要new 了 class类，必然会调用 constructor构造器。\ncomponentWillMount() 组件将要被挂载。此时还没有开始渲染虚拟DOM。\n在这个阶段，不能去操作DOM元素，但可以操作属性、状态、function。相当于 Vue 中的Create()函数。\nrender() 第一次开始渲染真正的虚拟DOM。当render执行完，内存中就有了完整的虚拟DOM了。\n意思是，此时，虚拟DOM在内存中创建好了，但是还没有挂在到页面上。\n在这个函数内部，不能去操作DOM元素，因为还没return之前，虚拟DOM还没有创建；当return执行完毕后，虚拟DOM就创建好了，但是还没有挂在到页面上。\ncomponentDidMount() 当组件（虚拟DOM）挂载到页面之后，会进入这个生命周期函数。\n只要进入到这个生命周期函数，则必然说明，页面上已经有可见的DOM元素了。此时，组件已经显示到了页面上，state上的数据、内存中的虚拟DOM、以及浏览器中的页面，已经完全保持一致了。\n当这个方法执行完，组件就进入都了 运行中 的状态。所以说，componentDidMount 是创建阶段的最后一个函数。\n在这个函数中，我们可以放心的去 操作 页面上你需要使用的 DOM 元素了。如果我们想操作DOM元素，最早只能在 componentDidMount 中进行。相当于 Vue 中的 mounted() 函数\n2、组件运行阶段 有一个显著的特点，根据组件的state和props的改变，有选择性的触发0次或多次。\ncomponentWillReceiveProps() 组件将要接收新属性。只有当父组件中，通过某些事件，重新修改了 传递给 子组件的 props 数据之后，才会触发这个钩子函数。\nshouldComponentUpdate() 判断组件是否需要被更新。此时，组件尚未被更新，但是，state 和 props 肯定是最新的。\ncomponentWillUpdate() 组件将要被更新。此时，组件还没有被更新，在进入到这个生命周期函数的时候，内存中的虚拟DOM还是旧的，页面上的 DOM 元素也是旧的。（也就是说，此时操作的是旧的 DOM元素）\nrender 此时，又要根据最新的 state 和 props，重新渲染一棵内存中的 虚拟DOM树。当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！此时，虚拟DOM树已经和组件的 state 保持一致了，都是最新的；但是页面还是旧的。\ncomponentDidUpdate 此时，组件完成更新，页面被重新渲染。此时，state、虚拟DOM 和 页面已经完全保持同步。\n3、组件销毁阶段 一辈子只执行一次。\ncomponentWillUnmount: 组件将要被卸载。此时组件还可以正常使用。 React 生命周期的截图如下：\n20190212_1745.jpg\n生命周期对比：\nvue中的生命周期图\nReact Native 中组件的生命周期\n组件生命周期的执行顺序 1、Mounting：\nconstructor()\ncomponentWillMount()\nrender()\ncomponentDidMount()\n2、Updating：\ncomponentWillReceiveProps(nextProps)：接收父组件传递过来的属性\nshouldComponentUpdate(nextProps, nextState)：一旦调用 setState，就会触发这个方法。方法默认 return true；如果 return false，后续的方法就不会走了。\ncomponentWillUpdate(nextProps, nextState)\nrender()\ncomponentDidUpdate(prevProps, prevState)\n3、Unmounting：\ncomponentWillUnmount() ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/03-react%E7%BB%84%E4%BB%B6%E4%B8%80%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/","summary":"组件的生命周期 在组件创建、到加载到页面上运行、以及组件被销毁的过程中，总是伴随着各种各样的事件，这些在组件特定时期，触发的事件统称为组件的生","title":"03-React组件（一）：生命周期"},{"content":"变量的数据类型 为什么需要数据类型 在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数据类型，寓意也不同。\n我们都知道，无论这个变量是字符串类型，还是数字类型，我们都可以直接用 var 去定义它。比如：\n1 2 3 var a = \u0026#39;hello word\u0026#39;; var b = 123; 为什么可以这样做呢？这是因为：JavaScript 是一种「弱类型语言」，或者说是一种「动态语言」，这意味着不需要提前声明变量的类型，在程序运行过程中，类型会自动被确定。\nJS 的变量数据类型，是在程序运行的过程中，根据等号右边的值来确定的。而且，变量的数据类型是可以变化的。比如说：\n1 2 3 var name = \u0026#39;qianguyihao\u0026#39;; name = 123; // 强制将变量 name 修改为 数字类型 JS中一共有六种数据类型 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。\n引用数据类型（引用类型）：Object 对象。\n注意：内置对象 Function、Array、Date、RegExp、Error等都是属于 Object 类型。也就是说，除了那五种基本数据类型之外，其他的，都称之为 Object类型。\n面试问：引用数据类型有几种？\n面试答：只有一种，即 Object 类型。\n数据类型之间最大的区别：\n基本数据类型：参数赋值的时候，传数值。\n引用数据类型：参数赋值的时候，传地址（修改的同一片内存空间）。\n一个经典的例子 基本数据类型举例：\n1 2 3 4 5 6 7 var a = 23; var b = a; a++; console.log(a); // 打印结果：24 console.log(b); // 打印结果：23 上面的代码中：a 和 b 都是基本数据类型，让 b 等于 a，然后改变 a 的值之后，发现 b 的值并没有被改变。\n但是在引用数据类型中，就不同了，我们来看一看。\n引用数据类型举例：\n1 2 3 4 5 6 7 8 9 10 11 var obj1 = new Object(); obj1.name = \u0026#39;smyh\u0026#39;; // 让 obj2 等于 obj1 var obj2 = obj1; // 修改 obj1 的 name 属性 obj1.name = \u0026#39;vae\u0026#39;; console.log(obj1.name); // 打印结果：vae console.log(obj2.name); // 打印结果：vae 上面的代码中：obj1 和 obj2 都是引用数据类型，让 obj2 等于 obj1，然后修改 obj1.name 的值之后，发现 obj2.name 的值也发生了改变。\n从上面的例子中，可以反映出，基本数据类型和引用数据类型是有区别的。\n那到底有什么区别呢？我们进一步往下看。\n栈内存和堆内存 我们首先记住一句话：JS中，所有的变量都是保存在栈内存中的。\n然后来看看下面的区别。\n基本数据类型：\n基本数据类型的值，直接保存在栈内存中。值与值之间是独立存在，修改一个变量不会影响其他的变量。\n引用数据类型：\n对象是保存到堆内存中的。每创建一个新的对象，就会在堆内存中开辟出一个新的空间；而变量保存了对象的内存地址（对象的引用），保存在栈内存当中。如果两个变量保存了同一个对象的引用，当一个通过一个变量修改属性时，另一个也会受到影响。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/03-%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"变量的数据类型 为什么需要数据类型 在计算机中，不同的数据所需占用的存储空间不同，为了充分利用存储空间，于是定义了不同的数据类型。而且，不同的数","title":"03-变量的数据类型：基本数据类型和引用数据类型"},{"content":"ES6 的变量声明 ES5 中，使用 var 定义全局变量（ var 是 variable 的简写）。\nES6 中，新增了 let 和 const 来定义变量：\nlet：定义局部变量，替代 var。\nconst：定义常量（定义后，不可修改）。\n1、var：定义全局变量 看下面的代码：\n1 2 3 4 5 { var a = 1; } console.log(a); //这里的 a，指的是 区块 里的 a 上方代码是可以输出结果的，输出结果为 1。因为 var 是全局声明的，所以，即使是在区块里声明，但仍然在全局起作用。\n也就是说：使用 var 声明的变量不具备块级作用域特性。\n再来看下面这段代码：\n1 2 3 4 5 6 var a = 1; { var a = 2; } console.log(a); //这里的 a，指的是 区块 里的 a 上方代码的输出结果为 2 ，因为 var 是全局声明的。\n总结：\n用 var 定义的全部变量，有时候会污染整个 js 的作用域。我们在如今的实战中，基本都是用的 ES6 语法，所以请尽量避免使用 var 定义变量。\n2、let：定义局部变量 举例 1：\n1 2 3 4 { let a = \u0026#39;hello\u0026#39;; } console.log(a); // 打印结果报错：Uncaught ReferenceError: a is not defined 上方代码，打印报错。\n举例 2：\n1 2 3 4 5 6 var a = 2; { let a = 3; } console.log(a); // 打印结果：2 通过上面两个例子可以看出，用 let 声明的变量，只在局部（块级作用域内）起作用。\n经典面试题：\nlet 可以防止数据污染，我们来看下面这个 for 循环的经典面试题。\n1、用 var 声明变量：\n1 2 3 4 5 for (var i = 0; i \u0026lt; 10; i++) { console.log(\u0026#39;循环体中:\u0026#39; + i); } console.log(\u0026#39;循环体外:\u0026#39; + i); 上方代码可以正常打印结果，且最后一行的打印结果是 10。说明循环体外定义的变量 i，是全局作用域下的 i。\n2、用 let 声明变量：\n1 2 3 4 5 for (let i = 0; i \u0026lt; 10; i++) { console.log(\u0026#39;循环体中:\u0026#39; + i); // // 每循环一次，就会在 { } 所在的块级作用域中，重新定义一个新的变量 i } console.log(\u0026#39;循环体外:\u0026#39; + i); 上方代码的关键在于：每次循环都会产生一个块级作用域，每个块级作用域中会重新定义一个新的变量 i。\n另外，上方代码的最后一行无法打印结果，也就是说打印会报错。因为用 let 定义的变量 i，只在{ }这个块级作用域里生效。\n总结：我们要习惯用 let 声明，减少 var 声明带来的污染全局空间。\n为了进一步说明 let 不会带来污染，需要说明的是：当我们定义了let a = 1时，如果我们在同一个作用域内继续定义let a = 2，是会报错的。\n3、const：定义常量 在程序开发中，有些变量是希望声明后，在业务层就不再发生变化，此时可以用 const 来定义常量。常量就是值（内存地址）不能变化的量。\n举例：\n1 const name = \u0026#39;smyhvae\u0026#39;; //定义常量 用 const 声明的常量，只在局部（块级作用域内）起作用；而且，用 const 声明常量时，必须赋值，否则报错。\nlet 和 const 的特点【重要】 不存在变量提升\n禁止重复声明\n支持块级作用域\n暂时性死区\n相反， 用var声明的变量：存在变量提升、可以重复声明、没有块级作用域。\nvar/let/const 的共同点 全局作用域中定义的变量，可以在函数中使用。\n函数中声明的变量，只能在函数及其子函数中使用，外部无法使用。\n总结 关于 let、const、var 更详细的介绍和区别，可以看本项目的另一篇文章《JavaScript 进阶/var、let、const 的区别.md》。\nfor 循环举例（经典案例） 代码 1、我们先来看看如下代码：（用 var 定义变量 i）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;aa\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;bb\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;cc\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;dd\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; var myBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;); for (var i = 0; i \u0026lt; myBtn.length; i++) { myBtn[i].onclick = function () { alert(i); }; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中的运行效果如下：\n你可能会感到诧异，为何点击任何一个按钮，弹出的内容都是 4 呢？这是因为，我们用 var 定义的变量 i，是在全局作用域声明的。整个代码中，自始至终只有一个变量。\nfor 循环是同步代码，而 onclick 点击事件是异步代码。当我们还没点击按钮之前，同步代码已经执行完了，变量 i 已经循环到 4 了。\n也就是说，上面的 for 循环，相当于如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 var i = 0; myBtn[0].onclick = function () { alert(i); }; i++; myBtn[1].onclick = function () { alert(i); }; i++; myBtn[2].onclick = function () { alert(i); }; i++; myBtn[3].onclick = function () { alert(i); }; i++; // 到这里，i 的值已经是4了。因此，当我们点击按钮时，i的值一直都是4 代码 2、上面的代码中，如果我们改为用 let 定义变量 i：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;aa\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;bb\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;cc\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;dd\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; var myBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;); for (let i = 0; i \u0026lt; myBtn.length; i++) { myBtn[i].onclick = function () { alert(i); }; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中的运行效果如下：\n上面这个运行结果，才是我们预期的效果。我们用 let 定义变量 i，在循环的过程中，每执行一次循环体，就会诞生一个新的 i。循环体执行 4 次，就会有四个 i。\n暂时性死区 DTC ES6 规定：使用 let/const 声明的变量，会使区块形成封闭的作用域。若在声明之前使用变量，就会报错。\n也就是说，在使用 let/const 声明变量时，变量需要先声明，再使用（声明语句必须放在使用之前）。这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）。\nDTC 其实是一种保护机制，可以让我们养成良好的编程习惯。\n代码举例：\n1 2 3 4 5 6 7 8 const name = \u0026#39;qianguyihao\u0026#39;; function foo() { console.log(name); const name = \u0026#39;hello\u0026#39;; } foo(); // 执行函数后，控制台报错：Uncaught ReferenceError: Cannot access \u0026#39;name\u0026#39; before initialization 参考链接： 阮一峰 | ECMAScript 6 入门 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/04-es6%E5%8F%98%E9%87%8F-letconst-%E5%92%8C%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/","summary":"ES6 的变量声明 ES5 中，使用 var 定义全局变量（ var 是 variable 的简写）。 ES6 中，新增了 let 和 const 来定义变量： let：定义局部变量，替代 var。 const：定义常量（","title":"04-ES6：变量 let、const 和块级作用域"},{"content":"前言 MySQL 中的字段，主要有四种数据类型：\n整型（整数）\n小数\n字符串类型\n时间日期类型\n下面来详细讲一讲。\n整数类型 整数类型的分类 MySQL中，整型有五种：\n迷你整型：tinyint，使用1个字节存储整数，最多存储256个整数（-128~127）。\n短整型：smallint，使用2个字节存储整数。\n中整型：mediumint，使用3个字节存储整数。\n标准整型：int，使用4个字节存储整数。\n大整型：bigint，使用8个字节存储。\n强调：\n（1）如果你不知道用哪一种，或者懒得计算，那就用标准整型 int吧，这个用的最多。\n（2）整型在 MySQL 中默认是有符号的，即有正负；无符号需要使用 unsigned 修饰整型，代表正整数。\n举例：\n在指定的表中新增 age 字段，要求 age 是正整数：\n1 alter table table_qiangu1 add age int unsigned; 设计思路 如果需要新建整型的字段，设计思路如下：\n（1）确定需要存储的数据是整数。\n（2）预估整数的范围，选择合适的整数类型。\n（3）确定这个整数是否需要包含负数。\n整数类型的取值范围 todo。参考链接：https://blog.csdn.net/slyjit/article/details/54290486\n整数类型的显示宽度、零填充 我们在很多设计表中，可能会看到比如 int(11)这种数据类型，这里面的 11代表的就是显示宽度。\n所谓的显示宽度，其实就是显示的时候，看到的最少数字个数。\n比如 int(2) ，表示不管你的数值是多少，最少可以看到两个数字。假如你存的数值是9，没有满两位，就会在前面补零，显示为09；假如你的数值是120，超过了显示宽度，则直接显示原始值，不会做零填充。\n显示宽度的注意事项：\n显示宽度只适用于 MySQL 的整数类型。\n显示宽度只是指明 MySQL 整数类型最少显示的数字个数（可以通过desc查看表字段显示）。\n显示宽度只是在显示的时候改变数值的样式，不会对原本的值进行更改。\n显示宽度和数值类型的取值范围无关。例如int(10) 他的取值范围依然是(-2 147 483 648，2 147 483 647)。\n零填充的注意事项：\n要想让显示宽度自动进行零填充，必须要配合 ZEROFILL这个关键字一起使用。\n零填充只能针对正整数，也就是说，ZEROFILL 要求整型为无符号型。\n举例：\n1、新建一张表，然后在这张表中新增 num1 字段，要求 num1 显示3位，不够3位的自动进行零填充：\n1 2 3 4 5 6 7 8 9 10 11 12 13 # 新建一张表 CREATE TABLE table_qiangu1 ( id int NOT NULL AUTO_INCREMENT PRIMARY KEY ); # 显示宽度有效（正确写法） alter table table_qiangu1 add num1 int(3) zerofill; # 对比：普通写法，显示宽度无效 alter table table_qiangu1 add num2 int(3); # 对比：普通写法 alter table table_qiangu1 add num3 int; 上述命令中，如果把 zerofill 这个关键字去掉，是达不到显示宽度的效果的。执行完上述命令后，我们执行 desc table_qiangu1 命令，对比一下 num1、num2、num3 的字段结构就知道了：\n上方截图可以看到，只有 num1 才有显示宽度，它可以进行零填充，num2、num3不行。我们往表中插入整数 6，然后看看显示结果，就一目了然：\n参考链接：MySql数据库 数值类型的显示宽度\n小数 MySQL 中的小数分为两大类：\n浮点型的数据分为两种：\n单精度：float，使用4个字节存储，精度范围为6-7位有效数字。\n双精度：double，使用8个字节存储，精度范围为14-15位有效数字。\n注意：\n浮点数超过精度范围会自动进行四舍五入。\n精度可以指定整数和小数部分。比如\n","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/04-mysql%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"前言 MySQL 中的字段，主要有四种数据类型： 整型（整数） 小数 字符串类型 时间日期类型 下面来详细讲一讲。 整数类型 整数类型的分类 MySQL中，整型有五种：","title":"04-MySQL字段的数据类型"},{"content":"前言 网站越来越复杂，js代码、js文件也越来越多，会遇到一些问题：\n文件依赖\n全局污染、命名冲突\n程序模块化包括：\n日期模块\n数学计算模块\n日志模块\n登陆认证模块\n报表展示模块等。\n所有这些模块共同组成了程序软件系统。\n一次编写，多次使用，才是提高效率的核心。\n模块化的理解 什么是模块化 概念：将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起。\n模块的内部数据、实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。\n最早的时候，我们会把所有的代码都写在一个js文件里，那么，耦合性会很高（关联性强），不利于维护；而且会造成全局污染，很容易命名冲突。\n模块化的好处 避免命名冲突，减少命名空间污染\n降低耦合性；更好地分离、按需加载\n高复用性：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能。\n高可维护性：软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁。使用模块化的开发，方式更容易维护。\n部署方便\n模块化规范 模块化规范的引入 假设我们引入模块化，首先可能会想到的思路是：在一个文件中引入多个js文件。如下：\n1 2 3 4 5 6 7 \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;zepto.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;fastClick.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;util/login.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;util/base.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;util/city.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 但是这样做会带来很多问题：\n请求过多：引入十个js文件，就有十次http请求。\n依赖模糊：不同的js文件可能会相互依赖，如果改其中的一个文件，另外一个文件可能会报错。\n以上两点，最终导致：难以维护。\n于是，这就引入了模块化规范。\n模块化的概念解读 模块化起源于 Node.js。Node.js 中把很多 js 打包成 package，需要的时候直接通过 require 的方式进行调用（CommonJS），这就是模块化的方式。\n那如何把这种模块化思维应用到前端来呢？这就产生了两种伟大的 js：RequireJS 和 SeaJS。\n模块化规范 服务器端规范：\nCommonJS规范：是 Node.js 使用的模块化规范。 CommonJS 就是一套约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。\n浏览器端规范：\nAMD规范：是 RequireJS 在推广过程中对模块化定义的规范化产出。 1 2 3 4 5 - 异步加载模块； - 依赖前置、提前执行：require([`foo`,`bar`],function(foo,bar){}); //也就是说把所有的包都 require 成功，再继续执行代码。 - define 定义模块：define([`require`,`foo`],function(){return}); CMD规范：是 SeaJS 在推广过程中对模块化定义的规范化产出。淘宝团队开发。 1 2 3 4 5 6 同步加载模块； 依赖就近，延迟执行：require(./a) 直接引入。或者Require.async 异步引入。 //依赖就近：执行到这一部分的时候，再去加载对应的文件。 define 定义模块， export 导出：define(function(require, export, module){}); PS：面试时，经常会问AMD 和 CMD 的区别。\n另外，还有ES6规范：import \u0026amp; export。\n这篇文章，我们来讲一下CommonJS，它是 Node.js 使用的模块化规范。\nCommonJS 的基本语法 CommonJS 的介绍 CommonJS：是 Node.js 使用的模块化规范。也就是说，Node.js 就是基于 CommonJS 这种模块化规范来编写的。\nCommonJS 规范规定：每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的 module.exports 对象。\n在 CommonJS 中，每个文件都可以当作一个模块：\n在服务器端：模块的加载是运行时同步加载的。\n在浏览器端: 模块需要提前编译打包处理。首先，既然同步的，很容易引起阻塞；其次，浏览器不认识require语法，因此，需要提前编译打包。\n模块的暴露和引入 Node.js 中只有模块级作用域，两个模块之间的变量、方法，默认是互不冲突，互不影响，这样就导致一个问题：模块 A 要怎样使用模块B中的变量\u0026amp;方法呢？这就需要通过 exports 关键字来实现。\nNode.js中，每个模块都有一个 exports 接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他的模块才可以使用。\n接下来详细讲一讲模块的暴露、模块的引入。\n暴露模块的方式一： exports exports对象用来导出当前模块的公共方法或属性。别的模块通过 require 函数调用当前模块时，得到的就是当前模块的 exports 对象。\n语法格式：\n1 2 // 相当于是：给 exports 对象添加属性 exports.xxx = value 这个 value 可以是任意的数据类型。\n注意：暴露的关键词是exports，不是export。其实，这里的 exports 类似于 ES6 中的 export 的用法，都是用来导出一个指定名字的对象。\n代码举例：\n1 2 3 4 5 6 7 8 const name = \u0026#39;qianguyihao\u0026#39;; const foo = function (value) { return value * 2; }; exports.name = name; exports.foo = foo; 暴露模块的方式二： module.exports module.exports用来导出一个默认对象，没有指定对象名。\n语法格式：\n1 2 3 4 5 // 方式一：导出整个 exports 对象 module.exports = value; // 方式二：给 exports 对象添加属性 module.exports.xxx = value; 这个 value 可以是任意的数据类型。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 方式1 module.exports = { name: \u0026#39;我是 module1\u0026#39;, foo(){ console.log(this.name); } } // 我们不能再继续写 module.exports = value2。因为重新赋值，会把 exports 对象 之前的赋值覆盖掉。 // 方式2 const age = 28; module.exports.age = age; module.exports 还可以修改模块的原始导出对象。比如当前模块原本导出的是一个对象，我们可以通过 module.exports 修改为导出一个函数。如下：\n1 2 3 module.exports = function () { console.log(\u0026#39;hello world\u0026#39;) } exports 和 module.exports 的区别 最重要的区别：\n使用exports时，只能单个设置属性 exports.a = a;\n使用module.exports时，既单个设置属性 module.exports.a，也可以整个赋值 module.exports = obj。\n其他要点：\nNode中每个模块的最后，都会执行 return: module.exports。\nNode中每个模块都会把 module.exports指向的对象赋值给一个变量 exports，也就是说 exports = module.exports。\nmodule.exports = XXX，表示当前模块导出一个单一成员，结果就是XXX。\n如果需要导出多个成员，则必须使用 exports.add = XXX; exports.foo = XXX。或者使用 module.exports.add = XXX; module.export.foo = XXX。\n问题: 暴露的模块到底是谁？ 答案：暴露的本质是exports对象。【重要】\n比如，方式一的 exports.a = a 可以理解成是，给 exports 对象添加属性。方式二的 module.exports = a可以理解成是给整个 exports 对象赋值。方式二的 module.exports.c = c可以理解成是给 exports 对象添加属性。\nNode.js 中每个模块都有一个 module 对象，module 对象中的有一个 exports 属性称之为接口对象。我们需要把模块之间公共的方法或属性挂载在这个接口对象中，方便其他的模块使用。\n引入模块的方式：require require函数用来在一个模块中引入另外一个模块。传入模块名，返回模块导出对象。\n语法格式：\n1 const module1 = require(\u0026#39;模块名\u0026#39;); 解释：\n内置模块：require的是包名。\n下载的第三方模块：require的是包名。\n自定义模块：require的是文件路径。文件路径既可以用绝对路径，也可以用相对路径。后缀名.js可以省略。\n代码举例：\n1 2 3 4 5 const module1 = require(\u0026#39;./main.js\u0026#39;); const module2 = require(\u0026#39;./main\u0026#39;); const module3 = require(\u0026#39;Demo/src/main.js\u0026#39;); require()函数的两个作用：\n执行导入的模块中的代码。\n返回导入模块中的接口对象。\n主模块 主模块是整个程序执行的入口，可以调度其他模块。\n1 2 # 运行main.js启动程序。此时，main.js就是主模块 $ node main.js 模块的初始化 一个模块中的 JS 代码仅在模块第一次被使用时执行一次，并且在使用的过程中进行初始化，然后会被缓存起来，便于后续继续使用。\n代码举例：\n（1）calModule.js:\n1 2 3 4 5 6 7 var a = 1; ​ function add () { return ++a; } ​ exports.add = add; （2）main.js：（在 main.js 中引入 hello.js 模块）\n1 2 3 4 5 var addModule1 = require(\u0026#39;./calModule\u0026#39;) var addModule2 = require(\u0026#39;./calModule\u0026#39;) ​ console.log(addModule1.add()); console.log(addModule2.add()); 在命令行执行 node main.js 运行程序，打印结果：\n1 2 2 3 从打印结果中可以看出，calModule.js这个模块虽然被引用了两次，但只初始化了一次。\nCommonJS 在服务器端的实现举例 1、初始化项目 在工程文件中新建如下目录和文件：\n1 2 3 4 5 6 modules | module1.js | module2.js | module3.js app.js 然后在根目录下新建如下命令：\n1 npm init 然后根据提示，依次输入如下内容：\n包名：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。\n版本：可以用默认的版本 1.0.0，也可以自己修改包名。\n其他的参数，一路回车即可。效果如下：\n于是，根目录下会自动生成package.json这个文件。点进去看一下：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;name\u0026#34;: \u0026#34;commonjs_node\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;app.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;smyhvae\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 2、导入第三方包 uniq这个第三方包的作用是保证唯一性（我们拿它来举例）。我们在当前工程目录下，输入如下命令进行安装：\n1 npm install uniq 安装成功后，根目录下会自动生成相应的文件：\n需要说明的是，我的node版本是 v8.10.0（v8以上），对应的 npm 版本是 v5.6.0，版本比较高，因此，当我输入完npm install uniq之后，package.json中就会自动添加uniq包的依赖：\n如果有些童鞋的npm版本较低，就需要手动去添加依赖；另一种方式是，可以使用npm install uniq --save命令，这个多出来的--save就可以自动添加依赖。\n我们去官网看一下uniq的用法：\n1 2 3 4 5 let uniq = require(\u0026#39;uniq\u0026#39;); let arr = [1, 1, 2, 2, 3, 5]; uniq(arr); console.log(arr); //输出结果：[ 1, 2, 3, 5 ] 可以看出，这个包可以起到数组去重的作用。\n3、自定义模块 （1）module1.js：\n1 2 3 4 5 6 7 8 9 10 11 //暴露方式一：module.exports = value //暴露一个对象出去 module.exports = { name: \u0026#39;我是 module1\u0026#39;, foo(){ console.log(this.name); } } //我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。 （2）module2.js：\n1 2 3 4 5 6 //暴露方式一：module.exports = value //暴露一个函数出去 module.exports = function(){ console.log(\u0026#39;我是 module2\u0026#39;); } 注意，此时暴露出去的 exports 对象 等价于整个函数。\n（3）module3.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //暴露方式二：exports.xxx = value //可以往 export 对象中不断地添加属性，进行暴露 exports.foo1 = function(){ console.log(\u0026#39;module3 中的 foo1 方法\u0026#39;); } exports.foo2 = function(){ console.log(\u0026#39;module3 中的 foo2 方法\u0026#39;); } exports.arr = [1,1,2,2,3,5,11]; （4）app.js：（将其他模块汇集到主模块）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //将其他模块汇集到主模块 let uniq = require(\u0026#39;uniq\u0026#39;); //引入时，第三方模块要放在自定义模块的上面 let module1 = require(\u0026#39;./modules/module1\u0026#39;); let module2 = require(\u0026#39;./modules/module2\u0026#39;); let module3 = require(\u0026#39;./modules/module3\u0026#39;); //调用module1对象的方法 module1.foo(); //调用module2的函数 module2(); //注意，在定义时，module2对象等价于整个函数function。所以，module2()的意思是，直接调用了函数。 //调用module3中的属性 module3.foo1(); module3.foo2(); uniq(module3.arr); //将module3中的数组进行去重操作 console.log(module3.arr); //打印数组去重后的结果 这样的话，我们的代码就写完了。\n我们在命令行中输入node app.js，就可以把代码跑起来了。打印结果如下：\n1 2 3 4 5 我是 module1 我是 module2 module3 中的 foo1 方法 module3 中的 foo2 方法 [ 1, 11, 2, 3, 5 ] CommonJS 基于浏览器端的实现举例 1、初始化项目 在工程文件中新建如下目录和文件：\n1 2 3 4 5 6 7 8 js dist //打包生成文件的目录 src //源码所在的目录 | module1.js | module2.js | module3.js | app.js //应用主源文件 index.html //因为CommonJS是基于浏览器端，js文件要跑在浏览器的页面上，所以要有这个html页面 然后在根目录下新建如下命令：\n1 npm init 然后根据提示，依次输入如下内容：\n包名：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。\n版本：可以用默认的版本 1.0.0，也可以自己修改包名。\n其他的参数，一路回车即可。\n于是，根目录下会自动生成package.json这个文件。点进去看一下：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;name\u0026#34;: \u0026#34;commonjs_browser\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34; } 2、下载第三方包：Browserify 这里需要用到Browserify这个工具进行编译打包。Browserify 称为 CommonJS 的浏览器端的打包工具。\n输入如下命令进行安装：（两个命令都要输入）\n1 2 npm install browserify -g //全局 npm install browserify --save-dev //局部。 上面的代码中，-dev表示开发依赖。这里解释一下相关概念：\n开发依赖：当前这个包，只在开发环境下使用。\n运行依赖：当前这个包，是在生产环境下使用。\n3、自定义模块 \u0026amp; 代码运行 （1）module1.js：\n1 2 3 4 5 6 7 8 9 10 11 //暴露方式一：module.exports = value //暴露一个对象出去 module.exports = { name: \u0026#39;我是 module1\u0026#39;, foo(){ console.log(this.name); } } //我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。 （2）module2.js：\n1 2 3 4 5 6 //暴露方式一：module.exports = value //暴露一个函数出去 module.exports = function(){ console.log(\u0026#39;我是 module2\u0026#39;); } 注意，此时暴露出去的 exports 对象 等价于整个函数。\n（3）module3.js：\n1 2 3 4 5 6 7 8 9 10 11 //暴露方式二：exports.xxx = value //可以往export对象中不断地添加属性，进行暴露 exports.foo1 = function(){ console.log(\u0026#39;module3 中的 foo1 方法\u0026#39;); } exports.foo2 = function(){ console.log(\u0026#39;module3 中的 foo2 方法\u0026#39;); } （4）app.js：（将其他模块汇集到主模块）\n1 2 3 4 5 6 7 8 let module1 = require(\u0026#39;./module1\u0026#39;); // ./ 指的是当前路径 let module2 = require(\u0026#39;./module2\u0026#39;); let module3 = require(\u0026#39;./module3\u0026#39;); module1.foo(); module2(); module3.foo1(); module3.foo2(); 引入的路径解释：\n./是相对路径，指的是当前路径（app.js的当前路径是src） 到此，我们的主要代码就写完了。\n但是，如果我们直接在index.html中，像下面这样写，是不行的：（因为浏览器不认识 require 关键字）\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;./js/src/app.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 为了能够让index.html引入app.js，我们需要输入如下命令：\n打包处理js:\n1 browserify js/src/app.js -o js/dist/bundle.js 然后在index.html中引入打包后的文件：\n1 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;js/dist/bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/04-node.js%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83commonjs/","summary":"前言 网站越来越复杂，js代码、js文件也越来越多，会遇到一些问题： 文件依赖 全局污染、命名冲突 程序模块化包括： 日期模块 数学计算模块 日志模块 登陆","title":"04-Node.js模块化规范：CommonJS"},{"content":"defaultProps 和 prop-types 使用 defaultProps 设置组件的默认值 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值。\n格式举例：\n1 2 3 4 // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） }; 使用prop-types进行props数据类型的校验 在组件中，可以通过 prop-types 把外界传递过来的属性，做类型校验。如果类型不匹配，控制台会弹出告警。\n注意：如果要为 传递过来的属性做类型校验，必须安装 React 提供的 第三方包，叫做 prop-types。\n格式举例：\n1 2 3 static propTypes = { initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 }; 下方代码中，在引用组件的时候，如果类型不匹配：\n1 2 3 4 5 6 7 8 // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; {/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */} \u0026lt;Counter initcount=\u0026#34;我是string类型\u0026#34;\u0026gt;\u0026lt;/Counter\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); 控制台告警如下：\n20190212_2130.png\n代码举例 我们把 defaultProps 和 prop-types 来举个例子。\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; // 导入计数器组件 import Counter from \u0026#34;./components/Counter.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; {/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */} \u0026lt;Counter initcount={0}\u0026gt;\u0026lt;/Counter\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); （3）/components/Counter.jsx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import React from \u0026#34;react\u0026#34;; // 注意： prop-types 包中职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验 import ReactTypes from \u0026#34;prop-types\u0026#34;; export default class Counter extends React.Component { constructor(props) { super(props); // 初始化组件，保存的是组件的私有数据 this.state = { msg: \u0026#34;ok\u0026#34;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 }; } // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个 数值，为0 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Counter 计数器组件 \u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;当前的计数是：{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 } } 运行效果：\n20190212_2100.png\n事件绑定 案例：点击按钮后，计数器 +1。\n原生js做事件绑定 代码举例：\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; // 导入计数器组件 import Counter from \u0026#34;./components/Counter.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; {/* 规定，每个用户在使用 组件的时候，必须传递一个 默认的 数值，作为 组件初始化的 数据 */} \u0026lt;Counter initcount={0}\u0026gt;\u0026lt;/Counter\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); （3）/components/Counter.jsx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 import React from \u0026#34;react\u0026#34;; // 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验 import ReactTypes from \u0026#34;prop-types\u0026#34;; export default class Counter extends React.Component { constructor(props) { super(props); // 初始化组件，保存的是组件的私有数据 this.state = { msg: \u0026#34;ok\u0026#34;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 }; } // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） }; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = { initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Counter 计数器组件 \u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;+1\u0026#34; id=\u0026#34;btn\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;当前的计数是：{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 } // 当组件挂载到页面上之后，会进入这个生命周期函数，只要进入这个生命周期函数了，必然说明，页面上，已经有可见的DOM元素了 componentDidMount() { // 在这个函数中，我们可以放心的去 操作 页面上你需要使用的 DOM 元素了。 // 也就是说，如果我们想操作DOM元素，最早，只能在 componentDidMount 中进行。 document.getElementById(\u0026#34;btn\u0026#34;).onclick = () =\u0026gt; { this.setState({ count: this.state.count + 1 }); }; } } 使用 React 提供的方法，做事件绑定 代码举例：\n（1）index.html和 （2）main.js 的代码不变，和上一小段中的代码一致。\n（3）/components/Counter.jsx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 import React from \u0026#34;react\u0026#34;; // 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验 import ReactTypes from \u0026#34;prop-types\u0026#34;; export default class Counter extends React.Component { constructor(props) { super(props); // 初始化组件，保存的是组件的私有数据 this.state = { msg: \u0026#34;ok\u0026#34;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 }; } // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） }; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = { initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Counter 计数器组件 \u0026lt;/h3\u0026gt; {/* 这里的 this 指向的是 Counter 组件的实例 */} \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;+1\u0026#34; id=\u0026#34;btn\u0026#34; onClick={this.myMethod} /\u0026gt; \u0026lt;p\u0026gt;当前的计数是：{this.state.count}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 } // 点击事件的方法定义 myMethod = () =\u0026gt; { // 修改组件的state里面的值 this.setState({ count: this.state.count + 1 }); }; } 生命周期函数：shouldComponentUpdate() 在 shouldComponentUpdate() 函数中，必须要求返回一个布尔值。\n需要注意的是：如果返回的值是 false，则不会继续执行后续的生命周期函数，而是直接退回到了 运行中 的状态。因为此时，后续的 render 函数并没有被调用，因此页面不会被更新，但是组件的 state 状态，却被修改了。这种情况，我们也可以这样理解：如果返回值为 false，此时只是更新了 state 里面的数值，但是并没有渲染到 DOM节点上。\n利用上面这个特性，我们可以来举个例子。\n举例：实现 Counter 计数器只在偶数情况下更新。\n实现思路：在 shouldComponentUpdate() 函数中，如果 state 中 的count 的值为奇数，就 return false；否则就 return true。\n代码实现：（我们在上面的Counter.jsx代码基础之上，做添加）\n1 2 3 4 5 6 7 8 9 10 11 12 // 判断组件是否需要更新 shouldComponentUpdate(nextProps, nextState) { // 经过打印测试发现：在 shouldComponentUpdate 中，通过 this.state.count 拿到的值，是上一次的旧数据，并不是当前最新的； // 解决办法：通过 shouldComponentUpdate 函数的第二个参数 nextState，可以拿到 最新的 state 数据。 console.log(this.state.count + \u0026#34; ---- \u0026#34; + nextState.count); // 需求： 如果 state 中的 count 值是偶数，则 更新页面；如果 count 值 是奇数，则不更新页面。最终实现的的页面效果：2，4，6，8，10，12.... // return this.state.count % 2 === 0 ? true : false return nextState.count % 2 === 0 ? true : false; } 上面这部分的代码，和 render() 方法是并列的。我们需要注意里面的注释，关注 nextState 参数的用法。\n在js代码中获取html标签的属性 比如说，如果想获取 html标签的 innerHTML 属性，做法如下：\n通过原生 js 获取：\n1 document.getElementById(\u0026#39;myh3\u0026#39;).innerHTML 也可以通过 React 提供的 refs 获取：\n1 this.refs.h3.innerHTML 代码举例：\n（3）/components/Counter.jsx：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 import React from \u0026#34;react\u0026#34;; // 注意： prop-types 包的职能跟单一，只提供了 一些常见的 数据类型，用于做类型校验 import ReactTypes from \u0026#34;prop-types\u0026#34;; export default class Counter extends React.Component { constructor(props) { super(props); // 初始化组件，保存的是组件的私有数据 this.state = { msg: \u0026#34;ok\u0026#34;, count: props.initcount // 把 父组件传递过来的 initcount 赋值给子组件 state 中的 count值。这样的话，就把 count 值改成了可读可写的 state 属性。因此，以后就能实现“点击 按钮 ，count 值 + 1”的需求了 }; } // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值 static defaultProps = { initcount: 0 // 如果外界没有传递 initcount，那么，自己初始化一个数值（比如0） }; // 这是创建一个 静态的 propTypes 对象，在这个对象中，可以把 外界传递过来的属性，做类型校验 static propTypes = { initcount: ReactTypes.number // 使用 prop-types 包，来定义 initcount 为 number 类型 }; render() { return ( \u0026lt;div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是 Counter 计数器组件 \u0026lt;/h3\u0026gt; {/* 这里的 this 指向的是 Counter 组件的实例 */} \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;+1\u0026#34; id=\u0026#34;btn\u0026#34; onClick={this.myMethod} /\u0026gt; \u0026lt;h3 id=\u0026#34;myh3\u0026#34; ref=\u0026#34;mymyh3\u0026#34;\u0026gt; 当前的计数是：{this.state.count} \u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); // 当 return 执行完毕后， 虚拟DOM创建好了，但是，还没有挂载到真正的页面中 } // 点击事件的方法定义 myMethod = () =\u0026gt; { // 修改组件的state里面的值 this.setState({ count: this.state.count + 1 }); }; // 判断组件是否需要更新 shouldComponentUpdate(nextProps, nextState) { // 需求： 如果 state 中的 count 值是偶数，则 更新页面；如果 count 值 是奇数，则不更新页面。最终实现的的页面效果：2，4，6，8，10，12.... // 经过打印测试发现：在 shouldComponentUpdate 中，通过 this.state.count 拿到的值，是上一次的旧数据，并不是当前最新的； // 解决办法：通过 shouldComponentUpdate 函数的第二个参数 nextState，可以拿到 最新的 state 数据。 console.log(this.state.count + \u0026#34; ---- \u0026#34; + nextState.count); // return this.state.count % 2 === 0 ? true : false // return nextState.count % 2 === 0 ? true : false; return true; } // 组件将要更新。此时尚未更新，在进入这个 生命周期函数的时候，内存中的虚拟DOM是旧的，页面上的 DOM 元素 也是旧的 componentWillUpdate() { // 经过打印分析发现：此时页面上的 DOM 节点，都是旧的，应该慎重操作，因为你可能操作的是旧DOM // console.log(document.getElementById(\u0026#39;myh3\u0026#39;).innerHTML) console.log(this.refs.mymyh3.innerHTML); } // 组件完成了更新。此时，state 中的数据、虚拟DOM、页面上的DOM，都是最新的，此时，你可以放心大胆的去操作页面了 componentDidUpdate() { console.log(this.refs.mymyh3.innerHTML); } } 上方代码中，componentWillUpdate() 和 componentDidUpdate() 方法里的代码，就是我们这一段要举的例子。\n需要注意的是，\u0026lt;h3 id=\u0026quot;myh3\u0026quot; ref=\u0026quot;mymyh3\u0026quot;\u0026gt;这部分代码中，属性名只能小写，不能大写。\n工程文件：\n2019-02-12-ReactDemo.zip 生命周期函数：componentWillReceiveProps() 当子组件第一次被渲染到页面上的时候，不会触发这个 函数。\n只有当父组件中，通过 某些 事件，重新修改了 传递给 子组件的 props 数据之后，才会触发 componentWillReceiveProps。\n代码举例：\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:（引入组件）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import MyParent from \u0026#34;./components/TestReceiveProps.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;MyParent\u0026gt;\u0026lt;/MyParent\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); （3）TestReceiveProps.jsx：（组件的定义）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 import React from \u0026#34;react\u0026#34;; // 父组件 export default class Parent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是父组件中的 msg 消息\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;这是父组件\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点击修改父组件的 MSG\u0026#34; onClick={this.changeMsg} /\u0026gt; \u0026lt;hr /\u0026gt; {/* 在父组件 Parent 中引用子组件 Son */} \u0026lt;Son pmsg={this.state.msg} /\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg = () =\u0026gt; { this.setState({ msg: \u0026#34;修改组件的msg为新的值\u0026#34; }); }; } // 子组件 class Son extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;这是子组件 --- {this.props.pmsg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } // 组件将要接收外界传递过来的新的 props 属性值 // 当子组件第一次被渲染到页面上的时候，不会触发这个 函数； // 只有当 父组件中，通过 某些 事件，重新修改了 传递给 子组件的 props 数据之后，才会触发 componentWillReceiveProps componentWillReceiveProps(nextProps) { // console.log(\u0026#39;被触发了！\u0026#39;); // 注意： 在 componentWillReceiveProps 被触发的时候，如果我们使用 this.props 来获取属性值，这个属性值，不是最新的，是上一次的旧属性值 // 如果想要获取最新的属性值，需要通过 componentWillReceiveProps 的参数列表来获取 console.log(this.props.pmsg + \u0026#34; ---- \u0026#34; + nextProps.pmsg); } } 上方代码中，我们在组件 Parent 中引入了子组件 Son。重点注意 componentWillReceiveProps()函数 的注释部分。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/04-react%E7%BB%84%E4%BB%B6%E4%BA%8C%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%87%BD%E6%95%B0/","summary":"defaultProps 和 prop-types 使用 defaultProps 设置组件的默认值 React 中，使用静态的 defaultProps 属性，来设置组件的默认属性值。 格式举例： 1 2 3 4 // 在 React 中，使用静态的 defaultProps 属性，来设置组件的默认属","title":"04-React组件（二）：常见属性和函数"},{"content":"Node.js 的官方API文档 Node.js 的API文档（英文）： https://nodejs.org/docs/latest-v8.x/api/index.html\nNode.js 的API文档（中文）：http://nodejs.cn/api/\n关于 Node.js 的内置模块和常见API，可以看官方文档。\n查阅文档时，稳定指数如下：\n红色：废弃。\n橙色：实验。表示当前版本可用，其他版本不确定。也许不向下兼容，建议不要在生产环境中使用该特性。\n绿色：稳定。与 npm 生态系统的兼容性是最高的优先级。\nNode.js 中模块的分类 Node.js 应用由模块组成，采用 CommonJS 模块规范。Node.js中的模块分为三种：\n内置模块\n第三方模块\n自定义模块\n下面简单介绍一下。\n1、内置模块 1 2 3 4 5 const process = require(\u0026#39;process\u0026#39;); const path = require(\u0026#39;path\u0026#39;); console.log(process.version); console.log(path.resolve(\u0026#39;../\u0026#39;)); require方法用于加载模块。\n常见的内置模块包括：\nFS：文件系统模块\npath：路径模块\nOS：操作系统相关\nnet：网络相关\nhttp\n\u0026hellip;\n你可能会有疑问：Node.js 这么牛吗？还能直接和操作系统做交互？\n带着这个疑问，我们不妨简单看看 Node.js 的源码，以 os 模块举例：\n打开os模块的源码：https://github.com/nodejs/node/blob/master/lib/os.js，翻到最底部，找到 cpus这个方法\n进而找到 getCPUs()\ninternalBinding(\u0026lsquo;os\u0026rsquo;)：通过 internalBinding 可以调用系统底层的方法。internalBinding 主要是 JS 虚拟机在做的事情。\ninternalBinding('os') 的实现，在 https://github.com/nodejs/node/blob/master/src/node_os.cc 里，里面都是 C++ 的代码。比如有一个getCPUs方法。\n现在你知道了，JS本身是没有能力获取底层系统资源的，这一切都是 JS虚拟机在和底层做交互，然后通过 JS 的表现形式，暴露给应用层。\n另外，还有很多库，是直接使用C/++编写的，通过编译之后，再提供给 JS 应用层调用，或者直接提供给 Node.js层使用。\n所有的编程语言底层都会回归C/C++，甚至是汇编语言。\n2、require 加载第三方包的机制 1 const express = require(\u0026#39;express\u0026#39;); require 加载第三方包的机制：\n（1）第三方包安装好后，这个包一般会存放在当前项目的 node_modules 文件夹中。我们找到这个包的 package.json 文件，并且找到里面的main属性对应的入口模块，这个入口模块就是这个包的入口文件。\n（2）如果第三方包中没有找到package.json文件，或者package.json文件中没有main属性，则默认加载第三方包中的index.js文件。\n（3）如果在 node_modules 文件夹中没有找到这个包，或者以上所有情况都没有找到，则会向上一级父级目录下查找node_modules文件夹，查找规则如上一致。\n（4）如果一直找到该模块的磁盘根路径都没有找到，则会报错：can not find module xxx。\n3、自定义模块（module）： 每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。\n举例：\n1 2 3 var example = require(\u0026#39;./example.js\u0026#39;); console.log(example.x); // 5 console.log(example.addX(1)); // 6 读取文件 今天这篇文章，重点讲一下 Node 内置模块中的 fs（文件处理模块）。\n在使用文件模块之前，记得先导入：\n1 2 // 导入文件模块 const fs = require(\u0026#39;fs\u0026#39;); fs 的英文全称是 File System。fs 模块提供了很多 api 方法，我们首先应该学习的方法是文件读取。\nNode中文件读取的方式主要有以下几种。\n异步读取文件 fs.readFile() 语法格式：\n1 fs.readFile(file[, options], callback(error, data)) 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 const fs = require(\u0026#39;fs\u0026#39;); fs.readFile(\u0026#39;hello.txt\u0026#39;, \u0026#39;utf8\u0026#39;, (err, data) =\u0026gt; { if (err) { // 失败 console.log(err) } else { // 成功 console.log(\u0026#39;异步读取数据：\u0026#39; + data2) } }); 如果需要嵌套读取多个文件，可以用 promise 或者 async \u0026hellip; await 进行封装。代码举例如下。\npromise 封装 fs.readFile() 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const fs = require(\u0026#39;fs\u0026#39;); function fsRead(path) { return new Promise((resolve, reject) =\u0026gt; { fs.readFile(path, { flag: \u0026#39;r\u0026#39;, encoding: \u0026#34;utf-8\u0026#34; }, (err, data) =\u0026gt; { if (err) { //失败执行的内容 reject(err) } else { //成功执行的内容 resolve(data) } }) }) } var promise1 = fsRead(\u0026#39;hello1.txt\u0026#39;) promise1.then(res1 =\u0026gt; { console.log(res1); return fsRead(\u0026#39;hello2.txt\u0026#39;); }).then(res2 =\u0026gt; { console.log(res2); return fsRead(\u0026#39;hello3.txt\u0026#39;); }).then(res3 =\u0026gt; { console.log(res); }) async \u0026hellip; await 封装 fs.readFile() 这个写法更为简洁，推荐。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 var fs = require(\u0026#39;fs\u0026#39;); function fsRead(path) { return new Promise((resolve, reject) =\u0026gt; { fs.readFile(path, { flag: \u0026#39;r\u0026#39;, encoding: \u0026#34;utf-8\u0026#34; }, (err, data) =\u0026gt; { if (err) { //失败执行的内容 reject(err) } else { //成功执行的内容 resolve(data) } }) }) } async function ReadList() { var res1 = await fsRead(\u0026#39;hello1.txt\u0026#39;); var res2 = await fsRead(\u0026#39;hello2.txt\u0026#39;); var res3 = await fsRead(\u0026#39;hello3.txt\u0026#39;); } // 执行方法 ReadList(); 同步读取文件 fs.readFileSync() 语法格式：\n1 fs.readFileSync(file[, options]) 代码举例：\n1 2 3 4 5 6 7 8 9 const fs = require(\u0026#39;fs\u0026#39;); try { const data = fs.readFileSync(\u0026#39;hello.txt\u0026#39;, \u0026#39;utf8\u0026#39;); console.log(data); } catch(e) { // 文件不存在，或者权限错误 throw e; } Node.js 中的同步和异步的区别 fs模块对文件的几乎所有操作都有同步和异步两种形式。例如：readFile() 和 readFileSync()。\n区别：\n同步调用会阻塞代码的执行，异步则不会。\n异步调用会将 读取任务 下达到任务队列，直到任务执行完成才会回调。\n异常处理方面：同步必须使用 try catch 方式，异步可以通过回调函数的第一个参数。【重要】\n写入文件 语法格式：\n1 fs.write(fd, string[, position[, encoding]], callback) async \u0026hellip; await 封装：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 let fs = require(\u0026#39;fs\u0026#39;) function writeFs(path, content) { return new Promise(function (resolve, reject) { fs.writeFile(path, content, { flag: \u0026#34;a\u0026#34;, encoding: \u0026#34;utf-8\u0026#34; }, function (err) { if (err) { //console.log(\u0026#34;写入内容出错\u0026#34;) reject(err) } else { resolve(err) //console.log(\u0026#34;写入内容成功\u0026#34;) } }) }) } async function writeList() { await writeFs(\u0026#39;1.html\u0026#39;, \u0026#34;\u0026lt;h1\u0026gt;qianguyihao\u0026lt;/h1\u0026gt;\u0026#34;); await writeFs(\u0026#39;2.html\u0026#39;, \u0026#34;\u0026lt;h1\u0026gt;hello world\u0026lt;/h1\u0026gt;\u0026#34;); await writeFs(\u0026#39;3.html\u0026#39;, \u0026#34;\u0026lt;h1\u0026gt;永不止步\u0026lt;/h1\u0026gt;\u0026#34;); } writeList() 删除文件 语法格式：\n1 fs.unlink(path, callback) 参数说明：\npath：文件路径。 callback：回调函数。 代码举例：\n1 2 3 4 fs.unlink(\u0026#39;path/file.txt\u0026#39;, (err) =\u0026gt; { if (err) throw err; console.log(\u0026#39;文件删除成功\u0026#39;); }); 备注：fs.unlink() 不能用于删除目录。 如果要删除目录，可以使用 fs.rmdir()。\nBuffer 通过 Buffer 开辟的内存空间，都是连续的内存空间，所以效率比较高。\n代码举例1：\n1 2 3 4 5 6 7 // 将字符串转成 buffer 对象 const str = \u0026#39;qianguyihao\u0026#39;; let buffer = Buffer.from(str); console.log(buffer); // 输出16进制编码 console.log(buffer.toString()); // 输出字符串：qianguyihao 代码举例2：\n1 2 3 4 5 // 从内存中开辟一个新的缓冲区 let buffer = Buffer.alloc(20); buffer[0] = \u0026#39;a\u0026#39;; console.log(buffer); 读取目录 语法格式：\n1 fs.mkdir(path[, options], callback) 参数说明：\npath：文件路径。\noptions参数可以是：\nrecursive：是否以递归的方式创建目录，默认为 false。 mode：设置目录权限，默认为 0777。 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 var fs = require(\u0026#34;fs\u0026#34;); ​ console.log(\u0026#34;查看 /tmp 目录\u0026#34;); fs.readdir(\u0026#34;/tmp/\u0026#34;,function(err, files){ if (err) { return console.error(err); } files.forEach( function (file){ console.log( file ); }); }); 其他的还有：（暂略）\n删除目录\n输入输出\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/05-node.js%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97fs%E6%96%87%E4%BB%B6%E6%A8%A1%E5%9D%97/","summary":"Node.js 的官方API文档 Node.js 的API文档（英文）： https://nodejs.org/docs/latest-v8.x/api/index.html Node.js 的API文档（中文）：http://nodejs.cn/api/ 关于 Node.js 的内置模块和常见API，","title":"05-Node.js内置模块：fs文件模块"},{"content":"前言 我们先来看下面这段代码：\ncomponents/MyComponent.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={this.changeMsg} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg() { // 注意：这里的changeMsg()只是一个普通方法。因此，在触发的时候，这里的 this 是 undefined console.log(this); // 打印结果：undefined this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; }); } } 上面的代码中，点击按钮，执行 changeMsg() 方法，尝试修改 this.state.msg 的值。但是，这个方法执行的时候，是会报错的：\n1 Uncaught TypeError: Cannot read property \u0026#39;setState\u0026#39; of null 而且，打印this的结果也是 undefined。这是为啥呢？因为这里的 this 并不是指向 MyComponent 组件本身。\n那如何让 changeMsg() 方法里面的 this，指向MyComponent 组件呢？办法总是有的，比如说，将changeMsg() 修改为箭头函数：\n1 2 3 4 5 6 changeMsg = () =\u0026gt; { console.log(this); // 打印结果：MyComponent 组件 this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; }); }; 那么，除了箭头函数可以 绑定 this，还有没有其他的方式呢？我们接下来讲一讲。\n绑定 this 的方式一：bind() 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; {/* bind 的作用：为前面的函数，修改函数内部的 this 指向。让 函数内部的this，指向 bind 参数列表中的 第一个参数 */} \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={this.changeMsg1.bind(this)} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg1() { this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; }); } } 上方代码中，我们为什么用 bind()，而不是用 call/apply 呢？因为 bind() 并不会立即调用，正是我们需要的。\n注意：bind 中的第一个参数，是用来修改 this 指向的。第一个参数后面的所有参数，都将作为函数的参数传递进去。\n我们来看看通过 bind() 是怎么传参的。\n通过 bind() 绑定this，并给函数传参：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; {/* bind 的作用：为前面的函数，修改函数内部的 this 指向。让 函数内部的this，指向 bind 参数列表中的 第一个参数 */} \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={this.changeMsg1.bind(this, \u0026#34;千古啊\u0026#34;, \u0026#34;壹号啊\u0026#34;)} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg1(arg1, arg2) { this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; + arg1 + arg2 }); } } 绑定 this 并给函数传参 的方式二：构造函数里设置 bind() 我们知道，构造函数中的 this 本身就是指向组件的实例的，所以，我们可以在这里做一些事情。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; // 绑定 this 并给函数传参的方式2: 在构造函数中绑定并传参 // 注意：当一个函数调用 bind 改变了this指向后，bind 函数调用的结果，有一个【返回值】，这个值，就是被改变this指向后的函数的引用。 // 也就是说： bind 不会修改 原函数的 this 指向，而是改变了 “函数拷贝”的this指向。 this.changeMsg2 = this.changeMsg2.bind(this, \u0026#34;千古恩\u0026#34;, \u0026#34;壹号恩\u0026#34;); } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={this.changeMsg2} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg2(arg1, arg2) { this.setState({ msg: \u0026#34;设置 msg 为新的值\u0026#34; + arg1 + arg2 }); } } 上方代码中，需要注意的是：当一个函数调用 bind 改变了this指向后，bind 函数调用的结果，有一个【返回值】，这个值，就是被改变this指向后的函数的引用。也就是说： bind 不会修改 原函数的 this 指向，而是改变了 “函数拷贝”的this指向。\n绑定 this 并给函数传参 的方式三：箭头函数【荐】 第三种方式用得最多。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;绑定This并传参\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;绑定this并传参\u0026#34; onClick={() =\u0026gt; { this.changeMsg3(\u0026#34;千古3\u0026#34;, \u0026#34;壹号3\u0026#34;); }} /\u0026gt; \u0026lt;h3\u0026gt;{this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } changeMsg3 = (arg1, arg2) =\u0026gt; { // console.log(this); // 注意：这里的方式，是一个普通方法，因此，在触发的时候，这里的 this 是 undefined this.setState({ msg: \u0026#34;绑定this并传参的方式3：\u0026#34; + arg1 + arg2 }); }; } ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/05-react%E4%B8%AD%E7%BB%91%E5%AE%9Athis%E5%B9%B6%E7%BB%99%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","summary":"前言 我们先来看下面这段代码： components/MyComponent.jsx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent","title":"05-React中绑定this并给函数传参的几种方式"},{"content":"箭头函数 定义箭头函数的语法 语法：\n1 (参数1, 参数2 ...) =\u0026gt; { 函数体 } 解释：\n如果有且仅有 1 个形参，则()可以省略 如果函数体内有且仅有 1 条语句，则{}可以省略，但前提是，这条语句必须是 return 语句。 需要强调的是，箭头函数是没有函数名的，既然如此，那要怎么调用箭头函数呢？ 你可以将箭头函数赋值给一个变量，通过变量名调用函数；也可以直接使用箭头函数。\n举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 定义和调用函数：（传统写法） function fn1(a, b) { console.log(\u0026#39;haha\u0026#39;); return a + b; } console.log(fn1(1, 2)); //输出结果：3 //定义和调用函数：（ES6 中的写法） const fn2 = (a, b) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + b; }; console.log(fn2(1, 2)); //输出结果：3 在箭头函数中，如果方法体内只有一句话，且这句话是 return 语句，那就可以把 {}省略。写法如下：\n1 2 const fn2 = (a, b) =\u0026gt; a + b; console.log(fn2(1, 2)); //输出结果：3 在箭头函数中，如果形参只有一个参数，则可以把()省略。写法如下：\n1 2 3 4 5 const fn2 = (a) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + 1; }; console.log(fn2(1)); //输出结果：2 箭头函数的 this 的指向 箭头函数不只是为了让函数写起来更简洁优雅，还有一个很大的作用是与 this 的指向有关。\nES6 之前的普通函数中：this 指向的是函数被调用的对象（也就是说，谁调用了函数，this 就指向谁）。\n而 ES6 的箭头函数中：箭头函数本身不绑定 this，this 指向的是箭头函数定义位置的 this（也就是说，箭头函数在哪个位置定义的，this 就跟这个位置的 this 指向相同）。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 const obj = { name: \u0026#39;lvbu\u0026#39; }; function fn1() { console.log(this); // 第一个 this return () =\u0026gt; { console.log(this); // 第二个 this }; } const fn2 = fn1.call(obj); fn2(); 打印结果：\n1 2 obj obj 代码解释：（一定要好好理解下面这句话）\n上面的代码中，箭头函数是在 fn1()函数里面定义的，所以第二个 this 跟 第一个 this 指向的是同一个位置。又因为，在执行 fn1.call(obj)之后，第一个 this 就指向了 obj，所以第二个 this 也是指向 了 obj。\n面试题：箭头函数的 this 指向 代码举例：\n1 2 3 4 5 6 7 8 9 const name = \u0026#39;许嵩\u0026#39;; const obj = { name: \u0026#39;lvbu\u0026#39;, sayHello: () =\u0026gt; { console.log(this.name); }, }; obj.sayHello(); 上方代码的打印结果是什么？你可能很难想到。\n正确答案的打印结果是许嵩。因为 obj 这个对象并不产生作用域， sayHello() 这个箭头函数实际仍然是定义在 window 当中的，所以 这里的 this 指向是 window。\n参数默认值 传统写法：\n1 2 3 4 function fn(param) { let p = param || \u0026#39;hello\u0026#39;; console.log(p); } 上方代码中，函数体内的写法是：如果 param 不存在，就用 hello字符串做兜底。这样写比较啰嗦。\nES6 写法：（参数默认值的写法，很简洁）\n1 2 3 function fn(param = \u0026#39;hello\u0026#39;) { console.log(param); } 在 ES6 中定义方法时，我们可以给方法里的参数加一个默认值（缺省值）：\n方法被调用时，如果没有给参数赋值，那就是用默认值；\n方法被调用时，如果给参数赋值了新的值，那就用新的值。\n如下：\n1 2 3 4 5 6 7 var fn2 = (a, b = 5) =\u0026gt; { console.log(\u0026#39;haha\u0026#39;); return a + b; }; console.log(fn2(1)); //第二个参数使用默认值 5。输出结果：6 console.log(fn2(1, 8)); //输出结果：9 提醒 1：默认值的后面，不能再有没有默认值的变量。比如(a,b,c)这三个参数，如果我给 b 设置了默认值，那么就一定要给 c 设置默认值。\n提醒 2：\n我们来看下面这段代码：\n1 2 3 4 5 let x = \u0026#39;smyh\u0026#39;; function fn(x, y = x) { console.log(x, y); } fn(\u0026#39;vae\u0026#39;); 注意第二行代码，我们给 y 赋值为x，这里的x是括号里的第一个参数，并不是第一行代码里定义的x。打印结果：vae vae。\n如果我把第一个参数改一下，改成：\n1 2 3 4 5 let x = \u0026#39;smyh\u0026#39;; function fn(z, y = x) { console.log(z, y); } fn(\u0026#39;vae\u0026#39;); 此时打印结果是：vae smyh。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/06-es6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/","summary":"箭头函数 定义箭头函数的语法 语法： 1 (参数1, 参数2 ...) =\u0026gt; { 函数体 } 解释： 如果有且仅有 1 个形参，则()可以省略 如果函数体内有且仅有 1 条语句，则{","title":"06-ES6：箭头函数"},{"content":"path 路径模块 Node.js 通过path这个内置模块，提供了一些路径操作的API，具体可以参考官方的api文档。这里列举一些常用的API。\npath.extname() 获取文件/路径的扩展名 语法格式：\n1 path.extname(myPath); 代码解释：\n获取 myPath 这个文件或者路径的扩展名。\nmyPath 这个参数要求是字符串。如果 myPath 不是字符串，则抛出 TypeError。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const path = require(\u0026#39;path\u0026#39;); path.extname(\u0026#39;hello.txt\u0026#39;); // 返回 \u0026#39;.txt\u0026#39; path.extname(\u0026#39;www.qianguyihao.com\u0026#39;); // 返回 \u0026#39;.com\u0026#39; path.extname(\u0026#39;index.coffee.md\u0026#39;); // 返回 \u0026#39;.md\u0026#39; path.extname(\u0026#39;index.\u0026#39;); // 返回 \u0026#39;.\u0026#39; path.extname(\u0026#39;index\u0026#39;); // 返回 \u0026#39;\u0026#39; path.extname(\u0026#39;.index\u0026#39;); // 返回 \u0026#39;\u0026#39; path.extname(\u0026#39;.index.md\u0026#39;); // 返回 \u0026#39;.md\u0026#39; path.resolve() 生成完成的绝对路径 语法格式：\n1 path.resolve([...myPaths]) 解释：\n将路径或路径片段的序列解析为绝对路径。\n返回的路径是从右往左处理，后面的每个 myPath 被依次解析，直到构造出一个完整的绝对路径。\n代码举例：\n1 2 3 4 5 6 7 8 9 const path = require(\u0026#39;path\u0026#39;); let arr1 = [\u0026#39;/foo1/foo2\u0026#39;, \u0026#39;qianguyihao\u0026#39;, \u0026#39;foo3\u0026#39;]; let result1 = path.resolve(...arr1); console.log(result1); // 打印结果：/foo1/foo2/qianguyihao/foo3 let arr2 = [\u0026#39;/foo1/foo2\u0026#39;, \u0026#39;/qianguyihao\u0026#39;, \u0026#39;foo3\u0026#39;]; let result2 = path.resolve(...arr2); console.log(result2); // 打印结果：/qianguyihao/foo3 几个常见路径 __dirname：这是一个常量，表示：当前执行文件所在完整目录。\n__filename：这是一个常量。表示：当前执行文件的完整目录 + 文件名。\nprocess.cwd：获取当前执行 Node命令 时的目录名。\n代码举例：\n1 2 3 4 5 console.log(__dirname); console.log(__filename); console.log(process.cwd()); 运行结果：\n1 2 3 4 5 $ node app.js /Users/smyhvae/qianguyihao /Users/smyhvae/qianguyihao/app.js /Users/smyhvae/qianguyihao path.join() 将多个路径进行拼接 如果是我们手动拼接路径，容易出错。这个时候，可以利用 path.join() 方法将路径进行拼接。\n语法格式：\n1 path.join([...paths]); 解释：使用平台特定的分隔符作为定界符将所有给定的 path 片段连接在一起，然后规范化生成的路径。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 const path = require(\u0026#39;path\u0026#39;); const result1 = path.join(__dirname, \u0026#39;./app.js\u0026#39;); console.log(result1); // 返回：/Users/smyhvae/qianguyihao/app.js const result2 = path.join(\u0026#39;/foo1\u0026#39;, \u0026#39;foo2\u0026#39;, \u0026#39;./foo3\u0026#39;); console.log(result2); // 返回：/foo1/foo2/foo3 const result3 = path.join(\u0026#39;/foo1\u0026#39;, \u0026#39;foo2\u0026#39;, \u0026#39;/foo3\u0026#39;); console.log(result3); // 返回：/foo1/foo2/foo3 OS 系统模块 os.networkInterfaces() 查看网络地址 ","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/06-node.js%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97/","summary":"path 路径模块 Node.js 通过path这个内置模块，提供了一些路径操作的API，具体可以参考官方的api文档。这里列举一些常用的API。 path.extname() 获取文件/路径的","title":"06-Node.js内置模块：path路径模块"},{"content":"单项数据绑定 在 Vue 中，可以通过 v-model 指令来实现双向数据绑定。但是，在 React 中并没有指令的概念，而且 React 默认不支持 双向数据绑定。\nReact 只支持，把数据从 state 上传输到 页面，但是，无法自动实现数据从 页面 传输到 state 中 进行保存。\nReact中，只支持单项数据绑定，不支持双向数据绑定。不信的话，我们来看下面这个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是 MyComponent 组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;呵呵哒\u0026lt;/h3\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={this.state.msg} /\u0026gt; \u0026lt;/div\u0026gt; ); } } 上方代码中，我们尝试在 input文本框中读取 state.msg 的值，运行结果中，却弹出了警告：\n20190213_2000.png\n1 Warning: Failed prop type: You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`. 通过onChange方法，实现双向数据绑定 如果针对 表单元素做 value 属性绑定，那么，必须同时为 表单元素 绑定 readOnly, 或者提供 onChange 事件：\n如果是绑定readOnly，表示这个元素只读，不能被修改。此时，控制台就不会弹出警告了。\n如果是绑定onChange，表示这个元素的值可以被修改，但是，要自己定义修改的逻辑。\n绑定readOnly的举例如下：（表示value中的数据是只读的）\n1 \u0026lt;input type=\u0026#34;text\u0026#34; value={this.state.msg} readOnly /\u0026gt; 绑定 onChange 的举例如下：（通过onChange方法，实现双向数据绑定）\n(1)index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; // 导入组件 import MyComponent from \u0026#34;./components/MyComponent.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render( \u0026lt;div\u0026gt; \u0026lt;MyComponent\u0026gt;\u0026lt;/MyComponent\u0026gt; \u0026lt;/div\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;) ); （3）components/MyComponent.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 import React from \u0026#34;react\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = { msg: \u0026#34;这是组件 默认的msg\u0026#34; }; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;呵呵哒\u0026lt;/h1\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; value={this.state.msg} onChange={this.txtChanged} ref=\u0026#34;txt\u0026#34; /\u0026gt; \u0026lt;h3\u0026gt;{\u0026#34;实时显示msg中的内容：\u0026#34; + this.state.msg}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; ); } // 为 文本框 绑定 txtChanged 事件 txtChanged = (e) =\u0026gt; { // 获取 \u0026lt;input\u0026gt; 文本框中 文本的3种方式： // 方式一：使用 document.getElementById // 方式二：使用 ref // console.log(this.refs.txt.value); // 方式三：使用 事件对象的 参数 e 来拿 // 此时，e.target 就表示触发 这个事件的 事件源对象，得到的是一个原生的JS DOM 对象。在这个案例里，e.target就是指文本框 // console.log(e.target.value); this.setState({ msg: e.target.value }); }; } 工程文件：\n2019-02-13-ReactDemo.zip ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/06-react%E7%9A%84%E5%8D%95%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/","summary":"单项数据绑定 在 Vue 中，可以通过 v-model 指令来实现双向数据绑定。但是，在 React 中并没有指令的概念，而且 React 默认不支持 双向数据绑定。 React 只支持，把数据从 state 上传输","title":"06-React的单向数据绑定"},{"content":"Node.js 连接 MySQL （1）安装 mysql 包：\n1 $ npm install mysql （2）引入 mysql 包：\n1 const mysql = require(\u0026#34;mysql\u0026#34;); （3）建立连接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let mysql = require(\u0026#34;mysql\u0026#34;); let options = { host: \u0026#34;localhost\u0026#34;, //port:\u0026#34;3306\u0026#34;, //可选，默认3306 user: \u0026#34;root\u0026#34;, password: \u0026#39;xxx\u0026#39;, // 这里改成你自己的数据库连接密码 database: \u0026#34;qiangu_database\u0026#34;, }; //创建与数据库进行连接的连接对象 let connection = mysql.createConnection(options); //建立连接 connection.connect((err) =\u0026gt; { if (err) { // 数据库连接成功 console.log(err); } else { // 数据库连接失败 console.log(\u0026#34;数据库连接成功\u0026#34;); } }); 正常来说，运行程序后，应该会提示数据库连接成功。\n如果在运行时提示错误Client does not support authentication protocol requested by server，解决办法如下：(在终端进入 sql 之后，输入如下命令)\n1 2 3 4 5 # 注意，这里的 \u0026#39;root\u0026#39; 请填你的user账号， \u0026#39;localhost\u0026#39; 请填 你的 host， \u0026#39;password\u0026#39; 请填你的密码 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;password\u0026#39;; # 然后执行如下命令 flush privileges; Node.js 增删改查 MySQL 针对下面这张表：\n通过 Node.js可以对其进行一些增删改查操作。代码举例如下。\n1、查询表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 let mysql = require(\u0026#39;mysql\u0026#39;); let options = { host: \u0026#39;localhost\u0026#39;, //port:\u0026#34;3306\u0026#34;,//可选，默认3306 user: \u0026#39;root\u0026#39;, password: \u0026#39;xxx\u0026#39;, // 这里改成你自己的数据库密码 database: \u0026#39;qiangu_database\u0026#39; } //创建与数据库进行连接的连接对象 let connection = mysql.createConnection(options); //建立连接 connection.connect((err) =\u0026gt; { if (err) { // 数据库连接成功 console.log(err) } else { // 数据库连接失败 console.log(\u0026#39;数据库连接成功\u0026#39;) } }); // 1、查询表 let strSql1 = \u0026#39;select * from qiangu_student_table\u0026#39;; connection.query(strSql1, (err, result, fields) =\u0026gt; { if (err) { // 表查询失败 console.log(err); } else { // 表查询成功 console.log(\u0026#39;qiangu_student_table 表查询结果：\u0026#39; + JSON.stringify(result)); console.log(\u0026#39;fields:\u0026#39; + JSON.stringify(fields)); } }) 打印结果如下：\n1 2 3 4 5 6 7 8 qiangu_student_table 表查询结果： [{\u0026#34;id\u0026#34;:1,\u0026#34;name\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;age\u0026#34;:28},{\u0026#34;id\u0026#34;:2,\u0026#34;name\u0026#34;:\u0026#34;许嵩\u0026#34;,\u0026#34;age\u0026#34;:34},{\u0026#34;id\u0026#34;:3,\u0026#34;name\u0026#34;:\u0026#34;邓紫棋\u0026#34;,\u0026#34;age\u0026#34;:28}] fields:[ {\u0026#34;catalog\u0026#34;:\u0026#34;def\u0026#34;,\u0026#34;db\u0026#34;:\u0026#34;qiangu_database\u0026#34;,\u0026#34;table\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;orgTable\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;id\u0026#34;,\u0026#34;orgName\u0026#34;:\u0026#34;id\u0026#34;,\u0026#34;charsetNr\u0026#34;:63,\u0026#34;length\u0026#34;:11,\u0026#34;type\u0026#34;:3,\u0026#34;flags\u0026#34;:0,\u0026#34;decimals\u0026#34;:0,\u0026#34;zeroFill\u0026#34;:false,\u0026#34;protocol41\u0026#34;:true}, {\u0026#34;catalog\u0026#34;:\u0026#34;def\u0026#34;,\u0026#34;db\u0026#34;:\u0026#34;qiangu_database\u0026#34;,\u0026#34;table\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;orgTable\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;orgName\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;charsetNr\u0026#34;:33,\u0026#34;length\u0026#34;:765,\u0026#34;type\u0026#34;:253,\u0026#34;flags\u0026#34;:0,\u0026#34;decimals\u0026#34;:0,\u0026#34;zeroFill\u0026#34;:false,\u0026#34;protocol41\u0026#34;:true}, {\u0026#34;catalog\u0026#34;:\u0026#34;def\u0026#34;,\u0026#34;db\u0026#34;:\u0026#34;qiangu_database\u0026#34;,\u0026#34;table\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;orgTable\u0026#34;:\u0026#34;qiangu_student_table\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;age\u0026#34;,\u0026#34;orgName\u0026#34;:\u0026#34;age\u0026#34;,\u0026#34;charsetNr\u0026#34;:63,\u0026#34;length\u0026#34;:11,\u0026#34;type\u0026#34;:3,\u0026#34;flags\u0026#34;:0,\u0026#34;decimals\u0026#34;:0,\u0026#34;zeroFill\u0026#34;:false,\u0026#34;protocol41\u0026#34;:true} ] 删除表 1 2 3 4 5 6 7 8 9 10 11 // 2、删除表 let strSql2 = \u0026#39;drop table test2_table\u0026#39;; connection.query(strSql2, (err, result) =\u0026gt; { if (err) { // 表删除失败 console.log(err); } else { // 表删除成功 console.log(\u0026#39;表删除成功：\u0026#39; + result); } }); 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 表删除成功： OkPacket { fieldCount: 0, affectedRows: 0, insertId: 0, serverStatus: 2, warningCount: 0, message: \u0026#39;\u0026#39;, protocol41: true, changedRows: 0 } 删除数据库 将上方的sql语句换一下即可：\n1 let strSql3 = \u0026#39;drop database qiangu_database\u0026#39;; 2、新建数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 let mysql = require(\u0026#39;mysql\u0026#39;); let options = { host: \u0026#39;localhost\u0026#39;, //port:\u0026#34;3306\u0026#34;,//可选，默认3306 user: \u0026#39;root\u0026#39;, password: \u0026#39;smyhvae001\u0026#39;, // database: \u0026#39;qiangu_database\u0026#39; // 注意，因为代码里是创建新的数据库，所以这里不需要填其他的数据库名 } //创建与数据库进行连接的连接对象 let connection = mysql.createConnection(options); //建立连接 connection.connect((err) =\u0026gt; { if (err) { // 数据库连接成功 console.log(err); } else { // 数据库连接失败 console.log(\u0026#39;数据库连接成功\u0026#39;) } }); // 创建新的数据库 const strSql4 = \u0026#39;create database qiangu_database3\u0026#39;; connection.query(strSql4, (err, result) =\u0026gt; { if (err) { console.log(err); } else { console.log(\u0026#39;新建数据库成功：\u0026#39; + JSON.stringify(result)); } }); 打印结果：\n1 2 3 4 数据库连接成功 新建数据库成功：{ \u0026#34;fieldCount\u0026#34;:0,\u0026#34;affectedRows\u0026#34;:1,\u0026#34;insertId\u0026#34;:0,\u0026#34;serverStatus\u0026#34;:2,\u0026#34;warningCount\u0026#34;:0,\u0026#34;message\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;protocol41\u0026#34;:true,\u0026#34;changedRows\u0026#34;:0 } 3、新建表 新建表的sql语句举例：\n1 2 3 4 5 6 CREATE TABLE `qiangu_table5` ( `id` int NOT NULL AUTO_INCREMENT, `name` varchar(255) DEFAULT NULL, `age` int DEFAULT NULL, PRIMARY KEY (`id`) ); 如果是在 js 代码中执行上面这样命令的话，要记得把 sql 语句存放在字符串里的同一行。\n代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 let mysql = require(\u0026#39;mysql\u0026#39;); let options = { host: \u0026#39;localhost\u0026#39;, //port:\u0026#34;3306\u0026#34;,//可选，默认3306 user: \u0026#39;root\u0026#39;, password: \u0026#39;smyhvae001\u0026#39;, database: \u0026#39;qiangu_database\u0026#39; } //创建与数据库进行连接的连接对象 let connection = mysql.createConnection(options); //建立连接 connection.connect((err) =\u0026gt; { if (err) { // 数据库连接成功 console.log(err); } else { // 数据库连接失败 console.log(\u0026#39;数据库连接成功\u0026#39;) } }); // 新建表 // 注意，在 js 代码中，sql 语句要存放在字符串里的同一行。 const strSql5 = \u0026#39;CREATE TABLE `qianguyihao_table5` (`id` int NOT NULL AUTO_INCREMENT,`name` varchar(255) DEFAULT NULL,`age` int DEFAULT NULL,PRIMARY KEY (`id`));\u0026#39;; connection.query(strSql5, (err, result) =\u0026gt; { if (err) { // 新建表失败 console.log(err); } else { // 新建表成功 console.log(\u0026#39;qianguyihao 新建表成功：\u0026#39; + JSON.stringify(result)); } }) 打印结果：\n1 2 3 4 5 数据库连接成功 qianguyihao 新建表成功： { \u0026#34;fieldCount\u0026#34;:0,\u0026#34;affectedRows\u0026#34;:0,\u0026#34;insertId\u0026#34;:0,\u0026#34;serverStatus\u0026#34;:2,\u0026#34;warningCount\u0026#34;:0,\u0026#34;message\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;protocol41\u0026#34;:true,\u0026#34;changedRows\u0026#34;:0 } 在指定的表中插入数据 在指定的表中插入数据：\n1 2 3 4 5 6 7 8 9 10 11 12 // 在指定的表中插入数据 const strSql6 = \u0026#34;insert into qianguyihao_table5 (name, age) values (\u0026#39;lvbu\u0026#39;, \u0026#39;28\u0026#39;)\u0026#34;; connection.query(strSql6, (err, result) =\u0026gt; { if (err) { // 插入数据失败 console.log(err); } else { // 在指定的表中插入数据成功 console.log(\u0026#39;qianguyihao 在指定的表中插入数据成功：\u0026#39; + JSON.stringify(result)); } }); 打印结果：\n1 2 3 4 qianguyihao 在指定的表中插入数据成功： { \u0026#34;fieldCount\u0026#34;:0,\u0026#34;affectedRows\u0026#34;:1,\u0026#34;insertId\u0026#34;:1,\u0026#34;serverStatus\u0026#34;:2,\u0026#34;warningCount\u0026#34;:0,\u0026#34;message\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;protocol41\u0026#34;:true,\u0026#34;changedRows\u0026#34;:0 } 如果插入的数据是变量（比如是用户提交上来的数据），那么，sql 语句可以这样写：\n1 2 3 4 5 6 7 8 9 10 11 12 // 在指定的表中插入数据（数据作为变量） const strSql7 = \u0026#34;insert into qianguyihao_table5 (name, age) values (?, ?)\u0026#34;; connection.query(strSql7, [\u0026#39;许嵩\u0026#39;, \u0026#39;34\u0026#39;], (err, result) =\u0026gt; { if (err) { // 插入数据失败 console.log(err); } else { // 在指定的表中插入数据成功 console.log(\u0026#39;qiangauyihao 在指定的表中插入数据成功：\u0026#39; + JSON.stringify(result)); } }); ","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/07-node.js%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/","summary":"Node.js 连接 MySQL （1）安装 mysql 包： 1 $ npm install mysql （2）引入 mysql 包： 1 const mysql = require(\u0026#34;mysql\u0026#34;); （3）建立连接： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 let mysql = require(\u0026#34;mysql\u0026#34;); let options = { host: \u0026#34;localhost\u0026#34;, //port:\u0026#34;3306\u0026#34;,","title":"07-Node.js操作MySQL数据库"},{"content":"React路由的使用 使用React路由之前，我们需要先安装 react-router-dom这个包。比如：\n1 yarn add react-router-dom 代码举例：\n（1）index.html\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js：\n1 2 3 4 5 6 7 8 9 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import App from \u0026#34;./App.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render(\u0026lt;App /\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;)); （3）app.jsx:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 import React from \u0026#34;react\u0026#34;; // 如果要使用 路由模块，第一步，运行 yarn add react-router-dom // 第二步，导入 路由模块 // HashRouter 表示一个路由的跟容器，将来，所有的路由相关的东西，都要包裹在 HashRouter 里面，而且，一个网站中，只需要使用一次 HashRouter 就好了； // Route 表示一个路由规则， 在 Route 上，有两个比较重要的属性， path component // Link 表示一个路由的链接 ，就好比 vue 中的 \u0026lt;router-link to=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/router-link\u0026gt; import { HashRouter, Route, Link } from \u0026#34;react-router-dom\u0026#34;; import Home from \u0026#34;./components/Home.jsx\u0026#34;; import Movie from \u0026#34;./components/Movie.jsx\u0026#34;; import About from \u0026#34;./components/About.jsx\u0026#34;; export default class App extends React.Component { constructor(props) { super(props); this.state = {}; } render() { // 当 使用 HashRouter 把 App 根组件的元素包裹起来之后，网站就已经启用路由了 // 在一个 HashRouter 中，只能有唯一的一个根元素 // 在一个网站中，只需要使用 唯一的一次 \u0026lt;HashRouter\u0026gt;\u0026lt;/HashRouter\u0026gt; 即可 return ( \u0026lt;HashRouter\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;这是网站的APP根组件\u0026lt;/h1\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;Link to=\u0026#34;/home\u0026#34;\u0026gt;首页\u0026lt;/Link\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;Link to=\u0026#34;/movie\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;Link to=\u0026#34;/about\u0026#34;\u0026gt;关于\u0026lt;/Link\u0026gt; \u0026lt;hr /\u0026gt; {/* Route 创建的标签，就是路由规则，其中 path 表示要匹配的路由，component 表示要展示的组件 */} {/* 在 vue 中有个 router-view 的路由标签，专门用来放置，匹配到的路由组件的，但是，在 react-router 中，并没有类似于这样的标签，而是 ，直接把 Route 标签，当作的 坑（占位符） */} {/* Route 具有两种身份：1. 它是一个路由匹配规则； 2. 它是 一个占位符，表示将来匹配到的组件都放到这个位置 */} \u0026lt;Route path=\u0026#34;/home\u0026#34; component={Home} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;Route path=\u0026#34;/movie\u0026#34; component={Movie} /\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;Route path=\u0026#34;/about\u0026#34; component={About} /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/HashRouter\u0026gt; ); } } （4）ReactDemo/src/components/Home.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#34;react\u0026#34;; export default class Home extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return \u0026lt;div\u0026gt;Home组件\u0026lt;/div\u0026gt;; } } （5）ReactDemo/src/components/Movie.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 13 import React from \u0026#34;react\u0026#34;; export default class Movie extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return \u0026lt;div\u0026gt;Movie组件\u0026lt;/div\u0026gt;; } } （6）ReactDemo/src/components/About.jsx\n1 2 3 4 5 6 7 8 9 10 11 12 import React from \u0026#34;react\u0026#34;; export default class About extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return \u0026lt;div\u0026gt;About组件\u0026lt;/div\u0026gt;; } } 运行结果：\n20190214_1000.png\n匹配路由参数 模糊匹配与精准匹配 我们在上面的代码中，进一步修改。假设 Movie 这个组件修改成这种路由匹配方式：\n1 2 3 \u0026lt;Link to=\u0026#34;/movie/top250\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt; \u0026lt;Route path=\u0026#34;/movie\u0026#34; component={Movie} /\u0026gt; 上面这种匹配方式，也是可以成功匹配到的。这是为啥呢？\n这是因为：默认情况下，路由中的匹配规则，是模糊匹配的。如果 路由可以部分匹配成功，就会展示这个路由对应的组件。\n如果想让路由规则，进行精确匹配，可以为Route添加 exact 属性。比如下面这种写法，因为是开启了精准匹配，所以是匹配不到的：（无法匹配）\n1 2 3 \u0026lt;Link to=\u0026#34;/movie/top250/20\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt; \u0026lt;Route path=\u0026#34;/movie/\u0026#34; component={Movie} exact/\u0026gt; 另外，如果要匹配参数，可以在匹配规则中，使用 : 修饰符，表示这个位置匹配到的是参数。举例如下：（匹配正常）\n1 2 3 \u0026lt;Link to=\u0026#34;/movie/top250/20\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;Route path=\u0026#34;/movie/:type/:id\u0026#34; component={Movie} exact/\u0026gt; 获取路由参数 继续修改上面的代码。如果我想在 Movie 组件中显示路由中的参数，怎么做呢？\n我们可以通过 props.match.params获取路由中的参数。举例做法如下：\napp.jsx中的匹配规则如下：\n1 2 3 \u0026lt;Link to=\u0026#34;/movie/top100/5\u0026#34;\u0026gt;电影\u0026lt;/Link\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp; \u0026lt;Route path=\u0026#34;/movie/:type/:id\u0026#34; component={Movie} exact/\u0026gt; Moivie 组件的写法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React from \u0026#34;react\u0026#34;; export default class Movie extends React.Component { constructor(props) { super(props); this.state = { routeParams: props.match.params // 把路由中的参数保存到 state 中 }; } render() { console.log(this); // 如果想要从路由规则中，提取匹配到的参数，进行使用，可以使用 this.props.match.params.*** 来访问 return ( \u0026lt;div\u0026gt; {/* Movie --- {this.props.match.params.type} --- {this.props.match.params.id} */} Movie --- {this.state.routeParams.type} --- {this.state.routeParams.id} \u0026lt;/div\u0026gt; ); } } 打印结果如下：\n20190214_1030.png\n工程文件：\n2019-02-14-ReactDemo.zip\n参考链接 ","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/07-react%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"React路由的使用 使用React路由之前，我们需要先安装 react-router-dom这个包。比如： 1 yarn add react-router-dom 代码举例： （1）index.","title":"07-React路由的使用"},{"content":"前言 变量的数据类型转换：将一种数据类型转换为另外一种数据类型。\n通常有三种形式的类型转换：\n转换为字符串类型\n转换为数字型\n转换为布尔型\n你会专门把某个数据类型转换成 null 或者 undefined 吗？不会，因为这样做，没有意义。\ntypeof 运算符 我们先来讲一下 typeof，再讲类型转换。\ntypeof()表示“获取变量的数据类型”，返回的是小写，语法为：（两种写法都可以）\n1 2 3 4 5 // 写法1 typeof 变量; // 写法2 typeof(变量); typeof 这个运算符的返回结果就是变量的类型。那返回结果的类型是什么呢？是字符串。\n返回结果：\ntypeof 的代码写法 返回结果 typeof 数字 number typeof 字符串 string typeof 布尔型 boolean typeof 对象 object typeof 方法 function typeof null object typeof undefined undefined 备注 1：为啥 typeof null的返回值也是 object 呢？因为 null 代表的是空对象。\n备注 2：typeof NaN的返回值是 number，上一篇文章中讲过，NaN 是一个特殊的数字。\n返回结果举例：\n1 2 3 console.log(typeof []); // 空数组的打印结果：object console.log(typeof {}); // 空对象的打印结果：object 代码解释：这里的空数组[]、空对象{} ，为啥他们在使用 typeof 时，返回值也是 object呢？因为这里的 返回结果object指的是引用数据类型。空数组、空对象都是引用数据类型 Object。\ntypeof 无法区分数组，但 instanceof 可以。比如：\n1 2 3 console.log([] instanceof Array); // 打印结果：true console.log({} instanceof Array); // 打印结果：false 关于 instanceof 的详细内容，以后讲对象的时候，会详细介绍。\n变量的类型转换的分类 类型转换分为两种：显示类型转换、隐式类型转换。\n显示类型转换 toString()\nString()\nNumber()\nparseInt(string)\nparseFloat(string)\nBoolean()\n隐式类型转换 isNaN ()\n自增/自减运算符：++、—-\n正号/负号：+a、-a\n加号：+\n运算符：-、*、/\n隐式类型转换（特殊） 逻辑运算符：\u0026amp;\u0026amp;、||、！ 。非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，但运算结果是原值。具体可以看下一篇文章《运算符》。\n关系运算符：\u0026lt;、\u0026gt; \u0026lt;= \u0026gt;=等。关系运算符，得到的运算结果都是布尔值：要么是true，要么是false。具体可以看下一篇文章《运算符》。\n针对上面这两种类型转换，这篇文章来详细介绍。\n其他的简单类型 \u0026ndash;\u0026gt; String 方法一（隐式类型转换）：字符串拼接 格式：变量+\u0026quot;\u0026quot; 或者 变量+\u0026ldquo;abc\u0026rdquo;\n举例：\n1 2 3 var a = 123; // Number 类型 console.log(a + \u0026#39;\u0026#39;); // 转换成 String 类型 console.log(a + \u0026#39;haha\u0026#39;); // 转换成 String 类型 上面的例子中，打印的结果，都是字符串类型的数据。实际上内部是调用的 String() 函数。也就是说，c = c + \u0026quot;\u0026quot; 等价于 c = String(c)。\n方法二：调用 toString()方法 语法：\n1 变量.toString() 【重要】该方法不会影响到原变量，它会将转换的结果返回。当然我们还可以直接写成a = a.toString()，这样的话，就是直接修改原变量。\n注意：null 和 undefined 这两个值没有 toString()方法，所以它们不能用方法二。如果调用，会报错。\n另外，Number 类型的变量，在调用 toString()时，可以在方法中传递一个整数作为参数。此时它将会把数字转换为指定的进制，如果不指定则默认转换为 10 进制。例如：\n1 2 3 4 5 6 7 8 var a = 255; //对于Number调用toString()时可以在方法中传递一个整数作为参数 //此时它将会把数字转换为指定的进制,如果不指定则默认转换为10进制 a = a.toString(2); // 转换为二进制 console.log(a); // 11111111 console.log(typeof a); // string 方法三（强制转换）：使用 String()函数 语法：\n1 String(变量) 使用 String()函数做强制类型转换时：\n对于 Number 和 Boolean 而言，本质上就是调用 toString()方法。\n但是对于 null 和 undefined，则不会调用 toString()方法。它会将 null 直接转换为 \u0026ldquo;null\u0026rdquo;。将 undefined 直接转换为 \u0026ldquo;undefined\u0026rdquo;。\nprompt()：用户的输入 我们在 JS 基础的第 01 篇里，就讲过，prompt()就是专门用来弹出能够让用户输入的对话框。重要的是：用户不管输入什么，都当字符串处理。\n其他的数据类型 \u0026ndash;\u0026gt; Number 【重要】 使用 Number() 函数 情况一：字符串 \u0026ndash;\u0026gt; 数字\n1.如果字符串中是纯数字，则直接将其转换为数字。\n2.如果字符串是一个空串或者是一个全是空格的字符串，则转换为 0。\n3.只要字符串中包含了其他非数字的内容（小数点按数字来算），则转换为 NaN。\n情况二：布尔 \u0026ndash;\u0026gt; 数字\ntrue 转成 1\nfalse 转成 0\n情况三：null \u0026ndash;\u0026gt; 数字\n结果为：0 情况四：undefined \u0026ndash;\u0026gt; 数字\n结果为：NaN 补充：怎么理解这里的 NaN 呢？可以这样理解，使用 Number() 函数之后，如果无法转换为数字，就会转换为 NaN。\n使用 parseInt()函数：字符串 -\u0026gt; 整数 parseInt()的作用是将字符串中的有效的整数内容转为数字。parse 表示“转换”，Int 表示“整数”（注意Int的拼写）。例如：\n1 parseInt(\u0026#34;5\u0026#34;); 得到的结果是数字 5。\nparseInt()的转换情况如下。\n情况一：字符串 \u0026ndash;\u0026gt; 数字\n1.只保留字符串最开头的数字，后面的中文自动消失。\n2.如果字符串不是以数字开头，则转换为 NaN。\n3.如果字符串是一个空串或者是一个全是空格的字符串，转换时会报错。\n情况二：Boolean \u0026ndash;\u0026gt; 数字\n结果为：NaN 情况三：Null \u0026ndash;\u0026gt; 数字\n结果为：NaN 情况四：Undefined \u0026ndash;\u0026gt; 数字\n结果为：NaN Number() 函数和 parseInt() 函数的区别：\n就拿Number(true) 和 parseInt(true)/parseFloat(true)来举例，二者在使用时，是有区别的：\nNumber(true) ：千方百计地想转换为数字。\nparseInt(true)/parseFloat(true) ：先转为字符串，再提取出最前面的数字部分；没提取出来，那就返回 NaN。\nparseInt()具有以下特性：\n（1）只保留字符串最开头的数字，后面的中文自动消失。例如：\n1 2 3 4 5 console.log(parseInt(\u0026#34;2017在公众号上写了6篇文章\u0026#34;)); //打印结果：2017 console.log(parseInt(\u0026#34;2017.01在公众号上写了6篇文章\u0026#34;)); //打印结果仍是：2017 （说明只会取整数） console.log(parseInt(\u0026#34;aaa2017.01在公众号上写了6篇文章\u0026#34;)); //打印结果：NaN （因为不是以数字开头） （2）如果对非 String使用 parseInt()或 parseFloat()，它会先将其转换为 String 然后再操作。【重要】\n比如：\n1 2 3 4 5 6 7 8 9 10 11 var a = 168.23; console.log(parseInt(a)); //打印结果：168 （因为是先将 a 转为字符串\u0026#34;168.23\u0026#34;，然后然后再操作） var b = true; console.log(parseInt(b)); //打印结果：NaN （因为是先将 b 转为字符串\u0026#34;true\u0026#34;，然后然后再操作） var c = null; console.log(parseInt(c)); //打印结果：NaN （因为是先将 c 转为字符串\u0026#34;null\u0026#34;，然后然后再操作） var d = undefined; console.log(parseInt(d)); //打印结果：NaN （因为是先将 d 转为字符串\u0026#34;undefined\u0026#34;，然后然后再操作） （3）自动带有截断小数的功能：取整，不四舍五入。\n例 1：\n1 2 var a = parseInt(5.8) + parseInt(4.7); console.log(a); 打印结果：\n1 9 例 2：\n1 2 var a = parseInt(5.8 + 4.7); console.log(a); 打印结果：\n1 10; （4）带两个参数时，表示在转换时，包含了进制转换。\n代码举例：\n1 2 3 4 5 var a = \u0026#39;110\u0026#39;; var num = parseInt(a, 16); // 【重要】将 a 当成 十六进制 来看待，转换成 十进制 的 num console.log(num); 打印结果：\n1 272 如果你对打印结果感到震惊，请仔细看上面的代码注释。就是说，无论 parseInt() 里面的进制参数是多少，最终的转换结果是十进制。\n我们继续来看下面的代码，打印结果是多少。\n1 2 3 4 5 var a = \u0026#39;5\u0026#39;; var num = parseInt(a, 2); // 将 a 当成 二进制 来看待，转换成 十进制 的 num console.log(num); // 打印结果：NaN。因为 二进制中没有 5 这个数，转换失败。 parseFloat()函数：字符串 \u0026ndash;\u0026gt; 浮点数（小数） parseFloat()的作用是：将字符串转换为浮点数。\nparseFloat()和 parseInt()的作用类似，不同的是，parseFloat()可以获得有效的小数部分。\n代码举例：\n1 2 var a = \u0026#39;123.456.789px\u0026#39;; console.log(parseFloat(a)); // 打印结果：123.456 parseFloat() 的几个特性，可以参照 parseInt()。\n转换为 Boolean 其他的数据类型都可以转换为 Boolean类型。情况如下：\n情况一：数字 \u0026ndash;\u0026gt; 布尔。除了 0 和 NaN，其余的都是 true。也就是说，Boolean(NaN)的结果是 false。\n情况二：字符串 \u0026mdash;\u0026gt; 布尔。除了空串，其余的都是 true。全是空格的字符串，转换结果也是 true。字符串'0'的转换结果也是 true。\n情况三：null 和 undefined 都会转换为 false。\n情况四：引用数据类型会转换为 true。注意，空数组[]和空对象{}，转换结果也是 true，这一点，很多人都不知道。\n1、隐式转换为 Boolean 类型：\n当非 Boolean 类型的数值和 Boolean类型的数值做比较时，会先把前者进行隐式转换为 Boolean类型，然后再做比较；且不会改变前者的数据类型。举例如下：\n1 2 3 4 5 6 const a = 1; console.log(a == true); // 打印结果：true console.log(typeof a); // 打印结果：number。可见，上面一行代码里，a 做了隐式类型转换，但是 a 的数据类型并没有发生变化，仍然是 Number 类型 console.log(0 == true); // 打印结果：false 2、显式转换为 Boolean 类型：\n方法1：使用 !!可以显式转换为 Boolean 类型。比如 !!3的结果是true。\n方法2：使用 Boolean()函数可以显式转换为 Boolean 类型。\n总结：\n转换为 Boolean 的这几种情况，很重要，开发中会经常用到。比如说，我们在项目开发中，经常需要对一些非布尔值做逻辑判断，符合条件后，才做进一步的事情。下面来看个例子。\n举例：（接口返回的内容不为空，前端才做进一步的事情）\n1 2 3 4 5 6 7 8 9 10 11 const result1 = \u0026#39;\u0026#39;; const result2 = {a:\u0026#39;data1\u0026#39;, b: \u0026#39;data2\u0026#39;}; if (result1) { console.log(\u0026#39;因为 result1的内容为空，所以代码进不了这里\u0026#39;); } if (result2 \u0026amp;\u0026amp; result2.a) { // 接口返回了 result2，且 result2.a 里面有值，前端才做进一步的事情 console.log(\u0026#39;代码能进来，前端继续在这里干活儿\u0026#39;); } 这里再次强调一下，空数组[]和空对象{}转换为 Boolean 值时，转换结果为 true。\n知识补充：其他进制的数字 16 进制的数字，以0x开头\n8 进制的数字，以0开头\n2 进制的数字，0b开头（不是所有的浏览器都支持：chrome 和火狐支持，IE 不支持）\n比如070这个字符串，如果我调用 parseInt()转成数字时，有些浏览器会当成 8 进制解析，有些会当成 10 进制解析。\n所以，比较建议的做法是：可以在 parseInt()中传递第二个参数，来指定当前数字的进制。例如：\n1 2 3 4 var a = \u0026#34;070\u0026#34;; a = parseInt(a, 8); //将 070 当成八进制来看待，转换结果为十进制。 console.log(a); // 打印结果：56。这个地方要好好理解。 隐式类型转换 重点：隐式类型转换，内部调用的都是显式类型的方法。下面来详细介绍。\nisNaN() 函数 语法：\n1 isNaN(参数); 解释：判断指定的参数是否为 NaN（非数字类型），返回结果为 Boolean 类型。也就是说：任何不能被转换为数值的参数，都会让这个函数返回 true。\n执行过程：\n（1）先调用Number(参数)函数；\n（2）然后将Number(参数)的返回结果和NaN进行比较。\n代码举例：\n1 2 3 4 5 6 7 8 9 console.log(isNaN(\u0026#39;123\u0026#39;)); // 返回结果：false。 console.log(isNaN(\u0026#39;abc\u0026#39;)); // 返回结果：true。因为 Number(\u0026#39;abc\u0026#39;) 的返回结果是 NaN console.log(isNaN(null)); // 返回结果：false console.log(isNaN(undefined)); // 返回结果：true console.log(isNaN(NaN)); // 返回结果：true 自增/自减运算符：++、—- 举例 1：\n1 2 3 4 5 var a = \u0026#34;666\u0026#34;; a++; console.log(typeof a); // 打印结果： number console.log(a); // 打印结果：667 执行过程：\n（1）先调用Number(参数)函数；\n（2）然后将Number(参数)的返回结果进行 加 1 操作。\n举例 2：\n1 2 3 4 var a = \u0026#39;abc\u0026#39;; a++; console.log(typeof a); // 打印结果：number console.log(a); // 打印结果：NaN。因为 Number(\u0026#39;abc\u0026#39;)的结果为 NaN，再自增后，结果依然是 NaN 正号/负号：+a、-a 注意，这里说的是正号/负号，不是加号/减号。\n任何值做+a、-a、/a运算时，运算结果都会自动转换为 Number 类型。 内部调用的是 Number() 函数。\n举例：\n1 2 3 4 5 6 7 8 var a = \u0026#39;666\u0026#39;; var b = +a; console.log(typeof a); // 打印结果：string。说明 a 的数据类型保持不变。 console.log(a); // 打印结果：666 console.log(typeof b); // 打印结果：number。说明 b 的数据类型发生了变化。 console.log(b); // 打印结果：666 加号：+ 情况一：字符串 + 数字\n当加号的两边，只要有一个是字符串的时候，就会调用 String() 函数将数字转为字符串，然后再计算。导致最终的运算结果是字符串。 情况二：Boolean + 数字\nBoolean 型和数字型相加时， true 按 1 来算 ，false 按 0 来算。这里其实是先调 Number() 函数，将 Boolean 类型转换为 Number类型，然后再和 数字相加。 情况三： null + 数字\n等价于：0 + 数字 情况四： undefined + 数字\n计算结果：NaN 运算符：-、*、/ 1、任何非 Number 类型的值做-、*、/运算时，会将这些值转换为Number然后再运算(内部调用的是 Number() 函数），运算结果是 Number 类型。（注：任何值 + 字符串是特例，运算结果是字符串）\n比如：\n1 2 3 4 5 6 7 result1 = true + 1; // 2 = 1+ 1 result2 = true + false; // 1 = 1+ 0 result3 = 1 + null; // 1 = 1+ 0 result4 = 100 - \u0026#39;1\u0026#39; // 99 2、任何的值和字符串做加法运算，都会先转换为字符串，然后再做拼串操作。\n比如：\n1 2 3 result1 = 1 + 2 + \u0026#39;3\u0026#39; // 33 result2 = \u0026#39;1\u0026#39; + 2 + 3; // 123 3、任何值和NaN做运算的结果都是NaN。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/07-typeof%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","summary":"前言 变量的数据类型转换：将一种数据类型转换为另外一种数据类型。 通常有三种形式的类型转换： 转换为字符串类型 转换为数字型 转换为布尔型 你会专门把某","title":"07-typeof和数据类型转换"},{"content":"剩余参数 剩余参数允许我们将不确定数量的剩余的元素放到一个数组中。\n比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。\n传统写法：\nES5 中，在定义方法时，参数要确定个数，如下：（程序会报错）\n1 2 3 4 5 6 7 8 function fn(a, b, c) { console.log(a); console.log(b); console.log(c); console.log(d); } fn(1, 2, 3); 上方代码中，因为方法的参数是三个，但使用时是用到了四个参数，所以会报错：\nES6 写法：\nES6 中，我们有了剩余参数，就不用担心报错的问题了。代码可以这样写：\n1 2 3 4 5 6 7 8 9 10 const fn = (...args) =\u0026gt; { //当不确定方法的参数时，可以使用剩余参数 console.log(args[0]); console.log(args[1]); console.log(args[2]); console.log(args[3]); }; fn(1, 2); fn(1, 2, 3); //方法的定义中了四个参数，但调用函数时只使用了三个参数，ES6 中并不会报错。 打印结果：\n1 2 3 4 5 6 7 8 9 10 1 2 undefined undefined 1 2 3 undefined 上方代码中注意，args 参数之后，不能再加别的参数，否则编译报错。\n下面这段代码，也是利用到了剩余参数：\n1 2 3 4 5 6 function fn1(first, ...args) { console.log(first); // 10 console.log(args); // 数组：[20, 30] } fn1(10, 20, 30); 剩余参数的举例：参数求和 代码举例：\n1 2 3 4 5 6 const sum = (...args) =\u0026gt; { let total = 0; args.forEach(item =\u0026gt; total += item); // 注意 forEach里面的代码，写得 很精简 return total; }; console.log(sum(10, 20, 30)); 打印结果：60\n剩余参数和解构赋值配合使用 代码举例：\n1 2 3 4 5 const students = [\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;]; let [s1, ...s2] = students; console.log(s1); // \u0026#39;张三\u0026#39; console.log(s2); // [\u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;] 扩展运算符（展开语法） 扩展运算符和剩余参数是相反的。\n剩余参数是将剩余的元素放到一个数组中；而扩展运算符是将数组或者对象拆分成逗号分隔的参数序列。\n代码举例：\n1 2 3 4 5 const arr = [10, 20, 30]; ...arr // 10, 20, 30 注意，这一行是伪代码，这里用到了扩展运算符 console.log(...arr); // 10 20 30 console.log(10, 20, 30); // 10 20 30 上面的代码要仔细看：\narr是一个数组，而...arr则表示10, 20, 30这样的序列。\n我们把...arr 打印出来，发现打印结果竟然是 10 20 30，为啥逗号不见了呢？因为逗号被当作了 console.log 的参数分隔符。如果你不信，可以直接打印 console.log(10, 20, 30) 看看。\n接下来，我们看一下扩展运算符的应用。\n举例1：数组赋值 数组赋值的代码举例：\n1 let arr2 = [...arr1]; // 将 arr1 赋值给 arr2 为了理解上面这行代码，我们先来分析一段代码：（将数组 arr1 赋值给 arr2）\n1 2 3 4 5 6 7 8 9 let arr1 = [\u0026#39;www\u0026#39;, \u0026#39;smyhvae\u0026#39;, \u0026#39;com\u0026#39;]; let arr2 = arr1; // 将 arr1 赋值给 arr2，其实是让 arr2 指向 arr1 的内存地址 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); console.log(\u0026#39;---------------------\u0026#39;); arr2.push(\u0026#39;你懂得\u0026#39;); //往 arr2 里添加一部分内容 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); 运行结果：\n上方代码中，我们往往 arr2 里添加了你懂的，却发现，arr1 里也有这个内容。原因是：let arr2 = arr1;其实是让 arr2 指向 arr1 的地址。也就是说，二者指向的是同一个内存地址。\n如果不想让 arr1 和 arr2 指向同一个内存地址，我们可以借助扩展运算符来做：\n1 2 3 4 5 6 7 8 9 let arr1 = [\u0026#39;www\u0026#39;, \u0026#39;smyhvae\u0026#39;, \u0026#39;com\u0026#39;]; let arr2 = [...arr1]; //【重要代码】arr2 会重新开辟内存地址 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); console.log(\u0026#39;---------------------\u0026#39;); arr2.push(\u0026#39;你懂得\u0026#39;); //往arr2 里添加一部分内容 console.log(\u0026#39;arr1:\u0026#39; + arr1); console.log(\u0026#39;arr2:\u0026#39; + arr2); 运行结果：\n1 2 3 4 5 arr1:www,smyhvae,com arr2:www,smyhvae,com --------------------- arr1:www,smyhvae,com arr2:www,smyhvae,com,你懂得 我们明白了这个例子，就可以避免开发中的很多业务逻辑上的 bug。\n举例2：合并数组 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 let arr1 = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; let arr2 = [\u0026#39;王四\u0026#39;, \u0026#39;王五\u0026#39;, \u0026#39;王六\u0026#39;]; // ...arr1 // \u0026#39;王一\u0026#39;,\u0026#39;王二\u0026#39;,\u0026#39;王三\u0026#39; // ...arr2 // \u0026#39;王四\u0026#39;,\u0026#39;王五\u0026#39;,\u0026#39;王六\u0026#39; // 方法1 let arr3 = [...arr1, ...arr2]; console.log(arr3); // [\u0026#34;王一\u0026#34;, \u0026#34;王二\u0026#34;, \u0026#34;王三\u0026#34;, \u0026#34;王四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;王六\u0026#34;] // 方法2 arr1.push(...arr2); console.log(arr1); // [\u0026#34;王一\u0026#34;, \u0026#34;王二\u0026#34;, \u0026#34;王三\u0026#34;, \u0026#34;王四\u0026#34;, \u0026#34;王五\u0026#34;, \u0026#34;王六\u0026#34;] 举例3：将伪数组或者可遍历对象转换为真正的数组 代码举例：\n1 2 const myDivs = document.getElementsByClassName(\u0026#39;div\u0026#39;); const divArr = [...myDivs]; // 利用扩展运算符，将伪数组转为真正的数组 补充：\n我们在《JavaScript基础/数组的常见方法》中也学过，还有一种方式，可以将伪数组（或者可遍历对象）转换为真正的数组。语法格式如下：\n1 let arr2 = Array.from(arrayLike); ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/07-%E5%89%A9%E4%BD%99%E5%8F%82%E6%95%B0%E5%92%8C%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"剩余参数 剩余参数允许我们将不确定数量的剩余的元素放到一个数组中。 比如说，当函数的实参个数大于形参个数时，我们可以将剩余的实参放到一个数组中。","title":"07-剩余参数和扩展运算符"},{"content":"andt 的介绍 Ant Design 是基于 React 实现，开发和服务于企业级后台产品。\n支持环境 现代浏览器和 IE9 及以上（需要 polyfills）。\n支持服务端渲染。\nElectron\nElectron（原名为Atom Shell）是GitHub开发的一个开源框架。 它允许使用Node.js（作为后端）和Chromium（作为前端）完成桌面GUI应用程序的开发。\n很多客户端软件都是基于 Electron 开发的。比如 VS Code。我们打开 VS Code 菜单栏的 “帮助 \u0026ndash;\u0026gt; 切换开发人员工具”，就会看到类似于 chrome的调试工具。\n相关链接 官方文档：https://ant.design/docs/react/introduce-cn andt 的使用 环境安装 1 npm install antd --save 代码示例 我们需要什么组件，就导入该组件即可。\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 容器，通过 React 渲染得到的 虚拟DOM，会呈现到这个位置 --\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）main.js:\n1 2 3 4 5 6 7 8 9 // JS打包入口文件 // 1. 导入包 import React from \u0026#34;react\u0026#34;; import ReactDOM from \u0026#34;react-dom\u0026#34;; import MyComponent from \u0026#34;./components/MyComponent.jsx\u0026#34;; // 使用 render 函数渲染 虚拟DOM ReactDOM.render(\u0026lt;MyComponent\u0026gt;\u0026lt;/MyComponent\u0026gt;, document.getElementById(\u0026#34;app\u0026#34;)); (3)MyComponent.jsx:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import React from \u0026#34;react\u0026#34;; // 导入 日期选择组件 import { DatePicker } from \u0026#34;antd\u0026#34;; export default class MyComponent extends React.Component { constructor(props) { super(props); this.state = {}; } render() { return ( \u0026lt;div\u0026gt; \u0026lt;h3\u0026gt;在组件中引入 andt\u0026lt;/h3\u0026gt; \u0026lt;DatePicker /\u0026gt; \u0026lt;/div\u0026gt; ); } } 代码运行效果：\n20190217_1500.png\nAntD组件 表格 pagination属性可以用来分页。\nloading框 需求：在数据显示之前，展示 loading；在数据显示之后，关闭loading。\n相关问题的链接 AntD pro，跳转到详情页，携带参数 ant design列表页，转跳到详情页，携带参数\nant design pro商品页带参数转到详情页\nAntD pro ，必填项前面，显示星号 表单必填项label上的红色*号是怎么出现的 其他问题 面包屑层级显示问题：https://github.com/ant-design/ant-design-pro/issues/1584\nfrom验证input框只能输入数字：https://blog.csdn.net/zr15829039341/article/details/82745239\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/08-ant-design%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"andt 的介绍 Ant Design 是基于 React 实现，开发和服务于企业级后台产品。 支持环境 现代浏览器和 IE9 及以上（需要 polyfills）。 支持服务端渲染。 Electron Electr","title":"08-Ant Design的基本使用"},{"content":"state / mutations / getters / actions =\u0026gt; 公共数据库 / 直接改变数据方法 / state的计算属性 / 异步( 调用mutations方法 )间接改变数据\n1、store.js文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 let store = new Vuex.Store({ state: { tableHeight:0, tableSHeight:0, tableTHeight:0, }, getters: { getCommonHeight: (state) =\u0026gt; (typeKey) =\u0026gt; { return state.tableHeight + \u0026#34;px\u0026#34; }, }, mutations: { changeTableHeight(state,payload){ state.tableHeight = payload.height; state.tableSHeight = payload.secondH; state.tableTHeight = payload.thirdH; } }, actions: { changeTableHeightSetTime(ctx){ setTimeout(()=\u0026gt;{ ctx.commit(\u0026#39;changeTableHeight\u0026#39;, {height:100,secondH:200,thirdH:300}); },2000) }, } }) export default store 2、实际应用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 this.$store.state.tableHeight; this.$store.commit(\u0026#39;changeTableHeight\u0026#39;, { height:460, secondH:390, thirdH:490 }) this.$store.dispatch(\u0026#39;changeTableHeightSetTime\u0026#39;); this.$store.getters.getCommonHeight; // 从vuex中按需导入mapState\\mapMutations\\mapActions\\mapGetters函数 import { mapState,mapMutations,mapActions,mapGetters } from \u0026#39;vuex\u0026#39; // 通过刚才导入的函数,将当前组件需要的全局数据,映射为当前组件的computed计算属性 computed: { ...mapState({\u0026#39;tableHeight\u0026#39;}) ...mapMutations([\u0026#39;changeTableHeight\u0026#39;]) //this.changeTableHeight() ...mapActions([\u0026#39;changeTableHeightSetTime\u0026#39;]) //this.changeTableHeightSetTime() ...mapGetters([\u0026#39;getCommonHeight\u0026#39;]) } ","permalink":"https://bablvsj.github.io/posts/tech/wait/11-vue%E5%9F%BA%E7%A1%80/08-vuex/","summary":"state / mutations / getters / actions =\u0026gt; 公共数据库 / 直接改变数据方法 / state的计算属性 / 异步( 调用mutations方法 )间接改变数据 1、store.js文件 1","title":"08-Vuex"},{"content":"字符串的扩展 下面提到的字符串的几个方法，更详细的内容，可以看《04-JavaScript 基础/内置对象 String：字符串的常见方法.md》。\nES6 中的字符串扩展如下：\nincludes(str)：判断是否包含指定的字符串\nstartsWith(str)：判断是否以指定字符串开头\nendsWith(str)：判断是否以指定字符串结尾\nrepeat(count)：重复指定次数\n举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let str = \u0026#39;abcdefg\u0026#39;; console.log(str.includes(\u0026#39;a\u0026#39;)); //true console.log(str.includes(\u0026#39;h\u0026#39;)); //false //startsWith(str) : 判断是否以指定字符串开头 console.log(str.startsWith(\u0026#39;a\u0026#39;)); //true console.log(str.startsWith(\u0026#39;d\u0026#39;)); //false //endsWith(str) : 判断是否以指定字符串结尾 console.log(str.endsWith(\u0026#39;g\u0026#39;)); //true console.log(str.endsWith(\u0026#39;d\u0026#39;)); //false //repeat(count) : 重复指定次数a console.log(str.repeat(5)); 打印结果：\nNumber 的扩展 二进制与八进制数值表示法: 二进制用0b, 八进制用0o。 举例：\n1 2 console.log(0b1010); //10 console.log(0o56); //46 Number.isFinite(i)：判断是否为有限大的数。比如Infinity这种无穷大的数，返回的就是 false。\nNumber.isNaN(i)：判断是否为 NaN。\nNumber.isInteger(i)：判断是否为整数。\nNumber.parseInt(str)：将字符串转换为对应的数值。\nMath.trunc(i)：去除小数部分。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //Number.isFinite(i) : 判断是否是有限大的数 console.log(Number.isFinite(NaN)); //false console.log(Number.isFinite(5)); //true console.log(Number.isFinite(Infinity)); //false //Number.isNaN(i) : 判断是否是NaN console.log(Number.isNaN(NaN)); //true console.log(Number.isNaN(5)); //falsse //Number.isInteger(i) : 判断是否是整数 console.log(Number.isInteger(5.23)); //false console.log(Number.isInteger(5.0)); //true console.log(Number.isInteger(5)); //true //Number.parseInt(str) : 将字符串转换为对应的数值 console.log(Number.parseInt(\u0026#39;123abc\u0026#39;)); //123 console.log(Number.parseInt(\u0026#39;a123abc\u0026#39;)); //NaN // Math.trunc(i) : 直接去除小数部分 console.log(Math.trunc(13.123)); //13 数组的扩展 下面提到的数组的几个方法，更详细的内容，可以看《04-JavaScript 基础/数组的常见方法.md》。\nArray.from()\nfind()\nfindIndex()\n对象的扩展 扩展 1 1 Object.is(v1, v2); 作用：判断两个数据是否完全相等。底层是通过字符串来判断的。\n我们先来看下面这两行代码的打印结果：\n1 2 console.log(0 == -0); console.log(NaN == NaN); 打印结果：\n1 2 true false 上方代码中，第一行代码的打印结果为 true，这个很好理解。第二行代码的打印结果为 false，因为 NaN 和任何值都不相等。\n但是，如果换成下面这种方式来比较：\n1 2 console.log(Object.is(0, -0)); console.log(Object.is(NaN, NaN)); 打印结果却是：\n1 2 false true 代码解释：还是刚刚说的那样，Object.is(v1, v2)比较的是字符串是否相等。\nObject.assign() Object.assign() 在实战开发中，使用到的频率非常高，一定要重视。关于它的内容，详见《04-JavaScript 基础/浅拷贝和深拷贝.md》。\n扩展 3：__proto__属性 举例：\n1 2 3 4 5 6 7 8 let obj1 = { name: \u0026#39;smyhvae\u0026#39; }; let obj2 = {}; obj2.__proto__ = obj1; console.log(obj1); console.log(obj2); console.log(obj2.name); 打印结果：\n上方代码中，obj2 本身是没有属性的，但是通过__proto__属性和 obj1 产生关联，于是就可以获得 obj1 里的属性。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/08-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/","summary":"字符串的扩展 下面提到的字符串的几个方法，更详细的内容，可以看《04-JavaScript 基础/内置对象 String：字符串的常见方法.md》","title":"08-字符串、数组、对象的扩展"},{"content":"我们在本文件夹的第 02 篇里讲到了JS中变量的概念，本篇文章讲一下运算符和表达式。\n运算符的定义和分类 运算符的定义 运算符：也叫操作符，是一种符号。通过运算符可以对一个或多个值进行运算，并获取运算结果。\n表达式：由数字、运算符、变量的组合（组成的式子）。\n表达式最终都会有一个运算结果，我们将这个结果称为表达式的返回值。\n比如：+、*、/、( 都是运算符，而（3+5）/2则是表达式。\n比如：typeof 就是运算符，可以来获得一个值的类型。它会将该值的类型以字符串的形式返回，返回值可以是 number、string、boolean、undefined、object。\n运算符的分类 JS 中的运算符，分类如下：\n算数运算符\n自增/自减运算符\n一元运算符\n逻辑运算符\n赋值运算符\n比较运算符\n三元运算符（条件运算符）\n下面来逐一讲解。\n算数运算符 算术运算符：用于执行两个变量或值的算术运算。\n常见的算数运算符有以下几种：\n运算符 描述 + 加、字符串连接 - 减 * 乘 / 除 % 获取余数（取余、取模） 求余的举例：\n假设用户输入345，怎么分别得到3、4、5这三个数呢？\n答案：\n1 2 3 4 5 得到3的方法：345 除以100，得到3.45然后取整，得到3。即：parseInt(345/100) 得到4的方法：345 除以100，余数是45，除以10，得到4.5，取整。即：parseInt(345 % 100 / 10) 得到5的方法：345 除以10，余数就是5。即：345 % 10 算数运算符的运算规则 （1）先算乘除、后算加减。\n（2）小括号( )：能够影响计算顺序，且可以嵌套。没有中括号、没有大括号，只有小括号。\n（3）百分号：取余。只关心余数。\n举例1：(取余)\n1 console.log(3 % 5); 输出结果为3。\n举例2：（注意运算符的优先级）\n1 var a = 1 + 2 * 3 % 4 / 3; 结果分析：\n原式 = 1 + 6 % 4 / 3 = 1 + 2 / 3 = 1.66666666666666\n补充：关于算数运算符的注意事项，详见上一篇文章里的“数据类型转换”的知识点。\n浮点数运算的精度问题 浮点数值的最高精度是 17 位小数，但在进行算术计算时，会丢失精度，导致计算不够准确。比如：\n1 2 3 console.log(0.1 + 0.2); // 运算结果不是 0.3，而是 0.30000000000000004 console.log(0.07 * 100); // 运算结果不是 7，而是 7.000000000000001 因此，不要直接判断两个浮点数是否相等。\n自增和自减 自增 ++ 自增分成两种：a++和++a。\n（1）一个变量自增以后，原变量的值会立即自增1。也就是说，无论是 a++ 还是++a，都会立即使原变量的值自增1。\n（2）我们要注意的是：a是变量，而a++和++a是表达式。\n那这两种自增，有啥区别呢？区别是：a++ 和 ++a的值不同：（也就是说，表达式的值不同）\na++这个表达式的值等于原变量的值（a自增前的值）。你可以这样理解：先把 a 的值赋值给表达式，然后 a 再自增。\n++a这个表达式的值等于新值 （a自增后的值）。 你可以这样理解：a 先自增，然后再把自增后的值赋值给表达式。\n自减 -- 原理同上。\n开发时，大多使用后置的自增/自减，并且代码独占一行，例如：num++，或者 num--。\n代码举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var n1 = 10; var n2 = 20; var result1 = n1++; console.log(n1); // 11 console.log(result1); // 10 result = ++n1; console.log(n1); //12 console.log(result); //12 var result2 = n2--; console.log(n2); // 19 console.log(result2); // 20 result2 = --n2; console.log(n2); // 18 console.log(result2); // 18 一元运算符 一元运算符，只需要一个操作数。\n常见的一元运算符如下。\ntypeof typeof就是典型的一元运算符，因为后面只跟一个操作数。\n举例如下：\n1 2 var a = \u0026#39;123\u0026#39;; console.log(typeof a); // 打印结果：string 正号 + （1）正号不会对数字产生任何影响。比如说，2和+2是一样的。\n（2）我们可以对一个其他的数据类型使用+，来将其转换为number【重要的小技巧】。比如：\n1 2 3 4 5 6 7 8 9 10 11 var a = true; a = +a; // 注意这行代码的一元运算符操作 console.log(\u0026#39;a：\u0026#39; + a); console.log(typeof a); console.log(\u0026#39;-----------------\u0026#39;); var b = \u0026#39;18\u0026#39;; b = +b; // 注意这行代码的一元运算符操作 console.log(\u0026#39;b：\u0026#39; + b); console.log(typeof b); 打印结果：\n1 2 3 4 5 6 7 a：1 number ----------------- b：18 number 负号 - 负号可以对数字进行取反。\n逻辑运算符 逻辑运算符有三个：\n\u0026amp;\u0026amp; 与（且）：两个都为真，结果才为真。\n||\t或：只要有一个是真，结果就是真。\n!\t非：对一个布尔值进行取反。\n注意：能参与逻辑运算的，都是布尔值。\n连比的写法：\n来看看逻辑运算符连比的写法。\n举例1：\n1 console.log(3 \u0026lt; 2 \u0026amp;\u0026amp; 2 \u0026lt; 4); 输出结果为false。\n举例2：（判断一个人的年龄是否在18~65岁之间）\n1 2 3 4 5 6 7 const a = prompt(\u0026#39;请输入您的年龄\u0026#39;); if (a \u0026gt;= 18 \u0026amp;\u0026amp; a \u0026lt; 65) { alert(\u0026#39;可以上班\u0026#39;); } else { alert(\u0026#39;准备退休\u0026#39;); } PS：上面的a\u0026gt;=18 \u0026amp;\u0026amp; a\u0026lt;= 65千万别想当然地写成 18\u0026lt;= a \u0026lt;= 65，没有这种语法。\n非布尔值的与或运算【重要】 之所以重要，是因为在实际开发中，我们经常用这种代码做容错处理或者兜底处理。\n非布尔值进行与或运算时，会先将其转换为布尔值，然后再运算，但返回结果是原值。比如说：\n1 2 var result = 5 \u0026amp;\u0026amp; 6; // 运算过程：true \u0026amp;\u0026amp; true; console.log(\u0026#39;result：\u0026#39; + result); // 打印结果：6（也就是说最后面的那个值。） 上方代码可以看到，虽然运算过程为布尔值的运算，但返回结果是原值。\n那么，返回结果是哪个原值呢？我们来看一下。\n与运算的返回结果：（以多个非布尔值的运算为例）\n如果第一个值为false，则执行第一条语句，并直接返回第一个值；不会再往后执行。\n如果第一个值为true，则继续执行第二条语句，并返回第二个值（如果所有的值都为true，则返回的是最后一个值）。\n或运算的返回结果：（以多个非布尔值的运算为例）\n如果第一个值为true，则执行第一条语句，并直接返回第一个值；不会再往后执行。\n如果第一个值为false，则继续执行第二条语句，并返回第二个值（（如果所有的值都为false，则返回的是最后一个值）。\n实际开发中，我们经常是这样来做「容错处理」的：\n当前端成功调用一个接口后，返回的数据为 result 对象。这个时候，我们用变量 a 来接收 result 里的图片资源。通常的写法是这样的：\n1 2 3 if (result.resultCode == 0) { var a = result \u0026amp;\u0026amp; result.data \u0026amp;\u0026amp; result.data.imgUrl || \u0026#39;http://img.smyhvae.com/20160401_01.jpg\u0026#39;; } 上方代码的意思是，获取返回结果中的result.data.imgUrl这个图片资源；如果返回结果中没有 result.data.imgUrl 这个字段，就用 http://img.smyhvae.com/20160401_01.jpg 作为兜底图片。这种写法，在实际开发中经常用到。\n非布尔值的 ! 运算 非布尔值进行非运算时，会先将其转换为布尔值，然后再运算，但返回结果是布尔值。\n举例：\n1 2 3 4 5 let a = 10; a = !a console.log(a); // false console.log(typeof a); // boolean 短路运算的妙用【重要】 下方举例中的写法技巧，在实际开发中，经常用到。这种写法，是一种很好的「容错、容灾、降级」方案，需要多看几遍。\n1、JS中的\u0026amp;\u0026amp;属于短路的与：\n如果第一个值为false，则不会执行后面的内容。\n如果第一个值为 true，则继续执行第二条语句，并返回第二个值。\n举例：\n1 2 3 4 5 6 7 const a1 = \u0026#39;qianguyihao\u0026#39;; //第一个值为true，会继续执行后面的内容 a1 \u0026amp;\u0026amp; alert(\u0026#39;看 a1 出不出来\u0026#39;); // 可以弹出 alert 框 const a2 = undefined; //第一个值为false，不会继续执行后面的内容 a2 \u0026amp;\u0026amp; alert(\u0026#39;看 a2 出不出来\u0026#39;); // 不会弹出 alert 框 2、JS中的||属于短路的或：\n如果第一个值为true，则不会执行后面的内容。\n如果第一个值为 false，则继续执行第二条语句，并返回第二个值。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 const result; // 请求接口时，后台返回的内容 let errorMsg = \u0026#39;\u0026#39;; // 前端的文案提示 if (result \u0026amp;\u0026amp; result.retCode != 0) { // 接口返回异常码时 errorMsg = result.msg || \u0026#39;活动太火爆，请稍后再试\u0026#39;; // 文案提示信息，优先用 接口返回的msg字段，其次用 \u0026#39;活动太火爆，请稍后再试\u0026#39; 这个文案兜底。 } if (!result) { // 接口挂掉时 errorMsg = \u0026#39;网络异常，请稍后再试\u0026#39;; } 赋值运算符 可以将符号右侧的值赋值给符号左侧的变量。\n举例：\n= 直接赋值。比如 var a = 5\n+=。a += 5 等价于 a = a + 5\n-=。a -= 5 等价于 a = a - 5\n*=。a *= 5 等价于 a = a * 5\n/=。a /= 5 等价于 a = a / 5\n%=。a %= 5 等价于 a = a % 5\n比较运算符 比较运算符可以比较两个值之间的大小关系，如果关系成立它会返回true，如果关系不成立则返回false。\n比较运算符有很多种，比如：\n1 2 3 4 5 6 7 8 \u0026gt;\t大于号 \u0026lt;\t小于号 \u0026gt;= 大于或等于 \u0026lt;= 小于或等于 == 等于 === 全等于 !=\t不等于 !== 不全等于 比较运算符，得到的结果都是布尔值：要么是true，要么是false。\n举例如下：\n1 var result = 5 \u0026gt; 10; // false 非数值的比较 （1）对于非数值进行比较时，会将其转换为数字然后再比较。\n举例如下：\n1 2 3 4 5 6 7 8 9 10 console.log(1 \u0026gt; true); //false console.log(1 \u0026gt;= true); //true console.log(1 \u0026gt; \u0026#34;0\u0026#34;); //true //console.log(10 \u0026gt; null); //true //任何值和NaN做任何比较都是false console.log(10 \u0026lt;= \u0026#34;hello\u0026#34;); //false console.log(true \u0026gt; false); //true （2）特殊情况：如果符号两侧的值都是字符串时，不会将其转换为数字进行比较。比较两个字符串时，比较的是字符串的Unicode编码。【非常重要，这里是个大坑，很容易踩到】\n比较字符编码时，是一位一位进行比较。如果两位一样，则比较下一位。\n比如说，当你尝试去比较\u0026quot;123\u0026quot;和\u0026quot;56\u0026quot;这两个字符串时，你会发现，字符串\u0026quot;56\u0026quot;竟然比字符串\u0026quot;123\u0026quot;要大（因为 5 比 1 大）。也就是说，下面这样代码的打印结果，其实是true:（这个我们一定要注意，在日常开发中，很容易忽视）\n1 2 // 比较两个字符串时，比较的是字符串的字符编码，所以可能会得到不可预期的结果 console.log(\u0026#34;56\u0026#34; \u0026gt; \u0026#34;123\u0026#34;); // true 因此：当我们在比较两个字符串型的数字时，一定一定要先转型再比较大小，比如 parseInt()。\n（3）任何值和NaN做任何比较都是false。\n==符号的强调 注意==这个符号，它是判断是否等于，而不是赋值。\n（1）== 这个符号，还可以验证字符串是否相同。例如：\n1 console.log(\u0026#34;我爱你中国\u0026#34; == \u0026#34;我爱你中国\u0026#34;);\t// 输出结果为true （2）== 这个符号并不严谨，会做隐式转换，将不同的数据类型，转为相同类型进行比较（大部分情况下，都是转换为数字）。例如：\n1 2 3 4 5 console.log(\u0026#34;6\u0026#34; == 6);\t// 打印结果：true。这里的字符串\u0026#34;6\u0026#34;会先转换为数字6，然后再进行比较 console.log(true == \u0026#34;1\u0026#34;); // 打印结果：true console.log(0 == -0); // 打印结果：true console.log(null == 0); // 打印结果：false （3）undefined 衍生自 null，所以这两个值做相等判断时，会返回true。\n1 console.log(undefined == null); //打印结果：true。 （4）NaN不和任何值相等，包括他本身。\n1 2 console.log(NaN == NaN); //false console.log(NaN === NaN); //false 问题：那如果我想判断 b的值是否为NaN，该怎么办呢？\n答案：可以通过isNaN()函数来判断一个值是否是NaN。举例：\n1 console.log(isNaN(b)); 如上方代码所示，如果 b 为 NaN，则返回true；否则返回false。\n===全等符号的强调 全等在比较时，不会做类型转换。如果要保证绝对等于（完全等于），我们就要用三个等号===。例如：\n1 2 console.log(\u0026#34;6\u0026#34; === 6);\t//false console.log(6 === 6);\t//true 上述内容分析出：\n==两个等号，不严谨，\u0026ldquo;6\u0026quot;和6是true。\n===三个等号，严谨，\u0026ldquo;6\u0026quot;和6是false。\n另外还有：==的反面是!=，===的反面是!==。例如：\n1 2 3 console.log(3 != 8);\t//true console.log(3 != \u0026#34;3\u0026#34;);\t//false，因为3==\u0026#34;3\u0026#34;是true，所以反过来就是false。 console.log(3 !== \u0026#34;3\u0026#34;);\t//true，应为3===\u0026#34;3\u0026#34;是false，所以反过来是true。 三元运算符 三元运算符也叫条件运算符。\n语法：\n1 条件表达式 ? 语句1 : 语句2; 执行的流程：\n条件运算符在执行时，首先对条件表达式进行求值：\n如果该值为true，则执行语句1，并返回执行结果\n如果该值为false，则执行语句2，并返回执行结果\n如果条件的表达式的求值结果是一个非布尔值，会将其转换为布尔值然后再运算。\n运算符的优先级 运算符的优先级如下：（优先级从高到低）\n.、[]、new\n()\n++、--\n!、~、+（单目）、-（单目）、typeof、void、delete\n%、*、/\n+（双目）、-（双目）\n\u0026lt;\u0026lt;、\u0026gt;\u0026gt;、\u0026gt;\u0026gt;\u0026gt;\n关系运算符：\u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=\n==、!==、===、!==\n\u0026amp;\n^\n|\n\u0026amp;\u0026amp;\n||\n?:\n=、+=、-=、*=、/=、%=、\u0026lt;\u0026lt;=、\u0026gt;\u0026gt;=、\u0026gt;\u0026gt;\u0026gt;=、\u0026amp;=、^=、|=\n,\n注意：逻辑与 \u0026amp;\u0026amp; 比逻辑或 || 的优先级更高。\n备注：你在实际写代码的时候，如果不清楚哪个优先级更高，可以把括号运用上。\nUnicode 编码 这一段中，我们来讲引申的内容：Unicode编码的使用。\n各位同学可以先在网上查一下“Unicode 编码表”。\n1、在字符串中可以使用转义字符输入Unicode编码。格式如下：\n1 \\u四位编码 举例如下：\n1 2 console.log(\u0026#34;\\u2600\u0026#34;); // 这里的 2600 采用的是16进制 console.log(\u0026#34;\\u2602\u0026#34;); // 这里的 2602 采用的是16进制。 打印结果：\n2、我们还可以在 HTML 网页中使用Unicode编码。格式如下：\n1 \u0026amp;#四位编码; PS：我们知道，Unicode编码采用的是16进制，但是，这里的编码需要使用10进制。\n举例如下：\n1 \u0026lt;h1 style=\u0026#34;font-size: 100px;\u0026#34;\u0026gt;\u0026amp;#9860;\u0026lt;/h1\u0026gt; 打印结果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/08-%E8%BF%90%E7%AE%97%E7%AC%A6/","summary":"我们在本文件夹的第 02 篇里讲到了JS中变量的概念，本篇文章讲一下运算符和表达式。 运算符的定义和分类 运算符的定义 运算符：也叫操作符，是一种符号。","title":"08-运算符"},{"content":"前言 本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。\n前端做文件上传这个功能，是很有技术难度的。既然框架给我们提供好了，那就直接用呗。结果用的时候，发现 upload 组件的很多bug。下面来列举几个。\n备注：本文写于2019-03-02，使用的 antd 版本是 3.13.6。\n使用 AntD 的 upload 组件做图片的上传 因为需要上传多张图片，所以采用的是照片墙的形式。上传成功后的界面如下：\n（1）上传中：\n（2）上传成功：\n（3）图片预览：\n按照官方提供的实例，特此整理出项目开发中的完整写法，亲测有效。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 /* eslint-disable */ import { Upload, Icon, Modal, Form } from \u0026#39;antd\u0026#39;; const FormItem = Form.Item; class PicturesWall extends PureComponent { state = { previewVisible: false, previewImage: \u0026#39;\u0026#39;, imgList: [], }; handleChange = ({ file, fileList }) =\u0026gt; { console.log(JSON.stringify(file)); // file 是当前正在上传的 单个 img console.log(JSON.stringify(fileList)); // fileList 是已上传的全部 img 列表 this.setState({ imgList: fileList, }); }; handleCancel = () =\u0026gt; this.setState({ previewVisible: false }); handlePreview = file =\u0026gt; { this.setState({ previewImage: file.url || file.thumbUrl, previewVisible: true, }); }; // 参考链接：https://www.jianshu.com/p/f356f050b3c9 handleBeforeUpload = file =\u0026gt; { //限制图片 格式、size、分辨率 const isJPG = file.type === \u0026#39;image/jpeg\u0026#39;; const isJPEG = file.type === \u0026#39;image/jpeg\u0026#39;; const isGIF = file.type === \u0026#39;image/gif\u0026#39;; const isPNG = file.type === \u0026#39;image/png\u0026#39;; if (!(isJPG || isJPEG || isGIF || isPNG)) { Modal.error({ title: \u0026#39;只能上传JPG 、JPEG 、GIF、 PNG格式的图片~\u0026#39;, }); return; } const isLt2M = file.size / 1024 / 1024 \u0026lt; 2; if (!isLt2M) { Modal.error({ title: \u0026#39;超过2M限制，不允许上传~\u0026#39;, }); return; } return (isJPG || isJPEG || isGIF || isPNG) \u0026amp;\u0026amp; isLt2M \u0026amp;\u0026amp; this.checkImageWH(file); }; //返回一个 promise：检测通过则返回resolve；失败则返回reject，并阻止图片上传 checkImageWH(file) { let self = this; return new Promise(function(resolve, reject) { let filereader = new FileReader(); filereader.onload = e =\u0026gt; { let src = e.target.result; const image = new Image(); image.onload = function() { // 获取图片的宽高，并存放到file对象中 console.log(\u0026#39;file width :\u0026#39; + this.width); console.log(\u0026#39;file height :\u0026#39; + this.height); file.width = this.width; file.height = this.height; resolve(); }; image.onerror = reject; image.src = src; }; filereader.readAsDataURL(file); }); } handleSubmit = e =\u0026gt; { const { dispatch, form } = this.props; e.preventDefault(); form.validateFieldsAndScroll((err, values) =\u0026gt; {// values 是form表单里的参数 // 点击按钮后，将表单提交给后台 dispatch({ type: \u0026#39;mymodel/submitFormData\u0026#39;, payload: values, }); }); }; render() { const { previewVisible, previewImage, imgList } = this.state; // 从 state 中拿数据 const uploadButton = ( \u0026lt;div\u0026gt; \u0026lt;Icon type=\u0026#34;plus\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;ant-upload-text\u0026#34;\u0026gt;Upload\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); return ( \u0026lt;div className=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;Form onSubmit={this.handleSubmit} hideRequiredMark style={{ marginTop: 8 }}\u0026gt; \u0026lt;FormItem label=\u0026#34;图片图片\u0026#34; {...formItemLayout}\u0026gt; {getFieldDecorator(\u0026#39;myImg\u0026#39;)( \u0026lt;Upload action=\u0026#34;//jsonplaceholder.typicode.com/posts/\u0026#34; // 这个是图片上传的接口请求，实际开发中，要替换成你自己的业务接口 data={file =\u0026gt; ({ // data里存放的是接口的请求参数 param1: myParam1, param2: myParam2, photoCotent: file, // file 是当前正在上传的图片 photoWidth: file.height, // 通过 handleBeforeUpload 获取 图片的宽高 photoHeight: file.width, })} listType=\u0026#34;picture-card\u0026#34; fileList={this.state.imgList} onPreview={this.handlePreview} // 点击图片缩略图，进行预览 beforeUpload={this.handleBeforeUpload} // 上传之前，对图片的格式做校验，并获取图片的宽高 onChange={this.handleChange} // 每次上传图片时，都会触发这个方法 \u0026gt; {this.state.imgList.length \u0026gt;= 9 ? null : uploadButton} \u0026lt;/Upload\u0026gt; )} \u0026lt;/FormItem\u0026gt; \u0026lt;/Form\u0026gt; \u0026lt;Modal visible={previewVisible} footer={null} onCancel={this.handleCancel}\u0026gt; \u0026lt;img alt=\u0026#34;example\u0026#34; style={{ width: \u0026#39;100%\u0026#39; }} src={previewImage} /\u0026gt; \u0026lt;/Modal\u0026gt; \u0026lt;/div\u0026gt; ); } } export default PicturesWall; 上传后，点击图片预览，浏览器卡死的问题 依据上方的代码，通过 Antd 的 upload 组件将图片上传成功后，点击图片的缩略图，理应可以在当前页面弹出 Modal，预览图片。但实际的结果是，浏览器一定会卡死。\n定位问题发现，原因竟然是：图片上传成功后， upload 会将其转为 base64编码。base64这个字符串太大了，点击图片预览的时候，浏览器在解析一大串字符串，然后就卡死了。详细过程描述如下。\n上方代码中，我们可以把 handleChange(file, fileList)方法中的 file、以及 fileList打印出来看看。 file指的是当前正在上传的 单个 img，fileList是已上传的全部 img 列表。 当我上传完 两张图片后， 打印结果如下：\nfile的打印的结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-5\u0026#34;, \u0026#34;width\u0026#34;: 600, \u0026#34;height\u0026#34;: 354, \u0026#34;lastModified\u0026#34;: 1546701318000, \u0026#34;lastModifiedDate\u0026#34;: \u0026#34;2019-01-05T15:15:18.000Z\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;e30e7b9680634b2c888c8bb513cc595d.jpg\u0026#34;, \u0026#34;size\u0026#34;: 31731, \u0026#34;type\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;percent\u0026#34;: 100, \u0026#34;originFileObj\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-5\u0026#34;, \u0026#34;width\u0026#34;: 600, \u0026#34;height\u0026#34;: 354 }, \u0026#34;status\u0026#34;: \u0026#34;done\u0026#34;, \u0026#34;thumbUrl\u0026#34;: \u0026#34;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAHQ9qKKlbimcXrIH9o2vH/AC2T+ddPj98v+9RRWsuhnHdk0ar9qb5R0Pb6VPB/qh9aKKiRr0Irnt/vUDr+NFFJCRqWxJik5Pb+dLJ938aKK06mYSdKKKKBH//Z\u0026#34;, \u0026#34;response\u0026#34;: { \u0026#34;retCode\u0026#34;: 0, \u0026#34;imgUrl\u0026#34;: \u0026#34;http://qianguyihao.com/opfewfwj098902kpkpkkj976fe.jpg\u0026#34;, \u0026#34;photoid\u0026#34;: 271850 } } fileList 的打印结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 [ { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-3\u0026#34;, \u0026#34;width\u0026#34;: 1000, \u0026#34;height\u0026#34;: 667, \u0026#34;lastModified\u0026#34;: 1501414799000, \u0026#34;lastModifiedDate\u0026#34;: \u0026#34;2017-07-30T11:39:59.000Z\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;29381f30e924b89914e91b33.jpg\u0026#34;, \u0026#34;size\u0026#34;: 135204, \u0026#34;type\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;percent\u0026#34;: 100, \u0026#34;originFileObj\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-3\u0026#34;, \u0026#34;width\u0026#34;: 1000, \u0026#34;height\u0026#34;: 667 }, \u0026#34;status\u0026#34;: \u0026#34;done\u0026#34;, \u0026#34;thumbUrl\u0026#34;: \u0026#34;data:image/jpeg;base64,/E3ju1tlaK1fzJOnHQU3LsLV7HO6Zrk11MZJ7luT0A4FZuRagi9quvzQQ4iuEJ7ZpqTG4djDsPFl2Lg733f8C4q+YhQ8zoYfGSqoMmfwo5huLL0HjiyPDSYPvxRdC1XQvxeLrB8fvl/OnoLmL9vrdvvYS3NGFVe2YsASOh71JfQyrqV2mXLHOcccVSIYEnDyZO9XXB9KYH//Z\u0026#34;, \u0026#34;response\u0026#34;: { \u0026#34;retCode\u0026#34;: 0, \u0026#34;msg\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;imgUrl\u0026#34;: \u0026#34;http://qianguyihao.com/hfwpjouiurewnmbhepr689.jpg\u0026#34;, } }, { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-5\u0026#34;, \u0026#34;width\u0026#34;: 600, \u0026#34;height\u0026#34;: 354, \u0026#34;lastModified\u0026#34;: 1546701318000, \u0026#34;lastModifiedDate\u0026#34;: \u0026#34;2019-01-05T15:15:18.000Z\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;e30e7b9680634b2c888c8bb513cc595d.jpg\u0026#34;, \u0026#34;size\u0026#34;: 31731, \u0026#34;type\u0026#34;: \u0026#34;image/jpeg\u0026#34;, \u0026#34;percent\u0026#34;: 100, \u0026#34;originFileObj\u0026#34;: { \u0026#34;uid\u0026#34;: \u0026#34;rc-upload-1551084269812-5\u0026#34;, \u0026#34;width\u0026#34;: 600, \u0026#34;height\u0026#34;: 354 }, \u0026#34;status\u0026#34;: \u0026#34;done\u0026#34;, \u0026#34;thumbUrl\u0026#34;: \u0026#34;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAHQ9qKKlbimcXrIH9o2vH/AC2T+ddPj98v+9RRWsuhnHdk0ar9qb5R0Pb6VPB/qh9aKKiRr0Irnt/vUDr+NFFJCRqWxJik5Pb+dLJ938aKK06mYSdKKKKBH//Z\u0026#34;, \u0026#34;response\u0026#34;: { \u0026#34;retCode\u0026#34;: 0, \u0026#34;imgUrl\u0026#34;: \u0026#34;http://qianguyihao.com/opfewfwj098902kpkpkkj976fe.jpg\u0026#34;, \u0026#34;photoid\u0026#34;: 271850 } } ] 上方的json数据中，需要做几点解释：\n（1）response 字段里面的数据，就是请求接口后，后台返回给前端的数据，里面包含了图片的url链接。\n（2）status 字段里存放的是图片上传的实时状态，包括上传中、上传完成、上传失败。\n（3）thumbUrl字段里面存放的是图片的base64编码。\n这个base64编码非常非常长。当点击图片预览的时候，其实就是加载的 thumbUrl 这个字段里的资源，难怪浏览器会卡死。\n解决办法：在 handleChange方法里，图片上传成功后，将 thumbUrl 字段里面的 base64 编码改为真实的图片url。代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 handleChange = ({ file, fileList }) =\u0026gt; { console.log(JSON.stringify(file)); // file 是当前正在上传的 单个 img console.log(JSON.stringify(fileList)); // fileList 是已上传的全部 img 列表 // 【重要】将 图片的base64替换为图片的url。 这一行一定不会能少。 // 图片上传成功后，fileList数组中的 thumbUrl 中保存的是图片的base64字符串，这种情况，导致的问题是：图片上传成功后，点击图片缩略图，浏览器会会卡死。而下面这行代码，可以解决该bug。 fileList.forEach(imgItem =\u0026gt; { if (imgItem \u0026amp;\u0026amp; imgItem.status == \u0026#39;done\u0026#39; \u0026amp;\u0026amp; imgItem.response \u0026amp;\u0026amp; imgItem.response.imgUrl) { imgItem.thumbUrl = imgItem.response.imgUrl; } }); this.setState({ imgList: fileList, }); }; 新需求：编辑现有页面 上面一段的代码中，我们是在新建的页面中，从零开始上传图片。\n现在有个新的需求：如何编辑现有的页面呢？也就是说，现有的页面在初始化时，是默认有几张图片的。当我编辑这个页面时，可以对现有的图片做增删，也能增加新的图片。而且要保证：新建页面和编辑现有页面，是共用一套代码。\n我看到upload 组件有提供 defaultFileList 的属性。我试了下，这个defaultFileList 的属性根本没法儿用。\n那就只有手动实现了。我的model层代码，是用 redux 写的。整体的实现思路如下：（这个也是在真正在实战中用到的代码）\n（1）PicturesWall.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 /* eslint-disable */ import { Upload, Icon, Modal, Form } from \u0026#39;antd\u0026#39;; const FormItem = Form.Item; class PicturesWall extends PureComponent { state = { previewVisible: false, previewImage: \u0026#39;\u0026#39;, }; // 页面初始化的时候，从接口拉取默认的图片数据 componentDidMount() { const { dispatch } = this.props; dispatch({ type: \u0026#39;mymodel/getAllInfo\u0026#39;, payload: { params: xxx }, }); } handleChange = ({ file, fileList }) =\u0026gt; { const { dispatch } = this.props; // 【重要】将 图片的base64替换为图片的url。 这一行一定不会能少。 // 图片上传成功后，fileList数组中的 thumbUrl 中保存的是图片的base64字符串，这种情况，导致的问题是：图片上传成功后，点击图片缩略图，浏览器会会卡死。而下面这行代码，可以解决该bug。 fileList.forEach(imgItem =\u0026gt; { if (imgItem \u0026amp;\u0026amp; imgItem.status == \u0026#39;done\u0026#39; \u0026amp;\u0026amp; imgItem.response \u0026amp;\u0026amp; imgItem.response.imgUrl) { imgItem.thumbUrl = imgItem.response.imgUrl; } }); dispatch({ type: \u0026#39;mymodel/setImgList\u0026#39;, payload: fileList, }); }; handleCancel = () =\u0026gt; this.setState({ previewVisible: false }); handlePreview = file =\u0026gt; { this.setState({ previewImage: file.url || file.thumbUrl, previewVisible: true, }); }; // 参考链接：https://www.jianshu.com/p/f356f050b3c9 handleBeforeUpload = file =\u0026gt; { //限制图片 格式、size、分辨率 const isJPG = file.type === \u0026#39;image/jpeg\u0026#39;; const isJPEG = file.type === \u0026#39;image/jpeg\u0026#39;; const isGIF = file.type === \u0026#39;image/gif\u0026#39;; const isPNG = file.type === \u0026#39;image/png\u0026#39;; const isLt2M = file.size / 1024 / 1024 \u0026lt; 2; if (!(isJPG || isJPEG || isGIF || isPNG)) { Modal.error({ title: \u0026#39;只能上传JPG 、JPEG 、GIF、 PNG格式的图片~\u0026#39;, }); } else if (!isLt2M) { Modal.error({ title: \u0026#39;超过2M限制，不允许上传~\u0026#39;, }); } } // 参考链接：https://github.com/ant-design/ant-design/issues/8779 return new Promise((resolve, reject) =\u0026gt; { if (!(isJPG || isJPEG || isGIF || isPNG)) { reject(file); } else { resolve(file \u0026amp;\u0026amp; this.checkImageWH(file)); } }); }; //返回一个 promise：检测通过则返回resolve；失败则返回reject，并阻止图片上传 checkImageWH(file) { let self = this; return new Promise(function(resolve, reject) { let filereader = new FileReader(); filereader.onload = e =\u0026gt; { let src = e.target.result; const image = new Image(); image.onload = function() { // 获取图片的宽高，并存放到file对象中 console.log(\u0026#39;file width :\u0026#39; + this.width); console.log(\u0026#39;file height :\u0026#39; + this.height); file.width = this.width; file.height = this.height; resolve(); }; image.onerror = reject; image.src = src; }; filereader.readAsDataURL(file); }); } handleSubmit = e =\u0026gt; { const { dispatch, form } = this.props; e.preventDefault(); const { mymodel: { imgList }, // 从props中拿默认的图片数据 } = this.props; form.validateFieldsAndScroll((err, values) =\u0026gt; { // values 是form表单里的参数 // 点击按钮后，将表单提交给后台 // start 问题描述：当编辑现有页面时，如果针对已经存在的默认图片不做修改，则不会触发 upload 的 onChange方法。此时提交表单，表单里的 myImg 字段是空的。 // 解决办法：如果发现存在默认图片，则追加到表单中 if (!values.myImg) { values.myImg = { fileList: [] }; values.myImg.fileList = imgList; } // end dispatch({ type: \u0026#39;mymodel/submitFormData\u0026#39;, payload: values, }); }); }; render() { const { previewVisible, previewImage } = this.state; // 从 state 中拿数据 const { mymodel: { imgList }, // 从props中拿到的图片数据 } = this.props; const uploadButton = ( \u0026lt;div\u0026gt; \u0026lt;Icon type=\u0026#34;plus\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;ant-upload-text\u0026#34;\u0026gt;Upload\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); return ( \u0026lt;div className=\u0026#34;clearfix\u0026#34;\u0026gt; \u0026lt;Form onSubmit={this.handleSubmit} hideRequiredMark style={{ marginTop: 8 }}\u0026gt; \u0026lt;FormItem label=\u0026#34;图片上传\u0026#34; {...formItemLayout}\u0026gt; {getFieldDecorator(\u0026#39;myImg\u0026#39;)( \u0026lt;Upload action=\u0026#34;//jsonplaceholder.typicode.com/posts/\u0026#34; // 这个是图片上传的接口请求，实际开发中，要替换成你自己的业务接口 data={file =\u0026gt; ({ // data里存放的是接口的请求参数 param1: myParam1, param2: myParam2, photoCotent: file, // file 是当前正在上传的图片 photoWidth: file.height, // 通过 handleBeforeUpload 获取 图片的宽高 photoHeight: file.width, })} listType=\u0026#34;picture-card\u0026#34; fileList={imgList} // 改为从 props 里拿图片数据，而不是从 state onPreview={this.handlePreview} // 点击图片缩略图，进行预览 beforeUpload={this.handleBeforeUpload} // 上传之前，对图片的格式做校验，并获取图片的宽高 onChange={this.handleChange} // 每次上传图片时，都会触发这个方法 \u0026gt; {this.state.imgList.length \u0026gt;= 9 ? null : uploadButton} \u0026lt;/Upload\u0026gt; )} \u0026lt;/FormItem\u0026gt; \u0026lt;/Form\u0026gt; \u0026lt;Modal visible={previewVisible} footer={null} onCancel={this.handleCancel}\u0026gt; \u0026lt;img alt=\u0026#34;example\u0026#34; style={{ width: \u0026#39;100%\u0026#39; }} src={previewImage} /\u0026gt; \u0026lt;/Modal\u0026gt; \u0026lt;/div\u0026gt; ); } } export default PicturesWall; （2）mymodel.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 /* eslint-disable */ import { routerRedux } from \u0026#39;dva/router\u0026#39;; import { message, Modal } from \u0026#39;antd\u0026#39;; import { getGoodsInfo, getAllGoods, } from \u0026#39;../services/api\u0026#39;; import { trim, getCookie } from \u0026#39;../utils/utils\u0026#39;; export default { namespace: \u0026#39;mymodel\u0026#39;, state: { form: {}, list: [], listDetail: [], goodsList: [], goodsListDetail: [], pagination: { pageSize: 10, total: 0, current: 1, }, imgList: [], //图片 }, subscriptions: { setup({ dispatch, history }) { history.listen(location =\u0026gt; { if (location.pathname !== \u0026#39;/xx/xxx\u0026#39;) return; if (!location.state || !location.state.xxxId) return; dispatch({ type: \u0026#39;fetch\u0026#39;, payload: location.state, }); }); }, }, effects: { // 接口。获取所有工厂店的列表 (步骤02) *getAllInfo({ payload }, { select, call, put }) { yield put({ type: \u0026#39;form\u0026#39;, payload, }); console.log(\u0026#39;params:\u0026#39; + JSON.stringify(payload)); let params = {}; params = payload; const response = yield call(getGoodsInfo, params); console.log(\u0026#39;smyhvae response:\u0026#39; + JSON.stringify(response)); if (response.error) return; yield put({ type: \u0026#39;allInfo\u0026#39;, payload: (response.data \u0026amp;\u0026amp; response.data.map(item =\u0026gt; ({ xx1: item.yy1, xx2: item.yy2, }))) || [], }); // response 里包含了接口返回给前端的默认图片数据 if (response \u0026amp;\u0026amp; response.data \u0026amp;\u0026amp; response.data[0] \u0026amp;\u0026amp; response.data[0].my_jpg) { let tempImgList = response.data[0].my_jpg.split(\u0026#39;,\u0026#39;); let imgList = []; if (tempImgList.length \u0026gt; 0) { tempImgList.forEach(item =\u0026gt; { imgList.push({ uid: item, name: \u0026#39;xxx.png\u0026#39;, status: \u0026#39;done\u0026#39;, thumbUrl: item, }); }); } // 通过 redux的方式 将 默认图片 传给 imgList console.log(\u0026#39;smyhvae payload imgList:\u0026#39; + JSON.stringify(imgList)); yield put({ type: \u0026#39;setImgList\u0026#39;, payload: imgList, }); } }, *setImgList({ payload }, { call, put }) { console.log(\u0026#39;model setImgList\u0026#39;); yield put({ type: \u0026#39;getImgList\u0026#39;, payload, }); }, }, reducers: { allInfo(state, action) { return { ...state, list: action.payload, }; }, getImgList(state, action) { return { ...state, imgList: action.payload, }; }, }, }; 上面的代码，可以规避 upload 组件的一些bug；而且可以在上传前，通过校验图片的尺寸、大小等，如果不满足条件，则弹出modal弹窗，阻止上传。\n大功告成。本文感谢 ld 同学的支持。\n更多内容，可以看本人的另外一篇文章：\nAntD框架的upload组件上传图片时使用customRequest方法自定义上传行为 其他问题 beforeUpload返回false后，文件仍然为上传中的状态 最后一段 有人说，前端开发，连卖菜的都会。可如果真的遇到技术难题，还是得找个靠谱的前端同学才行。这不，来看看前端码农日常：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/09-antd%E6%A1%86%E6%9E%B6%E7%9A%84upload%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/","summary":"前言 本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。 前端做文件上传这个功能，是很有技术难度的。既然框架给我们提","title":"09-AntD框架的upload组件上传图片时遇到的一些坑"},{"content":"Set 数据结构 Set 数据结构的介绍 ES6 提供了 新的数据结构 Set。Set 类似于数组，但成员的值都是唯一的，没有重复的值。\nSet 的应用有很多。比如，在 H5 页面的搜索功能里，用户可能会多次搜索重复的关键字；但是在数据存储上，不需要存储重复的关键字。此时，我们就可以用 Set 来存储用户的搜索记录，Set 内部会自动判断值是否重复，如果重复，则不会进行存储，十分方便。\n生成 Set 数据结构 Set 本身就是一个构造函数，可通过 new Set() 生成一个 Set 的实例。\n举例 1：\n1 2 const set1 = new Set(); console.log(set1.size); // 打印结果：0 举例 2、可以接收一个数组作为参数，实现数组去重：\n1 2 3 4 5 6 7 8 9 10 const set2 = new Set([\u0026#39;张三\u0026#39;, \u0026#39;李四\u0026#39;, \u0026#39;王五\u0026#39;, \u0026#39;张三\u0026#39;]); // 注意，这个数组里有重复的值 // 注意，这里的 set2 并不是数组，而是一个单纯的 Set 数据结构 console.log(set2); // {\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;} // 通过扩展运算符，拿到 set 中的元素（用逗号分隔的序列） // ...set2 // \u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34; // 注意，到这一步，才获取到了真正的数组 console.log([...set2]); // [\u0026#34;张三\u0026#34;, \u0026#34;李四\u0026#34;, \u0026#34;王五\u0026#34;] 注意上方的第一行代码，虽然参数里传递的是数组结构，但拿到的 set2 不是数组结构，而是 Set 结构，而且里面元素是去重了的。通过 [...set2]就可以拿到set2对应的数组。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/09-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E6%89%A9%E5%B1%95set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"Set 数据结构 Set 数据结构的介绍 ES6 提供了 新的数据结构 Set。Set 类似于数组，但成员的值都是唯一的，没有重复的值。 Set 的应用有很多。比如，在 H5 页面的","title":"09-内置对象扩展：Set数据结构"},{"content":"代码块 用{}包围起来的代码，就是代码块。\n在 ES5 语法中，代码块，只具有分组的作用，没有其他的用途。代码块中的内容，在外部是完全可见的。举例：\n1 2 3 4 5 6 7 { var a = 2; alert(\u0026#39;qianguyihao\u0026#39;); console.log(\u0026#39;永不止步\u0026#39;); } console.log(\u0026#39;a = \u0026#39; + a); 打印结果：（可以看出，虽然变量 a 是定义在代码块中的，但是在外部依然可以访问）\n1 2 永不止步 a = 2 流程控制语句 在一个程序执行的过程中，各条语句的执行顺序对程序的结果是有直接影响的。所以，我们必须清楚每条语句的执行流程。而且，很多时候我们要通过控制语句的执行顺序来实现我们要完成的功能。\n流程控制语句分类 顺序结构\n选择结构：if 语句、switch 语句\n循环结构：while 语句、for 语句\n顺序结构 按照代码的先后顺序，依次执行。结构图如下：\nif 语句 if 语句有以下三种。\n1、条件判断语句 条件成立才执行。如果条件不成立，那就什么都不做。\n格式：\n1 2 3 if (条件表达式) { // 条件为真时，做的事情 } 2、条件分支语句 格式 1：\n1 2 3 4 5 6 7 if (条件表达式) { // 条件为真时，做的事情 } else { // 条件为假时，做的事情 } 格式 2：（多分支的 if 语句）\n1 2 3 4 5 6 7 8 9 10 11 12 if (条件表达式1) { // 条件1为真时，做的事情 } else if (条件表达式2) { // 条件1不满足，条件2满足时，做的事情 } else if (条件表达式3) { // 条件1、2不满足，条件3满足时，做的事情 } else { // 条件1、2、3都不满足时，做的事情 } 以上所有的语句体中，只执行其中一个。\n做个题目 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 根据BMI（身体质量指数）显示一个人的体型。 BMI指数，就是体重、身高的一个计算公式。公式是： BMI =体重÷身高的平方 比如，老师的体重是81.6公斤，身高是1.71米。 那么老师的BMI就是 81.6 ÷ 1.712 等于 27.906022365856163 过轻：低于18.5 正常：18.5-24.99999999 过重：25-27.9999999 肥胖：28-32 非常肥胖, 高于32 用JavaScript开发一个程序，让用户先输入自己的体重，然后输入自己的身高（弹出两次prompt框）。 计算它的BMI，根据上表，弹出用户的身体情况。比如“过轻” 、 “正常” 、“过重” 、 “肥胖” 、“非常肥胖”。 答案：\n写法 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //第一步，输入身高和体重 var height = parseFloat(prompt(\u0026#39;请输入身高，单位是米\u0026#39;)); var weight = parseFloat(prompt(\u0026#39;请输入体重，单位是公斤\u0026#39;)); //第二步，计算BMI指数 var BMI = weight / Math.pow(height, 2); //第三步，if语句来判断。注意跳楼现象 if (BMI \u0026lt; 18.5) { alert(\u0026#39;偏瘦\u0026#39;); } else if (BMI \u0026lt; 25) { alert(\u0026#39;正常\u0026#39;); } else if (BMI \u0026lt; 28) { alert(\u0026#39;过重\u0026#39;); } else if (BMI \u0026lt;= 32) { alert(\u0026#39;肥胖\u0026#39;); } else { alert(\u0026#39;非常肥胖\u0026#39;); } 写法 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //第一步，输入身高和体重 var height = parseFloat(prompt(\u0026#39;请输入身高，单位是米\u0026#39;)); var weight = parseFloat(prompt(\u0026#39;请输入体重，单位是公斤\u0026#39;)); //第二步，计算BMI指数 var BMI = weight / Math.pow(height, 2); //第三步，if语句来判断。注意跳楼现象 if (BMI \u0026gt; 32) { alert(\u0026#39;非常肥胖\u0026#39;); } else if (BMI \u0026gt;= 28) { alert(\u0026#39;肥胖\u0026#39;); } else if (BMI \u0026gt;= 25) { alert(\u0026#39;过重\u0026#39;); } else if (BMI \u0026gt;= 18.5) { alert(\u0026#39;正常\u0026#39;); } else { alert(\u0026#39;偏瘦\u0026#39;); } if 语句的嵌套 我们通过下面这个例子来引出 if 语句的嵌套。\n1 2 3 4 一个加油站为了鼓励车主多加油，所以加的多有优惠。 92号汽油，每升6元；如果大于等于20升，那么每升5.9； 97号汽油，每升7元；如果大于等于30升，那么每升6.95 编写JS程序，用户输入自己的汽油编号，然后输入自己加多少升，弹出价格。 代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 //第一步，输入 var bianhao = parseInt(prompt(\u0026#39;您想加什么油？填写92或者97\u0026#39;)); var sheng = parseFloat(prompt(\u0026#39;您想加多少升？\u0026#39;)); //第二步，判断 if (bianhao == 92) { //编号是92的时候做的事情 if (sheng \u0026gt;= 20) { var price = sheng * 5.9; } else { var price = sheng * 6; } } else if (bianhao == 97) { //编号是97的时候做的事情 if (sheng \u0026gt;= 30) { var price = sheng * 6.95; } else { var price = sheng * 7; } } else { alert(\u0026#39;不好意思，没有这个编号的汽油！\u0026#39;); } alert(\u0026#39;价格是\u0026#39; + price); switch 语句（条件分支语句） switch 语句也叫条件分支语句。\n语法格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 switch(表达式) { case 值1： 语句体1; break; case 值2： 语句体2; break; ... ... default： 语句体 n+1; break; } 解释：switch 可以理解为“开关、转换” 。case 可以理解为“案例、选项”。\nswitch 语句的执行流程 流程图如下：\n执行流程如下：\n（1）首先，计算出表达式的值，和 case 依次比较，一旦有对应的值，就会执行相应的语句，在执行的过程中，遇到 break 就会结束。\n（2）然后，如果所有的 case 都和表达式的值不匹配，就会执行 default 语句体部分。\nswitch 和 case 后面的值（含代码举例） switch 后面的括号里可以是表达式或者值， 通常是一个变量（通常做法是：先把表达式或者值存放到变量中）。\nJS 是属于弱类型语言，case 后面的值1、值2可以是 'a'、6、true 等任意数据类型的值，也可以是表达式。注意，在这里，字符串'6'和 数字 6 是不一样的。\n举例1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let msg = \u0026#39;notice\u0026#39;; switch (msg) { case \u0026#39;notice\u0026#39;: console.log(\u0026#39;提示\u0026#39;); break; case \u0026#39;warning\u0026#39;: console.log(\u0026#39;警告\u0026#39;); break; case \u0026#39;error\u0026#39;: console.log(\u0026#39;错误\u0026#39;); break; default: console.log(\u0026#39;默认文案\u0026#39;); break; } 举例2：（case 后面的是表达式）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 let age = 28; switch (true) { case age \u0026lt; 18: console.log(\u0026#39;未成年人\u0026#39;); break; case age \u0026gt;= 18 \u0026amp;\u0026amp; age \u0026lt;= 65: console.log(\u0026#39;还能干活儿\u0026#39;); break; case age \u0026gt; 65: console.log(\u0026#39;该退休了\u0026#39;); break; default: console.log(\u0026#39;默认文案\u0026#39;); break; } 代码解释：由于 switch 里的值是 true，所以，在众多的 case 语句中，会去匹配第一个符合 case true的语句，然后命中这条语句。\nswitch 语句的结束条件【非常重要】 情况 a：遇到 break 就结束，而不是遇到 default 就结束。（因为 break 在此处的作用就是退出 switch 语句）\n情况 b：执行到程序的末尾就结束。\n我们来看下面的两个例子就明白了。\ncase 穿透 switch 语句中的break可以省略，但一般不建议（对于新手而言）。否则结果可能不是你想要的，会出现一个现象：case 穿透。\n当然，如果你能利用好 case 穿透，会让代码写得十分优雅。\n举例 1：（case 穿透的情况）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 var num = 4; //switch判断语句 switch (num) { case 1: console.log(\u0026#39;星期一\u0026#39;); break; case 2: console.log(\u0026#39;星期二\u0026#39;); break; case 3: console.log(\u0026#39;星期三\u0026#39;); break; case 4: console.log(\u0026#39;星期四\u0026#39;); //break; case 5: console.log(\u0026#39;星期五\u0026#39;); //break; case 6: console.log(\u0026#39;星期六\u0026#39;); break; case 7: console.log(\u0026#39;星期日\u0026#39;); break; default: console.log(\u0026#39;你输入的数据有误\u0026#39;); break; } 上方代码的运行结果，可能会令你感到意外：\n1 2 3 星期四 星期五 星期六 上方代码的解释：因为在 case 4 和 case 5 中都没有 break，那语句走到 case 6 的 break 才会停止。\n举例 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //switch判断语句 var number = 5; switch (number) { default: console.log(\u0026#39;我是defaul语句\u0026#39;); // break; case 2: console.log(\u0026#39;第二个呵呵:\u0026#39; + number); //break; case 3: console.log(\u0026#39;第三个呵呵:\u0026#39; + number); break; case 4: console.log(\u0026#39;第四个呵呵:\u0026#39; + number); break; } 上方代码的运行结果，你也许会意外：\n1 2 3 我是defaul语句 第二个呵呵:5 第三个呵呵:5 上方代码的解释：代码走到 default 时，因为没有遇到 break，所以会继续往下走，直到遇见 break 或者走到程序的末尾。 从这个例子可以看出：switch 语句的结束与 default 的顺序无关。\nswitch 语句的实战举例：替换 if 语句 我们实战开发中，经常需要根据接口的返回码 retCode ，来让前端做不同的展示。\n这种场景是业务开发中经常出现的，请一定要掌握。然而，很多人估计会这么写：\n写法 1（不推荐。这种写法太挫了） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 let retCode = 1003; // 返回码 retCode 的值可能有很多种情况 if (retCode == 0) { alert(\u0026#39;接口联调成功\u0026#39;); } else if (retCode == 101) { alert(\u0026#39;活动不存在\u0026#39;); } else if (retCode == 103) { alert(\u0026#39;活动未开始\u0026#39;); } else if (retCode == 104) { alert(\u0026#39;活动已结束\u0026#39;); } else if (retCode == 1001) { alert(\u0026#39;参数错误\u0026#39;); } else if (retCode == 1002) { alert(\u0026#39;接口频率限制\u0026#39;); } else if (retCode == 1003) { alert(\u0026#39;未登录\u0026#39;); } else if (retCode == 1004) { alert(\u0026#39;（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试\u0026#39;); } else { // 其他异常返回码 alert(\u0026#39;系统君失联了，请稍候再试\u0026#39;); } 如果你是按照上面的 if else的方式来写各种条件判断，说明你的代码水平太初级了，会被人喷的，千万不要这么写。这种写法，容易导致嵌套太深，可读性很差。\n那要怎么改进呢？继续往下看。\n写法 2（推荐。通过 return 的方式，将上面的写法进行改进） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 let retCode = 1003; // 返回码 retCode 的值可能有很多种情况 handleRetCode(retCode); // 方法：根据接口不同的返回码，处理前端不同的显示状态 function handleRetCode(retCode) { if (retCode == 0) { alert(\u0026#39;接口联调成功\u0026#39;); return; } if (retCode == 101) { alert(\u0026#39;活动不存在\u0026#39;); return; } if (retCode == 103) { alert(\u0026#39;活动未开始\u0026#39;); return; } if (retCode == 104) { alert(\u0026#39;活动已结束\u0026#39;); return; } if (retCode == 1001) { alert(\u0026#39;参数错误\u0026#39;); return; } if (retCode == 1002) { alert(\u0026#39;接口频率限制\u0026#39;); return; } if (retCode == 1003) { alert(\u0026#39;未登录\u0026#39;); return; } if (retCode == 1004) { alert(\u0026#39;（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试\u0026#39;); return; } // 其他异常返回码 alert(\u0026#39;系统君失联了，请稍候再试\u0026#39;); return; } 上面的写法 2，是比较推荐的写法：直接通过 return 的方式，让 function 里的代码不再继续往下走，这就达到目的了。对了，因为要用到 return ，所以整段代码是封装到一个 function 里的。\n如果你以后看到有前端小白采用的是写法 1，请一定要把写法 2传授给他：不需要那么多的 if else，直接用 return 返回就行了。\n写法 3（推荐。将 if else 改为 switch） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 let retCode = 1003; // 返回码 retCode 的值可能有很多种情况 switch (retCode) { case 0: alert(\u0026#39;接口联调成功\u0026#39;); break; case 101: alert(\u0026#39;活动不存在\u0026#39;); break; case 103: alert(\u0026#39;活动未开始\u0026#39;); break; case 104: alert(\u0026#39;活动已结束\u0026#39;); break; case 1001: alert(\u0026#39;参数错误\u0026#39;); break; case 1002: alert(\u0026#39;接口频率限制\u0026#39;); break; case 1003: alert(\u0026#39;未登录\u0026#39;); break; case 1004: alert(\u0026#39;（风控用户）提示 活动太火爆啦~军万马都在挤，请稍后再试\u0026#39;); break; // 其他异常返回码 default: alert(\u0026#39;系统君失联了，请稍候再试\u0026#39;); break; } 在实战开发中，方式 3 是非常推荐的写法，甚至比方式 2 还要好。我们尽量不要写太多的 if 语句，避免代码嵌套过深。\nswitch 语句的优雅写法：适时地去掉 break 我们先来看看下面这段代码：（不推荐）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 let day = 2; switch (day) { case 1: console.log(\u0026#39;work\u0026#39;); break; case 2: console.log(\u0026#39;work\u0026#39;); break; case 3: console.log(\u0026#39;work\u0026#39;); break; case 4: console.log(\u0026#39;work\u0026#39;); break; case 5: console.log(\u0026#39;work\u0026#39;); break; case 6: console.log(\u0026#39;relax\u0026#39;); break; case 7: console.log(\u0026#39;relax\u0026#39;); break; default: break; } 上面的代码，咋一看，好像没啥毛病。但你有没有发现，重复代码太多了？\n实战开发中，凡是有重复的地方，我们都必须要想办法简化。写代码就是在不断重构的过程。\n上面的代码，可以改进如下：（推荐，非常优雅）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 let day = 2; switch (day) { case 1: case 2: case 3: case 4: case 5: console.log(\u0026#39;work\u0026#39;); break; // 在这里放一个 break case 6: case 7: console.log(\u0026#39;relax\u0026#39;); break; // 在这里放一个 break default: break; } } 你没看错，就是上面的这种写法，能达到同样的效果，非常优雅。\n小白可能认为这样的写法可读性不强，所以说他是小白。我可以明确告诉你，改进后的这种写法，才是最优雅的、最简洁、可读性最好的。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/09-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84if%E5%92%8Cswitch/","summary":"代码块 用{}包围起来的代码，就是代码块。 在 ES5 语法中，代码块，只具有分组的作用，没有其他的用途。代码块中的内容，在外部是完全可见的。举例： 1 2","title":"09-流程控制语句：选择结构（if和switch）"},{"content":"本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。\n我在上一篇文章《前端AntD框架的upload组件上传图片时遇到的一些坑》中讲到：AntD 的 upload 组件有很多坑，引起了很多人的关注。折腾过的人，自然明白其中的苦楚。\n今天这篇文章，我们继续来研究 AntD 的 upload 组件的另一个坑。\n备注：本文写于2020-06-11，使用的 antd 版本是 3.13.6。\n使用 AntD 的 upload 组件做图片的上传，效果演示 因为需要上传多张图片，所以采用的是照片墙的形式。上传成功后的界面如下：\n（1）上传中：\n（2）上传成功：\n（3）图片预览：\n代码实现 首先，你需要让后台同学提供好图片上传的接口。上一篇文章中，我们是把接口调用直接写在了 \u0026lt;Upload\u0026gt; 标签的 action 属性当中。但如果你在调接口的时候，动作很复杂（比如根据业务要求，需要连续调两个接口才能上传图片，或者在调接口时还要做其他的事情），这个 action 方法就无法满足需求了。那该怎么做呢？\n好在 AntD 的 upload 组件给我们提供了 customRequest这个方法：\n关于customRequest 这个方法， AntD 官方并没有给出示例，他们只是在 GitHub 上给出了这样一个简短的介绍：\n但这个方法怎么用呢？用的时候，会遇到什么问题呢？AntD 官方没有说。我在网上搜了半天，也没看到比较完整的、切实可行的 Demo。我天朝地大物博，网络资料浩如烟海，AntD 可是口口声声被人们号称是天朝最好用的管理后台的样式框架。可如今，却面临这样的局面。我看着你们，满怀羡慕。\n既然如此，那我就自己研究吧。折腾了一天，总算是把 customRequest 的坑踩得差不多了。\n啥也不说了，直接上代码。\n采用 AntD框架的 upload 组件的 customRequest 方法，自定义上传行为。核心代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 import React, { PureComponent } from \u0026#39;react\u0026#39;; import { Button, Card, Form, message, Upload, Icon, Modal, Row, Col } from \u0026#39;antd\u0026#39;; import { connect } from \u0026#39;dva\u0026#39;; import { queryMyData, submitData } from \u0026#39;../api\u0026#39;; import { uploadImage } from \u0026#39;../../utils/wq.img.upload\u0026#39;; import styles from \u0026#39;../../utils/form.less\u0026#39;; const FormItem = Form.Item; @Form.create() export default class PicturesWall extends PureComponent { constructor(props) { super(props); const { id } = this.props.match.params; this.state = { id, img: undefined, // 从接口拿到的图片字段 imgList: [], // 展示在 antd图片组件上的数据 previewVisible: false, previewImage: \u0026#39;\u0026#39;, }; } componentDidMount() { const { id } = this.state; id \u0026amp;\u0026amp; this.queryData(); } // 调接口，查询已有的数据 queryData() { const { id } = this.state; queryMyData({ id, }) .then(({ ret, data }) =\u0026gt; { if (ret == 0 \u0026amp;\u0026amp; data \u0026amp;\u0026amp; data.list \u0026amp;\u0026amp; data.list.length) { const item = data.list[0]; const img = data.img; const imgList = item.img ? [ { uid: \u0026#39;1\u0026#39;, // 注意，这个uid一定不能少，否则展示失败 name: \u0026#39;hehe.png\u0026#39;, status: \u0026#39;done\u0026#39;, url: img, }, ] : []; this.setState({ img, imgList, }); } else { return Promise.reject(); } }) .catch(() =\u0026gt; { message.error(\u0026#39;查询出错，请重试\u0026#39;); }); } handleCancel = () =\u0026gt; this.setState({ previewVisible: false }); // 方法：图片预览 handlePreview = (file) =\u0026gt; { console.log(\u0026#39;smyhvae handlePreview:\u0026#39; + JSON.stringify(file)); this.setState({ previewImage: file.url || file.thumbUrl, previewVisible: true, }); }; // 参考链接：https://www.jianshu.com/p/f356f050b3c9 handleBeforeUpload = (file) =\u0026gt; { console.log(\u0026#39;smyhvae handleBeforeUpload file:\u0026#39; + JSON.stringify(file)); console.log(\u0026#39;smyhvae handleBeforeUpload file.file:\u0026#39; + JSON.stringify(file.file)); console.log(\u0026#39;smyhvae handleBeforeUpload file type:\u0026#39; + JSON.stringify(file.type)); //限制图片 格式、size、分辨率 const isJPG = file.type === \u0026#39;image/jpeg\u0026#39;; const isJPEG = file.type === \u0026#39;image/jpeg\u0026#39;; const isGIF = file.type === \u0026#39;image/gif\u0026#39;; const isPNG = file.type === \u0026#39;image/png\u0026#39;; const isLt2M = file.size / 1024 / 1024 \u0026lt; 1; if (!(isJPG || isJPEG || isPNG)) { Modal.error({ title: \u0026#39;只能上传JPG、JPEG、PNG格式的图片~\u0026#39;, }); } else if (!isLt2M) { Modal.error({ title: \u0026#39;图片超过1M限制，不允许上传~\u0026#39;, }); } return (isJPG || isJPEG || isPNG) \u0026amp;\u0026amp; isLt2M; }; // checkImageWH 返回一个promise 检测通过返回resolve 失败返回reject阻止图片上传 checkImageWH(file) { return new Promise(function (resolve, reject) { let filereader = new FileReader(); filereader.onload = (e) =\u0026gt; { let src = e.target.result; const image = new Image(); image.onload = function () { // 获取图片的宽高 file.width = this.width; file.height = this.height; resolve(); }; image.onerror = reject; image.src = src; }; filereader.readAsDataURL(file); }); } // 图片上传 doImgUpload = (options) =\u0026gt; { const { onSuccess, onError, file, onProgress } = options; // start：进度条相关 // 伪装成 handleChange里面的图片上传状态 const imgItem = { uid: \u0026#39;1\u0026#39;, // 注意，这个uid一定不能少，否则上传失败 name: \u0026#39;hehe.png\u0026#39;, status: \u0026#39;uploading\u0026#39;, url: \u0026#39;\u0026#39;, percent: 99, // 注意不要写100。100表示上传完成 }; this.setState({ imgList: [imgItem], }); // 更新 imgList // end：进度条相关 const reader = new FileReader(); reader.readAsDataURL(file); // 读取图片文件 reader.onload = (file) =\u0026gt; { const params = { myBase64: file.target.result, // 把 本地图片的base64编码传给后台，调接口，生成图片的url }; // 上传图片的base64编码，调接口后，返回 imageId uploadImage(params) .then((res) =\u0026gt; { console.log(\u0026#39;smyhvae doImgUpload:\u0026#39; + JSON.stringify(res)); console.log(\u0026#39;smyhvae 图片上传成功：\u0026#39; + res.imageUrl); const imgItem = { uid: \u0026#39;1\u0026#39;, // 注意，这个uid一定不能少，否则上传失败 name: \u0026#39;hehe.png\u0026#39;, status: \u0026#39;done\u0026#39;, url: res.imageUrl, // url 是展示在页面上的绝对链接 imgUrl: res.imageUrl, // imgUrl 是存到 db 里的相对链接 // response: \u0026#39;{\u0026#34;status\u0026#34;: \u0026#34;success\u0026#34;}\u0026#39;, }; this.setState({ imgList: [imgItem], }); // 更新 imgList }) .catch((e) =\u0026gt; { console.log(\u0026#39;smyhvae 图片上传失败:\u0026#39; + JSON.stringify(e || \u0026#39;\u0026#39;)); message.error(\u0026#39;图片上传失败，请重试\u0026#39;); }); }; }; handleChange = ({ file, fileList }) =\u0026gt; { console.log(\u0026#39;smyhvae handleChange file:\u0026#39; + JSON.stringify(file)); console.log(\u0026#39;smyhvae handleChange fileList:\u0026#39; + JSON.stringify(fileList)); if (file.status == \u0026#39;removed\u0026#39;) { this.setState({ imgList: [], }); } }; submit = (e) =\u0026gt; { e.preventDefault(); this.props.form.validateFields((err, fieldsValue) =\u0026gt; { if (err) { return; } const { id, imgList } = this.state; const tempImgList = imgList.filter((item) =\u0026gt; item.status == \u0026#39;done\u0026#39;); // 筛选出 status = done 的图片 const imgArr = []; tempImgList.forEach((item) =\u0026gt; { imgArr.push(item.imgUrl); // imgArr.push(item.url); }); submitData({ id, img: imgArr[0] || \u0026#39;\u0026#39;, // 1、暂时只传一张图片给后台。如果传多张图片，那么，upload组件需要进一步完善，比较麻烦，以后有需求再优化。2、如果图片字段是选填，那就用空字符串兜底 }) .then((res) =\u0026gt; { if (res.ret == 0) { message.success(`${id ? \u0026#39;修改\u0026#39; : \u0026#39;新增\u0026#39;}成功，自动跳转中...`); } else if (res.ret == 201 || res.ret == 202 || res.ret == 203 || res.ret == 6) { return Promise.reject(res.msg); } else { return Promise.reject(); } }) .catch((e) =\u0026gt; { message.error(e || \u0026#39;提交失败，请重试\u0026#39;); }); }); }; render() { const { id, imgList } = this.state; console.log(\u0026#39;smyhvae render imgList:\u0026#39; + JSON.stringify(imgList)); const { getFieldDecorator } = this.props.form; const formItemLayout = { labelCol: { span: 3 }, wrapperCol: { span: 10 }, }; const buttonItemLayout = { wrapperCol: { span: 10, offset: 3 }, }; const uploadButton = ( \u0026lt;div\u0026gt; \u0026lt;Icon type=\u0026#34;plus\u0026#34; /\u0026gt; \u0026lt;div className=\u0026#34;ant-upload-text\u0026#34;\u0026gt;Upload\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); return ( \u0026lt;Card title={id ? \u0026#39;修改信息\u0026#39; : \u0026#39;新增信息\u0026#39;}\u0026gt; \u0026lt;Form onSubmit={this.submit} layout=\u0026#34;horizontal\u0026#34;\u0026gt; {/* 新建图片、编辑图片 */} \u0026lt;FormItem label=\u0026#34;图片\u0026#34; {...formItemLayout}\u0026gt; {getFieldDecorator(\u0026#39;img\u0026#39;, { rules: [{ required: false, message: \u0026#39;请上传图片\u0026#39; }], })( \u0026lt;Upload action=\u0026#34;2\u0026#34; customRequest={this.doImgUpload} listType=\u0026#34;picture-card\u0026#34; fileList={imgList} onPreview={this.handlePreview} beforeUpload={this.handleBeforeUpload} onChange={this.handleChange} \u0026gt; {imgList.length \u0026gt;= 1 ? null : uploadButton} \u0026lt;/Upload\u0026gt; )} \u0026lt;/FormItem\u0026gt; \u0026lt;Row\u0026gt; \u0026lt;Col span={3} /\u0026gt; \u0026lt;Col span={18} className={styles.graytext}\u0026gt; 注：图片支持JPG、JPEG、PNG格式，小于1M，最多上传1张 \u0026lt;/Col\u0026gt; \u0026lt;/Row\u0026gt; \u0026lt;FormItem {...buttonItemLayout}\u0026gt; \u0026lt;Button type=\u0026#34;primary\u0026#34; htmlType=\u0026#34;submit\u0026#34;\u0026gt; 提交 \u0026lt;/Button\u0026gt; \u0026lt;/FormItem\u0026gt; \u0026lt;/Form\u0026gt; {/* 图片点开预览 */} \u0026lt;Modal visible={this.state.previewVisible} footer={null} onCancel={this.handleCancel}\u0026gt; \u0026lt;img alt=\u0026#34;example\u0026#34; style={{ width: \u0026#39;100%\u0026#39; }} src={this.state.previewImage} /\u0026gt; \u0026lt;/Modal\u0026gt; \u0026lt;/Card\u0026gt; ); } } 参考链接 注意file的格式：https://www.lmonkey.com/t/oREQA5XE1\nDemo在线演示：\nhttps://stackoverflow.com/questions/58128062/using-customrequest-in-ant-design-file-upload\nhttps://stackblitz.com/edit/so-58128062-upload-progress\nfileList 格式在线演示：\nhttps://stackoverflow.com/questions/51514757/action-function-is-required-with-antd-upload-control-but-i-dont-need-it\nhttps://codesandbox.io/s/rl7ooo544q\nant design Upload组件的使用总结：https://www.jianshu.com/p/0aa4612af987\nantd上传功能的CustomRequest：https://mlog.club/article/3832743\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/10-antd%E6%A1%86%E6%9E%B6%E7%9A%84upload%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%97%B6%E4%BD%BF%E7%94%A8customrequest%E6%96%B9%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%8A%E4%BC%A0%E8%A1%8C%E4%B8%BA/","summary":"本次做后台管理系统，采用的是 AntD 框架。涉及到图片的上传，用的是AntD的 upload 组件。 我在上一篇文章《前端AntD框架的upload组件上传图片时遇","title":"10-AntD框架的upload组件上传图片时使用customRequest方法自定义上传行为"},{"content":"前言：异步和回调 异步 JavaScript 的执行环境是单线程。\n所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，也就是一次只能完成一项任务，这个任务执行完后才能执行下一个，它会「阻塞」其他任务。这个任务可称为主线程。\n异步模式可以一起执行多个任务。常见的异步模式有以下几种：\n定时器\n接口调用\n事件函数\n今天这篇文章，我们重点讲一下接口调用。接口调用里，重点讲一下Promise。\n接口调用的方式 js 中常见的接口调用方式，有以下几种：\n原生 ajax、基于 jQuery 的 ajax Promise Fetch axios 多次异步调用的顺序 多次异步调用的结果，顺序可能不同步。\n异步调用的结果如果存在依赖，则需要通过回调函数进行嵌套。\n回调地狱的举例 假设买菜、做饭、洗碗、倒厨余垃圾都是异步的。\n但真实的场景中，实际的操作流程是：买菜成功之后，才能开始做饭。做饭成功后，才能开始洗碗。洗碗结束后， 再倒厨余垃圾。这里的一系列动作就涉及到了多层嵌套调用，也就是回调地狱。\n在 ES5 中，当进行多层嵌套回调时，会导致代码层次过多，很难进行后续维护和二次开发；而且会导致回调地狱的问题。ES6 中的 Promise 就可以解决这两个问题。\nPromise 概述 为什么需要 Promise？ 如上一段所述，Javascript 是⼀⻔单线程语⾔。早期我们解决异步场景时，⼤部分情况都是通过回调函数来进⾏。\n例如在浏览器中发送 ajax 请求，就是常⻅的⼀个异步场景，发送请求后，需要等待一段时间，等服务端响应之后我们才能拿到结果。如果我们希望在异步结束之后执⾏某个操作，就只能通过回调函数这样的⽅式进⾏操作。\n1 2 3 4 5 6 7 8 9 var dynamicFunc = function (callback) { setTimeout(function () { callback(); }, 1000); }; dynamicFunc(function () { console.log(\u0026#39;qian gu\u0026#39;); }); 例如上⾯这个例⼦，dynamicFunc 就是⼀个异步函数，⾥⾯ setTimeout 会在 1s 之后调⽤传⼊的 callback 函数。按照上⾯的调⽤⽅式，最终 1s 之后，会打印 qian gu 这个结果。\n同样的，如果后续还有内容需要在异步函数结束时输出，就需要多个异步函数进⾏嵌套，⾮常不利于后续的维护，而且会导致回调地狱的问题：\n1 2 3 4 5 6 setTimeout(function () { console.log(\u0026#39;qiangu1\u0026#39;); setTimeout(function () { console.log(\u0026#39;qiangu2\u0026#39;); }, 2000); }, 1000); 为了能使回调函数以更优雅的⽅式进⾏调⽤，在 ES6 语法中，新增了⼀个名为 Promise 的新规范。\nPromise 的介绍和优点 ES6 中的 Promise 是异步编程的一种方案。从语法上讲，Promise 是一个对象，它可以获取异步操作的消息。\nPromise 对象, 可以用同步的表现形式来书写异步代码（也就是说，代码看起来是同步的，但本质上的运行过程是异步的）。使用 Promise 主要有以下好处：\n可以很好地解决回调地狱的问题（避免了层层嵌套的回调函数）。\n语法非常简洁、可读性强，便于后期维护。Promise 对象提供了简洁的 API，使得控制异步操作更加容易。\nPromise 基础 Promise 的基本用法 （1）通过 new Promise() 构造出一个 Promise 实例。Promise 的构造函数中传入一个参数，这个参数是一个函数，该函数用于处理异步任务。\n（2）函数中传入两个参数：resolve 和 reject，分别表示异步执行成功后的回调函数和异步执行失败后的回调函数。代表着我们需要改变当前实例的状态到已完成或是已拒绝。\n（3）通过 promise.then() 处理返回结果（这里的 promise 指的是 Promise 实例）。\n接下来，我们来具体看看， promise 的代码是怎么写的。\nPromise 处理异步任务的过程 通过 Promise 处理异步任务的典型写法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 第一步：model层的接口封装 function promiseA() { return new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如 ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } // 第二步：业务层的接口调用。这里的 data 就是 从 resolve 和 reject 传过来的，也就是从接口拿到的数据 promiseA() .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(data); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 上方代码中，当从接口返回的数据data.retCode的值（接口返回码）不同时，可能会走 resolve，也可能会走 reject，这个由你自己的业务决定。\n上面的写法中，是将 promise 实例定义成了一个函数 PromiseA。我们也可以将 promise 实例定义成一个变量 promiseB，达到的效果是一模一样的。写法如下：（写法上略有区别）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 第一步：model层的接口封装 const promiseB = new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); // 第二步：业务层的接口调用。这里的 data 就是 从 resolve 和 reject 传过来的，也就是从接口拿到的数据 promiseB .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(data); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 捕获 reject 异常状态的两种写法 我们有两种写法可以捕获并处理 reject 异常状态。上一小段中，用的就是其中一种写法。\n这两种写法的代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 // 第一步：model层的接口封装 function promiseA() { return new Promise((resolve, reject) =\u0026gt; { // 这里做异步任务（比如 ajax 请求接口。这里暂时用定时器代替） setTimeout(() =\u0026gt; { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据，返回码 retCode 是动态数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } const onResolve = function (value) { console.log(value); }; const onReject = function (e) { console.log(e); }; // 写法1：通过 catch 方法捕获 状态变为已拒绝时的 promise promiseA().then(onResolve).catch(onReject); // 写法2：then 可以传两个参数，第⼀个参数为 resolve 后执⾏，第⼆个参数为 reject 后执⾏ promiseA().then(onResolve, onReject); // 【错误写法】写法3：通过 try catch 捕获 状态变为已拒绝时的 promise // 这种写法是错误的，因为 try catch只能捕获同步代码里的异常，而 promise.reject() 是异步代码。 try { promiseA().then(onResolve); } catch (e) { // 语法上，catch必须要传入一个参数，否则报错 onReject(e); } 需要注意的是：\n（1）上面的写法 3 是错误的。运行之后，控制台会报如下错误：\n解释如下：\ntry-catch 主要用于捕获异常，注意，这里的异常是指同步函数的异常。如果 try 里面的异步方法出现了异常，此时 catch 是无法捕获到异常的。\n原因是：当异步函数抛出异常时，对于宏任务而言，执行函数时已经将该函数推入栈，此时并不在 try-catch 所在的栈，所以 try-catch 并不能捕获到错误。对于微任务而言（比如 promise）promise 的构造函数的异常只能被自带的 reject 也就是.catch 函数捕获到。\n（2）写法1中，promiseA().then().catch()和promiseA().catch().then()区别在于：前者可以捕获到 then 里面的异常，后者不可以。\n小结 1、promise 有三种状态：等待中、成功、失败。等待中状态可以更改为成功或失败，已经更改过状态后⽆法继续更改（例如从失败改为成功）。\n2、promise 实例中需要传⼊⼀个函数，他接受两个函数参数，执⾏第⼀个参数之后就会改变当前 promise 为「成功」状态，执⾏第⼆个参数之后就会变为「失败」状态。\n3、通过 .then ⽅法，即可在上⼀个 promise 达到成功时继续执⾏下⼀个函数或 promise。同时通过 resolve 或 reject 时传⼊参数，即可给下⼀个函数或 promise 传⼊初始值。\n4、失败的 promise，后续可以通过 promise 自带的 .catch ⽅法或是 .then ⽅法的第⼆个参数进⾏捕获。\nPromise 规范 Promise 规范解读 Promise 是⼀个拥有 then ⽅法的对象或函数。任何符合 promise 规范的对象或函数都可以成为 Promise。\n关于promise 规范的详细解读，可以看下面这个链接：\nPromises/A+ 规范：https://promisesaplus.com/ promise 对象的 3 个状态 初始化（等待中）：pending\n成功：fulfilled\n失败：rejected\n（1）当 new Promise()执行之后，promise 对象的状态会被初始化为pending，这个状态是初始化状态。new Promise()这行代码，括号里的内容是同步执行的。括号里定义一个 function，function 有两个参数：resolve 和 reject。如下：\n如果请求成功了，则执行 resolve()，此时，promise 的状态会被自动修改为 fulfilled。\n如果请求失败了，则执行 reject()，此时，promise 的状态会被自动修改为 rejected\n（2）promise.then()方法，括号里面有两个参数，分别代表两个函数 function1 和 function2：\n如果 promise 的状态为 fulfilled（意思是：如果请求成功），则执行 function1 里的内容\n如果 promise 的状态为 rejected（意思是，如果请求失败），则执行 function2 里的内容\n另外，resolve()和 reject()这两个方法，是可以给 promise.then()传递参数的。\n完整代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 let promise = new Promise((resolve, reject) =\u0026gt; { //进来之后，状态为pending console.log(\u0026#39;111\u0026#39;); //这行代码是同步的 //开始执行异步操作（这里开始，写异步的代码，比如ajax请求 or 开启定时器） if (异步的ajax请求成功) { console.log(\u0026#39;333\u0026#39;); resolve(\u0026#39;haha\u0026#39;); //如果请求成功了，请写resolve()，此时，promise的状态会被自动修改为fulfilled } else { reject(\u0026#39;555\u0026#39;); //如果请求失败了，请写reject()，此时，promise的状态会被自动修改为rejected } }); console.log(\u0026#39;222\u0026#39;); //调用promise的then() promise.then( (successMsg) =\u0026gt; { //如果promise的状态为fulfilled，则执行这里的代码 console.log(successMsg, \u0026#39;成功了\u0026#39;); }, (errorMsg) =\u0026gt; { //如果promise的状态为rejected，则执行这里的代码 console.log(errorMsg, \u0026#39;失败了\u0026#39;); } ); 如何封装异步操作为 promise Promise 封装异步任务 传统写法：\n写法 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 定义一个异步的延迟函数：异步函数结束1秒之后，再执行cb回调函数 function fun1(cb) { setTimeout(function () { console.log(\u0026#39;即将执行cb回调函数\u0026#39;); cb(); }, 1000); } // 先执行异步函数 fun1，再执行回调函数 myCallback fun1(myCallback); // 定义回调函数 function myCallback() { console.log(\u0026#39;我是延迟执行的cb回调函数\u0026#39;); } 写法 2：（精简版，更常见）\n1 2 3 4 5 6 7 8 9 // 定义一个异步的延迟函数：异步函数结束1秒之后，再执行cb回调函数 function fun1(cb) { setTimeout(cb, 1000); } // 先执行异步函数fun1，再执行回调函数 fun1(function () { console.log(\u0026#39;我是延迟执行的cb回调函数\u0026#39;); }); 上⾯的例⼦就是最传统的写法，在异步结束后通过传入回调函数的方式执⾏函数。\n学习 Promise 之后，我们可以将这个异步函数封装为 Promise，如下。\nPromise 写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function fun2() { return new Promise((resolve) =\u0026gt; { setTimeout(resolve, 1000); }); } /* 【重要】上面的 fun2 也可以写成： function fun2() { return new Promise((resolve) =\u0026gt; { setTimeout(() =\u0026gt; { resolve(); }, 1000); }); } */ // 先执行异步函数fun1，再执行回调函数 fun2().then(() =\u0026gt; { console.log(\u0026#39;我是延迟执行的回调函数\u0026#39;); }); Promise 封装 Ajax 请求 传统写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 定义 ajax 请求：传入回调函数 success 和 fail function ajax(url, success, fail) { var client = new XMLHttpRequest(); client.open(\u0026#39;GET\u0026#39;, url); client.onreadystatechange = function () { if (this.readyState !== 4) { return; } if (this.status === 200) { success(this.response); } else { fail(new Error(this.statusText)); } }; client.send(); } // 执行 ajax 请求 ajax( \u0026#39;/ajax.json\u0026#39;, function () { console.log(\u0026#39;qianguyihao 成功\u0026#39;); }, function () { console.log(\u0026#39;失败\u0026#39;); } ); 上面的传统写法里，定义和执行 ajax 时需要传⼊ success 和 fail 这两个回调函数，进而执行回调函数。\n有了 Promise 之后，我们不需要传入回调函数，而是：\n先将 promise 实例化；\n然后在原来执行回调函数的地方，改为执行对应的改变 promise 状态的函数；\n并通过 then \u0026hellip; catch 或者 then \u0026hellip;then 等写法，实现链式调用，提高代码可读性。\n和传统写法相比，promise 在写法上的大致区别是：定义异步函数的时候，将 callback 改为 resolve 和 reject，待状态改变之后，我们在外面控制具体执行哪些函数。\nPromise 写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const request = require(\u0026#39;request\u0026#39;); // Promise 定义接口 function request1() { return new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, (response) =\u0026gt; { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); } request1() .then((res1) =\u0026gt; { // 接口1请求成功后，打印接口1的返回结果 console.log(res1); return request2(); }) .catch((e) =\u0026gt; { // 从 reject 获取异常结果 console.log(e); }); 总结 了解这些内容之后， 你已经对 Promise 有了基本了解。下一篇文章，我们来讲一讲 Promise在实战开发的常见用法。\n参考链接 当面试官问你 Promise 的时候，他究竟想听到什么？\n手写一个 Promise/A+,完美通过官方 872 个测试用例\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/10-promise%E5%85%A5%E9%97%A8%E8%AF%A6%E8%A7%A3/","summary":"前言：异步和回调 异步 JavaScript 的执行环境是单线程。 所谓单线程，是指 JS 引擎中负责解释和执行 JavaScript 代码的线程只有一个，也就是一次只能完成一项任务，这个任务执","title":"10-Promise入门详解"},{"content":"搭建开发环境 官方文档：https://reactnative.cn/docs/getting-started.html\n安装Node、homebrew、Watchman 安装 homebrew：\n安装 watchman：\n1 brew install watchman Watchman则是由 Facebook 提供的监视文件系统变更的工具。安装此工具可以提高开发时的性能（packager 可以快速捕捉文件的变化从而实现实时刷新）。\n安装 React Native 的命令行工具（react-native-cli） 安装 react-native-cli：\n1 npm install -g react-native-cli React Native 的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。\n创建新项目 1 react-native init MyApp --version 0.44.3 编译并运行 React Native 应用 在 ios 模拟器上运行：\n1 react-native run-ios 调试 官网文档：https://reactnative.cn/docs/debugging.html\n访问 App 内的开发菜单 如果是在 iOS 模拟器中运行，还可以按下Command + D快捷键，Android 模拟器对应的则是Command⌘ + M（windows 上可能是 F1 或者 F2），或是直接在命令行中运行adb shell input keyevent 82来发送菜单键命令。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/10-react-navive%E5%88%9D%E8%AF%86/","summary":"搭建开发环境 官方文档：https://reactnative.cn/docs/getting-started.html 安装Node、home","title":"10-React Navive初识"},{"content":"前言 循环语句：通过循环语句可以反复的执行一段代码多次。\nfor 循环 for 循环的语法 语法：\n1 2 3 for(①初始化表达式; ②条件表达式; ④更新表达式){ ③语句... } 执行流程：\n1 2 3 4 5 6 7 ①执行初始化表达式，初始化变量（初始化表达式只会执行一次） ②执行条件表达式，判断是否执行循环： 如果为true，则执行循环③ 如果为false，终止循环 ④执行更新表达式，更新表达式执行完毕继续重复② for 循环举例：\n1 2 3 for (var i = 1; i \u0026lt;= 100; i++) { console.log(i); } 上方代码的解释：\nfor 循环举例 1 2 3 for (var i = 1; i \u0026lt; 13; i = i + 4) { console.log(i); } 上方代码的遍历步骤：\n1 2 3 4 5 6 7 8 9 10 11 12 13 程序一运行，将执行var i = 1;这条语句， 所以i的值是1。 然后程序会验证一下i \u0026lt; 13是否满足，1\u0026lt;13是真，所以执行一次循环体（就是大括号里面的语句）。 执行完循环体之后，会执行i=i+4这条语句，所以i的值，是5。 程序会会验证一下i \u0026lt; 13是否满足，5\u0026lt;13是真，所以执行一次循环体（就是大括号里面的语句）。 执行完循环体之后，会执行i=i+4这条语句，所以i的值，是9。 程序会会验证一下i \u0026lt; 13是否满足，9\u0026lt;13是真，所以执行一次循环体（就是大括号里面的语句）。 执行完循环体之后，会执行i=i+4这条语句，所以i的值，是13。 程序会会验证一下i \u0026lt; 13是否满足，13\u0026lt;13是假，所以不执行循环体了，将退出循环。 最终输出输出结果为：1、5、9 接下来做几个题目。\n题目 1：\n1 2 3 4 for (var i = 1; i \u0026lt; 10; i = i + 3) { i = i + 1; console.log(i); } 输出结果：2、6、10\n题目 2：\n1 2 for (var i = 1; i \u0026lt;= 10; i++) {} console.log(i); 输出结果：11\n题目 3：\n1 2 for (var i = 1; i \u0026lt; 7; i = i + 3) {} console.log(i); 输出结果：7\n题目 4：\n1 2 3 for (var i = 1; i \u0026gt; 0; i++) { console.log(i); } 死循环。\nwhile 循环语句 while 循环 语法：\n1 2 3 while(条件表达式){ 语句... } 执行流程：\n1 2 3 4 5 6 7 while语句在执行时，先对条件表达式进行求值判断： 如果值为true，则执行循环体： 循环体执行完毕以后，继续对表达式进行判断 如果为true，则继续执行循环体，以此类推 如果值为false，则终止循环 如果有必要的话，我们可以使用 break 来终止循环。\ndo\u0026hellip;while 循环 语法：\n1 2 3 do{ 语句... }while(条件表达式) 执行流程：\n1 2 3 4 5 do...while语句在执行时，会先执行循环体： 循环体执行完毕以后，在对while后的条件表达式进行判断： 如果结果为true，则继续执行循环体，执行完毕继续判断以此类推 如果结果为false，则终止循环 while 循环和 do\u0026hellip;while 循环的区别 这两个语句的功能类似，不同的是：\nwhile 是先判断后执行，而 do\u0026hellip;while 是先执行后判断。 也就是说，do\u0026hellip;while 可以保证循环体至少执行一次，而 while 不能。\nwhile 循环举例 题目：假如投资的年利率为 5%，试求从 1000 块增长到 5000 块，需要花费多少年？\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;meta /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; /* * 假如投资的年利率为5%，试求从1000块增长到5000块，需要花费多少年 * * 1000 1000*1.05 * 1050 1050*1.05 */ //定义一个变量，表示当前的钱数 var money = 1000; //定义一个计数器 var count = 0; //定义一个while循环来计算每年的钱数 while (money \u0026lt; 5000) { money *= 1.05; //使count自增 count++; } console.log(money); console.log(\u0026#39;一共需要\u0026#39; + count + \u0026#39;年\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n1 2 3 5003.18854203379 一共需要33年 另外，你也可以自己算一下，假如投资的年利率为 5%，从 1000 块增长到 1 万块，需要花费 48 年：\n1 2 10401.269646942128 一共需要48年 break 和 continue 这个知识点非常重要。\nbreak break 可以用来退出 switch 语句或退出整个循环语句（循环语句包括 for 循环、while 循环。不包括 if。if 里不能用 break 和 continue，否则会报错）。\nbreak 会立即终止离它最近的那个循环语句。\n可以为循环语句创建一个 label，来标识当前的循环（格式：label:循环语句）。使用 break 语句时，可以在 break 后跟着一个 label，这样 break 将会结束指定的循环，而不是最近的。\n举例 1：通过 break 终止循环语句\n1 2 3 4 5 6 for (var i = 0; i \u0026lt; 5; i++) { console.log(\u0026#39;i的值:\u0026#39; + i); if (i == 2) { break; // 注意，虽然在 if 里 使用了 break，但这里的 break 是服务于外面的 for 循环。 } } 打印结果：\n1 2 3 i的值:0 i的值:1 i的值:2 举例 2：label 的使用\n1 2 3 4 5 6 7 outer: for (var i = 0; i \u0026lt; 5; i++) { console.log(\u0026#39;外层循环 i 的值：\u0026#39; + i); for (var j = 0; j \u0026lt; 5; j++) { break outer; // 直接跳出outer所在的外层循环（这个outer是我自定义的label） console.log(\u0026#39;内层循环 j 的值:\u0026#39; + j); } } 打印结果：\n1 外层循环 i 的值：0 continue continue 可以用来跳过当次循环，继续下一次循环。\n同样，continue 默认只会离他最近的循环起作用。\n同样，如果需要跳过指定的当次循环，可以使用 label 标签。\n举例：\n1 2 3 4 5 6 for (var i = 0; i \u0026lt; 10; i++) { if (i % 2 == 0) { continue; } console.log(\u0026#39;i的值:\u0026#39; + i); } 打印结果：\n1 2 3 4 5 6 7 8 9 i的值:1 i的值:3 i的值:5 i的值:7 i的值:9 各种练习 练习一：质数相关 题目：在页面中接收一个用户输入的数字，并判断该数是否是质数。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 质数：只能被1和它自身整除的数，1不是质数也不是合数，质数必须是大于1的自然数。 */ var num = prompt(\u0026#39;请输入一个大于1的整数:\u0026#39;); //判断这个值是否合法 if (num \u0026lt;= 1) { alert(\u0026#39;该值不合法！\u0026#39;); } else { //先用flag标志位，来保存当前的数的状态 //默认当前num是质数 var flag = true; //判断num是否是质数 //获取2-num之间的数 for (var i = 2; i \u0026lt; num; i++) { //console.log(i); //判断num是否能被i整除 if (num % i == 0) { //一旦发现：如果num能被i整除，则说明num一定不是质数， //此时：设置flag为false，然后跳出 for 循环 flag = false; break; } } //如果num是质数则输出 if (flag) { alert(num + \u0026#39;是质数！！！\u0026#39;); } else { alert(\u0026#39;这个不是质数\u0026#39;); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 练习二：质数相关 题目：打印 1~100 之间的所有质数\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* * 打印出1-100之间所有的质数 */ //打印2-100之间所有的数 for (var i = 2; i \u0026lt;= 100; i++) { //创建一个布尔值，用来保存结果，默认i是质数 var flag = true; //判断i是否是质数 //获取到2-i之间的所有的数 for (var j = 2; j \u0026lt; i; j++) { //判断i是否能被j整除 if (i % j == 0) { //如果进入判断则证明i不是质数,修改flag值为false flag = false; } } //如果是质数，则打印i的值 if (flag) { console.log(i); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n练习三：99 乘法表 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body { width: 2000px; } span { display: inline-block; width: 80px; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* * 1.打印99乘法表 * 1*1=1 * 1*2=2 2*2=4 * 1*3=3 2*3=6 3*3=9 * 1*4=4 2*4=8 3*4=12 4*4=16 * ....9*9=81 * * 2.打印出1-100之间所有的质数 */ //创建外层循环，用来控制乘法表的高度 for (var i = 1; i \u0026lt;= 9; i++) { //创建一个内层循环来控制图形的宽度 for (var j = 1; j \u0026lt;= i; j++) { document.write(\u0026#39;\u0026lt;span\u0026gt;\u0026#39; + j + \u0026#39;*\u0026#39; + i + \u0026#39;=\u0026#39; + i * j + \u0026#39;\u0026lt;/span\u0026gt;\u0026#39;); } //输出一个换行 document.write(\u0026#39;\u0026lt;br /\u0026gt;\u0026#39;); } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 页面效果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/10-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84for%E5%92%8Cwhile/","summary":"前言 循环语句：通过循环语句可以反复的执行一段代码多次。 for 循环 for 循环的语法 语法： 1 2 3 for(①初始化表达式; ②条件表达式; ④更新表达式){ ③","title":"10-流程控制语句：循环结构（for和while）"},{"content":"链式调用：基于 Promise 处理多次 Ajax 请求【重要】 实际开发中，我们经常需要同时请求多个接口。比如说：在请求完接口1的数据data1之后，需要根据data1的数据，继续请求接口 2，获取data2；然后根据data2的数据，继续请求接口 3。\n换而言之，现在有三个网络请求，请求 2 必须依赖请求 1 的结果，请求 3 必须依赖请求 2 的结果，如果按照往常的写法，会有三层回调，会陷入“回调地狱”。\n这种场景其实就是接口的多层嵌套调用。有了 Promise 之后，我们可以把多层嵌套调用按照线性的方式进行书写，非常优雅。也就是说：Promise 可以把原本的多层嵌套调用改进为链式调用。\n代码举例：（多次 Ajax 请求，链式调用）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; const request = require(\u0026#39;request\u0026#39;); // Promise 封装接口1 const request1 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // Promise 封装接口2 const request2 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.jd.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口2的返回结果 resolve(\u0026#39;request2 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // Promise 封装接口3 const request3 = function () { const promise = new Promise((resolve, reject) =\u0026gt; { request(\u0026#39;https://www.taobao.com\u0026#39;, function (response) { if (response.retCode == 200) { // 这里的 response 是接口3的返回结果 resolve(\u0026#39;request3 success\u0026#39; + response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; // 先发起request1，等resolve后再发起request2；紧接着，等 request2有了 resolve之后，再发起 request3 request1() .then((res1) =\u0026gt; { // 接口1请求成功后，打印接口1的返回结果 console.log(res1); return request2(); }) .then((res2) =\u0026gt; { // 接口2请求成功后，打印接口2的返回结果 console.log(res2); return request3(); }) .then((res3) =\u0026gt; { // 接口3请求成功后，打印接口3的返回结果 console.log(res3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面代码中，then 是可以链式调用的，后面的 then 可以拿到前面 resolve 出来的数据。\n这个举例很经典，需要多看几遍。\nreturn 的函数返回值 return 后面的返回值，有两种情况：\n情况 1：返回 Promise 实例对象。返回的该实例对象会调用下一个 then。\n情况 2：返回普通值。返回的普通值会直接传递给下一个 then，通过 then 参数中函数的参数接收该值。\n我们针对上面这两种情况，详细解释一下。\n情况 1：返回 Promise 实例对象 举例如下：（这个例子，跟上一段 Ajax 链式调用 的例子差不多）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 基于Promise发送Ajax请求 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常情况 resolve(xhr.responseText); } else { // 处理异常情况 reject(\u0026#39;接口请求失败\u0026#39;); } }; xhr.responseType = \u0026#39;json\u0026#39;; // 设置返回的数据类型 xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); // 请求接口 }); } // 发送多个ajax请求并且保证顺序 queryData(\u0026#39;http://localhost:3000/api1\u0026#39;) .then( (data1) =\u0026gt; { console.log(JSON.stringify(data1)); return queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); }, (error1) =\u0026gt; { console.log(error1); } ) .then( (data2) =\u0026gt; { console.log(JSON.stringify(data2)); // 这里的 return，返回的是 Promise 实例对象 return new Promise((resolve, reject) =\u0026gt; { resolve(\u0026#39;qianguyihao\u0026#39;); }); }, (error2) =\u0026gt; { console.log(error2); } ) .then((data3) =\u0026gt; { console.log(data3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 情况 2：返回 普通值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 基于Promise发送Ajax请求 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常情况 resolve(xhr.responseText); } else { // 处理异常情况 reject(\u0026#39;接口请求失败\u0026#39;); } }; xhr.responseType = \u0026#39;json\u0026#39;; // 设置返回的数据类型 xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); // 请求接口 }); } // 发送多个ajax请求并且保证顺序 queryData(\u0026#39;http://localhost:3000/api1\u0026#39;) .then( (data1) =\u0026gt; { console.log(JSON.stringify(data1)); return queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); }, (error1) =\u0026gt; { console.log(error1); } ) .then( (data2) =\u0026gt; { console.log(JSON.stringify(data2)); // 返回普通值 return \u0026#39;qianguyihao\u0026#39;; }, (error2) =\u0026gt; { console.log(error2); } ) /* 既然上方返回的是 普通值，那么，这里的 then 是谁来调用呢？ 答案是：这里会产生一个新的 默认的 promise实例，来调用这里的then，确保可以继续进行链式操作。 */ .then((data3) =\u0026gt; { // 这里的 data3 接收的是 普通值 \u0026#39;qianguyihao\u0026#39; console.log(data3); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Promise 的常用 API：实例方法【重要】 Promise 自带的 API 提供了如下实例方法：\npromise.then()：获取异步任务的正常结果。\npromise.catch()：获取异步任务的异常结果。\npromise.finaly()：异步任务无论成功与否，都会执行。\n代码举例如下。\n写法 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function queryData() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(function () { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } queryData() .then((data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(\u0026#39;接口请求成功时，走这里\u0026#39;); console.log(data); }) .catch((data) =\u0026gt; { // 从 reject 获取异常结果 console.log(\u0026#39;接口请求失败时，走这里\u0026#39;); console.log(data); }) .finally(() =\u0026gt; { console.log(\u0026#39;无论接口请求成功与否，都会走这里\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 写法 2：（和上面的写法 1 等价）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; function queryData() { return new Promise((resolve, reject) =\u0026gt; { setTimeout(function () { var data = { retCode: 0, msg: \u0026#39;qianguyihao\u0026#39; }; // 接口返回的数据 if (data.retCode == 0) { // 接口请求成功时调用 resolve(data); } else { // 接口请求失败时调用 reject({ retCode: -1, msg: \u0026#39;network error\u0026#39; }); } }, 100); }); } queryData() .then( (data) =\u0026gt; { // 从 resolve 获取正常结果 console.log(\u0026#39;接口请求成功时，走这里\u0026#39;); console.log(data); }, (data) =\u0026gt; { // 从 reject 获取异常结果 console.log(\u0026#39;接口请求失败时，走这里\u0026#39;); console.log(data); } ) .finally(() =\u0026gt; { console.log(\u0026#39;无论接口请求成功与否，都会走这里\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意：写法 1 和写法 2 的作用是完全等价的。只不过，写法 2 是把 catch 里面的代码作为 then 里面的第二个参数而已。\nPromise 的常用 API：对象方法【重要】 Promise 自带的 API 提供了如下对象方法：\nPromise.all()：并发处理多个异步任务，所有任务都执行成功，才能得到结果。\nPromise.race(): 并发处理多个异步任务，只要有一个任务执行成功，就能得到结果。\n下面来详细介绍。\nPromise.all() 代码举例 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 封装 Promise 接口调用 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常结果 resolve(xhr.responseText); } else { // 处理异常结果 reject(\u0026#39;服务器错误\u0026#39;); } }; xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); }); } var promise1 = queryData(\u0026#39;http://localhost:3000/api1\u0026#39;); var promise2 = queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); var promise3 = queryData(\u0026#39;http://localhost:3000/api3\u0026#39;); Promise.all([promise1, promise2, promise3]).then((result) =\u0026gt; { console.log(result); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Promise.race() 代码举例 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; /* 封装 Promise 接口调用 */ function queryData(url) { return new Promise((resolve, reject) =\u0026gt; { var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () { if (xhr.readyState != 4) return; if (xhr.readyState == 4 \u0026amp;\u0026amp; xhr.status == 200) { // 处理正常结果 resolve(xhr.responseText); } else { // 处理异常结果 reject(\u0026#39;服务器错误\u0026#39;); } }; xhr.open(\u0026#39;get\u0026#39;, url); xhr.send(null); }); } var promise1 = queryData(\u0026#39;http://localhost:3000/api1\u0026#39;); var promise2 = queryData(\u0026#39;http://localhost:3000/api2\u0026#39;); var promise3 = queryData(\u0026#39;http://localhost:3000/api3\u0026#39;); Promise.race([promise1, promise2, promise3]).then((result) =\u0026gt; { console.log(result); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/11-promise%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%E5%92%8Capi/","summary":"链式调用：基于 Promise 处理多次 Ajax 请求【重要】 实际开发中，我们经常需要同时请求多个接口。比如说：在请求完接口1的数据data1之后，需要根据data","title":"11-Promise的常见用法和API"},{"content":"对象简介 面向对象简介 面向对象：可以创建自定义的类型，很好的支持继承和多态。\n面向对象的特征：封装、继承、多态。\n对象的概念 在 JavaScript 中，对象是一组无序的相关属性和方法的集合。\n对象的作用是：封装信息。比如Student类里可以封装学生的姓名、年龄、成绩等。\n对象具有特征（属性）和行为（方法）。\n为什么需要对象 保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。\n比如，如果要保存一个人的信息，通过数组的方式可以这样保存：\n1 var arr = [\u0026#39;王二\u0026#39;, 35, \u0026#39;男\u0026#39;, \u0026#39;180\u0026#39;]; 上面这种表达方式比较乱。而如果用JS中的对象来表达，结构会更清晰。如下：\n1 2 3 4 5 6 var person = {}; person.name = \u0026#39;王二\u0026#39;; person.age = 35; person.sex = \u0026#39;男\u0026#39;; person.height = \u0026#39;180\u0026#39;; 由此可见，对象里面的属性均是键值对：\n键：相当于属性名。\n值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）。\n两条补充 补充1：对象的属性值可以是任何的数据类型，也可以是个函数：（也称之为方法）\n1 2 3 4 5 6 7 8 var obj = new Object(); obj.sayName = function () { console.log(\u0026#39;smyhvae\u0026#39;); }; console.log(obj.sayName); //没加括号，就是获取方法 console.log(\u0026#39;-----------\u0026#39;); console.log(obj.sayName()); //加了括号，就是调用方法。即：执行函数内容，并执行函数体的内容 打印结果：\n补充2：对象中的属性值，也可以是一个对象。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 //创建对象 obj1 var obj1 = new Object(); obj1.test = undefined; //创建对象 obj2 var obj2 = new Object(); obj2.name = \u0026#34;smyhvae\u0026#34;; //将整个 obj2 对象，设置为 obj1 的属性 obj1.test = obj2; console.log(obj1.test.name); 打印结果为：smyhvae\n对象和数据类型之间的关系 数据类型分类 基本数据类型（值类型）：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。\n引用数据类型（引用类型）：Object 对象。\n基本数据类型：\n基本数据类型的值直接保存在栈内存中，值与值之间是独立存在，修改一个变量不会影响其他的变量。\n对象：\n只要不是那五种基本数据类型，就全都是对象。\n如果使用基本数据类型的数据，我们所创建的变量都是独立的，不能成为一个整体。\n对象属于一种复合的数据类型，在对象中可以保存多个不同数据类型的属性。\n对象是保存到堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间。变量保存的是对象的内存地址（对象的引用）。\n换而言之，对象的值是保存在堆内存中的，而对象的引用（即变量）是保存在栈内存中的。\n如果两个变量保存的是同一个对象引用，当一个通过一个变量修改属性时，另一个也会受到影响。\n上面这句话很重要，我们来看看下面的例子。\n传值和传址的区别 传值 代码举例：\n1 2 3 4 5 let a = 1; let b = a;// 将 a 赋值给 b b = 2; // 修改 b 的值 上方代码中，当我修改 b 的值之后，a 的值并不会发生改变。这个大家都知道。我们继续往下看。\n传址（一个经典的例子） 代码举例：\n1 2 3 4 5 6 7 var obj1 = new Object(); obj1.name = \u0026#34;孙悟空\u0026#34;; var obj2 = obj1; // 将 obj1 的地址赋值给 obj2。从此， obj1 和 obj2 指向了同一个堆内存空间 //修改obj2的name属性 obj2.name = \u0026#34;猪八戒\u0026#34;; 上面的代码中，当我修改 obj2 的name属性后，会发现，obj1 的 name 属性也会被修改。因为obj1和obj2指向的是堆内存中的同一个地址。\n这个例子要尤其注意，实战开发中，很容易忽略。\n对于引用类型的数据，赋值相当于地址拷贝，a、b指向了同一个堆内存地址。所以改了b，a也会变；本质上a、b就是一个东西。\n如果你打算把引用类型 A 的值赋值给 B，让A和B相互不受影响的话，可以通过 Object.assign() 来复制对象。效果如下：\n1 2 3 4 var obj1 = {name: \u0026#39;孙悟空\u0026#39;}; // 复制对象：把 obj1 赋值给 obj3。两者之间互不影响 var obj3 = Object.assign({}, obj1); 对象的分类 1.内置对象：\n由ES标准中定义的对象，在任何的ES的实现中都可以使用\n比如：Object、Math、Date、String、Array、Number、Boolean、Function等。\n2.宿主对象：\n由JS的运行环境提供的对象，目前来讲主要指由浏览器提供的对象。\n比如 BOM DOM。比如console、document。\n3.自定义对象：\n由开发人员自己创建的对象 通过 new 关键字创建出来的对象实例，都是属于对象类型，比如Object、Array、Date等。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/11-%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B/","summary":"对象简介 面向对象简介 面向对象：可以创建自定义的类型，很好的支持继承和多态。 面向对象的特征：封装、继承、多态。 对象的概念 在 JavaScript 中，对象是一组无序","title":"11-对象简介"},{"content":" 备注： async/await 的内容还有待完善。\nasync/await （异步函数）概述 async/await 是在 ES7 中引入的新语法，可以更加方便地进行异步操作。\n本质： Generator 的语法糖。\nasync 的返回值是 Promise 实例对象。\nawait 可以得到异步结果。\n我们在普通的函数前面加上 async 关键字，就成了 async 函数。\nasync/await 的基本用法 async 后面可以跟一个 Promise 实例对象。代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const request1 = function() { const promise = new Promise(resolve =\u0026gt; { request(\u0026#39;https://www.baidu.com\u0026#39;, function(response) { if (response.retCode == 200) { // 这里的 response 是接口1的返回结果 resolve(\u0026#39;request1 success\u0026#39;+ response); } else { reject(\u0026#39;接口请求失败\u0026#39;); } }); }); return promise; }; async function queryData() { const response = await request1(); }); return response; } queryData().then(data =\u0026gt; { console.log(data); }); 基于 async/await 处理多次 Ajax 请求【重要】 实际开发中，现在有三个网络请求，请求2必须依赖请求1的结果，请求3必须依赖请求2的结果，如果按照往常的写法，会有三层回调，会陷入“回调地狱”。\n这种场景其实就是接口的多层嵌套调用。之前学过 Promise，它可以把原本的多层嵌套调用改进为链式调用。\n而今天要学习的 async/await ，可以把原本的“多层嵌套调用”改成类似于同步的写法，非常优雅。\n代码举例：\n暂略。\nPromise、async\u0026hellip;await、Generator的对比 我们在使用 Promise、async\u0026hellip;await、Generator 的时候，返回的都是 Promise 的实例。\n如果直接使用 Promise，则需要通过 then 来进行链式调用；如果使用 async\u0026hellip;await、Generator，写起来更像同步的代码。\n参考链接 js async await 终极异步解决方案\n理解 JavaScript 的 async/await\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/12-es7async%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/","summary":"备注： async/await 的内容还有待完善。 async/await （异步函数）概述 async/await 是在 ES7 中引入的新语法，可以更加方便地进行异步操作。 本质： Generator 的语法糖。 async 的返回值是 Promise 实例对象。 await","title":"12-ES7：async函数详解"},{"content":"基本数据类型不能绑定属性和方法 属性和方法只能添加给对象，不能添加给基本数据类型。\n1、基本数据类型：\n注意，基本数据类型string是无法绑定属性和方法的。比如说：\n1 2 3 4 5 var str = \u0026#39;qianguyihao\u0026#39;; str.aaa = 12; console.log(typeof str); //打印结果为：string console.log(str.aaa); //打印结果为：undefined 上方代码中，当我们尝试打印str.aaa的时候，会发现打印结果为：undefined。也就是说，不能给 string 绑定属性和方法。\n当然，我们可以打印 str.length、str.indexOf(\u0026ldquo;m\u0026rdquo;)等等。因为这两个方法的底层做了数据类型转换（临时将 string 字符串转换为 String 对象，然后再调用内置方法），也就是我们在上一段中讲到的包装类。\n2、引用数据类型：\n引用数据类型String是可以绑定属性和方法的。如下：\n1 2 3 4 5 var strObj = new String(\u0026#39;smyhvae\u0026#39;); strObj.aaa = 123; console.log(strObj); console.log(typeof strObj); //打印结果：Object console.log(strObj.aaa); 打印结果：\n内置对象 Number 也有一些自带的方法，比如：\nNumber.MAX_VALUE;\nNumber.MIN_VALUE;\n内置对象 Boolean 也有一些自带的方法，但是用的不多。\n基本包装类型 介绍 我们都知道，js 中的数据类型包括以下几种。\n基本数据类型：String、Number、Boolean、Null、Undefined\n引用数据类型：Object\nJS 为我们提供了三个基本包装类：\nString()：将基本数据类型字符串，转换为 String 对象。\nNumber()：将基本数据类型的数字，转换为 Number 对象。\nBoolean()：将基本数据类型的布尔值，转换为 Boolean 对象。\n通过上面这这三个包装类，我们可以将基本数据类型的数据转换为对象。\n代码举例：\n1 2 3 4 5 6 7 8 9 let str1 = \u0026#39;qianguyihao\u0026#39;; let str2 = new String(\u0026#39;qianguyihao\u0026#39;); let num = new Number(3); let bool = new Boolean(true); console.log(typeof str1); // 打印结果：string console.log(typeof str2); // 注意，打印结果：object 需要注意的是：我们在实际应用中一般不会使用基本数据类型的对象。如果使用基本数据类型的对象，在做一些比较时可能会带来一些不可预期的结果。\n比如说：\n1 2 3 4 var boo1 = new Boolean(true); var boo2 = new Boolean(true); console.log(boo1 === boo2); // 打印结果竟然是：false 再比如说：\n1 2 3 4 5 var boo3 = new Boolean(false); if (boo3) { console.log(\u0026#39;qianguyihao\u0026#39;); // 这行代码竟然执行了 } 基本包装类型的作用 当我们对一些基本数据类型的值去调用属性和方法时，浏览器会临时使用包装类将基本数据类型转换为引用数据类型，这样的话，基本数据类型就有了属性和方法，然后再调用对象的属性和方法；调用完以后，再将其转换为基本数据类型。\n举例：\n1 2 var str = \u0026#39;qianguyihao\u0026#39;; console.log(str.length); // 打印结果：11 比如，上面的代码，执行顺序是这样的：\n1 2 3 4 5 6 7 8 // 步骤（1）：把简单数据类型 string 转换为 引用数据类型 String，保存到临时变量中 var temp = new String(\u0026#39;qianguyihao\u0026#39;); // 步骤（2）：把临时变量的值 赋值给 str str = temp; // 步骤（3）：销毁临时变量 temp = null; 在底层，字符串以字符数组的形式保存 在底层，字符串是以字符数组的形式保存的。代码举例：\n1 2 3 var str = \u0026#39;smyhvae\u0026#39;; console.log(str.length); // 获取字符串的长度 console.log(str[2]); // 获取字符串中的第2个字符 上方代码中，smyhvae这个字符串在底层是以[\u0026quot;s\u0026quot;, \u0026quot;m\u0026quot;, \u0026quot;y\u0026quot;, \u0026quot;h\u0026quot;, \u0026quot;v\u0026quot;, \u0026quot;a\u0026quot;, \u0026quot;e\u0026quot;]的形式保存的。因此，我们既可以获取字符串的长度，也可以获取指定索引 index 位置的单个字符。这很像数组中的操作。\n再比如，String 对象的很多内置方法，也可以直接给字符串用。此时，也是临时将字符串转换为 String 对象，然后再调用内置方法。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/12-%E5%9F%BA%E6%9C%AC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B/","summary":"基本数据类型不能绑定属性和方法 属性和方法只能添加给对象，不能添加给基本数据类型。 1、基本数据类型： 注意，基本数据类型string是无法绑定属","title":"12-基本包装类型"},{"content":"内置对象简介 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象。\n前面两种对象：是JS的基础内容，属于 ECMAScript； 第三个浏览器对象：属于JS独有，即 JS 内置的API。\n内置对象：就是指这个语言自带的一些对象，供开发者使用，这些对象提供了一些常用或者最基本而必要的功能（属性和方法）。\n内置对象最大的优点就是帮助我们快速开发。\nJavaScript的内置对象：\n内置对象 对象说明 Arguments 函数参数集合 Array 数组 Boolean 布尔对象 Math 数学对象 Date 日期时间 Error 异常对象 Function 函数构造器 Number 数值对象 Object 基础对象 RegExp 正则表达式对象 String 字符串对象 前面的几篇文章中，我们专门讲到了数组 Array。今天这篇文章，我们先来讲一下内置对象 Math。\n字符串前言 在日常开发中，String 对象（字符串对象）的使用频率是非常高的。所以有必要详细介绍。\n需要注意的是：字符串的所有方法，都不会改变原字符串（字符串的不可变性），操作完成后会返回一个新的值。\n字符串的常见方法如下。\n查找字符串 1、indexOf()/lastIndexOf()：获取字符串中指定内容的索引 这个方法，是使用频率最高的一个方法。\n语法 1：\n1 索引值 = str.indexOf(想要查询的字符串); 备注：indexOf() 是从前向后查找字符串的位置。同理，lastIndexOf()是从后向前寻找。\n解释：可以检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其第一次出现的索引；如果没有找到指定的内容，则返回 -1。\n因此可以得出一个重要技巧：\n如果获取的索引值为 0，说明字符串是以查询的参数为开头的。\n如果获取的索引值为-1，说明这个字符串中没有指定的内容。\n举例 1：(查找单个字符)\n1 2 3 4 5 6 7 8 const str = \u0026#39;abcdea\u0026#39;; //给字符查索引(索引值为0,说明字符串以查询的参数为开头) console.log(str.indexOf(\u0026#39;c\u0026#39;)); console.log(str.lastIndexOf(\u0026#39;c\u0026#39;)); console.log(str.indexOf(\u0026#39;a\u0026#39;)); console.log(str.lastIndexOf(\u0026#39;a\u0026#39;)); 打印结果：\n举例 2：（查找字符串）\n1 2 3 const name = \u0026#39;qianguyihao\u0026#39;; console.log(name.indexOf(\u0026#39;yi\u0026#39;)); // 打印结果：6 语法 2：\n这个方法还可以指定第二个参数，用来指定查找的起始位置。语法如下：\n1 索引值 = str.indexOf(想要查询的字符串, [起始位置]); 举例 3：（两个参数时，需要特别注意）\n1 2 3 4 var str = \u0026#39;qianguyihao\u0026#39;; result = str.indexOf(\u0026#39;a\u0026#39;, 3); // 从第三个位置开始查找 \u0026#39;a\u0026#39;这个字符 【重要】 console.log(result); // 打印结果：9 上方代码中，indexOf()方法中携带了两个参数，具体解释请看注释。\nindexOf 举例 案例：查找字符串\u0026quot;qianguyihao\u0026quot;中，所有 a 出现的位置以及次数。\n思路：\n（1）先查找第一个 a 出现的位置。\n（2）只要 indexOf 返回的结果不是 -1 就继续往后查找。\n（3）因为 indexOf 只能查找到第一个，所以后面的查找，可以利用第二个参数，在当前索引加 1，从而继续查找。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 var str = \u0026#39;qianguyihao\u0026#39;; var index = str.indexOf(\u0026#39;a\u0026#39;); var num = 0; while (index !== -1) { console.log(index); num++; // 每打印一次，就计数一次 index = str.indexOf(\u0026#39;o\u0026#39;, index + 1); } console.log(\u0026#39;a 出现的次数是: \u0026#39; + num); 2、search()：获取字符串中指定内容的索引（参数里一般是正则） 语法：\n1 2 索引值 = str.search(想要查找的字符串); 索引值 = str.search(正则表达式); 备注：search() 方法里的参数，既可以传字符串，也可以传正则表达式。\n解释：可以检索一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回其第一次出现的索引；如果没有找到指定的内容，则返回 -1。\n举例：\n1 2 3 4 const name = \u0026#39;qianguyihao\u0026#39;; console.log(name.search(\u0026#39;yi\u0026#39;)); // 打印结果：6 console.log(name.search(/yi/i)); // 打印结果：6 备注：上方的/yi/i采用的是正则表达式的写法，意思是，让 name去匹配字符yi，忽略大小写。我们在后面会专门介绍正则表达式。\n3、includes()：字符串中是否包含指定的内容 语法：\n1 布尔值 = str.includes(想要查找的字符串, [position]); 解释：判断一个字符串中是否含有指定内容。如果字符串中含有该内容，则会返回 true；否则返回 false。\n参数中的 position：如果不指定，则默认为0；如果指定，则规定了检索的起始位置。\n1 2 3 4 5 6 const name = \u0026#39;qianguyihao\u0026#39;; console.log(name.includes(\u0026#39;yi\u0026#39;)); // 打印结果：true console.log(name.includes(\u0026#39;haha\u0026#39;)); // 打印结果：false console.log(name.includes(\u0026#39;yi\u0026#39;,7)); // 打印结果：false 4、startsWith()：字符串是否以指定的内容开头 语法：\n1 布尔值 = str.startsWith(想要查找的内容, [position]); 解释：判断一个字符串是否以指定的子字符串开头。如果是，则返回 true；否则返回 false。\n参数中的position：\n如果不指定，则默认为0。\n如果指定，则规定了检索的起始位置。检索的范围包括：这个指定位置开始，直到字符串的末尾。即：[position, str.length)\n举例：\n1 2 3 4 5 6 7 8 const name = \u0026#39;abcdefg\u0026#39;; console.log(name.startsWith(\u0026#39;a\u0026#39;)); // 打印结果：true console.log(name.startsWith(\u0026#39;b\u0026#39;)); // 打印结果：false // 因为指定了起始位置为3，所以是在 defg 这个字符串中检索。 console.log(name.startsWith(\u0026#39;d\u0026#39;,3)); // 打印结果：true console.log(name.startsWith(\u0026#39;c\u0026#39;,3)); // 打印结果：false 5、endsWith()：字符串是否以指定的内容结尾 语法：\n1 布尔值 = str.endsWith(想要查找的内容, [position]); 解释：判断一个字符串是否以指定的子字符串结尾。如果是，则返回 true；否则返回 false。\n参数中的position：\n如果不指定，则默认为 str.length。\n如果指定，则规定了检索的结束位置。检索的范围包括：从第一个字符串开始，直到这个指定的位置。即：[0, position)\n或者你可以这样简单理解：endsWith() 方法里的position，表示检索的长度。\n注意：startsWith() 和 endsWith()这两个方法，他们的 position 的含义是不同的，请仔细区分。\n举例：\n1 2 3 4 5 6 7 8 const name = \u0026#39;abcdefg\u0026#39;; console.log(name.endsWith(\u0026#39;g\u0026#39;)); // 打印结果：true console.log(name.endsWith(\u0026#39;f\u0026#39;)); // 打印结果：false // 因为指定了截止位置为3，所以是在 abc 这个长度为3字符串中检索 console.log(name.endsWith(\u0026#39;c\u0026#39;, 3)); // 打印结果：true console.log(name.endsWith(\u0026#39;d\u0026#39;, 3)); // 打印结果：false 注意看上方的注释。\n参考链接：JavaScript endsWith()介绍\n获取指定位置的字符 1、charAt(index) 语法：\n1 字符 = str.charAt(index); 解释：返回字符串指定位置的字符。这里的 str.charAt(index)和str[index]的效果是一样的。\n注意：字符串中第一个字符的下标是 0。如果参数 index 不在 [0, string.length) 之间，该方法将返回一个空字符串。\n代码举例：\n1 2 3 4 5 var str = new String(\u0026#39;smyhvae\u0026#39;); for (var i = 0; i \u0026lt; str.length; i++) { console.log(str.charAt(i)); } 打印结果：\n上面这个例子一般不用。一般打印数组和 json 的时候用索引，打印 String 不建议用索引。\n2、str[index] str.charAt(index)和str[index]的效果是一样的，不再赘述。区别在于：str[index]是 H5 标准里新增的特性。\n3、charCodeAt(index) 语法：\n1 字符 = str.charCodeAt(index); 解释：返回字符串指定位置的字符的 Unicode 编码。不会修改原字符串。\n在实际应用中，通过这个方法，我们可以判断用户按下了哪个按键。\n代码举例：打印字符串的占位长度。\n提示：一个英文占一个位置，一个中文占两个位置。\n思路：判断该字符是否在 0-127 之间（在的话是英文，不在是非英文）。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;script\u0026gt; // sort(); 底层用到了charCodeAt(); var str = \u0026#39;I love my country!我你爱中国！\u0026#39;; //需求：求一个字符串占有几个字符位。 //思路；如果是英文，站一个字符位，如果不是英文占两个字符位。 //技术点：判断该字符是否在0-127之间。（在的话是英文，不在是非英文） alert(getZFWlength(str)); alert(str.length); //定义方法：字符位 function getZFWlength(string) { //定义一个计数器 var count = 0; for (var i = 0; i \u0026lt; string.length; i++) { //对每一位字符串进行判断，如果Unicode编码在0-127，计数器+1；否则+2 if (string.charCodeAt(i) \u0026lt; 128 \u0026amp;\u0026amp; string.charCodeAt(i) \u0026gt;= 0) { count++; } else { count += 2; } } return count; } \u0026lt;/script\u0026gt; 打印结果：\n1 2 30 24 从打印结果可以看出：字符串的长度是 24，但是却占了 30 个字符位（一个中文占两个字符位）。\n另外，sort()方法其实底层也是用到了 charCodeAt()，因为用到了 Unicode 编码。\n字符串截取 1、slice() slice() 方法用的最多。\n语法：\n1 新字符串 = str.slice(开始索引, 结束索引); //两个参数都是索引值。包左不包右。 解释：从字符串中截取指定的内容。不会修改原字符串，而是将截取到的内容返回。\n注意：上面的参数，包左不包右。参数举例如下：\n(2, 5) 截取时，包左不包右。\n(2) 表示从指定的索引位置开始，截取到最后。\n(-3) 表示从倒数第三个开始，截取到最后。\n(1, -1) 表示从第一个截取到倒数第一个。\n(5, 2) 表示前面的大，后面的小，返回值为空。\n2、substring() 语法：\n1 新字符串 = str.substring(开始索引, 结束索引); //两个参数都是索引值。包左不包右。 解释：从字符串中截取指定的内容。和slice()类似。\nsubstring()和slice()是类似的。但不同之处在于：\nsubstring()不能接受负值作为参数。如果传递了一个负值，则默认使用 0。\nsubstring()还会自动调整参数的位置，如果第二个参数小于第一个，则自动交换。比如说， substring(1, 0)相当于截取的是第一个字符。\n3、substr() 语法：\n1 字符串 = str.substr(开始索引, 截取的长度); 解释：从字符串中截取指定的内容。不会修改原字符串，而是将截取到的内容返回。\n注意，这个方法的第二个参数截取的长度，不是结束索引。\n参数举例：\n(2,4) 从索引值为 2 的字符开始，截取 4 个字符。\n(1) 从指定位置开始，截取到最后。\n(-3) 从倒数第几个开始，截取到最后。\n备注：ECMAscript 没有对 substr() 方法进行标准化，因此不建议使用它。\nString.fromCharCode() String.fromCharCode()：根据字符的 Unicode 编码获取字符。\n代码举例：\n1 2 3 4 5 var result1 = String.fromCharCode(72); var result2 = String.fromCharCode(20013); console.log(result1); // 打印结果：H console.log(result2); // 打印结果：中 concat() 语法：\n1 新字符串 = str1.concat(str2)； //连接两个字符串 解释：字符串的连接。\n这种方法基本不用，直接把两个字符串相加就好。\n是的，你会发现，数组中也有concat()方法，用于数组的连接。这个方法在数组中用得挺多的。\n代码举例：\n1 2 3 4 5 var str1 = \u0026#39;qiangu\u0026#39;; var str2 = \u0026#39;yihao\u0026#39;; var result = str1.concat(str2); console.log(result); // 打印结果：qianguyihao split()：字符串转换为数组 【重要】 语法：\n1 新的数组 = str.split(分隔符); 解释：通过指定的分隔符，将一个字符串拆分成一个数组。不会改变原字符串。\n备注：split()这个方法在实际开发中用得非常多。一般来说，从接口拿到的 json 数据中，经常会收到类似于\u0026quot;q, i, a, n\u0026quot;这样的字符串，前端需要将这个字符串拆分成['q', 'i', 'a', 'n']数组，这个时候split()方法就派上用场了。\n代码举例 1：\n1 2 3 4 var str = \u0026#39;qian, gu, yi, hao\u0026#39;; // 用逗号隔开的字符串 var array = str.split(\u0026#39;,\u0026#39;); // 将字符串 str 拆分成数组，通过逗号来拆分 console.log(array); // 打印结果是数组：[\u0026#34;qian\u0026#34;, \u0026#34; gu\u0026#34;, \u0026#34; yi\u0026#34;, \u0026#34; hao\u0026#34;] 代码举例 2：\n1 2 3 4 5 6 7 8 9 10 //split()方法：字符串变数组 var str3 = \u0026#39;lvbu|qianguyihao|许嵩\u0026#39;; console.log(\u0026#39;结果1：\u0026#39; +str3.split()); // 无参数，表示：把整个字符串作为一个元素添加到数组中。 console.log(str3.split(\u0026#39;\u0026#39;)); // 参数为空字符串，则表示：分隔字符串中每一个字符，分别添加到数组中 console.log(str3.split(\u0026#39;|\u0026#39;)); // 参数为指定字符，表示：用 \u0026#39;|\u0026#39; 分隔字符串。此分隔符将不会出现在数组的任意一个元素中 console.log(str3.split(\u0026#39;许\u0026#39;)); // 同上 打印结果：（都是数组）\nreplace() 语法：\n1 新的字符串 = str.replace(被替换的字符，新的字符); 解释：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。\n注意：这个方法，默认只会替换第一个被匹配到的字符。如果要全局替换，需要使用正则。\n代码举例：\n1 2 3 4 5 6 //replace()方法：替换 var str2 = \u0026#39;Today is fine day,today is fine day !\u0026#39;; console.log(str2); console.log(str2.replace(\u0026#39;today\u0026#39;, \u0026#39;tomorrow\u0026#39;)); //只能替换第一个today console.log(str2.replace(/today/gi, \u0026#39;tomorrow\u0026#39;)); //这里用到了正则，才能替换所有的today repeat()：重复字符串 语法：\n1 newStr = str.repeat(重复的次数); 解释：将字符串重复指定的次数。会返回新的值，不会修改原字符串。\n举例1：\n1 2 3 const name = \u0026#39;qianguyihao\u0026#39;; console.log(name.repeat(2)); // 打印内容：qianguyihaoqianguyihao 举例2：（模糊字符串的后四位）\n1 2 3 4 5 const telephone = \u0026#39;13088889999\u0026#39;; const mix_telephone = telephone.slice(0, -4) + \u0026#39;*\u0026#39;.repeat(4); // 模糊电话号码的后四位 console.log(telephone); // 打印结果：13088889999 console.log(mix_telephone); // 打印结果：1308888**** trim() trim()：去除字符串前后的空白。\n代码举例：\n1 2 3 4 5 6 7 //去除字符串前后的空格，trim(); let str = \u0026#39; a b c \u0026#39;; console.log(str); console.log(str.length); console.log(str.trim()); console.log(str.trim().length); 打印结果：\n大小写转换 举例：\n1 2 3 4 5 6 7 var str = \u0026#39;abcdEFG\u0026#39;; //转换成小写 console.log(str.toLowerCase()); //转换成大写 console.log(str.toUpperCase()); html 方法 anchor() 创建 a 链接\nbig()\nsub()\nsup()\nlink()\nbold()\n注意，str.link() 返回值是字符串。\n举例：\n1 2 3 4 5 6 7 8 var str = \u0026#39;你好\u0026#39;; console.log(str.anchor()); console.log(str.big()); console.log(str.sub()); console.log(str.sup()); console.log(str.link(\u0026#39;http://www.baidu.com\u0026#39;)); console.log(str.bold()); 字符串练习 练习 1：\u0026ldquo;smyhvaevaesmyh\u0026quot;查找字符串中所有 m 出现的位置。\n代码实现：\n1 2 3 4 5 6 7 8 var str2 = \u0026#39;smyhvaevaesmyh\u0026#39;; for (var i = 0; i \u0026lt; str2.length; i++) { //如果指定位置的符号=== \u0026#34;o\u0026#34; //str2[i] if (str2.charAt(i) === \u0026#39;m\u0026#39;) { console.log(i); } } 练习 2：判断一个字符串中出现次数最多的字符，统计这个次数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;script\u0026gt; var str2 = \u0026#39;smyhvaevaesmyhvae\u0026#39;; //定义一个json，然后判断json中是够有该属性，如果有该属性，那么值+1;否则创建一个该属性，并赋值为1； var json = {}; for (var i = 0; i \u0026lt; str2.length; i++) { //判断：如果有该属性，那么值+1;否则创建一个该属性，并赋值为1； var key = str2.charAt(i); if (json[key] === undefined) { json[key] = 1; } else { json[key] += 1; } } console.log(json); console.log(\u0026#39;----------------\u0026#39;); //获取json中属性值最大的选项 var maxKey = \u0026#39;\u0026#39;; var maxValue = 0; for (var k in json) { // if(maxKey == \u0026#34;\u0026#34;){ // maxKey = k; // maxValue = json[k]; // }else{ if (json[k] \u0026gt; maxValue) { maxKey = k; maxValue = json[k]; } // } } console.log(maxKey); console.log(maxValue); \u0026lt;/script\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/13-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-string%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/","summary":"内置对象简介 JavaScript 中的对象分为3种：自定义对象 、内置对象、 浏览器对象。 前面两种对象：是JS的基础内容，属于 ECMAScript； 第三个浏览器对象","title":"13-内置对象 String：字符串的常见方法"},{"content":"内置对象 Number 的常见方法 Number.isInteger() 判断是否为整数 语法：\n1 布尔值 = Number.isInteger(数字); toFixed() 小数点后面保留多少位 语法：\n1 字符串 = myNum.toFixed(num); 解释：将数字 myNum 的小数点后面保留 num 位小数（四舍五入），并返回。不会改变原数字。注意，返回结果是字符串。\n参数 num：指定了小数点后面的位数。\n举例：\n1 2 3 4 5 6 7 8 let num = 3.456; let num2 = num.toFixed(2); console.log(num); // 打印结果：3.456 console.log(num2); // 打印结果：3.46 console.log(typeof num); // number console.log(typeof num2); // string 上方代码中，num2的结果是3.46，但是请注意，num的类型Number型，而num2的类型却是String型。\n内置对象 Math 的常见方法 Math 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是直接使用里面的属性和方法即可。\nMath属于一个工具类，里面封装了数学运算相关的属性和方法。如下：\n方法 描述 备注 Math.PI 圆周率 Math对象的属性 Math.abs() 返回绝对值 Math.random() 生成0-1之间的随机浮点数 取值范围是 [0，1) Math.floor() 向下取整（往小取值） Math.ceil() 向上取整（往大取值） Math.round() 四舍五入取整（正数四舍五入，负数五舍六入） Math.max(x, y, z) 返回多个数中的最大值 Math.min(x, y, z) 返回多个数中的最小值 Math.pow(x,y) 乘方：返回 x 的 y 次幂 Math.sqrt() 开方：对一个数进行开方运算 举例：\n1 2 3 4 5 6 7 8 9 10 11 var num = -0.6; console.log(Math.abs(num)); //取绝对值 console.log(Math.floor(num)); //向下取整，向小取 console.log(Math.ceil(num)); //向上取整，向大取 console.log(Math.round(num)); //四舍五入取整（正数四舍五入，负数五舍六入） console.log(Math.random()); //生成0-1之间的随机数 运行结果：\n1 2 3 4 5 6 7 8 9 0.6 -1 -0 -1 0.6453756205275165 Math.abs()：获绝对值 方法定义：返回绝对值。\n注意：\n参数中可以接收字符串类型的数字，此时会将字符串做隐式类型转换，然后再调用 Math.abs() 方法。 代码举例：\n1 2 3 4 5 6 7 console.log(Math.abs(2)); // 2 console.log(Math.abs(-2)); // 2 // 先做隐式类型转换，将 \u0026#39;-2\u0026#39;转换为数字类型 -2，然后再调用 Math.abs() console.log(Math.abs(\u0026#39;-2\u0026#39;)); console.log(Math.abs(\u0026#39;hello\u0026#39;)); // NaN Math.random() 方法：生成随机数 方法定义：生成 [0, 1) 之间的随机浮点数。\n我们来看几个例子。\n生成 [0, x) 之间的随机数 1 Math.round(Math.random()*x) 生成 [x, y) 之间的随机数 1 Math.round(Math.random()*(y-x)+x) 【重要】生成 [x, y]之间的随机整数 也就是说：生成两个整数之间的随机整数，并且要包含这两个整数。\n这个功能很常用，我们可以将其封装成一个方法，代码实现如下：\n1 2 3 4 5 6 7 8 /* * 生成两个整数之间的随机整数，并且要包含这两个整数 */ function getRandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } console.log(getRandom(1, 10)); 举例：随机点名 根据上面的例子，我们还可以再延伸一下，来看看随机点名的例子。\n1 2 3 4 5 6 7 8 9 10 /* * 生成两个整数之间的随机整数，并且要包含这两个整数 */ function getRandom(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; } const arr = [\u0026#39;许嵩\u0026#39;, \u0026#39;邓紫棋\u0026#39;, \u0026#39;毛不易\u0026#39;, \u0026#39;解忧邵帅\u0026#39;]; const index = getRandom(0, arr.length - 1); // 生成随机的index console.log(arr[index]); // 随机点名 pow()：乘方 如果想计算 a 的 b 次方，可以使用如下函数：\n1 Math.pow(a, b); Math的中文是“数学”，pow是“幂”。\n举例1：\n代码实现：\n1 2 var a = Math.pow(3, Math.pow(2, 2)); console.log(a); 举例2：\n代码实现：\n1 2 var a = Math.pow(Math.pow(3, 2), 4); console.log(a); sqrt()：开方 如果想计算数值a的开二次方，可以使用如下函数：\n1 Math.sqrt(a); sqrt即“square 开方”。比如：\n1 var a = Math.sqrt(36); url 编码和解码 URI (Uniform ResourceIdentifiers,通用资源标识符)进行编码，以便发送给浏览器。有效的URI中不能包含某些字符，例如空格。而这URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。\n1 2 encodeURIComponent(); //把字符串作为 URI 组件进行编码 decodeURIComponent(); //把字符串作为 URI 组件进行解码 举例：\n1 2 3 4 5 var url = \u0026#34;http://www.cnblogs.com/smyhvae/\u0026#34;; var str = encodeURIComponent(url); console.log(str); //打印url的编码 console.log(decodeURIComponent(str)); //对url进行编码后，再解码，还原为url 打印结果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/14-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1number%E5%92%8Cmath/","summary":"内置对象 Number 的常见方法 Number.isInteger() 判断是否为整数 语法： 1 布尔值 = Number.isInteger(数字); toFixed() 小数点后面保留多少位 语法： 1 字符串 = myNum.toFixed(num); 解释：","title":"14-内置对象：Number和Math"},{"content":"内置对象：Date Date 对象在实际开发中，使用得很频繁，且容易在细节地方出错，需要引起重视。\n内置对象 Date 用来处理日期和时间。\n需要注意的是：与 Math 对象不同，Date 对象是一个构造函数 ，需要先实例化后才能使用。\n创建Date对象 创建Date对象有两种写法：\n写法一：如果Date()不写参数，就返回当前时间对象\n写法二：如果Date()里面写参数，就返回括号里输入的时间对象\n针对这两种写法，我们来具体讲一讲。\n写法一：不传递参数时，则获取系统的当前时间对象 代码举例：\n1 2 3 var date1 = new Date(); console.log(date1); console.log(typeof date1); 代码解释：不传递参数时，表示的是获取系统的当前时间对象。也可以理解成是：获取当前代码执行的时间。\n打印结果：\n1 2 Mon Feb 17 2020 21:57:22 GMT+0800 (中国标准时间) object 写法二：传递参数 传递参数时，表示获取指定时间的时间对象。参数中既可以传递字符串，也可以传递数字，也可以传递时间戳。\n通过传参的这种写法，我们可以把时间字符串/时间数字/时间戳，按照指定的格式，转换为时间对象。\n举例1：（参数是字符串）\n1 2 3 4 5 6 7 8 9 10 11 const date11 = new Date(\u0026#39;2020/02/17 21:00:00\u0026#39;); console.log(date11); // Mon Feb 17 2020 21:00:00 GMT+0800 (中国标准时间) const date12 = new Date(\u0026#39;2020/04/19\u0026#39;); // 返回的就是四月 console.log(date12); // Sun Apr 19 2020 00:00:00 GMT+0800 (中国标准时间) const date13 = new Date(\u0026#39;2020-05-20\u0026#39;); console.log(date13); // Wed May 20 2020 08:00:00 GMT+0800 (中国标准时间) const date14 = new Date(\u0026#39;Wed Jan 27 2017 12:00:00 GMT+0800 (中国标准时间)\u0026#39;); console.log(date14); // Fri Jan 27 2017 12:00:00 GMT+0800 (中国标准时间) 举例2：（参数是多个数字）\n1 2 3 4 5 6 7 8 9 const date21 = new Date(2020, 2, 18); // 注意，第二个参数返回的是三月，不是二月 console.log(date21); // Wed Mar 18 2020 00:00:00 GMT+0800 (中国标准时间) const date22 = new Date(2020, 3, 18, 22, 59, 58); console.log(date22); // Sat Apr 18 2020 22:59:58 GMT+0800 (中国标准时间) const params = [2020, 06, 12, 16, 20, 59]; const date23 = new Date(...params); console.log(date23); // Sun Jul 12 2020 16:20:59 GMT+0800 (中国标准时间) 举例3：（参数是时间戳）\n1 2 3 4 5 6 7 const date31 = new Date(1591950413388); console.log(date31); // Fri Jun 12 2020 16:26:53 GMT+0800 (中国标准时间) // 先把时间对象转换成时间戳，然后把时间戳转换成时间对象 const timestamp = new Date().getTime(); const date32 = new Date(timestamp); console.log(date32); // Fri Jun 12 2020 16:28:21 GMT+0800 (中国标准时间) 日期的格式化 上一段内容里，我们获取到了 Date 对象，但这个对象，打印出来的结果并不是特别直观。\n如果我们需要获取日期的指定部分，就需要用到 Date对象自带的方法。\n获取了日期指定的部分之后，我们就可以让日期按照指定的格式，进行展示（即日期的格式化）。比如说，我期望能以 2020-02-02 19:30:59 这种格式进行展示。\n在这之前，我们先来看看 Date 对象有哪些方法。\nDate对象的方法 Date对象 有如下方法，可以获取日期和时间的指定部分：\n方法名 含义 备注 getFullYear() 获取年份 getMonth() 获取月： 0-11 0代表一月 getDate() 获取日：1-31 获取的是几号 getDay() 获取星期：0-6 0代表周日，1代表周一 getHours() 获取小时：0-23 getMinutes() 获取分钟：0-59 getSeconds() 获取秒：0-59 getMilliseconds() 获取毫秒 1s = 1000ms 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 我在执行这行代码时，当前时间为 2019年2月4日，周一，13:23:52 var myDate = new Date(); console.log(myDate); // 打印结果：Mon Feb 04 2019 13:23:52 GMT+0800 (中国标准时间) console.log(myDate.getFullYear()); // 打印结果：2019 console.log(myDate.getMonth() + 1); // 打印结果：2 console.log(myDate.getDate()); // 打印结果：4 var dayArr = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;,\u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; console.log(myDate.getDay()); // 打印结果：1 console.log(dayArr[myDate.getDay()]); // 打印结果：星期一 console.log(myDate.getHours()); // 打印结果：13 console.log(myDate.getMinutes()); // 打印结果：23 console.log(myDate.getSeconds()); // 打印结果：52 console.log(myDate.getMilliseconds()); // 打印结果：393 console.log(myDate.getTime()); // 获取时间戳。打印结果：1549257832393 获取了日期和时间的指定部分之后，我们把它们用字符串拼接起来，就可以按照自己想要的格式，来展示日期。\n举例：年月日的格式化 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 console.log(formatDate()); /* 方法：日期格式化。 格式要求：今年是：2020年02月02日 08:57:09 星期日 */ function formatDate() { var date = new Date(); var year = date.getFullYear(); // 年 var month = date.getMonth() + 1; // 月 var day = date.getDate(); // 日 var week = date.getDay(); // 星期几 var weekArr = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;, \u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; var hour = date.getHours(); // 时 hour = hour \u0026lt; 10 ? \u0026#39;0\u0026#39; + hour : hour; // 如果只有一位，则前面补零 var minute = date.getMinutes(); // 分 minute = minute \u0026lt; 10 ? \u0026#39;0\u0026#39; + minute : minute; // 如果只有一位，则前面补零 var second = date.getSeconds(); // 秒 second = second \u0026lt; 10 ? \u0026#39;0\u0026#39; + second : second; // 如果只有一位，则前面补零 var result = \u0026#39;今天是：\u0026#39; + year + \u0026#39;年\u0026#39; + month + \u0026#39;月\u0026#39; + day + \u0026#39;日 \u0026#39; + hour + \u0026#39;:\u0026#39; + minute + \u0026#39;:\u0026#39; + second + \u0026#39; \u0026#39; + weekArr[week]; return result; } 获取时间戳 时间戳的定义和作用 时间戳：指的是从格林威治标准时间的1970年1月1日，0时0分0秒到当前日期所花费的毫秒数（1秒 = 1000毫秒）。\n计算机底层在保存时间时，使用的都是时间戳。时间戳的存在，就是为了统一时间的单位。\n我们经常会利用时间戳来计算时间，因为它更精确。而且，在实战开发中，接口返回给前端的日期数据，都是以时间戳的形式。\n我们再来看下面这样的代码：\n1 2 3 var myDate = new Date(\u0026#34;1970/01/01 0:0:0\u0026#34;); console.log(myDate.getTime()); // 获取时间戳 打印结果（可能会让你感到惊讶）\n1 -28800000 为啥打印结果是-28800000，而不是0呢？这是因为，我们的当前代码，是在中文环境下运行的，与英文时间会存在8个小时的时差（中文时间比英文时间早了八个小时）。如果代码是在英文环境下运行，打印结果就是0。\ngetTime()：获取时间戳 getTime() 获取日期对象的时间戳（单位：毫秒）。这个方法在实战开发中，用得比较多。但还有比它更常用的写法，我们往下看。\n获取 Date 对象的时间戳 代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 方式一：获取 Date 对象的时间戳（最常用的写法） const timestamp1 = +new Date(); console.log(timestamp1); // 打印结果举例：1589448165370 // 方式二：获取 Date 对象的时间戳（较常用的写法） const timestamp2 = new Date().getTime(); console.log(timestamp2); // 打印结果举例：1589448165370 // 方式三：获取 Date 对象的时间戳 const timestamp3 = new Date().valueOf(); console.log(timestamp3); // 打印结果举例：1589448165370 // 方式4：获取 Date 对象的时间戳 const timestamp4 = new Date() * 1; console.log(timestamp4); // 打印结果举例：1589448165370 // 方式5：获取 Date 对象的时间戳 const timestamp5 = Number(new Date()); console.log(timestamp5); // 打印结果举例：1589448165370 上面这五种写法都可以获取任意 Date 对象的时间戳，最常见的写法是方式一，其次是方式二。\n根据前面所讲的关于「时间戳」的概念，上方代码获取到的时间戳指的是：从 1970年1月1日，0时0分0秒 到现在所花费的总毫秒数。\n获取当前时间的时间戳 如果我们要获取当前时间的时间戳，除了上面的几种方式之外，还有另一种方式。代码如下：\n1 2 // 方式六：获取当前时间的时间戳（很常用的写法） console.log(Date.now()); // 打印结果举例：1589448165370 上面这种方式六，用得也很多。只不过，Date.now()是H5标准中新增的特性，如果你的项目需要兼容低版本的IE浏览器，就不要用了。这年头，谁还用IE呢？\n利用时间戳检测代码的执行时间 我们可以在业务代码的前面定义 时间戳1，在业务代码的后面定义 时间戳2。把这两个时间戳相减，就能得出业务代码的执行时间。\nformat() 将时间对象转换为指定格式。\n参考链接：https://www.cnblogs.com/tugenhua0707/p/3776808.html\n练习 举例1：模拟日历 要求每天打开这个页面，都能定时显示当前的日期。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 800px; margin: 200px auto; color: red; text-align: center; font: 600 30px/30px \u0026#39;simsun\u0026#39;; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //模拟日历 //需求：每天打开这个页面都能定时显示年月日和星期几 function getCurrentDate() { //1.创建一个当前日期的日期对象 const date = new Date(); //2.然后获取其中的年、月、日和星期 const year = date.getFullYear(); const month = date.getMonth(); const hao = date.getDate(); const week = date.getDay(); // console.log(year+\u0026#34; \u0026#34;+month+\u0026#34; \u0026#34;+hao+\u0026#34; \u0026#34;+week); //3.赋值给div const arr = [\u0026#39;星期日\u0026#39;, \u0026#39;星期一\u0026#39;, \u0026#39;星期二\u0026#39;, \u0026#39;星期三\u0026#39;, \u0026#39;星期四\u0026#39;, \u0026#39;星期五\u0026#39;, \u0026#39;星期六\u0026#39;]; const div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; return \u0026#39;今天是：\u0026#39; + year + \u0026#39;年\u0026#39; + (month + 1) + \u0026#39;月\u0026#39; + hao + \u0026#39;日 \u0026#39; + arr[week]; } const div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; div.innerText = getCurrentDate(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\n举例2：发布会倒计时 实现思路：\n设置一个定时器，每间隔1毫秒就自动刷新一次div的内容。\n核心算法：输入的时间戳减去当前的时间戳，就是剩余时间（即倒计时），然后转换成时分秒。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 1210px; margin: 200px auto; color: red; text-align: center; font: 600 30px/30px \u0026#39;simsun\u0026#39;; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementsByTagName(\u0026#39;div\u0026#39;)[0]; var timer = setInterval(() =\u0026gt; { countDown(\u0026#39;2022/02/03 11:20:00\u0026#39;); }, 1); function countDown(myTime) { var nowTime = new Date(); var future = new Date(myTime); var timeSum = future.getTime() - nowTime.getTime(); //获取时间差：发布会时间减去此刻的毫秒值 var day = parseInt(timeSum / 1000 / 60 / 60 / 24); // 天 var hour = parseInt((timeSum / 1000 / 60 / 60) % 24); // 时 var minu = parseInt((timeSum / 1000 / 60) % 60); // 分 var sec = parseInt((timeSum / 1000) % 60); // 秒 var millsec = parseInt(timeSum % 1000); // 毫秒 //细节处理：所有的时间小于10的时候，在前面自动补0，毫秒值要补双0（比如如，把 8 秒改成 08 秒） day = day \u0026lt; 10 ? \u0026#39;0\u0026#39; + day : day; //day小于10吗？如果小于，就补0；如果不小于，就是day本身 hour = hour \u0026lt; 10 ? \u0026#39;0\u0026#39; + hour : hour; minu = minu \u0026lt; 10 ? \u0026#39;0\u0026#39; + minu : minu; sec = sec \u0026lt; 10 ? \u0026#39;0\u0026#39; + sec : sec; if (millsec \u0026lt; 10) { millsec = \u0026#39;00\u0026#39; + millsec; } else if (millsec \u0026lt; 100) { millsec = \u0026#39;0\u0026#39; + millsec; } // 兜底处理 if (timeSum \u0026lt; 0) { div.innerHTML = \u0026#39;距离苹果发布会还有00天00小时00分00秒000毫秒\u0026#39;; clearInterval(timer); return; } // 前端要显示的文案 div.innerHTML = \u0026#39;距离苹果发布会还有\u0026#39; + day + \u0026#39;天\u0026#39; + hour + \u0026#39;小时\u0026#39; + minu + \u0026#39;分\u0026#39; + sec + \u0026#39;秒\u0026#39; + millsec + \u0026#39;毫秒\u0026#39;; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\nMoment.js Moment.js 是一个轻量级的JavaScript时间库，我们可以利用它很方便地进行时间操作，提升开发效率。\n中文官网：http://momentjs.cn/ 使用举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.bootcdn.net/ajax/libs/moment.js/2.26.0/moment.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 按照指定的格式，格式化当前时间 console.log(moment().format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;)); // 打印结果举例：2020-06-12 16:38:38 console.log(typeof moment().format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;)); // 打印结果：string // 按照指定的格式，格式化指定的时间 console.log(moment(\u0026#39;2020/06/12 18:01:59\u0026#39;).format(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;)); // 打印结果：2020-06-12 18:01:59 // 按照指定的格式，获取七天后的时间 console.log(moment().add(7, \u0026#39;days\u0026#39;).format(\u0026#39;YYYY-MM-DD hh:mm:ss\u0026#39;)); // 打印结果举例：2020-06-19 04:43:56 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/15-%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1date/","summary":"内置对象：Date Date 对象在实际开发中，使用得很频繁，且容易在细节地方出错，需要引起重视。 内置对象 Date 用来处理日期和时间。 需要注意的是：与 Math 对象","title":"15-内置对象：Date"},{"content":" 之前学习的数据类型，只能存储一个值（字符串也为一个值）。如果我们想存储多个值，就可以使用数组。\n数组简介 数组（Array）是属于内置对象，我们可以在MDN网站上查询它的各种方法。\n数组和普通对象的功能类似，也是用来存储一些值的。不同的是：\n普通对象是使用字符串作为属性名的，而数组是使用数字作为索引来操作元素。索引：从 0 开始的整数就是索引。 数组的存储性能比普通对象要好。在实际开发中我们经常使用数组来存储一些数据（尤其是列表数据），使用频率非常高。\n比如说，上面这个页面的列表数据，它的结构就是一个大数组。\n数组中的元素可以是任意的数据类型，也可以是对象，也可以是函数，也可以是数组。数组的元素中，如果存放的是数组，我们就称这种数组为二维数组。\n接下来，我们讲一讲数组的基本操作。\n创建数组对象 方式一：使用字面量创建数组 举例：\n1 2 3 var arr1 = []; // 创建一个空的数组 var arr2 = [1, 2, 3]; // 创建带初始值的数组 方式一最简单，也用得最多。\n方式二：使用构造函数创建数组 语法：\n1 2 3 let arr = new Array(参数); let arr = Array(参数); 如果参数为空，则表示创建一个空数组；如果参数是一个数值时，表示数组的长度；如果有多个参数时，表示数组中的元素。\n来举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 方式一 var arr1 = [11, 12, 13]; // 方式二 var arr2 = new Array(); // 参数为空 var arr3 = new Array(4); // 参数为一个数值 var arr4 = new Array(15, 16, 17); // 参数为多个数值 console.log(typeof arr1); // 打印结果：object console.log(\u0026#39;arr1 = \u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;arr2 = \u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;arr3 = \u0026#39; + JSON.stringify(arr3)); console.log(\u0026#39;arr4 = \u0026#39; + JSON.stringify(arr4)); 打印结果：\n1 2 3 4 5 6 object; arr1 = [11, 12, 13]; arr2 = []; arr3 = [null, null, null, null]; arr4 = [15, 16, 17]; 从上方打印结果的第一行里，可以看出，数组的类型其实也是属于对象。\n数组中的元素的类型 数组中可以存放任意类型的数据，例如字符串、数字、布尔值、对象等。\n比如：\n1 const arr = [\u0026#39;qianguyihao\u0026#39;, 28, true, { name: \u0026#39;qianguyihao\u0026#39; }]; 我们甚至还可以存放多维数组（数组里面放数组）。比如：\n1 2 3 4 const arr2 = [ [11, 12, 13], [21, 22, 23], ]; 数组的基本操作 数组的索引 索引 (下标) ：用来访问数组元素的序号，代表的是数组中的元素在数组中的位置（下标从 0 开始算起）。\n数组可以通过索引来访问、设置、修改对应的数组元素。我们继续看看。\n向数组中添加元素 语法：\n1 数组[索引] = 值; 代码举例：\n1 2 3 4 5 6 7 8 9 10 var arr = []; // 向数组中添加元素 arr[0] = 10; arr[1] = 20; arr[2] = 30; arr[3] = 40; arr[5] = 50; console.log(JSON.stringify(arr)); 打印结果：\n1 [10,20,30,40,null,50] 获取数组中的元素 语法：\n1 数组[索引]; 如果读取不存在的索引（比如元素没那么多），系统不会报错，而是返回 undefined。\n代码举例：\n1 2 3 4 var arr = [21, 22, 23]; console.log(arr[0]); // 打印结果：21 console.log(arr[5]); // 打印结果：undefined 获取数组的长度 可以使用length属性来获取数组的长度(即“元素的个数”)。\n数组的长度是元素个数，不要跟索引号混淆。\n语法：\n1 数组的长度 = 数组名.length； 代码举例：\n1 2 3 var arr = [21, 22, 23]; console.log(arr.length); // 打印结果：3 补充：\n对于连续的数组，使用 length 可以获取到数组的长度（元素的个数）；对于非连续的数组，使用 length 会获取到数组的最大的索引+1。因此，尽量不要创建非连续的数组。\n修改数组的长度（修改 length） 如果修改的 length 大于原长度，则多出部分会空出来，置为 null。\n如果修改的 length 小于原长度，则多出的元素会被删除，数组将从后面删除元素。\n（特例：伪数组 arguments 的长度可以修改，但是不能修改里面的元素，后面单独讲。）\n代码举例：\n1 2 3 4 5 6 7 8 9 10 var arr1 = [11, 12, 13]; var arr2 = [21, 22, 23]; // 修改数组 arr1 的 length arr1.length = 1; console.log(JSON.stringify(arr1)); // 修改数组 arr2 的 length arr2.length = 5; console.log(JSON.stringify(arr2)); 打印结果：\n1 [11][(21, 22, 23, null, null)]; 遍历数组 遍历: 就是把数组中的每个元素从头到尾都访问一次。\n最简单的做法是通过 for 循环，遍历数组中的每一项。举例：\n1 2 3 4 5 var arr = [10, 20, 30, 40, 50]; for (var i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); // 打印出数组中的每一项 } 下一篇文章，会学习数组的各种方法，到时候，会有更多的做法去遍历数组。\n案例 例 1：翻转数组 代码实现：\n1 2 3 4 5 6 var arr = [10, 20, 30, 40, 50]; // 原始数组 var newArr = []; // 翻转后的数组 for (var i = 0; i \u0026lt; arr.length; i++) { newArr[i] = arr[arr.length - i - 1]; } console.log(JSON.stringify(newArr)); 打印结果：\n1 [50,40,30,20,10] 例 2：冒泡排序 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 var arr = [20, 10, 50, 30, 40]; for (var i = 0; i \u0026lt; arr.length - 1; i++) { for (var j = 0; j \u0026lt; arr.length - i - 1; j++) { if (arr[j] \u0026gt; arr[j + 1]) { var temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } console.log(JSON.stringify(arr)); 打印结果：\n1 [10,20,30,40,50] ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/16-%E6%95%B0%E7%BB%84%E7%AE%80%E4%BB%8B/","summary":"之前学习的数据类型，只能存储一个值（字符串也为一个值）。如果我们想存储多个值，就可以使用数组。 数组简介 数组（Array）是属于内置对象，我们","title":"16-数组简介"},{"content":"数组的方法清单 数组的类型相关 方法 描述 备注 Array.isArray() 判断是否为数组 toString() 将数组转换为字符串 Array.from(arrayLike) 将伪数组转化为真数组 Array.of(value1, value2, value3) 创建数组：将一系列值转换成数组 注意，获取数组的长度是用length属性，不是方法。关于 length属性，详见上一篇文章。\n数组元素的添加和删除 方法 描述 备注 push() 向数组的最后面插入一个或多个元素，返回结果为新数组的长度 会改变原数组 pop() 删除数组中的最后一个元素，返回结果为被删除的元素 会改变原数组 unshift() 在数组最前面插入一个或多个元素，返回结果为新数组的长度 会改变原数组 shift() 删除数组中的第一个元素，返回结果为被删除的元素 会改变原数组 slice() 从数组中提取指定的一个或多个元素，返回结果为新的数组 不会改变原数组 splice() 从数组中删除指定的一个或多个元素，返回结果为被删除元素组成的新数组 会改变原数组 fill() 填充数组：用固定的值填充数组，返回结果为新的数组 不会改变原数组 数组的合并和拆分 方法 描述 备注 concat() 合并数组：连接两个或多个数组，返回结果为新的数组 不会改变原数组 join() 将数组转换为字符串，返回结果为转换后的字符串 不会改变原数组 split() 将字符串按照指定的分隔符，组装为数组 不会改变原字符串 注意，split()是字符串的方法，不是数组的方法。\n数组排序 方法 描述 备注 reverse() 反转数组，返回结果为反转后的数组 会改变原数组 sort() 对数组的元素,默认按照Unicode 编码，从小到大进行排序 会改变原数组 查找数组的元素 方法 描述 备注 indexOf(value) 从前往后索引，检索一个数组中是否含有指定的元素 lastIndexOf(value) 从后往前索引，检索一个数组中是否含有指定的元素 includes(item) 数组中是否包含指定的内容 find(function()) 找出第一个满足「指定条件返回 true」的元素 findIndex(function()) 找出第一个满足「指定条件返回 true」的元素的 index every() 确保数组中的每个元素都满足「指定条件返回 true」，则停止遍历，此方法才返回 true 全真才为真。要求每一项都返回 true，最终的结果才返回 true some() 数组中只要有一个元素满足「指定条件返回 true」，则停止遍历，此方法就返回 true 一真即真。只要有一项返回 true，最终的结果就返回 true 遍历数组 方法 描述 备注 for 循环 这个大家都懂 forEach() 和 for 循环类似，但需要兼容 IE8 以上 forEach() 没有返回值。也就是说，它的返回值是 undefined map() 对原数组中的每一项进行加工，将组成新的数组 不会改变原数组 filter() 过滤数组：返回结果是 true 的项，将组成新的数组，返回结果为新的数组 不会改变原数组 reduce 接收一个函数作为累加器，返回值是回调函数累计处理的结果 isArray()：判断是否为数组 语法：\n1 布尔值 = Array.isArray(被检测的数组); 以前，我们会通过 A instanceof B来判断 A 是否属于 B 类型。但是在数组里，这种 instanceof 方法已经用的不多了，因为有 isArray()方法。\ntoString()：数组转换为字符串 1 字符串 = 数组.toString(); 解释：把数组转换成字符串，每一项用,分割。\n备注：大多数的数据类型都可以使用.toString()方法，将其转换为字符串。\n知识点补充：将数组转换为字符串，有哪些方式 方式 1：\n1 字符串 = 数组.toString(); 方式 2：\n1 字符串 = String(数组); 方式 3：\n1 字符串 = 数组.join(\u0026#39;,\u0026#39;); // 将数组转为字符串，每一项用 英文逗号 分隔 Array.from()：将伪数组转换为真数组 语法：\n1 array = Array.from(arrayLike); 作用：将伪数组或可遍历对象转换为真数组。\n代码举例：\n1 2 const name = \u0026#39;qianguyihao\u0026#39;; console.log(Array.from(name)); // 打印结果是数组：[\u0026#34;q\u0026#34;,\u0026#34;i\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;g\u0026#34;,\u0026#34;u\u0026#34;,\u0026#34;y\u0026#34;,\u0026#34;i\u0026#34;,\u0026#34;h\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;o\u0026#34;] 伪数组与真数组的区别 伪数组：包含 length 属性的对象或可迭代的对象。\n另外，伪数组的原型链中没有 Array.prototype，而真数组的原型链中有 Array.prototype。因此伪数组没有数组的一般方法，比如 pop()、join() 等方法。\n伪数组举例 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;按钮3\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; let btnArray = document.getElementsByTagName(\u0026#39;button\u0026#39;); console.log(btnArray); console.log(btnArray[0]); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 上面的布局中，有三个 button 标签，我们通过getElementsByTagName获取到的btnArray实际上是伪数组，并不是真实的数组：\n既然btnArray是伪数组，它就不能使用数组的一般方法，否则会报错：\n解决办法：采用Array.from方法将btnArray这个伪数组转换为真数组即可：\n1 Array.from(btnArray); 然后就可以使用数组的一般方法了：\nArray.of()：创建数组 语法：\n1 Array.of(value1, value2, value3); 作用：根据参数里的内容，创建数组。\n举例：\n1 2 const arr = Array.of(1, \u0026#39;abc\u0026#39;, true); console.log(arr); // 打印结果是数组：[1, \u0026#34;abc\u0026#34;, true] 补充：new Array()和 Array.of()的区别在于：当参数只有一个时，前者表示数组的长度，后者表示数组中的内容。\n数组元素的添加和删除 push() push()：向数组的最后面插入一个或多个元素，返回结果为新数组的长度。会改变原数组，因为原数组变成了新数组。\n语法：\n1 新数组的长度 = 数组.push(元素); 代码举例：\n1 2 3 4 5 6 7 8 var arr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; var result1 = arr.push(\u0026#39;王四\u0026#39;); // 末尾插入一个元素 var result2 = arr.push(\u0026#39;王五\u0026#39;, \u0026#39;王六\u0026#39;); // 末尾插入多个元素 console.log(result1); // 打印结果：4 console.log(result2); // 打印结果：6 console.log(JSON.stringify(arr)); // 打印结果：[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;,\u0026#34;王四\u0026#34;,\u0026#34;王五\u0026#34;,\u0026#34;王六\u0026#34;] pop() pop()：删除数组中的最后一个元素，返回结果为被删除的元素。\n语法：\n1 被删除的元素 = 数组.pop(); 代码举例：\n1 2 3 4 5 6 var arr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; var result1 = arr.pop(); console.log(result1); // 打印结果：王三 console.log(JSON.stringify(arr)); // 打印结果：[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;] unshift() unshift()：在数组最前面插入一个或多个元素，返回结果为新数组的长度。会改变原数组，因为原数组变成了新数组。插入元素后，其他元素的索引会依次调整。\n语法：\n1 新数组的长度 = 数组.unshift(元素); 代码举例：\n1 2 3 4 5 6 7 8 var arr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; var result1 = arr.unshift(\u0026#39;王四\u0026#39;); // 最前面插入一个元素 var result2 = arr.unshift(\u0026#39;王五\u0026#39;, \u0026#39;王六\u0026#39;); // 最前面插入多个元素 console.log(result1); // 打印结果：4 console.log(result2); // 打印结果：6 console.log(JSON.stringify(arr)); // 打印结果：[\u0026#34;王五\u0026#34;,\u0026#34;王六\u0026#34;,\u0026#34;王四\u0026#34;,\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] shift() shift()：删除数组中的第一个元素，返回结果为被删除的元素。\n语法：\n1 被删除的元素 = 数组.shift(); 代码举例：\n1 2 3 4 5 6 var arr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; var result1 = arr.shift(); console.log(result1); // 打印结果：王一 console.log(JSON.stringify(arr)); // 打印结果：[\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] slice() slice()：从数组中提取指定的一个或者多个元素，返回结果为新的数组（不会改变原来的数组）。\n备注：该方法不会改变原数组，而是将截取到的元素封装到一个新数组中返回。\n语法：\n1 新数组 = 原数组.slice(开始位置的索引, 结束位置的索引); //注意：包含开始索引，不包含结束索引 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; const result1 = arr.slice(); // 不加参数时，则获取所有的元素。相当于数组的整体赋值 const result2 = arr.slice(2); // 从第二个值开始提取，直到末尾 const result3 = arr.slice(-2); // 提取最后两个元素 const result4 = arr.slice(2, 4); // 提取从第二个到第四个之间的元素（不包括第四个元素） const result5 = arr.slice(4, 2); // 空 console.log(\u0026#39;arr:\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result1:\u0026#39; + JSON.stringify(result1)); console.log(\u0026#39;result2:\u0026#39; + JSON.stringify(result2)); console.log(\u0026#39;result3:\u0026#39; + JSON.stringify(result3)); console.log(\u0026#39;result4:\u0026#39; + JSON.stringify(result4)); console.log(\u0026#39;result5:\u0026#39; + JSON.stringify(result5)); 打印结果：\n1 2 3 4 5 6 arr: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; result1: [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; result2: [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; result3: [\u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; result4: [\u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;]; result5: []; 补充：\n很多前端开发人员会用 slice()将伪数组，转化为真数组。写法如下：\n1 2 3 4 5 // 方式1 array = Array.prototype.slice.call(arrayLike); // 方式2 array = [].slice.call(arrayLike); ES6 看不下去这种蹩脚的转化方法，于是出了一个新的 API：（专门用来将伪数组转化成真数组）\n1 array = Array.from(arrayLike); 关于这个 API 的详细介绍，上面的内容已经讲了，请往前翻。\nsplice() splice()：从数组中删除指定的一个或多个元素，返回结果为被删除元素组成的新数组（会改变原来的数组）。\n备注：该方法会改变原数组，会将指定元素从原数组中删除；被删除的元素会封装到一个新的数组中返回。\n语法：\n1 2 3 4 新数组 = 原数组.splice(起始索引index, 需要删除的个数); 新数组 = 原数组.splice(起始索引index, 需要删除的个数, 新的元素1, 新的元素2...); 上方语法中，第三个及之后的参数，表示：删除元素之后，向原数组中添加新的元素，这些元素将会自动插入到起始位置索引的前面。也可以理解成：删除了哪些元素，就在那些元素的所在位置补充新的内容。\nslice()方法和splice()方法很容易搞混，请一定要注意区分。\n举例 1：\n1 2 3 4 5 var arr1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; var result1 = arr1.splice(1); //从第index为1的位置开始，删除元素 console.log(\u0026#39;arr1：\u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;result1：\u0026#39; + JSON.stringify(result1)); 打印结果：\n1 2 arr1：[\u0026#34;a\u0026#34;] result1：[\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] 举例 2：\n1 2 3 4 5 var arr2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; var result2 = arr2.splice(-2); //删除最后两个元素 console.log(\u0026#39;arr2：\u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;result2：\u0026#39; + JSON.stringify(result2)); 打印结果：\n1 2 arr2：[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;] result2：[\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] 举例 3：\n1 2 3 4 5 var arr3 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; var result3 = arr3.splice(1, 3); //从第index为1的位置开始删除元素,一共删除三个元素 console.log(\u0026#39;arr3：\u0026#39; + JSON.stringify(arr3)); console.log(\u0026#39;result3：\u0026#39; + JSON.stringify(result3)); 打印结果：\n1 2 arr3：[\u0026#34;a\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] result3：[\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;] 举例 4：（我们来看看第三个参数的用法）\n1 2 3 4 5 6 7 var arr4 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; //从第index为1的位置开始删除元素,一共删除三个元素。并且在 index=1 的前面追加两个元素 var result4 = arr4.splice(1, 3, \u0026#39;lvbu\u0026#39;, \u0026#39;vae\u0026#39;); console.log(\u0026#39;arr4：\u0026#39; + JSON.stringify(arr4)); console.log(\u0026#39;result4：\u0026#39; + JSON.stringify(result4)); 打印结果：\n1 2 arr4：[\u0026#34;a\u0026#34;,\u0026#34;lvbu\u0026#34;,\u0026#34;vae\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] result4：[\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;] fill() fill()：用一个固定值填充数组，返回结果为新的数组。不会改变原数组。\n语法：\n1 2 3 4 5 6 7 8 // 用一个固定值填充数组。数组里的每个元素都会被这个固定值填充 新数组 = 数组.fill(固定值); // 从 startIndex 开始的数组元素，用固定值填充 新数组 = 数组.fill(固定值, startIndex); // 从 startIndex 到 endIndex 之间的元素（包左不包右），用固定值填充 新数组 = 数组.fill(固定值, startIndex, endIndex); 举例：\n1 2 3 4 5 6 7 8 // 创建一个长度为4的空数组，然后用 \u0026#39;f\u0026#39; 来填充这个空数组 console.log(Array(4).fill(\u0026#39;f\u0026#39;)); // [\u0026#39;f\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;f,\u0026#39; \u0026#39;f\u0026#39;] // 将现有数组的每一个元素都进行填充 console.log([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;].fill(\u0026#39;f\u0026#39;)); // [\u0026#39;f\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;f,\u0026#39; \u0026#39;f\u0026#39;] // 指定位置进行填充 console.log([\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;].fill(\u0026#39;f\u0026#39;, 1, 3)); // [\u0026#34;a\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;d\u0026#34;] 数组的合并和拆分 concat() concat()：连接两个或多个数组，返回结果为新的数组。不会改变原数组。concat()方法的作用是数组合并。\n语法：\n1 新数组 = 数组1.concat(数组2, 数组3 ...); 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const arr1 = [1, 2, 3]; const arr2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; const arr3 = [\u0026#39;lvbu\u0026#39;, \u0026#39;vae\u0026#39;]; const result1 = arr1.concat(arr2); const result2 = arr2.concat(arr1, arr3); console.log(\u0026#39;arr1 =\u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;arr2 =\u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;arr3 =\u0026#39; + JSON.stringify(arr3)); console.log(\u0026#39;result1 =\u0026#39; + JSON.stringify(result1)); console.log(\u0026#39;result2 =\u0026#39; + JSON.stringify(result2)); 打印结果：\n1 2 3 4 5 6 arr1 = [1, 2, 3]; arr2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; arr3 = [\u0026#39;lvbu\u0026#39;, \u0026#39;vae\u0026#39;]; result1 = [1, 2, 3, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; result2 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, 1, 2, 3, \u0026#39;lvbu\u0026#39;, \u0026#39;vae\u0026#39;]; 从打印结果中可以看到，原数组并没有被修改。\n数组合并的另一种方式：\n我们可以使用...这种展开语法，将两个数组进行合并。举例如下：\n1 2 3 4 const arr1 = [1, 2, 3]; const result = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, ...arr1]; console.log(JSON.stringify(result)); // 打印结果：[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,1,2,3] join() join()：将数组转换为字符串，返回结果为转换后的字符串（不会改变原来的数组）。\n补充：join()方法可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符；如果不指定连接符，则默认使用 , 作为连接符，此时和 toString()的效果是一致的。\n语法：\n1 新的字符串 = 原数组.join(参数); // 参数选填 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 var arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;]; var result1 = arr.join(); // 这里没有指定连接符，所以默认使用 , 作为连接符 var result2 = arr.join(\u0026#39;-\u0026#39;); // 使用指定的字符串作为连接符 console.log(typeof arr); // 打印结果：object console.log(typeof result1); // 打印结果：string console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result1 =\u0026#39; + JSON.stringify(result1)); console.log(\u0026#39;result2 =\u0026#39; + JSON.stringify(result2)); 上方代码中，最后三行的打印结果是：\n1 2 3 arr =[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;] result1 =a,b,c result2 =a-b-c split() 注意，split()是字符串的方法，不是数组的方法。\n语法：\n1 新的数组 = str.split(分隔符); 解释：通过指定的分隔符，将一个字符串拆分成一个数组。不会改变原字符串。\n备注：split()这个方法在实际开发中用得非常多。一般来说，从接口拿到的 json 数据中，经常会收到类似于\u0026quot;q, i, a, n\u0026quot;这样的字符串，前端需要将这个字符串拆分成['q', 'i', 'a', 'n']数组，这个时候split()方法就派上用场了。\nreverse() reverse()：反转数组，返回结果为反转后的数组（会改变原来的数组）。\n语法：\n1 反转后的数组 = 数组.reverse(); 举例：\n1 2 3 4 5 6 var arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;]; var result = arr.reverse(); // 将数组 arr 进行反转 console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果：\n1 2 arr =[\u0026#34;f\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;] result =[\u0026#34;f\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;] 从打印结果可以看出，原来的数组已经被改变了。\nsort()方法 sort()方法需要好好理解。\nsort()：对数组的元素进行从小到大来排序（会改变原来的数组）。\nsort()方法：无参时 如果在使用 sort() 方法时不带参，则默认按照Unicode 编码，从小到大进行排序。\n举例 1：（当数组中的元素为字符串时）\n1 2 3 4 5 6 let arr1 = [\u0026#39;e\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;c\u0026#39;]; let result = arr1.sort(); // 将数组 arr1 进行排序 console.log(\u0026#39;arr1 =\u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果：\n1 2 arr1 =[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] result =[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;f\u0026#34;] 从上方的打印结果中，我们可以看到，sort 方法会改变原数组，而且方法的返回值也是同样的结果。\n举例 2：（当数组中的元素为数字时）\n1 2 3 4 5 6 let arr2 = [5, 2, 11, 3, 4, 1]; let result = arr2.sort(); // 将数组 arr2 进行排序 console.log(\u0026#39;arr2 =\u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果：\n1 2 arr2 =[1,11,2,3,4,5] result =[1,11,2,3,4,5] 上方的打印结果中，你会发现，使用 sort() 排序后，数字11竟然在数字2的前面。这是为啥呢？因为上面讲到了，sort()方法是按照Unicode 编码进行排序的。\n那如果我想让 arr2 里的数字，完全按照从小到大排序，怎么操作呢？继续往下看。\nsort()方法：带参时，自定义排序规则 如果在 sort()方法中带参，我们就可以自定义排序规则。具体做法如下：\n我们可以在 sort()添加一个回调函数，来指定排序规则。回调函数中需要定义两个形参，浏览器将会分别使用数组中的元素作为实参去调用回调函数。\n浏览器根据回调函数的返回值来决定元素的排序：（重要）\n如果返回一个大于 0 的值，则元素会交换位置\n如果返回一个小于 0 的值，则元素位置不变\n如果返回一个等于 0 的值，则认为两个元素相等，则不交换位置\n如果只是看上面的文字，可能不太好理解，我们来看看下面的例子，你肯定就能明白。\n举例：将数组中的数字按照从小到大排序 写法 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 var arr = [5, 2, 11, 3, 4, 1]; // 自定义排序规则 var result = arr.sort(function (a, b) { if (a \u0026gt; b) { // 如果 a 大于 b，则交换 a 和 b 的位置 return 1; } else if (a \u0026lt; b) { // 如果 a 小于 b，则位置不变 return -1; } else { // 如果 a 等于 b，则位置不变 return 0; } }); console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果：\n1 2 arr = [1, 2, 3, 4, 5, 11]; result = [1, 2, 3, 4, 5, 11]; 上方代码的写法太啰嗦了，其实也可以简化为如下写法：\n写法 2：（冒泡排序）\n1 2 3 4 5 6 7 8 9 10 let arr = [5, 2, 11, 3, 4, 1]; // 自定义排序规则 let result = arr.sort(function (a, b) { return a - b; // 升序排列 // return b - a; // 降序排列 }); console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 打印结果不变。\n上方代码还可以写成 ES6 的形式，也就是将 function 改为箭头函数，其写法如下。\n写法 3：（箭头函数）\n1 2 3 4 5 6 7 8 9 let arr = [5, 2, 11, 3, 4, 1]; // 自定义排序规则 let result = arr.sort((a, b) =\u0026gt; { return a - b; // 升序排列 }); console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 上方代码，因为函数体内只有一句话，所以可以去掉 return 语句，继续简化为如下写法。\n写法 4：（推荐）\n1 2 3 4 5 6 7 let arr = [5, 2, 11, 3, 4, 1]; // 自定义排序规则：升序排列 let result = arr.sort((a, b) =\u0026gt; a - b); console.log(\u0026#39;arr =\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;result =\u0026#39; + JSON.stringify(result)); 上面的各种写法中，写法 4 是我们在实战开发中用得最多的。\n为了确保代码的简洁优雅，接下来的代码中，凡是涉及到函数，我们将尽量采用 ES6 中的箭头函数来写。\nsort 方法举例：将数组从小到大排序 将数组从小到大排序，这个例子很常见。但在实际开发中，总会有一些花样。\n下面这段代码，在实际开发中，经常用到，一定要掌握。完整代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; let dataList = [ { title: \u0026#39;品牌鞋子，高品质低价入手\u0026#39;, publishTime: 200, }, { title: \u0026#39;不是很贵，但是很暖\u0026#39;, publishTime: 100, }, { title: \u0026#39;无法拒绝的美食，跟我一起吃吃\u0026#39;, publishTime: 300, }, ]; console.log(\u0026#39;qianguyihao 排序前的数组：\u0026#39; + JSON.stringify(dataList)); // 将dataList 数组，按照 publishTime 字段，从小到大排序。（会改变原数组） dataList.sort((a, b) =\u0026gt; parseInt(a.publishTime) - parseInt(b.publishTime)); console.log(\u0026#39;qianguyihao 排序后的数组：\u0026#39; + JSON.stringify(dataList)); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 qianguyihao 排序前的数组：[ {\u0026#34;title\u0026#34;:\u0026#34;品牌鞋子，高品质低价入手\u0026#34;,\u0026#34;publishTime\u0026#34;:200}, {\u0026#34;title\u0026#34;:\u0026#34;不是很贵，但是很暖\u0026#34;,\u0026#34;publishTime\u0026#34;:100}, {\u0026#34;title\u0026#34;:\u0026#34;无法拒绝的美食，跟我一起吃吃\u0026#34;,\u0026#34;publishTime\u0026#34;:300} ] qianguyihao 排序后的数组：[ {\u0026#34;title\u0026#34;:\u0026#34;不是很贵，但是很暖\u0026#34;,\u0026#34;publishTime\u0026#34;:100}, {\u0026#34;title\u0026#34;:\u0026#34;品牌鞋子，高品质低价入手\u0026#34;,\u0026#34;publishTime\u0026#34;:200}, {\u0026#34;title\u0026#34;:\u0026#34;无法拒绝的美食，跟我一起吃吃\u0026#34;,\u0026#34;publishTime\u0026#34;:300} ] 上方代码中，有人可能会问： publishTime 字段已经是 int 类型了，为啥在排序前还要做一次 parseInt() 转换？这是因为，这种数据，一般是后台接口返回给前端的，数据可能是 int 类型、也可能是字符串类型，所以还是统一先做一次 partInt() 比较保险。这是一种良好的工作习惯。\nindexOf() 和 lastIndexOf()：获取数据的索引 语法 1：\n1 2 3 索引值 = 数组.indexOf(想要查询的元素); 索引值 = 数组.lastIndexOf(想要查询的元素); 备注：indexOf() 是从前向后查找元素的位置。同理，lastIndexOf()是从后向前寻找。\n解释：可以检索一个数组中是否含有指定的元素。如果数组中含有该元素，则会返回其第一次出现的索引；如果没有找到指定的内容，则返回 -1。\n这个方法的作用：\n如果获取的索引值为 0，说明数组是以查询的元素为开头的。\n如果获取的索引值为-1，说明这个数组中没有指定的元素。\n注意：indexOf()在检索时，是严格类型约束，类似于===。\n举例 1：\n1 2 3 4 var arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;c\u0026#39;]; console.log(arr.indexOf(\u0026#39;c\u0026#39;)); //从前往后，找第一个\u0026#34;c\u0026#34;在哪个位置 console.log(arr.lastIndexOf(\u0026#39;d\u0026#39;)); //从后往前，找第一个\u0026#34;d\u0026#34;在哪个位置 打印结果：\n1 2 2 5 举例 2：\n1 2 let arr = [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;]; console.log(arr.indexOf(2)); 打印结果：\n1 -1 语法 2：\n这个方法还可以指定第二个参数，用来指定查找的起始位置。语法如下：\n1 索引值 = 数组.indexOf(想要查询的元素, [起始位置]); 举例 3：（两个参数时，需要特别注意）\n1 2 3 4 let arr = [\u0026#39;q\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;o\u0026#39;]; result = str.indexOf(\u0026#39;a\u0026#39;, 3); // 从第三个位置开始查找 \u0026#39;a\u0026#39;这个元素 【重要】 console.log(result); // 打印结果：9 上方代码中，indexOf()方法中携带了两个参数，具体解释请看注释。\nincludes() 语法：\n1 布尔值 = arr.includes(想要查找的元素, [position]); 解释：判断一个数组中是否包含指定的元素。如果是，则会返回 true；否则返回 false。\n参数中的 position：如果不指定，则默认为0；如果指定，则规定了检索的起始位置。\n1 2 3 4 5 const arr = [11, 12, 13, 14, 15]; console.log(arr.includes(12)); // 打印结果：true console.log(name.includes(20)); // 打印结果：false console.log(name.includes(11, 1)); // 打印结果：false find() 语法：\n1 2 3 find((item, index, arr) =\u0026gt; { return true; }); 作用：找出第一个满足「指定条件返回 true」的元素；如果没找到，则返回 undefined。\n备注：一旦找到符合条件的第一个元素，将不再继续往下遍历。\n举例：\n1 2 3 4 5 6 7 let arr = [2, 3, 2, 5, 7, 6]; let result = arr.find((item, index) =\u0026gt; { return item \u0026gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素返回 }); console.log(result); //打印结果：5 findIndex() 语法：\n1 2 3 findIndex((item, index, arr) =\u0026gt; { return true; }); 作用：找出第一个满足「指定条件返回 true」的元素的 index。\n举例：\n我们直接把上面的代码中的 find 方法改成 findIndex，来看看效果。\n1 2 3 4 5 6 7 let arr = [2, 3, 2, 5, 7, 6]; let result = arr.findIndex((item, index) =\u0026gt; { return item \u0026gt; 4; //遍历数组arr，一旦发现有第一个元素大于4，就把这个元素的index返回 }); console.log(result); //打印结果：3 every() every()：对数组中每一项运行回调函数，如果都返回 true，every 就返回 true；如果有一项返回 false，则停止遍历，此方法返回 false。\n注意：every()方法的返回值是 boolean 值，参数是回调函数。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 var arr1 = [\u0026#39;千古\u0026#39;, \u0026#39;宿敌\u0026#39;, \u0026#39;南山忆\u0026#39;, \u0026#39;素颜\u0026#39;]; var bool1 = arr1.every(function (element, index, array) { if (element.length \u0026gt; 2) { return false; } return true; }); console.log(bool1); //输出结果：false。只要有一个元素的长度是超过两个字符的，就返回false var arr2 = [\u0026#39;千古\u0026#39;, \u0026#39;宿敌\u0026#39;, \u0026#39;南山\u0026#39;, \u0026#39;素颜\u0026#39;]; var bool2 = arr2.every(function (element, index, array) { if (element.length \u0026gt; 2) { return false; } return true; }); console.log(bool2); //输出结果：true。因为每个元素的长度都是两个字符。 some() some()：对数组中每一个元素运行回调函数，只要有一个元素返回 true，则停止遍历，此方法返回 true。\n注意：some()方法的返回值是 boolean 值。\nevery() 和 some() 的使用场景 every() 和 some() 这两个方法，初学者很容易搞混。要怎么区分呢？你可以这样记：\nevery()：全部真，才为真。当你需要让数组中的每一个元素都满足指定条件时，那就使用 every()。\nsome()：一个真，则为真，点到为止。数组中只要有一个元素满足指定条件时，就停止遍历。那就使用 some()。\nvalueOf()：返回数组本身 1 数组本身 = 数组.valueOf(); 这个方法的意义不大。因为我们直接写数组对象的名字，就已经是数组本身了。\n概念：数组的遍历 遍历数组即：获取并操作数组中的每一个元素，然后得到想要的返回结果。在我们的实战开发中，使用得非常频繁。\n遍历数组的方法包括：every()、filter()、forEach()、map()等。\nPS：这几个方法不会修改原数组。\n语法格式：\n1 2 3 4 数组/boolean/无 = 数组.every/filter/forEach/map/some( function(item, index, arr){ 程序和返回值； }) 有了这几种方法，就可以替代一些 for 循环了。下面依次来介绍。\nfor 循环遍历 举例：\n1 2 3 4 5 6 const arr = [\u0026#39;生命壹号\u0026#39;, \u0026#39;许嵩\u0026#39;, \u0026#39;永不止步\u0026#39;]; for (let i = 0; i \u0026lt; arr.length; i++) { console.log(arr[i]); // arr[i]代表的是数组中的每一个元素i } console.log(JSON.stringify(arr)); 打印结果：\n1 2 3 4 5 生命壹号 许嵩 永不止步 [\u0026#34;生命壹号\u0026#34;,\u0026#34;许嵩\u0026#34;,\u0026#34;永不止步\u0026#34;] forEach() 遍历 forEach() 这种遍历方法只支持 IE8 以上的浏览器。IE8 及以下的浏览器均不支持该方法。所以如果需要兼容 IE8，则不要使用 forEach，改为使用 for 循环来遍历即可。\nforEach()方法需要一个函数作为参数。这种函数，是由我们创建但是不由我们调用的，我们称为回调函数。\n数组中有几个元素，该回调函数就会执行几次。\n回调函数中传递三个参数：\n第一个参数，就是当前正在遍历的元素\n第二个参数，就是当前正在遍历的元素的索引\n第三个参数，就是正在遍历的数组\n代码举例：\n1 2 3 4 5 6 7 8 let myArr = [\u0026#39;王一\u0026#39;, \u0026#39;王二\u0026#39;, \u0026#39;王三\u0026#39;]; myArr.forEach((item, index, arr) =\u0026gt; { console.log(\u0026#39;item:\u0026#39; + item); console.log(\u0026#39;index:\u0026#39; + index); console.log(\u0026#39;arr:\u0026#39; + JSON.stringify(arr)); console.log(\u0026#39;----------\u0026#39;); }); 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 12 item:王一 index:0 arr:[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] ---------- item:王二 index:1 arr:[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] ---------- item:王三 index:2 arr:[\u0026#34;王一\u0026#34;,\u0026#34;王二\u0026#34;,\u0026#34;王三\u0026#34;] ---------- 注意，forEach() 没有返回值。也可以理解成：forEach() 的返回值是 undefined。如果你尝试 tempArry = myArr.forEach()这种方式来接收，是达不到效果的。\nforEach() 能不能改变原数组？ forEach() 能不能改变原数组？关于这个问题，大部分人会搞错。我们来看看下面的代码。\n1、数组的元素是基本数据类型：（无法改变原数组）\n1 2 3 4 5 6 let numArr = [1, 2, 3]; numArr.forEach((item) =\u0026gt; { item = item * 2; }); console.log(JSON.stringify(numArr)); // 打印结果：[1, 2, 3] 上面这段代码，你可要看仔细了，打印结果是 [1, 2, 3]，不是 [2, 4, 6]。\n2、数组的元素是引用数据类型：（直接修改整个元素对象时，无法改变原数组）\n1 2 3 4 5 6 7 8 9 10 11 12 let objArr = [ { name: \u0026#39;lvbu\u0026#39;, age: 20 }, { name: \u0026#39;许嵩\u0026#39;, age: 30 }, ]; objArr.forEach((item) =\u0026gt; { item = { name: \u0026#39;邓紫棋\u0026#39;, age: \u0026#39;29\u0026#39;, }; }); console.log(JSON.stringify(objArr)); // 打印结果：[{\u0026#34;name\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;age\u0026#34;:20},{\u0026#34;name\u0026#34;:\u0026#34;许嵩\u0026#34;,\u0026#34;age\u0026#34;:30}] 3、数组的元素是引用数据类型：（修改元素对象里的某个属性时，可以改变原数组）\n1 2 3 4 5 6 7 8 9 let objArr = [ { name: \u0026#39;lvbu\u0026#39;, age: 28 }, { name: \u0026#39;许嵩\u0026#39;, age: 30 }, ]; objArr.forEach((item) =\u0026gt; { item.name = \u0026#39;邓紫棋\u0026#39;; }); console.log(JSON.stringify(objArr)); // 打印结果：[{\u0026#34;name\u0026#34;:\u0026#34;邓紫棋\u0026#34;,\u0026#34;age\u0026#34;:28},{\u0026#34;name\u0026#34;:\u0026#34;邓紫棋\u0026#34;,\u0026#34;age\u0026#34;:30}] 如果你需要通过 forEach 修改原数组，建议用 forEach 里面的参数 2 和参数 3 来做，具体请看下面的标准做法。\n4、forEach() 通过参数 2、参数 3 修改原数组：（标准做法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 1、数组的元素是基本数据类型 let numArr = [1, 2, 3]; numArr.forEach((item, index, arr) =\u0026gt; { arr[index] = arr[index] * 2; }); console.log(JSON.stringify(numArr)); // 打印结果：[2,4,6] // 2、数组的元素是引用数据类型时，直接修改对象 let objArr = [ { name: \u0026#39;lvbu\u0026#39;, age: 28 }, { name: \u0026#39;许嵩\u0026#39;, age: 34 }, ]; objArr.forEach((item, index, arr) =\u0026gt; { arr[index] = { name: \u0026#39;小明\u0026#39;, age: \u0026#39;10\u0026#39;, }; }); console.log(JSON.stringify(objArr)); // 打印结果：[{\u0026#34;name\u0026#34;:\u0026#34;小明\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;10\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;小明\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;10\u0026#34;}] // 3、数组的元素是引用数据类型时，修改对象的某个属性 let objArr2 = [ { name: \u0026#39;lvbu\u0026#39;, age: 28 }, { name: \u0026#39;许嵩\u0026#39;, age: 34 }, ]; objArr2.forEach((item, index, arr) =\u0026gt; { arr[index].name = \u0026#39;小明\u0026#39;; }); console.log(JSON.stringify(objArr2)); // 打印结果：[{\u0026#34;name\u0026#34;:\u0026#34;小明\u0026#34;,\u0026#34;age\u0026#34;:28},{\u0026#34;name\u0026#34;:\u0026#34;小明\u0026#34;,\u0026#34;age\u0026#34;:34}] 总结：\n如果纯粹只是遍历数组，那么，可以用 forEach() 方法。但是，如果你想在遍历数组的同时，去改变数组里的元素内容，那么，最好是用 map() 方法来做，不要用 forEach()方法，避免出现一些低级错误。\n参考链接：\nforEach 到底可以改变原数组吗？\nforEach 会改变原数组值吗\nmap()方法 语法：\n1 2 3 arr.map(function (item, index, arr) { return newItem; }); 解释：对数组中每一项运行回调函数，返回该函数的结果，组成的新数组（返回的是加工之后的新数组）。不会改变原数组。\n作用：对数组中的每一项进行加工。\n举例 1：（拷贝的过程中改变数组元素的值）\n有一个已知的数组 arr1，我要求让 arr1 中的每个元素的值都加 10，这里就可以用到 map 方法。代码举例：\n1 2 3 4 5 6 var arr1 = [1, 3, 6, 2, 5, 6]; var arr2 = arr1.map(function (item, index) { return item + 10; //让arr1中的每个元素加10 }); console.log(arr2); 打印结果：\n举例 2：【重要案例，实际开发中经常用到】\n将 A 数组中某个属性的值，存储到 B 数组中。代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const arr1 = [ { name: \u0026#39;lvbu\u0026#39;, age: \u0026#39;28\u0026#39; }, { name: \u0026#39;许嵩\u0026#39;, age: \u0026#39;32\u0026#39; }, ]; // 将数组 arr1 中的 name 属性，存储到 数组 arr2 中 const arr2 = arr1.map((item) =\u0026gt; item.name); // 将数组 arr1 中的 name、age这两个属性，改一下“键”的名字，存储到 arr3中 const arr3 = arr1.map((item) =\u0026gt; ({ myName: item.name, myAge: item.age, })); // 将数组 arr1 中的 name 属性，存储到 数组 arr2 中 console.log(\u0026#39;arr1:\u0026#39; + JSON.stringify(arr1)); console.log(\u0026#39;arr2:\u0026#39; + JSON.stringify(arr2)); console.log(\u0026#39;arr3:\u0026#39; + JSON.stringify(arr3)); 打印结果：\n1 2 3 4 5 arr1:[{\u0026#34;name\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;28\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;许嵩\u0026#34;,\u0026#34;age\u0026#34;:\u0026#34;32\u0026#34;}] arr2:[\u0026#34;lvbu\u0026#34;,\u0026#34;许嵩\u0026#34;] arr3:[{\u0026#34;myName\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;myAge\u0026#34;:\u0026#34;28\u0026#34;},{\u0026#34;myName\u0026#34;:\u0026#34;许嵩\u0026#34;,\u0026#34;myAge\u0026#34;:\u0026#34;32\u0026#34;}] map 的应用场景，主要就是以上两种。\n注意：map() 方法真的不会改变原数组吗？ 答案：不一定。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const arr = [ { name: \u0026#34;qianguyihao1\u0026#34;, age: 22, }, { name: \u0026#34;qianguyihao2\u0026#34;, age: 23, }, ]; arr.map((item) =\u0026gt; { item.name = \u0026#34;haha\u0026#34;; // 修改 item 里的某个属性 return item; }); console.log(JSON.stringify(arr)); 打印结果：\n1 [{\u0026#34;name\u0026#34;:\u0026#34;haha\u0026#34;,\u0026#34;age\u0026#34;:22},{\u0026#34;name\u0026#34;:\u0026#34;haha\u0026#34;,\u0026#34;age\u0026#34;:23}] 总结：map方法如果是修改整个item的值，则不会改变原数组。但如果是修改 item 里面的某个属性，那就会改变原数组。\nfilter() 语法：\n1 2 3 arr.filter(function (item, index, arr) { return true; }); 解释：对数组中的每一项运行回调函数，该函数返回结果是 true 的项，将组成新的数组（返回值就是这个新的数组）。不会改变原数组。\n作用：对数组进行过滤。\n举例 1：找出数组 arr1 中大于 4 的元素，返回一个新的数组。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 let arr1 = [1, 3, 6, 2, 5, 6]; let arr2 = arr1.filter((item) =\u0026gt; { if (item \u0026gt; 4) { return true; // 将arr1中大于4的元素返回，组成新的数组 } return false; }); console.log(JSON.stringify(arr1)); // 打印结果：[1,3,6,2,5,6] console.log(JSON.stringify(arr2)); // 打印结果：[6,5,6] 上方代码更简洁的写法如下：\n1 2 3 4 5 6 let arr1 = [1, 3, 6, 2, 5, 6]; let arr2 = arr1.filter((item) =\u0026gt; item \u0026gt; 4); // 将arr1中大于4的元素返回，组成新的数组 console.log(JSON.stringify(arr1)); // 打印结果：[1,3,6,2,5,6] console.log(JSON.stringify(arr2)); // 打印结果：[6,5,6] 举例 2：\n获取数组 A 中指定类型的对象，放到数组 B 中。代码举例如下：\n1 2 3 4 5 6 7 8 9 const arr1 = [ { name: \u0026#39;许嵩\u0026#39;, type: \u0026#39;一线\u0026#39; }, { name: \u0026#39;周杰伦\u0026#39;, type: \u0026#39;过气\u0026#39; }, { name: \u0026#39;邓紫棋\u0026#39;, type: \u0026#39;一线\u0026#39; }, ]; const arr2 = arr1.filter((item) =\u0026gt; item.type == \u0026#39;一线\u0026#39;); // 筛选出一线歌手 console.log(JSON.stringify(arr2)); 打印结果：\n1 2 3 4 [ { name: \u0026#39;许嵩\u0026#39;, type: \u0026#39;一线\u0026#39; }, { name: \u0026#39;邓紫棋\u0026#39;, type: \u0026#39;一线\u0026#39; }, ]; reduce()方法 reduce() 语法 reduce 的发音：[rɪ\u0026rsquo;djuːs]。中文含义是减少，但这个方法跟“减少”没有任何关系。\nreduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。返回值是回调函数累计处理的结果。\n语法：\n1 arr.reduce(function (previousValue, currentValue, currentIndex, arr) {}, initialValue); 参数解释：\npreviousValue：必填，上一次调用回调函数时的返回值\ncurrentValue：必填，当前正在处理的数组元素\ncurrentIndex：选填，当前正在处理的数组元素下标\narr：选填，调用 reduce()方法的数组\ninitialValue：选填，可选的初始值（作为第一次调用回调函数时传给 previousValue 的值）\n在以往的数组方法中，匿名的回调函数里是传三个参数：item、index、arr。但是在 reduce() 方法中，前面多传了一个参数previousValue，这个参数的意思是上一次调用回调函数时的返回值。第一次执行回调函数时，previousValue 没有值怎么办？可以用 initialValue 参数传给它。\n备注：绝大多数人在一开始接触 reduce() 的时候会很懵逼，但是没关系，有事没事多看几遍，自然就掌握了。如果能熟练使用 reduce() 的用法，将能替代很多其他的数组方法，并逐渐走上进阶之路，领先于他人。\n为了方便理解 reduce()，我们先来看看下面的简单代码，过渡一下：\n1 2 3 4 5 6 7 8 let arr1 = [1, 2, 3, 4, 5, 6]; arr1.reduce((prev, item) =\u0026gt; { console.log(prev); console.log(item); console.log(\u0026#39;------\u0026#39;); return 88; }, 0); 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 0 1 ------ 88 2 ------ 88 3 ------ 88 4 ------ 88 5 ------ 88 6 ------ 上面的代码中，由于return的是固定值，所以 prev 打印的也是固定值（只有初始值是 0，剩下的遍历中，都是打印 88）。\n现在来升级一下，实际开发中，prev 的值往往是动态变化的，这便是 reduce()的精妙之处。我们来看几个例子就明白了。\nreduce() 的常见应用 举例 1、求和：\n计算数组中所有元素项的总和。代码实现：\n1 2 3 4 5 6 7 const arr = [2, 0, 1, 9, 6]; // 数组求和 const total = arr.reduce((prev, item) =\u0026gt; { return prev + item; }); console.log(\u0026#39;total:\u0026#39; + total); // 打印结果：18 举例 2、统计某个元素出现的次数：\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 定义方法：统一 value 这个元素在数组 arr 中出现的次数 function repeatCount(arr, value) { if (!arr || arr.length == 0) return 0; return arr.reduce((totalCount, item) =\u0026gt; { totalCount += item == value ? 1 : 0; return totalCount; }, 0); } let arr1 = [1, 2, 6, 5, 6, 1, 6]; console.log(repeatCount(arr1, 6)); // 打印结果：3 举例 3、求元素的最大值：\n代码实现：\n1 2 3 4 5 6 7 const arr = [2, 0, 1, 9, 6]; // 数组求最大值 const maxValue = arr.reduce((prev, item) =\u0026gt; { return prev \u0026gt; item ? prev : item; }); console.log(maxValue); // 打印结果：9 参考链接：\nJS reduce 函数 数组练习 splice()练习：数组去重 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //创建一个数组 var arr = [1, 2, 3, 2, 2, 1, 3, 4, 2, 5]; //去除数组中重复的数字 //获取数组中的每一个元素 for (var i = 0; i \u0026lt; arr.length; i++) { //console.log(arr[i]); /*获取当前元素后的所有元素*/ for (var j = i + 1; j \u0026lt; arr.length; j++) { //console.log(\u0026#34;----\u0026gt;\u0026#34;+arr[j]); //判断两个元素的值是否相等 if (arr[i] == arr[j]) { //如果相等则证明出现了重复的元素，则删除j对应的元素 arr.splice(j, 1); //当删除了当前j所在的元素以后，后边的元素会自动补位 //此时将不会在比较这个元素，我需要再比较一次j所在位置的元素 //使j自减 j--; } } } console.log(arr); 清空数组 清空数组，有以下几种方式：\n1 2 3 4 5 var array = [1, 2, 3, 4, 5, 6]; array.splice(0); //方式1：删除数组中所有项目 array.length = 0; //方式2：length属性可以赋值，在其它语言中length是只读 array = []; //方式3：推荐 join() 练习 问题：将一个字符串数组输出为|分割的形式，比如“千古|宿敌|素颜”。使用两种方式实现。\n答案：\n方式 1：（不推荐）\n1 2 3 4 5 6 7 8 var arr = [\u0026#39;千古\u0026#39;, \u0026#39;宿敌\u0026#39;, \u0026#39;素颜\u0026#39;]; var str = arr[0]; var separator = \u0026#39;|\u0026#39;; for (var i = 1; i \u0026lt; arr.length; i++) { str += separator + arr[i]; //从第1个数组元素开始，每个元素前面加上符号\u0026#34;|\u0026#34; } console.log(str); 输出结果：\n不推荐这种方式，因为：由于字符串的不变性，str 拼接过多的话，容易导致内存溢出（很多个 str 都堆放在栈里）。\n方式 2：（推荐。通过 array 数组自带的 api 来实现）\n1 2 3 var arr = [\u0026#39;千古\u0026#39;, \u0026#39;宿敌\u0026#39;, \u0026#39;素颜\u0026#39;]; console.log(arr.join(\u0026#39;|\u0026#39;)); 结果：\nreverse() 练习 题目：将一个字符串数组的元素的顺序进行反转，使用两种种方式实现。提示：第 i 个和第 length-i-1 个进行交换。\n答案：\n方式 1：\n1 2 3 4 5 6 7 function reverse(array) { var newArr = []; for (var i = array.length - 1; i \u0026gt;= 0; i--) { newArr[newArr.length] = array[i]; } return newArr; } 方式 2：（算法里比较常见的方式）\n1 2 3 4 5 6 7 8 function reverse(array) { for (var i = 0; i \u0026lt; array.length / 2; i++) { var temp = array[i]; array[i] = array[array.length - 1 - i]; array[array.length - 1 - i] = temp; } return array; } 方式 3：（数组自带的 reverse 方法）\n现在我们学习了数组自带的 api，我们就可以直接使用 reverse()方法。\n练习 问题：找到数组[\u0026ldquo;c\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;z\u0026rdquo;,\u0026ldquo;a\u0026rdquo;,\u0026ldquo;x\u0026rdquo;,\u0026ldquo;a\u0026rdquo;]中每一个元素出现的次数。\n分析：这道题建议用 json 数据来做，因为我们想知道 a 出现了几次，c 出现了几次，x 出现了几次。恰好k:v .. k:v这种键值对的形式就比数组方便很多了。\n键值对的形式：用 key 代表数组中的元素，用 value 代表元素出现的次数。\n略难，答案暂略。\n练习：数组去重 问题：编写一个方法去掉一个数组中的重复元素。\n分析：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。\n答案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 编写一个方法 去掉一个数组的重复元素 var arr = [1, 2, 3, 4, 5, 2, 3, 4]; console.log(arr); var aaa = fn(arr); console.log(aaa); //思路：创建一个新数组，循环遍历，只要新数组中有老数组的值，就不用再添加了。 function fn(array) { var newArr = []; for (var i = 0; i \u0026lt; array.length; i++) { //开闭原则 var bool = true; //每次都要判断新数组中是否有旧数组中的值。 for (var j = 0; j \u0026lt; newArr.length; j++) { if (array[i] === newArr[j]) { bool = false; } } if (bool) { newArr[newArr.length] = array[i]; } } return newArr; } ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/17-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95/","summary":"数组的方法清单 数组的类型相关 方法 描述 备注 Array.isArray() 判断是否为数组 toString() 将数组转换为字符串 Array.from(arrayLike) 将伪数组转化为真数组 Array.of(value1, value2, value3) 创建数组：将一系列值转换成数组 注意，","title":"17-数组的常见方法"},{"content":"前言 关于函数的核心内容：\n函数有哪几种定义和调用方式\nthis：函数内部的 this 指向、如何改变 this 的指向。\n函数的严格模式\n高阶函数：函数作为参数传递、函数作为返回值传递\n闭包：闭包的作用\n递归：递归的两个条件\n深拷贝和浅拷贝的区别\n函数的介绍 函数：就是将一些功能或语句进行封装，在需要的时候，通过调用的形式，执行这些语句。\n函数也是一个对象\n使用typeof检查一个函数对象时，会返回function\n函数的作用：\n将大量重复的语句抽取出来，写在函数里，以后需要这些语句的时候，可以直接调用函数，避免重复劳动。\n简化编程，让编程模块化。高内聚、低耦合。\n来看个例子：\n1 2 3 4 5 6 7 8 console.log(\u0026#34;你好\u0026#34;); sayHello();\t// 调用函数 // 定义函数 function sayHello(){ console.log(\u0026#34;欢迎\u0026#34;); console.log(\u0026#34;welcome\u0026#34;); } 函数的定义/声明 方式一：利用函数关键字自定义函数（命名函数） 使用函数声明来创建一个函数（也就是 function 关键字）。语法：\n1 2 3 function 函数名([形参1,形参2...形参N]){ // 备注：语法中的中括号，表示“可选” 语句... } 举例：\n1 2 3 function fun1(a, b){ return a+b; } 解释如下：\nfunction：是一个关键字。中文是“函数”、“功能”。\n函数名字：命名规定和变量的命名规定一样。只能是字母、数字、下划线、美元符号，不能以数字开头。\n参数：可选。\n大括号里面，是这个函数的语句。\nPS：在有些编辑器中，方法写完之后，我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。\n方式二：函数表达式（匿名函数） 使用函数表达式来创建一个函数。语法：\n1 2 3 var 变量名 = function([形参1,形参2...形参N]){ 语句.... } 举例：\n1 2 3 var fun2 = function() { console.log(\u0026#34;我是匿名函数中封装的代码\u0026#34;); }; 解释如下：\n上面的 fun2 是变量名，不是函数名。\n函数表达式的声明方式跟声明变量类似，只不过变量里面存的是值，而函数表达式里面存的是函数。\n函数表达式也可以传递参数。\n从方式二的举例中可以看出：所谓的“函数表达式”，其实就是将匿名函数赋值给一个变量。\n方式三：使用构造函数 new Function() 使用构造函数new Function()来创建一个对象。这种方式，用的少。\n语法：\n1 var 变量名/函数名 = new Function(\u0026#39;形参1\u0026#39;, \u0026#39;形参2\u0026#39;, \u0026#39;函数体\u0026#39;); 注意，Function 里面的参数都必须是字符串格式。也就是说，形参也必须放在字符串里；函数体也是放在字符串里包裹起来，放在 Function 的最后一个参数的位置。\n代码举例：\n1 2 3 var fun3 = new Function(\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;console.log(\u0026#34;我是函数内部的内容\u0026#34;); console.log(a + b);\u0026#39;); fun3(1, 2); // 调用函数 打印结果：\n1 2 我是函数内部的内容 3 分析：\n方式3的写法很少用，原因如下：\n不方便书写：写法过于啰嗦和麻烦。\n执行效率较低：首先需要把字符串转换为 js 代码，然后再执行。\n总结 1、所有的函数，都是 Fuction 的“实例”（或者说是“实例对象”）。函数本质上都是通过 new Function 得到的。\n2、函数既然是实例对象，那么，函数也属于“对象”。还可以通过如下特征，来佐证函数属于对象：\n（1）我们直接打印某一个函数，比如 console.log(fun2)，发现它的里面有__proto__。（这个是属于原型的知识，后续再讲）\n（2）我们还可以打印 console.log(fun2 instanceof Object)，发现打印结果为 true。这说明 fun2 函数就是属于 Object。\n函数的调用 方式1：普通函数的调用 函数调用的语法：\n1 函数名(); 或者：\n1 函数名.call(); 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 function fn1() { console.log(\u0026#39;我是函数体里面的内容1\u0026#39;); } function fn2() { console.log(\u0026#39;我是函数体里面的内容2\u0026#39;); } fn1(); // 调用函数 fn2.call(); // 调用函数 方式2：通过对象的方法来调用 1 2 3 4 5 6 7 8 var obj = { a: \u0026#39;qianguyihao\u0026#39;, fn2: function() { console.log(\u0026#39;lvbu，永不止步!\u0026#39;); }, }; obj.fn2(); // 调用函数 如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。\nPS：关于函数和方法的区别，本文的后续内容里有讲到，可以往下面翻。\n方式3：立即执行函数 代码举例：\n1 2 3 (function() { console.log(\u0026#39;我是立即执行函数\u0026#39;); })(); 立即执行函数在定义后，会自动调用。\nPS：关于立即执行函数，本文的后续内容里有讲到，可以往下面翻。\n上面讲到的这三种方式，是用得最多的。接下来讲到的三种方式，暂时看不懂也没关系，可以等学完其他的知识点，再回过头来看。\n方式4：通过构造函数来调用 代码举例：\n1 2 3 4 5 function Fun3() { console.log(\u0026#39;lvbu，永不止步~\u0026#39;); } new Fun3(); 这种方式用得不多。\n方式5：绑定事件函数 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;btn\u0026#34;\u0026gt;我是按钮，请点击我\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementById(\u0026#39;btn\u0026#39;); //2.绑定事件 btn.onclick = function() { console.log(\u0026#39;点击按钮后，要做的事情\u0026#39;); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里涉及到DOM操作和事件的知识点，后续再讲。\n方式6：定时器函数 代码举例：（每间隔一秒，将 数字 加1）\n1 2 3 4 5 let num = 1; setInterval(function () { num ++; console.log(num); }, 1000); 这里涉及到定时器的知识点。\n函数的参数：形参和实参 函数的参数包括形参和实参。先来看下面的图就很好懂了：\n形参：\n概念：形式上的参数。定义函数时传递的参数，当时并不知道是什么值。\n定义函数时，可以在函数的()中来指定一个或多个形参。\n多个形参之间使用,隔开，声明形参就相当于在函数内部声明了对应的变量，但是并不赋值。\n实参：\n概念：实际上的参数。调用函数时传递的参数，实参将会传递给函数中对应的形参。\n在调用函数时，可以在函数的 ()中指定实参。\n注意：实际参数和形式参数的个数，一般要相同。\n举例：\n1 2 3 4 5 6 7 8 9 // 调用函数 sum(3,4); sum(\u0026#34;3\u0026#34;,4); sum(\u0026#34;Hello\u0026#34;,\u0026#34;World\u0026#34;); // 定义函数：求和 function sum(a, b) { console.log(a + b); } 控制台输出结果：\n1 2 3 7 34 helloworld 实参的类型 函数的实参可以是任意的数据类型。\n调用函数时，解析器不会检查实参的类型，所以要注意，是否有可能会接收到非法的参数，如果有可能则需要对参数进行类型的检查。\n实参的数量（实参和形参的个数不匹配时） 调用函数时，解析器也不会检查实参的数量。\n如果实参的数量多余形参的数量，多余实参不会被赋值。\n如果实参的数量少于形参的数量，多余的形参会被定义为 undefined。表达式的运行结果为 NaN。\n代码举例：\n1 2 3 4 5 6 7 function sum(a, b) { console.log(a + b); } sum(1, 2); sum(1, 2, 3); sum(1); 打印结果：\n1 2 3 4 5 3 3 NaN 注意：在 JS 中，形参的默认值是 undefined。\n函数的返回值 举例：\n1 2 3 4 5 6 console.log(sum(3, 4)); // 将函数的返回值打印出来 //函数：求和 function sum(a, b) { return a + b; } return 的作用是结束方法（终止函数）。\n注意：\nreturn 的值将会作为函数的执行结果返回，可以定义一个变量，来接收该结果。\n在函数中，return后的语句都不会执行（函数在执行完 return 语句之后停止并立即退出函数）\n如果return语句后不跟任何值，就相当于返回一个undefined\n如果函数中不写return，则也会返回undefined\n返回值可以是任意的数据类型，可以是对象，也可以是函数。\nreturn 只能返回一个值。如果用逗号隔开多个值，则以最后一个为准。\n函数名、函数体和函数加载问题（重要，请记住） 我们要记住：函数名 == 整个函数。举例：\n1 2 3 4 5 6 console.log(fn) == console.log(function fn(){alert(1)}); //定义fn方法 function fn(){ alert(1) }; 我们知道，当我们在调用一个函数时，通常使用函数()这种格式；可如果，我们是直接使用函数这种格式，它的作用相当于整个函数。\n函数的加载问题：JS加载的时候，只加载函数名，不加载函数体。所以如果想使用内部的成员变量，需要调用函数。\nfn() 和 fn 的区别【重要】 fn()：调用函数。调用之后，还获取了函数的返回值。\nfn：函数对象。相当于直接获取了整个函数对象。\nbreak、continue、return 的区别 break ：结束当前的循环体（如 for、while）\ncontinue ：跳出本次循环，继续执行下次循环（如 for、while）\nreturn ：1、退出循环。2、返回 return 语句中的值，同时结束当前的函数体内的代码，退出当前函数。\n立即执行函数 现有匿名函数如下：\n1 2 3 4 function(a, b) { console.log(\u0026#34;a = \u0026#34; + a); console.log(\u0026#34;b = \u0026#34; + b); }; 立即执行函数如下：\n1 2 3 4 (function(a, b) { console.log(\u0026#34;a = \u0026#34; + a); console.log(\u0026#34;b = \u0026#34; + b); })(123, 456); 立即执行函数：函数定义完，立即被调用，这种函数叫做立即执行函数。\n立即执行函数往往只会执行一次。为什么呢？因为没有变量保存它，执行完了之后，就找不到它了。\n方法 函数也可以成为对象的属性。如果一个函数是作为一个对象的属性保存，那么，我们称这个函数是这个对象的方法。\n调用这个函数就说调用对象的方法（method）。函数和方法，有什么本质的区别吗？它只是名称上的区别，并没有其他的区别。\n函数举例：\n1 2 // 调用函数 fn(); 方法举例：\n1 2 // 调用方法 obj.fn(); 我们可以这样说，如果直接是fn()，那就说明是函数调用。如果是XX.fn()的这种形式，那就说明是方法调用。\n类数组 arguments 这部分，小白可能看不懂。所以，这一段，暂时可以忽略。\n在调用函数时，浏览器每次都会传递进两个隐含的参数：\n1.函数的上下文对象 this\n2.封装实参的对象 arguments\n例如：\n1 2 3 4 5 6 function foo() { console.log(arguments); console.log(typeof arguments); } foo(); arguments 是一个类数组对象，它可以通过索引来操作数据，也可以获取长度。\narguments 代表的是实参。在调用函数时，我们所传递的实参都会在 arguments 中保存。有个讲究的地方是：arguments只在函数中使用。\n1、返回函数实参的个数：arguments.length arguments.length 可以用来获取实参的长度。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 fn(2, 4); fn(2, 4, 6); fn(2, 4, 6, 8); function fn(a, b) { console.log(arguments); console.log(fn.length); //获取形参的个数 console.log(arguments.length); //获取实参的个数 console.log(\u0026#39;----------------\u0026#39;); } 打印结果：\n我们即使不定义形参，也可以通过 arguments 来使用实参（只不过比较麻烦）：arguments[0] 表示第一个实参、arguments[1] 表示第二个实参\u0026hellip;\n2、返回正在执行的函数：arguments.callee arguments 里边有一个属性叫做 callee，这个属性对应一个函数对象，就是当前正在指向的函数对象。\n1 2 3 4 5 function fun() { console.log(arguments.callee == fun); //打印结果为true } fun(\u0026#39;hello\u0026#39;); 在使用函数递归调用时，推荐使用 arguments.callee 代替函数名本身。\n3、arguments 可以修改元素 之所以说 arguments 是伪数组，是因为：arguments 可以修改元素，但不能改变数组的长短。举例：\n1 2 3 4 5 6 7 8 fn(2, 4); fn(2, 4, 6); fn(2, 4, 6, 8); function fn(a, b) { arguments[0] = 99; //将实参的第一个数改为99 arguments.push(8); //此方法不通过，因为无法增加元素 } arguments 的使用 当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象（只有函数才有 arguments 对象），arguments 对象中存储了传递的所有实参.\narguments的展示形式是一个伪数组。伪数组具有以下特点：\n可以进行遍历；具有数组的 length 属性。\n按索引方式存储数据。\n不具有数组的 push()、pop() 等方法。\n代码举例：利用 arguments 求函数实参中的最大值\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 function getMaxValue() { var max = arguments[0]; // 通过 arguments 遍历实参 for (var i = 0; i \u0026lt; arguments.length; i++) { if (max \u0026lt; arguments[i]) { max = arguments[i]; } } return max; } console.log(getMaxValue(1, 3, 7, 5)); ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/18-%E5%87%BD%E6%95%B0/","summary":"前言 关于函数的核心内容： 函数有哪几种定义和调用方式 this：函数内部的 this 指向、如何改变 this 的指向。 函数的严格模式 高阶函数：函数作为参数传递、函","title":"18-函数"},{"content":" 作用域、变量提升的知识点，面试时会经常遇到。\n作用域（Scope）的概念 概念：通俗来讲，作用域是一个变量或函数的作用范围。作用域在函数定义时，就已经确定了。\n目的：为了提高程序的可靠性，同时减少命名冲突。\n作用域的分类 在 JS 中，一共有两种作用域：（ES6 之前）\n全局作用域：作用于整个 script 标签内部，或者作用域一个独立的 JS 文件。\n函数作用域（局部作用域）：作用于函数内的代码环境。\n作用域的访问关系 在内部作用域中可以访问到外部作用域的变量，在外部作用域中无法访问到内部作用域的变量。\n代码举例：\n1 2 3 4 5 6 7 8 var a = \u0026#39;aaa\u0026#39;; function foo() { var b = \u0026#39;bbb\u0026#39;; console.log(a); // 打印结果：aaa。说明 内层作用域 可以访问 外层作用域 里的变量 } foo(); console.log(b); // 报错：Uncaught ReferenceError: b is not defined。说明 外层作用域 无法访问 内层作用域 里的变量 变量的作用域 根据作用域的不同，变量可以分为两类：全局变量、布局变量。\n全局变量：\n在全局作用域下声明的变量，叫「全局变量」。在全局作用域的任何一地方，都可以访问这个变量。\n在全局作用域下，使用 var 声明的变量是全局变量。\n特殊情况：在函数内不使用 var 声明的变量也是全局变量（不建议这么用）。\n局部变量：\n定义在函数作用域的变量，叫「局部变量」。\n在函数内部，使用 var 声明的变量是局部变量。\n函数的形参也是属于局部变量。\n从执行效率来看全局变量和局部变量：\n全局变量：只有浏览器关闭时才会被销毁，比较占内存。\n局部变量：当其所在的代码块运行结束后，就会被销毁，比较节约内存空间。\n作用域的上下级关系 当在函数作用域操作一个变量时，它会先在自身作用域中寻找，如果有就直接使用（就近原则）。如果没有则向上一级作用域中寻找，直到找到全局作用域；如果全局作用域中依然没有找到，则会报错 ReferenceError。\n在函数中要访问全局变量可以使用window对象。（比如说，全局作用域和函数作用域都定义了变量a，如果想访问全局变量，可以使用window.a）\n全局作用域 直接编写在script标签中的JS代码，都在全局作用域。\n全局作用域在页面打开时创建，在页面关闭时销毁。\n在全局作用域中有一个全局对象window，它代表的是一个浏览器的窗口，由浏览器创建，我们可以直接使用。\n在全局作用域中：\n创建的变量都会作为window对象的属性保存。比如在全局作用域内写 var a = 100，这里的 a 等价于 window.a。\n创建的函数都会作为window对象的方法保存。\n变量的声明提前（变量提升） 使用var关键字声明的变量（ 比如 var a = 1），会在所有的代码执行之前被声明（但是不会赋值），但是如果声明变量时不是用var关键字（比如直接写a = 1），则变量不会被声明提前。\n举例1：\n1 2 console.log(a); var a = 123; 打印结果：undefined。注意，打印结果并没有报错，而是 undefined，说明变量 a 被提前声明了，只是尚未被赋值。\n举例2：\n1 2 console.log(a); a = 123; //此时a相当于window.a 程序会报错：Uncaught ReferenceError: a is not defined。\n举例3：\n1 2 a = 123; //此时a相当于window.a console.log(a); 打印结果：123。\n举例4：\n1 2 3 4 5 6 7 8 foo(); function foo() { if (false) { var i = 123; } console.log(i); } 打印结果：undefined。注意，打印结果并没有报错，而是 undefined。这个例子，再次说明了：变量 i 在函数执行前，就被提前声明了，只是尚未被赋值。\n例4中， if(false)里面的代码虽然不会被执行，但是整个代码有解析的环节，解析的时候就已经把 变量 i 给提前声明了。\n总结：\n既然JS中存在变量提升的现象，那么，在实战开发中，为了避免出错，建议先声明一个变量，然后再使用这个变量。\n函数的声明提前 函数声明：\n使用函数声明的形式创建的函数function foo(){}，会被声明提前。\n也就是说，整个函数会在所有的代码执行之前就被创建完成。所以，在代码顺序里，我们可以先调用函数，再定义函数。\n代码举例：\n1 2 3 4 5 fn1(); // 虽然 函数 fn1 的定义是在后面，但是因为被提前声明了， 所以此处可以调用函数 function fn1() { console.log(\u0026#39;我是函数 fn1\u0026#39;); } 函数表达式：\n使用函数表达式创建的函数var foo = function(){}，不会被声明提前，所以不能在声明前调用。\n很好理解，因为此时foo被声明了（这里只是变量声明），且为undefined，并没有把 function(){} 赋值给 foo。\n所以说，下面的例子，会报错：\n函数作用域 提醒1：在函数作用域中，也有声明提前的特性：\n函数中，使用var关键字声明的变量，会在函数中所有的代码执行之前被声明。\n函数中，没有var声明的变量都是全局变量，而且并不会提前声明。\n举例：\n1 2 3 4 5 6 7 8 9 var a = 1; function foo() { console.log(a); a = 2; // 此处的a相当于window.a } foo(); console.log(a); //打印结果是2 上方代码中，执行foo()后，函数里面的打印结果是1。如果去掉第一行代码，执行foo()后，函数里面的打印结果是Uncaught ReferenceError: a is not defined。\n提醒2：定义形参就相当于在函数作用域中声明了变量。\n1 2 3 4 5 6 function fun6(e) { // 这个函数中，因为有了形参 e，此时就相当于在函数内部的第一行代码里，写了 var e; console.log(e); } fun6(); //打印结果为 undefined fun6(123);//打印结果为123 JavaScript 没有块级作用域（ES6之前） 在其他编程语言中（如 Java、C#等），存在块级作用域，由{}包括起来。比如在 Java 语言中，if 语句里创建的变量，只能在if语句内部使用：\n1 2 3 4 5 if(true){ int num = 123; system.out.print(num); // 123 } system.out.print(num); // 报错 但是，在 JS 中没有块级作用域（ES6之前）。举例如下：\n1 2 3 4 5 6 if(true){ var num = 123; console.log(123); //123 } console.log(123); //123（可以正常打印） 作用域链 引入：\n只要是代码，就至少有一个作用域\n写在函数内部的局部作用域\n如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域\n基于上面几条内容，我们可以得出作用域链的概念。\n作用域链：内部函数访问外部函数的变量，采用的是链式查找的方式来决定取哪个值，这种结构称之为作用域链。查找时，采用的是就近原则。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var num = 10; function fn() { // 外部函数 var num = 20; function fun() { // 内部函数 console.log(num); } fun(); } fn(); 打印结果：20。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/19-%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/","summary":"作用域、变量提升的知识点，面试时会经常遇到。 作用域（Scope）的概念 概念：通俗来讲，作用域是一个变量或函数的作用范围。作用域在函数定义时，","title":"19-作用域和变量提升"},{"content":" 我们在上一篇文章《作用域》中简单讲过“变量提升”，今天来讲一下预编译，这对我们深入理解变量提升会有帮助。\nJavaScript 运行三部曲 语法分析\n预编译\n解释执行\n预编译前奏 在讲预编译前，我们先来普及下面两个规律。\n两个规律 规律1：任何变量，如果未经声明就赋值，此变量是属于 window 的属性，而且不会做变量提升。（注意，无论在哪个作用域内赋值）\n比如说，如果我们直接在代码里写 console.log(a)，这肯定会报错的，提示找不到 a。但如果我直接写 a = 100，这就不会报错，此时，这个 a 就是 window.a。\n规律2：一切声明的全局变量，全是window的属性。（注意，我说的是在全局作用域内声明的全局变量，不是说局部变量）\n比如说，当我定义 var a = 200 时，这此时这个 a 就是 window.a。\n由此，我们可以看出：window 代表了全局作用域（是说「代表」，没说「等于」）。\n举例 掌握了上面两句话之后，我们再来看看下面的例子。\n1 2 3 4 5 6 7 8 9 10 11 function foo() { var a = b = 100; // 连续赋值 } foo(); console.log(window.b); // 在全局范围内访问 b console.log(b); // 在全局范围内访问 b，但是前面没有加 window 这个关键字 console.log(window.a); // 在全局范围内访问 a console.log(a); // 在全局范围内访问 a，但是前面没有加 window 这个关键字 上方代码的打印结果：\n1 2 3 4 5 6 7 100 100 undefined （会报错，提示 Uncaught ReferenceError: a is not defined） 解释：\n当执行了foo()函数之后， var a = b = 100 这行连续赋值的代码等价于 var a = (b = 100)，其执行顺序是：\n（1）先把 100 赋值给 b；\n（2）再声明变量 a；\n（3）再把 b 的值赋值给 a。\n我们可以看到，b 是未经声明的变量就被赋值了，此时，根据规律1，这个 b 是属于 window.b；而 a 的作用域仅限于 foo() 函数内部，不属于 window。所以也就有了这样的打印结果。\n预编译 函数预编译的步骤 函数预编译，发生在函数执行的前一刻。\n（1）创建AO对象。AO即 Activation Object 活跃对象，其实就是「执行期上下文」。\n（2）找形参和变量声明，将形参名和变量作为 AO 的属性名，值为undefined。\n（3）将实参值和形参统一，实参的值赋给形参。\n（4）查找函数声明，函数名作为 AO 对象的属性名，值为整个函数体。\n这个地方比较难理解。但只有了解了函数的预编译，才能理解明白函数的执行顺序。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function fn(a) { console.log(a); var a = 666; console.log(a); function a() {} console.log(a); var b = function() {}; console.log(b); function c() {} } fn(1); 打印结果：\n1 2 3 4 ƒ a() {} 666 666 ƒ () {} 参考链接 JavaScript预编译原理分析：https://blog.csdn.net/q1056843325/article/details/52951114\nhttps://segmentfault.com/a/1190000018001871\n预编译及变量提升：https://juejin.im/post/5aa6693df265da23884cb571\nhttps://juejin.im/post/5adaf8215188256712781830\nhttps://www.qqzmly.com/archives/1521\n宏任务\u0026amp;微任务相关：https://segmentfault.com/a/1190000018134157\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/20-%E9%A2%84%E7%BC%96%E8%AF%91/","summary":"我们在上一篇文章《作用域》中简单讲过“变量提升”，今天来讲一下预编译，这对我们深入理解变量提升会有帮助。 JavaScript 运行三部曲 语法分析 预编译 解释执行 预","title":"20-预编译"},{"content":"执行期上下文 当函数执行时（准确来说，是在函数发生预编译的前一刻），会创建一个执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环境。\n每调用一次函数，就会创建一个新的上下文对象，他们之间是相互独立且独一无二的。当函数执行完毕，它所产生的执行期上下文会被销毁。\n参考链接：https://www.cnblogs.com/chenyingjie1207/p/9966036.html\nthis 解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是 this，this 指向的是一个对象，这个对象我们称为函数执行的 上下文对象。\n函数内 this 的指向【非常重要】 我们在《JavaScript 基础/函数.md》这篇文章讲过，函数的调用有六种形式。\n根据函数的调用方式的不同，this 会指向不同的对象：\n1.以函数的形式（包括普通函数、定时器函数、立即执行函数）调用时，this 的指向永远都是 window。比如fun();相当于window.fun();\n2.以方法的形式调用时，this 指向调用方法的那个对象\n3.以构造函数的形式调用时，this 指向实例对象\n4.以事件绑定函数的形式调用时，this 指向绑定事件的对象\n5.使用 call 和 apply 调用时，this 指向指定的那个对象\n针对第 1 条的举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function fun() { console.log(this); console.log(this.name); } var obj1 = { name: \u0026#39;smyh\u0026#39;, sayName: fun, }; var obj2 = { name: \u0026#39;vae\u0026#39;, sayName: fun, }; var name = \u0026#39;全局的name属性\u0026#39;; //以函数形式调用，this是window fun(); //可以理解成 window.fun() 打印结果：\n1 2 Window 全局的name属性 上面的举例可以看出，this 指向的是 window 对象，所以 this.name 指的是全局的 name。\n第 2 条的举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function fun() { console.log(this); console.log(this.name); } var obj1 = { name: \u0026#39;smyh\u0026#39;, sayName: fun, }; var obj2 = { name: \u0026#39;vae\u0026#39;, sayName: fun, }; var name = \u0026#39;全局的name属性\u0026#39;; //以方法的形式调用，this是调用方法的对象 obj2.sayName(); 打印结果：\n1 2 Object vae 上面的举例可以看出，this 指向的是 对象 obj2 ，所以 this.name 指的是 obj2.name。\n箭头函数中 this 的指向 ES6 中的箭头函数并不会使用上面的准则，而是会继承外层函数调用的 this 绑定（无论 this 绑定到什么）。\n改变函数内部的 this 指向 JS 专门为我们提供了一些方法来改变函数内部的 this 指向。详见下一篇文章中的 call()、apply()、bind() 方法。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/21-this%E6%8C%87%E5%90%91/","summary":"执行期上下文 当函数执行时（准确来说，是在函数发生预编译的前一刻），会创建一个执行期上下文的内部对象。一个执行期上下文定义了一个函数执行时的环","title":"21-this指向"},{"content":"前言 JS 专门为我们提供了一些方法来改变函数内部的 this 指向。常见的方法有 call()、apply()、bind() 方法。\ncall() 方法 call() 方法的作用 call() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。\ncall() 方法的另一个应用：可以实现继承。之所以能实现继承，其实是利用了上面的作用。\n语法：\n1 fn1.call(想要将this指向哪里, 函数实参1, 函数实参2); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。\ncall() 方法举例 举例 1、通过 call() 调用函数：\n1 2 3 4 5 6 7 8 9 const obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1() { console.log(this); console.log(this.nickName); } fn1.call(this); // this的指向并没有被改变，此时相当于 fn1(); 上方代码的打印结果：\n1 2 window undefined 上面的代码，跟普通的函数调用 fn1() 没有区别。\n举例 2、通过 call() 改变 this 指向：\n1 2 3 4 5 6 7 8 9 10 11 12 var obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1(a, b) { console.log(this); console.log(this.nickName); console.log(a + b); } fn1.call(obj1, 2, 4); // 先将 this 指向 obj1，然后执行 fn1() 函数 上方代码的打印结果：\n1 2 3 obj1 qianguyihao 6 举例 3、通过 call() 实现继承：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 给 Father 增加 name 和 age 属性 function Father(myName, myAge) { this.name = myName; this.age = myAge; } function Son(myName, myAge) { // 【下面这一行，重要代码】 // 通过这一步，将 father 里面的 this 修改为 Son 里面的 this；另外，给 Son 加上相应的参数，让 Son 自动拥有 Father 里的属性。最终实现继承 Father.call(this, myName, myAge); } const son1 = new Son(\u0026#39;lvbu\u0026#39;, 28); console.log(JSON.stringify(son1)); 上方代码中，通过 call() 方法，让 Son 继承了 Father 里面的 name 和 age 属性。\n打印结果：\n1 {\u0026#34;myName\u0026#34;:\u0026#34;lvbu\u0026#34;,\u0026#34;myAge\u0026#34;:28} apply() 方法 apply() 方法的作用 apply() 方法的作用：可以调用一个函数，与此同时，它还可以改变这个函数内部的 this 指向。这一点，和 call()类似。\napply() 方法的应用： 由于 apply()需要传递数组，所以它有一些巧妙应用，稍后看接下来的应用举例就知道了。\n语法：\n1 fn1.apply(想要将this指向哪里, [函数实参1, 函数实参2]); 备注：第一个参数中，如果不需要改变 this 指向，则传 null。\n到这里可以看出， call() 和 apply() 方法的作用是相同的。唯一的区别在于，apply() 里面传入的实参，必须是数组（或者维数组）。\napply() 方法举例 举例、通过 apply() 改变 this 指向：\n1 2 3 4 5 6 7 8 9 10 11 12 var obj1 = { nickName: \u0026#39;qianguyihao\u0026#39;, age: 28, }; function fn1(a) { console.log(this); console.log(this.nickName); console.log(a); } fn1.apply(obj1, [\u0026#39;hello\u0026#39;]); // 先将 this 指向 obj1，然后执行 fn1() 函数 注意，上方代码中，call() 里面传实参时，需要以数组的形式。即便是传一个实参，也需要传数组。\n打印结果：\n1 2 3 obj1 qianguyihao hello apply() 方法的巧妙应用：求数组的最大值 我们知道，如果想要求数组中元素的最大值的时候，数组本身是没有自带方法的。那怎么办呢？\n虽然数组里没有获取最大值的方法，但是数值里面有 Math.max(数字1，数字2，数字3) 方法，可以获取多个数值中的最大值。 另外，由于 apply() 方法在传递实参时，必须要以数组的形式，所以我们可以 通过 Math.max() 和 apply() 曲线救国。\n举例：求数组中多个元素的最大值：\n1 2 3 4 5 6 7 8 const arr1 = [3, 7, 10, 8]; // 下面这一行代码的目的，无需改变 this 指向，所以：第一个参数填 null，或者填 Math，或者填 this 都可以。严格模式中，不让填null。 const maxValue = Math.max.apply(Math, arr1); // 求数组 arr1 中元素的最大值 console.log(maxValue); const minValue = Math.min.apply(Math, arr1); // 求数组 arr1 中元素的最小值 console.log(minValue); 打印结果：\n1 2 3 10 3 bind() 方法 bind() 方法的作用 bind() 方法不会调用函数，但是可以改变函数内部的 this 指向。\n把call()、apply()、bind()这三个方法做一下对比，你会发现：实际开发中， bind() 方法使用得最为频繁。如果有些函数，我们不需要立即调用，但是又想改变这个函数内部的this指向，此时用 bind() 是最为合适的。\n语法：\n1 新函数 = fn1.bind(想要将this指向哪里, 函数实参1, 函数实参2); 参数：\n第一个参数：在 fn1 函数运行时，指定 fn1 函数的this 指向。如果不需要改变 this 指向，则传 null。\n其他参数：fn1 函数的实参。\n解释：它不会调用 fn1 函数，但会返回 由指定this 和指定实参的原函数拷贝。可以看出， bind() 方法是有返回值的。\ncall() 方法举例 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/22-callapply-%E5%92%8C-bind/","summary":"前言 JS 专门为我们提供了一些方法来改变函数内部的 this 指向。常见的方法有 call()、apply()、bind() 方法。 call() 方法 call() 方法的作用 call() 方法的","title":"22-call、apply 和 bind"},{"content":"高阶函数 高阶函数的概念 当 函数 A 接收函数 B 作为参数，或者把函数 C 作为返回值输出时，我们称 函数 A 为高阶函数。\n通俗来说，高阶函数是 对其他函数进行操作 的函数。\n高阶函数举例1：把其他函数作为参数 1 2 3 4 5 6 7 8 9 function fn1(a, b, callback) { console.log(a + b); // 执行完上面的 console.log() 语句之后，再执行下面这个 callback 函数。也就是说，这个 callback 函数是最后执行的。 callback \u0026amp;\u0026amp; callback(); } fn1(10, 20, function () { console.log(\u0026#39;我是最后执行的函数\u0026#39;); }); 打印结果：\n1 2 30 我是最后执行的函数 高阶函数举例2：把其他区函数作为返回值 1 2 3 4 5 6 7 8 9 10 function fn1() { let a = 20; return function () { console.log(a); }; } const foo = fn1(); // 执行 fn1() 之后，会得到一个返回值。这个返回值是函数 foo(); 上面的代码，产生了闭包现象。关于闭包，详见下一篇文章《JavaScript基础/闭包.md》。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/23-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/","summary":"高阶函数 高阶函数的概念 当 函数 A 接收函数 B 作为参数，或者把函数 C 作为返回值输出时，我们称 函数 A 为高阶函数。 通俗来说，高阶函数是 对其他函数进行操","title":"23-高阶函数"},{"content":"闭包的引入 我们知道，变量根据作用域的不同分为两种：全局变量和局部变量。\n函数内部可以访问全局变量和局部变量。\n函数外部只能访问全局变量，不能访问局部变量。\n当函数执行完毕，本作用域内的局部变量会销毁。\n比如下面这样的代码：\n1 2 3 4 5 6 function foo() { let a = 1; } foo(); console.log(a); // 打印报错：Uncaught ReferenceError: a is not defined 上方代码中，由于变量 a 是函数内的局部变量，所以外部无法访问。\n但是，在有些场景下，我们就是想要在函数外部访问函数内的局部变量，那要怎么办呢？这就需要引入闭包的概念。\n闭包的概念和代码举例 闭包的概念 闭包（closure）：指有权访问另一个函数作用域中变量的函数。\n上面这个概念，出自《JavaScript 高级程序设计（第 3 版）》这本书。上面的概念中指出，闭包是一种函数；当然，你可以把闭包理解成是一种现象。具体解释如下。\n简单理解就是：如果这个作用域可以访问另外一个函数内部的局部变量，那就产生了闭包（此时，你可以把闭包理解成是一种现象）；而另外那个作用域所在的函数称之为闭包函数。注意，这里强调的是访问局部变量哦。\n闭包代码举例 代码举例：\n1 2 3 4 5 6 7 8 9 10 function fn1() { let a = 10; function fn2() { console.log(a); } fn2(); } fn1(); 打印结果：\n1 10 上方代码中，函数 fn2 的作用域 访问了 fn1 中的局部变量，那么，此时在 fn1 中就产生了闭包，fn1 称之为闭包函数。\n在 chrome 浏览器控制台中，调试闭包 上面的代码中，要怎么验证，确实产生了闭包呢？我们可以在 chrome 浏览器的控制台中设置断点，当代码执行到 console.log(a)这一行的时候，如下图所示：\n上图中， Local 指的是局部作用域，Global 指的是 全局作用域；而 Closure 则是闭包，fn1 是一个闭包函数。\n闭包的作用：延伸变量的作用范围 我们来看看下面这段闭包的代码：\n1 2 3 4 5 6 7 8 9 10 11 function fn1() { let a = 20; function fn2() { console.log(a); } return fn2; } const foo = fn1(); // 执行 fn1() 之后，会得到一个返回值。foo 代表的就是 fn2 函数 foo(); 上方代码中，foo 代表的就是整个 fn2 函数。当执行了 foo() 语句之后（相当于执行了 ），fn1 函数内就产生了闭包。\n一般来说，在 fn1 函数执行完毕后，它里面的变量 a 会立即销毁。但此时由于产生了闭包，所以 fn1 函数中的变量 a 不会立即销毁，因为 fn2 函数还要继续调用变量 a。只有等所有函数把变量 a 调用完了，变量 a 才会销毁。\n而且，可以看出， 在执行 foo()语句之后，竟然能够打印出 20，这就完美通过闭包实现了：全局作用局成功访问到了局部作用域中的变量 a。\n因此，我们可以看出，闭包的主要作用就是：延伸了变量的作用范围。\n上面的代码也可以简写成：\n1 2 3 4 5 6 7 8 9 10 function fn1() { let a = 20; return function () { console.log(a); }; } const foo = fn1(); // 执行 fn1() 之后，会得到一个返回值。这个返回值是函数 foo(); ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/24-%E9%97%AD%E5%8C%85/","summary":"闭包的引入 我们知道，变量根据作用域的不同分为两种：全局变量和局部变量。 函数内部可以访问全局变量和局部变量。 函数外部只能访问全局变量，不能访问","title":"24-闭包"},{"content":"面向过程和面向对象 面向过程 面向过程：先分析好的具体步骤，然后按照步骤，一步步解决问题。\n优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。\n缺点：没有面向对象易维护、易复用、易扩展。\n面向对象 面向对象（OOP，Object Oriented Programming）：以对象功能来划分问题，而不是步骤。\n优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护。\n缺点：性能比面向过程低。\n面向对象的编程思想 面向对象的编程思想：对代码和数据进行封装，并以对象调用的方式，对外提供统一的调用接口。\n比如说，当我们在开车的时候，无需关心汽车的内部构造有多复杂，对于大多数人而言，只需要会开、知道汽车有哪些功能就行了。\n面向对象的特性 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工。面向对象编程具有灵活、代码可复用、容易维护和开发的优点，适合多人合作的大型软件项目，更符合我们认识事物的规律。\n面向对象的特性如下：\n封装性\n继承性\n多态性\nJS 中的面向对象 JS 中的面向对象，是基于原型的面向对象。\n另外，在ES6中，新引入了 类（Class）和继承（Extends）来实现面向对象。\n基于原型的面向对象 JS 中的对象（Object）是依靠构造器（constructor）和原型（prototype）构造出来的。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/25-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E8%BF%B0/","summary":"面向过程和面向对象 面向过程 面向过程：先分析好的具体步骤，然后按照步骤，一步步解决问题。 优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例","title":"25-面向对象概述"},{"content":" 在看本文之前，可以先复习前面的一篇文章：《04-JavaScript 基础/11-对象简介.md》\n创建自定义对象的几种方法 方式一：对象字面量 对象的字面量就是一个{}。里面的属性和方法均是键值对：\n键：相当于属性名。\n值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）。\n使用对象字面量来创建一个对象，非常简洁，举例如下：：\n1 var obj = {}; 使用对象字面量，可以在创建对象时，直接指定对象中的属性。语法：{属性名:属性值,属性名:属性值\u0026hellip;.}\n例 1：（一个简单的对象）\n1 2 3 4 const obj1 = { name: \u0026#39;lvbu\u0026#39;, age: 28, }; 例 2：（一个较复杂的对象）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const obj2 = { name: \u0026#34;lvbu\u0026#34;, age: 26, isBoy: true, // 还可以存放一个嵌套的对象 test: { id: 123, tel: 180 } //我们还可以在对象中增加一个方法。以后可以通过obj.sayName()的方式调用这个方法 sayName: function() { console.log(this.name); } }; console.log(JSON.stringify(obj)); 对象字面量的属性名可以加引号也可以不加，建议不加。如果要使用一些特殊的名字，则必须加引号。\n属性名和属性值是一组一组的键值对结构，键和值之间使用:连接，多个值对之间使用,隔开。\n方式二：工厂模式 new Object() 通过该方法可以大批量的创建对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* * 使用工厂方法创建对象 * 通过该方法可以大批量的创建对象 */ function createPerson(name, age, gender) { //创建一个新的对象 var obj = new Object(); //向对象中添加属性 obj.name = name; obj.age = age; obj.gender = gender; obj.sayName = function () { alert(this.name); }; //将新的对象返回 return obj; } var obj2 = createPerson(\u0026#39;猪八戒\u0026#39;, 28, \u0026#39;男\u0026#39;); var obj3 = createPerson(\u0026#39;白骨精\u0026#39;, 16, \u0026#39;女\u0026#39;); var obj4 = createPerson(\u0026#39;蜘蛛精\u0026#39;, 18, \u0026#39;女\u0026#39;); 第一次看到这种工厂模式时，你可能会觉得陌生。如果简化一下，可以写成下面这种形式，更容易理解：（也就是，利用 new Object 创建对象）\n1 2 3 4 5 6 7 var obj = new Obect(); obj.name = \u0026#39;猪八戒\u0026#39;; obj.age = 28; obj.gender = \u0026#39;男\u0026#39;; obj.sayHi = function () { alert(\u0026#39;hello world\u0026#39;); }; 弊端：\n使用工厂方法创建的对象，使用的构造函数都是 Object。所以创建的对象都是 Object 这个类型，就导致我们无法区分出多种不同类型的对象。\n方式三：利用构造函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //利用构造函数自定义对象 var stu1 = new Student(\u0026#39;smyh\u0026#39;); console.log(stu1); stu1.sayHi(); var stu2 = new Student(\u0026#39;vae\u0026#39;); console.log(stu2); stu2.sayHi(); // 创建一个构造函数 function Student(name) { this.name = name; //this指的是当前对象实例【重要】 this.sayHi = function () { console.log(this.name + \u0026#39;厉害了\u0026#39;); }; } 打印结果：\n接下来，我们专门来讲一下构造函数。\n构造函数 代码引入 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 创建一个构造函数，专门用来创建Person对象 function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; this.sayName = function () { alert(this.name); }; } var per = new Person(\u0026#39;孙悟空\u0026#39;, 18, \u0026#39;男\u0026#39;); var per2 = new Person(\u0026#39;玉兔精\u0026#39;, 16, \u0026#39;女\u0026#39;); var per3 = new Person(\u0026#39;奔波霸\u0026#39;, 38, \u0026#39;男\u0026#39;); // 创建一个构造函数，专门用来创建 Dog 对象 function Dog() {} var dog = new Dog(); 构造函数的概念 构造函数：是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。它与 new 一起使用才有意义。\n我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个构造函数里面。\n构造函数和普通函数的区别 构造函数的创建方式和普通函数没有区别，不同的是构造函数习惯上首字母大写。\n构造函数和普通函数的区别就是调用方式的不同：普通函数是直接调用，而构造函数需要使用 new 关键字来调用。\nthis 的指向也有所不同：\n1.以函数的形式调用时，this 永远都是 window。比如fun();相当于window.fun();\n2.以方法的形式调用时，this 是调用方法的那个对象\n3.以构造函数的形式调用时，this 是新创建的实例对象\nnew 一个构造函数的执行流程 new 在执行时，会做下面这四件事：\n（1）开辟内存空间，在内存中创建一个新的空对象。\n（2）让 this 指向这个新的对象。\n（3）执行构造函数里面的代码，给这个新对象添加属性和方法。\n（4）返回这个新对象（所以构造函数里面不需要 return）。\n因为 this 指的是 new 一个 Object 之后的对象实例。于是，下面这段代码：\n1 2 3 4 5 // 创建一个函数 function createStudent(name) { var student = new Object(); student.name = name; //第一个name指的是student对象定义的变量。第二个name指的是createStudent函数的参数。二者不一样 } 可以改进为：\n1 2 3 4 // 创建一个函数 function Student(name) { this.name = name; //this指的是构造函数中的对象实例 } 注意上方代码中的注释。\n静态成员和实例成员 JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的 this 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。\n静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问。\n实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问。\n类、实例 使用同一个构造函数创建的对象，我们称为一类对象，也将一个构造函数称为一个类。\n通过一个构造函数创建的对象，称为该类的实例。\ninstanceof 使用 instanceof 可以检查一个对象是否为一个类的实例。\n语法如下：\n1 对象 instanceof 构造函数; 如果是，则返回 true；否则返回 false。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 function Person() {} function Dog() {} var person1 = new Person(); var dog1 = new Dog(); console.log(person1 instanceof Person); // 打印结果： true console.log(dog1 instanceof Person); // 打印结果：false console.log(dog1 instanceof Object); // 所有的对象都是Object的后代。因此，打印结果为：true 根据上方代码中的最后一行，需要补充一点：所有的对象都是 Object 的后代，因此 任何对象 instanceof Object 的返回结果都是 true。\nothers json 的介绍 对象字面量和 json 比较像，这里我们对 json 做一个简单介绍。\nJSON：JavaScript Object Notation（JavaScript 对象表示形式）。\nJSON 和对象字面量的区别：JSON 的属性必须用双引号引号引起来，对象字面量可以省略。\njson 举例：\n1 2 3 4 5 6 7 8 { \u0026#34;name\u0026#34; : \u0026#34;zs\u0026#34;, \u0026#34;age\u0026#34; : 18, \u0026#34;sex\u0026#34; : true, \u0026#34;sayHi\u0026#34; : function() { console.log(this.name); } }; 注：json 里一般放常量、数组、对象等，但很少放 function。\n另外，对象和 json 没有长度，json.length 的打印结果是 undefined。于是乎，自然也就不能用 for 循环遍历（因为遍历时需要获取长度 length）。\njson 遍历的方法：\njson 采用 for...in...进行遍历，和数组的遍历方式不同。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; var myJson = { name: \u0026#39;smyhvae\u0026#39;, aaa: 111, bbb: 222, }; //json遍历的方法：for...in... for (var key in myJson) { console.log(key); //获取 键 console.log(myJson[key]); //获取 值（第二种属性绑定和获取值的方法） console.log(\u0026#39;------\u0026#39;); } \u0026lt;/script\u0026gt; 打印结果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/26-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","summary":"在看本文之前，可以先复习前面的一篇文章：《04-JavaScript 基础/11-对象简介.md》 创建自定义对象的几种方法 方式一：对象字面量 对","title":"26-对象的创建\u0026构造函数"},{"content":"对象的基本操作 创建对象 使用 new 关键字调用的函数，是构造函数 constructor。构造函数是专门用来创建对象的函数。\n例如：\n1 var obj = new Object(); 记住，使用typeof检查一个对象时，会返回object。\n关于常见对象的更多方式，可以看上一篇文章《对象的创建\u0026amp;构造函数》。\n向对象中添加属性 在对象中保存的值称为属性。\n向对象添加属性的语法：\n1 对象.属性名 = 属性值; 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 var obj = new Object(); //向obj中添加一个name属性 obj.name = \u0026#39;孙悟空\u0026#39;; //向obj中添加一个gender属性 obj.gender = \u0026#39;男\u0026#39;; //向obj中添加一个age属性 obj.age = 18; console.log(JSON.stringify(obj)); // 将 obj 以字符串的形式打印出来 打印结果：\n1 2 3 4 5 { \u0026#34;name\u0026#34;:\u0026#34;孙悟空\u0026#34;, \u0026#34;gender\u0026#34;:\u0026#34;男\u0026#34;, \u0026#34;age\u0026#34;:18 } 获取对象中的属性 方式 1：\n语法：\n1 对象.属性名; 如果获取对象中没有的属性，不会报错而是返回undefined。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 var obj = new Object(); //向obj中添加一个name属性 obj.name = \u0026#39;孙悟空\u0026#39;; //向obj中添加一个gender属性 obj.gender = \u0026#39;男\u0026#39;; //向obj中添加一个age属性 obj.age = 18; // 获取对象中的属性，并打印出来 console.log(obj.gender); // 打印结果：男 console.log(obj.color); // 打印结果：undefined 方式 2：可以使用[]这种形式去操作属性\n对象的属性名不强制要求遵守标识符的规范，不过我们尽量要按照标识符的规范去做。\n但如果确实要使用特殊的属性名，就不能采用.的方式来操作对象的属性。比如说，123这种属性名，如果我们直接写成obj.123 = 789来操作属性，是会报错的。那怎么办呢？办法如下：\n语法格式如下：（读取时，也是采用这种方式）\n1 2 // 注意，括号里的属性名，必须要加引号 对象[\u0026#39;属性名\u0026#39;] = 属性值; 上面这种语法格式，举例如下：\n1 obj[\u0026#39;123\u0026#39;] = 789; 重要：使用[]这种形式去操作属性，更加的灵活，因为，我们可以在[]中直接传递一个变量。\n修改对象的属性值 语法：\n1 对象.属性名 = 新值; 1 obj.name = \u0026#39;tom\u0026#39;; 删除对象的属性 语法：\n1 delete obj.name; in 运算符 通过该运算符可以检查一个对象中是否含有指定的属性。如果有则返回 true，没有则返回 false。\n语法：\n1 \u0026#39;属性名\u0026#39; in 对象; 举例：\n1 2 //检查对象 obj 中是否含有name属性 console.log(\u0026#39;name\u0026#39; in obj); 我们平时使用的对象不一定是自己创建的，可能是从接口获取的，这个时候，in 运算符可以派上用场。\n当然，还有一种写法可以达到上述目的：\n1 2 3 if (obj.name) { // 如果对象 obj 中有name属性，我就继续做某某事情。 } for of：遍历数组 ES6 中，如果我们要遍历一个数组，可以这样做：\n1 2 3 4 5 let arr1 = [2, 6, 8, 5]; for (let value of arr1) { console.log(value); } 打印结果：\n1 2 3 4 2 6 8 5 for \u0026hellip; of 的循环可以避免我们开拓内存空间，增加代码运行效率，所以建议大家在以后的工作中使用 for…of 遍历数组。\n注意，上面的数组中，for ... of获取的是数组里的值；如果采用for ... in遍历数组，则获取的是 index 索引值。\nMap 对象的遍历 for ... of既可以遍历数组，也可以遍历 Map 对象。\nfor in：遍历对象的属性 for ... in主要用于遍历对象，不建议用来遍历数组。\n语法：\n1 2 3 for (const 变量 in 对象) { } 解释：对象中有几个属性，循环体就会执行几次。每次执行时，会将对象中的每个属性的 属性名 赋值给变量。\n语法举例：\n1 2 3 4 for (var key in obj) { console.log(key); // 这里的 key 是：对象属性的键（也就是属性名） console.log(obj[key]); // 这里的 obj[key] 是：对象属性的值（也就是属性值） } 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; const obj = { name: \u0026#39;smyhvae\u0026#39;, age: 28, gender: \u0026#39;男\u0026#39;, address: \u0026#39;shenzhen\u0026#39;, sayHi: function () { console.log(this.name); }, }; // 遍历对象中的属性 for (const key in obj) { console.log(\u0026#39;属性名:\u0026#39; + key); console.log(\u0026#39;属性值:\u0026#39; + obj[key]); // 注意，因为这里的属性名 key 是变量，所以，如果想获取属性值，不能写成 obj.key，而是要写成 obj[key] } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt;\u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 属性名:name 属性值:smyhvae 属性名:age 属性值:26 属性名:gender 属性值:男 属性名:address 属性值:shenzhen 属性名:sayHi 属性值:function() { console.log(this.name); } for in 遍历数组（不建议） 另外，for in 当然也可以用来遍历数组（只是不建议），此时的 key 是数组的索引。举例如下：\n1 2 3 4 5 6 const arr = [\u0026#39;hello1\u0026#39;, \u0026#39;hello2\u0026#39;, \u0026#39;hello3\u0026#39;]; for (const key in arr) { console.log(\u0026#39;属性名：\u0026#39; + key); console.log(\u0026#39;属性值：\u0026#39; + arr[key]); } 打印结果：\n1 2 3 4 5 6 7 8 属性名：0 属性值：hello1 属性名：1 属性值：hello2 属性名：2 属性值：hello3 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/27-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"对象的基本操作 创建对象 使用 new 关键字调用的函数，是构造函数 constructor。构造函数是专门用来创建对象的函数。 例如： 1 var obj = new Object(); 记住，使","title":"27-对象的基本操作"},{"content":"概念 浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用。\n深拷贝：拷贝多层数据；每一层级别的数据都会拷贝。\n总结：\n拷贝引用的时候，是属于传址，而非传值。关于传值和传址的区别，是很基础的内容，详见《JavaScript 基础/对象简介.md》这篇文章。\n深拷贝会把对象里所有的数据重新复制到新的内存空间，是最彻底的拷贝。\n浅拷贝的实现方式 用 for in 实现浅拷贝（比较繁琐） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, info: { desc: \u0026#39;很厉害\u0026#39;, }, }; const obj2 = {}; // 用 for in 将 obj1 的值拷贝给 obj2 for (let key in obj1) { obj2[key] = obj1[key]; } console.log(\u0026#39;obj2:\u0026#39; + JSON.stringify(obj2)); obj1.info.desc = \u0026#39;永不止步\u0026#39;; // 当修改 obj1 的第二层数据时，obj2的值也会被改变。所以 for in 是浅拷贝 console.log(\u0026#39;obj2:\u0026#39; + JSON.stringify(obj2)); 上方代码中，用 for in 做拷贝时，只能做到浅拷贝。也就是说，在 obj2 中， name 和 age 这两个属性会单独存放在新的内存地址中，和 obj1 没有关系。但是，obj2.info 属性，跟 obj1.info属性，它俩指向的是同一个堆内存地址。所以，当我修改 obj1.info 里的值之后，obj2.info的值也会被修改。\n打印结果如下：\n1 2 3 obj2:{\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;info\u0026#34;:{\u0026#34;desc\u0026#34;:\u0026#34;很厉害\u0026#34;}} obj2:{\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;info\u0026#34;:{\u0026#34;desc\u0026#34;:\u0026#34;永不止步\u0026#34;}} 用 Object.assgin() 实现浅拷贝（推荐的方式） 上面的 for in 方法做浅拷贝过于繁琐。ES6 给我们提供了新的语法糖，通过 Object.assgin() 可以实现浅拷贝。\nObject.assgin() 在日常开发中，使用得相当频繁，非掌握不可。\n语法：\n1 2 3 4 5 // 语法1 obj2 = Object.assgin(obj2, obj1); // 语法2 Object.assign(目标对象, 源对象1, 源对象2...); 解释：将obj1 拷贝给 obj2。执行完毕后，obj2 的值会被更新。\n作用：将 obj1 的值追加到 obj2 中。如果对象里的属性名相同，会被覆盖。\n从语法2中可以看出，Object.assign() 可以将多个“源对象”拷贝到“目标对象”中。\n例 1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, info: { desc: \u0026#39;hello\u0026#39;, }, }; // 浅拷贝：把 obj1 拷贝给 obj2。如果 obj1 只有一层数据，那么，obj1 和 obj2 则互不影响 const obj2 = Object.assign({}, obj1); console.log(\u0026#39;obj2:\u0026#39; + JSON.stringify(obj2)); obj1.info.desc = \u0026#39;永不止步\u0026#39;; // 由于 Object.assign() 只是浅拷贝，所以当修改 obj1 的第二层数据时，obj2 对应的值也会被改变。 console.log(\u0026#39;obj2:\u0026#39; + JSON.stringify(obj2)); 代码解释：由于 Object.assign() 只是浅拷贝，所以在当前这个案例中， obj2 中的 name 属性和 age 属性是单独存放在新的堆内存地址中的，和 obj1 没有关系；但是，obj2.info 属性，跟 obj1.info属性，它俩指向的是同一个堆内存地址。所以，当我修改 obj1.info 里的值之后，obj2.info的值也会被修改。\n打印结果：\n1 2 3 obj2:{\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;info\u0026#34;:{\u0026#34;desc\u0026#34;:\u0026#34;hello\u0026#34;}} obj2:{\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;info\u0026#34;:{\u0026#34;desc\u0026#34;:\u0026#34;永不止步\u0026#34;}} 例 2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const myObj = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, }; // 【写法1】浅拷贝：把 myObj 拷贝给 obj1 const obj1 = {}; Object.assign(obj1, myObj); // 【写法2】浅拷贝：把 myObj 拷贝给 obj2 const obj2 = Object.assign({}, myObj); // 【写法3】浅拷贝：把 myObj 拷贝给 obj31。注意，这里的 obj31 和 obj32 其实是等价的，他们指向了同一个内存地址 const obj31 = {}; const obj32 = Object.assign(obj31, myObj); 上面这三种写法，是等价的。所以，当我们需要将对象 A 复制（拷贝）给对象 B，不要直接使用 B = A，而是要使用 Object.assign(B, A)。\n例 3：\n1 2 3 4 5 6 let obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 26 }; let obj2 = { city: \u0026#39;shenzhen\u0026#39;, age: 28 }; let obj3 = {}; Object.assign(obj3, obj1, obj2); // 将 obj1、obj2的内容赋值给 obj3 console.log(obj3); // {name: \u0026#34;qianguyihao\u0026#34;, age: 28, city: \u0026#34;shenzhen\u0026#34;} 上面的代码，可以理解成：将多个对象（obj1和obj2）合并成一个对象 obj3。\n例4：【重要】\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, desc: \u0026#39;hello world\u0026#39;, }; const obj2 = { name: \u0026#39;许嵩\u0026#39;, sex: \u0026#39;男\u0026#39;, }; // 浅拷贝：把 obj1 赋值给 obj2。这一行，是关键代码。这行代码的返回值也是 obj2 Object.assign(obj2, obj1); console.log(JSON.stringify(obj2)); 打印结果：\n1 {\u0026#34;name\u0026#34;:\u0026#34;qianguyihao\u0026#34;,\u0026#34;sex\u0026#34;:\u0026#34;男\u0026#34;,\u0026#34;age\u0026#34;:28,\u0026#34;desc\u0026#34;:\u0026#34;hello world\u0026#34;} 注意，例 4 在实际开发中，会经常遇到，一定要掌握。它的作用是：将 obj1 的值追加到 obj2 中。如果两个对象里的属性名相同，则 obj12 中的值会被 obj2 中的值覆盖。\n深拷贝的实现方式 深拷贝其实就是将浅拷贝进行递归。\n用 for in 递归实现深拷贝 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 let obj1 = { name: \u0026#39;qianguyihao\u0026#39;, age: 28, info: { desc: \u0026#39;hello\u0026#39;, }, color: [\u0026#39;red\u0026#39;, \u0026#39;blue\u0026#39;, \u0026#39;green\u0026#39;], }; let obj2 = {}; deepCopy(obj2, obj1); console.log(obj2); obj1.info.desc = \u0026#39;github\u0026#39;; console.log(obj2); // 方法：深拷贝 function deepCopy(newObj, oldObj) { for (let key in oldObj) { // 获取属性值 oldObj[key] let item = oldObj[key]; // 判断这个值是否是数组 if (item instanceof Array) { newObj[key] = []; deepCopy(newObj[key], item); } else if (item instanceof Object) { // 判断这个值是否是对象 newObj[key] = {}; deepCopy(newObj[key], item); } else { // 简单数据类型，直接赋值 newObj[key] = item; } } } ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/28-%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/","summary":"概念 浅拷贝：只拷贝最外面一层的数据；更深层次的对象，只拷贝引用。 深拷贝：拷贝多层数据；每一层级别的数据都会拷贝。 总结： 拷贝引用的时候，是属于","title":"28-浅拷贝和深拷贝"},{"content":"Object.freeze() 冻结对象 Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。\n代码举例：\n1 2 3 4 5 6 7 8 const params = { name: \u0026#39;qianguyihao\u0026#39;; port: \u0026#39;8899\u0026#39;; } Object.freeze(params); // 冻结对象 params params.port = \u0026#39;8080\u0026#39;;// 修改无效 上方代码中，把 params 对象冻结后，如果想再改变 params 里面的属性值，是无效的。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/29-%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%E5%BE%85%E6%9B%B4%E6%96%B0/","summary":"Object.freeze() 冻结对象 Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对","title":"29-对象的高级操作（待更新）"},{"content":"前言 在 ES6 中，我们可以通过 ES6 引入的类 Class 来实现面向对象的编程（下一篇文章会讲到）。但是在 ES6 之前，我们是通过构造函数和原型，来模拟类的实现机制。\n今天这篇文章，我们就来学习构造函数和原型。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/30-%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%92%8C%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF%E5%BE%85%E6%9B%B4%E6%96%B0/","summary":"前言 在 ES6 中，我们可以通过 ES6 引入的类 Class 来实现面向对象的编程（下一篇文章会讲到）。但是在 ES6 之前，我们是通过构造函数和原型，来模拟类的实现机制。 今","title":"30-原型链和原型继承（待更新）"},{"content":"","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/31-%E7%B1%BB%E5%92%8C%E6%9E%84%E9%80%A0%E7%BB%A7%E6%89%BF%E5%BE%85%E6%9B%B4%E6%96%B0/","summary":"","title":"31-类和构造继承（待更新）"},{"content":"正则表达式简介 定义：正则表达式用于定义一些字符串的规则。\n作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符合规则的内容提取出来。\n如果你想查看正则更多的内容，可以查阅官方文档关于 RegExp 这个内置对象的用法。\n创建正则表达式的对象 方式一：使用构造函数创建正则表达式的对象 语法：\n1 2 3 var 变量 = new RegExp(\u0026#34;正则表达式\u0026#34;); // 注意，参数是字符串 var 变量 = new RegExp(\u0026#34;正则表达式\u0026#34;, \u0026#34;匹配模式\u0026#34;); // 注意，两个参数都是字符串 备注：RegExp的意思是 Regular expression。使用typeof检查正则对象，会返回object。\n上面的语法中，既可以传一个参数，也可以传两个参数。\n创建了正则表达式的对象后，该怎么使用呢？大致分为两个步骤：\n（1）创建正则表达式的对象 reg。\n（2）使用 reg 的test() 方法，判断指定字符串是否符合规则。\n正则表达式的test()方法：【重要】\n1 myReg.test(str); // 判断字符串 str 是否符合 指定的 myReg 这个正则表达式的规则 解释：使用test()这个方法可以用来检查一个字符串是否符合正则表达式的规则，如果符合则返回true，否则返回false。\n我们来看看下面的例子。\n1、传一个参数时：\n构造函数 RegExp 中，可以只传一个参数。\n代码举例：\n1 2 3 4 5 6 7 8 var reg = new RegExp(\u0026#34;a\u0026#34;); // 定义一个正则表达式：检查一个字符串中是否含有 a var str1 = \u0026#34;qianguyihao\u0026#34;; var str2 = \u0026#34;smyh\u0026#34;; // 通过 test()方法，判断字符串是否符合 上面定义的 reg 规则 console.log(reg.test(str1)); // 打印结果：true console.log(reg.test(str2)); // 打印结果：false 注意，上面的例子中，我们是先定义了一个正则表达式的规则，然后通过正则表达式的test()方法来判断字符串是否符合之前定义的规则。\n2、传两个参数时：匹配模式 【重要】\n构造函数 RegExp 中，也可以传两个参数。我们可以传递一个匹配模式作为第二个参数。这个参数可以是：\ni 忽略大小写。这里的 i 指的是 ignore。\ng 全局匹配模式。这里的 g 指的是 global。\n代码举例：\n1 2 3 4 var reg = new RegExp(\u0026#39;A\u0026#39;, \u0026#39;i\u0026#39;); var str = \u0026#39;qiangu\u0026#39;; console.log(reg.test(str)); // 打印结果：true 方式二：使用字面量创建正则表达式 我们可以使用字面量来创建正则表达式。\n语法：\n1 2 3 var 变量 = /正则表达式/; // 注意，这个语法里没有引号 var 变量 = /正则表达式/匹配模式; // 注意，这个语法里没有引号 代码举例：\n1 2 3 4 5 var reg = /A/i; // 定义正则表达式的规则：检查一个字符串中是否含有 a。忽略大小写。 var str = \u0026#34;qiangu\u0026#34;; console.log(typeof reg); // 打印结果：object console.log(reg.test(str)); // 打印结果：true 以上两种方式的对比 方式一：使用构造函数创建时，更加灵活，因为参数中还可以传递变量。\n方式二：使用字面量的方式创建，更加简单。\n代码举例：\n1 2 3 var reg = new RegExp(\u0026#34;a\u0026#34;, \u0026#34;i\u0026#34;); // 方式一 var reg = /a/i; // 方式二 上面这两行代码的作用是等价的。\n避坑指南：全局匹配 g 慎用test()方法 对于非全局匹配的正则表达式，test()只会检测是否存在某个目标字符串（只要存在就为 true），多次检测的结果都相同。例如：\n1 2 3 4 5 6 const reg = /test/; const str = \u0026#39;_test_test\u0026#39;; reg.test(str) // true reg.test(str) // true reg.test(str) // true 重点来了。\n当设置全局标志 /g 时，一旦字符串中还存在匹配，test() 方法都将返回 true，同时匹配成功后将把 lastIndex 属性的值设置为上次匹配成功结果之后的第一个字符所在的位置，下次匹配将从 lastIndex 指示的位置开始；匹配不成功时返回 false，同时将 lastIndex 属性的值重置为 0。\n举例：（很重要的例子，看仔细）\n1 2 3 4 5 6 7 8 9 10 11 const reg = /test/g; const str = \u0026#39;_test_test\u0026#39;; console.log(reg.test(str)); // true console.log(reg.lastIndex); // 5 console.log(reg.test(str)); // true console.log(reg.lastIndex); // 10 console.log(reg.test(str)); // false console.log(reg.lastIndex); // 0 总结：\n全局匹配模式g一般用于 exec()、match()、replace()等方法。\n全局匹配模式g如果用于test()方法会有问题。因为g模式会生成一个lastindex参数来存储匹配最后一次的位置。\n参考链接：\nJS正则表达式全局匹配的那些坑\njavascript正则全局匹配g慎用test方法\nissues\n正则表达式的简单语法 检查一个字符串中是否包含 a或b 写法1：\n1 var reg = /a|b/; 解释：使用 | 表示或的意思。\n写法2：\n1 var reg = /[ab]/; // 跟上面的那行语法，是等价的 解释：这里的[]也是表示或的意思。\n[]这个符号在正则还是比较常用的。我们接下来看几个例子。\n[]表示：或 一些规则：\n/[ab]/ 等价于 /a|b/：检查一个字符串中是否包含 a或b\n/[a-z]/：检查一个字符串那种是否包含任意小写字母\n/[A-Z]/：任意大写字母\n/[A-z]/：任意字母\n/[0-9]/：任意数字\n/a[bde]c/：检查一个字符串中是否包含 abc 或 adc 或 aec\n[^ ] 表示：除了 举例1：\n1 2 3 4 var reg = /[^ab]/; // 规则：字符串中，除了a、b之外，还有没有其他的字符内容？ var str = \u0026#34;acb\u0026#34;; console.log(reg.test(str)); // 打印结果：true 举例2：（可以用来验证某字符串是否为 纯数字）\n1 2 3 4 5 6 var reg = /[^0-9]/; // 规则：字符串中，除了数字之外，还有没有其他的内容？ var str1 = \u0026#34;1991\u0026#34;; var str2 = \u0026#34;199a1\u0026#34;; console.log(reg.test(str1)); // 打印结果：false （如果字符串是 纯数字，则返回 false） console.log(reg.test(str2)); // 打印结果：true 支持正则表达式的 String 对象的方法 String对象的如下方法，是支持正则表达式的：\n方法 描述 备注 split() 将字符串拆分成数组 search() 搜索字符串中是否含有指定内容，返回索引 index match() 根据正则表达式，从一个字符串中将符合条件的内容提取出来 replace() 将字符串中的指定内容，替换为新的内容并返回 下面来分别介绍和举例。\nsplit() split()：将一个字符串拆分成一个数组。可以接受一个正则表达式作为参数。\n备注：关于split()更详细的用法，可以看之前的关于《内置对象：String》这篇文章。\n正则相关的举例：根据任意字母，将字符串拆分成数组。\n代码实现：（通过正则）\n1 2 3 4 var str = \u0026#34;1a2b3c4d5e6f7g\u0026#34;; var result = str.split(/[A-z]/); // 参数是一个正则表达式：表示所有字母 console.log(result); 打印结果：\n1 [\u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;, \u0026#34;3\u0026#34;, \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;, \u0026#34;7\u0026#34;, \u0026#34;\u0026#34;] search() search()：搜索字符串中是否含有指定内容。如果搜索到指定内容，则会返回第一次出现的索引；否则返回-1。\nsearch()方法可以接受一个正则表达式作为参数，然后会根据正则表达式去检索字符串。serach()只会查找第一个，即使设置全局匹配也没用。\n举例：\n1 2 3 4 5 6 var str = \u0026#34;hello abc hello aec afc\u0026#34;; /* * 搜索字符串中是否含有abc 或 aec 或 afc */ result = str.search(/a[bef]c/); console.log(result); // 打印结果：6 match() match()：根据正则表达式，从一个字符串中将符合条件的内容提取出来，封装到一个数组中返回（即使只查询到一个结果）。\n注意：默认情况下，match()方法只会找到第一个符合要求的内容，找到以后就停止检索。我们可以设置正则表达式为全局匹配模式，这样就会匹配到所有的内容，并以数组的形式返回。\n另外，我们可以为一个正则表达式设置多个匹配模式，且匹配模式的顺序无所谓。\n代码举例：\n1 2 3 4 5 6 7 8 9 var str = \u0026#34;1a2a3a4a5e6f7A8B9C\u0026#34;; var result1 = str.match(/[a-z]/); // 找到符合要求的第一个内容，然后返回 var result2 = str.match(/[a-z]/g); // 设置为“全局匹配”模式，匹配字符串中 所有的小写字母 var result3 = str.match(/[a-z]/gi); // 设置多个匹配模式，匹配字符串中 所有的字母（忽略大小写） console.log(result1); // 打印结果：[\u0026#34;a\u0026#34;] console.log(result2); // 打印结果：[\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;] console.log(result3); // 打印结果：[\u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;a\u0026#34;, \u0026#34;e\u0026#34;, \u0026#34;f\u0026#34;, \u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;] 总结：\nmatch()这个方法还是很实用的，可以在一个很长的字符串中，提取出有规则的内容。这不就是爬虫的时候经常会遇到的场景么？\nreplace() replace()：将字符串中的指定内容，替换为新的内容并返回。不会修改原字符串。\n语法：\n1 新的字符串 = str.replace(被替换的内容，新的内容); 参数解释：\n被替换的内容：可以接受一个正则表达式作为参数。\n新的内容：默认只会替换第一个。如果需要替换全部符合条件的内容，可以设置正则表达式为全局匹配模式。\n代码举例：\n1 2 3 4 5 6 //replace()方法：替换 var str2 = \u0026#34;Today is fine day,today is fine day !!!\u0026#34; console.log(str2); console.log(str2.replace(\u0026#34;today\u0026#34;,\u0026#34;tomorrow\u0026#34;)); //只能替换第一个today console.log(str2.replace(/today/gi,\u0026#34;tomorrow\u0026#34;)); //这里用到了正则，且为“全局匹配”模式，才能替换所有的today 常见正则表达式举例 检查一个字符串是否是一个合法手机号 手机号的规则：\n以1开头（^1 表示1开头 , [^1]表示非1或除了1）\n第二位是3~9之间任意数字\n三位以后任意9位数字\n正则实现：\n1 2 3 4 5 var phoneStr = \u0026#34;13067890123\u0026#34;; var phoneReg = /^1[3-9][0-9]{9}$/; console.log(phoneReg.test(phoneStr)); 备注：如果在正则表达式中同时使用^和$符号，则要求字符串必须完全符合正则表达式。\n去掉字符串开头和结尾的空格 正则实现：\n1 str = str.replace(/^\\s*|\\s*$/g,\u0026#34;\u0026#34;); 解释如下：\n1 2 3 str = str.replace(/^\\s*/, \u0026#34;\u0026#34;); //去除开头的空格 str = str.replace(/\\s*$/, \u0026#34;\u0026#34;); //去除结尾的空格 判断字符串是否为电子邮件 正则实现：\n1 2 3 4 5 var emailReg = /^\\w{3,}(\\.\\w+)*@[A-z0-9]+(\\.[A-z]{2,5}){1,2}$/; var email = \u0026#34;abchello@163.com\u0026#34;; console.log(emailReg.test(email)); ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/32-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","summary":"正则表达式简介 定义：正则表达式用于定义一些字符串的规则。 作用：计算机可以根据正则表达式，来检查一个字符串是否符合指定的规则；或者将字符串中符","title":"32-正则表达式"},{"content":" 本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。\n以下是正文。\n事件简介 事件：就是文档或浏览器窗口中发生的一些特定的交互瞬间。对于 Web 应用来说，有下面这些代表性的事件：点击某个元素、将鼠标移动至某个元素上方、关闭弹窗等等。\nJavaScript 是以事件驱动为核心的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。\n事件的三要素 事件的三要素：事件源、事件、事件驱动程序。\n比如，我用手去按开关，灯亮了。这件事情里，事件源是：手。事件是：按开关。事件驱动程序是：灯开了或者关了。\n再比如，网页上弹出一个广告，我点击右上角的X，广告就关闭了。这件事情里，事件源是：X。事件是：onclick。事件驱动程序是：广告关闭了。\n于是我们可以总结出：谁引发的后续事件，谁就是事件源。\n总结如下：\n事件源：引发后续事件的html标签。\n事件：js已经定义好了（见下图）。\n事件驱动程序：对样式和html的操作。也就是DOM。\n也就是说，我们可以在时间对应的属性中写一些js代码，当事件被触发时，这些代码将会执行。\n代码书写步骤如下：（重要）\n（1）获取事件源：document.getElementById(“box”); // 类似于Android里面的findViewById\n（2）绑定事件： 事件源box.事件onclick = function(){ 事件驱动程序 };\n（3）书写事件驱动程序：关于DOM的操作。\n最简单的代码举例：（点击box1，然后弹框）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 1、获取事件源 var div = document.getElementById(\u0026#34;box1\u0026#34;); // 2、绑定事件 div.onclick = function () { // 3、书写事件驱动程序 alert(\u0026#34;我是弹出的内容\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 常见的事件如下：\n下面针对这事件的三要素，进行分别介绍。\n1、获取事件源的方式（DOM节点的获取） 获取事件源的常见方式如下：\n1 2 3 4 5 var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //方式一：通过id获取单个标签 var arr1 = document.getElementsByTagName(\u0026#34;div\u0026#34;); //方式二：通过 标签名 获得 标签数组，所以有s var arr2 = document.getElementsByClassName(\u0026#34;hehe\u0026#34;); //方式三：通过 类名 获得 标签数组，所以有s 2、绑定事件的方式 方式一：直接绑定匿名函数\n1 2 3 4 5 6 7 8 9 \u0026lt;div id=\u0026#34;box1\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //绑定事件的第一种方式 div1.onclick = function () { alert(\u0026#34;我是弹出的内容\u0026#34;); } \u0026lt;/script\u0026gt; 方式二：先单独定义函数，再绑定\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div id=\u0026#34;box1\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //绑定事件的第二种方式 div1.onclick = fn; //注意，这里是fn，不是fn()。fn()指的是返回值。 //单独定义函数 function fn() { alert(\u0026#34;我是弹出的内容\u0026#34;); } \u0026lt;/script\u0026gt; 注意上方代码的注释。绑定的时候，是写fn，不是写fn()。fn代表的是整个函数，而fn()代表的是返回值。\n方式三：行内绑定\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!--行内绑定--\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34; onclick=\u0026#34;fn()\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function fn() { alert(\u0026#34;我是弹出的内容\u0026#34;); } \u0026lt;/script\u0026gt; 注意第一行代码，绑定时，是写的\u0026quot;fn()\u0026quot;，不是写的\u0026quot;fn\u0026quot;。因为绑定的这段代码不是写在js代码里的，而是被识别成了字符串。\n3、事件驱动程序 我们在上面是拿alert举例，不仅如此，我们还可以操作标签的属性和样式。举例如下：\n点击鼠标时，原本粉色的div变大了，背景变红：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;style\u0026gt; #box1 { width: 100px; height: 100px; background-color: pink; cursor: pointer; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //点击鼠标时，原本粉色的div变大了，背景变红了 div1.onclick = function () { div1.style.width = \u0026#34;200px\u0026#34;; //属性值要写引号 div1.style.height = \u0026#34;200px\u0026#34;; div1.style.backgroundColor = \u0026#34;red\u0026#34;; //属性名是backgroundColor，不是background-color } \u0026lt;/script\u0026gt; 上方代码的注意事项：\n在js里写属性值时，要用引号\n在js里写属性名时，是backgroundColor，不是CSS里面的background-color。\n实现效果如下：\nonload事件 onload事件比较特殊，这里单独讲一下。\n当页面加载（文本和图片）完毕的时候，触发onload事件。\n举例：\n1 2 3 4 5 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function () { console.log(\u0026#34;smyhvae\u0026#34;); //等页面加载完毕时，打印字符串 } \u0026lt;/script\u0026gt; 有一点我们要知道：js的加载是和html同步加载的。因此，如果使用元素在定义元素之前，容易报错。这个时候，onload事件就能派上用场了，我们可以把使用元素的代码放在onload里，就能保证这段代码是最后执行。\n建议是：整个页面上所有元素加载完毕再执行js内容。所以，window.onload可以预防使用标签在定义标签之前。\n备注：关于 onLoad事件，在下一篇文章《DOM简介和DOM操作》中有更详细的讲解和示例。\n事件举例：京东顶部广告栏 比如上面这张图，当鼠标点击右上角的X时，关掉整个广告栏，这就要用到事件。\n代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { padding: 0; margin: 0; } .top-banner { background-color: pink; height: 80px; } .w { width: 1210px; margin: 10px auto; position: relative; } img { display: block; width: 1210px; height: 80px; background-color: blue; } a { position: absolute; top: 5px; right: 5px; color: #fff; background-color: #000; text-decoration: none; width: 20px; height: 20px; font: 700 14px/20px \u0026#34;simsum\u0026#34;; text-align: center; } .hide { display: none!important; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;top-banner\u0026#34; id=\u0026#34;topBanner\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;w\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;a href=\u0026#34;#\u0026#34; id=\u0026#34;closeBanner\u0026#34;\u0026gt;×\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //需求：点击案例，隐藏盒子。 //思路：点击a链接，让top-banner这个盒子隐藏起来（加隐藏类名）。 //1.获取事件源和相关元素 var closeBanner = document.getElementById(\u0026#34;closeBanner\u0026#34;); var topBanner = document.getElementById(\u0026#34;topBanner\u0026#34;); //2.绑定事件 closeBanner.onclick = function () { //3.书写事件驱动程序 //类控制 // topBanner.className += \u0026#34; hide\u0026#34;; //保留原类名，添加新类名 topBanner.className = \u0026#34;hide\u0026#34;;//替换旧类名（方式一） // topBanner.style.display = \u0026#34;none\u0026#34;; //方式二：与上一行代码的效果相同 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意最后一行代码，这种方式会替换旧类名，意思是，不管之前的类名叫什么，都会被修改。\n事件举例： 要求实现效果：当鼠标悬停在img上时，更换为另外一张图片；鼠标离开时，还原为本来的图片。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; //window.onload页面加载完毕以后再执行此代码 window.onload = function () { //需求：鼠标放到img上，更换为另一张图片，也就是修改路径（src的值）。 //步骤： //1.获取事件源 //2.绑定事件 //3.书写事件驱动程序 //1.获取事件源 var img = document.getElementById(\u0026#34;box\u0026#34;); //2.绑定事件(悬停事件：鼠标进入到事件源中，立即触发事件) img.onmouseover = function () { //3.书写事件驱动程序(修改src) img.src = \u0026#34;image/jd2.png\u0026#34;; // this.src = \u0026#34;image/jd2.png\u0026#34;; } //2.绑定事件(悬停事件：鼠标进入到事件源中，立即触发事件) img.onmouseout = function () { //3.书写事件驱动程序(修改src) img.src = \u0026#34;image/jd1.png\u0026#34;; } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img id=\u0026#34;box\u0026#34; src=\u0026#34;image/jd1.png\u0026#34; style=\u0026#34;cursor: pointer;border: 1px solid #ccc;\u0026#34;/\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/33-%E4%BA%8B%E4%BB%B6%E7%AE%80%E4%BB%8B/","summary":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 事件简介 事件：就","title":"33-事件简介"},{"content":"常见概念 JavaScript的组成 JavaScript基础分为三个部分：\nECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。\nDOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。\nBOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。\n节点 节点（Node）：构成 HTML 网页的最基本单元。网页中的每一个部分都可以称为是一个节点，比如：html标签、属性、文本、注释、整个文档等都是一个节点。\n虽然都是节点，但是实际上他们的具体类型是不同的。常见节点分为四类：\n文档节点（文档）：整个 HTML 文档。整个 HTML 文档就是一个文档节点。\n元素节点（标签）：HTML标签。\n属性节点（属性）：元素的属性。\n文本节点（文本）：HTML标签中的文本内容（包括标签之间的空格、换行）。\n节点的类型不同，属性和方法也都不尽相同。所有的节点都是Object。\n什么是DOM DOM：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。\nDOM就是由节点组成的。\n解析过程： HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树，getElementById是获取内中DOM上的元素节点。然后操作的时候修改的是该元素的属性。\nDOM树：（一切都是节点）\nDOM的数据结构如下：\n上图可知，在HTML当中，一切都是节点（非常重要）。节点的分类，在上一段中，已经讲了。\n整个html文档就是一个文档节点。所有的节点都是Object。\nDOM可以做什么 找对象（元素节点）\n设置元素的属性值\n设置元素的样式\n动态创建和删除元素\n事件的触发响应：事件源、事件、事件的驱动程序\n元素节点的获取 DOM节点的获取方式其实就是获取事件源的方式。关于事件，上一篇文章中已经讲到了。\n想要操作元素节点，必须首先要找到该节点。有三种方式可以获取DOM节点：\n1 2 3 4 5 var div1 = document.getElementById(\u0026#34;box1\u0026#34;); //方式一：通过 id 获取 一个 元素节点（为什么是一个呢？因为 id 是唯一的） var arr1 = document.getElementsByTagName(\u0026#34;div\u0026#34;); //方式二：通过 标签名 获取 元素节点数组，所以有s var arr2 = document.getElementsByClassName(\u0026#34;hehe\u0026#34;); //方式三：通过 类名 获取 元素节点数组，所以有s 既然方式二、方式三获取的是标签数组，那么习惯性是先遍历之后再使用。\n特殊情况：数组中的值只有1个。即便如此，这一个值也是包在数组里的。这个值的获取方式如下：\n1 2 3 document.getElementsByTagName(\u0026#34;div1\u0026#34;)[0]; //取数组中的第一个元素 document.getElementsByClassName(\u0026#34;hehe\u0026#34;)[0]; //取数组中的第一个元素 DOM访问关系的获取 DOM的节点并不是孤立的，因此可以通过DOM节点之间的相对关系对它们进行访问。如下：\n节点的访问关系，是以属性的方式存在的。\nJS中的父子兄访问关系：\n这里我们要重点知道parentNode和children这两个属性的用法。下面分别介绍。\n获取父节点 调用者就是节点。一个节点只有一个父节点，调用方式就是\n1 节点.parentNode 获取兄弟节点 1、下一个节点 | 下一个元素节点：\nSibling的中文是兄弟。\n（1）nextSibling：\n火狐、谷歌、IE9+版本：都指的是下一个节点（包括标签、空文档和换行节点）。\nIE678版本：指下一个元素节点（标签）。\n（2）nextElementSibling：\n火狐、谷歌、IE9+版本：都指的是下一个元素节点（标签）。 总结：为了获取下一个元素节点，我们可以这样做：在IE678中用nextSibling，在火狐谷歌IE9+以后用nextElementSibling，于是，综合这两个属性，可以这样写：\n1 下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling 2、前一个节点 | 前一个元素节点：\nprevious的中文是：前一个。\n（1）previousSibling：\n火狐、谷歌、IE9+版本：都指的是前一个节点（包括标签、空文档和换行节点）。\nIE678版本：指前一个元素节点（标签）。\n（2）previousElementSibling：\n火狐、谷歌、IE9+版本：都指的是前一个元素节点（标签）。 总结：为了获取前一个元素节点，我们可以这样做：在IE678中用previousSibling，在火狐谷歌IE9+以后用previousElementSibling，于是，综合这两个属性，可以这样写：\n1 前一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling 3、补充：获得任意一个兄弟节点：\n1 节点自己.parentNode.children[index]; //随意得到兄弟节点 获取单个的子节点 1、第一个子节点 | 第一个子元素节点：\n（1）firstChild：\n火狐、谷歌、IE9+版本：都指的是第一个子节点（包括标签、空文档和换行节点）。\nIE678版本：指第一个子元素节点（标签）。\n（2）firstElementChild：\n火狐、谷歌、IE9+版本：都指的是第一个子元素节点（标签）。 总结：为了获取第一个子元素节点，我们可以这样做：在IE678中用firstChild，在火狐谷歌IE9+以后用firstElementChild，于是，综合这两个属性，可以这样写：\n1 第一个子元素节点 = 节点.firstElementChild || 节点.firstChild 2、最后一个子节点 | 最后一个子元素节点：\n（1）lastChild：\n火狐、谷歌、IE9+版本：都指的是最后一个子节点（包括标签、空文档和换行节点）。\nIE678版本：指最后一个子元素节点（标签）。\n（2）lastElementChild：\n火狐、谷歌、IE9+版本：都指的是最后一个子元素节点（标签）。 总结：为了获取最后一个子元素节点，我们可以这样做：在IE678中用lastChild，在火狐谷歌IE9+以后用lastElementChild，于是，综合这两个属性，可以这样写：\n1 最后一个子元素节点 = 节点.lastElementChild || 节点.lastChild 获取所有的子节点 （1）childNodes：标准属性。返回的是指定元素的子节点的集合（包括元素节点、所有属性、文本节点）。是W3C的亲儿子。\n火狐 谷歌等高本版会把换行也看做是子节点。 用法：\n1 子节点数组 = 父节点.childNodes; //获取所有节点。 （2）children：非标准属性。返回的是指定元素的子元素节点的集合。【重要】\n它只返回HTML节点，甚至不返回文本节点。 在IE6/7/8中包含注释节点（在IE678中，注释节点不要写在里面）。 虽然不是标准的DOM属性，但它和innerHTML方法一样，得到了几乎所有浏览器的支持。\n用法：（用的最多）\n1 子节点数组 = 父节点.children; //获取所有节点。用的最多。 DOM节点的操作（重要） 上一段的内容：节点的访问关系都是属性。\n本段的内容：节点的操作都是函数（方法）。\n创建节点 格式如下：\n1 新的标签(元素节点) = document.createElement(\u0026#34;标签名\u0026#34;); 比如，如果我们想创建一个li标签，或者是创建一个不存在的adbc标签，可以这样做：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var a1 = document.createElement(\u0026#34;li\u0026#34;); //创建一个li标签 var a2 = document.createElement(\u0026#34;adbc\u0026#34;); //创建一个不存在的标签 console.log(a1); console.log(a2); console.log(typeof a1); console.log(typeof a2); \u0026lt;/script\u0026gt; 打印结果：\n插入节点 插入节点有两种方式，它们的含义是不同的。\n方式1：\n1 父节点.appendChild(新的子节点); 解释：父节点的最后插入一个新的子节点。\n方式2：\n1 父节点.insertBefore(新的子节点,作为参考的子节点) 解释：\n在参考节点前插入一个新的节点。 如果参考节点为null，那么他将在父节点里面的最后插入一个子节点。 我们可以看到，li标签确实被插入到了box1标签的里面，和box2并列了。\n方式2的举例：\n我们可以看到，b1标签被插入到了box1标签的里面，和a1标签并列，在a1标签的前面。\n特别强调：\n关于方式1的appendChild方法，这里要强调一下。比如，现在有下面这样一个div结构：\n1 2 3 4 5 6 7 8 \u0026lt;div class=\u0026#34;box11\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box12\u0026#34;\u0026gt;生命壹号\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box21\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box22\u0026#34;\u0026gt;永不止步\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 上方结构中，子盒子box12是在父亲box11里的，子盒子box22是在父亲box21里面的。现在，如果我调用方法box11.appendChild(box22)，最后产生的结果是：box22会跑到box11中（也就是说，box22不在box21里面了）。这是一个很神奇的事情：\n删除节点 格式如下：\n1 父节点.removeChild(子节点); 解释：用父节点删除子节点。必须要指定是删除哪个子节点。\n如果我想删除自己这个节点，可以这么做：\n1 node1.parentNode.removeChild(node1); 复制节点（克隆节点） 格式如下：\n1 2 3 要复制的节点.cloneNode(); //括号里不带参数和带参数false，效果是一样的。 要复制的节点.cloneNode(true); 括号里带不带参数，效果是不同的。解释如下：\n不带参数/带参数false：只复制节点本身，不复制子节点。\n带参数true：既复制节点本身，也复制其所有的子节点。\n设置节点的属性 我们可以获取节点的属性值、设置节点的属性值、删除节点的属性。\n我们就统一拿下面这个标签来举例：\n1 \u0026lt;img src=\u0026#34;images/1.jpg\u0026#34; class=\u0026#34;image-box\u0026#34; title=\u0026#34;美女图片\u0026#34; alt=\u0026#34;地铁一瞥\u0026#34; id=\u0026#34;a1\u0026#34;\u0026gt; 下面分别介绍。\n1、获取节点的属性值 方式1：\n1 2 元素节点.属性名; 元素节点[属性名]; 举例：（获取节点的属性值）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;images/1.jpg\u0026#34; class=\u0026#34;image-box\u0026#34; title=\u0026#34;美女图片\u0026#34; alt=\u0026#34;地铁一瞥\u0026#34; id=\u0026#34;a1\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var myNode = document.getElementsByTagName(\u0026#34;img\u0026#34;)[0]; console.log(myNode.src); console.log(myNode.className); //注意，是className，不是class console.log(myNode.title); console.log(\u0026#34;------------\u0026#34;); console.log(myNode[\u0026#34;src\u0026#34;]); console.log(myNode[\u0026#34;className\u0026#34;]); //注意，是className，不是class console.log(myNode[\u0026#34;title\u0026#34;]); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 上方代码中的img标签，有各种属性，我们可以逐一获取，打印结果如下：\n方式2：\n1 元素节点.getAttribute(\u0026#34;属性名称\u0026#34;); 举例：\n1 2 3 console.log(myNode.getAttribute(\u0026#34;src\u0026#34;)); console.log(myNode.getAttribute(\u0026#34;class\u0026#34;)); //注意是class，不是className console.log(myNode.getAttribute(\u0026#34;title\u0026#34;)); 打印结果：\n方式1和方式2的区别在于：前者是直接操作标签，后者是把标签作为DOM节点。推荐方式2。\n2、设置节点的属性值 方式1举例：（设置节点的属性值）\n1 2 myNode.src = \u0026#34;images/2.jpg\u0026#34; //修改src的属性值 myNode.className = \u0026#34;image2-box\u0026#34;; //修改class的name 方式2：\n1 元素节点.setAttribute(\u0026#34;属性名\u0026#34;, \u0026#34;新的属性值\u0026#34;); 方式2举例：（设置节点的属性值）\n1 2 3 myNode.setAttribute(\u0026#34;src\u0026#34;,\u0026#34;images/3.jpg\u0026#34;); myNode.setAttribute(\u0026#34;class\u0026#34;,\u0026#34;image3-box\u0026#34;); myNode.setAttribute(\u0026#34;id\u0026#34;,\u0026#34;你好\u0026#34;); 3、删除节点的属性 格式：\n1 元素节点.removeAttribute(属性名); 举例：（删除节点的属性）\n1 2 myNode.removeAttribute(\u0026#34;class\u0026#34;); myNode.removeAttribute(\u0026#34;id\u0026#34;); 总结 获取节点的属性值和设置节点的属性值，都有两种方式。\n如果是节点的“原始属性”（比如 普通标签的class/className属性、普通标签的style属性、普通标签的 title属性、img 标签的src属性、超链接的href属性等），方式1和方式2是等价的，可以混用。怎么理解混用呢？比如说：用 div.title = '我是标题'设置属性，用 div.getAttribute('title')获取属性，就是混用。\n但如果是节点的“非原始属性”，比如：\n1 2 3 div.aaa = \u0026#39;qianguyihao\u0026#39;; div.setAttribute(\u0026#39;bbb\u0026#39;, \u0026#39;qianguyihao\u0026#39;); 上面的这个“非原始属性”，在使用这两种方式时，是有区别的。区别如下：\n方式1 的元素节点.属性和元素节点[属性]：绑定的属性值不会出现在标签上。\n方式2 的get/set/removeAttribut：绑定的属性值会出现在标签上。\n这两种方式不能交换使用，get值和set值必须使用同一种方法。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box\u0026#34; title=\u0026#34;主体\u0026#34; class=\u0026#34;asdfasdfadsfd\u0026#34;\u0026gt;我爱你中国\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementById(\u0026#34;box\u0026#34;); //采用方式一进行set div.aaaa = \u0026#34;1111\u0026#34;; console.log(div.aaaa); //打印结果：1111。可以打印出来，但是不会出现在标签上 //采用方式二进行set div.setAttribute(\u0026#34;bbbb\u0026#34;,\u0026#34;2222\u0026#34;); //bbbb作为新增的属性，会出现在标签上 console.log(div.getAttribute(\u0026#34;aaaa\u0026#34;)); //打印结果：null。因为方式一的set，无法采用方式二进行get。 console.log(div.bbbb); //打印结果：undefined。因为方式二的set，无法采用方式一进行get。 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; DOM对象的属性-补充 innerHTML和innerText的区别 value：标签的value属性。\ninnerHTML：双闭合标签里面的内容（包含标签）。\ninnerText：双闭合标签里面的内容（不包含标签）。（老版本的火狐用textContent）\n获取内容举例：\n如果我们想获取innerHTML和innerText里的内容，看看会如何：（innerHTML会获取到标签本身，而innerText则不会）\n修改内容举例：（innerHTML会修改标签本身，而innerText则不会）\nnodeType属性 这里讲一下nodeType属性。\nnodeType == 1 表示的是元素节点（标签） 。记住：在这里，元素就是标签。\nnodeType == 2 表示是属性节点。\nnodeType == 3 是文本节点。\nnodeType、nodeName、nodeValue 我们那下面这个标签来举例：\n1 2 3 \u0026lt;div id=\u0026#34;box\u0026#34; value=\u0026#34;111\u0026#34;\u0026gt; 生命壹号 \u0026lt;/div\u0026gt; 上面这个标签就包含了三种节点：\n元素节点（标签）\n属性节点\n文本节点\n获取这三个节点的方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var element = document.getElementById(\u0026#34;box1\u0026#34;); //获取元素节点（标签） var attribute = element.getAttributeNode(\u0026#34;id\u0026#34;); //获取box1的属性节点 var txt = element.firstChild; //获取box1的文本节点 var value = element.getAttribute(\u0026#34;id\u0026#34;); //获取id的属性值 console.log(element); console.log(\u0026#34;--------------\u0026#34;); console.log(attribute); console.log(\u0026#34;--------------\u0026#34;); console.log(txt); console.log(\u0026#34;--------------\u0026#34;); console.log(value); 打印结果如下：\n既然这三个都是节点，如果我想获取它们的nodeType、nodeName、nodeValue，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 var element = document.getElementById(\u0026#34;box1\u0026#34;); //获取元素节点（标签） var attribute = element.getAttributeNode(\u0026#34;id\u0026#34;); //获取box1的属性节点 var txt = element.firstChild; //获取box1的文本节点 //获取nodeType console.log(element.nodeType); //1 console.log(attribute.nodeType); //2 console.log(txt.nodeType); //3 console.log(\u0026#34;--------------\u0026#34;); //获取nodeName console.log(element.nodeName); //DIV console.log(attribute.nodeName); //id console.log(txt.nodeName); //#text console.log(\u0026#34;--------------\u0026#34;); //获取nodeValue console.log(element.nodeValue); //null console.log(attribute.nodeValue); //box1 console.log(txt.nodeValue); //生命壹号 打印结果如下：\n文档的加载 浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行。如果将script标签写到页面的上边，在代码执行时，页面还没有加载，页面没有加载DOM对象也没有加载，会导致无法获取到DOM对象。\nonload 事件：\nonload 事件会在整个页面加载完成之后才触发。为 window 绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 【方式一：先加载，后执行】这段 js 代码是写在 \u0026lt;head\u0026gt; 标签里的，所以建议放在 window.onload 里面。 window.onload = function() { // 获取id为btn的按钮 var btn = document.getElementById(\u0026#34;btn\u0026#34;); // 为按钮绑定点击事件 btn.onclick = function() { alert(\u0026#34;hello\u0026#34;); }; }; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button id=\u0026#34;btn\u0026#34;\u0026gt;点我一下\u0026lt;/button\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 【方式二：后加载，后执行】这段 js 代码是写在 \u0026lt;body\u0026gt; 标签里的，代码的位置是处在页面的下方。这么做，也可以确保：在页面加载完毕后，再执行 js 代码。 // 获取id为btn的按钮 var btn = document.getElementById(\u0026#34;btn\u0026#34;); // 为按钮绑定点击事件 btn.onclick = function() { alert(\u0026#34;hello\u0026#34;); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中，方式一和方式二均可以确保：在页面加载完毕后，再执行 js 代码。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/34-dom%E7%AE%80%E4%BB%8B%E5%92%8Cdom%E6%93%8D%E4%BD%9C/","summary":"常见概念 JavaScript的组成 JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达","title":"34-DOM简介和DOM操作"},{"content":"style属性的获取和修改 在DOM当中，如果想设置样式，有两种形式：\nclassName（针对内嵌样式）\nstyle（针对行内样式）\n这篇文章，我们就来讲一下style。\n需要注意的是：style是一个对象，只能获取行内样式，不能获取内嵌的样式和外链的样式。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Title\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { border: 6px solid red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34; style=\u0026#34;width: 200px;height: 100px;background-color: pink;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var box1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; console.log(box1.style.backgroundColor); console.log(box1.style.border); //没有打印结果，因为这个属性不是行内样式 console.log(typeof box1.style); //因为是对象，所以打印结果是Object console.log(box1.style); //打印结果是对象 \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n上图显示，因为border属性不是行内样式，所以无法通过style对象获取。\n通过 js 读取元素的样式 语法：（方式一）\n1 元素.style.样式名 备注：我们通过style属性读取的样式都是行内样式。\n语法：（方式二）\n1 2 3 元素.style[\u0026#34;属性\u0026#34;]; //格式 box.style[\u0026#34;width\u0026#34;]; //举例 方式二最大的优点是：可以给属性传递参数。\n通过 js 设置元素的样式 语法：\n1 元素.style.样式名 = 样式值; 举例：\n1 2 box1.style.width = \u0026#34;300px\u0026#34;; box1.style.backgroundColor = \u0026#34;red\u0026#34;; // 驼峰命名法 备注：我们通过style属性设置的样式都是行内样式，而行内样式有较高的优先级。但是如果在样式中的其他地方写了!important，则此时!important会有更高的优先级。\nstyle属性的注意事项 style属性需要注意以下几点：\n（1）样式少的时候使用。\n（2）style是对象。我们在上方已经打印出来，typeof的结果是Object。\n（3）值是字符串，没有设置值是“”。\n（4）命名规则，驼峰命名。\n（5）只能获取行内样式，和内嵌和外链无关。\n（6）box.style.cssText = “字符串形式的样式”。\ncssText这个属性，其实就是把行内样式里面的值当做字符串来对待。在上方代码的基础之上，举例：\n1 2 3 4 5 6 7 8 9 \u0026lt;script\u0026gt; var box1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; //通过cssText一次性设置行内样式 box1.style.cssText = \u0026#34;width: 300px;height: 300px;background-color: green;\u0026#34;; console.log(box1.style.cssText); //这一行更加可以理解,style是对象 \u0026lt;/script\u0026gt; 打印结果：\nstyle的常用属性 style的常用属性包括：\nbackgroundColor\nbackgroundImage\ncolor\nwidth\nheight\nborder\nopacity 设置透明度 (IE8以前是filter: alpha(opacity=xx))\n注意DOM对象style的属性和标签中style内的值不一样，因为在JS中，-不能作为标识符。比如：\nDOM中：backgroundColor\nCSS中：background-color\nstyle属性的举例 我们针对上面列举的几个style的样式，来举几个例子：\n举例1、改变div的大小和透明度\n举例2、当前输入的文本框高亮显示\n举例3、高级隔行变色、高亮显示\n下面来逐一实现。\n举例1：改变div的大小和透明度 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;width: 100px;height: 100px;background-color: pink;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div.onmouseover = function () { div.style.width = \u0026#34;200px\u0026#34;; div.style.height = \u0026#34;200px\u0026#34;; div.style.backgroundColor = \u0026#34;black\u0026#34;; div.style.opacity = \u0026#34;0.2\u0026#34;; //设置背景色的透明度。单位是0.1 div.style.filter = \u0026#34;alpha(opacity=20)\u0026#34;; //上一行代码的兼容性写法。注意单位是百进制 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 举例2：当前输入的文本框高亮显示 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; input { display: block; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34;/\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;script\u0026gt; //需求：让所有的input标签获取焦点后高亮显示 //1.获取事件源 var inpArr = document.getElementsByTagName(\u0026#34;input\u0026#34;); //2.绑定事件 //3.书写事件驱动程序 for (var i = 0; i \u0026lt; inpArr.length; i++) { //获取焦点后，所有的input标签被绑定onfocus事件 inpArr[i].onfocus = function () { this.style.border = \u0026#34;2px solid red\u0026#34;; this.style.backgroundColor = \u0026#34;#ccc\u0026#34;; } //绑定onblur事件，取消样式 inpArr[i].onblur = function () { this.style.border = \u0026#34;\u0026#34;; this.style.backgroundColor = \u0026#34;\u0026#34;; } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 举例3：高级隔行变色、高亮显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { padding: 0; margin: 0; text-align: center; } .wrap { width: 500px; margin: 100px auto 0; } table { border-collapse: collapse; border-spacing: 0; border: 1px solid #c0c0c0; width: 500px; } th, td { border: 1px solid #d0d0d0; color: #404060; padding: 10px; } th { background-color: #09c; font: bold 16px \u0026#34;微软雅黑\u0026#34;; color: #fff; } td { font: 14px \u0026#34;微软雅黑\u0026#34;; } tbody tr { background-color: #f0f0f0; cursor: pointer; } .current { background-color: red !important; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;wrap\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;序号\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;姓名\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;课程\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;成绩\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody id=\u0026#34;target\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 1 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;生命壹号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;语文\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;100\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 2 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;生命贰号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;日语\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;99\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 3 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;生命叁号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;营销学\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;98\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 4 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;生命伍号\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;数学\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;90\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 5 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;许嵩\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;英语\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;96\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt; 6 \u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;vae\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;体育\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;90\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //需求：让tr各行变色，鼠标放入tr中，高亮显示。 //1.隔行变色。 var tbody = document.getElementById(\u0026#34;target\u0026#34;); var trArr = tbody.children; //循环判断并各行赋值属性（背景色） for (var i = 0; i \u0026lt; trArr.length; i++) { if (i % 2 !== 0) { trArr[i].style.backgroundColor = \u0026#34;#a3a3a3\u0026#34;; } else { trArr[i].style.backgroundColor = \u0026#34;#ccc\u0026#34;; } //鼠标进入高亮显示 //难点：鼠标移开的时候要回复原始颜色。 //计数器（进入tr之后，立刻记录颜色，然后移开的时候使用记录好的颜色） var myColor = \u0026#34;\u0026#34;; trArr[i].onmouseover = function () { //赋值颜色之前，先记录颜色 myColor = this.style.backgroundColor; this.style.backgroundColor = \u0026#34;#fff\u0026#34;; } trArr[i].onmouseout = function () { this.style.backgroundColor = myColor; } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现的效果如下：\n代码解释：\n上方代码中，我们用到了计数器myColor来记录每一行最原始的颜色（赋值白色之前）。如果不用计数器，可能很多人以为代码是写的：（错误的代码）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;script\u0026gt; //需求：让tr各行变色，鼠标放入tr中，高亮显示。 //1.隔行变色。 var tbody = document.getElementById(\u0026#34;target\u0026#34;); var trArr = tbody.children; //循环判断并各行赋值属性（背景色） for (var i = 0; i \u0026lt; trArr.length; i++) { if (i % 2 !== 0) { trArr[i].style.backgroundColor = \u0026#34;#a3a3a3\u0026#34;; } else { trArr[i].style.backgroundColor = \u0026#34;#ccc\u0026#34;; } //鼠标进入高亮显示 //难点：鼠标移开的时候要回复原始颜色。 //计数器（进入tr之后，立刻记录颜色，然后移开的时候使用记录好的颜色） trArr[i].onmouseover = function () { this.style.backgroundColor = \u0026#34;#fff\u0026#34;; } trArr[i].onmouseout = function () { this.style.backgroundColor = \u0026#34;#a3a3a3\u0026#34;; } } \u0026lt;/script\u0026gt; 这种错误的代码，实现的效果却是：（未达到效果）\n通过 js 获取元素当前显示的样式 我们在上面的内容中，通过元素.style.className的方式只能获取行内样式。但是，有些元素，也写了内嵌样式或外链样式。\n既然样式有这么种，那么，如何获取元素当前显示的样式（包括行内样式、内嵌样式、外链样式）呢？我们接下来看一看。\n获取元素当前正在显示的样式 （1）w3c的做法：\n1 window.getComputedStyle(\u0026#34;要获取样式的元素\u0026#34;, \u0026#34;伪元素\u0026#34;); 两个参数都是必须要有的。参数二中，如果没有伪元素就用 null 代替（一般都传null）。\n（2）IE和opera的做法：\n1 obj.currentStyle; 注意：\n如果当前元素没有设置该样式，则获取它的默认值。\n该方法会返回一个对象，对象中封装了当前元素对应的样式，可以通过对象.样式名来读取具体的某一个样式。\n通过currentStyle和getComputedStyle()读取到的样式都是只读的，不能修改，如果要修改必须通过style属性。\n综合上面两种写法，就有了一种兼容性的写法，同时将其封装。代码举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { background-color: pink; /*border: 1px solid #000;*/ padding: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div style=\u0026#34;width: 100px;height: 100px;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; console.log(getStyle(div1, \u0026#34;width\u0026#34;)); console.log(getStyle(div1, \u0026#34;padding\u0026#34;)); console.log(getStyle(div1, \u0026#34;background-color\u0026#34;)); /* * 兼容方法，获取元素当前正在显示的样式。 * 参数： * obj 要获取样式的元素 *. name 要获取的样式名 */ function getStyle(ele, attr) { if (window.getComputedStyle) { return window.getComputedStyle(ele, null)[attr]; } return ele.currentStyle[attr]; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/35-%E9%80%9A%E8%BF%87style%E5%AF%B9%E8%B1%A1%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E8%A1%8C%E5%86%85%E6%A0%B7%E5%BC%8F/","summary":"style属性的获取和修改 在DOM当中，如果想设置样式，有两种形式： className（针对内嵌样式） style（针对行内样式） 这篇文章，我","title":"35-通过style对象获取和设置行内样式"},{"content":"前言 JS动画的主要内容如下：\n1、三大家族和一个事件对象：\n三大家族：offset/scroll/client。也叫三大系列。\n事件对象/event（事件被触动时，鼠标和键盘的状态）（通过属性控制）。\n2、动画(闪现/匀速/缓动)\n3、冒泡/兼容/封装\noffset 家族的组成 我们知道，JS动画的三大家族包括：offset/scroll/client。今天来讲一下offset，以及与其相关的匀速动画。\noffset的中文是：偏移，补偿，位移。\njs中有一套方便的获取元素尺寸的办法就是offset家族。offset家族包括：\noffsetWidth\noffsetHight\noffsetLeft\noffsetTop\noffsetParent\n下面分别介绍。\n1、offsetWidth 和 offsetHight offsetWidth 和 offsetHight：获取元素的宽高 + padding + border，不包括margin。如下：\noffsetWidth = width + padding + border\noffsetHeight = Height + padding + border\n这两个属性，他们绑定在了所有的节点元素上。获取元素之后，只要调用这两个属性，我们就能够获取元素节点的宽和高。\n举例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; padding: 10px; border: 10px solid #000; margin: 100px; background-color: pink; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; console.log(div1.offsetHeight); //打印结果：140（100+20+20） console.log(typeof div1.offsetHeight); //打印结果：number \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 2、offsetParent offsetParent：获取当前元素的定位父元素。\n如果当前元素的父元素，有CSS定位（position为absolute、relative、fixed），那么 offsetParent 获取的是最近的那个父元素。\n如果当前元素的父元素，没有CSS定位（position为absolute、relative、fixed），那么offsetParent 获取的是body。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34; style=\u0026#34;position: absolute;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34; style=\u0026#34;position: fixed;\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var box3 = document.getElementsByClassName(\u0026#34;box3\u0026#34;)[0]; console.log(box3.offsetParent); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n3、offsetLeft 和 offsetTop offsetLeft：当前元素相对于其定位父元素的水平偏移量。\noffsetTop：当前元素相对于其定位父元素的垂直偏移量。\n备注：从父亲的 padding 开始算起，父亲的 border 不算在内。\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box1 { width: 300px; height: 300px; padding: 100px; margin: 100px; position: relative; border: 100px solid #000; background-color: pink; } .box2 { width: 100px; height: 100px; background-color: red; /*position: absolute;*/ /*left: 10px;*/ /*top: 10px;*/ } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34; style=\u0026#34;left: 10px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var box2 = document.getElementsByClassName(\u0026#34;box2\u0026#34;)[0]; //offsetTop和offsetLeft console.log(box2.offsetLeft); //100 console.log(box2.style.left); //10px \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在父盒子有定位的情况下，offsetLeft == style.left(去掉px之后)。注意，后者只识别行内样式。但区别不仅仅于此，下面会讲。\noffsetLeft 和 style.left 区别 （1）最大区别在于：\noffsetLeft 可以返回无定位父元素的偏移量。如果父元素中都没有定位，则body为准。\nstyle.left 只能获取行内样式，如果父元素中都没有设置定位，则返回\u0026quot;\u0026quot;（意思是，返回空字符串）;\n（2）offsetTop 返回的是数字，而 style.top 返回的是字符串，而且还带有单位：px。\n比如：\n1 2 3 div.offsetLeft = 100; div.style.left = \u0026#34;100px\u0026#34;; （3）offsetLeft 和 offsetTop 只读，而 style.left 和 style.top 可读写（只读是获取值，可写是修改值）\n总结：我们一般的做法是：用offsetLeft 和 offsetTop 获取值，用style.left 和 style.top 赋值（比较方便）。理由如下：\nstyle.left：只能获取行内式，获取的值可能为空，容易出现NaN。\noffsetLeft：获取值特别方便，而且是现成的number，方便计算。它是只读的，不能赋值。\n动画的种类 闪现（基本不用）\n匀速（本文重点）\n缓动（后续重点）\n简单举例如下：（每间隔500ms，向右移动盒子100px）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; background-color: pink; position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;动画\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34; style=\u0026#34;left: 0px\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;)[0]; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; //1、闪动 // btn.onclick = function () { // div.style.left = \u0026#34;500px\u0026#34;; // } //2、匀速运动 btn.onclick = function () { //定时器，每隔一定的时间向右走一些 setInterval(function () { console.log(parseInt(div.style.left)); //动画原理： 盒子未来的位置 = 盒子现在的位置 + 步长； //方法1：用offsetLeft获取值，用style.left赋值。 div.style.left = div.offsetLeft + 100 + \u0026#39;px\u0026#39;; // 方法2：必须一开始就在DOM节点上添加 style=\u0026#34;left: 0px;\u0026#34;属性，才能用方法2。否则， div.style.left 的值为 NaN // div.style.left = parseInt(div.style.left)+100+\u0026#34;px\u0026#34;; //方法2： }, 500); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下：\n匀速动画的封装：每间隔30ms，移动盒子10px【重要】 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box1 { margin: 0; padding: 5px; height: 300px; background-color: #ddd; position: relative; } button { margin: 5px; } .box2 { width: 100px; height: 100px; background-color: red; position: absolute; left: 195px; top: 40px; } .box3 { width: 100px; height: 100px; background-color: yellow; position: absolute; left: 0; top: 150px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box1\u0026#34;\u0026gt; \u0026lt;button\u0026gt;运动到 left = 200px\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;运动到 left = 400px\u0026lt;/button\u0026gt; \u0026lt;div class=\u0026#34;box2\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box3\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btnArr = document.getElementsByTagName(\u0026#34;button\u0026#34;); var box2 = document.getElementsByClassName(\u0026#34;box2\u0026#34;)[0]; var box3 = document.getElementsByClassName(\u0026#34;box3\u0026#34;)[0]; //绑定事件 btnArr[0].onclick = function () { //如果有一天我们要传递另外一个盒子，那么我们的方法就不好用了 //所以我们要增加第二个参数，被移动的盒子本身。 animate(box2, 200); animate(box3, 200); } btnArr[1].onclick = function () { animate(box2, 400); animate(box3, 400); } //【重要】方法的封装：每间隔30ms，将盒子向右移动10px function animate(ele, target) { //要用定时器，先清除定时器 //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突 //我们可以把定时器本身，当成为盒子的一个属性 clearInterval(ele.timer); //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负 //目标值如果大于当前值取正，目标值如果小于当前值取负 var speed = target \u0026gt; ele.offsetLeft ? 10 : -10; //speed指的是步长 ele.timer = setInterval(function () { //在执行之前就获取当前值和目标值之差 var val = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + \u0026#34;px\u0026#34;; //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了 //因为步长有正有负，所有转换成绝对值来比较 if (Math.abs(val) \u0026lt; Math.abs(speed)) { ele.style.left = target + \u0026#34;px\u0026#34;; clearInterval(ele.timer); } }, 30) } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现的效果：\n上方代码中的方法封装，可以作为一个模板步骤，要记住。其实，这个封装的方法，写成下面这样，会更严谨，更容易理解：（将if语句进行了改进）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 //【重要】方法的封装：每间隔30ms，将盒子向右移动10px function animate(ele, target) { //要用定时器，先清除定时器 //一个盒子只能有一个定时器，这样的话，不会和其他盒子出现定时器冲突 //我们可以把定时器本身，当成为盒子的一个属性 clearInterval(ele.timer); //我们要求盒子既能向前又能向后，那么我们的步长就得有正有负 //目标值如果大于当前值取正，目标值如果小于当前值取负 var speed = target \u0026gt; ele.offsetLeft ? 10 : -10; //speed指的是步长 ele.timer = setInterval(function () { //在执行之前就获取当前值和目标值之差 var val = target - ele.offsetLeft; //移动的过程中，如果目标值和当前值之差如果小于步长，那么就不能在前进了 //因为步长有正有负，所有转换成绝对值来比较 if (Math.abs(val) \u0026lt; Math.abs(speed)) { //如果val小于步长，则直接到达目的地；否则，每次移动一个步长 ele.style.left = target + \u0026#34;px\u0026#34;; clearInterval(ele.timer); } else { ele.style.left = ele.offsetLeft + speed + \u0026#34;px\u0026#34;; } }, 30) } 代码举例：轮播图的实现 完整版代码如下：（注释已经比较详细）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34;/\u0026gt; \u0026lt;title\u0026gt;无标题文档\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; * { padding: 0; margin: 0; list-style: none; border: 0; } .all { width: 500px; height: 200px; padding: 7px; border: 1px solid #ccc; margin: 100px auto; position: relative; } .screen { width: 500px; height: 200px; overflow: hidden; position: relative; } .screen li { width: 500px; height: 200px; overflow: hidden; float: left; } .screen ul { position: absolute; left: 0; top: 0px; width: 3000px; } .all ol { position: absolute; right: 10px; bottom: 10px; line-height: 20px; text-align: center; } .all ol li { float: left; width: 20px; height: 20px; background: #fff; border: 1px solid #ccc; margin-left: 10px; cursor: pointer; } .all ol li.current { background: yellow; } #arr { display: none; } #arr span { width: 40px; height: 40px; position: absolute; left: 5px; top: 50%; margin-top: -20px; background: #000; cursor: pointer; line-height: 40px; text-align: center; font-weight: bold; font-family: \u0026#39;黑体\u0026#39;; font-size: 30px; color: #fff; opacity: 0.3; border: 1px solid #fff; } #arr #right { right: 5px; left: auto; } \u0026lt;/style\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { //需求：无缝滚动。 //思路：赋值第一张图片放到ul的最后，然后当图片切换到第五张的时候 // 直接切换第六章，再次从第一张切换到第二张的时候先瞬间切换到 // 第一张图片，然后滑动到第二张 //步骤： //1.获取事件源及相关元素。（老三步） //2.复制第一张图片所在的li,添加到ul的最后面。 //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 //4.鼠标放到ol的li上切换图片 //5.添加定时器 //6.左右切换图片（鼠标放上去隐藏，移开显示） //1.获取事件源及相关元素。（老三步） var all = document.getElementById(\u0026#34;all\u0026#34;); var screen = all.firstElementChild || all.firstChild; var imgWidth = screen.offsetWidth; var ul = screen.firstElementChild || screen.firstChild; var ol = screen.children[1]; var div = screen.lastElementChild || screen.lastChild; var spanArr = div.children; //2.复制第一张图片所在的li,添加到ul的最后面。 var ulNewLi = ul.children[0].cloneNode(true); ul.appendChild(ulNewLi); //3.给ol中添加li，ul中的个数-1个，并点亮第一个按钮。 for (var i = 0; i \u0026lt; ul.children.length - 1; i++) { var olNewLi = document.createElement(\u0026#34;li\u0026#34;); olNewLi.innerHTML = i + 1; ol.appendChild(olNewLi) } var olLiArr = ol.children; olLiArr[0].className = \u0026#34;current\u0026#34;; //4.鼠标放到ol的li上切换图片 for (var i = 0; i \u0026lt; olLiArr.length; i++) { //自定义属性，把索引值绑定到元素的index属性上 olLiArr[i].index = i; olLiArr[i].onmouseover = function () { //排他思想 for (var j = 0; j \u0026lt; olLiArr.length; j++) { olLiArr[j].className = \u0026#34;\u0026#34;; } this.className = \u0026#34;current\u0026#34;; //鼠标放到小的方块上的时候索引值和key以及square同步 // key = this.index; // square = this.index; key = square = this.index; //移动盒子 animate(ul, -this.index * imgWidth); } } //5.添加定时器 var timer = setInterval(autoPlay, 1000); //固定向右切换图片 //两个定时器（一个记录图片，一个记录小方块） var key = 0; var square = 0; function autoPlay() { //通过控制key的自增来模拟图片的索引值，然后移动ul key++; if (key \u0026gt; olLiArr.length) { //图片已经滑动到最后一张，接下来，跳转到第一张，然后在滑动到第二张 ul.style.left = 0; key = 1; } animate(ul, -key * imgWidth); //通过控制square的自增来模拟小方块的索引值，然后点亮盒子 //排他思想做小方块 square++; if (square \u0026gt; olLiArr.length - 1) {//索引值不能大于等于5，如果等于5，立刻变为0； square = 0; } for (var i = 0; i \u0026lt; olLiArr.length; i++) { olLiArr[i].className = \u0026#34;\u0026#34;; } olLiArr[square].className = \u0026#34;current\u0026#34;; } //鼠标放上去清除定时器，移开后在开启定时器 all.onmouseover = function () { div.style.display = \u0026#34;block\u0026#34;; clearInterval(timer); } all.onmouseout = function () { div.style.display = \u0026#34;none\u0026#34;; timer = setInterval(autoPlay, 1000); } //6.左右切换图片（鼠标放上去显示，移开隐藏） spanArr[0].onclick = function () { //通过控制key的自增来模拟图片的索引值，然后移动ul key--; if (key \u0026lt; 0) { //先移动到最后一张，然后key的值取之前一张的索引值，然后在向前移动 ul.style.left = -imgWidth * (olLiArr.length) + \u0026#34;px\u0026#34;; key = olLiArr.length - 1; } animate(ul, -key * imgWidth); //通过控制square的自增来模拟小方块的索引值，然后点亮盒子 //排他思想做小方块 square--; if (square \u0026lt; 0) {//索引值不能大于等于5，如果等于5，立刻变为0； square = olLiArr.length - 1; } for (var i = 0; i \u0026lt; olLiArr.length; i++) { olLiArr[i].className = \u0026#34;\u0026#34;; } olLiArr[square].className = \u0026#34;current\u0026#34;; } spanArr[1].onclick = function () { //右侧的和定时器一模一样 autoPlay(); } function animate(ele, target) { clearInterval(ele.timer); var speed = target \u0026gt; ele.offsetLeft ? 10 : -10; ele.timer = setInterval(function () { var val = target - ele.offsetLeft; ele.style.left = ele.offsetLeft + speed + \u0026#34;px\u0026#34;; if (Math.abs(val) \u0026lt; Math.abs(speed)) { ele.style.left = target + \u0026#34;px\u0026#34;; clearInterval(ele.timer); } }, 10) } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;all\u0026#34; id=\u0026#39;all\u0026#39;\u0026gt; \u0026lt;div class=\u0026#34;screen\u0026#34; id=\u0026#34;screen\u0026#34;\u0026gt; \u0026lt;ul id=\u0026#34;ul\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/1.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/2.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/3.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/4.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;img src=\u0026#34;images/5.jpg\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;200\u0026#34;/\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;div id=\u0026#34;arr\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;left\u0026#34;\u0026gt;\u0026lt;\u0026lt;/span\u0026gt; \u0026lt;span id=\u0026#34;right\u0026#34;\u0026gt;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\n温馨提示：动图太大，可以把http://img.smyhvae.com/20180202_2020.gif单独在浏览器中打开。\n工程文件：\n2018-02-02-JS动画实现轮播图.rar ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/36-offset%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E5%8C%80%E9%80%9F%E5%8A%A8%E7%94%BB%E5%90%AB%E8%BD%AE%E6%92%AD%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0/","summary":"前言 JS动画的主要内容如下： 1、三大家族和一个事件对象： 三大家族：offset/scroll/client。也叫三大系列。 事件对象/even","title":"36-offset相关属性和匀速动画(含轮播图的实现)"},{"content":"scroll 相关属性 window.onscroll() 方法 当我们用鼠标滚轮，滚动网页的时候，会触发 window.onscroll() 方法。效果如下：（注意看控制台的打印结果）\n如果你需要做滚动监听，可以使用这个方法。\n我们来看看和 scroll 相关的有哪些属性。\n1、ScrollWidth 和 scrollHeight ScrollWidth 和 scrollHeight：获取元素整个滚动区域的宽、高。包括 width 和 padding，不包括 border和margin。\n注意：\nscrollHeight 的特点是：如果内容超出了盒子，scrollHeight为内容的高（包括超出的内容）；如果不超出，scrollHeight为盒子本身的高度。ScrollWidth同理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; padding: 10px; margin: 3px; border: 8px solid red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 静，能寒窗苦守；动，能点石成金。 \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; // `scrollHeight` 的特点是：如果内容超出了盒子，`scrollHeight`为内容的高（包括超出的内容）；如果不超出，`scrollHeight`为盒子本身的高度。 //IE8以下（不包括IE8），为盒子本身内容的高度。 console.log(div.scrollWidth); console.log(div.scrollHeight); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\n2、scrollTop 和 scrollLeft scrollLeft：获取水平滚动条滚动的距离。\nscrollTop：获取垂直滚动条滚动的距离。\n实战经验：\n当某个元素满足scrollHeight - scrollTop == clientHeight时，说明垂直滚动条滚动到底了。\n当某个元素满足scrollWidth - scrollLeft == clientWidth时，说明水平滚动条滚动到底了。\n这个实战经验非常有用，可以用来判断用户是否已经将内容滑动到底了。比如说，有些场景下，希望用户能够看完“长长的活动规则”，才允许触发接下来的表单操作。\nscrollTop 的兼容性 如果要获取页面滚动的距离，scrollTop 这个属性的写法要注意兼容性，如下。\n（1）如果文档没有 DTD 声明，写法为：\n1 document.body.scrollTop 在没有 DTD 声明的情况下，要求是这种写法，chrome浏览器才能认出来。\n（2）如果文档有 DTD 声明，写法为：\n1 document.documentElement.scrollTop 在有 DTD 声明的情况下，要求是这种写法，IE6、7、8才能认出来。\n综合上面这两个，就诞生了一种兼容性的写法：\n1 2 3 document.body.scrollTop || document.documentElement.scrollTop //方式一 document.body.scrollTop + document.documentElement.scrollTop //方式二 另外还有一种兼容性的写法：window.pageYOffset 和 window.pageXOffset。这种写法无视DTD的声明。这种写法支持的浏览器版本是：火狐/谷歌/ie9+。\n综合上面的几种写法，为了兼容，不管有没有DTD，最终版的兼容性写法：\n1 window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop; 判断是否已经 DTD 声明 方法如下：\n1 2 document.compatMode === \u0026#34;CSS1Compat\u0026#34; // 已声明 document.compatMode === \u0026#34;BackCompat\u0026#34; // 未声明 将 scrollTop 和 scrollLeft 进行封装 这里，我们将 scrollTop 和 scrollLeft 封装为一个方法，名叫scroll()，返回值为 一个对象。以后就直接调用scroll().top 和 scroll().left就好。\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { height: 6000px; width: 5000px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; //需求：封装一个兼容的scroll().返回的是对象，用scroll().top获取scrollTop，用scroll().left获取scrollLeft window.onscroll = function () { // var myScroll = scroll(); // myScroll.top; console.log(scroll().top); console.log(scroll().left); } //函数封装（简单封装，实际工作使用） function scroll() { return { //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中，函数定义的那部分就是要封装的代码。\n另外还有一种比较麻烦的封装方式：（仅供参考）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function scroll() { // 开始封装自己的scrollTop if(window.pageYOffset !== undefined) { // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return { left: window.pageXOffset, top: window.pageYOffset } } else if(document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { // 标准浏览器 来判断有没有声明DTD return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop } } return { // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop } } 获取 html 文档的方法 获取title、body、head、html标签的方法如下：\ndocument.title 文档标题；\ndocument.head 文档的头标签\ndocument.body 文档的body标签；\ndocument.documentElement （这个很重要）。\ndocument.documentElement表示文档的html标签。也就是说，基本结构当中的 html 标签而是通过document.documentElement访问的，并不是通过 document.html 去访问的。\nscrollTop 举例：固定导航栏 完整版代码实现：\n（1）index.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0 } img { vertical-align: top; } .main { margin: 0 auto; width: 1000px; margin-top: 10px; } #Q-nav1 { overflow: hidden; } .fixed { position: fixed; top: 0; left: 0; } \u0026lt;/style\u0026gt; \u0026lt;!--引入工具js--\u0026gt; \u0026lt;script src=\u0026#34;tools.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { //需求1：当我们滚动界面的时候，被卷曲的头部如果超过第二个盒子距离顶部的位置，那么直接给第二个盒子加类名.fixed //需求2：当我们滚动界面的时候，被卷曲的头部如果小于第二个盒子距离顶部的位置，那么直接给第二个盒子取消类名.fixed //1.老三步。 var topDiv = document.getElementById(\u0026#34;top\u0026#34;); var height = topDiv.offsetHeight; var middle = document.getElementById(\u0026#34;Q-nav1\u0026#34;); var main = document.getElementById(\u0026#34;main\u0026#34;); window.onscroll = function () { //2.判断 ，被卷曲的头部的大小 if (scroll().top \u0026gt; height) { //3.满足条件添加类，否则删除类 middle.className += \u0026#34; fixed\u0026#34;; //第二个盒子也要占位置，为了避免重叠，我们给第三个盒子一个上padding的空间，把这个空间留给第二个盒子 main.style.paddingTop = middle.offsetHeight + \u0026#34;px\u0026#34;; } else { middle.className = \u0026#34;\u0026#34;; //清零 main.style.paddingTop = 0; } } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;top\u0026#34; id=\u0026#34;top\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/top.png\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;Q-nav1\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/nav.png\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;main\u0026#34; id=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/main.png\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码中，有一个技巧：\n1 main.style.paddingTop = middle.offsetHeight + \u0026#34;px\u0026#34;; 仔细看注释就好。\n（2）tools.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /** * Created by smyhvae on 2018/02/03. */ function scroll() { // 开始封装自己的scrollTop if (window.pageYOffset !== undefined) { // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return { left: window.pageXOffset, top: window.pageYOffset } } else if (document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { // 标准浏览器 来判断有没有声明DTD return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop } } return { // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop } } 实现效果：\n工程文件：\n2018-02-03-scrollTop固定导航栏.rar 缓动动画 三个函数 缓慢动画里，我们要用到三个函数，这里先列出来：\nMath.ceil() 向上取整\nMath.floor() 向下取整\nMath.round(); 四舍五入\n缓动动画的原理 缓动动画的原理就是：在移动的过程中，步长越来越小。\n设置步长为：目标位置和盒子当前位置的十分之一。用公式表达，即：\n1 盒子位置 = 盒子本身位置 + (目标位置 - 盒子本身位置)/ 10； 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; background-color: pink; position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;运动到left = 400px\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;)[0]; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; btn.onclick = function () { setInterval(function () { //动画原理：盒子未来的位置 = 盒子当前的位置+步长 div.style.left = div.offsetLeft + (400 - div.offsetLeft) / 10 + \u0026#34;px\u0026#34;; }, 30); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果：\n缓慢动画的封装（解决四舍五入的问题） 我们发现一个问题，上图中的盒子最终并没有到达400px的位置，而是只到了396.04px就停住了：\n原因是：JS在取整的运算时，进行了四舍五入。\n我们把打印396.04px这个left值打印出来看看：\n我么发现，通过div.style.left获取的值是精确的，通过div.offsetLeft获取的left值会进行四舍五入。\n此时，我们就要用到取整的函数了。\n通过对缓动动画进行封装，完整版的代码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; background-color: pink; position: absolute; left: 0; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;运动到200\u0026lt;/button\u0026gt; \u0026lt;button\u0026gt;运动到400\u0026lt;/button\u0026gt; \u0026lt;div\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;); var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; btn[0].onclick = function () { animate(div, 200); } btn[1].onclick = function () { animate(div, 400); } //缓动动画封装 function animate(ele, target) { //要用定时器，先清定时器 //一个萝卜一个坑儿，一个元素对应一个定时器 clearInterval(ele.timer); //定义定时器 ele.timer = setInterval(function () { //获取步长 //步长应该是越来越小的，缓动的算法。 var step = (target - ele.offsetLeft) / 10; //对步长进行二次加工(大于0向上取整,小于0向下取整) //达到的效果是：最后10像素的时候都是1像素1像素的向目标位置移动，就能够到达指定位置。 step = step \u0026gt; 0 ? Math.ceil(step) : Math.floor(step); //动画原理： 目标位置 = 当前位置 + 步长 ele.style.left = ele.offsetLeft + step + \u0026#34;px\u0026#34;; console.log(step); //检测缓动动画有没有停止 console.log(\u0026#34;smyhvae\u0026#34;); if (Math.abs(target - ele.offsetLeft) \u0026lt;= Math.abs(step)) { //处理小数赋值 ele.style.left = target + \u0026#34;px\u0026#34;; clearInterval(ele.timer); } }, 30); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\nwindow.scrollTo()方法举例：返回到顶部小火箭 （1）index.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; img { position: fixed; bottom: 100px; right: 50px; cursor: pointer; display: none; border: 1px solid #000; } div { width: 1210px; margin: 100px auto; text-align: center; font: 500 26px/35px \u0026#34;simsun\u0026#34;; color: red; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;tools.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { //需求：被卷去的头部超过100显示小火箭，然后点击小火箭屏幕缓慢移动到最顶端。 //难点：我们以前是移动盒子，现在是移动屏幕，我们没有学过如何移动屏幕。 // 技术点：window.scrollTo(x,y);浏览器显示区域跳转到指定的坐标 //步骤： //1.老三步 var img = document.getElementsByTagName(\u0026#34;img\u0026#34;)[0]; window.onscroll = function () { //被卷去的距离大于200显示小火箭，否则隐藏 //2.显示隐藏小火箭 if (scroll().top \u0026gt; 1000) { img.style.display = \u0026#34;block\u0026#34;; } else { img.style.display = \u0026#34;none\u0026#34;; } //每次移动滚动条的时候都给leader赋值，模拟leader获取距离顶部的距离 leader = scroll().top; } //3.缓动跳转到页面最顶端（利用我们的缓动动画） var timer = null; var target = 0; //目标位置 var leader = 0; //显示区域自身的位置 img.onclick = function () { //技术点：window.scrollTo(0,0); //要用定时器，先清定时器 clearInterval(timer); timer = setInterval(function () { //获取步长 var step = (target - leader) / 10; //二次处理步长 step = step \u0026gt; 0 ? Math.ceil(step) : Math.floor(step); leader = leader + step; //往上移动的过程中，step是负数。当前位置减去步长，就等于下一步的位置。 //显示区域移动 window.scrollTo(0, leader); //清除定时器 if (leader === 0) { clearInterval(timer); } }, 25); } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;img src=\u0026#34;images/Top.jpg\u0026#34;/\u0026gt; \u0026lt;div\u0026gt; 我是最顶端.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; 生命壹号，永不止步.....\u0026lt;br\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）tools.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 /** * Created by smyhvae on 2015/12/8. */ //函数：获取scrollTop和scrollLeft的值 function scroll() { // 开始封装自己的scrollTop if (window.pageYOffset != null) { // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return { left: window.pageXOffset, top: window.pageYOffset } } else if (document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { // 标准浏览器 来判断有没有声明DTD return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop } } return { // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop } } 实现效果：\n小火箭的图片资源：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/37-scroll%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BC%93%E5%8A%A8%E5%8A%A8%E7%94%BB/","summary":"scroll 相关属性 window.onscroll() 方法 当我们用鼠标滚轮，滚动网页的时候，会触发 window.onscroll() 方法。效果如下：（注意看控制台的打印结果） 如果你需要做滚动监听，可以使用这个方法。","title":"37-scroll相关属性和缓动动画"},{"content":"client 家族的组成 clientWidth 和 clientHeight 元素调用时：\nclientWidth：获取元素的可见宽度（width + padding）。\nclientHeight：获取元素的可见高度（height + padding）。\nbody/html 调用时：\nclientWidth：获取网页可视区域宽度。\nclientHeight：获取网页可视区域高度。\n声明：\nclientWidth 和 clientHeight 属性是只读的，不可修改。\nclientWidth 和 clientHeight 的值都是不带 px 的，返回的都是一个数字，可以直接进行计算。\nclientX 和 clientY event调用：\nclientX：鼠标距离可视区域左侧距离。\nclientY：鼠标距离可视区域上侧距离。\nclientTop 和 clientLeft clientTop：盒子的上border。\nclientLeft：盒子的左border。\n三大家族 offset/scroll/client 的区别 区别1：宽高 offsetWidth = width + padding + border\noffsetHeight = height + padding + border\nscrollWidth = 内容宽度（不包含border）\nscrollHeight = 内容高度（不包含border）\nclientWidth = width + padding\nclientHeight = height + padding\n区别2：上左 offsetTop/offsetLeft：\n调用者：任意元素。(盒子为主) 作用：距离父系盒子中带有定位的距离。 scrollTop/scrollLeft：\n调用者：document.body.scrollTop（window调用）(盒子也可以调用，但必须有滚动条) 作用：浏览器无法显示的部分（被卷去的部分）。 clientY/clientX：\n调用者：event 作用：鼠标距离浏览器可视区域的距离（左、上）。 函数封装：获取浏览器的宽高（可视区域） 函数封装如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 //函数封装：获取屏幕可视区域的宽高 function client() { if (window.innerHeight !== undefined) { //ie9及其以上的版本的写法 return { \u0026#34;width\u0026#34;: window.innerWidth, \u0026#34;height\u0026#34;: window.innerHeight } } else if (document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { //标准模式的写法（有DTD时） return { \u0026#34;width\u0026#34;: document.documentElement.clientWidth, \u0026#34;height\u0026#34;: document.documentElement.clientHeight } } else { //没有DTD时的写法 return { \u0026#34;width\u0026#34;: document.body.clientWidth, \u0026#34;height\u0026#34;: document.body.clientHeight } } } 案例：根据浏览器的可视宽度，给定不同的背景的色。\nPS：这个可以用来做响应式。\n代码如下：（需要用到上面的封装好的方法）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;tools.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //需求：浏览器每次更改大小，判断是否符合某一标准然后给背景上色。 // // \u0026gt;960红色，大于640小于960蓝色，小于640绿色。 window.onresize = fn; //页面大小发生变化时，执行该函数。 //页面加载的时候直接执行一次函数，确定浏览器可视区域的宽，给背景上色 fn(); //封装成函数，然后指定的时候去调用和绑定函数名 function fn() { if (client().width \u0026gt; 960) { document.body.style.backgroundColor = \u0026#34;red\u0026#34;; } else if (client().width \u0026gt; 640) { document.body.style.backgroundColor = \u0026#34;blue\u0026#34;; } else { document.body.style.backgroundColor = \u0026#34;green\u0026#34;; } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上当代码中，window.onresize事件指的是：在窗口或框架被调整大小时发生。各个事件的解释如下：\nwindow.onscroll 屏幕滑动\nwindow.onresize 浏览器大小变化\nwindow.onload\t页面加载完毕\ndiv.onmousemove 鼠标在盒子上移动（注意：不是盒子移动）\n获取显示器的分辨率 比如，我的电脑的显示器分辨率是：1920*1080。\n获取显示器的分辨率：\n1 2 3 window.onresize = function () { document.title = window.screen.width + \u0026#34; \u0026#34; + window.screen.height; } 显示效果：\n上图中，不管我如何改变浏览器的窗口大小，title栏显示的值永远都是我的显示器分辨率：1920*1080。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/38-client%E5%8F%AF%E8%A7%86%E5%8C%BA%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7/","summary":"client 家族的组成 clientWidth 和 clientHeight 元素调用时： clientWidth：获取元素的可见宽度（width + padding）。 clientHeight：获取元素的","title":"38-client(可视区)相关属性"},{"content":"绑定事件的两种方式/DOM事件的级别 我们在之前的一篇文章《04-JavaScript/22-DOM简介和DOM操作》中已经讲过事件的概念。这里讲一下绑定（注册）事件的两种方式，我们以onclick事件为例。\nDOM0的写法：onclick 1 2 3 element.onclick = function () { } 举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;点我\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;)[0]; //这种事件绑定的方式，如果绑定多个，则后面的会覆盖掉前面的 btn.onclick = function () { console.log(\u0026#34;事件1\u0026#34;); } btn.onclick = function () { console.log(\u0026#34;事件2\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 点击按钮后，上方代码的打印结果：\n1 事件2 我们可以看到，DOM对象.事件 = 函数的这种绑定事件的方式：一个元素的一个事件只能绑定一个响应函数。如果绑定了多个响应函数，则后者会覆盖前者。\nDOM2的写法：addEventListener（高版本浏览器） 1 2 3 element.addEventListener(\u0026#39;click\u0026#39;, function () { }, false); 参数解释：\n参数1：事件名的字符串(注意，没有on)\n参数2：回调函数：当事件触发时，该函数会被执行\n参数3：true表示捕获阶段触发，false表示冒泡阶段触发（默认）。如果不写，则默认为false。【重要】\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#34;button\u0026#34;)[0]; // addEventListener: 事件监听器。 原事件被执行的时候，后面绑定的事件照样被执行 // 这种写法不存在响应函数被覆盖的情况。（更适合团队开发） btn.addEventListener(\u0026#34;click\u0026#34;, fn1); btn.addEventListener(\u0026#34;click\u0026#34;, fn2); function fn1() { console.log(\u0026#34;事件1\u0026#34;); } function fn2() { console.log(\u0026#34;事件2\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 点击按钮后，上方代码的打印结果：\n1 2 事件1 事件2 我们可以看到，addEventListener()这种绑定事件的方式：\n一个元素的一个事件，可以绑定多个响应函数。不存在响应函数被覆盖的情况。执行顺序是：事件被触发时，响应函数会按照函数的绑定顺序执行。\naddEventListener()中的this，是绑定事件的对象。\naddEventListener()不支持 IE8 及以下的浏览器。在IE8中可以使用attachEvent来绑定事件（详见下一小段）。\nDOM2的写法：attachEvent（IE8及以下版本浏览器） 1 2 3 element.attachEvent(\u0026#39;onclick\u0026#39;, function () { }); 参数解释：\n参数1：事件名的字符串(注意，有on)\n参数2：回调函数：当事件触发时，该函数会被执行\n举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#39;button\u0026#39;)[0]; btn.attachEvent(\u0026#39;onclick\u0026#39;, function() { console.log(\u0026#39;事件1\u0026#39;); }); btn.attachEvent(\u0026#39;onclick\u0026#39;, function() { console.log(\u0026#39;事件2\u0026#39;); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 在低版本的IE浏览器上，点击按钮后，上方代码的打印结果：\n1 2 事件2 事件1 我们可以看到，attachEvent()这种绑定事件的方式：\n一个元素的一个事件，可以绑定多个响应函数。不存在响应函数被覆盖的情况。注意：执行顺序是，后绑定的先执行。\nattachEvent()中的this，是window\n兼容性写法 上面的内容里，需要强调的是：\naddEventListener()中的this，是绑定事件的对象。\nattachEvent()中的this，是window。\n既然这两个写法的this不同，那么，有没有一种兼容性的写法可以确保这两种绑定方式的this是相同的呢？我们可以封装一下。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 \u0026lt;body\u0026gt; \u0026lt;button\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; var btn = document.getElementsByTagName(\u0026#39;button\u0026#39;)[0]; myBind(btn , \u0026#34;click\u0026#34; , function(){ alert(this); }); //定义一个函数，用来为指定元素绑定响应函数 /* * addEventListener()中的this，是绑定事件的对象 * attachEvent()中的this，是window * 需要统一两个方法this */ /* * 参数： * element 要绑定事件的对象 * eventStr 事件的字符串(不要on) * callback 回调函数 */ function myBind(element , eventStr , callback){ if(element.addEventListener){ //大部分浏览器兼容的方式 element.addEventListener(eventStr , callback , false); }else{ /* * this是谁，由调用方式决定 * callback.call(element) */ //IE8及以下 element.attachEvent(\u0026#34;on\u0026#34;+eventStr , function(){ //在匿名函数 function 中调用回调函数callback callback.call(element); }); } } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 事件对象 当事件的响应函数被触发时，会产生一个事件对象event。浏览器每次都会将这个事件event作为实参传进之前的响应函数。\n这个对象中包含了与当前事件相关的一切信息。比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向等。\n获取 event 对象（兼容性问题） 所有浏览器都支持event对象，但支持的方式不同。如下。\n（1）普通浏览器的写法是 event。比如：\n（2）ie 678 的写法是 window.event。此时，事件对象 event 是作为window对象的属性保存的。\n于是，我们可以采取一种兼容性的写法。如下：\n1 event = event || window.event; // 兼容性写法 代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; //点击页面的任何部分 document.onclick = function (event) { event = event || window.event; ////兼容性写法 console.log(event); console.log(event.timeStamp); console.log(event.bubbles); console.log(event.button); console.log(event.pageX); console.log(event.pageY); console.log(event.screenX); console.log(event.screenY); console.log(event.target); console.log(event.type); console.log(event.clientX); console.log(event.clientY); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; event 属性 event 有很多属性，比如：\n由于pageX 和 pageY的兼容性不好，我们可以这样做：\n鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 Event举例 举例1：使 div 跟随鼠标移动 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #box1 { width: 100px; height: 100px; background-color: red; /* * 开启box1的绝对定位 */ position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function() { /* * 使div可以跟随鼠标移动 */ //获取box1 var box1 = document.getElementById(\u0026#34;box1\u0026#34;); //给整个页面绑定：鼠标移动事件 document.onmousemove = function(event) { //兼容的方式获取event对象 event = event || window.event; // 鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; // 设置div的偏移量（相对于整个页面） // 注意，如果想通过 style.left 来设置属性，一定要给 box1开启绝对定位。 box1.style.left = pagex + \u0026#34;px\u0026#34;; box1.style.top = pagey + \u0026#34;px\u0026#34;; }; }; // scroll 函数封装 function scroll() { return { //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft }; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;height: 1000px;width: 2000px;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 举例2：获取鼠标距离所在盒子的距离 关键点：\n1 鼠标距离所在盒子的距离 = 鼠标在整个页面的位置 - 所在盒子在整个页面的位置 代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box { width: 300px; height: 200px; padding-top: 100px; background-color: pink; margin: 100px; text-align: center; font: 18px/30px \u0026#34;simsun\u0026#34;; cursor: pointer; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;animate.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //需求：鼠标进入盒子之后只要移动，哪怕1像素，随时显示鼠标在盒子中的坐标。 //技术点：新事件，onmousemove：在事件源上，哪怕鼠标移动1像素也会触动这个事件。 //一定程度上，模拟了定时器 //步骤： //1.老三步和新五步 //2.获取鼠标在整个页面的位置 //3.获取盒子在整个页面的位置 //4.用鼠标的位置减去盒子的位置赋值给盒子的内容。 //1.老三步和新五步 var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div.onmousemove = function (event) { event = event || window.event; //2.获取鼠标在整个页面的位置 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; //3.获取盒子在整个页面的位置 // var xx = // var yy = //4.用鼠标的位置减去盒子的位置赋值给盒子的内容。 var targetx = pagex - div.offsetLeft; var targety = pagey - div.offsetTop; this.innerHTML = \u0026#34;鼠标在盒子中的X坐标为：\u0026#34; + targetx + \u0026#34;px;\u0026lt;br\u0026gt;鼠标在盒子中的Y坐标为：\u0026#34; + targety + \u0026#34;px;\u0026#34; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实现效果：\n举例3：商品放大镜 代码实现：\n（1）index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .box { width: 350px; height: 350px; margin: 100px; border: 1px solid #ccc; position: relative; } .big { width: 400px; height: 400px; position: absolute; top: 0; left: 360px; border: 1px solid #ccc; overflow: hidden; display: none; } /*mask的中文是：遮罩*/ .mask { width: 175px; height: 175px; background: rgba(255, 255, 0, 0.4); position: absolute; top: 0; left: 0; cursor: move; display: none; } .small { position: relative; } img { vertical-align: top; } \u0026lt;/style\u0026gt; \u0026lt;script src=\u0026#34;tools.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { //需求：鼠标放到小盒子上，让大盒子里面的图片和我们同步等比例移动。 //技术点：onmouseenter==onmouseover 第一个不冒泡 //技术点：onmouseleave==onmouseout 第一个不冒泡 //步骤： //1.鼠标放上去显示盒子，移开隐藏盒子。 //2.老三步和新五步（黄盒子跟随移动） //3.右侧的大图片，等比例移动。 //0.获取相关元素 var box = document.getElementsByClassName(\u0026#34;box\u0026#34;)[0]; var small = box.firstElementChild || box.firstChild; var big = box.children[1]; var mask = small.children[1]; var bigImg = big.children[0]; //1.鼠标放上去显示盒子，移开隐藏盒子。(为小盒子绑定事件) small.onmouseenter = function () { //封装好方法调用：显示元素 show(mask); show(big); } small.onmouseleave = function () { //封装好方法调用：隐藏元素 hide(mask); hide(big); } //2.老三步和新五步（黄盒子跟随移动） //绑定的事件是onmousemove，而事件源是small(只要在小盒子上移动1像素，黄盒子也要跟随) small.onmousemove = function (event) { //新五步 event = event || window.event; //想要移动黄盒子，必须要知道鼠标在small小图中的位置。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; //x：mask的left值，y：mask的top值。 var x = pagex - box.offsetLeft - mask.offsetWidth / 2; //除以2，可以保证鼠标mask的中间 var y = pagey - box.offsetTop - mask.offsetHeight / 2; //限制换盒子的范围 //left取值为大于0，小盒子的宽-mask的宽。 if (x \u0026lt; 0) { x = 0; } if (x \u0026gt; small.offsetWidth - mask.offsetWidth) { x = small.offsetWidth - mask.offsetWidth; } //top同理。 if (y \u0026lt; 0) { y = 0; } if (y \u0026gt; small.offsetHeight - mask.offsetHeight) { y = small.offsetHeight - mask.offsetHeight; } //移动黄盒子 console.log(small.offsetHeight); mask.style.left = x + \u0026#34;px\u0026#34;; mask.style.top = y + \u0026#34;px\u0026#34;; //3.右侧的大图片，等比例移动。 //如何移动大图片？等比例移动。 // 大图片/大盒子 = 小图片/mask盒子 // 大图片走的距离/mask走的距离 = （大图片-大盒子）/（小图片-黄盒子） // var bili = (bigImg.offsetWidth-big.offsetWidth)/(small.offsetWidth-mask.offsetWidth); //大图片走的距离/mask盒子都的距离 = 大图片/小图片 var bili = bigImg.offsetWidth / small.offsetWidth; var xx = bili * x; //知道比例，就可以移动大图片了 var yy = bili * y; bigImg.style.marginTop = -yy + \u0026#34;px\u0026#34;; bigImg.style.marginLeft = -xx + \u0026#34;px\u0026#34;; } } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;small\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/001.jpg\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;div class=\u0026#34;mask\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;big\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;images/0001.jpg\u0026#34; alt=\u0026#34;\u0026#34;/\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; （2）tools.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Created by smyhvae on 2018/02/03. */ //显示和隐藏 function show(ele) { ele.style.display = \u0026#34;block\u0026#34;; } function hide(ele) { ele.style.display = \u0026#34;none\u0026#34;; } function scroll() { // 开始封装自己的scrollTop if (window.pageYOffset != null) { // ie9+ 高版本浏览器 // 因为 window.pageYOffset 默认的是 0 所以这里需要判断 return { left: window.pageXOffset, top: window.pageYOffset } } else if (document.compatMode === \u0026#34;CSS1Compat\u0026#34;) { // 标准浏览器 来判断有没有声明DTD return { left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop } } return { // 未声明 DTD left: document.body.scrollLeft, top: document.body.scrollTop } } 效果演示：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/39-%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%BB%91%E5%AE%9A%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1event/","summary":"绑定事件的两种方式/DOM事件的级别 我们在之前的一篇文章《04-JavaScript/22-DOM简介和DOM操作》中已经讲过事件的概念。这","title":"39-事件的绑定和事件对象Event"},{"content":"DOM事件流 事件传播的三个阶段是：事件捕获、事件冒泡和目标。\n事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。\n事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。\n事件冒泡阶段：事件从事件目标 target 开始，从子元素往冒泡祖先元素冒泡，直到页面的最上一级标签。\n如下图所示：\nPS：这个概念类似于 Android 里的 touch 事件传递。\n事件捕获 addEventListener可以捕获事件：\n1 2 3 box1.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 box3\u0026#34;); }, true); 上面的方法中，参数为true，代表事件在捕获阶段执行。\n代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //参数为true，代表事件在「捕获」阶段触发；参数为false或者不写参数，代表事件在「冒泡」阶段触发 box3.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 child\u0026#34;); }, true); box2.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 father\u0026#34;); }, true); box1.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 grandfather\u0026#34;); }, true); document.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 body\u0026#34;); }, true); 效果演示：\n（如果上面的图片打不开，请点击：http://img.smyhvae.com/20180204_1101.gif）\n重点：捕获阶段，事件依次传递的顺序是：window \u0026ndash;\u0026gt; document \u0026ndash;\u0026gt; html\u0026ndash;\u0026gt; body \u0026ndash;\u0026gt; 父元素、子元素、目标元素。\n这几个元素在事件捕获阶段的完整写法是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 window.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 window\u0026#34;); }, true); document.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 document\u0026#34;); }, true); document.documentElement.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 html\u0026#34;); }, true); document.body.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 body\u0026#34;); }, true); fatherBox.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 father\u0026#34;); }, true); childBox.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 child\u0026#34;); }, true); 说明：\n（1）第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。\n（2）JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩是最先获取到事件的。\n补充一个知识点：\n在 js中：\n如果想获取 html节点，方法是document.documentElement。\n如果想获取 body 节点，方法是：document.body。\n二者不要混淆了。\n事件冒泡 事件冒泡: 当一个元素上的事件被触发的时候（比如说鼠标点击了一个按钮），同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；这个事件从原始元素开始一直冒泡到DOM树的最上层。\n通俗来讲，冒泡指的是：子元素的事件被触发时，父元素的同样的事件也会被触发。取消冒泡就是取消这种机制。\n代码演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //事件冒泡 box3.onclick = function () { alert(\u0026#34;child\u0026#34;); } box2.onclick = function () { alert(\u0026#34;father\u0026#34;); } box1.onclick = function () { alert(\u0026#34;grandfather\u0026#34;); } document.onclick = function () { alert(\u0026#34;body\u0026#34;); } （如果上面的图片打不开，请点击：http://img.smyhvae.com/20180204_1028.gif）\n上图显示，当我点击子元素 box3 的时候，它的父元素box2、box1、body都依次被触发了。即使我改变代码的顺序，也不会影响效果的顺序。\n当然，上面的代码中，我们用 addEventListener 这种 DOM2的写法也是可以的，但是第三个参数要写 false，或者不写。\n冒泡顺序：\n一般的浏览器: （除IE6.0之外的浏览器）\ndiv -\u0026gt; body -\u0026gt; html -\u0026gt; document -\u0026gt; window IE6.0：\ndiv -\u0026gt; body -\u0026gt; html -\u0026gt; document 不是所有的事件都能冒泡 以下事件不冒泡：blur、focus、load、unload、onmouseenter、onmouseleave。意思是，事件不会往父元素那里传递。\n我们检查一个元素是否会冒泡，可以通过事件的以下参数：\n1 event.bubbles 如果返回值为true，说明该事件会冒泡；反之则相反。\n举例：\n1 2 3 4 5 6 box1.onclick = function (event) { alert(\u0026#34;冒泡 child\u0026#34;); event = event || window.event; console.log(event.bubbles); //打印结果：true。说明 onclick 事件是可以冒泡的 } 阻止冒泡 大部分情况下，冒泡都是有益的。当然，如果你想阻止冒泡，也是可以的。可以按下面的方法阻止冒泡。\n阻止冒泡的方法 w3c的方法：（火狐、谷歌、IE11）\n1 event.stopPropagation(); IE10以下则是：\n1 event.cancelBubble = true 兼容代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 box3.onclick = function (event) { alert(\u0026#34;child\u0026#34;); //阻止冒泡 event = event || window.event; if (event \u0026amp;\u0026amp; event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } } 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。\n阻止冒泡的举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #box1 { width: 100px; height: 100px; background-color: red; /* * 开启box1的绝对定位 */ position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function() { /* * 使div可以跟随鼠标移动 */ //获取box1 var box1 = document.getElementById(\u0026#39;box1\u0026#39;); //给整个页面绑定：鼠标移动事件 document.onmousemove = function(event) { //兼容的方式获取event对象 event = event || window.event; // 鼠标在页面的位置 = 滚动条滚动的距离 + 可视区域的坐标。 var pagex = event.pageX || scroll().left + event.clientX; var pagey = event.pageY || scroll().top + event.clientY; // 设置div的偏移量（相对于整个页面） // 注意，如果想通过 style.left 来设置属性，一定要给 box1 开启绝对定位。 box1.style.left = pagex + \u0026#39;px\u0026#39;; box1.style.top = pagey + \u0026#39;px\u0026#39;; }; // 【重要注释】 // 当 document.onmousemove 和 box2.onmousemove 同时触发时，通过 box2 阻止事件向 document 冒泡。 // 也就是说，只要是在 box2 的区域，就只触发 document.onmousemove 事件 var box2 = document.getElementById(\u0026#39;box2\u0026#39;); box2.onmousemove = function(event) { //阻止冒泡 event = event || window.event; if (event \u0026amp;\u0026amp; event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } }; }; // scroll 函数封装 function scroll() { return { //此函数的返回值是对象 left: window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop, right: window.pageXOffset || document.body.scrollLeft || document.documentElement.scrollLeft, }; } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body style=\u0026#34;height: 1000px;width: 2000px;\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;box2\u0026#34; style=\u0026#34;width: 300px; height: 300px; background-color: #bfa;\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 关键地方可以看代码中的注释。\n效果演示：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/40-%E4%BA%8B%E4%BB%B6%E7%9A%84%E4%BC%A0%E6%92%AD%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1/","summary":"DOM事件流 事件传播的三个阶段是：事件捕获、事件冒泡和目标。 事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 ta","title":"40-事件的传播和事件冒泡"},{"content":"事件委托 事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown\u0026hellip;\u0026hellip;）的函数委托到另一个元素。\n比如说有一个列表 ul，列表之中有大量的列表项 \u0026lt;a\u0026gt;标签：\n1 2 3 4 5 \u0026lt;ul id=\u0026#34;parent-list\u0026#34;\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;my_link\u0026#34;\u0026gt;超链接一\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;my_link\u0026#34;\u0026gt;超链接二\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;my_link\u0026#34;\u0026gt;超链接三\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; 当我们的鼠标移到\u0026lt;a\u0026gt;标签上的时候，需要获取此\u0026lt;a\u0026gt;的相关信息并飘出悬浮窗以显示详细信息，或者当某个\u0026lt;a\u0026gt;被点击的时候需要触发相应的处理事件。我们通常的写法，是为每个\u0026lt;a\u0026gt;都绑定类似onMouseOver或者onClick之类的事件监听：\n1 2 3 4 5 6 7 8 9 10 window.onload = function(){ var parentNode = document.getElementById(\u0026#34;parent-list\u0026#34;); var aNodes = parentNode.getElementByTagName(\u0026#34;a\u0026#34;); for(var i=0, l = aNodes.length; i \u0026lt; l; i++){ aNodes[i].onclick = function() { console.log(\u0026#39;我是超链接 a 的单击相应函数\u0026#39;); } } } 但是，上面的做法过于消耗内存和性能。我们希望，只绑定一次事件，即可应用到多个元素上，即使元素是后来添加的。\n因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件函数的时候再去匹配判断目标元素。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.onload = function() { // 获取父节点，并为它绑定click单击事件。 false 表示事件在冒泡阶段触发（默认） document.getElementById(\u0026#39;parent-list\u0026#39;).addEventListener(\u0026#39;click\u0026#39;, function(event) { event = event || window.event; // e.target 表示：触发事件的对象 //如果触发事件的对象是我们期望的元素，则执行否则不执行 if (event.target \u0026amp;\u0026amp; event.target.className == \u0026#39;link\u0026#39;) { // 或者写成 if (event.target \u0026amp;\u0026amp; event.target.nodeName.toUpperCase() == \u0026#39;A\u0026#39;) { console.log(\u0026#39;我是ul的单击响应函数\u0026#39;); } }, false); }; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;ul id=\u0026#34;parent-list\u0026#34; style=\u0026#34;background-color: #bfa;\u0026#34;\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;我是p元素\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;link\u0026#34;\u0026gt;超链接一\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;link\u0026#34;\u0026gt;超链接二\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:;\u0026#34; class=\u0026#34;link\u0026#34;\u0026gt;超链接三\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/body\u0026gt; 上方代码，为父节点注册 click 事件，当子节点被点击的时候，click事件会从子节点开始向父节点冒泡。父节点捕获到事件之后，开始执行方法体里的内容：通过判断 event.target 拿到了被点击的子节点\u0026lt;a\u0026gt;。从而可以获取到相应的信息，并作处理。\n换而言之，参数为false，说明事件是在冒泡阶段触发（子元素向父元素传递事件）。而父节点注册了事件函数，子节点没有注册事件函数，此时，会在父节点中执行函数体里的代码。\n总结：事件委托是利用了冒泡机制，减少了事件绑定的次数，减少内存消耗，提高性能。\n事件委托的参考链接：\n荐 | JavaScript事件代理和委托（Delegation）\nJavaScript 事件委托详解\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/41-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/","summary":"事件委托 事件委托，通俗地来讲，就是把一个元素响应事件（click、keydown\u0026hellip;\u0026hellip;）的函数委托到另一个元素。 比","title":"41-事件委托"},{"content":"鼠标的拖拽事件 拖拽的流程：\n（1）onmousedown：当鼠标在被拖拽元素上按下时，开始拖拽；\n（2）onmousemove：当鼠标移动时被拖拽元素跟随鼠标移动；\n（3）onmouseup：当鼠标松开时，被拖拽元素固定在当前位置。\n鼠标的滚轮事件 onmousewheel：鼠标滚轮滚动的事件，会在滚轮滚动时触发。但是火狐不支持该属性。\nDOMMouseScroll：在火狐中需要使用 DOMMouseScroll 来绑定滚动事件。注意该事件需要通过addEventListener()函数来绑定。\n键盘事件 事件名 onkeydown：按键被按下。\nonkeyup：按键被松开。\n注意：\n如果一直按着某一个按键不松手，那么，onkeydown事件会一直触发。此时，松开键盘，onkeyup事件会执行一次。\n当onkeydown连续触发时，第一次和第二次之间会间隔稍微长一点，后续的间隔会非常快。这种设计是为了防止误操作的发生。\n键盘事件一般都会绑定给一些可以获取到焦点的对象或者是document。代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.onkeydown = function(event) { event = event || window.event; console.log(\u0026#39;qianguyihao 键盘按下了\u0026#39;); }; document.onkeyup = function() { console.log(\u0026#39;qianguyihao 键盘松开了\u0026#39;); }; \u0026lt;/script\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; 判断哪个键盘被按下 可以通过event事件对象的keyCode来获取按键的编码。\n此外，event事件对象里面还提供了以下几个属性：\naltKey\nctrlKey\nshiftKey\n上面这三个属性，可以用来判断alt、ctrl、和shift是否被按下。如果按下则返回true，否则返回false。代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; document.onkeydown = function(event) { event = event || window.event; console.log(\u0026#39;qianguyihao：键盘按下了\u0026#39;); // 判断y和ctrl是否同时被按下 if (event.ctrlKey \u0026amp;\u0026amp; event.keyCode === 89) { console.log(\u0026#39;ctrl和y都被按下了\u0026#39;); } }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 举例：input 文本框中，禁止输入数字。代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; /\u0026gt; \u0026lt;script\u0026gt; //获取input var input = document.getElementsByTagName(\u0026#39;input\u0026#39;)[0]; input.onkeydown = function(event) { event = event || window.event; //console.log(\u0026#39;qianguyihao:\u0026#39; + event.keyCode); //数字 48 - 57 //使文本框中不能输入数字 if (event.keyCode \u0026gt;= 48 \u0026amp;\u0026amp; event.keyCode \u0026lt;= 57) { //在文本框中输入内容，属于onkeydown的默认行为 return false; // 如果在onkeydown中取消了默认行为，则输入的内容，不会出现在文本框中 } }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 举例：通过键盘的方向键，移动盒子 代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; #box1 { width: 100px; height: 100px; background-color: red; position: absolute; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;box1\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 使div可以根据不同的方向键向不同的方向移动 /* * 按左键，div向左移 * 按右键，div向右移 * ... */ //为document绑定一个按键按下的事件 document.onkeydown = function(event) { event = event || window.event; //定义一个变量，来表示移动的速度 var speed = 10; //当用户按了ctrl以后，速度加快 if (event.ctrlKey) { console.log(\u0026#39;smyhvae ctrl\u0026#39;); speed = 20; } /* * 37 左 * 38 上 * 39 右 * 40 下 */ switch (event.keyCode) { case 37: //alert(\u0026#34;向左\u0026#34;); left值减小 box1.style.left = box1.offsetLeft - speed + \u0026#39;px\u0026#39;; // 在初始值的基础之上，减去 speed 大小 break; case 39: //alert(\u0026#34;向右\u0026#34;); box1.style.left = box1.offsetLeft + speed + \u0026#39;px\u0026#39;; break; case 38: //alert(\u0026#34;向上\u0026#34;); box1.style.top = box1.offsetTop - speed + \u0026#39;px\u0026#39;; break; case 40: //alert(\u0026#34;向下\u0026#34;); box1.style.top = box1.offsetTop + speed + \u0026#39;px\u0026#39;; break; } }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上方代码，待改进的地方：\n（1）移动盒子时，如果要加速，需要先按方向键，再按Ctrl键。\n（2）首次移动盒子时，动作较慢。后续如果学习了定时器相关的内容，可以再改进。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/42-%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6/","summary":"鼠标的拖拽事件 拖拽的流程： （1）onmousedown：当鼠标在被拖拽元素上按下时，开始拖拽； （2）onmousemove：当鼠标移动时被拖","title":"42-键盘事件"},{"content":"常见概念 JavaScript的组成 JavaScript基础分为三个部分：\nECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。\nDOM：文档对象模型（Document object Model），操作网页上的元素的API。比如让盒子移动、变色、轮播图等。\nBOM：浏览器对象模型（Browser Object Model），操作浏览器部分功能的API。比如让浏览器自动滚动。\n常见的 BOM 对象 BOM可以让我们通过JS来操作浏览器。BOM中为我们提供了一些对象，来完成对浏览器相关的操作。\n常见的 BOM对象有：\nWindow：代表整个浏览器的窗口，同时 window 也是网页中的全局对象。\nNavigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。\nLocation：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。\nHistory：代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。\nScreen：代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。\n备注：这些 BOM 对象都是作为 window 对象的属性保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 window.location.href，也可以直接使用 location.href，二者是等价的。\n备注2：不要忘了，之前学习过的document也是在window中保存的。\n这篇文章，我们先来讲一下 几个常见的 BOM 对象。\nNavigator 和 navigator.userAgent Navigator代表当前浏览器的信息，通过该对象可以识别不同的浏览器。\n由于历史原因，Navigator对象中的大部分属性都已经不能帮助我们识别浏览器了。\n一般我们只会使用navigator.userAgent来获取浏览器的信息。\nuserAgent 的值是一个字符串，简称 UA，这个字符串中包含了用来描述浏览器信息的内容，不同的浏览器会有不同的userAgent。\n代码举例：（获取当前浏览器的UA）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; var ua = navigator.userAgent; // 获取当前浏览器的 userAgent console.log(\u0026#39;qianguyihao 当前浏览器的UA是：\u0026#39; + ua); if (/firefox/i.test(ua)) { alert(\u0026#39;是火狐浏览器\u0026#39;); } else if (/chrome/i.test(ua)) { alert(\u0026#39;是Chrome浏览器\u0026#39;); } else if (/msie/i.test(ua)) { alert(\u0026#39;是IE浏览器\u0026#39;); } else if (\u0026#39;ActiveXObject\u0026#39; in window) { alert(\u0026#39;是 IE11 浏览器\u0026#39;); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在电脑上模拟移动端浏览器 不同浏览器（包括微信内置的浏览器）的 userAgent 信息，是不一样的，我们可以根据 navigator.userAgent属性来获取。\n比如说，我们在电脑浏览器上，按F12，然后在控制台输入navigator.userAgent，如下：\n上图显示，MacOS上的Chrome浏览器的 userAgent 是：\n1 \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.117 Safari/537.36\u0026#34; 我们还可以在电脑浏览器的控制台里可以添加很多设备，通过这种方式，可以模拟移动端浏览器的场景，非常有用，请务必掌握。操作如下：\n（1）需要点击 edit，手动添加：\n（2）添加时，根据 User agent 来识别不同的浏览器：\n不同浏览器的 userAgent iOS 版微信浏览器：\n1 Mozilla/5.0 (iPhone; CPU iPhone OS 9_3 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13E233 MicroMessenger/6.3.15 NetType/WIFI Language/zh_CN Android 版微信浏览器：\n1 Mozilla/5.0 (Linux; Android 5.0.1; GT-I9502 Build/LRX22C; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/43.0.2357.121 Mobile Safari/537.36 MicroMessenger/6.1.0.78_r1129455.543 NetType/WIFI iOS 版本QQ浏览器：\n1 Mozilla/5.0 (iPhone; CPU iPhone OS 11_2_2 like Mac OS X) AppleWebKit/604.4.7 (KHTML, like Gecko) Mobile/15C202 QQ/7.3.5.473 V1_IPH_SQ_7.3.5_1_APP_A Pixel/1125 Core/UIWebView Device/Apple(iPhone X) NetType/WIFI QBWebViewType/1 Android 版 QQ浏览器：\n1 Mozilla/5.0 (Linux; Android 4.4.2; PE-TL20 Build/HuaweiPE-TL20; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/57.0.2987.132 MQQBrowser/6.2 TBS/043807 Mobile Safari/537.36 V1_AND_SQ_7.3.2_762_YYB_D QQ/7.3.2.3350 NetType/WIFI WebP/0.3.0 Pixel/1080 参考链接：\n微信、QQ在Android和iOS的UserAgent\n判断微信内置浏览器的UserAgent\n微信内置浏览器UserAgent的判断\nHistory 对象 History对象：可以用来操作浏览器的向前或向后翻页。\nHistory对象的属性 1 history.length 解释：获取浏览器历史列表中的 url 数量。注意，只是统计当次的数量，如果浏览器关了，数量会重置为1。\nHistory对象的方法 方法1：\n1 history.back(); 解释：用来回退到上一个页面，作用和浏览器的「回退按钮」一样。\n方法2：\n1 history.forward(); 解释：用来跳转下一个页面，作用和浏览器的「前进按钮」一样。\n方法3：\n1 2 3 4 5 6 7 8 9 10 11 12 history.go( int n); // 需要整数作为参数 // 代码举例： history.go( 1 ); // 向前跳转一个页面，相当于 history.forward() history.go( 2 ); // 表示向前跳转两个页面 history.go( 0 ); // 刷新当前页面 history.go( -1 ); // 向后跳转一个页面，相当于 history.back() history.go( -2 ); // 向后跳转两个页面 解释：向前/向后跳转 n 个页面。\n备注：浏览器的前进按钮、后退按钮，在这个位置：\nLocation 对象 Location 对象：封装了浏览器地址栏的 URL 信息。\n下面介绍一些常见的属性和方法。\nLocation 对象的属性 属性1：\n1 2 3 location.href location.href = \u0026#39;https://xxx\u0026#39;; 解释：获取当前页面的 url 路径（或者设置 url 路径）。\n代码举例1：\n1 console.log(location.href); // 获取当前页面的url 路径 代码举例2：\n1 location.href = \u0026#39;www.baidu.com\u0026#39;; // 跳转到指定的页面链接。通俗理解就是：跳转到其他的页面 从上方的举例2中可以看出：如果直接将location.href属性修改为一个绝对路径（或相对路径），则页面会自动跳转到该路径，并生成相应的历史记录。\nLocation 对象的方法 方法1：\n1 location.assign(str); 解释：用来跳转到其他的页面，作用和直接修改location.href一样。\n方法2：\n1 location.reload(); 解释：用于重新加载当前页面，作用和刷新按钮一样。\n代码举例：\n1 2 location.reload(); // 重新加载当前页面。 location.reload(true); // 在方法的参数中传递一个true，则会强制清空缓存刷新页面。 方法3：\n1 2 location.replace(); 解释：使用一个新的页面替换当前页面，调用完毕也会跳转页面。但不会生成历史记录，不能使用「后退按钮」后退。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/43-bom%E7%AE%80%E4%BB%8B%E5%92%8Cnavigator.useragenthistorylocation/","summary":"常见概念 JavaScript的组成 JavaScript基础分为三个部分： ECMAScript：JavaScript的语法标准。包括变量、表达","title":"43-BOM简介和navigator.userAgent\u0026History\u0026Location"},{"content":"定时器的常见方法 setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行）\nsetTimeout()：延时调用。将一段代码，等待一段时间之后再执行。（只执行一次）\n备注：在实际开发中，二者是可以根据需要，互相替代的。\nsetInterval() 的使用 setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行）\n参数：\n参数1：回调函数，该函数会每隔一段时间被调用一次。\n参数2：每次调用的间隔时间，单位是毫秒。\n返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。\n定义定时器 方式一：匿名函数\n每间隔一秒，将 数字 加1：\n1 2 3 4 5 let num = 1; setInterval(function () { num ++; console.log(num); }, 1000); 方式二：\n每间隔一秒，将 数字 加1：\n1 2 3 4 5 6 setInterval(fn,1000); function fn() { num ++; console.log(num); } 清除定时器 定时器的返回值是作为这个定时器的唯一标识，可以用来清除定时器。具体方法是：假设定时器setInterval()的返回值是参数1，那么clearInterval(参数1)就可以清除定时器。\nsetTimeout()的道理是一样的。\n代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; let num = 1; const timer = setInterval(function () { console.log(num); //每间隔一秒，打印一次num的值 num ++; if(num === 5) { //打印四次之后，就清除定时器 clearInterval(timer); } }, 1000); \u0026lt;/script\u0026gt; setTimeout() 的使用 setTimeout()：延时调用。将一段代码，等待一段时间之后再执行。（只执行一次）\n参数：\n参数1：回调函数，该函数会每隔一段时间被调用一次。\n参数2：每次调用的间隔时间，单位是毫秒。\n返回值：返回一个Number类型的数据。这个数字用来作为定时器的唯一标识，方便用来清除定时器。\n定义和清除定时器 代码举例：\n1 2 3 4 5 const timer = setTimeout(function() { console.log(1); // 3秒之后，再执行这段代码。 }, 3000); clearTimeout(timer); 代码举例：（箭头函数写法）\n1 2 3 setTimeout(() =\u0026gt; { console.log(1); // 3秒之后，再执行这段代码。 }, 3000); setTimeout() 举例：5秒后关闭网页两侧的广告栏 假设网页两侧的广告栏为两个img标签，它们的样式为：\n1 2 3 4 5 \u0026lt;style\u0026gt; ... ... \u0026lt;/style\u0026gt; 5秒后关闭广告栏的js代码为：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; window.onload = function () { //获取相关元素 var imgArr = document.getElementsByTagName(\u0026#34;img\u0026#34;); //设置定时器：5秒后关闭两侧的广告栏 setTimeout(fn,5000); function fn(){ imgArr[0].style.display = \u0026#34;none\u0026#34;; imgArr[1].style.display = \u0026#34;none\u0026#34;; } } \u0026lt;/script\u0026gt; ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/44-%E5%AE%9A%E6%97%B6%E5%99%A8/","summary":"定时器的常见方法 setInterval()：循环调用。将一段代码，每隔一段时间执行一次。（循环执行） setTimeout()：延时调用。将一","title":"44-定时器"},{"content":" 本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。\n以下是正文。\nBOM的介绍 JavaScript的组成 JavaScript基础分为三个部分：\nECMAScript：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。\nDOM：文档对象模型，操作网页上的元素的API。比如让盒子移动、变色、轮播图等。\nBOM：浏览器对象模型，操作浏览器部分功能的API。比如让浏览器自动滚动。\n什么是BOM BOM：Browser Object Model，浏览器对象模型。\nBOM的结构图：\n从上图也可以看出：\nwindow对象是BOM的顶层(核心)对象，所有对象都是通过它延伸出来的，也可以称为window的子对象。\nDOM越是BOM的一部分。\nwindow对象：\nwindow对象是JavaScript中的顶级对象。\n全局变量、自定义函数也是window对象的属性和方法。\nwindow对象下的属性和方法调用时，可以省略window。\n下面讲一下 BOM 的常见内置方法和内置对象。\n弹出系统对话框 比如说，alert(1)是window.alert(1)的简写，因为它是window的子方法。\n系统对话框有三种：\n1 2 3 alert();\t//不同浏览器中的外观是不一样的 confirm(); //兼容不好 prompt();\t//不推荐使用 打开窗口、关闭窗口 1、打开窗口：\n1 window.open(url,target,param) 参数解释：\nurl：要打开的地址。\ntarget：新窗口的位置。可以是：_blank 、_self、 _parent 父框架。\nparam：新窗口的一些设置。\n返回值：新窗口的句柄。\nparam这个参数，可以填各种各样的参数（），比如：\nname：新窗口的名称，可以为空\nfeatures：属性控制字符串，在此控制窗口的各种属性，属性之间以逗号隔开。\nfullscreen= { yes/no/1/0 } 是否全屏，默认no\nchannelmode= { yes/no/1/0 } 是否显示频道栏，默认no\ntoolbar= { yes/no/1/0 } 是否显示工具条，默认no\nlocation= { yes/no/1/0 } 是否显示地址栏，默认no。（有的浏览器不一定支持）\ndirectories = { yes/no/1/0 } 是否显示转向按钮，默认no\nstatus= { yes/no/1/0 } 是否显示窗口状态条，默认no\nmenubar= { yes/no/1/0 } 是否显示菜单，默认no\nscrollbars= { yes/no/1/0 } 是否显示滚动条，默认yes\nresizable= { yes/no/1/0 } 是否窗口可调整大小，默认no\nwidth=number 窗口宽度（像素单位）\nheight=number 窗口高度（像素单位）\ntop=number 窗口离屏幕顶部距离（像素单位）\nleft=number 窗口离屏幕左边距离（像素单位）\n各个参数之间用逗号隔开就行，但我们最好是把它们统一放到json里。\n2、关闭窗口：window.close()\n（1）和（2）的代码举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;点击我打开一个新的页面\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026#34;javascript:;\u0026#34;\u0026gt;点击我关闭本页面\u0026lt;/a\u0026gt; \u0026lt;script\u0026gt; //新窗口 = window.open(地址,是否开新窗口,新窗口的各种参数); var a1 = document.getElementsByTagName(\u0026#34;a\u0026#34;)[0]; var a2 = document.getElementsByTagName(\u0026#34;a\u0026#34;)[1]; a1.onclick = function () { //举例1： window.open(\u0026#34;http://www.jx.com\u0026#34;,\u0026#34;_blank\u0026#34;); var json = { \u0026#34;name\u0026#34;: \u0026#34;helloworld\u0026#34;, \u0026#34;fullscreen\u0026#34;: \u0026#34;no\u0026#34;, \u0026#34;location\u0026#34;: \u0026#34;no\u0026#34;, \u0026#34;width\u0026#34;: \u0026#34;100px\u0026#34;, \u0026#34;height\u0026#34;: \u0026#34;100px\u0026#34;, \u0026#34;top\u0026#34;: \u0026#34;100px\u0026#34;, \u0026#34;left\u0026#34;: \u0026#34;100px\u0026#34; }; window.open(\u0026#34;http://www.baidu.com\u0026#34;, \u0026#34;_blank\u0026#34;, json); //举例2 } //关闭本页面 a2.onclick = function () { window.close(); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 3、新窗口相关：\n新窗口.moveTo(5,5)\n新窗口.moveBy()\n新窗口.resizeTo()\nwindow.resizeBy()\n代码举例：\n1 2 var newWin = window.open(\u0026#34;demo.html\u0026#34;, \u0026#34;_blank\u0026#34;, json); newWin.moveTo(500, 500); location对象 window.location可以简写成location。location相当于浏览器地址栏，可以将url解析成独立的片段。\nlocation对象的属性 href：跳转\nhash 返回url中#后面的内容，包含#\nhost 主机名，包括端口\nhostname 主机名\npathname url中的路径部分\nprotocol 协议 一般是http、https\nsearch\t查询字符串\nlocation.href属性举例：\n**举例1：**点击盒子时，进行跳转。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;smyhvae\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; var div = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div.onclick = function () { location.href = \u0026#34;http://www.baidu.com\u0026#34;; //点击div时，跳转到指定链接 // window.open(\u0026#34;http://www.baidu.com\u0026#34;,\u0026#34;_blank\u0026#34;); //方式二 } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 举例2：5秒后自动跳转到百度。\n有时候，当我们访问一个不存在的网页时，会提示5秒后自动跳转到指定页面，此时就可以用到location。举例：\n1 2 3 4 5 6 \u0026lt;script\u0026gt; setTimeout(function () { location.href = \u0026#34;http://www.baidu.com\u0026#34;; }, 5000); \u0026lt;/script\u0026gt; location对象的方法 location.assign()：改变浏览器地址栏的地址，并记录到历史中 设置location.href 就会调用assign()。一般使用location.href 进行页面之间的跳转。\nlocation.replace()：替换浏览器地址栏的地址，不会记录到历史中\nlocation.reload()：重新加载\nnavigator对象 window.navigator 的一些属性可以获取客户端的一些信息。\nuserAgent：系统，浏览器)\nplatform：浏览器支持的系统，win/mac/linux\n举例：\n1 2 console.log(navigator.userAgent); console.log(navigator.platform); 效果如下：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/bom%E7%9A%84%E5%B8%B8%E8%A7%81%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/","summary":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 BOM的介绍 Ja","title":"BOM的常见内置方法和内置对象"},{"content":"call()和apply() 介绍 这两个方法都是函数对象的方法，需要通过函数对象来调用。\n当函数调用call()和apply()时，函数都会立即执行。\n都可以用来改变函数的this对象的指向。\n第一个参数都是this要指向的对象（函数执行时，this将指向这个对象），后续参数用来传实参。\n显式绑定this JS提供的绝大多数函数以及我们自己创建的所有函数，都可以使用call 和apply方法。\n它们的第一个参数是一个对象。因为你可以直接指定 this 绑定的对象，因此我们称之为显式绑定。\n例1：\n1 2 3 4 5 6 7 8 9 10 function foo() { console.log(this.a); } var obj = { a: 2 }; // 将 this 指向 obj foo.apply(obj); //打印结果：2 第一个参数的传递 1、thisObj不传或者为null、undefined时，函数中的this会指向window对象（非严格模式）。\n2、传递一个别的函数名时，函数中的this将指向这个函数的引用。\n3、传递的值为数字、布尔值、字符串时，this会指向这些基本类型的包装对象Number、Boolean、String。\n4、传递一个对象时，函数中的this则指向传递的这个对象。\ncall()和apply()的区别 call()和apply()方法都可以将实参在对象之后依次传递，但是apply()方法需要将实参封装到一个数组中统一传递（即使只有实参只有一个，也要放到数组中）。\n比如针对下面这样的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 var persion1 = { name: \u0026#34;小王\u0026#34;, gender: \u0026#34;男\u0026#34;, age: 24, say: function (school, grade) { alert(this.name + \u0026#34; , \u0026#34; + this.gender + \u0026#34; ,今年\u0026#34; + this.age + \u0026#34; ,在\u0026#34; + school + \u0026#34;上\u0026#34; + grade); } } var person2 = { name: \u0026#34;小红\u0026#34;, gender: \u0026#34;女\u0026#34;, age: 18 } 如果是通过call的参数进行传参，是这样的：\n1 persion1.say.call(persion2, \u0026#34;实验小学\u0026#34;, \u0026#34;六年级\u0026#34;); 如果是通过apply的参数进行传参，是这样的：\n1 persion1.say.apply(persion2, [\u0026#34;实验小学\u0026#34;, \u0026#34;六年级\u0026#34;]); 看到区别了吗，call后面的实参与say方法中是一一对应的，而apply传实参时，要封装成一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。\ncall()和apply()的作用 改变this的指向\n实现继承。Father.call(this)\nbind() 都能改变this的指向\ncall()/apply()是立即调用函数\nbind()是将函数返回，因此后面还需要加()才能调用。\nbind()传参的方式与call()相同。\n参考链接：\nhttps://www.jianshu.com/p/56a9c2d11adc\nhttps://github.com/lin-xin/blog/issues/7\nhttps://segmentfault.com/a/1190000007402815\nJS中改变this指向的方法\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/callapplybind%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"call()和apply() 介绍 这两个方法都是函数对象的方法，需要通过函数对象来调用。 当函数调用call()和apply()时，函数都会立即","title":"call、apply、bind的区别"},{"content":" title: \u0026ldquo;HelloWorld\u0026rdquo; date: 2022-11-22T17:11:35+08:00 draft: true 控制台的使用 控制台查看源码 控制台的Sources标签可以查看源码。按住快捷键「cmd + P」，可以根据文件名查找源码文件。\n其他 show user agent shadow DOM 把上图中的红框部分打钩。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/06-chrome%E6%B5%8F%E8%A7%88%E5%99%A8/","summary":"title: \u0026ldquo;HelloWorld\u0026rdquo; date: 2022-11-22T17:11:35+08:00 draft: true 控制台的使用 控制台查看源码 控制台的Sources标签可以查看源码。按住快捷键「cmd + P」，可以根据文件名查找源码文件。 其他 show user","title":"chrome浏览器"},{"content":"全局对象 global 类似于客户端 JavaScript 运行环境中的 window。\nprocess 用于获取当前的 Node 进程信息，一般用于获取环境变量之类的信息。\nconsole Node 中内置的 console 模块，提供操作控制台的输入输出功能，常见使用方式与客户端类似。\n全局函数 setInterval(callback, millisecond)\nclearInterval(timer)\nsetTimeout(callback, millisecond)\nclearTimeout(timer)\nBuffer：Class\n用于操作二进制数据 以后介绍 Node 调试 最简单的调试 最方便也是最简单的调试：console.log()\nNode 原生的调试 网址：https://nodejs.org/api/debugger.html\n第三方模块提供的调试工具 1 2 3 4 $ npm install node-inspector –g //方式一 $ npm install devtool -g //方式二 开发工具的调试 Visual Studio Code\nWebStorm\n模块化结构 Node 实现 CommonJS 规范，所以可以使用模块化的方式组织代码结构。\nNode 采用的模块化结构是按照 CommonJS 规范。\n模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。\nCommonJS 规范 CommonJS 就是一套约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。\n参考链接：\nhttp://wiki.commonjs.org/wiki/CommonJS 常用内置模块 path：处理文件路径。\nfs：操作（CRUD）文件系统。\nchild_process：新建子进程。\nutil：提供一系列实用小工具。\nhttp：提供 HTTP 服务器功能。\nurl：用于解析 URL。\nquerystring：解析 URL 中的查询字符串。\ncrypto：提供加密和解密功能。\n总结：更多内容可以参考 api文档：https://nodejs.org/api/\n文件系统操作 相关模块 fs：基础的文件操作 API\npath：提供和路径相关的操作 API\nreadline：用于读取大文本文件，一行一行读\nfs-extra（第三方）：https://www.npmjs.com/package/fs-extra\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/commonjs/","summary":"全局对象 global 类似于客户端 JavaScript 运行环境中的 window。 process 用于获取当前的 Node 进程信息，一般用于获取环境变量之类的信息。 console Node 中内置的 console 模块，提供操作控","title":"CommonJS"},{"content":"CSS display: none; 与 visibility: hidden; 的区别\n联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见 display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；visibility:hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘 读屏器不会读取display: none;元素内容；会读取visibility: hidden元素内容 css hack原理及常用hack\n原理：利用不同浏览器对CSS的支持和解析结果不一样编写针对特定浏览器样式。 常见的hack有 属性hack 选择器hack IE条件注释 link 与 @import 的区别\nlink 是HTML方式， @import 是CSS方式 link 最大限度支持并行下载， @import 过多嵌套导致串行下载，出现FOUC link 可以通过 rel=\u0026quot;alternate stylesheet\u0026quot; 指定候选样式 浏览器对 link 支持早于 @import ，可以使用 @import 对老浏览器隐藏样式 @import 必须在样式规则之前，可以在css文件中引用其他文件 总体来说：link优于@import CSS有哪些继承属性\n关于文字排版的属性如： font word-break letter-spacing text-align text-rendering word-spacing white-space text-indent text-transform text-shadow line-height color visibility cursor display,float,position的关系\n如果 display 为none，那么position和float都不起作用，这种情况下元素不产生框 否则，如果position值为absolute或者fixed，框就是绝对定位的，float的计算值为none，display根据下面的表格进行调整 否则，如果float不是none，框是浮动的，display根据下表进行调整 否则，如果元素是根元素，display根据下表进行调整 其他情况下display的值为指定值 总结起来：绝对定位、浮动、根元素都需要调整 display 外边距折叠(collapsing margins)\n毗邻的两个或多个 margin 会合并成一个margin，叫做外边距折叠。规则如下： 两个或多个毗邻的普通流中的块元素垂直方向上的margin会折叠 浮动元素或inline-block元素或绝对定位元素的margin不会和垂直方向上的其他元素的margin折叠 创建了块级格式化上下文的元素，不会和它的子元素发生margin折叠 元素自身的margin-bottom和margin-top相邻时也会折 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n有两种， IE 盒子模型、W3C 盒子模型； 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； 区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？\nid选择器（ # myid）\n类选择器（.myclassname）\n标签选择器（div, h1, p）\n相邻选择器（h1 + p）\n子选择器（ul \u0026gt; li）\n后代选择器（li a）\n通配符选择器（ * ）\n属性选择器（a[rel = \u0026ldquo;external\u0026rdquo;]）\n伪类选择器（a:hover, li:nth-child）\n可继承的样式： font-size font-family color, UL LI DL DD DT\n不可继承的样式：border padding margin width height CSS优先级算法如何计算？\n优先级就近原则，同权重情况下样式定义最近者为准 载入样式以最后载入的定位为准 优先级为: !important \u0026gt; id \u0026gt; class \u0026gt; tag important 比 内联优先级高 CSS3新增伪类有那些？\n1 2 3 4 5 6 7 8 9 10 11 p:first-of-type 选择属于其父元素的首个 \u0026lt;p\u0026gt; 元素的每个 \u0026lt;p\u0026gt; 元素。 p:last-of-type 选择属于其父元素的最后 \u0026lt;p\u0026gt; 元素的每个 \u0026lt;p\u0026gt; 元素。 p:only-of-type 选择属于其父元素唯一的 \u0026lt;p\u0026gt; 元素的每个 \u0026lt;p\u0026gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 \u0026lt;p\u0026gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 \u0026lt;p\u0026gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？\n给div设置一个宽度，然后添加margin:0 auto属性 1 2 3 4 div{ width:200px; margin:0 auto; } 居中一个浮动元素 1 2 3 4 5 6 7 8 9 10 11 //确定容器的宽高 宽500 高 300 的层 //设置层的外边距 .div { width:500px ; height:300px;//高度可以不设 margin: -150px 0 0 -250px; position:relative; //相对定位 background-color:pink; //方便看效果 left:50%; top:50%; } 让绝对定位的div居中 1 2 3 4 5 6 7 8 position: absolute; width: 1200px; background: none; margin: 0 auto; top: 0; left: 0; bottom: 0; right: 0; display有哪些值？说明他们的作用\nblock 象块类型元素一样显示。 none 缺省值。象行内元素类型一样显示。 inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示 inherit 规定应该从父元素继承 display 属性的值 position的值relative和absolute定位原点是？\nabsolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right - z-index 声明）。 inherit 规定从父元素继承 position 属性的值 CSS3有哪些新特性？\n新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 增加了旋转,缩放,定位,倾斜,动画，多背景 transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation: 用纯CSS创建一个三角形的原理是什么？\n1 2 3 4 5 6 7 8 // 把上、左、右三条边隐藏掉（颜色设为 transparent） #demo { width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; } 一个满屏 品 字布局 如何设计?\n简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？\npng24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.\n浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一\nIE下,可以使用获取常规属性的方法来获取自定义属性,也可以使用getAttribute()获取自定义属性;\nFirefox下,只能使用getAttribute()获取自定义属性。\n解决方法:统一通过getAttribute()获取自定义属性 IE下,even对象有x,y属性,但是没有pageX,pageY属性\nFirefox下,event对象有pageX,pageY属性,但是没有x,y属性\nli与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\n行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了 为什么要初始化CSS样式\n因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异 对BFC规范(块级格式化上下文：block formatting context)的理解？\n一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响 css定义的权重\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下/// 例子是演示各种定义的权重值： /*权重为1*/ div{ } /*权重为10*/ .class1{ } /*权重为100*/ #id1{ } /*权重为100+1=101*/ #id1 div{ } /*权重为10+1=11*/ .class1 div{ } /*权重为10+10+1=21*/ .class1 .class2 div{ } // 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 display:inline-block 什么时候会显示间隙？(携程)\n移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing 谈谈浮动和清除浮动\n浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin) IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型) 标准(W3C)盒模型：元素宽度 = width + padding + border + margin 怪异(IE)盒模型：元素宽度 = width + margin 标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高 box-sizing 常用的属性有哪些？分别有什么作用？\nbox-sizing: content-box; // 默认的标准(W3C)盒模型元素效果 box-sizing: border-box; // 触发怪异(IE)盒模型元素的效果 box-sizing: inherit; // 继承父元素 box-sizing 属性的值 CSS选择器有哪些？\nid选择器 #id 类选择器 .class 标签选择器 div, h1, p 相邻选择器 h1 + p 子选择器 ul \u0026gt; li 后代选择器 li a 通配符选择器 * 属性选择器 a[rel=\u0026lsquo;external\u0026rsquo;] 伪类选择器 a:hover, li:nth-child CSS哪些属性可以继承？哪些属性不可以继承？\n可以继承的样式：font-size、font-family、color、list-style、cursor 不可继承的样式：width、height、border、padding、margin、background CSS如何计算选择器优先？\n相同权重，定义最近者为准：行内样式 \u0026gt; 内部样式 \u0026gt; 外部样式 含外部载入样式时，后载入样式覆盖其前面的载入的样式和内部样式 选择器优先级: 行内样式[1000] \u0026gt; id[100] \u0026gt; class[10] \u0026gt; Tag[1] 在同一组属性设置中，!important 优先级最高，高于行内样式 CSS3新增伪类有哪些？\n:root 选择文档的根元素，等同于 html 元素\n:empty 选择没有子元素的元素\n:target 选取当前活动的目标元素\n:not(selector) 选择除 selector 元素意外的元素\n:enabled 选择可用的表单元素\n:disabled 选择禁用的表单元素\n:checked 选择被选中的表单元素\n:after 在元素内部最前添加内容\n:before 在元素内部最后添加内容\n:nth-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n\n:nth-last-child(n) 匹配父元素下指定子元素，在所有子元素中排序第n，从后向前数\n:nth-child(odd)\n:nth-child(even)\n:nth-child(3n+1)\n:first-child\n:last-child\n:only-child\n:nth-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n\n:nth-last-of-type(n) 匹配父元素下指定子元素，在同类子元素中排序第n，从后向前数\n:nth-of-type(odd)\n:nth-of-type(even)\n:nth-of-type(3n+1)\n:first-of-type\n:last-of-type\n:only-of-type\n::selection 选择被用户选取的元素部分\n:first-line 选择元素中的第一行\n:first-letter 选择元素中的第一个字符\n请列举几种隐藏元素的方法\nvisibility: hidden; 这个属性只是简单的隐藏某个元素，但是元素占用的空间任然存在 opacity: 0; CSS3属性，设置0可以使一个元素完全透明 position: absolute; 设置一个很大的 left 负值定位，使元素定位在可见区域之外 display: none; 元素会变得不可见，并且不会再占用文档的空间。 transform: scale(0); 将一个元素设置为缩放无限小，元素将不可见，元素原来所在的位置将被保留 \u0026lt;div hidden=\u0026quot;hidden\u0026quot;\u0026gt; HTML5属性,效果和display:none;相同，但这个属性用于记录一个元素的状态 height: 0; 将元素高度设为 0 ，并消除边框 filter: blur(0); CSS3属性，将一个元素的模糊度设置为0，从而使这个元素“消失”在页面中 rgba() 和 opacity 的透明效果有什么不同？\nopacity 作用于元素以及元素内的所有内容（包括文字）的透明度 rgba() 只作用于元素自身的颜色或其背景色，子元素不会继承透明效果 css 属性 content 有什么作用？\ncontent 属性专门应用在 before/after 伪元素上，用于插入额外内容或样式 CSS3有哪些新特性？\n新增选择器 p:nth-child(n){color: rgba(255, 0, 0, 0.75)} 弹性盒模型 display: flex; 多列布局 column-count: 5; 媒体查询 @media (max-width: 480px) {.box: {column-count: 1;}} 个性化字体 @font-face{font-family: BorderWeb; src:url(BORDERW0.eot);} 颜色透明度 color: rgba(255, 0, 0, 0.75); 圆角 border-radius: 5px; 渐变 background:linear-gradient(red, green, blue); 阴影 box-shadow:3px 3px 3px rgba(0, 64, 128, 0.3); 倒影 box-reflect: below 2px; 文字装饰 text-stroke-color: red; 文字溢出 text-overflow:ellipsis; 背景效果 background-size: 100px 100px; 边框效果 border-image:url(bt_blue.png) 0 10; 转换 旋转 transform: rotate(20deg); 倾斜 transform: skew(150deg, -10deg); 位移 transform: translate(20px, 20px); 缩放 transform: scale(.5); 平滑过渡 transition: all .3s ease-in .1s; 动画 @keyframes anim-1 {50% {border-radius: 50%;}} animation: anim-1 1s; 请解释一下 CSS3 的 Flexbox（弹性盒布局模型）以及适用场景？\nFlexbox 用于不同尺寸屏幕中创建可自动扩展和收缩布局 经常遇到的浏览器的JS兼容性有哪些？解决方法是什么？\n当前样式：getComputedStyle(el, null) VS el.currentStyle 事件对象：e VS window.event 鼠标坐标：e.pageX, e.pageY VS window.event.x, window.event.y 按键码：e.which VS event.keyCode 文本节点：el.textContent VS el.innerText li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\nli排列受到中间空白(回车/空格)等的影响，因为空白也属于字符，会被应用样式占据空间，产生间隔 解决办法：在ul设置设置font-size=0,在li上设置需要的文字大小 什么是外边距重叠？ 重叠的结果是什么？\n外边距重叠就是 margin-collapse\n相邻的两个盒子（可能是兄弟关系也可能是祖先关系）的外边距可以结合成一个单独的外边距。 这种合并外边距的方式被称为折叠，结合而成的外边距称为折叠外边距\n折叠结果遵循下列计算规则：\n两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值 两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值 两个外边距一正一负时，折叠结果是两者的相加的和 请写出多种等高布局\n在列的父元素上使用这个背景图进行Y轴的铺放，从而实现一种等高列的假像 模仿表格布局等高列效果：兼容性不好，在ie6-7无法正常运行 css3 flexbox 布局： .container{display: flex; align-items: stretch;} css垂直居中的方法有哪些？\n如果是单行文本, line-height 设置成和 height 值 1 2 3 4 .vertical { height: 100px; line-height: 100px; } 已知高度的块级子元素，采用绝对定位和负边距 1 2 3 4 5 6 7 8 9 .container { position: relative; } .vertical { height: 300px; /*子元素高度*/ position: absolute; top:50%; /*父元素高度50%*/ margin-top: -150px; /*自身高度一半*/ } 未知高度的块级父子元素居中，模拟表格布局 缺点：IE67不兼容，父级 overflow：hidden 失效 1 2 3 4 5 6 7 .container { display: table; } .content { display: table-cell; vertical-align: middle; } 新增 inline-block 兄弟元素，设置 vertical-align 缺点：需要增加额外标签，IE67不兼容 1 2 3 4 5 6 7 8 9 10 11 .container { height: 100%;/*定义父级高度，作为参考*/ } .extra .vertical{ display: inline-block; /*行内块显示*/ vertical-align: middle; /*垂直居中*/ } .extra { height: 100%; /*设置新增元素高度为100%*/ } 绝对定位配合 CSS3 位移 1 2 3 4 5 .vertical { position: absolute; top:50%; /*父元素高度50%*/ transform:translateY(-50%, -50%); } CSS3弹性盒模型 1 2 3 4 5 .container { display:flex; justify-content: center; /*子元素水平居中*/ align-items: center; /*子元素垂直居中*/ } 圣杯布局的实现原理？\n要求：三列布局；中间主体内容前置，且宽度自适应；两边内容定宽 好处：重要的内容放在文档流前面可以优先渲染 原理：利用相对定位、浮动、负边距布局，而不添加额外标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 .container { padding-left: 150px; padding-right: 190px; } .main { float: left; width: 100%; } .left { float: left; width: 190px; margin-left: -100%; position: relative; left: -150px; } .right { float: left; width: 190px; margin-left: -190px; position: relative; right: -190px; } 什么是双飞翼布局？实现原理？\n双飞翼布局：对圣杯布局（使用相对定位，对以后布局有局限性）的改进，消除相对定位布局 原理：主体元素上设置左右边距，预留两翼位置。左右两栏使用浮动和负边距归位，消除相对定位。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 .container { /*padding-left:150px;*/ /*padding-right:190px;*/ } .main-wrap { width: 100%; float: left; } .main { margin-left: 150px; margin-right: 190px; } .left { float: left; width: 150px; margin-left: -100%; /*position: relative;*/ /*left:-150px;*/ } .right { float: left; width: 190px; margin-left: -190px; /*position:relative;*/ /*right:-190px;*/ } 在CSS样式中常使用 px、em 在表现上有什么区别？\npx 相对于显示器屏幕分辨率，无法用浏览器字体放大功能 em 值并不是固定的，会继承父级的字体大小： em = 像素值 / 父级font-size 为什么要初始化CSS样式？\n不同浏览器对有些标签样式的默认值解析不同 不初始化CSS会造成各现浏览器之间的页面显示差异 可以使用 reset.css 或 Normalize.css 做 CSS 初始化 解释下什么是浮动和它的工作原理？\n非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。 工作原理： 浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象） 浮动元素碰到包含它的边框或者其他浮动元素的边框停留 浮动元素引起的问题？\n父元素的高度无法被撑开，影响与父元素同级的元素 与浮动元素同级的非浮动元素会跟随其后 列举几种清除浮动的方式？\n添加额外标签，例如 \u0026lt;div style=\u0026quot;clear:both\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; 使用 br 标签和其自身的 clear 属性，例如 \u0026lt;br clear=\u0026quot;all\u0026quot; /\u0026gt; 父元素设置 overflow：hidden; 在IE6中还需要触发 hasLayout，例如zoom：1; 父元素也设置浮动 使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout 清除浮动最佳实践（after伪元素闭合浮动）：\n1 2 3 4 5 6 7 8 9 .clearfix:after{ content: \u0026#34;\\200B\u0026#34;; display: table; height: 0; clear: both; } .clearfix{ *zoom: 1; } 什么是 FOUC(Flash of Unstyled Content)？ 如何来避免 FOUC？\n当使用 @import 导入 CSS 时，会导致某些页面在 IE 出现奇怪的现象： 没有样式的页面内容显示瞬间闪烁，这种现象称为“文档样式短暂失效”，简称为FOUC 产生原因：当样式表晚于结构性html加载时，加载到此样式表时，页面将停止之前的渲染。 等待此样式表被下载和解析后，再重新渲染页面，期间导致短暂的花屏现象。 解决方法：使用 link 标签将样式表放在文档 head 介绍使用过的 CSS 预处理器？\nCSS 预处理器基本思想：为 CSS 增加了一些编程的特性（变量、逻辑判断、函数等） 开发者使用这种语言进行进行 Web 页面样式设计，再编译成正常的 CSS 文件使用 使用 CSS 预处理器，可以使 CSS 更加简洁、适应性更强、可读性更佳，无需考虑兼容性 最常用的 CSS 预处理器语言包括：Sass（SCSS）和 LESS CSS优化、提高性能的方法有哪些？\n多个css合并，尽量减少HTTP请求 将css文件放在页面最上面 移除空的css规则 避免使用CSS表达式 选择器优化嵌套，尽量避免层级过深 充分利用css继承属性，减少代码量 抽象提取公共样式，减少代码量 属性值为0时，不加单位 属性值为小于1的小数时，省略小数点前面的0 css雪碧图 浏览器是怎样解析CSS选择器的？\n浏览器解析 CSS 选择器的方式是从右到左 在网页中的应该使用奇数还是偶数的字体？\n在网页中的应该使用“偶数”字体： 偶数字号相对更容易和 web 设计的其他部分构成比例关系 使用奇数号字体时文本段落无法对齐 宋体的中文网页排布中使用最多的就是 12 和 14 margin和padding分别适合什么场景使用？\n需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin 需要在border内测添加空白，且空白处需要背景（色）时，使用 padding 抽离样式模块怎么写，说出思路？\nCSS可以拆分成2部分：公共CSS 和 业务CSS： 网站的配色，字体，交互提取出为公共CSS。这部分CSS命名不应涉及具体的业务 对于业务CSS，需要有统一的命名，使用公用的前缀。可以参考面向对象的CSS 元素竖向的百分比设定是相对于容器的高度吗？\n元素竖向的百分比设定是相对于容器的宽度，而不是高度 全屏滚动的原理是什么？ 用到了CSS的那些属性？\n原理类似图片轮播原理，超出隐藏部分，滚动时显示 可能用到的CSS属性：overflow:hidden; transform:translate(100%, 100%); display:none; 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？\n响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本 基本原理是利用CSS3媒体查询，为不同尺寸的设备适配不同样式 对于低版本的IE，可采用JS获取屏幕宽度，然后通过resize方法来实现兼容： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $(window).resize(function () { screenRespond(); }); screenRespond(); function screenRespond(){ var screenWidth = $(window).width(); if(screenWidth \u0026lt;= 1800){ $(\u0026#34;body\u0026#34;).attr(\u0026#34;class\u0026#34;, \u0026#34;w1800\u0026#34;); } if(screenWidth \u0026lt;= 1400){ $(\u0026#34;body\u0026#34;).attr(\u0026#34;class\u0026#34;, \u0026#34;w1400\u0026#34;); } if(screenWidth \u0026gt; 1800){ $(\u0026#34;body\u0026#34;).attr(\u0026#34;class\u0026#34;, \u0026#34;\u0026#34;); } } 什么是视差滚动效果，如何给每页做不同的动画？\n视差滚动是指多层背景以不同的速度移动，形成立体的运动效果，具有非常出色的视觉体验\n一般把网页解剖为：背景层、内容层和悬浮层。当滚动鼠标滚轮时，各图层以不同速度移动，形成视差的\n实现原理\n以 “页面滚动条” 作为 “视差动画进度条” 以 “滚轮刻度” 当作 “动画帧度” 去播放动画的 监听 mousewheel 事件，事件被触发即播放动画，实现“翻页”效果 a标签上四个伪类的执行顺序是怎么样的？\nlink \u0026gt; visited \u0026gt; hover \u0026gt; active\nL-V-H-A love hate 用喜欢和讨厌两个词来方便记忆 伪元素和伪类的区别和作用？\n伪元素 \u0026ndash; 在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。 它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如： 1 2 3 4 p::before {content:\u0026#34;第一章：\u0026#34;;} p::after {content:\u0026#34;Hot!\u0026#34;;} p::first-line {background:red;} p::first-letter {font-size:30px;} 伪类 \u0026ndash; 将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如： 1 2 a:hover {color: #FF00FF} p:first-child {color: red} ::before 和 :after 中双冒号和单冒号有什么区别？\n在 CSS 中伪类一直用 : 表示，如 :hover, :active 等 伪元素在CSS1中已存在，当时语法是用 : 表示，如 :before 和 :after 后来在CSS3中修订，伪元素用 :: 表示，如 ::before 和 ::after，以此区分伪元素和伪类 由于低版本IE对双冒号不兼容，开发者为了兼容性各浏览器，继续使使用 :after 这种老语法表示伪元素 综上所述：::before 是 CSS3 中写伪元素的新语法； :after 是 CSS1 中存在的、兼容IE的老语法 如何修改Chrome记住密码后自动填充表单的黄色背景？\n产生原因：由于Chrome默认会给自动填充的input表单加上 input:-webkit-autofill 私有属性造成的 解决方案1：在form标签上直接关闭了表单的自动填充：autocomplete=\u0026ldquo;off\u0026rdquo; 解决方案2：input:-webkit-autofill { background-color: transparent; } input [type=search] 搜索框右侧小图标如何美化？\n1 2 3 4 5 6 7 8 input[type=\u0026#34;search\u0026#34;]::-webkit-search-cancel-button{ -webkit-appearance: none; height: 15px; width: 15px; border-radius: 8px; background:url(\u0026#34;images/searchicon.png\u0026#34;) no-repeat 0 0; background-size: 15px 15px; } 网站图片文件，如何点击下载？而非点击预览？\n\u0026lt;a href=\u0026quot;logo.jpg\u0026quot; download\u0026gt;下载\u0026lt;/a\u0026gt; \u0026lt;a href=\u0026quot;logo.jpg\u0026quot; download=\u0026quot;网站LOGO\u0026quot; \u0026gt;下载\u0026lt;/a\u0026gt;\niOS safari 如何阻止“橡皮筋效果”？\n1 2 3 4 5 6 7 $(document).ready(function(){ var stopScrolling = function(event) { event.preventDefault(); } document.addEventListener(\u0026#39;touchstart\u0026#39;, stopScrolling, false); document.addEventListener(\u0026#39;touchmove\u0026#39;, stopScrolling, false); }); 你对 line-height 是如何理解的？\nline-height 指一行字的高度，包含了字间距，实际上是下一行基线到上一行基线距离 如果一个标签没有定义 height 属性，那么其最终表现的高度是由 line-height 决定的 一个容器没有设置高度，那么撑开容器高度的是 line-height 而不是容器内的文字内容 把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中 line-height 和 height 都能撑开一个高度，height 会触发 haslayout，而 line-height 不会 line-height 三种赋值方式有何区别？（带单位、纯数字、百分比）\n带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高 纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 = 27px 百分比：将计算后的值传递给后代 设置元素浮动后，该元素的 display 值会如何变化？\n设置元素浮动后，该元素的 display 值自动变成 block 怎么让Chrome支持小于12px 的文字？\n1 2 3 4 5 .shrink{ -webkit-transform:scale(0.8); -o-transform:scale(1); display:inline-block; } 让页面里的字体变清晰，变细用CSS怎么做？（IOS手机浏览器字体齿轮设置）\n1 -webkit-font-smoothing: antialiased; font-style 属性 oblique 是什么意思？\nfont-style: oblique; 使没有 italic 属性的文字实现倾斜 如果需要手动写动画，你认为最小时间间隔是多久？\n16.7ms 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔: 1s / 60 * 1000 ＝ 16.7ms display:inline-block 什么时候会显示间隙？\n相邻的 inline-block 元素之间有换行或空格分隔的情况下会产生间距 非 inline-block 水平元素设置为 inline-block 也会有水平间距 可以借助 vertical-align:top; 消除垂直间隙 可以在父级加 font-size：0; 在子元素里设置需要的字体大小，消除垂直间隙 把 li 标签写到同一行可以消除垂直间隙，但代码可读性差 overflow: scroll 时不能平滑滚动的问题怎么处理？\n监听滚轮事件，然后滚动到一定距离时用 jquery 的 animate 实现平滑效果。 一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度\n方案1： .sub { height: calc(100%-100px); } 方案2： .container { position:relative; } .sub { position: absolute; top: 100px; bottom: 0; } 方案3： .container { display:flex; flex-direction:column; } .sub { flex:1; } ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/css/","summary":"CSS display: none; 与 visibility: hidden; 的区别 联系：它们都能让元素不可见 区别： display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；visib","title":"CSS"},{"content":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面：\n基本概念：content、padding、margin 标准盒模型、IE盒模型的区别。不要漏说了IE盒模型，通过这个问题，可以筛选一部分人 CSS如何设置这两种模型（即：如何设置某个盒子为其中一个模型）？如果回答了上面的第二条，还会继续追问这一条。 JS如何设置、获取盒模型对应的宽和高？这一步，已经有很多人答不上来了。 实例题：根据盒模型解释边距重叠。 前四个方面是逐渐递增，第五个方面，却鲜有人知。\nBFC（边距重叠解决方案）或IFC。 如果能回答第五条，就会引出第六条。BFC是面试频率较高的。\n总结：以上几点，从上到下，知识点逐渐递增，知识面从理论、CSS、JS，又回到CSS理论\n接下来，我们把上面的六条，依次讲解。\n标准盒模型和IE盒子模型\n标准盒子模型：\nIE盒子模型：\n上图显示：\n在 CSS 盒子模型 (Box Model) 规定了元素处理元素的几种方式：\nwidth和height：内容的宽度、高度（不是盒子的宽度、高度）。 padding：内边距。 border：边框。 margin：外边距。 CSS盒模型和IE盒模型的区别：\n在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。\nIE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。\nCSS如何设置这两种模型\n代码如下：\n1 2 3 4 5 /* 设置当前盒子为 标准盒模型（默认） */ box-sizing: content-box; /* 设置当前盒子为 IE盒模型 */ box-sizing: border-box; 备注：盒子默认为标准盒模型。\nJS如何设置、获取盒模型对应的宽和高\n方式一：通过DOM节点的 style 样式获取\n1 element.style.width/height; 缺点：通过这种方式，只能获取行内样式，不能获取内嵌的样式和外链的样式。\n这种方式有局限性，但应该了解。\n方式二（通用型）\n1 window.getComputedStyle(element).width/height; 方式二能兼容 Chrome、火狐。是通用型方式。\n方式三（IE独有的）\n1 element.currentStyle.width/height; 和方式二相同，但这种方式只有IE独有。获取到的即时运行完之后的宽高（三种css样式都可以获取）。\n方式四\n1 element.getBoundingClientRect().width/height; 此 api 的作用是：获取一个元素的绝对位置。绝对位置是视窗 viewport 左上角的绝对位置。此 api 可以拿到四个属性：left、top、width、height。\n总结：\n上面的四种方式，要求能说出来区别，以及哪个的通用型更强。\nmargin塌陷/margin重叠\n标准文档流中，竖直方向的margin不叠加，只取较大的值作为margin(水平方向的margin是可以叠加的，即水平方向没有塌陷现象)。\n子元素和父元素之间\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; * { margin: 0; padding: 0; } .father { background: green; } /* 给儿子设置margin-top为10像素 */ .son { height: 100px; margin-top: 10px; background: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 上面的代码中，儿子的height是 100px，magin-top 是10px。注意，此时父亲的 height 是100，而不是110。因为儿子和父亲在竖直方向上，共一个margin。\n儿子这个盒子：\n父亲这个盒子：\n上方代码中，如果我们给父亲设置一个属性：overflow: hidden，就可以避免这个问题，此时父亲的高度是110px，这个用到的就是BFC（下一段讲解）。\n善于使用父亲的padding，而不是儿子的margin\n其实，这一小段讲的内容与上一小段相同，都是讲父子之间的margin重叠。\n我们来看一个奇怪的现象。现在有下面这样一个结构：（div中放一个p）\n1 2 3 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 上面的结构中，我们尝试通过给儿子p一个margin-top:50px;的属性，让其与父亲保持50px的上边距。结果却看到了下面的奇怪的现象：\n此时我们给父亲div加一个border属性，就正常了：\n如果父亲没有border，那么儿子的margin实际上踹的是“流”，踹的是这“行”。所以，父亲整体也掉下来了。\nmargin这个属性，本质上描述的是兄弟和兄弟之间的距离； 最好不要用这个marign表达父子之间的距离。\n所以，如果要表达父子之间的距离，我们一定要善于使用父亲的padding，而不是儿子的`margin。\nBFC（边距重叠解决方案）\nBFC（Block Formatting Context）：块级格式化上下文。你可以把它理解成一个独立的区域。\n另外还有个概念叫IFC。不过，BFC问得更多。\nBFC 的原理/BFC的布局规则【非常重要】\nBFC 的原理，其实也就是 BFC 的渲染规则（能说出以下四点就够了）。包括：\nBFC 内部的子元素，在垂直方向，边距会发生重叠。 BFC在页面中是独立的容器，外面的元素不会影响里面的元素，反之亦然。（稍后看举例1） BFC区域不与旁边的float box区域重叠。（可以用来清除浮动带来的影响）。（稍后看举例2） 计算BFC的高度时，浮动的子元素也参与计算。（稍后看举例3） 如何生成BFC\n有以下几种方法：\n方法1：overflow: 不为visible，可以让属性是 hidden、auto。【最常用】 方法2：浮动中：float的属性值不为none。意思是，只要设置了浮动，当前元素就创建了BFC。 方法3：定位中：只要posiiton的值不是 static或者是relative即可，可以是absolute或fixed，也就生成了一个BFC。 方法4：display为inline-block, table-cell, table-caption, flex, inline-flex BFC 的应用\n**举例1：**解决 margin 重叠\n当父元素和子元素发生 margin 重叠时，解决办法：给子元素或父元素创建BFC。\n比如说，针对下面这样一个 div 结构：\n1 2 3 4 \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;son\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 上面的div结构中，如果父元素和子元素发生margin重叠，我们可以给子元素创建一个 BFC，就解决了：\n1 2 3 4 \u0026lt;div class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;p class=\u0026#34;son\u0026#34; style=\u0026#34;overflow: hidden\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; 因为第二条：BFC区域是一个独立的区域，不会影响外面的元素。\n举例2：BFC区域不与float区域重叠：\n针对下面这样一个div结构；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .father-layout { background: pink; } .father-layout .left { float: left; width: 100px; height: 100px; background: green; } .father-layout .right { height: 150px; /*右侧标准流里的元素，比左侧浮动的元素要高*/ background: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section class=\u0026#34;father-layout\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;left\u0026#34;\u0026gt; 左侧，生命壹号 \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;right\u0026#34;\u0026gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下：\n上图中，由于右侧标准流里的元素，比左侧浮动的元素要高，导致右侧有一部分会跑到左边的下面去。\n如果要解决这个问题，可以将右侧的元素创建BFC，因为第三条：BFC区域不与float box区域重叠。解决办法如下：（将right区域添加overflow属性）\n1 2 3 \u0026lt;div class=\u0026#34;right\u0026#34; style=\u0026#34;overflow: hidden\u0026#34;\u0026gt; 右侧，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae，smyhvae， \u0026lt;/div\u0026gt; 上图表明，解决之后，father-layout的背景色显现出来了，说明问题解决了。\n**举例3：**清除浮动\n现在有下面这样的结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .father { background: pink; } .son { float: left; background: green; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;section class=\u0026#34;father\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;son\u0026#34;\u0026gt; 生命壹号 \u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果如下：\n上面的代码中，儿子浮动了，但由于父亲没有设置高度，导致看不到父亲的背景色（此时父亲的高度为0）。正所谓有高度的盒子，才能关住浮动。\n如果想要清除浮动带来的影响，方法一是给父亲设置高度，然后采用隔墙法。方法二是 BFC：给父亲增加 overflow=hidden属性即可， 增加之后，效果如下：\n为什么父元素成为BFC之后，就有了高度呢？这就回到了第四条：计算BFC的高度时，浮动元素也参与计算。意思是，在计算BFC的高度时，子元素的float box也会参与计算\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/css%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%8F%8Abfc/","summary":"题目：谈一谈你对CSS盒模型的认识 专业的面试，一定会问 CSS 盒模型。对于这个题目，我们要回答一下几个方面： 基本概念：content、paddin","title":"CSS盒模型及BFC"},{"content":"CSS 概述\nCSS：Cascading Style Sheet，层叠样式表。CSS 的作用就是给 HTML 页面标签添加各种样式，定义网页的显示效果。简单一句话：CSS 将网页内容和显示样式进行分离，提高了显示功能。\nCSS 语法 语法格式：（其实就是键值对）\n1 选择器{ 属性名: 属性值; 属性名: 属性值; } 解释：\n选择器代表页面上的某类元素，选择器后一定是大括号。 属性名后必须用冒号隔开，属性值后用分号（最后一个属性可以不用分号，但最好还是加上分号）。 冒号和属性值之间可以留一个空格（编程习惯的经验）。 如果一个属性有多个值的话，那么多个值用空格隔开。 举例：\n1 2 3 p { color: red; } css 代码的注释 格式：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; /* 具体的注释 */ p { font-weight: bold; font-style: italic; color: red; } \u0026lt;/style\u0026gt; 注意：CSS 只有/* */这种注释，没有//这种注释。而且注释要写在\u0026lt;style\u0026gt;标签里面才算生效哦。\nCSS 和 HTML 结合的方式（样式表） 优先级： 行内 \u0026gt; 内联 \u0026gt; 外部样式表\n行内样式：在某个特定的标签里采用 style属性。范围只针对此标签。\n内嵌样式表：在页面的 head 里采用\u0026lt;style\u0026gt;标签。范围针对此页面。\n引入外部样式表 css 文件的方式。这种引入方式又分为两种：\n1、采用\u0026lt;link\u0026gt;标签。例如：\u0026lt;link rel = \u0026quot;stylesheet\u0026quot; type = \u0026quot;text/css\u0026quot; href = \u0026quot;a.css\u0026quot;\u0026gt;\u0026lt;/link\u0026gt;\n2、采用 import，必须写在\u0026lt;style\u0026gt;标签中，并且必须是第一句。例如：@import url(a.css) ;\n1、CSS 和 HTML 结合方式一：行内样式 范围只针对此标签适用，适合局部修改。\n1 \u0026lt;p style=\u0026#34;color:white;background-color:red\u0026#34;\u0026gt;我不会就这样轻易的狗带\u0026lt;/p\u0026gt; 2、CSS 和 HTML 结合方式二：内嵌样式表 写在\u0026lt;style\u0026gt;标签，可以对单个页面的样式进行统一设置，但对于局部不够灵活。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; p { font-weight: bold; font-style: italic; color: red; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;洗白白\u0026lt;/p\u0026gt; \u0026lt;p style=\u0026#34;color:blue\u0026#34;\u0026gt;你懂得\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; 3、CSS 和 HTML 结合方式三：引入外部样式表 css 文件 引入样式表文件的方式又分为两种：\n（1）采用\u0026lt;link\u0026gt;标签。例如：\u0026lt;link rel = \u0026quot;stylesheet\u0026quot; type = \u0026quot;text/css\u0026quot; href = \u0026quot;a.css\u0026quot;\u0026gt;\u0026lt;/link\u0026gt;\n（2）采用 import，必须写在\u0026lt;style\u0026gt;标签中，并且必须是第一句。例如：@import url(a.css) ;\n两种引入样式方式的区别：外部样式表中不能写标签，但是可以写 import 语句。\n具体操作如下：\n新建一个a.css样式文件\n1 2 3 4 p { border: 1px solid red; font-size: 40px; } 通过\u0026lt;link\u0026gt;标签引入这个 css 文件\nCSS 的四种基本选择器 权重： 内联 \u0026gt; id （#head） \u0026gt; 类选择器（.head）\u0026gt; 标签选择器 ( p ) 内联样式，如: style=\u0026quot;\u0026hellip;\u0026quot;，权值为1000。 ID选择器，如：#content，权值为0100。 类、伪类、属性选择器，如.content，权值为0010。 标签选择器、伪元素选择器**，如div p，权值为0001。 通配符、子选择器、相邻选择器等。如* \u0026gt; +，权值为0000。 继承的样式没有权值 基本选择器：\nID 选择器：针对某一个特定的标签使用 类选择器：针对你想要的所有标签使用 标签选择器：针对一类标签 通用选择器（通配符）：针对所有的标签都适用（不建议使用） 1、ID 选择器：规定用#来定义 1 #mytitle{ border:3px dashed green; } 2、类选择器：规定用圆点.来定义 css 中用.来表示类。举例如下：\n1 .one{ width:800px; } 3、标签选择器：p 、div 、a \u0026hellip; 1 p{ font-size:14px; } 4、通配符*：匹配任何标签 1 2 3 4 * { margin-left: 0px; margin-top: 0px; } CSS 的几种高级选择器 高级选择器：\n后代选择器：用空格隔开 交集选择器：选择器之间紧密相连 并集选择器（分组选择器）：用逗号隔开 伪类选择器 下面详细讲一下这几种高级（扩展）选择器。\n1、后代选择器: 定义的时候用空格隔开 对于E F这种格式，表示所有属于 E 元素后代的 F 元素，有这个样式。空格就表示后代。\n1 2 3 4 5 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .div1 p { color: red; } \u0026lt;/style\u0026gt; 空格就表示后代。.div1 p 表示.div1的后代所有的p。\n2、交集选择器：定义的时候紧密相连 一般是以标签名开头，比如div.haha，再比如p.special。\n如果后一个选择器是类选择器，则写为div.special；如果后一个选择器 id 选择器，则写为div#special。\n1 2 3 h3.special { color: red; } 选择的元素要求同时满足两个条件：必须是 h3 标签，然后必须是 special 标签。\n3、并集选择器：定义的时候用逗号隔开 1 2 3 4 5 6 p, h1, #mytitle, .one { color: red; } 一些 CSS3 选择器 1.子代选择器（直接下级），用符号\u0026gt;表示 IE7 开始兼容，IE6 不兼容。\n1 2 3 div \u0026gt; p { color: red; } div 的儿子 p。和 div 的后代 p 的截然不同。\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;我是div的儿子\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; /*反例*/ \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt; \u0026lt;p\u0026gt;我是div的重孙子\u0026lt;/p\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 2.序选择器 1 2 3 4 first-child /*第一个*/ last-child\t/*最后一个*/ nth-child(n)\t/*第n个*/ nth-of-type() /*第n个*/ 3.下一个兄弟选择器 +表示选择下一个兄弟\n1 2 3 4 5 \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; h3 + p { color: red; } \u0026lt;/style\u0026gt; 上方的选择器意思是：选择的是 h3 元素后面紧挨着的第一个兄弟。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;h3\u0026gt;我是一个标题\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;我是一个标题\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;我是一个标题\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;我是一个段落\u0026lt;/p\u0026gt; \u0026lt;h3\u0026gt;我是一个标题\u0026lt;/h3\u0026gt; 效果如下：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/01-html/03-css%E9%80%89%E6%8B%A9%E5%99%A8/","summary":"CSS 概述 CSS：Cascading Style Sheet，层叠样式表。CSS 的作用就是给 HTML 页面标签添加各种样式，定义网页的显示效果。简单一句话：CSS 将","title":"CSS选择器"},{"content":"栈和队列的区别?\n栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别？\n栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构 快速 排序的思想并实现一个快排？\n\u0026ldquo;快速排序\u0026quot;的思想很简单，整个排序过程只需要三步：\n（1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function quickSort(arr){ if(arr.length\u0026lt;=1){ return arr;//如果数组只有一个数，就直接返回； } var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i\u0026lt;arr.length;i++){ if(arr[i]\u0026lt;numValue){ left.push(arr[i]);//基准点的左边的数传到左边数组 } else{ right.push(arr[i]);//基准点的右边的数传到右边数组 } } return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较 } alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87” ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/data-structure/","summary":"栈和队列的区别? 栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除","title":"data-structure"},{"content":"知识点主要包括以下几个方面：\n基本概念：DOM事件的级别 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 \u0026hellip;.”。\nDOM事件模型、DOM事件流 面试官如果问你“DOM事件模型”，你不一定知道怎么回事。其实说的就是捕获和冒泡。\nDOM事件流，指的是事件传递的三个阶段。\n描述DOM事件捕获的具体流程 讲的是事件的传递顺序。参数为false（默认）、参数为true，各自代表事件在什么阶段触发。\n能回答出来的人，寥寥无几。也许有些人可以说出一大半，但是一字不落的人，极少。\nEvent对象的常见应用（Event的常用api方法） DOM事件的知识点，一方面包括事件的流程；另一方面就是：怎么去注册事件，也就是监听用户的交互行为。第三点：在响应时，Event对象是非常重要的。\n自定义事件（非常重要）\n一般人可以讲出事件和注册事件，但是如果让你讲自定义事件，能知道的人，就更少了。\nDOM事件的级别\nDOM事件的级别，准确来说，是DOM标准定义的级别。包括：\nDOM0的写法：\n1 2 3 element.onclick = function () { } 上面的代码是在 js 中的写法；如果要在html中写，写法是：在onclick属性中，加 js 语句。\nDOM2的写法：\n1 2 3 element.addEventListener(\u0026#39;click\u0026#39;, function () { }, false); 【重要】上面的第三参数中，true表示事件在捕获阶段触发，false表示事件在冒泡阶段触发（默认）。如果不写，则默认为false。\nDOM3的写法：\n1 2 3 element.addEventListener(\u0026#39;keyup\u0026#39;, function () { }, false); DOM3中，增加了很多事件类型，比如鼠标事件、键盘事件等。\nPS：为何事件没有DOM1的写法呢？因为，DOM1标准制定的时候，没有涉及与事件相关的内容。\n总结：关于“DOM事件的级别”，能回答出以上内容即可，不会出题目让你做。\nDOM事件模型\nDOM事件模型讲的就是捕获和冒泡，一般人都能回答出来。\n捕获：从上往下。 冒泡：从下（目标元素）往上。 DOM事件流\nDOM事件流讲的就是：浏览器在于当前页面做交互时，这个事件是怎么传递到页面上的。\n完整的事件流，分三个阶段：\n捕获：从 window 对象传到 目标元素。 目标阶段：事件通过捕获，到达目标元素，这个阶段就是目标阶段。 冒泡：从目标元素传到 Window 对象。 描述DOM事件捕获的具体流程\n很少有人能说完整。\n捕获的流程\n说明：捕获阶段，事件依次传递的顺序是：window \u0026ndash;\u0026gt; document \u0026ndash;\u0026gt; html\u0026ndash;\u0026gt; body \u0026ndash;\u0026gt; 父元素、子元素、目标元素。\nPS1：第一个接收到事件的对象是 window（有人会说body，有人会说html，这都是错误的）。 PS2：JS中涉及到DOM对象时，有两个对象最常用：window、doucument。它们俩也是最先获取到事件的。 代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 window.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 window\u0026#34;); }, true); document.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 document\u0026#34;); }, true); document.documentElement.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 html\u0026#34;); }, true); document.body.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 body\u0026#34;); }, true); fatherBox.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 father\u0026#34;); }, true); childBox.addEventListener(\u0026#34;click\u0026#34;, function () { alert(\u0026#34;捕获 child\u0026#34;); }, true); 补充一个知识点：\n在 js中：\n如果想获取 body 节点，方法是：document.body； 但是，如果想获取 html节点，方法是document.documentElement。 冒泡的流程\n与捕获的流程相反\nEvent对象的常见 api 方法\n用户做的是什么操作（比如，是敲键盘了，还是点击鼠标了），这些事件基本都是通过Event对象拿到的。这些都比较简单，我们就不讲了。我们来看看下面这几个方法：\n方法一\n1 event.preventDefault(); 解释：阻止默认事件。 比如，已知\u0026lt;a\u0026gt;标签绑定了click事件，此时，如果给\u0026lt;a\u0026gt;设置了这个方法，就阻止了链接的默认跳转。 方法二：阻止冒泡\n这个在业务中很常见。\n有的时候，业务中不需要事件进行冒泡。比如说，业务这样要求：单击子元素做事件A，单击父元素做事件B，如果不阻止冒泡的话，出现的问题是：单击子元素时，子元素和父元素都会做事件A。这个时候，就要用到阻止冒泡了。\nw3c的方法：（火狐、谷歌、IE11）\n1 event.stopPropagation(); IE10以下则是：\n1 event.cancelBubble = true; 兼容代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 box3.onclick = function (event) { alert(\u0026#34;child\u0026#34;); //阻止冒泡 event = event || window.event; if (event \u0026amp;\u0026amp; event.stopPropagation) { event.stopPropagation(); } else { event.cancelBubble = true; } } 上方代码中，我们对box3进行了阻止冒泡，产生的效果是：事件不会继续传递到 father、grandfather、body了。\n方法三：设置事件优先级\n1 event.stopImmediatePropagation(); 这个方法比较长，一般人没听说过。解释如下：\n比如说，我用addEventListener给某按钮同时注册了事件A、事件B。此时，如果我单击按钮，就会依次执行事件A和事件B。现在要求：单击按钮时，只执行事件A，不执行事件B。该怎么做呢？这是时候，就可以用到stopImmediatePropagation方法了。做法是：在事件A的响应函数中加入这句话。\n大家要记住 event 有这个方法。\n属性4、属性5（事件委托中用到）\n1 2 3 4 event.currentTarget //当前所绑定的事件对象。在事件委托中，指的是【父元素】。 event.target //当前被点击的元素。在事件委托中，指的是【子元素】。 上面这两个属性，在事件委托中经常用到。\n总结：上面这几项，非常重要，但是容易弄混淆。\n自定义事件\n自定义事件的代码如下：\n1 2 3 4 5 6 7 var myEvent = new Event(\u0026#39;clickTest\u0026#39;); element.addEventListener(\u0026#39;clickTest\u0026#39;, function () { console.log(\u0026#39;smyhvae\u0026#39;); }); //元素注册事件 element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest 上面这个事件是定义完了之后，就直接自动触发了。在正常的业务中，这个事件一般是和别的事件结合用的。比如延时器设置按钮的动作：\n1 2 3 4 5 6 7 8 9 var myEvent = new Event(\u0026#39;clickTest\u0026#39;); element.addEventListener(\u0026#39;clickTest\u0026#39;, function () { console.log(\u0026#39;smyhvae\u0026#39;); }); setTimeout(function () { element.dispatchEvent(myEvent); //注意，参数是写事件对象 myEvent，不是写 事件名 clickTest }, 1000); ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/dom%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%80%BB%E7%BB%93/","summary":"知识点主要包括以下几个方面： 基本概念：DOM事件的级别 面试不会直接问你，DOM有几个级别。但会在题目中体现：“请用DOM2 \u0026hellip;.","title":"DOM事件的总结"},{"content":"前言 ECMAScript 是 JS 的语言标准。而 ES6 是新的 JS 语法标准。\n发展历史 20180303_1633.png\n2015年6月，ES6正式发布。 ES6 的其他优势 使用 babel 语法转换器，支持低端浏览器\n流行的库基本都是基于 ES6 构建。 React 默认使用 ES6 新源发开发。\nES6 的常用语法 ES6语法概览 块级作用域、字符串\n对象扩展、解构\n类、模块化等。\n作用域：let 和 const 用 let定义变量 ，替代 var\n用const 定义常量（定义后，不可修改）\n作用域和 {}\n举例：\n1 2 3 let a1 = \u0026#39;haha\u0026#39;; const name = `smyhvae`; 模板字符串 我们以前让字符串进行拼接的时候，是这样做的：（传统写法的字符串拼接）\n1 2 3 var name = \u0026#39;smyhvae\u0026#39;; var age = \u0026#39;26\u0026#39;; console.log(\u0026#39;name:\u0026#39;+name+\u0026#39;,age:\u0026#39;+age); //传统写法 这种写法，比较繁琐，而且容易出错。\n现在有了 ES6 语法，字符串拼接可以这样写：\n1 2 3 4 5 6 var name = \u0026#39;smyhvae\u0026#39;; var age = \u0026#39;26\u0026#39;; console.log(\u0026#39;name:\u0026#39;+name+\u0026#39;,age:\u0026#39;+age); //传统写法 console.log(`name:${name},age:${age}`); //ES6 写法 注意，上方代码中，倒数第二行用的是单引号，最后一行用的是反引号（在tab键的上方）。\n函数扩展 ES6 中函数的用法：\n参数默认值\n箭头函数\n展开运算符\n定义和调用函数：（传统写法）\n1 2 3 4 5 function fn1(name) { console.log(name); } fn1(\u0026#39;smyhvae\u0026#39;); 定义和调用函数：（ES6写法）\n1 2 3 4 5 var fn2 = (name)=\u0026gt;{ console.log(name); } fn2(\u0026#39;smyhvae\u0026#39;); 上面两端代码，执行的结果是一样的。\n当然，也可以给上面这个函数的参数加一个默认值：\n1 2 3 4 5 6 var fn2 = (name=\u0026#39;enen\u0026#39;)=\u0026gt;{ console.log(name); } fn2(); //参数用默认值 enen fn2(\u0026#39;smyhvae\u0026#39;); 比如说，1秒后执行一段代码，可以用箭头函数：\n1 2 3 setTimeout(()=\u0026gt;{ console.log(\u0026#39;something\u0026#39;); },1000); 如果函数体只有一条 return 语句，那么大括号可以省略：\n1 2 const myDouble = x=\u0026gt;x*2; console.log(myDouble(5)); //打印结果为10 箭头函数的好处：\n简写代码\n保持 this 的作用域\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/es6/","summary":"前言 ECMAScript 是 JS 的语言标准。而 ES6 是新的 JS 语法标准。 发展历史 20180303_1633.png 2015年6月，ES6正式发布。 ES6 的其他优势 使用 babel 语法转换器，支持低端浏览器 流行的库基","title":"ES6"},{"content":"1、ES5、ES6和ES2015有什么区别? ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES2015、ES2016、ES2017、ES2018等。现阶段在绝大部分场景下，ES2015默认等同ES6。ES5泛指上一代语言标准。ES2015可以理解为ES5和ES6的时间分界线\n2、babel是什么，有什么作用? babel是一个 ES6 转码器，可以将 ES6 代码转为 ES5 代码，以便兼容那些还没支持ES6的平台\n4、举一些ES6对String字符串类型做的常用升级优化? 优化部分\nES6新增了字符串模板，在拼接大段字符串时，用反斜杠()`取代以往的字符串相加的形式，能保留所有空格和换行，使得字符串拼接看起来更加直观，更加优雅\n升级部分\nES6在String原型上新增了includes()方法，用于取代传统的只能用indexOf查找包含字符的方法(indexOf返回-1表示没查到不如includes方法返回false更明确，语义更清晰), 此外还新增了startsWith(), endsWith(), padStart(),padEnd(),repeat()等方法，可方便的用于查找，补全字符串\n5、举一些ES6对Array数组类型做的常用升级优化 优化部分\n数组解构赋值。ES6可以直接以let [a,b,c] = [1,2,3]形式进行变量赋值，在声明较多变量时，不用再写很多let(var),且映射关系清晰，且支持赋默认值 扩展运算符。ES6新增的扩展运算符(...)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代arguments对象和apply方法，轻松获取未知参数个数情况下的参数集合。（尤其是在ES5中，arguments并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（let a = [2,3,4]; let b = [...a]） 升级部分\nES6在Array原型上新增了find()方法，用于取代传统的只能用indexOf查找包含数组项目的方法,且修复了indexOf查找不到NaN的bug([NaN].indexOf(NaN) === -1).此外还新增了copyWithin(), includes(), fill(),flat()等方法，可方便的用于字符串的查找，补全,转换等\n6、举一些ES6对Number数字类型做的常用升级优化 优化部分\nES6在Number原型上新增了isFinite(), isNaN()方法，用来取代传统的全局isFinite(), isNaN()方法检测数值是否有限、是否是NaN。ES5的isFinite(), isNaN()方法都会先将非数值类型的参数转化为Number类型再做判断，这其实是不合理的，最造成isNaN('NaN') === true的奇怪行为--'NaN'是一个字符串，但是isNaN却说这就是NaN。而Number.isFinite()和Number.isNaN()则不会有此类问题(Number.isNaN('NaN') === false)。（isFinite()同上）\n升级部分\nES6在Math对象上新增了Math.cbrt()，trunc()，hypot()等等较多的科学计数法运算方法，可以更加全面的进行立方根、求和立方根等等科学计算\n7、举一些ES6对Object类型做的常用升级优化?(重要) 优化部分\n对象属性变量式声明。ES6可以直接以变量形式声明对象属性或者方法，。比传统的键值对形式声明更加简洁，更加方便，语义更加清晰\n1 2 let [apple, orange] = [\u0026#39;red appe\u0026#39;, \u0026#39;yellow orange\u0026#39;]; let myFruits = {apple, orange}; // let myFruits = {apple: \u0026#39;red appe\u0026#39;, orange: \u0026#39;yellow orange\u0026#39;}; 尤其在对象解构赋值(见优化部分b.)或者模块输出变量时，这种写法的好处体现的最为明显\n1 2 let {keys, values, entries} = Object; let MyOwnMethods = {keys, values, entries}; // let MyOwnMethods = {keys: keys, values: values, entries: entries} 可以看到属性变量式声明属性看起来更加简洁明了。方法也可以采用简洁写法\n1 2 3 4 5 6 let es5Fun = { method: function(){} }; let es6Fun = { method(){} } 对象的解构赋值。 ES6对象也可以像数组解构赋值那样，进行变量的解构赋值\n1 let {apple, orange} = {apple: \u0026#39;red appe\u0026#39;, orange: \u0026#39;yellow orange\u0026#39;}; 对象的扩展运算符(...)。 ES6对象的扩展运算符和数组扩展运算符用法本质上差别不大，毕竟数组也就是特殊的对象。对象的扩展运算符一个最常用也最好用的用处就在于可以轻松的取出一个目标对象内部全部或者部分的可遍历属性，从而进行对象的合并和分解\n1 2 3 4 5 let {apple, orange, ...otherFruits} = {apple: \u0026#39;red apple\u0026#39;, orange: \u0026#39;yellow orange\u0026#39;, grape: \u0026#39;purple grape\u0026#39;, peach: \u0026#39;sweet peach\u0026#39;}; // otherFruits {grape: \u0026#39;purple grape\u0026#39;, peach: \u0026#39;sweet peach\u0026#39;} // 注意: 对象的扩展运算符用在解构赋值时，扩展运算符只能用在最有一个参数(otherFruits后面不能再跟其他参数) let moreFruits = {watermelon: \u0026#39;nice watermelon\u0026#39;}; let allFruits = {apple, orange, ...otherFruits, ...moreFruits}; super 关键字。ES6在Class类里新增了类似this的关键字super。同this总是指向当前函数所在的对象不同，super关键字总是指向当前函数所在对象的原型对象\n升级部分\nES6在Object原型上新增了is()方法，做两个目标对象的相等比较，用来完善'==='方法。'==='方法中NaN === NaN //false其实是不合理的，Object.is修复了这个小bug。(Object.is(NaN, NaN) // true)\nES6在Object原型上新增了assign()方法，用于对象新增属性或者多个对象合并\n1 2 3 4 5 const target = { a: 1 }; const source1 = { b: 2 }; const source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 注意: assign合并的对象target只能合并source1、source2中的自身属性，并不会合并source1、source2中的继承属性，也不会合并不可枚举的属性，且无法正确复制get和set属性（会直接执行get/set函数，取return的值）\nES6在Object原型上新增了getOwnPropertyDescriptors()方法，此方法增强了ES5中getOwnPropertyDescriptor()方法，可以获取指定对象所有自身属性的描述对象。结合defineProperties()方法，可以完美复制对象，包括复制get和set属性 ES6在Object原型上新增了getPrototypeOf()和setPrototypeOf()方法，用来获取或设置当前对象的prototype对象。这个方法存在的意义在于，ES5中获取设置prototype对像是通过__proto__属性来实现的，然而__proto__属性并不是ES规范中的明文规定的属性，只是浏览器各大产商“私自”加上去的属性，只不过因为适用范围广而被默认使用了，再非浏览器环境中并不一定就可以使用，所以为了稳妥起见，获取或设置当前对象的prototype对象时，都应该采用ES6新增的标准用法 ES6在Object原型上还新增了Object.keys()，Object.values()，Object.entries()方法，用来获取对象的所有键、所有值和所有键值对数组 8、举一些ES6对Function函数类型做的常用升级优化? 优化部分\n箭头函数(核心)。箭头函数是ES6核心的升级项之一，箭头函数里没有自己的this,这改变了以往JS函数中最让人难以理解的this运行机制。主要优化点\n箭头函数内的this指向的是函数定义时所在的对象，而不是函数执行时所在的对象。ES5函数里的this总是指向函数执行时所在的对象，这使得在很多情况下this的指向变得很难理解，尤其是非严格模式情况下，this有时候会指向全局对象，这甚至也可以归结为语言层面的bug之一。ES6的箭头函数优化了这一点，它的内部没有自己的this,这也就导致了this总是指向上一层的this，如果上一层还是箭头函数，则继续向上指，直到指向到有自己this的函数为止，并作为自己的this 箭头函数不能用作构造函数，因为它没有自己的this，无法实例化 也是因为箭头函数没有自己的this,所以箭头函数 内也不存在arguments对象。（可以用扩展运算符代替） 函数默认赋值。ES6之前，函数的形参是无法给默认值得，只能在函数内部通过变通方法实现。ES6以更简洁更明确的方式进行函数默认赋值 1 2 3 4 function es6Fuc (x, y = \u0026#39;default\u0026#39;) { console.log(x, y); } es6Fuc(4) // 4, default 升级部分\nES6新增了双冒号运算符，用来取代以往的bind，call,和apply。(浏览器暂不支持，Babel已经支持转码)\n1 2 3 4 5 6 7 foo::bar; // 等同于 bar.bind(foo); foo::bar(...arguments); // 等同于 bar.apply(foo, arguments); 9、Symbol是什么，有什么作用？ Symbol是ES6引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中Symbol()属性不能被for...in遍历，但是也不是私有属性\n10、Set是什么，有什么作用？ Set是ES6引入的一种类似Array的新的数据结构，Set实例的成员类似于数组item成员，区别是Set实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重\n11、Map是什么，有什么作用？ Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。可以更加全面的描述对象的属性\n12、Proxy是什么，有什么作用？ Proxy是ES6新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的get/set等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的get/set方法，可以轻松地定制自己想要的key或者value。下面的例子可以看到，随便定义一个myOwnObj的key,都可以变成自己想要的函数`\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 function createMyOwnObj() { //想把所有的key都变成函数，或者Promise,或者anything return new Proxy({}, { get(target, propKey, receiver) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { let randomBoolean = Math.random() \u0026gt; 0.5; let Message; if (randomBoolean) { Message = `你的${propKey}运气不错，成功了`; resolve(Message); } else { Message = `你的${propKey}运气不行，失败了`; reject(Message); } }, 1000); }); } }); } let myOwnObj = createMyOwnObj(); myOwnObj.hahaha.then(result =\u0026gt; { console.log(result) //你的hahaha运气不错，成功了 }).catch(error =\u0026gt; { console.log(error) //你的hahaha运气不行，失败了 }) myOwnObj.wuwuwu.then(result =\u0026gt; { console.log(result) //你的wuwuwu运气不错，成功了 }).catch(error =\u0026gt; { console.log(error) //你的wuwuwu运气不行，失败了 }) 13、Reflect是什么，有什么作用？ Reflect是ES6引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在Object、Function或者全局函数里的方法(如apply、delete、get、set等等)，统一整合到Reflect上，这样可以更加方便更加统一的管理一些原生API。其次就是因为Proxy可以改写默认的原生API，如果一旦原生API别改写可能就找不到了，所以Reflect也可以起到备份原生API的作用，使得即使原生API被改写了之后，也可以在被改写之后的API用上默认的API\n14、Promise是什么，有什么作用？ Promise是ES6引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的API，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用\n15、Iterator是什么，有什么作用？(重要) Iterator是ES6中一个很重要概念，它并不是对象，也不是任何一种数据类型。因为ES6新增了Set、Map类型，他们和Array、Object类型很像，Array、Object都是可以遍历的，但是Set、Map都不能用for循环遍历，解决这个问题有两种方案，一种是为Set、Map单独新增一个用来遍历的API，另一种是为Set、Map、Array、Object新增一个统一的遍历API，显然，第二种更好，ES6也就顺其自然的需要一种设计标准，来统一所有可遍历类型的遍历方式。Iterator正是这样一种标准。或者说是一种规范理念 就好像JavaScript是ECMAScript标准的一种具体实现一样，Iterator标准的具体实现是Iterator遍历器。Iterator标准规定，所有部署了key值为[Symbol.iterator]，且[Symbol.iterator]的value是标准的Iterator接口函数(标准的Iterator接口函数: 该函数必须返回一个对象，且对象中包含next方法，且执行next()能返回包含value/done属性的Iterator对象)的对象，都称之为可遍历对象，next()后返回的Iterator对象也就是Iterator遍历器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //obj就是可遍历的，因为它遵循了Iterator标准，且包含[Symbol.iterator]方法，方法函数也符合标准的Iterator接口规范。 //obj.[Symbol.iterator]() 就是Iterator遍历器 let obj = { data: [ \u0026#39;hello\u0026#39;, \u0026#39;world\u0026#39; ], [Symbol.iterator]() { const self = this; let index = 0; return { next() { if (index \u0026lt; self.data.length) { return { value: self.data[index++], done: false }; } else { return { value: undefined, done: true }; } } }; } }; ES6给Set、Map、Array、String都加上了[Symbol.iterator]方法，且[Symbol.iterator]方法函数也符合标准的Iterator接口规范，所以Set、Map、Array、String默认都是可以遍历的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //Array let array = [\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]; array[Symbol.iterator]() //Iterator遍历器 array[Symbol.iterator]().next() //{value: \u0026#34;red\u0026#34;, done: false} //String let string = \u0026#39;1122334455\u0026#39;; string[Symbol.iterator]() //Iterator遍历器 string[Symbol.iterator]().next() //{value: \u0026#34;1\u0026#34;, done: false} //set let set = new Set([\u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;blue\u0026#39;]); set[Symbol.iterator]() //Iterator遍历器 set[Symbol.iterator]().next() //{value: \u0026#34;red\u0026#34;, done: false} //Map let map = new Map(); let obj= {map: \u0026#39;map\u0026#39;}; map.set(obj, \u0026#39;mapValue\u0026#39;); map[Symbol.iterator]().next() {value: Array(2), done: false} 16、for\u0026hellip;in 和for\u0026hellip;of有什么区别？ 如果看到问题十六，那么就很好回答。问题十六提到了ES6统一了遍历标准，制定了可遍历对象，那么用什么方法去遍历呢？答案就是用for...of。ES6规定，有所部署了载了Iterator接口的对象(可遍历对象)都可以通过for...of去遍历，而for..in仅仅可以遍历对象\n这也就意味着，数组也可以用for...of遍历，这极大地方便了数组的取值，且避免了很多程序用for..in去遍历数组的恶习 17、Generator函数是什么，有什么作用？ 如果说JavaScript是ECMAScript标准的一种具体实现、Iterator遍历器是Iterator的具体实现，那么Generator函数可以说是Iterator接口的具体实现方式。 执行Generator函数会返回一个遍历器对象，每一次Generator函数里面的yield都相当一次遍历器对象的next()方法，并且可以通过next(value)方法传入自定义的value,来改变Generator函数的行为。 Generator函数可以通过配合Thunk 函数更轻松更优雅的实现异步编程和控制流管理。 18、async函数是什么，有什么作用？ async函数可以理解为内置自动执行器的Generator函数语法糖，它配合ES6的Promise近乎完美的实现了异步编程解决方案\n19、Class、extends是什么，有什么作用？ ES6 的class可以看作只是一个ES5生成实例对象的构造函数的语法糖。它参考了java语言，定义了一个类的概念，让对象原型写法更加清晰，对象实例化更像是一种面向对象编程。Class类可以通过extends实现继承。它和ES5构造函数的不同点\n类的内部定义的所有方法，都是不可枚举的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ///ES5 function ES5Fun (x, y) { this.x = x; this.y = y; } ES5Fun.prototype.toString = function () { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; } var p = new ES5Fun(1, 3); p.toString(); Object.keys(ES5Fun.prototype); //[\u0026#39;toString\u0026#39;] //ES6 class ES6Fun { constructor (x, y) { this.x = x; this.y = y; } toString () { return \u0026#39;(\u0026#39; + this.x + \u0026#39;, \u0026#39; + this.y + \u0026#39;)\u0026#39;; } } Object.keys(ES6Fun.prototype); //[] ES6的class类必须用new命令操作，而ES5的构造函数不用new也可以执行。 ES6的class类不存在变量提升，必须先定义class之后才能实例化，不像ES5中可以将构造函数写在实例化之后。 ES5 的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（所以必须先调用super方法），然后再用子类的构造函数修改this。 20、module、export、import是什么，有什么作用？ module、export、import是ES6用来统一前端模块化方案的设计思路和实现方案。export、import的出现统一了前端模块化的实现方案，整合规范了浏览器/服务端的模块化方法，用来取代传统的AMD/CMD、requireJS、seaJS、commondJS等等一系列前端模块不同的实现方案，使前端模块化更加统一规范，JS也能更加能实现大型的应用程序开发。 import引入的模块是静态加载（编译阶段加载）而不是动态加载（运行时加载）。 import引入export导出的接口值是动态绑定关系，即通过该接口，可以取到模块内部实时的值 21、日常前端代码开发中，有哪些值得用ES6去改进的编程优化或者规范？ 常用箭头函数来取代var self = this;的做法。 常用let取代var命令。 常用数组/对象的结构赋值来命名变量，结构更清晰，语义更明确，可读性更好。 在长字符串多变量组合场合，用模板字符串来取代字符串累加，能取得更好地效果和阅读体验。 用Class类取代传统的构造函数，来生成实例化对象。 在大型应用开发中，要保持module模块化开发思维，分清模块之间的关系，常用import、export方法。 22、ES6的了解 新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=\u0026gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念\n23、说说你对Promise的理解 依照 Promise/A+ 的定义，Promise 有四种状态：\npending: 初始状态, 非 fulfilled 或 rejected.\nfulfilled: 成功的操作.\nrejected: 失败的操作.\nsettled: Promise已被fulfilled或rejected，且不是pending\n另外， fulfilled 与 rejected 一起合称 settled\nPromise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算\n24、Promise 的构造函数 构造一个 Promise，最基本的用法如下： 1 2 3 4 5 6 7 8 9 10 11 12 var promise = new Promise(function(resolve, reject) { if (...) { // succeed resolve(result); } else { // fails reject(Error(errMessage)); } }); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为thenable）。它的使用方法如下： 1 promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在rejected的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject 什么是 Promise ？\nPromise 就是一个对象，用来表示并传递异步操作的最终结果 Promise 最主要的交互方式：将回调函数传入 then 方法来获得最终结果或出错原因 Promise 代码书写上的表现：以“链式调用”代替回调函数层层嵌套（回调地狱） 25、谈一谈你了解ECMAScript6的新特性？ 块级作用区域 let a = 1; 可定义常量 const PI = 3.141592654; 变量解构赋值 var [a, b, c] = [1, 2, 3]; 字符串的扩展(模板字符串) var sum =${a + b}; 数组的扩展(转换数组类型) Array.from($('li')); 函数的扩展(扩展运算符) [1, 2].push(...[3, 4, 5]); 对象的扩展(同值相等算法) Object.is(NaN, NaN); 新增数据类型(Symbol) let uid = Symbol('uid'); 新增数据结构(Map) let set = new Set([1, 2, 2, 3]); for\u0026hellip;of循环 for(let val of arr){}; Promise对象 var promise = new Promise(func); Generator函数 function* foo(x){yield x; return x*x;} 引入Class(类) class Foo {} 引入模块体系 export default func; 引入async函数[ES7] 1 2 3 4 5 async function asyncPrint(value, ms) { await timeout(ms); console.log(value) } 26、Object.is() 与原来的比较操作符 ===、== 的区别？ == 相等运算符，比较时会自动进行数据类型转换 === 严格相等运算符，比较时不进行隐式类型转换 Object.is 同值相等算法，在 === 基础上对 0 和 NaN 特别处理 1 2 3 4 5 +0 === -0 //true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true 27、什么是 Babel Babel 是一个 JS 编译器，自带一组 ES6 语法转化器，用于转化 JS 代码。 这些转化器让开发者提前使用最新的 JS语法(ES6/ES7)，而不用等浏览器全部兼容。 Babel 默认只转换新的 JS 句法(syntax)，而不转换新的API。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-es6/","summary":"1、ES5、ES6和ES2015有什么区别? ES2015特指在2015年发布的新一代JS语言标准，ES6泛指下一代JS语言标准，包含ES20","title":"ES6"},{"content":"Symbol 概述 背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。\n概念：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。\n特点：\nSymbol属性对应的值是唯一的，解决命名冲突问题\nSymbol值不能与其他数据进行计算，包括同字符串拼串\nfor in、for of 遍历时不会遍历Symbol属性。\n创建Symbol属性值 Symbol是函数，但并不是构造函数。创建一个Symbol数据类型：\n1 2 3 4 let mySymbol = Symbol(); console.log(typeof mySymbol); //打印结果：symbol console.log(mySymbol); //打印结果：Symbol() 打印结果：\n下面来讲一下Symbol的使用。\n1、将Symbol作为对象的属性值 1 2 3 4 5 6 7 8 9 10 11 let mySymbol = Symbol(); let obj = { name: \u0026#39;smyhvae\u0026#39;, age: 26 }; //obj.mySymbol = \u0026#39;male\u0026#39;; //错误：不能用 . 这个符号给对象添加 Symbol 属性。 obj[mySymbol] = \u0026#39;hello\u0026#39;; //正确：通过**属性选择器**给对象添加 Symbol 属性。后面的属性值随便写。 console.log(obj); 上面的代码中，我们尝试给obj添加一个Symbol类型的属性值，但是添加的时候，不能采用.这个符号，而是应该用属性选择器的方式。打印结果：\n现在我们用for in尝试对上面的obj进行遍历：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let mySymbol = Symbol(); let obj = { name: \u0026#39;smyhvae\u0026#39;, age: 26 }; obj[mySymbol] = \u0026#39;hello\u0026#39;; console.log(obj); //遍历obj for (let i in obj) { console.log(i); } 打印结果：\n从打印结果中可以看到：for in、for of 遍历时不会遍历Symbol属性。\n创建Symbol属性值时，传参作为标识 如果我通过 Symbol()函数创建了两个值，这两个值是不一样的：\n1 2 3 4 5 6 let mySymbol1 = Symbol(); let mySymbol2 = Symbol(); console.log(mySymbol1 == mySymbol2); //打印结果：false console.log(mySymbol1); //打印结果：Symbol() console.log(mySymbol2); //打印结果：Symbol() 上面代码中，倒数第三行的打印结果也就表明了，二者的值确实是不相等的。\n最后两行的打印结果却发现，二者的打印输出，肉眼看到的却相同。那该怎么区分它们呢？\n既然Symbol()是函数，函数就可以传入参数，我们可以通过参数的不同来作为标识。比如：\n1 2 3 4 5 6 7 8 //在括号里加入参数，来标识不同的Symbol let mySymbol1 = Symbol(\u0026#39;one\u0026#39;); let mySymbol2 = Symbol(\u0026#39;two\u0026#39;); console.log(mySymbol1 == mySymbol2); //打印结果：false console.log(mySymbol1); //打印结果：Symbol(one) console.log(mySymbol2); //打印结果：Symbol(two)。颜色为红色。 console.log(mySymbol2.toString());//打印结果：Symbol(two)。颜色为黑色。 打印结果：\n定义常量 Symbol 可以用来定义常量：\n1 const MY_NAME = Symbol(\u0026#39;my_name\u0026#39;); 内置的 Symbol 值 除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。\nSymbol.iterator属性 对象的Symbol.iterator属性，指向该对象的默认遍历器方法。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/es6symbol/","summary":"Symbol 概述 背景：ES5中对象的属性名都是字符串，容易造成重名，污染环境。 概念：ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它","title":"ES6：Symbol"},{"content":"GitHub的使用 GitHub添加wiki 参考链接：\nhttps://juejin.im/post/5a3216c8f265da43333e6b54 GitHub项目添加 license 参考链接：\nhttps://blog.csdn.net/qq_35246620/article/details/77647234 GitHub 引用图片的另一种方式 参考链接：\n关于markdown文件插入图片遇到的小问题和解决办法 ","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/05-github%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"GitHub的使用 GitHub添加wiki 参考链接： https://juejin.im/post/5a3216c8f265da43333e6b54 GitHub项目添加 license 参考链接： https://blog.csdn.net/qq_35246620/article/details/77647234 GitHub 引用图片的另一种方式 参考链接： 关于markdown","title":"GitHub的使用"},{"content":"HTML 语义化\nHTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构\ncss命名的语义化是指：为html标签添加有意义的class\n为什么需要语义化：\n去掉样式后页面呈现清晰的结构 盲人使用读屏器更好地阅读 搜索引擎更好地理解页面，有利于收录 便团队项目的可持续运作及维护 简述一下你对HTML语义化的理解？\n用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解 Doctype作用？标准模式与兼容模式各有什么区别?\n\u0026lt;!DOCTYPE\u0026gt;声明位于位于HTML文档中的第一行，处于 \u0026lt;html\u0026gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作 HTML5 为什么只需要写 \u003c!DOCTYPE HTML\u003e？\nHTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行） 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？\n行内元素有：a b span img input select strong（强调的语气） 块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p 常见的空元素: \u0026lt;br\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;img\u0026gt; \u0026lt;input\u0026gt; \u0026lt;link\u0026gt; \u0026lt;meta\u0026gt; 页面导入样式时，使用link和@import有什么区别？\nlink属于XHTML标签，除了加载CSS外，还能用于定义RSS,定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载 import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题 介绍一下你对浏览器内核的理解？\n主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎\n渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核\nJS引擎则：解析和执行javascript来实现网页的动态效果\n最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎\n常见的浏览器内核有哪些？\nTrident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的Blink（WebKit的分支）] html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？\nHTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加\n绘画 canvas 用于媒介回放的 video 和 audio 元素 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失 sessionStorage 的数据在浏览器关闭后自动删除 语意化更好的内容元素，比如 article、footer、header、nav、section 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素：\n纯表现的元素：basefont，big，center，font, s，strike，tt，u\n对可用性产生负面影响的元素：frame，frameset，noframes\n支持HTML5新标签：\nIE8/IE7/IE6支持通过document.createElement方法产生的标签 可以利用这一特性让这些浏览器支持HTML5新标签 浏览器支持新标签后，还需要添加标签默认的样式 当然也可以直接使用成熟的框架、比如html5shim\n1 2 3 \u0026lt;!--[if lt IE 9]\u0026gt; \u0026lt;script\u0026gt; src=\u0026#34;http://html5shim.googlecode.com /svn/trunk/html5.js\u0026#34;\u0026lt;/script\u0026gt;\u0026lt;![endif]--\u0026gt; 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素 HTML5的离线储存怎么使用，工作原理能不能解释一下？\n在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件\n原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示\n如何使用：\n页面头部像下面一样加入一个manifest的属性； 在cache.manifest文件的编写离线存储的资源 在离线状态时，操作window.applicationCache进行需求实现 1 2 3 4 5 6 7 8 9 CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\n在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n离线的情况下，浏览器就直接使用离线存储的资源。\n请描述一下 cookies，sessionStorage 和 localStorage 的区别？\ncookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）\ncookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递\nsessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存\n存储大小：\ncookie数据大小不能超过4k sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间：\nlocalStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？\niframe会阻塞主页面的Onload事件 搜索引擎的检索程序无法解读这种页面，不利于SEO iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript动态给iframe添加src属性值，这样可以绕开以上两个问题 Label的作用是什么？是怎么用的？\nlabel标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件 HTML5的form如何关闭自动完成功能？\n给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里)\nWebSocket、SharedWorker 也可以调用localstorge、cookies等本地存储方式 webSocket如何兼容低浏览器？(阿里)\nAdobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？\n通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 如何在页面上实现一个圆形的可点击区域？\nmap+area或者svg border-radius 纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果\n1 \u0026lt;div style=\u0026#34;height:1px;overflow:hidden;background:red\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 网页验证码是干嘛的，是为了解决什么安全问题\n区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试 title与h1的区别、b与strong的区别、i与em的区别？\ntitle属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响 strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：strong会重读，而b是展示强调内容 i内容展示为斜体，em表示强调的文本 页面导入样式时，使用 link 和 @import 有什么区别？\nlink 属于HTML标签，除了加载CSS外，还能用于定 RSS等；@import 只能用于加载CSS 页面加载的时，link 会同时被加载，而 @import 引用的 CSS 会等到页面被加载完再加载 @import 只在 IE5 以上才能被识别，而 link 是HTML标签，无兼容问题 介绍一下你对浏览器内核的理解？\n浏览器内核主要分为两部分：渲染引擎(layout engineer 或 Rendering Engine) 和 JS引擎 渲染引擎负责取得网页的内容进行布局计和样式渲染，然后会输出至显示器或打印机 JS引擎则负责解析和执行JS脚本来实现网页的动态效果和用户交互 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎 常见的浏览器内核有哪些？\nBlink内核：新版 Chrome、新版 Opera Webkit内核：Safari、原Chrome Gecko内核：FireFox、Netscape6及以上版本 Trident内核（又称MSHTML内核）：IE、国产浏览器 Presto内核：原Opera7及以上 HTML5有哪些新特性？\n新增选择器 document.querySelector、document.querySelectorAll 拖拽释放(Drag and drop) API 媒体播放的 video 和 audio 本地存储 localStorage 和 sessionStorage 离线应用 manifest 桌面通知 Notifications 语意化标签 article、footer、header、nav、section 增强表单控件 calendar、date、time、email、url、search 地理位置 Geolocation 多任务 webworker 全双工通信协议 websocket 历史管理 history 跨域资源共享(CORS) Access-Control-Allow-Origin 页面可见性改变事件 visibilitychange 跨窗口通信 PostMessage Form Data 对象 绘画 canvas HTML5移除了那些元素？\n纯表现的元素：basefont、big、center、font、s、strike、tt、u 对可用性产生负面影响的元素：frame、frameset、noframes 如何处理HTML5新标签的浏览器兼容问题？\n通过 document.createElement 创建新标签 使用垫片 html5shiv.js 如何区分 HTML 和 HTML5？\nDOCTYPE声明、新增的结构元素、功能元素 HTML5的离线储存工作原理能不能解释一下，怎么使用？\nHTML5的离线储存原理：\n用户在线时，保存更新用户机器上的缓存文件；当用户离线时，可以正常访离线储存问站点或应用内容 HTML5的离线储存使用：\n在文档的 html 标签设置 manifest 属性，如 manifest=\u0026quot;/offline.appcache\u0026quot; 在项目中新建 manifest 文件，manifest 文件的命名建议：xxx.appcache 在 web 服务器配置正确的 MIME-type，即 text/cache-manifest 浏览器是怎么对HTML5的离线储存资源进行管理和加载的？\n在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件 如果是第一次访问app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储 如果已经访问过app且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储 离线的情况下，浏览器就直接使用离线存储的资源。 iframe 有那些优点和缺点？\n优点：\n用来加载速度较慢的内容（如广告） 可以使脚本可以并行下载 可以实现跨子域通信 缺点：\niframe 会阻塞主页面的 onload 事件 无法被一些搜索引擎索识别 会产生很多页面，不容易管理 label 的作用是什么？怎么使用的？\nlabel标签来定义表单控件的关系：\n当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上 使用方法1：\n\u0026lt;label for=\u0026quot;mobile\u0026quot;\u0026gt;Number:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;mobile\u0026quot;/\u0026gt; 使用方法2：\n\u0026lt;label\u0026gt;Date:\u0026lt;input type=\u0026quot;text\u0026quot;/\u0026gt;\u0026lt;/label\u0026gt; 如何实现浏览器内多个标签页之间的通信？\niframe + contentWindow postMessage SharedWorker(Web Worker API) storage 事件(localStorge API) WebSocket webSocket 如何兼容低浏览器？\nAdobe Flash Socket ActiveX HTMLFile (IE) 基于 multipart 编码发送 XHR 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？\n在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放 当用户浏览其他页面，暂停网站首页幻灯自动播放 完成登陆后，无刷新自动同步其他页面的登录状态 title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？\ntitle 表示是整个页面标题，h1 则表示层次明确的标题，对页面信息的抓取有很大的影响 strong 标明重点内容，有语气加强的含义，使用阅读设备阅读网络时，strong 会重读，而 b 是展示强调内容\ni 内容展示为斜体，em 表示强调的文本 自然样式标签：b, i, u, s, pre 语义样式标签：strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用。如果不能确定时，首选使用自然样式标签 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-html/","summary":"HTML 语义化 HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构 css命名的语义化是指：为html标签添加有意义的","title":"HTML"},{"content":"一面中，如果有笔试，考HTTP协议的可能性较大。\n1. 前言 一面要讲的内容：\nHTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的区别 HTTP状态码 什么是持久连接 什么是管线化 二面要讲的内容；\n缓存 CSRF攻击 2. HTTP协议的主要特点 简单快速 灵活 无连接 无状态 通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个：无连接、无状态。\n2.1 简单快速 简单：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。\n2.2 灵活 http协议的头部有一个数据类型，通过http协议，就可以完成不同数据类型的传输。\n2.3 无连接 连接一次，就会断开，不会继续保持连接。\n2.4 无状态 客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时，服务器端并没有记住之前的状态，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。\n有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。\n3 HTTP报文的组成部分 在回答此问题时，我们要按照顺序回答：\n先回答的是，http报文包括：请求报文和响应报文。 再回答的是，每个报文包含什么部分。 最后回答，每个部分的内容是什么 3.1 请求报文包括： 请求行：包括请求方法、请求的url、http协议及版本。 请求头：一大堆的键值对。 空行指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体 请求体：数据部分。 3.2 响应报文包括： 状态行：http协议及版本、状态码及状态描述。 响应头 空行 响应体 4 HTTP方法 包括：\nGET：获取资源 POST：传输资源 put：更新资源 DELETE：删除资源 HEAD：获得报文首部 HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。\nget 和 post` 比较常见。 put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。 head 可能偶尔用的到。 5 get 和 post的区别 区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。 有一点要强调，get是相对不隐私的，而post是相对隐私的。 我们大概要记住以下几点：\n浏览器在回退时，get 不会重新请求，但是post会重新请求。【重要】 get请求会被浏览器主动缓存，而post不会。【重要】 get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。 get请求在url中传递的参数有大小限制，基本是2kb`，不同的浏览器略有不同。而post没有注意。 get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。 6 http状态码 http状态码分类：\n常见的http状态码：\n部分解释：\n206的应用：range指的是请求的范围，客户端只请求某个大文件里的一部分内容。比如说，如果播放视频地址或音频地址的前面一部分，可以用到206。 301：重定向（永久）。 302：重定向（临时）。 304：我这个服务器告诉客户端，你已经有缓存了，不需要从我这里取了。 400和401用的不多,未授权。403指的是请求被拒绝。404指的是资源不存在。 7 持久链接/http长连接 如果你能答出持久链接，这是面试官很想知道的一个点。\n轮询：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。 长连接：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。 注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。\n8 长连接中的管线化 如果能答出管线化，则属于加分项。\n8.1 管线化的原理 长连接时，默认的请求这样的：\n1 请求1 --\u0026gt; 响应1 --\u0026gt;请求2 --\u0026gt; 响应2 --\u0026gt; 请求3 --\u0026gt; 响应3 管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/http%E5%8D%8F%E8%AE%AE/","summary":"一面中，如果有笔试，考HTTP协议的可能性较大。 1. 前言 一面要讲的内容： HTTP协议的主要特点 HTTP报文的组成部分 HTTP方法 get 和 post的","title":"HTTP协议"},{"content":"方法的注释 方法写完之后（注意，一定要先写完整），我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。\n比如：\n1 2 3 4 5 6 7 8 9 /** * 功能：给定元素查找他的第一个元素子节点，并返回 * @param ele * @returns {Element|*|Node} */ function getFirstNode(ele){ var node = ele.firstElementChild || ele.firstChild; return node; } 断点调试 （1）先让程序运行一遍。\n（2）f12，弹出代码调试工具\n（3）打断点：\n然后刷新页面。\n（4）一步步调试，每点击一次，执行一步：\n（5）监视变量：\n当然，也可以添加变量或者表达式到监视窗口。操作如下：\n上图中，选择变量或表达式，然后右键add to watch.\n然后监视窗口：\n2019-05-20-给数组、对象赋值 数组赋值的正确写法：\n1 this.todayList.splice(0, 0, ...dataList); 对象赋值的正确写法：\n1 Object.assign(obj2, obj1); 上方代码中，是将obj1 的值追加到obj2中。如果对象里的属性名相同，会被覆盖。\n2019-11-25-在新的窗口中打开url 在原来的窗体中跳转到新页面：\n1 window.location.href=\u0026#34;要跳转的新页面\u0026#34;; 在新窗体中打开新页面：\n1 window.open(\u0026#39;你所要跳转的新页面\u0026#39;); 2019-12-10-JavaScript 新特性：Optional Chaining（可选链式调用）语法 以往写代码，我们一般都这么写：\n1 2 3 if (result \u0026amp;\u0026amp; result.user \u0026amp;\u0026amp; result.user.name \u0026amp;\u0026amp; result.user.name.length) { console.log(\u0026#39;qianguyihao\u0026#39;); } 有了 Optinal Chain 语法之后，就简洁很多了，可以这么写：\n1 2 3 if (result?.user?.name?.length) { console.log(\u0026#39;qianguyihao\u0026#39;); } 参考链接：\n了解 JavaScript 新特性：Optional Chaining：https://www.infoq.cn/article/2JDORgXrU6VmZ7jlyuFD\n原文链接： https://v8.dev/features/optional-chaining\n2020-04-28-判断字符串的包含关系 1 2 3 4 var str = \u0026#39;qiangu2\u0026#39;; if (str == (\u0026#39;qiangu1\u0026#39; || \u0026#39;qiangu2\u0026#39;)) { console.log(\u0026#39;qianguyihao\u0026#39;); } 注意，上面的代码，根本就不会走 console.log 语句，因为if里面的内容是false。\n如果我们要判断变量 str 是否在 qiangu1、qiangu2的合集里，我们应该这样写：\n1 2 3 4 var str = \u0026#39;qiangu2\u0026#39;; if (str == \u0026#39;qiangu1\u0026#39; || str == \u0026#39;qiangu2\u0026#39;) { console.log(\u0026#39;qianguyihao\u0026#39;); } ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/javascript%E5%BC%80%E5%8F%91%E7%A7%AF%E7%B4%AF/","summary":"方法的注释 方法写完之后（注意，一定要先写完整），我们在方法的前面输入/**，然后回车，会发现，注释的格式会自动补齐。 比如： 1 2 3 4 5 6 7 8 9","title":"JavaScript开发积累"},{"content":"AMD的基本语法 AMD的概念 AMD（Asynchronous Module Definition）：异步模块定义。AMD专门用于浏览器端，模块的加载是异步的。\nAMD规范：是 RequireJS 在推广过程中对模块化定义的规范化产出。\nRequireJS：一个基于AMD规范实现的模块化开发解决方案。\n暴露模块的方式 定义没有依赖的模块：（参数只有一个 function）\n1 2 3 4 5 define(function () { return 模块 }) 定义有依赖的模块：（参数有两个：模块名、function）\n1 2 3 4 5 6 //定义有依赖的模块：第一个参数为数组 define([\u0026#39;module1\u0026#39;, \u0026#39;module2\u0026#39;], function (m1, m2) { return 模块 }) 代码解释：\n第一个参数必须是数组，里面存放的是，需要依赖的其他的模块。\n第二个参数是function，里面带了形参 m1 和 m2，分别代表了 module1 和 module2。这个形参的作用是，前面依赖的模块一旦声明了，就可以一一对应地注入到 function中去，从而在 function 内部使用依赖的模块。这种方式称之为显式声明依赖注入。\n引入模块的方式 在主模块中引入其他的模块：\n1 2 3 4 5 6 //在主模块中引入其他的模块 require([\u0026#39;module1\u0026#39;, \u0026#39;module2\u0026#39;], function (m1, m2) { 使用m1 / m2 }) RequireJS：是AMD的实现 http://www.requirejs.org/\nhttp://www.ruanyifeng.com/blog/2012/11/require_js.html\nRequireJS的使用举例（自定义模块） 1、创建项目结构 在工程文件中新建如下目录：\n1 2 3 4 5 6 7 8 9 js | libs | modules | alerter.js | dataService.js | main.js index.html 所有的代码写完之后，项目结构如下：\n2、下载require.js，并导入 官网: http://requirejs.org/docs/download.html\nGitHub：https://github.com/requirejs/requirejs\n在官网下载require.js文件：\n然后将require.js文件拷贝到项目的js/libs/目录中。\n这样的话，就导入成功了。\n3、自定义模块 （1）dataService.js：\n1 2 3 4 5 6 7 8 9 10 //定义没有依赖的模块 define(function () { let name = \u0026#39;我是 dataService.js中的内容\u0026#39;; function getName() { return name; } //暴露模块 return { getName }; }); 这模块没有依赖。\n（2）alerter.js：\n1 2 3 4 5 6 7 8 9 10 11 12 //定义有依赖的模块 define([\u0026#39;myDataService\u0026#39;], function (dataService) { let msg = \u0026#39;我是 aleter.js中的内容\u0026#39;; function showMsg() { console.log(dataService.getName()); //调用了 myDataService 模块中的内容 console.log(msg); } //暴露模块 return { showMsg }; }); 这个模块，依赖了myDataService这个模块，模块名是我自己起的。稍后，我们会在main.js中做映射，将myDataService这个名字和dataService.js文件关联起来。\n（3）main.js：\n这个是主模块。\n1 2 3 4 5 6 7 8 9 10 11 requirejs.config({ //baseUrl: \u0026#39;js/\u0026#39;, //基本路径 paths: { //配置路径 myDataService: \u0026#39;./modules/dataService\u0026#39;, myAlerter: \u0026#39;./modules/alerter\u0026#39; } }); requirejs([\u0026#39;myAlerter\u0026#39;], function (alerter) { alerter.showMsg(); })(); 这个模块，依赖了myAlerter这个模块，模块名是我自己起的。并且，我们在文件的上方做了映射，将myAlerter这个名字和alerter.js文件关联了起来。\n我们来讲一下最上方的几行代码（即requirejs.config里的内容）的意思：\n我们可以看到，文件（3）依赖了文件（2），文件（2）依赖了文件（1）。\npaths里做的就是映射：将键myDataService和文件dataService.js进行关联，将键myAlerter和文件alerter.js进行关联。\n另外，再讲一下注释里的baseUrl的用法：如果没有这个注释，那么paths里的路径，是从当前这个文件（main.js）的角度出发的；如果加了一行baseUrl，表明它是 paths 里所有路径的最开头的部分，baseUrl的路径是从项目的根目录的角度出发的。\n（4）index.html：\n这个是入口文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 先通过 src 引入 require.js 文件，然后通过 data-main 引入主模块（main.js） --\u0026gt; \u0026lt;script data-main=\u0026#34;js/main.js\u0026#34; src=\u0026#34;js/libs/require.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意，上面的代码中，我们直接通过src属性引入requre.js 文件，一旦这个文件发挥作用了，会去找data-main属性里的指向，它正好指向的是主模块。\n有了上面这种引入的方式，我们就不用再老土地引入多个\u0026lt;script\u0026gt;标签了。\n运行 index.html，打印结果如下：\n项目源码：2018-04-11-RequireJSDemo\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/javascript%E6%A8%A1%E5%9D%97%E5%8C%96amd/","summary":"AMD的基本语法 AMD的概念 AMD（Asynchronous Module Definition）：异步模块定义。AMD专门用于浏览器端，模块的加载是异步","title":"JavaScript模块化：AMD"},{"content":"CMD的基本语法 CMD的概念 CMD（Common Module Definition）：同步模块定义。CMD专门用于浏览器端，模块的加载是同步的。模块在使用时才会加载执行。\nCMD规范：是 SeaJS 在推广过程中对模块化定义的规范化产出。\nSeaJS SeaJS：一个基于CMD规范实现的模块化开发解决方案。\n官网链接：\nhttp://seajs.org/\nhttps://github.com/seajs/seajs\n推荐学习链接：\nhttp://www.zhangxinxu.com/sp/seajs/\nhttp://es6.ruanyifeng.com/#docs/module\n暴露模块的方式 不管是定义没有依赖的模块，还是定义有依赖的模块，参数只有一个，那就是 function。\n定义没有依赖的模块：\n1 2 3 4 5 6 7 8 define(function (require, exports, module) { exports.xxx = value //暴露模块 module.exports = value }) 参数只有一个，那就是 function。function 里有三个参数：\n定义有依赖的模块：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //定义有依赖的模块 define(function (require, exports, module) { //引入依赖的模块(同步的方式) var module2 = require(\u0026#39;./module2\u0026#39;) //引入依赖的模块(异步的方式) require.async(\u0026#39;./module3\u0026#39;, function (m3) { }) //暴露模块 exports.xxx = value }) 上面的代码可以看到，在引入依赖的模块时，有两种引入的方式：同步和异步。\n引入模块的方式 1 2 3 4 5 6 7 8 define(function (require) { var m1 = require(\u0026#39;./module1\u0026#39;) var m4 = require(\u0026#39;./module4\u0026#39;) m1.show() m4.show() }) SeaJS的使用举例（自定义模块） 1、创建项目结构 在工程文件中新建如下目录：\n1 2 3 4 5 6 7 8 9 10 js | libs | sea.js | modules | module1.js | module2.js | module3.js | module4.js | main.js //主模块 index.html 2、下载SeaJS，并导入 官网: https://seajs.github.io/seajs/docs/#downloads\nGitHub：https://github.com/seajs/seajs\n在官网下载sea.js文件，然后将其拷贝到项目的js/libs/目录中。这样的话，就导入成功了。\n3、自定义模块 （1）module1.js：\n1 2 3 4 5 6 7 8 9 10 //定义没有依赖的模块 define(function (require, exports, module) { let name = \u0026#39;我是 module1 中的内容\u0026#39;; function foo1() { return name; } //暴露模块 module.exports = { foo1 }; //暴露出去的是 foo1这个函数对象 }); （2）module2.js：\n1 2 3 4 5 6 7 8 9 10 //定义没有依赖的模块 define(function (require, exports, module) { let name = \u0026#39;我是 module2 中的内容\u0026#39;; function foo2() { console.log(name); } //暴露模块 module.exports = foo2; //可以理解成：exports就是 foo2 这个函数 }); （3）module3.js:\n1 2 3 4 5 6 7 8 9 10 //定义没有依赖的模块 define(function (require,exports,module) { let data = \u0026#39;我是 module3 中的内容\u0026#39;; function foo3() { console.log(data); } //暴露模块 exports.module3 = { foo3 }; //可以理解成：给 export 对象暴露了 module3 这个属性，这个属性里有foo3 这个函数。 }); （4）module4.js：\n这个模块依赖了 module2 和 module3。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //定义有依赖的模块 define(function (require, exports, module) { let name = \u0026#39;我是 module4 中的内容\u0026#39;; //同步的方式引入 module2 let myModule2 = require(\u0026#39;./module2\u0026#39;); myModule2(); //异步的方式引入 module3 require.async(\u0026#39;./module3\u0026#39;, function (myModule3) { myModule3.module3.foo3(); }); function foo4() { console.log(name); } exports.foo4 = foo4; }) （5）main.js：\nmodule1.js没有依赖其他的模块，它是独立的\nmodule4.js依赖了module2和module3。\n因此，让main.js依赖module1.js和module4就够了。\nmain.js：\n1 2 3 4 5 6 7 8 9 10 11 12 //主模块（主模块不需要导出） define(function (require) { //导入 module1 let module1 = require(\u0026#39;./module1\u0026#39;); console.log(module1.foo1()); //执行foo1函数后，将返回值打印 //导入 module4 let module4 = require(\u0026#39;./module4\u0026#39;); module4.foo4(); }); （6）index.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 引入 sea.js库 --\u0026gt; \u0026lt;script src=\u0026#34;js/libs/sea.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; // 引入主模块 seajs.use(\u0026#39;./js/modules/main.js\u0026#39;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打印结果：\nothers SeaJS 的介绍 SeaJS：一个基于CMD规范实现的模块化开发解决方案。\n作者：Alibaba 玉伯。\n官网：http://seajs.org/\nGitHub：https://github.com/seajs/seajs\n现在官网变成了：https://seajs.github.io/seajs/docs/\n特性：\n简单友好的模块定义规范。\n自然直观的代码组织方式。\nRequireJS（AMD）、SeaJS（CDM）、CommonJS、ES6 的对比 1、RequireJS 和 AMD：\n异步模块定义，特点是依赖前置。\n2、SeaJS 和 CMD：\n同步模块定义。\n1 2 3 4 5 6 7 8 9 // 所有模块都通过 define 来定义 define(function(require, exports, module) { //通过 require 引入依赖 var $ require(`jquery`); var Spinning = require(`./spinning`); }) 3、CommonJS：\n以上三个都是 ES5里面的规范。\n4、ES6：\nES6的特性：export/import\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/javascript%E6%A8%A1%E5%9D%97%E5%8C%96cmd/","summary":"CMD的基本语法 CMD的概念 CMD（Common Module Definition）：同步模块定义。CMD专门用于浏览器端，模块的加载是同步的。模块在使","title":"JavaScript模块化：CMD"},{"content":"模块化开发的引入 JS开发的弊端 JS 在使用时存在两大问题，而 Node.js 可以很好地避免这两个问题：\n文件依赖。比如 a 文件依赖 b 文件，b 文件依赖 c 文件。而 Node.js 中的文件依赖，不需要人工维护和人为分析。\n命名冲突。js 的各个文件是相互开放的，容易导致命名冲突。而 Node.js 是属于半封闭的状态，可以指定哪些内容是开放的，哪些内容是封闭的。\nNode.js 在解决这两个问题时，用到的就是模块化开发。\n软件开发中的模块化开发 一个功能就是一个模块，多个模块可以组成完整的应用，抽离一个模块不会影响其他功能的运行。\n效果如下：\nNode.js 中的模块化开发 Node.js 规定，一个 JS 文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法访问。\n模块内部可以使用 exports 对象进行成员导出， 使用 require 方法导入其他模块。效果如下：\nES6模块化的基本语法 ES6模块化的说明 依赖模块需要编译打包处理。原因如下：\n（1）有些浏览器不支持 ES6 的语法，写完 ES6 的代码后，需要通过Babel将 ES6 转化为 ES5。\n（2）生成了ES5之后，里面仍然有require语法，而浏览器并不认识require这个关键字。此时，可以用 Browserify编译打包 js，进行再次转换。\n推荐学习链接：\nhttp://es6.ruanyifeng.com/#docs/module 基本语法： 导出模块：\n1 export 引入模块：\n1 import xxx from \u0026#39;路径\u0026#39; ES6模块化的使用举例（自定义模块） 1、初始化项目 （1）在工程文件中新建如下目录：\n1 2 3 4 5 6 7 8 9 js | src | module1.js | module2.js | module3.js | main.js index.html （2）在工程的根目录下，新建文件package.json，内容如下：\n1 2 3 4 { \u0026#34;name\u0026#34;: \u0026#34;es6-babel-browserify\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34; } 2、环境配置：安装babel 和 browserify等 （1）安装babel 和 browserify：\n1 2 3 4 5 npm install babel-cli -g npm install babel-preset-es2015 --save-dev npm install browserify -g 安装 babel 的详细解释，可以参考本人的另外一篇文章：ES6的介绍和环境配置\n（2）新建.babelrc：\n在根目录下新建文件.babelrc，输入如下内容：\n1 2 3 4 5 6 { \u0026#34;presets\u0026#34;:[ \u0026#34;es2015\u0026#34; ], \u0026#34;plugins\u0026#34;:[] } 3、编写代码 （1）module1.js：\n1 2 3 4 5 6 7 8 9 10 11 //暴露模块：采用分别暴露的方式 export function foo1() { console.log(\u0026#39;我是 module1 中的 foo1\u0026#39;); } export function foo2() { console.log(\u0026#39;我是 module2 中的 foo2\u0026#39;); } export let arr = [1, 2, 3, 4, 5]; （2）module2.js：\n1 2 3 4 5 6 7 8 9 10 11 12 //暴露模块：采用统一暴露的方式 function fn1() { console.log(\u0026#39;我是 module2 中的 fn1\u0026#39;); } function fn2() { console.log(\u0026#39;我是 module2 中的 fn2\u0026#39;); } //统一暴露 export { fn1, fn2 }; （3）module3.js：\n1 2 3 4 5 6 7 //暴露模块：采用默认暴露的方式。 //默认暴露的方式可以暴露任意数据类型，暴露的是什么数据，接收到的就是什么数据 //语法格式：export default value; export default () =\u0026gt; { console.log(\u0026#39;我是 module3 中 default 方式暴露的函数\u0026#39;); }; 这里，我们采取了一种新的暴露方式（默认暴露），在暴露时，加上了default这个关键字。代码里暴露了一个箭头函数，稍后，我们注意在main.js里是怎么引入module3.js的。\n注意，我们只能写一次 default，也就是说，只能进行一次默认暴露。\n（4）module4.js：（default方式暴露多个属性）\n1 2 3 4 5 6 7 8 9 10 //暴露模块：采用默认暴露的方式。 //默认暴露的方式可以暴露任意数据类型，暴露的是什么数据，接收到的就是什么数据 //语法格式：export default value; export default { name: \u0026#39;我是 module4 中 default 方式暴露的属性 name\u0026#39;, foo() { console.log(\u0026#39;我是 module4 中 default 方式暴露的函数 foo\u0026#39;); } } 这里，我们依旧采取了默认暴露的方式，只能写一次 default。代码里暴露了一个对象（对象里存放了一个属性、一个方法）。稍后，我们注意在main.js里是怎么引入module4.js的。\n如果我想暴露多个属性、多个对象怎呢？很简单，把你想要暴露的所有内容，都放在default里，包成一个对象。你看module4.js就是如此， 同时暴露了多个属性\u0026amp;方法。\n（5）main.js：\n这个是主模块。现在，我们来看一下，它如何引入上面的四个模块。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 //主模块。引入其他的模块 import { foo1, foo2 } from \u0026#39;./module1\u0026#39;; //采用解构赋值的形式进行导入。注意，括号里的对象名，要和 module1 中的对象名一致。 import { fn1, fn2 } from \u0026#39;./module2\u0026#39;; //采用解构赋值的形式进行导入。注意，括号里的对象名，要和 module2 中的对象名一致。 import myModule3 from \u0026#39;./module3\u0026#39;; //module3 模块是采用 default 方式进行暴露的，myModule3 这个名字是我随便起的 import myModule4 from \u0026#39;./module4\u0026#39;; //module4 模块是采用 default 方式进行暴露的，myModule4 这个名字是我随便起的 //调用module1、module2中的内容 foo1(); foo2(); fn1(); fn2(); //调用module3中的内容 myModule3(); //调用module4中的内容 console.log(myModule4.name); //module4中的属性 myModule4.foo(); //module4中的方法 我们可以看出：（具体请看注释，非常重要）\nmodule1和module2是采用常规暴露的形式，在引入它们时，模块名要一致。而且，要求用对象解构赋值的形式，而不是用 import myModule from ...这种形式（否则会报错 undefined）。\nmodule2和module3是采用默认暴露的形式，在引入它们时，模块名随便起。\n（6）index.html：\n在这里引入main.js即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script src=\u0026#34;dist/main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4、编译转换 如果我们不进行转换，而是直接在 index.html 中加载 js/src/main.js，是会报错的：\n接下来，我们就进行转换。\n（1）利用 babel 将 ES6 转换为 ES5：\n1 babel src -d build //build目录会自动生成 上方命令的意思是，将src目录下的所有ES6文件转化为ES5文件，并放在build目录下（build目录会被自动创建）。\n转化成ES5之后，我们发现，如果直接在 index.html 中加载build目录下的ES5文件，也是会报错的，因为浏览器不认识main.js里的require关键字：\n于是，我们还要进行一次转换。\n（2）利用Browserify编译打包 build目录下的 ES5 文件：\n1 browserify build/main.js -o dist/main.js //dist目录需要手动创建 dist/main.js就是我们需要引入到 index.html 里的文件。\n以后，我们每次修改完ES6的代码，就要执行上面的两个命令，重新生成新的js文件。\n运行效果：\n工程文件：\n2018-04-13-ES6Demo.rar ES6模块化的使用举例（引入第三方模块） 下载 jQuery 包：\n1 npm install jquery@1 //下载jQuery 1.X 的版本里最新的 在main.js 中引入上面的 jQuery：\n1 import $ from \u0026#39;jQuery\u0026#39;; 然后我们就可以通过$这个符号去写jQuery的代码了。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/javascript%E6%A8%A1%E5%9D%97%E5%8C%96es6/","summary":"模块化开发的引入 JS开发的弊端 JS 在使用时存在两大问题，而 Node.js 可以很好地避免这两个问题： 文件依赖。比如 a 文件依赖 b 文件，b 文件依赖 c 文件。而 Node.js 中","title":"JavaScript模块化：ES6"},{"content":" 本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。\n以下是正文。\nCSS 预处理器 为什么要有 CSS 预处理器 CSS基本上是设计师的工具，不是程序员的工具。在程序员的眼里，CSS是很头痛的事情，它并不像其它程序语言，比如说PHP、Javascript等等，有自己的变量、常量、条件语句以及一些编程语法，只是一行行单纯的属性描述，写起来相当的费事，而且代码难以组织和维护。\n很自然的，有人就开始在想，能不能给CSS像其他程序语言一样，加入一些编程元素，让CSS能像其他程序语言一样可以做一些预定的处理。这样一来，就有了“CSS预处器（CSS Preprocessor）”。\n什么是 CSS 预处理器 是 CSS 语言的超集，比CSS更丰满。 CSS 预处理器定义了一种新的语言，其基本思想是：用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。\n通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。\nCSS预处理器技术已经非常成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：Sass（SCSS）、LESS、Stylus、Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、CSS-Trick、知乎以及各大技术论坛上，很多人为此争论不休。相比过去我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。\n到目前为止，在众多优秀的CSS预处理器语言中就属Sass、LESS和Stylus最优秀，讨论的也多，对比的也多。本文将分别从他们产生的背景、安装、使用语法、异同等几个对比之处向你介绍这三款CSS预处理器语言。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器。\nless 的介绍 less 是一款比较流行的预处理 CSS，支持变量、混合、函数、嵌套、循环等特点。\n官网\n中文网（less 文档）\nBootstrap网站的 less 文档\n推荐文章：http://www.w3cplus.com/css/less\nless 的语法 注释 less 的注释可以有两种。\n第一种注释：模板注释\n1 // 模板注释 这里的注释转换成CSS后将会删除 因为 less 要转换为 css才能在浏览器中使用。转换成 css 之后，这种注释会被删除（毕竟 css 不识别这种注释）。\n第二种注释：CSS 注释语法\n1 2 /* CSS 注释语法 转换为CSS后让然保留 */ 总结：如果在less中写注释，我们推荐写第一种注释。除非是类似于版权等内容，就采用第二种注释。\n定义变量 我们可以把重复使用或经常修改的值定义为变量，在需要使用的地方引用这个变量即可。这样可以避免很多重复的工作量。\n（1）在less文件中，定义一个变量的格式：\n1 2 3 @变量名: 变量值; //格式 @bgColor: #f5f5f5; //格式举例 （2）同时，在 less 文件中引用这个变量。\n最终，less文件的完整版代码如下：\nmain.less：\n1 2 3 4 5 6 7 // 定义变量 @bgColor: #f5f5f5; // 引用变量 body{ background-color: @bgColor; } 我们将上面的less文件编译为 css 文件后（下一段讲less文件的编译），自动生成的代码如下：\nmain.css：\n1 2 3 body{ background-color: #f5f5f5; } 使用嵌套 在 css 中经常会用到子代选择器，效果可能是这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 .container { width: 1024px; } .container \u0026gt; .row { height: 100%; } .container \u0026gt; .row a { color: #f40; } .container \u0026gt; .row a:hover { color: #f50; } 上面的代码嵌套了很多层，写起来很繁琐。可如果用 less 的嵌套语法来写这段代码，就比较简洁。\n嵌套的举例如下：\nmain.less:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 .container { width: @containerWidth; \u0026gt; .row { height: 100%; a { color: #f40; \u0026amp;:hover { color: #f50; } } } div { width: 100px; .hello { background-color: #00f; } } } 将上面的less文件编译为 css 文件后，自动生成的代码如下：\nmain.css\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 .container { width: 1024px; } .container \u0026gt; .row { height: 100%; } .container \u0026gt; .row a { color: #f40; } .container \u0026gt; .row a:hover { color: #f50; } .container div { width: 100px; } .container div .hello { background-color: #00f; } Mixin Mixin 的作用是把重复的代码放到一个类当中，每次只要引用类名，就可以引用到里面的代码了，非常方便。\n（1）在 less 文件中定义一个类：（将重复的代码放到自定义的类中）\n1 2 3 4 5 6 /* 定义一个类 */ .roundedCorners(@radius: 5px) { -moz-border-radius: @radius; -webkit-border-radius: @radius; border-radius: @radius; } 上方代码中，第一行里面，括号里的内容是参数：这个参数是缺省值。\n（2）在 less 文件中引用上面这个类：\n1 2 3 4 5 6 #header { .roundedCorners; } #footer { .roundedCorners(10px); } 上方代码中，header 中的引用没有带参数，表示参数为缺省值； footer 中的引用带了参数，那就用这个参数。\nImport 在开发阶段，我们可以将不同的样式放到多个文件中，最后通过@import 的方式合并。意思就是，当出现多个 less 文件时，怎么引用它们。\n这个很好理解， css 文件可以有很多个，less文件也可以有很多个。\n（1）定义一个被引用的less文件，名为_button1.less：\n_button1.less:\n1 2 3 4 .btn{ line-height: 100px; color: @btnColor; } PS1：被引用的less文件，我们习惯在前面加下划线，表示它是部分文件。\nPS2：_button1.less里可以引用main.css里的自定义变量。\n（2）在 main.css 中引用上面的 _button1.less：（代码的第二行）\nmain.css：\n1 2 3 4 5 6 7 @btnColor: red; @import url(`_button1.less:\u0026#39;); //这里的路径写的是相对路径 body{ width: 1024px; } 将 上面的main.less 编译为 main.css之后，自动生成的代码如下：\n1 2 3 4 5 6 7 8 .btn { line-height: 100px; color: red; } body { width: 1024px; } 内置函数 less 里有一些内置的函数，这里讲一下 lighten 和 darken 这两个内置函数。\nmain.less:\n1 2 3 4 body { background-color: lighten(#000, 10%); // 让黑色变亮 10% color: darken(#fff, 10%); // 让白色变暗 10% } 将 上面的 main.less 编译为 main.css 之后，自动生成的代码如下：\nmain.css：\n1 2 3 4 body { background-color: #1a1a1a; color: #e6e6e6; } 如果还有什么不懂的，可以看 api 文档，在上面的第二段附上了链接。\n在 index.html中直接引用 less.js 做法一：写完 less文件后，将其编译为 css 文件，然后在代码中引用css文件。\n做法二：在代码中直接用引用 less 文件。\n产品上线后，当然是使用做法一，因为做法二会多出编译的时间。\n平时开发或演示demo的时候可以用做法二。\n这一段，我们讲一下做法二，其实是浏览器在本地在线地把 less 文件转换为 css 文件。\n（1）在 less 官网下载 less.js 文件：\n把下载好的文件放在工程文件的lib文件夹里：\n（2）在 index.html 中引入 less.js 和我们自己写的 main.less。位置如下：\ncopy 红框那部分的代码如下：\n1 \u0026lt;link rel=\u0026#34;stylesheet/less\u0026#34; href=\u0026#34;../main.less\u0026#34;\u0026gt; 我们可以在打开的网页中，通过控制台看到效果：\n注意，我们要在服务器中打开 html 文件，否则，看不到效果。\n这里也告诉了我们：\n不提倡将 less 引入页面，因为 less 需要编译，因此你就需要再引入一个less.js, 多了一个HTTP 请求，同时当浏览器禁用了 js 你的样式就不起作用了，less 编译应该在服务端或使用 grunt 自动编译。\n工程文件：（工程文件中，我引用的less.js版本是 2.5.3）\n2018-02-27-LessDemo.rar 参考链接：\n知乎 | less文件如何引入页面 less 的编译 less 的编译指的是将写好的 less 文件 生成为 css 文件。\nless 的编译，依赖于 NodeJS 环境。因此，我们需要先安装 NodeJS。\n1、安装 Node.js 去 Node.js的官网下载安装包：\n一路 next 进行安装。\n安装完成后，配置环境变量：\n在 path 变量中追加安装路径：;C:\\Program Files\\nodejs。重启资源管理器，即可生效。\nPS：我发现，我安装的 node.js v8.9.4 版本，已经自动添加了环境变量。\n在 cmd 命令行，输入node.exe -v，可以查看 node.js 的版本。\n2、安装 less 的编译环境 将 npm.zip 解压，将解压后的文件拷贝到路径C:\\Users\\smyhvae\\AppData\\Roaming\\npm下：\n然后重启资源管理器（或者重启电脑）。在 cmd 中输入 lessc，如果能看到下面的效果，说明 less编译环境安装成功：\n如果你用的是 linux 系统，可以输入下面的命令安装：\n1 npm install -g less 3、将 less 文件编译为 css 文件 在 less 所在的路径下，输入 lessc xxx.less，即可编译成功。或者，如果输入 lessc xxx.less \u0026gt; ..\\xx.css，表示输出到指定路径。\n","permalink":"https://bablvsj.github.io/posts/interview/css/03-less%E8%AF%A6%E8%A7%A3/","summary":"本文最初发表于博客园，并在GitHub上持续更新前端的系列文章。欢迎在GitHub上关注我，一起入门和进阶前端。 以下是正文。 CSS 预处理器 为什么","title":"Less详解"},{"content":"浏览器本地存储\n在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的 web storage和cookie的区别\nWeb Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用 除此之外，WebStorage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 cookie 和session 的区别：\n1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗\n考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能\n考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n5、所以个人建议：\n将登陆信息等重要信息存放为SESSION\n其他信息如果需要保留，可以放在COOKIE中\n描述 cookies、sessionStorage 和 localStorage 的区别？\n与服务器交互：\ncookie 是网站为了标示用户身份而储存在用户本地终端上的数据（通常经过加密） cookie 始终会在同源 http 请求头中携带（即使不需要），在浏览器和服务器间来回传递 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存 存储大小：\ncookie 数据根据不同浏览器限制，大小一般不能超过 4k sessionStorage 和 localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据 sessionStorage 数据在当前浏览器窗口关闭后自动删除 cookie 设置的cookie过期时间之前一直有效，与浏览器是否关闭无关 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/localstorage/","summary":"浏览器本地存储 在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localSto","title":"localStorage"},{"content":"MySQL 的一些简单命令 我们可以在 Navicat Premium 软件中，创建数据库和表，然后输入查询命令来查询数据。选择菜单栏「查询-\u0026gt;新建查询-\u0026gt;输入 sql 命令-\u0026gt;运行」即可，效果如下：\n我们还可以直接在终端输入命令行来操作。\n注意，在 Mac 终端执行 sql 命令时，命令的末尾必须加上;（英文格式的分号）。效果如下：\nMySQL 命令行的一些简单命令如下。\n以 root 身份进入命令行：\n1 mysql -u root -p 查看有哪些数据库：\n1 show databases; 选择进入指定的数据库：\n1 2 3 4 use xxx_database; # 举例 use qianguyihao_database; 在当前数据库中，查看有哪些表：\n1 show tables; 在当前数据库中，查询指定表的全部数据：\n1 2 3 4 SELECT * FROM xxx_table; # 举例 SELECT * FROM qianguyihao_student_table 删除指定的表：\n1 2 3 4 drop table xxx; # 举例 drop table qianguyihao_student_table; 删除指定的数据库：\n1 drop database qianguyihao_student_table; 创建一个数据库：\n1 create database qianguyihao_database2; where 条件查询 使用 where 子句可以对表中的数据进行筛选，结果为 true 的行会出现在查询结果中。\n语法格式如下：\n1 SELECT * FROM 表名 where 条件; 上面的语法格式中，条件 具体要怎么写呢？这个可能有很多种情况。我们继续往下看。\n比较运算符 = 等于 \u0026gt; 大于 \u0026gt;= 大于等于 \u0026lt; 小于 \u0026lt;= 小于等于 !=：不等于 age \u0026gt; 20：查询 age 大于 30 的数据 举例：\n1 2 # 查询 age 大于 20 的数据 SELECT * FROM qianguyihao_table WHERE age \u0026gt; 20; 逻辑运算符 AND\nOR\nNOT\n举例：\n1 2 # 查询 age 在20至30之间的数据 SELECT * FROM qianguyihao_table WHERE age BETWEEN 20 AND 30; 范围查询 in 表示在一个非连续的范围内。\nbetween ... and ... 表示在一个连续的范围内\n举例：\n1 2 3 4 # 查询 name 为 lvbu 或者 许嵩的数据 SELECT * FROM qianguyihao_table WHERE name IN [\u0026#39;lvbu\u0026#39;, \u0026#39;许嵩\u0026#39;]; SELECT * FROM qianguyihao_table WHERE age BETWEEN 20 AND 30; 模糊查询 like % 表示任意多个任意字符 _ 表示一个任意字符 % 符号举例：\n1 2 3 4 5 # 查询标题中包含“前端”这两个字的数据（“前端”这两个字的前后可能都有内容） select * from qianguyihao_table where `title` like \u0026#34;%前端%\u0026#34;; # 查询标题以“前端”开头的数据 select * from qianguyihao_table where `title` like \u0026#34;前端%\u0026#34;; _符号举例：\n1 2 # 查询标题，查询条件是：标题中至少有五个字符，而且，这五个字符中，前两个字符一定是“千古”开头的。 SELECT * FROM qianguyihao_table WHERE `title` LIKE \u0026#34;千古___\u0026#34;; NULL 的判断 is null 判断为空\nis not null 判断为非空\n注意，is null 和空字符串\u0026quot;\u0026quot; 是有区别的。学过 js 基础之后，你应该知道：空字符串并非 null，只不过是里面的值为空而已；空字符串也是会占有内存空间的。\n举例：\n1 select * from qianguyihao_table where name is not NULL; join 联表查询 联表查询命令 tableA inner join tableB：表 A 与表 B 匹配的行会出现在结果中。\ntableA left join tableB：表 A 与表 B 匹配的行会出现在结果中。表 A 中独有的数据，对应表 B 中用 null 填充。\ntableA right join tableB：表 A 与表 B 匹配的行会出现在结果中。表 B 中独有的数据，对应表 A 中用 null 填充。\n光是这样看，不好理解，我们来举个例子。\n举例 现在有下面这两张表：作者表 author、图书表 book。\n表 1、作者表 author：\nid authorId authorName 1 11 王小波 2 12 吴军 3 88 lvbu 表 2、图书表 book：\nid bookId bookName authorId 1 201 黄金时代 11 2 202 白银时代 11 3 203 青铜时代 11 4 204 浪潮之巅 12 5 205 硅谷之谜 12 6 206 数学之美 12 7 777 设计心理学 99 注意，表2中的每本图书都有对应的 authorId，这个 authorId 就是对应表1中的 authorId。通过 authorId 把两张表关联起来。\n通过联表查询上面的两张表，我们来对比一下查询结果。\n情况 0：（inner join）\n1 SELECT * FROM author INNER JOIN book; 查询结果：\n上面这种查询，没有意义，因为没有加任何查询条件。\n情况 1：（inner join）\n1 SELECT * FROM author INNER JOIN book ON author.authorId = book.authorId; 查询结果：\n上面这行命令，跟下面这行命令等价：\n1 SELECT * FROM author, book WHERE author.authorId = book.authorId; 情况 2：（left join）\n1 SELECT * FROM author LEFT JOIN book ON author.authorId = book.authorId; 查询结果：\n情况 3：（right join）\n1 SELECT * FROM author RIGHT JOIN book ON author.authorId = book.authorId; 查询结果：\n参考链接 Mysql 联表查询 自关联查询 涉及到层级关系时可以用自关联查询。\n子查询 当一个查询结果是另一个查询的条件时，这个查询称之为子查询。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","summary":"MySQL 的一些简单命令 我们可以在 Navicat Premium 软件中，创建数据库和表，然后输入查询命令来查询数据。选择菜单栏「查询-\u0026gt;新建查询-\u0026gt;输入 sql 命令-\u0026","title":"MySQL数据库的常用命令"},{"content":"前言 范式即规范。MySQL 范式的作用是：\n让我们建的表更佳简洁和高效。\n让功能独立化，避免耦合。\nMySQL 设计三大范式 第一范式（1NF）：原子性 表的每一列具有原子性，不可再分。\n第二范式：唯一性 第二范式是建立在第一范式基础上的；外要求所有非主键字段必须完全依赖主键，而不是部分依赖。\n第三范式 第三范式是建立在第二范式基础上的；且要求没有传递依赖。\n参考链接 MySql\u0026ndash;数据库设计三范式 ","permalink":"https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E8%AE%BE%E8%AE%A1%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F/","summary":"前言 范式即规范。MySQL 范式的作用是： 让我们建的表更佳简洁和高效。 让功能独立化，避免耦合。 MySQL 设计三大范式 第一范式（1NF）：原子性 表的每一","title":"MySQL设计三大范式"},{"content":"在 Node.js 上建一个 http 服务器 （1）新建一个文件 server01.js，然后在里面输入如下代码：\n1 2 3 4 5 6 7 8 9 10 const http = require(\u0026#39;http\u0026#39;); //引入 node.js里面的一个http包。因为引入之后，我们不会去修改它，所以用常量来表示 // 创建一台服务器 var server = http.createServer(function (){ //当有人来访问这台服务器时，就会执行 function 回调函数 console.log(\u0026#39;有人来访问我了\u0026#39;); }); server.listen(8080); //要让服务器设置为监听状态，端口设置为8080 注意看注释。\n我们把上面这个 js 文件跑起来，然后在浏览器端输入http://localhost:8080/，每请求一次，服务器的控制台就会打印 有人来访问我了。\n（2）write()函数和 end()函数：\n将上面的代码修改如下：\nserver02.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 const http = require(\u0026#39;http\u0026#39;); // 创建一台服务器 var server = http.createServer(function (request, response) { //当有人来访问这个服务器时，就会执行function 这个回调函数 console.log(\u0026#39;有人来访问我了\u0026#39;); response.write(\u0026#39;smyhvae\u0026#39;); //向浏览器输出内容 response.end(); //结束了，浏览器你走吧。 }); server.listen(8080); function 回调函数里可以设置两个参数：request 和 response。response.write()表示向浏览器输出一些内容。\n将上面的 js 代码跑起来，产生的问题是，无论我们在浏览器端输入http://localhost:8080/1.html，还是输入http://localhost:8080/2.jpg，浏览器上显示的都是smyhvae。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/node.js%E4%BB%A3%E7%A0%81%E4%B8%BE%E4%BE%8B/","summary":"在 Node.js 上建一个 http 服务器 （1）新建一个文件 server01.js，然后在里面输入如下代码： 1 2 3 4 5 6 7 8 9 10 const http = require(\u0026#39;http\u0026#39;); //引入 node.js里面","title":"Node.js代码举例"},{"content":"1、姓名组件 hello lvsijun ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //组件名称必须以大写字母开头。React 会将以小写字母开头的组件视为原生 DOM 标签 //例如，\u0026lt;div /\u0026gt; 代表 HTML 的 div 标签，而 \u0026lt;Welcome /\u0026gt; 则代表一个组件，并且需在作用域内使用 Welcome。 function FormatName(user) { return \u0026lt;h1\u0026gt;Hello , {user.firstName}{user.lastName} !\u0026lt;/h1\u0026gt; } function tick() { const element = ( \u0026lt;div\u0026gt; \u0026lt;FormatName firstName=\u0026#34;Lv\u0026#34; lastName=\u0026#34;SiJun\u0026#34; /\u0026gt; \u0026lt;h2\u0026gt;It is {new Date().toLocaleTimeString()}.\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ); ReactDOM.render(element, document.getElementById(\u0026#39;root\u0026#39;)); } setInterval(tick, 1000); 2、封装嵌套个人信息组件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 function Comment(props) { return ( \u0026lt;div className=\u0026#34;Comment\u0026#34;\u0026gt; \u0026lt;div className=\u0026#34;UserInfo\u0026#34;\u0026gt; \u0026lt;img className=\u0026#34;Avatar\u0026#34; src={props.author.avatarUrl} alt={props.author.name} /\u0026gt; \u0026lt;div className=\u0026#34;UserInfo-name\u0026#34;\u0026gt; {props.author.name} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;Comment-text\u0026#34;\u0026gt; {props.text} \u0026lt;/div\u0026gt; \u0026lt;div className=\u0026#34;Comment-date\u0026#34;\u0026gt; {formatDate(props.date)} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } function Comment(props) { return ( \u0026lt;div className=\u0026#34;Comment\u0026#34;\u0026gt; \u0026lt;UserInfo user={props.author}/\u0026gt; \u0026lt;div className=\u0026#34;Comment-text\u0026#34;\u0026gt; {props.text} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } function Avatar(props) { return ( \u0026lt;img className=\u0026#34;Avatar\u0026#34; src={props.user.avatarUrl} alt={props.user.name} /\u0026gt; ); } function UserInfo(props) { return ( \u0026lt;div className=\u0026#34;UserInfo\u0026#34;\u0026gt; \u0026lt;Avatar user={props.user} /\u0026gt; \u0026lt;div className=\u0026#34;UserInfo-name\u0026#34;\u0026gt; {props.user.name} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; ); } 3、class封装clock组件 开始使用state 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Clock extends React.Component{ constructor(props) { super(props); this.state = {date: new Date()}; } componentDidMount(){ //组件初始化之后 this.timerClock = setInterval(()=\u0026gt; this.tick() ,1000) } componentWillUnmount(){//组件销毁前 clearInterval(this.timerClock) } tick() { this.setState({ date: new Date() }); } render(){ return \u0026lt;h2\u0026gt;It is {this.state.date.toLocaleTimeString()}.\u0026lt;/h2\u0026gt;; } } 正确地使用 State 关于 setState() 你应该了解三件事： 不要直接修改 State 例如，此代码不会重新渲染组件： // Wrong this.state.comment = \u0026#39;Hello\u0026#39;; 而是应该使用 setState(): // Correct this.setState({comment: \u0026#39;Hello\u0026#39;}); 构造函数是唯一可以给 this.state 赋值的地方： 4、组件添加点击事件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Taggle extends React.Component{ constructor(props) { super(props); this.state = {isToggleOn: true}; // 为了在回调中使用 `this`，这个绑定是必不可少的 // this.handleClick = this.handleClick.bind(this); } handleClick() { console.log(\u0026#39;this is:\u0026#39;, this); this.setState(state =\u0026gt; ({ isToggleOn: !state.isToggleOn })); } render(){ return ( // this.handleClick.bind(this) // (e) =\u0026gt; this.handleClick(e) \u0026lt;button onClick={(e) =\u0026gt; this.handleClick(e)}\u0026gt; {this.state.isToggleOn ? \u0026#39;ON\u0026#39; : \u0026#39;OFF\u0026#39;} \u0026lt;/button\u0026gt; ) } } 5、条件判断 登录退出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 function IsLogin(props){ if(props.isLoggedIn){ return \u0026lt;h1\u0026gt;Wellcome Back !\u0026lt;/h1\u0026gt; }else{ return \u0026lt;h2\u0026gt;Give Me Five !\u0026lt;/h2\u0026gt; } } function LogoutButton(props){ return (\u0026lt;button onClick={props.onClick}\u0026gt; Logout \u0026lt;/button\u0026gt;) } function LoginButton(props){ return (\u0026lt;button onClick={props.onClick}\u0026gt; LoginButton \u0026lt;/button\u0026gt;) } class LoginControl extends React.Component{ constructor(props){ super(props); this.state= {isLoggedIn:false} } handleLoginClick(){ this.setState({isLoggedIn: true}); } handleLogoutClick(){ this.setState({ isLoggedIn:false }) } render(){ const isLoggedIn = this.state.isLoggedIn; let button; if (isLoggedIn) { button = \u0026lt;LogoutButton onClick={this.handleLogoutClick.bind(this)} /\u0026gt;; } else { button = \u0026lt;LoginButton onClick={(e)=\u0026gt;this.handleLoginClick(e)} /\u0026gt;; } return ( \u0026lt;div\u0026gt; {button} \u0026lt;IsLogin isLoggedIn={isLoggedIn} /\u0026gt; \u0026lt;/div\u0026gt; ) } } 自上而下或者自下而上构建应用：\n自上而下 意味着首先编写层级较高的组件（比如 FilterableProductTable），适用于简单应用。\n自下而上 意味着从最基本的组件开始编写（比如 ProductRow）。适用较为大型项目，同时为低层组件编写测试是更加简单的方式。\n","permalink":"https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/react/","summary":"1、姓名组件 hello lvsijun ! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //组件名称必须以大写字母开头。React 会将以小写字母开头的组件视为原生 DOM 标签 //例如","title":"react"},{"content":"前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可 语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页 重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取 重要内容不要用js输出：爬虫不会执行js获取内容 少用iframe：搜索引擎不会抓取iframe中的内容 非装饰性图片必须加alt 提高网站速度：网站速度是搜索引擎排序的一个重要指标 如何做SEO优化?\n标题与关键词 设置有吸引力切合实际的标题，标题中要包含所做的关键词 网站结构目录 最好不要超过三级，每级有“面包屑导航”，使网站成树状结构分布 页面元素 给图片标注\u0026quot;Alt\u0026quot;可以让搜索引擎更友好的收录 网站内容 每个月每天有规律的更新网站的内容，会使搜索引擎更加喜欢 友情链接 对方一定要是正规网站，每天有专业的团队或者个人维护更新 内链的布置 使网站形成类似蜘蛛网的结构，不会出现单独连接的页面或链接 流量分析 通过统计工具(百度统计，CNZZ)分析流量来源，指导下一步的SEO ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/seo/","summary":"前端需要注意哪些SEO 合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要","title":"SEO"},{"content":"this this的作用 this可以帮我们简化很多代码。比如xiaoming.name、xiaoming.age可以直接写成this.name、this.age。\n特别是当我们不知道一个对象是什么，或者这个对象没有名字但又很想调用它的时候，就会使用到this对象。\n举例：\n遍历DOM对象，绑定click事件，调用当前点击的对象的id，而不是所有对象的id。 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; div { width: 100px; height: 100px; background-color: green; margin: 10px; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.onload = function () { var myDiv = document.getElementsByTagName(\u0026#39;div\u0026#39;); for (var i = 0; i \u0026lt; myDiv.length; i++) { myDiv[i].onclick = function () { console.log(i); console.log(this.id); } } } \u0026lt;/script\u0026gt; \u0026lt;section\u0026gt; \u0026lt;div id=\u0026#34;div0\u0026#34;\u0026gt; div0\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div1\u0026#34;\u0026gt; div1\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div2\u0026#34;\u0026gt; div2\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div3\u0026#34;\u0026gt; div3\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026#34;div4\u0026#34;\u0026gt; div4\u0026lt;/div\u0026gt; \u0026lt;/section\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 点击其中的任何一个元素后，i的打印结果是5。你可能会觉得很惊讶。我们来解释一下：\n当代码执行完毕后，i已经等于5了。因为一旦运行程序，for循环已经执行完了，此时i等于5。\n现在，我们尝试在 myDiv[i].onclick事件中写代码，如果打印：\n1 console.log(i); //打印结果为5 如果打印：\n1 console.log(myDiv[i].id); 上方这行代码，打印会报错，因为i=5；如果想打印每个div的id，应该这样写：\n1 console.log(this.id); 你看，this的作用，就体现出来了。\nPS：顺便提醒一下，上面的代码中，如果把var i改成let i，效果又完全不同了。参考链接：let和var在for循环中的表现\n全局作用域中的this 当一段代码在浏览器中执行时，所有的全局变量和对象都是在window对象上定义的。换而言之，所有的全局变量和对象都属于window对象。\nthis的定律 this关键字永远指向函数（方法）运行时的所有者。\n函数赋值给变量时，this指向window 比如：\n1 2 3 4 5 var foo1 = args.getInfo; foo1(); var foo2 = function(){}; foo2(); this都是指向window。\n以函数形式调用时，this永远都是window 以方法的形式调用时，this是调用方法的对象 解决闭包中的this指向问题 内部函数是可以访问到外部函数的变量的。\n方式一：直接通过父函数的名字访问\n方式二：如果不知道父函数的名字，在父函数里加一句_this = this，此时_this相当于父函数的名字。\n当this遇到一些特殊的函数时 ","permalink":"https://bablvsj.github.io/posts/tech/wait/04-javascript/this/","summary":"this this的作用 this可以帮我们简化很多代码。比如xiaoming.name、xiaoming.age可以直接写成this.name、th","title":"this"},{"content":"快捷键\n作用 IDEA 快捷键 VS Code 备注 复制当前行 Ctrl + D Shift + Alt + ↑↓ 使用很频繁 当前文件搜索 Ctrl + R Ctrl + F 非常实用 全局搜索内容 Ctrl + Shift + R Ctrl + Shift + F 不如上面的快捷键快 全局搜索文件 双击Shift / 格式化代码 Ctrl + Alt + L Shift + Alt + F ​\n前言 VS Code 软件实在是太酷、太好用了，越来越多的新生代互联网青年正在使用它。\n前端男神尤雨溪大大这样评价 VS Code：\n有一点你可能会感到惊讶：VS Code 这款软件本身，是用 JavaScript 语言编写的（具体请自行查阅基于 JS 的 PC 客户端开发框架 Electron）。Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：\n任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。\nJeff Atwood 这个人是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n前端目前是处在春秋战国时代，各路英雄豪杰成为后浪，各种框架工具层出不穷，VS Code 软件无疑是大前端时代最骄傲的工具。\n如果你是做前端开发（JavaScript 编程语言为主），则完全可以将 VS Code 作为「主力开发工具」。这款软件是为前端同学量身定制的。\n如果你是做其他语言方向的开发，并且不需要太复杂的集成开发环境，那么，你可以把 VS Code 作为「代码编辑器」来使用，纵享丝滑。\n甚至是一些写文档、写作的同学，也经常把 VS Code 作为 markdown 写作工具，毫无违和感。\n退而求其次，即便你不属于以上任何范畴，你还可以把 VS Code 当作最简单的文本编辑器来使用，完胜 Windows 系统自带的记事本。\n写下这篇文章，是顺势而为。\n一、VS Code 的介绍 VS Code 的全称是 Visual Studio Code，是一款开源的、免费的、跨平台的、高性能的、轻量级的代码编辑器。它在性能、语言支持、开源社区方面，都做得很不错。\n微软有两种软件：一种是 VS Code，一种是其他软件。\nIDE 与 编辑器的对比 IDE 和编辑器是有区别的：\nIDE（Integrated Development Environment，集成开发环境）：对代码有较好的智能提示和相互跳转，同时侧重于工程项目，对项目的开发、调试工作有较好的图像化界面的支持，因此比较笨重。比如 Eclipse 的定位就是 IDE。\n编辑器：要相对轻量许多，侧重于文本的编辑。比如 Sublime Text 的定位就是编辑器。再比如 Windows 系统自带的「记事本」就是最简单的编辑器。\n需要注意的是，VS Code 的定位是编辑器，而非 IDE ，但 VS Code 又比一般的编辑器的功能要丰富许多。可以这样理解：VS Code 的体量是介于编辑器和 IDE 之间。\nVS Code 的特点 VS Code 的使命，是让开发者在编辑器里拥有 IDE 那样的开发体验，比如代码的智能提示、语法检查、图形化的调试工具、插件扩展、版本管理等。\n跨平台支持 MacOS、Windows 和 Linux 等多个平台。\nVS Code 的源代码以 MIT 协议开源。\n支持第三方插件，功能强大，生态系统完善。\nVS Code 自带了 JavaScript、TypeScript 和 Node.js 的支持。也就是说，你在书写 JS 和 TS 时，是自带智能提示的。当然，其他的语言，你可以安装相应的扩展包插件，也会有智能提示。\n前端利器之争： VS Code 与 WebStorm 前端小白最喜欢问的一个问题是：哪个编辑器/IDE 好用？是 VS Code 还是 WebStorm （WebStorm 其实是 IntelliJ IDEA 的定制版）？我来做个对比：\n哪个更酷：显然 VS Code 更酷。\n内存占用情况：根据我的观察，VS Code 是很占内存的（尤其是当你打开多个窗口的时候），但如果你的内存条够用，使用起来是不会有任何卡顿的感觉的。相比之下，IntelliJ IDEA 不仅非常占内存，而且还非常卡顿。如果你想换个既轻量级、又不占内存的编辑器，最好还是使用「Sublime Text」编辑器。\n使用比例：当然是 VS Code 更胜一筹。先不说别的，我就拿数据说话，我目前所在的研发团队有 200 人左右（120个后台、80个前端），他们绝大部分人都在用 VS Code 编码，妥妥的。\n所以，如果你以后还问这个问题，那就真有些掉底了。\nVS Code 的安装 VS Code 官网：https://code.visualstudio.com 二、崭露锋芒：VS Code 快捷键 VS Code 用得熟不熟，首先就看你是否会用快捷键。以下列出的内容，都是常用快捷键，而加粗部分的快捷键，使用频率则非常高。\n任何工具，掌握 20%的技能，足矣应对 80% 的工作。既然如此，你可能会问：那就只保留 20% 的特性，不久可以满足 80%的用户了吗？\n但我想说的是：那从来都不是同样的 20%，每个人都会用到不同的功能。\n掌握下面这些高频核心快捷键，你和你的工具，足矣露出锋芒。\n1、工作区快捷键 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + P Ctrl + Shift + P，F1 显示命令面板 Cmd + B Ctrl + B 显示/隐藏侧边栏 很实用 Cmd + \\ Ctrl + \\ 创建多个编辑器 【重要】抄代码利器 Cmd + 1、2 Ctrl + 1、2 聚焦到第 1、第 2 个编辑器 同上重要 cmd +/- ctrl +/- 将工作区放大/缩小（包括代码字体、左侧导航栏） 在投影仪场景经常用到 Cmd + J Ctrl + J 显示/隐藏控制台 Cmd + Shift + N Ctrl + Shift + N 重新开一个软件的窗口 很常用 Cmd + Shift + W Ctrl + Shift + W 关闭软件的当前窗口 Cmd + N Ctrl + N 新建文件 Cmd + W Ctrl + W 关闭当前文件 2、跳转操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Option + 左右方向键 Ctrl + Pagedown/Pageup 在已经打开的多个文件之间进行切换 非常实用 Ctrl + Tab Ctrl + Tab 在已经打开的多个文件之间进行跳转 不如上面的快捷键快 Cmd + Shift + O Ctrl + shift + O 在当前文件的各种方法之间进行跳转 Ctrl + G Ctrl + G 跳转到指定行 Cmd+Shift+\\ Ctrl+Shift+\\ 跳转到匹配的括号 3、移动光标 Mac 快捷键 Win 快捷键 作用 备注 方向键 方向键 在单个字符之间移动光标 大家都知道 option + 左右方向键 Ctrl + 左右方向键 在单词之间移动光标 很常用 Cmd + 左右方向键 Fn + 左右方向键 在整行之间移动光标 很常用 Cmd + ← Fn + ←（或 Win + ←） 将光标定位到当前行的最左侧 很常用 Cmd + → Fn + →（或 Win + →） 将光标定位到当前行的最右侧 很常用 Cmd + ↑ Ctrl + Home 将光标定位到文章的第一行 Cmd + ↓ Ctrl + End 将光标定位到文章的最后一行 Cmd + Shift + \\ 在代码块之间移动光标 4、编辑操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Enter Ctrl + Enter 在当前行的下方新增一行，然后跳至该行 即使光标不在行尾，也能快速向下插入一行 Cmd+Shift+Enter Ctrl+Shift+Enter 在当前行的上方新增一行，然后跳至该行 即使光标不在行尾，也能快速向上插入一行 Option + ↑ Alt + ↑ 将代码向上移动 很常用 Option + ↓ Alt + ↓ 将代码向下移动 很常用 Option + Shift + ↑ Alt + Shift + ↑ 将代码向上复制 Option + Shift + ↓ Alt + Shift + ↓ 将代码向下复制 写重复代码的利器 5、多光标编辑 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Option + 上下键 Ctrl + Alt + 上下键 在连续的多列上，同时出现光标 Option + 鼠标点击任意位置 Alt + 鼠标点击任意位置 在任意位置，同时出现光标 Option + Shift + 鼠标拖动 Alt + Shift + 鼠标拖动 在选中区域的每一行末尾，出现光标 Cmd + Shift + L Ctrl + Shift + L 在选中文本的所有相同内容处，出现光标 其他的多光标编辑操作：（很重要）\n选中某个文本，然后反复按住快捷键「 Cmd + D 」键（windows 用户是按住「Ctrl + D」键）， 即可将全文中相同的词逐一加入选择。\n选中一堆文本后，按住「Option + Shift + i」键（windows 用户是按住「Alt + Shift + I」键），既可在每一行的末尾都创建一个光标。\n6、删除操作 Mac 快捷键 Win 快捷键 作用 备注 Cmd + shift + K Ctrl + Shift + K 删除整行 「Cmd + X」的作用是剪切，但也可以删除整行 option + Backspace Ctrl + Backspace 删除光标之前的一个单词 英文有效，很常用 option + delete Ctrl + delete 删除光标之后的一个单词 Cmd + Backspace 删除光标之前的整行内容 很常用 Cmd + delete 删除光标之后的整行内容 备注：上面所讲到的移动光标、编辑操作、删除操作的快捷键，在其他编辑器里，大部分都适用。\n7、编程语言相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + / Ctrl + / 添加单行注释 很常用 Option + Shift + F Alt + shift + F 代码格式化 很常用 F2 F2 以重构的方式进行重命名 改代码备 Ctrl + J 将多行代码合并为一行 Win 用户可在命令面板搜索”合并行“ Cmd + Cmd + U Ctrl + U 将光标的移动回退到上一个位置 撤销光标的移动和选择 8、搜索相关 Mac 快捷键 Win 快捷键 作用 备注 Cmd + Shift + F Ctrl + Shift +F 全局搜索代码 很常用 Cmd + P Ctrl + P 在当前的项目工程里，全局搜索文件名 Cmd + F Ctrl + F 在当前文件中搜索代码，光标在搜索框里 Cmd + G F3 在当前文件中搜索代码，光标仍停留在编辑器里 很巧妙 9、自定义快捷键 按住快捷键「Cmd + Shift + P」，弹出命令面板，在命令面板中输入“快捷键”，可以进入快捷键的设置。\n当然，你也可以选择菜单栏「偏好设置 \u0026ndash;\u0026gt; 键盘快捷方式」，进入快捷键的设置：\n10、快捷键列表 你可以点击 VS Code 左下角的齿轮按钮，效果如下：\n上图中，在展开的菜单中选择「键盘快捷方式」，就可以查看和修改所有的快捷键列表了：\n快捷键参考链接 快捷键速查表[官方]：https://code.visualstudio.com/shortcuts/keyboard-shortcuts-windows.pdf 三、命令面板的使用 Mac 用户按住快捷键 Cmd+Shift+P （Windows 用户按住快捷键Ctrl+Shift+P），可以打开命令面板。效果如下：\n如果们需要修改一些设置项，可以通过「命令面板」来操作，效率会更高。这里列举一些。\n1、设置字体大小 在命令面板输入“字体”，可以进行字体的设置，效果如下：\n当然，你也可以在菜单栏，选择「首选项-设置-常用设置」，在这个设置项里修改字体大小。\n2、快捷键设置 在命令面板输入“快捷键”，就可以进入快捷键的设置。\n3、大小写转换 选中文本后，在命令面板中输入transfrom，就可以修改文本的大小写了。\n4、使用命令行启动 VS Code （1）输入快捷键「Cmd + Shift + P 」，选择install code command：\n（2）使用命令行：\ncode命令：启动 VS Code 软件\ncode pathName/fileName命令：通过 VS Code 软件打开指定目录/指定文件。\n四、私人订制：VS Code 的常见配置 1、VS Code 设置为中文语言 Mac 用户按住快捷键 Cmd+Shift+P （Windows 用户按住快捷键Ctrl+Shift+P），打开命令面板。\n在命令面板中，输入Configure Display Language，选择Install additional languages，然后安装插件Chinese (Simplified) Language Pack for Visual Studio Code即可。\n或者，我们可以直接安装插件Chinese (Simplified) Language Pack for Visual Studio Code，是一样的。\n安装完成后，重启 VS Code。\n2、面包屑（Breadcrumb） 打开 VS Code 的设置项，选择「用户设置 -\u0026gt; 工作台 -\u0026gt; 导航路径」，如下图所示：\n上图中，将红框部分打钩即可。\n设置成功后，我们就可以查看到当前文件的「层级结构」，非常方便。如下图所示：\n有了这个面包屑导航，我们可以在任意目录、任意文件之间随意跳转。\n3、左右显示多个编辑器窗口（抄代码利器） Mac 用户按住快捷键 Cmd + \\， Windows 用户按住快捷键Ctrl + \\，即可同时打开多个编辑器窗口，效果如下：\n按快捷键「Cmd + 1 」切换到左边的窗口，按快捷键「Cmd + 2 」切换到右边的窗口。随时随地，想切就切。\n学会了这一招，以后抄代码的时候，leader 再也不用担心我抄得慢了，一天工资到手。\n4、是否显示代码的行号 VS Code 默认显示代码的行号。你可以在设置项里搜索 editor.lineNumbers修改设置，配置项如下：\n我建议保留这个设置项，无需修改。\n5、右侧是否显示代码的缩略图 VS Code 会在代码的右侧，默认显示缩略图。你可以在设置项里搜索 editor.minimap进行设置，配置项如下：\n6、将当前行代码高亮显示（更改光标所在行的背景色） 当我们把光标放在某一行时，这一行的背景色并没有发生变化。如果想高亮显示当前行的代码，需要设置两步：\n（1）在设置项里搜索editor.renderLineHighlight，将选项值设置为all或者line。\n（2）在设置项里增加如下内容：\n1 2 3 4 \u0026#34;workbench.colorCustomizations\u0026#34;: { \u0026#34;editor.lineHighlightBackground\u0026#34;: \u0026#34;#00000090\u0026#34;, \u0026#34;editor.lineHighlightBorder\u0026#34;: \u0026#34;#ffffff30\u0026#34; } 上方代码，第一行代码的意思是：修改光标所在行的背景色（背景色设置为全黑，不透明度 90%）；第二行代码的意思是：修改光标所在行的边框色。\n7、改完代码后立即自动保存 方式一：\n改完代码后，默认不会自动保存。你可以在设置项里搜索files.autoSave，修改配置项如下：\n上图中，我们将配置项修改为onFocusChange之后，那么，当光标离开该文件后，这个文件就会自动保存了。非常方便。\n方式二：\n当然，你也可以直接在菜单栏选择「文件-自动保存」。勾选后，当你写完代码后，文件会立即实时保存。\n8、保存代码后，是否立即格式化 保存代码后，默认不会立即进行代码的格式化。你可以在设置项里搜索editor.formatOnSave查看该配置项：\n我觉得这个配置项保持默认就好，不用打钩。\n9、空格 or 制表符 VS Code 会根据你所打开的文件来决定该使用空格还是制表。也就是说，如果你的项目中使用的都是制表符，那么，当你在写新的代码时，按下 tab 键后，编辑器就会识别成制表符。\n常见的设置项如下：\neditor.detectIndentation：自动检测（默认开启）。截图如下： editor.insertSpaces：按 Tab 键时插入空格（默认）。截图如下： editor.tabSize：一个制表符默认等于四个空格。截图如下： 10、新建文件后的默认文件类型 当我们按下快捷键「Cmd + N」新建文件时，VS Code 默认无法识别这个文件到底是什么类型的，因此也就无法识别相应的语法高亮。\n如果你想修改默认的文件类型，可以在设置项里搜索files.defaultLanguage，设置项如下：\n上图中的红框部分，填入你期望的默认文件类型。我填的是html类型，你也可以填写成 javascript 或者 markdown，或者其他的语言类型。\n11、删除文件时，是否弹出确认框 当我们在 VS Code 中删除文件时，默认会弹出确认框。如果你想修改设置，可以在设置项里搜索xplorer.confirmDelete。截图如下：\n我建议这个设置项保持默认的打钩就好，不用修改。删除文件前的弹窗提示，也是为了安全考虑，万一手贱不小心删了呢？\n接下来，我们来讲一些更高级的配置。\n12、文件对比 VS Code 默认支持对比两个文件的内容。选中两个文件，然后右键选择「将已选项进行比较」即可，效果如下：\nVS Code 自带的对比功能并不够强大，我们可以安装插件compareit，进行更丰富的对比。比如说，安装完插件compareit之后，我们可以将「当前文件」与「剪切板」里的内容进行对比：\n13、查找某个函数在哪些地方被调用了 比如我已经在a.js文件里调用了 foo()函数。那么，如果我想知道foo()函数在其他文件中是否也被调用了，该怎么做呢？\n做法如下：在 a.js 文件里，选中foo()函数（或者将光标放置在foo()函数上），然后按住快捷键「Shift + F12」，就能看到 foo()函数在哪些地方被调用了，比较实用。\n14、鼠标操作 在当前行的位置，鼠标三击，可以选中当前行。\n用鼠标单击文件的行号，可以选中当前行。\n在某个行号的位置，上下移动鼠标，可以选中多行。\n15、重构 重构分很多种，我们来举几个例子。\n命名重构：\n当我们尝试去修改某个函数（或者变量名）时，我们可以把光标放在上面，然后按下「F2」键，那么，这个函数（或者变量名）出现的地方都会被修改。\n方法重构：\n选中某一段代码，这个时候，代码的左侧会出现一个「灯泡图标」，点击这个图标，就可以把这段代码提取为一个单独的函数。\n16、在当前文件中搜索 在上面的快捷键列表中，我们已经知道如下快捷键：\nCmd + F（Win 用户是 Ctrl + F）：在当前文件中搜索，光标在搜索框里\nCmd + G（Win 用户是 F3）：在当前文件中搜索，光标仍停留在编辑器里\n另外，你可能会注意到，搜索框里有很多按钮，每个按钮都对应着不同的功能，如下图所示：\n上图中，你可以通过「Tab」键和「Shift + Tab」键在输入框和替换框之间进行切换。\n「在选定内容中查找」这个功能还是比较实用的。你也可以在设置项里搜索 editor.find.autoFindInSelection，勾选该设置项后，那么，当你选中指定内容后，然后按住「Cmd + F」，就可以自动只在这些内容里进行查找。该设置项如下图所示：\n17、全局搜索 在上面的快捷键列表中，我们已经知道如下快捷键：\nCmd + Shift + F（Win 用户是 Ctrl + Shift +F）：在全局的文件夹中进行搜索。效果如下： 上图中，你可以点击红框部分，展开更多的配置项。\n18、Git 版本管理 VS Code 自带了 Git 版本管理，如下图所示：\n上图中，我们可以在这里进行常见的 git 命令操作。如果你还不熟悉 Git 版本管理，可以先去补补课。\n与此同时，我建议安装插件GitLens，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。\n19、将工作区放大/缩小 我们在上面的设置项里修改字体大小后，仅仅只是修改了代码的字体大小。\n如果你想要缩放整个工作区（包括代码的字体、左侧导航栏的字体等），可以按下快捷键「cmd +/-」。windows 用户是按下「ctrl +/-」\n当我们在投影仪上给别人演示代码的时候，这一招十分管用。\n如果你想恢复默认的工作区大小，可以在命令面板输入重置缩放（英文是reset zoom）\n20、创建多层子文件夹 我们可以在新建文件夹的时候，如果直接输入aa/bb/cc，比如：\n那么，就可以创建多层子文件夹，效果如下：\n21、.vscode 文件夹的作用 为了统一团队的 vscode 配置，我们可以在项目的根目录下建立.vscode目录，在里面放置一些配置内容，比如：\nsettings.json：工作空间设置、代码格式化配置、插件配置。\nsftp.json：ftp 文件传输的配置。\n.vscode目录里的配置只针对当前项目范围内生效。将.vscode提交到代码仓库，大家统一配置时，会非常方便。\n22、自带终端 我们可以按下「Ctrl + `」打开 VS Code 自带的终端。我认为内置终端并没有那么好用，我更建议你使用第三方的终端 item2。\n23、markdown 语法支持 VS Code 自带 markdown 语法高亮。也就是说，如果你是用 markdown 格式写文章，则完全可以用 VS Code 进行写作。\n写完 md 文件之后，你可以点击右上角的按钮进行预览，如下图所示：\n我一般是安装「Markdown Preview Github Styling」插件，以 GitHub 风格预览 Markdown 样式。样式十分简洁美观。\n你也可以在控制面板输入Markdown: 打开预览，直接全屏预览 markdown 文件。\n24、Emmet in VS Code Emmet可以极大的提高 html 和 css 的编写效率，它提供了一种非常简练的语法规则。\n举个例子，我们在编辑器中输入缩写代码：ul\u0026gt;li*6 ，然后按下 Tab 键，即可得到如下代码片段：\n1 2 3 4 5 6 7 8 \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; VS Code 默认支持 Emmet。更多 Emmet 语法规则，请自行查阅。\n25、修改字体，使用「Fira Code」字体 这款字体很漂亮，很适合用来写代码：\n安装步骤如下：\n（1）进入 https://github.com/tonsky/FiraCode 网站，下载并安装「Fira Code」字体。\n（2）打开 VS Code 的「设置」，搜索font，修改相关配置为如下内容：\n1 2 \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;Fira Code\u0026#39;,Menlo, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, // 设置字体显示 \u0026#34;editor.fontLigatures\u0026#34;: false,//控制是否启用字体连字，true启用，false不启用 上方的第二行配置，取决于个人习惯，我是直接设置为\u0026quot;editor.fontLigatures\u0026quot;: null，因为我不太习惯连字。\n26、代码格式化：Prettier 我们可以使用 Prettier进行代码格式化，会让代码的展示更加美观。步骤如下：\n（1）安装插件 Prettier。\n（2）在项目的根路径下，新建文件.prettierrc，并在文件中添加如下内容：\n1 2 3 4 5 6 7 8 9 { \u0026#34;printWidth\u0026#34;: 150, \u0026#34;tabWidth\u0026#34;: 4, \u0026#34;semi\u0026#34;: true, \u0026#34;singleQuote\u0026#34;: true, \u0026#34;trailingComma\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;tslintIntegration\u0026#34;: true, \u0026#34;insertSpaceBeforeFunctionParenthesis\u0026#34;: false } 上面的内容，是我自己的配置，你可以参考。\n更多配置，可以参考官方文档：https://prettier.io/docs/en/options.html\n27、文件传输：sftp 如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装sftp这个插件，很好用。在公司会经常用到。\n步骤如下：\n（1）安装插件sftp。\n（2）配置 sftp.json文件。 插件安装完成后，输入快捷键「cmd+shift+P」弹出命令面板，然后输入sftp:config，回车，当前工程的.vscode文件夹下就会自动生成一个sftp.json文件，我们需要在这个文件里配置的内容可以是：\nhost：服务器的 IP 地址\nusername：用户名\nprivateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是 ppk 文件）\nremotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用 sftp 上传文件之前，要手动在工作站上 mkdir 生成这个根目录\nignore：指定在使用 sftp: sync to remote 的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号\n举例如下：(注意，其中的注释需要去掉)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 { \u0026#34;host\u0026#34;: \u0026#34;192.168.xxx.xxx\u0026#34;, //服务器ip \u0026#34;port\u0026#34;: 22, //端口，sftp模式是22 \u0026#34;username\u0026#34;: \u0026#34;\u0026#34;, //用户名 \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, //密码 \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, //模式 \u0026#34;agent\u0026#34;: null, \u0026#34;privateKeyPath\u0026#34;: null, \u0026#34;passphrase\u0026#34;: null, \u0026#34;passive\u0026#34;: false, \u0026#34;interactiveAuth\u0026#34;: false, \u0026#34;remotePath\u0026#34;: \u0026#34;/root/node/build/\u0026#34;, //服务器上的文件地址 \u0026#34;context\u0026#34;: \u0026#34;./server/build\u0026#34;, //本地的文件地址 \u0026#34;uploadOnSave\u0026#34;: true, //监听保存并上传 \u0026#34;syncMode\u0026#34;: \u0026#34;update\u0026#34;, \u0026#34;watcher\u0026#34;: { //监听外部文件 \u0026#34;files\u0026#34;: false, //外部文件的绝对路径 \u0026#34;autoUpload\u0026#34;: false, \u0026#34;autoDelete\u0026#34;: false }, \u0026#34;ignore\u0026#34;: [ //忽略项 \u0026#34;**/.vscode/**\u0026#34;, \u0026#34;**/.git/**\u0026#34;, \u0026#34;**/.DS_Store\u0026#34; ] } （3）在 VS Code 的当前文件里，选择「右键 -\u0026gt; upload」，就可以将本地的代码上传到 指定的 ftp 服务器上（也就是在上方 host 中配置的服务器 ip）。\n我们还可以选择「右键 -\u0026gt; Diff with Remote」，就可以将本地的代码和 ftp 服务器上的代码做对比。\n七、VS Code 配置云同步 我们可以将配置云同步，这样的话，当我们换个电脑时，即可将配置一键同步到本地，就不需要重新安装插件了，也不需要重新配置软件。\n我们还可以把配置分享其他用户，也可以把其他用户的配置给自己用。\n将自己本地的配置云同步到 GitHub：\n（1）安装插件 settings-sync。\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n（3）登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist。\n（4）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub。\n换另外一个电脑时，从云端同步配置到本地：\n（1）当我们换另外一台电脑时，可以先在 VS Code 中安装 settings-sync 插件。\n（2）安装完插件后，在插件里使用 GitHub 账号登录。\n（3）登录之后，插件的界面上，会自动出现之前的同步记录：\n上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：\n如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次。\n使用其他人的配置：\n如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：\n（1）安装插件 settings-sync。\n（2）使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」\n（3）在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。\n八、三头六臂：VS Code 插件推荐 VS Code 有一个很强大的功能就是支持插件扩展，让你的编辑器仿佛拥有了三头六臂。\n上图中，点击红框部分，即可在输入框里，查找你想要的插件名，然后进行安装。\n我来列举几个常见的插件，这些插件都很实用。注意：顺序越靠前，越实用。\n1、GitLens 【荐】 我强烈建议你安装插件GitLens，它是 VS Code 中我最推荐的一个插件，简直是 Git 神器，码农必备。如果你不知道，那真是 out 了。\nGitLens 在 Git 管理上有很多强大的功能，比如：\n将光标放置在代码的当前行，可以看到这样代码的提交者是谁，以及提交时间。这一点，是 GitLens 最便捷的功能。\n查看某个 commit 的代码改动记录\n查看不同的分支\n可以将两个 commit 进行代码对比\n甚至可以将两个 branch 分支进行整体的代码对比。这一点，简直是 GitLens 最强大的功能。当我们在不同分支 review 代码的时候，就可以用到这一招。\n2、Git History 有些同学习惯使用编辑器中的 Git 管理工具，而不太喜欢要打开另外一个 Git UI 工具的同学，这一款插件满足你查询所有 Git 记录的需求。\n3、Live Server 【荐】 在本地启动一个服务器，代码写完后可以实现「热更新」，实时地在网页中看到运行效果。就不需要每次都得手动刷新页面了。\n使用方式：安装插件后，开始写代码；代码写完后，右键选择「Open with Live Server」。\n4、Chinese (Simplified) Language Pack for Visual Studio Code 让软件显示为简体中文语言。\n5、Bracket Pair Colorizer 2：突出显示成对的括号【荐】 Bracket Pair Colorizer 2插件：以不同颜色显示成对的括号，并用连线标注括号范围。简称彩虹括号。\n另外，还有个Rainbow Brackets插件，也可以突出显示成对的括号。\n6、sftp：文件传输 【荐】 如果你需要将本地文件通过 ftp 的形式上传到局域网的服务器，可以安装sftp这个插件，很好用。在公司会经常用到。\n详细配置已经在上面讲过。\n7、open in browser 安装open in browser插件后，在 HTML 文件中「右键选择 \u0026ndash;\u0026gt; Open in Default Browser」，即可在浏览器中预览网页。\n8、highlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】 VSCode 自带的高亮显示，实在是不够显眼。用插件支持一下吧。\n所用了这个插件之后，VS Code 自带的高亮就可以关掉了：\n在用户设置里添加\u0026quot;editor.selectionHighlight\u0026quot;: false即可。\n参考链接：vscode 选中后相同内容高亮插件推荐\n9、vscode-icons vscode-icons 会根据文件的后缀名来显示不同的图标，让你更直观地知道每种文件是什么类型的。\n10、Project Manager 工作中，我们经常会来回切换多个项目，每次都要找到对应项目的目录再打开，比较麻烦。Project Manager 插件可以解决这样的烦恼，它提供了专门的视图来展示你的项目，我们可以把常用的项目保存在这里，需要时一键切换，十分方便。\n11、TODO Highlight 写代码过程中，突然发现一个 Bug，但是又不想停下来手中的活，以免打断思路，怎么办？按照代码规范，我们一般是在代码中加个 TODO 注释。比如：（注意，一定要写成大写TODO，而不是小写的todo）\n1 //TODO:这里有个bug，我一会儿再收拾你 或者：\n1 //FIXME:我也不知道为啥， but it works only that way. 安装了插件 TODO Highlight之后，按住「Cmd + Shift + P」打开命令面板，输入「Todohighlist」，选择相关的命令，我们就可以看到一个 todoList 的清单。\n12、WakaTime 【荐】 统计在 VS Code 里写代码的时间。统计效果如下：\n13、Code Time Code Time插件：记录编程时间，统计代码行数。\n安装该插件后，VS Code 底部的状态栏右下角可以看到时间统计。点击那个位置之后，选择「Code Time Dashboard」，即可查看统计结果。\n备注：团长试了一下这个 code time 插件，发现统计结果不是很准。\n14、Markdown Preview Github Styling 【荐】 以 GitHub 风格预览 Markdown 样式，十分简洁优雅。就像下面这样，左侧书写 Markdown 文本，右侧预览 Markdown 的渲染效果：\n15、Markdown Preview Enhanced 预览 Markdown 样式。\nMarkdown All in One 这个插件将帮助你更高效地在 Markdown 中编写文档。\n16、Settings Sync【荐】 地址：https://github.com/shanalikhan/code-settings-sync\n作用：多台设备之间，同步 VS Code 配置。通过登录 GitHub 账号来使用这个同步工具。\n同步的详细操作已在上面讲过。\n17、vscode-syncing 地址：https://github.com/nonoroazoro/vscode-syncing\n作用：多台设备之间，同步 VS Code 配置。\n18、Vetur Vue 多功能集成插件，包括：语法高亮，智能提示，emmet，错误提示，格式化，自动补全，debugger。VS Code 官方钦定 Vue 插件，Vue 开发者必备。\n19、ES7 React/Redux/GraphQL/React-Native snippets React/Redux/react-router 的语法智能提示。\n20、minapp：小程序支持 小程序开发必备插件。\n21、Prettier：代码格式化 Prettier 是一个代码格式化工具，只关注格式化，但不具备校验功能。在一个多人协同开发的团队中，统一的代码编写规范非常重要。一套规范可以让我们编写的代码达到一致的风格，提高代码的可读性和统一性。自然维护性也会有所提高。\n22、ESLint：代码格式校验 日常开发中，建议用可以用 Prettier 做代码格式化，然后用 eslint 做校验。\n23、Beautify 代码格式化工具。\n备注：相比之下，Prettier 是当前最流行的代码格式化工具，比 Beautify 用得更多。\n24、JavaScript(ES6) code snippets ES6 语法智能提示，支持快速输入。\n25、Search node_modules 【荐】 node_modules模块里面的文件夹和模块实在是太多了，根本不好找。好在安装 Search node_modules 这个插件后，输入快捷键「Cmd + Shift + P」，然后输入 node_modules，在弹出的选项中选择 Search node_modules，即可搜索 node_modules 里的模块。\n26、indent-rainbow：突出显示代码缩进 indent-rainbow插件：突出显示代码缩进。\n安装完成后，效果如下图所示：\n27、javascript console utils：快速打印 log 日志【荐】 安装这个插件后，当我们按住快捷键「Cmd + Shift + L」后，即可自动出现日志 console.log()。简直是日志党福音。\n当我们选中某个变量 name，然后按住快捷键「Cmd + Shift + L」，即可自动出现这个变量的日志 console.log(name)。\n其他的同类插件还有：Turbo Console Log。\n不过，生产环境的代码，还是尽量少打日志比较好，避免出现一些异常。\n编程有三等境界：\n第三等境界是打日志，这是最简单、便捷的方式，略显低级，一般新手或资深程序员偷懒时会用。\n第二等境界是断点调试，在前端、Java、PHP、iOS 开发时非常常用，通过断点调试可以很直观地跟踪代码执行逻辑、调用栈、变量等，是非常实用的技巧。\n第一等境界是测试驱动开发，在写代码之前先写测试。与第二等的断点调试刚好相反，大部分人不是很习惯这种方式，但在国外开发者或者敏捷爱好者看来，这是最高效的开发方式，在保证代码质量、重构等方面非常有帮助，是现代编程开发必不可少的一部分。\n28、Code Spell Checker：单词拼写错误检查 这个拼写检查程序的目标是帮助捕获常见的单词拼写错误，可以检测驼峰命名。从此告别 Chinglish.\n29、Local History 【荐】 维护文件的本地历史记录，强烈建议安装。代码意外丢失时，有时可以救命。\n30、Polacode-2020：生成代码截图 【荐】 可以把代码片段保存成美观的图片，主题不同，代码的配色方案也不同，也也可以自定义设置图片的边框颜色、大小、阴影。\n尤其是在我们做 PPT 分享时需要用到代码片段时，或者需要在网络上优雅地分享代码片段时，这一招很有用。\n生成的效果如下：\n其他同类插件：CodeSnap。我们也可以通过 https://carbon.now.sh/这个网站生成代码图片\n有人可能会说：直接用 QQ 截图不行吗？可以是可以，但不够美观、不够干净。\n31、Image Preview 【荐】 图片预览。鼠标移动到图片 url 上的时候，会自动显示图片的预览和图片尺寸。\n32、Auto Close Tag、Auto Rename Tag 自动闭合标签、自动对标签重命名。\n33、Better Comments 为注释添加更醒目、带分类的色彩。\n34、CSS Peek 增强 HTML 和 CSS 之间的关联，快速查看该元素上的 CSS 样式。\n35、Vue CSS Peek CSS Peek 对 Vue 没有支持，该插件提供了对 Vue 文件的支持。\n36、Color Info 这个便捷的插件，将为你提供你在 CSS 中使用颜色的相关信息。你只需在颜色上悬停光标，就可以预览色块中色彩模型的（HEX、 RGB、HSL 和 CMYK）相关信息了。\n37、RemoteHub 不要惊讶，RemoteHub 和 GitLens 是同一个作者开发出来的。\nRemoteHub插件的作用是：可以在本地查看 GitHub 网站上的代码，而不需要将代码下载到本地。\n这个插件目前使用的人还不多，赶紧安装起来尝尝鲜吧。\n38、Live Share：实时编码分享 Live Share这个神奇的插件是由微软官方出品，它的作用是：实时编码分享。也就是说，它可以实现你和你的同伴一起写代码。这绝对就是结对编程的神器啊。\n安装方式：\n打开插件管理，搜索“live share”，安装。安装后重启 VS Code，在左侧会多出一个按钮：\n上图中，点击红框部分，登录后就可以分享你的工作空间了。\n39、Import Cost 在项目开发过程中，我们会引入很多 npm 包，有时候可能只用到了某个包里的一个方法，却引入了整个包，导致代码体积增大很多。Import Cost插件可以在代码中友好的提示我们，当前引入的包会增加多少体积，这很有助于帮我们优化代码的体积。\nPaste JSON as Code 此插件可以将剪贴板中的 JSON 字符串转换成工作代码。支持多种语言。\n八、常见主题插件 给你的 VS Code 换个皮肤吧，免费的那种。\nDracula Theme\nMaterial Theme\nNebula Theme\nOne Dark Pro\nOne Monokai Theme\nMonokai Pro\nAyu\nSnazzy Plus\nDainty\nSynthWave '84\nGitHub Plus Theme：白色主题\nHorizon Theme：红色主题\n最后一段 如果你还有什么推荐的 VS Code 插件，欢迎留言。\n大家完全不用担心这篇文章会过时，随着 VS Code 的版本更新和插件更新，本文也会随之更新。关于 VS Code 内容的后续更新，你可以关注我在 GitHub 上的前端入门项目，项目地址是：\nhttps://github.com/qianguyihao/Web\n一个超级详细和真诚的前端入门项目。\ntodo issues 84 参考链接 VSCode 插件大全｜ VSCode 高级玩家之第二篇\nhttp://www.supuwoerc.xyz/tools/vscode/plugins.html\n如何让 VS Code 更好用 10 倍？这里有一份 VS Code 新手指南\n那些你应该考虑卸载的 VSCode 扩展\nVS Code 折腾记 - (16) 推荐一波实用的插件集\nVSCode 前端必备插件，有可能你装了却不知道如何使用？\n能让你开发效率翻倍的 VSCode 插件配置（上）\nhttps://segmentfault.com/a/1190000012811886\n「Vscode」打造类 sublime 的高颜值编辑器\nMac Vscode 快捷键\n使用 VSCode 的一些技巧\n本作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/01-vs-code%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"快捷键 作用 IDEA 快捷键 VS Code 备注 复制当前行 Ctrl + D Shift + Alt + ↑↓ 使用很频繁 当前文件搜索 Ctrl + R Ctrl + F 非常实用 全局搜索内容 Ctrl + Shift + R Ctrl + Shift + F 不如上面的快","title":"VS Code的使用"},{"content":"常见配置 自动保存：\n1 \u0026#34;files.autoSave\u0026#34;: \u0026#34;onFocusChange\u0026#34; 参考链接：https://blog.csdn.net/WestLonly/article/details/78048049\n在新的窗口中打开文件：\n1 \u0026#34;workbench.editor.enablePreview\u0026#34;: false, 常见操作 如何查看代码结构 方法一：「Cmd + Shift + O」\n方法二：安装插件Code Outline\n参考链接：https://www.zhihu.com/question/264045094\n在本地开启服务器 1 2 3 4 5 # 安装 npm install -g live-server # 启动 live-server 参考链接：Visual Studio Code + live-server编辑和浏览HTML网页\n常用插件 方式一：打开VS Code，左侧有五个按钮，点击最下方的按钮，然后就可以开始安装相应的插件了。\n方式二：在vscode中输入快捷键「ctrl+shift+P」，弹出指令窗口，输入extension:install，回车，左侧即打开扩展安装的界面。\nsftp：文件传输 输入快捷键「ctrl+shift+P」，弹出指令窗口，输入sftp:config，回车，当前工作工程的.vscode文件夹下就会自动生成一个sftp.json文件，我们需要在这个文件里配置的是：\nhost：服务器的IP地址\nusername：工作站自己的用户名\nprivateKeyPath：存放在本地的已配置好的用于登录工作站的密钥文件（也可以是ppk文件）\nremotePath：工作站上与本地工程同步的文件夹路径，需要和本地工程文件根目录同名，且在使用sftp上传文件之前，要手动在工作站上mkdir生成这个根目录\nignore：指定在使用sftp: sync to remote的时候忽略的文件及文件夹，注意每一行后面有逗号，最后一行没有逗号\n举例如下：(注意，其中的注释不能保留)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { \u0026#34;host\u0026#34;: \u0026#34;\u0026#34;, //服务器ip \u0026#34;port\u0026#34;: 22, //端口，sftp模式是22 \u0026#34;username\u0026#34;: \u0026#34;\u0026#34;, //用户名 \u0026#34;password\u0026#34;: \u0026#34;\u0026#34;, //密码 \u0026#34;protocol\u0026#34;: \u0026#34;sftp\u0026#34;, //模式 \u0026#34;agent\u0026#34;: null, \u0026#34;privateKeyPath\u0026#34;: null, \u0026#34;passphrase\u0026#34;: null, \u0026#34;passive\u0026#34;: false, \u0026#34;interactiveAuth\u0026#34;: false, \u0026#34;remotePath\u0026#34;: \u0026#34;/root/node/build/\u0026#34;, //服务器上的文件地址 \u0026#34;context\u0026#34;: \u0026#34;./server/build\u0026#34;, //本地的文件地址 \u0026#34;uploadOnSave\u0026#34;: true, //监听保存并上传 \u0026#34;syncMode\u0026#34;: \u0026#34;update\u0026#34;, \u0026#34;watcher\u0026#34;: { //监听外部文件 \u0026#34;files\u0026#34;: false, //外部文件的绝对路径 \u0026#34;autoUpload\u0026#34;: false, \u0026#34;autoDelete\u0026#34;: false }, \u0026#34;ignore\u0026#34;: [ //忽略项 \u0026#34;**/.vscode/**\u0026#34;, \u0026#34;**/.git/**\u0026#34;, \u0026#34;**/.DS_Store\u0026#34; ] } Sass Formatter Sass 文件格式化。\nCode Outline：显示代码结构 安装好插件「Code Outline」后，可以在左侧的资源管理器中，显示当前文件的代码结构：\n参考链接：\nhttps://www.zhihu.com/question/50273450\nhttp://itopic.org/vscode.html\nhttps://github.com/varHarrie/varharrie.github.io/issues/10\nvscode-fileheader：添加顶部注释模板(签名) （1）安装插件vscode -fileheader，并重启。\n（2）在首选项-》设置-》中搜索fileheader，找到头部模板修改。\n默认的快捷键是：「Ctrl + option + I」。\n参考链接：\nhttps://www.zhihu.com/question/62385647 Express 在本地开启Node服务器：\n然后在浏览器的地址栏输入http://localhost/ + 文件的相对路径，就可以通过服务器的形式打开这个文件。\nhighlight-icemode：选中相同的代码时，让高亮显示更加明显【荐】 VSCode自带的高亮显示，实在是不够显眼。用插件支持一下吧。\n所用了这个插件之后，VS Code自带的高亮就可以关掉了：\n在用户设置里添加\u0026quot;editor.selectionHighlight\u0026quot;: false即可。\n参考链接：vscode 选中后相同内容高亮插件推荐\nhighlight-words：全局高亮（跨文件多色彩） 参考链接：Visual Studio Code全局高亮着色插件(跨文件多色彩)经验纪要\ncolor-exchange：颜色格式转换【荐】 安装完插件后，在css中输入颜色，然后按cmd + .，就能进行颜色的格式转换。\nVue 相关的插件 vetur：vue 文件的基本语法高亮 安装完 vetur 后还需要加上这样一段配置下：\n1 2 3 4 \u0026#34;emmet.syntaxProfiles\u0026#34;: { \u0026#34;vue-html\u0026#34;: \u0026#34;html\u0026#34;, \u0026#34;vue\u0026#34;: \u0026#34;html\u0026#34; } 参考链接：\nhttps://www.clarencep.com/2017/03/18/edit-vue-file-via-vscode/ https://github.com/varHarrie/varharrie.github.io/issues/10 参考链接 https://www.jianshu.com/p/0724921285d4\nhttps://www.cnblogs.com/AmosLee94/p/8338013.html\n常用快捷键 Win快捷键 Mac快捷键 作用 备注 Shift + Alt + F Shift + option + F 代码格式化 Ctrl + Shift + N 在当前行上面增加一行并跳至该行 Ctrl + Shift + D 复制当前行到下一行 参考链接 能让你开发效率翻倍的 VSCode 插件配置（上） ","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/05-vs-code%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A7%AF%E7%B4%AF/","summary":"常见配置 自动保存： 1 \u0026#34;files.autoSave\u0026#34;: \u0026#34;onFocusChange\u0026#34; 参考链接：https://blog.csdn.net/WestLonly/article/details/78048","title":"VS Code的使用积累"},{"content":"什么是mvvm？ MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑；View 代表UI 组件，它负责将数据模型转化成UI 展现出来，ViewModel 是一个同步View 和 Model的对象\n在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理 vue的优点是什么？ 低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的\u0026quot;View\u0026quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变 可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑 可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写 请详细说下你对vue生命周期的理解 答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后\n创建前/后： 在beforeCreate阶段，vue实例的挂载元素el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，el还没有 载入前/后：在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。 更新前/后：当data变化时，会触发beforeUpdate和updated方法 销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在 组件之间的传值？ 父组件与子组件传值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 //父组件通过标签上面定义传值 \u0026lt;template\u0026gt; \u0026lt;Main :obj=\u0026#34;data\u0026#34;\u0026gt;\u0026lt;/Main\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; //引入子组件 import Main form \u0026#34;./main\u0026#34; exprot default{ name:\u0026#34;parent\u0026#34;, data(){ return { data:\u0026#34;我要向子组件传递数据\u0026#34; } }, //初始化组件 components:{ Main } } \u0026lt;/script\u0026gt; //子组件通过props方法接受数据 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{data}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; exprot default{ name:\u0026#34;son\u0026#34;, //接受父组件传值 props:[\u0026#34;data\u0026#34;] } \u0026lt;/script\u0026gt; 子组件向父组件传递数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //子组件通过$emit方法传递参数 \u0026lt;template\u0026gt; \u0026lt;div v-on:click=\u0026#34;events\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; //引入子组件 import Main form \u0026#34;./main\u0026#34; exprot default{ methods:{ events:function(){ } } } \u0026lt;/script\u0026gt; // \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{data}}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; exprot default{ name:\u0026#34;son\u0026#34;, //接受父组件传值 props:[\u0026#34;data\u0026#34;] } \u0026lt;/script\u0026gt; 路由之间跳转？ 声明式（标签跳转）\n1 \u0026lt;router-link :to=\u0026#34;index\u0026#34;\u0026gt; 编程式（ js跳转）\n1 router.push(\u0026#39;index\u0026#39;) vuex是什么？怎么使用？哪种功能场景使用它？ vue框架中状态管理。在main.js引入store，注入。新建了一个目录store，….. export 。场景有：单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车\n实现 Vue SSR 其基本实现原理\napp.js 作为客户端与服务端的公用入口，导出 Vue 根实例，供客户端 entry 与服务端 entry 使用。客户端 entry 主要作用挂载到 DOM 上，服务端 entry 除了创建和返回实例，还进行路由匹配与数据预获取。 webpack 为客服端打包一个 Client Bundle ，为服务端打包一个 Server Bundle 。 服务器接收请求时，会根据 url，加载相应组件，获取和解析异步数据，创建一个读取 Server Bundle 的 BundleRenderer，然后生成 html 发送给客户端。 客户端混合，客户端收到从服务端传来的 DOM 与自己的生成的 DOM 进行对比，把不相同的 DOM 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 stroe 里，这样，在客户端挂载到 DOM 之前，可以直接从 store 里取数据。首屏的动态数据通过 window.__INITIAL_STATE__ 发送到客户端 Vue SSR 的实现，主要就是把 Vue 的组件输出成一个完整 HTML, vue-server-renderer 就是干这事的\nVue SSR 需要做的事多点（输出完整 HTML），除了 complier -\u0026gt; vnode，还需如数据获取填充至 HTML、客户端混合（hydration）、缓存等等。 相比于其他模板引擎（ejs, jade 等），最终要实现的目的是一样的，性能上可能要差点 Vue 组件 data 为什么必须是函数 每个组件都是 Vue 的实例。 组件共享 data 属性，当 data 的值是同一个引用类型的值时，改变其中一个会影响其他 Vue computed 实现 建立与其他属性（如：data、 Store）的联系； 属性改变后，通知计算属性重新计算 实现时，主要如下\n初始化 data， 使用 Object.defineProperty 把这些属性全部转为 getter/setter。 初始化 computed, 遍历 computed 里的每个属性，每个 computed 属性都是一个 watch 实例。每个属性提供的函数作为属性的 getter，使用 Object.defineProperty 转化。 Object.defineProperty getter 依赖收集。用于依赖发生变化时，触发属性重新计算。 若出现当前 computed 计算属性嵌套其他 computed 计算属性时，先进行其他的依赖收集 Vue complier 实现 模板解析这种事，本质是将数据转化为一段 html ，最开始出现在后端，经过各种处理吐给前端。随着各种 mv* 的兴起，模板解析交由前端处理。 总的来说，Vue complier 是将 template 转化成一个 render 字符串。 可以简单理解成以下步骤：\nparse 过程，将 template 利用正则转化成 AST 抽象语法树。 optimize 过程，标记静态节点，后 diff 过程跳过静态节点，提升性能。 generate 过程，生成 render 字符串 怎么快速定位哪个组件出现性能问题 用 timeline 工具。 大意是通过 timeline 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue/","summary":"什么是mvvm？ MVVM是Model-View-ViewModel的缩写。mvvm是一种设计思想。Model 层代表数据模型，也可以在Mode","title":"vue"},{"content":"WebSocket 的引入 背景分析 HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。\n当用户在浏览器上进行操作时，可以请求服务器上的api；但是反过来却不可能：服务器端发生了一个事件，无法将这个事件的信息实时主动地通知客户端。只有在客户端查询服务器当前状态时，所发生事件的信息才会从服务器传递到客户端。\n那怎么去实时地知道服务器的状态呢？方法有两个：\n（1）轮询：客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。\n（2）长连接：客户端只请求一次，但是服务器会将连接保持，不会返回结果。当服务器有了新数据时，实时地发给客户端，而一直保持挂起状态。这种做法的也造成了大量的性能浪费。\nWebSocket 协议 最新的 HTML5协议，制定了 WebSocket 协议标准，允许客户端和服务器端以全双工的方式进行通信。\nWebSocket 的原理非常简单：利用HTTP请求产生握手，HTTP头部含有 WebSocket 协议的请求，*握手之后，二者转用TCP协议进行交流（QQ的协议）。\nWebSocket协议需要浏览器和服务器都支持才可以使用：\n支持WebSocket协议的浏览器有：Chrome 4、火狐4、IE10、Safari5\n支持WebSocket协议的服务器有：Node 0、Apach7.0.2、Nginx1.3\nhttp 长连接和 websocket 的长连接区别 HTTP1.1通过使用Connection:keep-alive进行长连接，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对每个请求仍然要单独发 header，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。\nwebsocket是一个真正的全双工。长连接第一次tcp链路建立之后，后续数据可以双方都进行发送，不需要发送请求头。\nkeep-alive双方并没有建立正真的连接会话，服务端可以在任何一次请求完成后关闭。WebSocket 它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。\nSocket.IO 的引入 Node.js上需要写一些程序，来处理TCP请求。\nNode.js从诞生之日起，就支持 WebSocket 协议。不过，从底层一步一步搭建一个Socket服务器很费劲（想象一下Node写一个静态文件服务都那么费劲）。所以，有大神帮我们写了一个库 Socket.IO。\nSocket.IO 是业界良心，新手福音。它屏蔽了所有底层细节，让顶层调用非常简单。并且还为不支持 WebSocket 协议的浏览器，提供了长轮询的透明模拟机制。\nNode的单线程、非阻塞I/O、事件驱动机制，使它非常适合Socket服务器。\nSocket.IO 的安装 Socket.IO 的官网是：http://socket.io/\n安装方式：\n1 npm install socket.io ","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/websocket/","summary":"WebSocket 的引入 背景分析 HTTP协议是无状态的，服务器只会响应来自客户端的请求，但是它与客户端之间不具备持续连接。 当用户在浏览器上进行操作时，可以请","title":"WebSocket"},{"content":"常见web安全及防护原理\nsql注入原理\n就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令 总的来说有以下几点\n永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双\u0026quot;-\u0026ldquo;进行转换等 永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接 不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息 XSS原理及防范\nXss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点 XSS防范方法\n首先代码里对用户输入的地方和变量都需要仔细检查长度和对”\u0026lt;”,”\u0026gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击 XSS与CSRF有什么区别吗？\nXSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤\n登录受信任网站A，并在本地生成Cookie\n在不登出A的情况下，访问危险网站B\nCSRF的防御\n服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数 通过验证码的方法 是否了解 Web 注入攻击（最常见 XSS 和 CSRF）？\nSQL注入\n把SQL命令插入到表单或输入URL查询字符串提交，欺骗服务器达到执行恶意的SQL目的 XSS(Cross Site Script)，跨站脚本攻击\n攻击者在页面里插入恶意代码，当用户浏览该页之时，执行嵌入的恶意代码达到攻击目的 CSRF(Cross Site Request Forgery)，跨站点伪造请求\n伪造合法请求，让用户在不知情的情况下以登录的身份访问，利用用户信任达到攻击目的 如何防范 Web 前端攻击？\n不要信任任何外部传入的数据\n针对用户输入作相关的格式检查、过滤等操作 不要信任在任何传入的第三方数据\n使用 CORS，设置 Access-Control-Allow-Origin 更安全地使用 Cookie\n设置Cookie为HttpOnly，禁止了JavaScript操作Cookie 防止网页被其他网站内嵌为iframe\n服务器端设置 X-Frame-Options 响应头，防止页面被内嵌 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230802-web%E5%AE%89%E5%85%A8/","summary":"常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的","title":"web安全"},{"content":"异步编程 异步操作 Node 采用 Chrome V8 引擎处理 JavaScript 脚本。V8 最大特点就是单线程运行，一次只能运行一个任务。\nNode 大量采用异步操作（asynchronous operation），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。\n提高代码的响应能力。\n异步IO也叫非阻塞IO。例如读文件，传统的语言，基本都是读取完毕才能进行下一步操作。非阻塞就是Node的callback，不会影响下一步操作，等到文件读取完毕，回调函数自动被执行，而不是在等待。\n异步操作回调 由于系统永远不知道用户什么时候会输入内容，所以代码不能永远停在一个地方。\nNode 中的操作方式就是以异步回调的方式解决无状态的问题。\n回调函数的设计：错误优先 异步操作中，无法通过 try catch 捕获异常。\n这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try…catch对于异步操作行不通，所以只能把错误交给回调函数处理。\n统一约定：\n回调函数的第一个参数默认接收错误信息，第二个参数才是真正的回调数据（便于外界获取调用的错误情况）：\n1 2 3 4 foo1(\u0026#39;赵小黑\u0026#39;, 19, function(error, data) { if(error) throw error; console.log(data); }); 异步回调的问题 相比较于传统的代码：\n异步事件驱动的代码\n不容易阅读\n不容易调试\n不容易维护\n另外还有个问题是回调地狱：\n1 2 3 4 5 6 7 8 9 10 11 do1(function() { do2(function() { do3(function() { do4(function() { do5(function() { do6() }); }); }); }); }); 进程和线程 进程（进行中的程序） 每一个 正在运行 的应用程序都称之为进程。\n每一个应用程序运行都至少有一个进程。\n进程是用来给应用程序提供一个运行的环境。\n进程是操作系统为应用程序分配资源的一个单位。\n线程 用来执行应用程序中的代码\n在一个进程内部，可以有很多的线程\n在一个线程内部，同时只可以干一件事\n传统的开发方式大部分都是 I/O 阻塞的，所以需要多线程来更好的利用硬件资源。\n线程并不是越多越好。\n多线程的弊端 缺点一：\n- 创建线程耗费。 - 线程数量有限。 - CPU 在不同线程之间转换，有个上下文转换，这个转换非常耗时。 所谓的多线程其实都是假的，对于单核CPU而言，它们无非是在抢占 CPU 资源。线程和线程之间需要切换和调度，这是很耗费资源的。\n缺点二：\n线程之间共享某些数据，同步某个状态都很麻烦。 就算 CPU 是多核的，现在的问题是，线程与线程之间如果要共享数据，该怎么办？比如 A 线程要访问 B 线程的变量。\n事件驱动和非阻塞机制 参考链接：https://www.kancloud.cn/revin/nodejs/176211\n总结：\nNode 中将所有的阻塞操作交给了内部线程池实现。\nNode 主线程本身，主要就是不断的往返调度。\n平台实现差异 由于 Windows 和 *nix 平台（其他平台）的差异，Node 提供了 libuv 作为抽象封装层，保证上层的 Node 与下层的自定义线程池及 IOCP 之间各自独立。\n如下图所示：\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E5%92%8C%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%9C%BA%E5%88%B6/","summary":"异步编程 异步操作 Node 采用 Chrome V8 引擎处理 JavaScript 脚本。V8 最大特点就是单线程运行，一次只能运行一个任务。 Node 大量采用异步操作（asynchronous op","title":"事件驱动和非阻塞机制"},{"content":"1 前言 1.1 面向对象的三大特性 封装 继承 多态 1.2 原型链的知识 原型链是面向对象的基础，是非常重要的部分。有以下几种知识：\n创建对象有几种方法 原型、构造函数、实例、原型链 instanceof的原理 new 运算符 2 创建对象有几种方法 2.1 方式一：字面量 1 2 var obj11 = {name: \u0026#39;smyh\u0026#39;}; var obj12 = new Object(name: `smyh`); //内置对象（内置的构造函数） 上面的两种写法，效果是一样的。因为，第一种写法，obj11会指向Object。\n第一种写法是：字面量的方式。 第二种写法是：内置的构造函数 2.2 方式二：通过构造函数 1 2 3 4 var M = function (name) { this.name = name; } var obj3 = new M(\u0026#39;smyhvae\u0026#39;); 2.3 方法三：Object.create 1 2 var p = {name:\u0026#39;smyhvae\u0026#39;}; var obj3 = Object.create(p); //此方法创建的对象，是用原型链连接的 第三种方法，很少有人能说出来。这种方式里，obj3是实例，p是obj3的``原型（name是p原型里的属性），构造函数是Objecet` 。\n3 原型、构造函数、实例，以及原型链 PS：任何一个函数，如果在前面加了new，那就是构造函数。\n3.1 原型、构造函数、实例三者之间的关系 构造函数通过 new 生成实例 构造函数也是函数，构造函数的prototype指向原型。（所有的函数有prototype属性，但实例没有 prototype属性） 原型对象中有 constructor，指向该原型的构造函数。 上面的三行，代码演示：\n1 2 3 4 5 var Foo = function (name) { this.name = name; } var fn = new Foo(\u0026#39;smyhvae\u0026#39;); 上面的代码中，Foo.prototype.constructor === Foo的结果是true：\n实例的__proto__指向原型。也就是说，Foo.__proto__ === M.prototype。 声明：所有的引用类型（数组、对象、函数）都有__proto__这个属性。\nFoo.__proto__ === Function.prototype的结果为true，说明Foo这个普通的函数，是Function构造函数的一个实例。\n3.2 原型链 原型链的基本原理：任何一个实例，通过原型链，找到它上面的原型，该原型对象中的方法和属性，可以被所有的原型实例共享。\nObject是原型链的顶端。\n原型可以起到继承的作用。原型里的方法都可以被不同的实例共享： 1 2 3 4 //给Foo的原型添加 say 函数 Foo.prototype.say = function () { console.log(\u0026#39;\u0026#39;); } 原型链的关键：在访问一个实例的时候，如果实例本身没找到此方法或属性，就往原型上找。如果还是找不到，继续往上一级的原型上找。\n3.3 instanceof的原理 instanceof的作用：用于判断实例属于哪个构造函数。 instanceof的原理：判断实例对象的__proto__属性，和构造函数的prototype属性，是否为同一个引用（是否指向同一个地址）。 注意1：虽然说，实例是由构造函数 new 出来的，但是实例的__proto__属性引用的是构造函数的prototype。也就是说，实例的__proto__属性与构造函数本身无关。 注意2：在原型链上，原型的上面可能还会有原型，以此类推往上走，继续找__proto__属性。这条链上如果能找到， instanceof 的返回结果也是 true。 比如说：\nfoo instance of Foo的结果为true，因为foo.__proto__ === M.prototype为true。 foo instance of Objecet的结果也为true，为Foo.prototype.__proto__ === Object.prototype为true。 但我们不能轻易的说：foo 一定是 由Object创建的实例`。这句话是错误的。我们来看下一个问题就明白了。\n3.4 分析一个问题 问题：已知A继承了B，B继承了C。怎么判断 a 是由A直接生成的实例，还是B直接生成的实例呢？还是C直接生成的实例呢？\n分析：这就要用到原型的constructor属性了。\nfoo.__proto__.constructor === M的结果为true，但是 foo.__proto__.constructor === Object的结果为false。 所以，用 consturctor判断就比用 instanceof判断，更为严谨。 4 new 运算符 当new Foo()时发生了什么：\n创建一个新的空对象实例。 将此空对象的隐式原型指向其构造函数的显示原型。 执行构造函数（传入相应的参数，如果没有参数就不用传），同时 this 指向这个新实例。 如果返回值是一个新对象，那么直接返回该对象；如果无返回值或者返回一个非对象值，那么就将步骤（1）创建的对象返回。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/12%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","summary":"1 前言 1.1 面向对象的三大特性 封装 继承 多态 1.2 原型链的知识 原型链是面向对象的基础，是非常重要的部分。有以下几种知识： 创建对象有几种方法 原型、构造函","title":"创建对象和原型链"},{"content":"如何解决跨域问题 JSONP：\n原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function createJs(sUrl){ var oScript = document.createElement(\u0026#39;script\u0026#39;); oScript.type = \u0026#39;text/javascript\u0026#39;; oScript.src = sUrl; document.getElementsByTagName(\u0026#39;head\u0026#39;)[0].appendChild(oScript); } createJs(\u0026#39;jsonp.js\u0026#39;); box({ \u0026#39;name\u0026#39;: \u0026#39;test\u0026#39; }); function box(json){ alert(json.name); } CORS\n服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问 通过修改document.domain来跨子域\n将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。主域相同的使用document.domain 使用window.name来进行跨域\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据\n还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法 如何解决跨域问题?\njsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面\n如何解决跨域问题?\ndocument.domain + iframe：要求主域名相同 //只能跨子域 JSONP(JSON with Padding)``：response: callback(data)`` //只支持 GET 请求 跨域资源共享CORS(XHR2)``：Access-Control-Allow` //兼容性 IE10+ 跨文档消息传输(HTML5)：postMessage + onmessage //兼容性 IE8+ WebSocket(HTML5)：new WebSocket(url) + onmessage //兼容性 IE10+ 服务器端设置代理请求：服务器端不受同源策略限制 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","summary":"如何解决跨域问题 JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url","title":"如何解决跨域问题"},{"content":"1 前言 面试中的安全问题，明确来说，就两个方面：\nCSRF：基本概念、攻击方式、防御措施 XSS：基本概念、攻击方式、防御措施 这两个问题，一般不会问太难。\n有人问：SQL注入算吗？答案：这个其实跟前端的关系不是很大。\n2 CSRF 问的不难，一般问：\nCSRF的基本概念、缩写、全称 攻击原理 防御措施 如果把攻击原理和防御措施掌握好，基本没什么问题。\n2.1 CSRF的基本概念、缩写、全称 CSRF（Cross-site request forgery）：跨站请求伪造。\nPS：中文名一定要记住。英文全称，如果记不住也拉倒。\n2.2 CSRF的攻击原理 用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。\n从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：\n登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录） 在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。 我们在讲CSRF时，一定要把上面的两点说清楚。\n温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。\n举个例子，前段时间里，微博网站有个api接口有漏洞，导致很多用户的粉丝暴增。\n2.3 CSRF如何防御 方法一、Token 验证：（用的最多）\n服务器发送给客户端一个token； 客户端提交的表单中带着这个token。 如果这个 token 不合法，那么服务器拒绝这个请求。 方法二：隐藏令牌：\n把 token 隐藏在 http 的 head头中。 方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。\n方法三、Referer 验证：\nReferer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。\n3 XSS 3.1 XSS的基本概念 `XSS（Cross Site Scripting）``：跨域脚本攻击。\n接下来，我们详细讲一下 XSS 的内容。 预备知识：HTTP、Cookie、Ajax。\n3.2 XSS的攻击原理 XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。\n最后导致的结果可能是：\n盗用Cookie 破坏页面的正常结构，插入广告等恶意内容 D-doss攻击 3.3 XSS的攻击方式 反射型 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。\n存储型 存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。\n3.4 XSS的防范措施（encode + 过滤） XSS的防范措施主要有三个：\n1. 编码：\n对用户输入的数据进行HTML Entity编码。\n如上图所示，把字符转换成 转义字符。\nEncode的作用是将$var等一些字符进行转化，使得浏览器在最终输出结果上是一样的。\n比如说这段代码：\n1 \u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; 若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。\n进行编码处理之后，L在浏览器中的显示结果就是\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;，实现了将``$var作为纯文本进行输出，且不引起JavaScript`的执行。\n2、过滤：\n移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容） 移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。 3、校正\n避免直接对HTML Entity进行解码。 使用DOM Parse转换，校正不配对的DOM标签。 备注：我们应该去了解一下DOM Parse这个概念，它的作用是把文本解析成DOM结构。\n比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。\n还有一种简洁的答案：\n首先是encode，如果是富文本，就白名单。\n4 CSRF 和 XSS 的区别 面试官还可能喜欢问二者的区别。\n区别一：\nCSRF：需要用户先登录网站A，获取 cookie XSS：不需要登录。 区别二：（原理的区别）\nCSRF：是利用网站A本身的漏洞，去请求网站A的api。 XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/11%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98csrf%E5%92%8Cxss/","summary":"1 前言 面试中的安全问题，明确来说，就两个方面： CSRF：基本概念、攻击方式、防御措施 XSS：基本概念、攻击方式、防御措施 这两个问题，一般不会","title":"安全问题：CSRF和XSS"},{"content":"一、网络相关 1.1 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP 1 \u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;//yuchengkai.cn\u0026#34;\u0026gt; 1.2 缓存 缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度 通常浏览器缓存策略分为两种：强缓存和协商缓存 强缓存\n实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200\n1 Expires: Wed, 22 Oct 2018 08:41:00 GMT Expires 是 HTTP / 1.0 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效\n1 Cache-control: max-age=30 Cache-Control 出现于 HTTP / 1.1，优先级高于 Expires 。该属性表示资源会在 30 秒后过期，需要再次请求\n协商缓存\n如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304 协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式 Last-Modified 和 If-Modified-Since\nLast-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来 但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag ETag 和 If-None-Match\nETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高 选择合适的缓存策略\n对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略\n对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件 1.3 使用 HTTP / 2.0 因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小 1.4 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 1 \u0026lt;link rel=\u0026#34;preload\u0026#34; href=\u0026#34;http://example.com\u0026#34;\u0026gt; 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好\n1.5 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染\n1 \u0026lt;link rel=\u0026#34;prerender\u0026#34; href=\u0026#34;http://example.com\u0026#34;\u0026gt; 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染 二、优化渲染过程 2.1 懒执行 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒 2.2 懒加载 懒加载就是将不关键的资源延后加载 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载\n懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","summary":"一、网络相关 1.1 DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP 1 \u0026lt;link rel=\u0026#34;dns-prefetch\u0026#34; href=\u0026#34;//yuchengkai.cn\u0026#34;\u0026gt; 1.2 缓存 缓存对于前端性能优化来说是个很重要的点","title":"性能优化"},{"content":" 阿里9年，我总结的前端架构演进3大阶段及团队管理心法 伟明的推荐，说是对前端开发的价值观形成有良好的影响。\n前端开发面试题 在逛公众号「前端大全」的时候发现的，然后顺着找到了对应的GitHub链接。面试题有答案哦。\n你可能不需要 Vuex 2017-08-01 资深Web技术专家曹刘阳：2016年前端技术观察 有很多争议，知乎上都有人评论了。\n2017-08-16 道阻且长啊TAT(前端面试总结) 作者毕业于华科，面的是前端的实习，还拿了不少offer：百度外卖，头条，美团，狗东，其他，最终在美团实习。我最初是在微信公众号上看到的文章。\nhello。我看你拿了不少实习offer。有没有推荐的前端学习资料呀？比如说：网站、链接、书籍等。可否分享给我？如果内容较多，欢迎发表成博客。谢啦～～～\n2017-08-17 面试分享：一年经验初探阿里巴巴前端社招 在公众号「web前端课程」上看到的文章。作者经历了4面，也是厉害了。另外，作者在gihub上的博客也是出彩的。比如说下面这篇文章就值得推荐：\n挖 \u0026ldquo;掘\u0026rdquo; 淘 \u0026ldquo;金\u0026rdquo; 之 前端闯关历险记学习资料汇总 作者搜集了几百篇在掘金上看到的好文章，让人惊叹。\n2017-09-15 你所不知道的 CSS 滤镜技巧与细节 2017-09-19 适合程序员的写作技法 写作过程包括下面的部分：\n需求 设计 实现 测试 交付 2018-01-09 翻译 | 像 JavaScript 一样思考 在MacTalk的小密圈里看到有人分享。\n大前端公共知识杂谈\n小白谈数据脱敏\n2018-01-10 MAC全栈开发环境搭建指南 今天发现这个网址，感觉还不错。在里面发现了一个比较好的Sublime Text主题。\n介绍几个上网+分流+图床工具 2018-01-12 张鑫旭 | 话说我为什么要闭关学习 作者闭关学习了半年的前端。\n2018-01-17 你的简历能帮你争取到面试机会吗\n漫话JavaScript与异步·第三话——Generator：化异步为同步\n2017-01-19 一个三年工作经验的软件工程师的经验之谈 2018-01-22 前端程序员容易忽视的一些基础知识 2018-01-23 2018 前端趋势：更一致，更简单 2018-01-24 推荐一个网站，名叫：web骇客。网址：http://www.webhek.com/\n比如：\n电影里敲代码的样子：http://www.webhek.com/post/hackertyper.html\n测试眼睛对颜色的敏感程度：http://www.webhek.com/post/color-test.html\n2018-01-25 面试分享：一年经验初探阿里巴巴前端社招 一般阿里社招都是招3-5年的P6+高级工程师。面试官明知道作者只有一年工作经验，在面了这么多轮之后却来一句：“我们只要高工”。这是不是太欺负人了？\n2018-01-28 WEB前端工作五年了，我来告诉你如何系统的学习现在的JAVASCRIPT 2018-01-29 最棒的 JavaScript 学习指南（2018版）\n我们为什么选择Vue.js而不是React\n【长文慎入】通信十年—通信行业分析与跳槽之路\n我在深圳南山写代码：是在改变世界还是养家糊口\n我所理解的前端\n开发人员的奋斗目标\n十倍效能提升——Web 基础研发体系的建立\n长期写博客的人，最少能证明他是一个善于思考和总结的人。\n这句话的来源：我依然坚持建议你开始写博客 | 写给我的 2017\n不谈面试题，谈谈招聘时我喜欢见到的特质\nJerry和您聊聊Chrome开发者工具\nWhat makes a good front end engineer\n一个bit一个bit的进行 Base64 白话科普，看不懂算你输\n技术的热门度曲线\n浅谈XXE攻击\n关于XXE攻击，这几天微信支付被爆出漏洞，使用微信支付的各个业务都在努力修补。\n《博客园美化教程大集合\u0026mdash;-极致个性化你的专属博客（超详细，看这篇就够了）》\nhttps://www.yuque.com/sxc/front/kvokg4\n作者在语雀上的系列文章，都值得一看。\n前端学习网站和资源推荐 ","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/2019-%E6%8E%A8%E8%8D%90%E6%96%87%E7%AB%A0/","summary":"阿里9年，我总结的前端架构演进3大阶段及团队管理心法 伟明的推荐，说是对前端开发的价值观形成有良好的影响。 前端开发面试题 在逛公众号「前端大全」","title":"推荐文章"},{"content":"说说你对AMD和Commonjs的理解\nCommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 模块化开发怎么做？\n立即执行函数,不暴露私有成员 1 2 3 4 5 6 7 8 9 10 11 12 13 var module1 = (function(){ var _count = 0; var m1 = function(){ //... }; var m2 = function(){ //... }; return { m1 : m1, m2 : m2 }; })(); AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？\nAsynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // CMD define(function(require, exports, module) { var a = require(\u0026#39;./a\u0026#39;) a.doSomething() // 此处略去 100 行 var b = require(\u0026#39;./b\u0026#39;) // 依赖可以就近书写 b.doSomething() // ... }) // AMD 默认推荐 define([\u0026#39;./a\u0026#39;, \u0026#39;./b\u0026#39;], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ... }) 对前端模块化的认识\nAMD 是 RequireJS 在推广过程中对模块定义的规范化产出 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出 AMD 是提前执行，CMD 是延迟执行 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-%E6%A8%A1%E5%9D%97%E5%8C%96/","summary":"说说你对AMD和Commonjs的理解 CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步","title":"模块化"},{"content":"二、跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败\n2.1 JSONP JSONP 的原理很简单，就是利用 script标签没有跨域限制的漏洞。通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时\n1 2 3 4 5 6 \u0026lt;script src=\u0026#34;http://domain/api?param1=a\u0026amp;param2=b\u0026amp;callback=jsonp\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; function jsonp(data) { console.log(data) } \u0026lt;/script\u0026gt; JSONP 使用简单且兼容性不错，但是只限于 get 请求 2.2 CORS CORS需要浏览器和后端同时支持 浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源 2.3 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域 2.4 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n1 2 3 4 5 6 7 8 9 10 11 // 发送消息端 window.parent.postMessage(\u0026#39;message\u0026#39;, \u0026#39;http://test.com\u0026#39;); // 接收消息端 var mc = new MessageChannel(); mc.addEventListener(\u0026#39;message\u0026#39;, (event) =\u0026gt; { var origin = event.origin || event.originalEvent.origin; if (origin === \u0026#39;http://test.com\u0026#39;) { console.log(\u0026#39;验证通过\u0026#39;) } }); 三、Event loop 3.1 JS中的event loop 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）\nJS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 1 2 3 4 5 6 7 console.log(\u0026#39;script start\u0026#39;); setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); console.log(\u0026#39;script end\u0026#39;); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 console.log(\u0026#39;script start\u0026#39;); setTimeout(function() { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); new Promise((resolve) =\u0026gt; { console.log(\u0026#39;Promise\u0026#39;) resolve() }).then(function() { console.log(\u0026#39;promise1\u0026#39;); }).then(function() { console.log(\u0026#39;promise2\u0026#39;); }); console.log(\u0026#39;script end\u0026#39;); // script start =\u0026gt; Promise =\u0026gt; script end =\u0026gt; promise1 =\u0026gt; promise2 =\u0026gt; setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务\n微任务\nprocess.nextTick promise Object.observe MutationObserver 宏任务\nscript setTimeout setInterval setImmediate I/O UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务\n所以正确的一次 Event loop 顺序是这样的\n执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中\n3.2 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ┌───────────────────────┐ ┌─\u0026gt;│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │\u0026lt;──connections─── │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ timer\ntimers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟 I/O\nI/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle, prepare idle, prepare 阶段内部实现\npoll\npoll 阶段很重要，这一阶段中，系统会做两件事情\n执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情\n如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check\ncheck 阶段执行 setImmediate close callbacks\nclose callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 1 2 3 4 5 6 7 8 9 10 setTimeout(() =\u0026gt; { console.log(\u0026#39;setTimeout\u0026#39;); }, 0); setImmediate(() =\u0026gt; { console.log(\u0026#39;setImmediate\u0026#39;); }) // 这里可能会输出 setTimeout，setImmediate // 可能也会相反的输出，这取决于性能 // 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate // 否则会执行 setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 setTimeout(()=\u0026gt;{ console.log(\u0026#39;timer1\u0026#39;) Promise.resolve().then(function() { console.log(\u0026#39;promise1\u0026#39;) }) }, 0) setTimeout(()=\u0026gt;{ console.log(\u0026#39;timer2\u0026#39;) Promise.resolve().then(function() { console.log(\u0026#39;promise2\u0026#39;) }) }, 0) // 以上代码在浏览器和 node 中打印情况是不同的 // 浏览器中一定打印 timer1, promise1, timer2, promise2 // node 中可能打印 timer1, timer2, promise1, promise2 // 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行\n1 2 3 4 5 6 7 8 9 10 11 12 setTimeout(() =\u0026gt; { console.log(\u0026#34;timer1\u0026#34;); Promise.resolve().then(function() { console.log(\u0026#34;promise1\u0026#34;); }); }, 0); process.nextTick(() =\u0026gt; { console.log(\u0026#34;nextTick\u0026#34;); }); // nextTick, timer1, promise1 四、Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API\n目前该技术通常用来做缓存文件，提高首屏速度\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(\u0026#34;sw.js\u0026#34;) .then(function(registration) { console.log(\u0026#34;service worker 注册成功\u0026#34;); }) .catch(function(err) { console.log(\u0026#34;servcie worker 注册失败\u0026#34;); }); } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener(\u0026#34;install\u0026#34;, e =\u0026gt; { e.waitUntil( caches.open(\u0026#34;my-cache\u0026#34;).then(function(cache) { return cache.addAll([\u0026#34;./index.html\u0026#34;, \u0026#34;./index.js\u0026#34;]); }) ); }); // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener(\u0026#34;fetch\u0026#34;, e =\u0026gt; { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response; } console.log(\u0026#34;fetch source\u0026#34;); }) ); }); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了\n在 Cache 中也可以发现我们所需的文件已被缓存\n当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的\n五、渲染机制 浏览器的渲染机制一般分为以下几个步骤\n处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM 5.1 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用\n通过以下几个常用属性可以生成新图层\n3D 变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 5.2 重绘（Repaint）和回流（Reflow） 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流\n所以以下几个动作可能会导致性能问题：\n改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关\n当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调 减少重绘和回流\n使用 translate 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层 ","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/","summary":"二、跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败 2.1 JSONP JSONP 的原理很简单，就是利","title":"浏览器"},{"content":"硅谷甄选 技术栈包含: vue3+TypeScript+vue-router+pinia+element-plus+axios+echarts 等技术栈。\n一、vue3 组件通信方式 通信仓库地址: https://gitee.com/jch1011/vue3_communication.git\n不管是 vue2 还是 vue3,组件通信方式很重要,不管是项目还是面试都是经常用到的知识点。 比如:vue2 组件通信方式\nprops: 可以实现父子组件、子父组件、甚至兄弟组件通信 自定义事件: 可以实现子父组件通信 全局事件总线$bus: 可以实现任意组件通信 pubsub: 发布订阅模式实现任意组件通信 vuex: 集中式状态管理容器，实现任意组件通信 ref: 父组件获取子组件实例 VC,获取子组件的响应式数据以及方法 slot: 插槽(默认插槽、具名插槽、作用域插槽)实现父子组件通信\u0026hellip;\u0026hellip;.. 1.1 props props 可以实现父子组件通信,在 vue3 中我们可以通过 defineProps 获取父组件传递的数据。且在组件内部不需要引入 defineProps 方法可以直接使用！\n父组件给子组件传递数据\n1 \u0026lt;Child info=\u0026#34;我爱祖国\u0026#34; :money=\u0026#34;money\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 子组件获取父组件传递数据:方式 1\n1 2 3 4 5 6 7 8 9 10 let props = defineProps({ info: { type: String, //接受的数据类型 default: \u0026#39;默认参数\u0026#39;, //接受默认数据 }, money: { type: Number, default: 0, }, }) 子组件获取父组件传递数据:方式 2\n1 let props = defineProps([\u0026#39;info\u0026#39;, \u0026#39;money\u0026#39;]) 子组件获取到 props 数据就可以在模板中使用了,但是切记 props 是只读的(只能读取，不能修改)\n1.2 自定义事件 在 vue 框架中事件分为两种:一种是原生的 DOM 事件，另外一种自定义事件。\n原生 DOM 事件可以让用户与网页进行交互，比如 click、dbclick、change、mouseenter、mouseleave\u0026hellip;.\n自定义事件可以实现子组件给父组件传递数据\n1.2.1 原生 DOM 事件 代码如下:\n1 2 3 4 \u0026lt;pre @click=\u0026#34;handler\u0026#34;\u0026gt; 我是祖国的老花骨朵 \u0026lt;/pre \u0026gt; 当前代码级给 pre 标签绑定原生 DOM 事件点击事件,默认会给事件回调注入 event 事件对象。当然点击事件想注入多个参数可以按照下图操作。但是切记注入的事件对象务必叫做$event.\n1 \u0026lt;div @click=\u0026#34;handler1(1,2,3,$event)\u0026#34;\u0026gt;我要传递多个参数\u0026lt;/div\u0026gt; 在 vue3 框架 click、dbclick、change(这类原生 DOM 事件),不管是在标签、自定义标签上(组件标签)都是原生 DOM 事件。\n1.2.2 自定义事件 自定义事件可以实现子组件给父组件传递数据.在项目中是比较常用的。\n比如在父组件内部给子组件(Event2)绑定一个自定义事件\n1 \u0026lt;Event2 @xxx=\u0026#34;handler3\u0026#34;\u0026gt;\u0026lt;/Event2\u0026gt; 在 Event2 子组件内部触发这个自定义事件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;我是子组件2\u0026lt;/h1\u0026gt; \u0026lt;button @click=\u0026#34;handler\u0026#34;\u0026gt;点击我触发xxx自定义事件\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; let $emit = defineEmits([\u0026#39;xxx\u0026#39;]) const handler = () =\u0026gt; { $emit(\u0026#39;xxx\u0026#39;, \u0026#39;法拉利\u0026#39;, \u0026#39;茅台\u0026#39;) } \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 我们会发现在 script 标签内部,使用了 defineEmits 方法，此方法是 vue3 提供的方法,不需要引入直接使用。defineEmits 方法执行，传递一个数组，数组元素即为将来组件需要触发的自定义事件类型，此方执行会返回一个$emit 方法用于触发自定义事件。\n当点击按钮的时候，事件回调内部调用$emit 方法去触发自定义事件,第一个参数为触发事件类型，第二个、三个、N 个参数即为传递给父组件的数据。\n需要注意的是:代码如下\n1 \u0026lt;Event2 @xxx=\u0026#34;handler3\u0026#34; @click=\u0026#34;handler\u0026#34;\u0026gt;\u0026lt;/Event2\u0026gt; 正常说组件标签书写@click 应该为原生 DOM 事件,但是如果子组件内部通过 defineEmits 定义就变为自定义事件了\n1 let $emit = defineEmits([\u0026#39;xxx\u0026#39;, \u0026#39;click\u0026#39;]) 1.3 全局事件总线 全局事件总线可以实现任意组件通信，在 vue2 中可以根据 VM 与 VC 关系推出全局事件总线。\n但是在 vue3 中没有 Vue 构造函数，也就没有 Vue.prototype.以及组合式 API 写法没有 this，\n那么在 Vue3 想实现全局事件的总线功能就有点不现实啦，如果想在 Vue3 中使用全局事件总线功能\n可以使用插件 mitt 实现。\nmitt:官网地址: https://www.npmjs.com/package/mitt\n1.4 v-model v-model 指令可是收集表单数据(数据双向绑定)，除此之外它也可以实现父子组件数据同步。\n而 v-model 实指利用 props[modelValue]与自定义事件[update:modelValue]实现的。\n下方代码:相当于给组件 Child 传递一个 props(modelValue)与绑定一个自定义事件 update:modelValue\n实现父子组件数据同步\n1 \u0026lt;Child v-model=\u0026#34;msg\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 在 vue3 中一个组件可以通过使用多个 v-model,让父子组件多个数据同步,下方代码相当于给组件 Child 传递两个 props 分别是 pageNo 与 pageSize，以及绑定两个自定义事件 update:pageNo 与 update:pageSize 实现父子数据同步\n1 \u0026lt;Child v-model:pageNo=\u0026#34;msg\u0026#34; v-model:pageSize=\u0026#34;msg1\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 1.5 useAttrs 在 Vue3 中可以利用 useAttrs 方法获取组件的属性与事件(包含:原生 DOM 事件或者自定义事件),次函数功能类似于 Vue2 框架中$attrs属性与$listeners 方法。\n比如:在父组件内部使用一个子组件 my-button\n1 2 3 4 5 6 \u0026lt;my-button type=\u0026#34;success\u0026#34; size=\u0026#34;small\u0026#34; title=\u0026#34;标题\u0026#34; @click=\u0026#34;handler\u0026#34; \u0026gt;\u0026lt;/my-button\u0026gt; 子组件内部可以通过 useAttrs 方法获取组件属性与事件.因此你也发现了，它类似于 props,可以接受父组件传递过来的属性与属性值。需要注意如果 defineProps 接受了某一个属性，useAttrs 方法返回的对象身上就没有相应属性与属性值。\n1 2 3 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {useAttrs} from \u0026#39;vue\u0026#39;; let $attrs = useAttrs(); \u0026lt;/script\u0026gt; 1.6 ref 与$parent ref,提及到 ref 可能会想到它可以获取元素的 DOM 或者获取子组件实例的 VC。既然可以在父组件内部通过 ref 获取子组件实例 VC，那么子组件内部的方法与响应式数据父组件可以使用的。\n比如:在父组件挂载完毕获取组件实例\n父组件内部代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;ref与$parent\u0026lt;/h1\u0026gt; \u0026lt;Son ref=\u0026#34;son\u0026#34;\u0026gt;\u0026lt;/Son\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Son from \u0026#39;./Son.vue\u0026#39; import { onMounted, ref } from \u0026#39;vue\u0026#39; const son = ref() onMounted(() =\u0026gt; { console.log(son.value) }) \u0026lt;/script\u0026gt; 但是需要注意，如果想让父组件获取子组件的数据或者方法需要通过 defineExpose 对外暴露,因为 vue3 中组件内部的数据对外“关闭的”，外部不能访问\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; //数据 let money = ref(1000); //方法 const handler = ()=\u0026gt;{ } defineExpose({ money, handler }) \u0026lt;/script\u0026gt; $parent 可以获取某一个组件的父组件实例 VC,因此可以使用父组件内部的数据与方法。必须子组件内部拥有一个按钮点击时候获取父组件实例，当然父组件的数据与方法需要通过 defineExpose 方法对外暴露\n1 \u0026lt;button @click=\u0026#34;handler($parent)\u0026#34;\u0026gt;点击我获取父组件实例\u0026lt;/button\u0026gt; 1.7 provide 与 inject provide[提供]\ninject[注入]\nvue3 提供两个方法 provide 与 inject,可以实现隔辈组件传递参数\n组件组件提供数据:\nprovide 方法用于提供数据，此方法执需要传递两个参数,分别提供数据的 key 与提供数据 value\n1 2 3 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {provide} from \u0026#39;vue\u0026#39; provide(\u0026#39;token\u0026#39;,\u0026#39;admin_token\u0026#39;); \u0026lt;/script\u0026gt; 后代组件可以通过 inject 方法获取数据,通过 key 获取存储的数值\n1 2 3 \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import {inject} from \u0026#39;vue\u0026#39; let token = inject(\u0026#39;token\u0026#39;); \u0026lt;/script\u0026gt; 1.8 pinia pinia 官网: https://pinia.web3doc.top/\npinia 也是集中式管理状态容器,类似于 vuex。但是核心概念没有 mutation、modules,使用方式参照官网\n1.9 slot 插槽：默认插槽、具名插槽、作用域插槽可以实现父子组件通信.\n默认插槽:\n在子组件内部的模板中书写 slot 全局组件标签\n1 2 3 4 5 6 7 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;slot\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 在父组件内部提供结构：Todo 即为子组件,在父组件内部使用的时候，在双标签内部书写结构传递给子组件\n注意开发项目的时候默认插槽一般只有一个\n1 2 3 \u0026lt;Todo\u0026gt; \u0026lt;h1\u0026gt;我是默认插槽填充的结构\u0026lt;/h1\u0026gt; \u0026lt;/Todo\u0026gt; 具名插槽：\n顾名思义，此插槽带有名字在组件内部留多个指定名字的插槽。\n下面是一个子组件内部,模板中留两个插槽\n1 2 3 4 5 6 7 8 9 10 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;todo\u0026lt;/h1\u0026gt; \u0026lt;slot name=\u0026#34;a\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;slot name=\u0026#34;b\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 父组件内部向指定的具名插槽传递结构。需要注意 v-slot：可以替换为#\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;slot\u0026lt;/h1\u0026gt; \u0026lt;Todo\u0026gt; \u0026lt;template v-slot:a\u0026gt; //可以用#a替换 \u0026lt;div\u0026gt;填入组件A部分的结构\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;template v-slot:b\u0026gt; //可以用#b替换 \u0026lt;div\u0026gt;填入组件B部分的结构\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Todo\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Todo from \u0026#39;./Todo.vue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 作用域插槽\n作用域插槽：可以理解为，子组件数据由父组件提供，但是子组件内部决定不了自身结构与外观(样式)\n子组件 Todo 代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;todo\u0026lt;/h1\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;!--组件内部遍历数组--\u0026gt; \u0026lt;li v-for=\u0026#34;(item,index) in todos\u0026#34; :key=\u0026#34;item.id\u0026#34;\u0026gt; \u0026lt;!--作用域插槽将数据回传给父组件--\u0026gt; \u0026lt;slot :$row=\u0026#34;item\u0026#34; :$index=\u0026#34;index\u0026#34;\u0026gt;\u0026lt;/slot\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; defineProps([\u0026#39;todos\u0026#39;]) //接受父组件传递过来的数据 \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 父组件内部代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;slot\u0026lt;/h1\u0026gt; \u0026lt;Todo :todos=\u0026#34;todos\u0026#34;\u0026gt; \u0026lt;template v-slot=\u0026#34;{$row,$index}\u0026#34;\u0026gt; \u0026lt;!--父组件决定子组件的结构与外观--\u0026gt; \u0026lt;span :style=\u0026#34;{color:$row.done?\u0026#39;green\u0026#39;:\u0026#39;red\u0026#39;}\u0026#34;\u0026gt;{{$row.title}}\u0026lt;/span\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;/Todo\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; import Todo from \u0026#39;./Todo.vue\u0026#39; import { ref } from \u0026#39;vue\u0026#39; //父组件内部数据 let todos = ref([ { id: 1, title: \u0026#39;吃饭\u0026#39;, done: true }, { id: 2, title: \u0026#39;睡觉\u0026#39;, done: false }, { id: 3, title: \u0026#39;打豆豆\u0026#39;, done: true }, ]) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 二、搭建后台管理系统模板 2.1 项目初始化 今天来带大家从 0 开始搭建一个 vue3 版本的后台管理系统。一个项目要有统一的规范，需要使用 eslint+stylelint+prettier 来对我们的代码质量做检测和修复，需要使用 husky 来做 commit 拦截，需要使用 commitlint 来统一提交规范，需要使用 preinstall 来统一包管理工具。\n下面我们就用这一套规范来初始化我们的项目，集成一个规范的模版。\n2.1.1 环境准备 node v16.14.2 pnpm 8.0.0 2.1.2 初始化项目 本项目使用 vite 进行构建，vite 官方中文文档参考：cn.vitejs.dev/guide/\npnpm:performant npm ，意味“高性能的 npm”。pnpm由 npm/yarn 衍生而来，解决了 npm/yarn 内部潜在的 bug，极大的优化了性能，扩展了使用场景。被誉为“最先进的包管理工具”\npnpm 安装指令\n1 npm i -g pnpm 项目初始化命令:\n1 pnpm create vite 进入到项目根目录 pnpm install 安装全部依赖.安装完依赖运行程序:pnpm run dev\n运行完毕项目跑在http://127.0.0.1:5173/,可以访问你得项目啦\n2.2 项目配置 一、eslint 配置 eslint 中文官网: http://eslint.cn/\nESLint 最初是由Nicholas C. Zakas 于 2013 年 6 月创建的开源项目。它的目标是提供一个插件化的javascript 代码检测工具\n首先安装 eslint\n1 pnpm i eslint -D 生成配置文件:.eslint.cjs\n1 npx eslint --init .eslint.cjs 配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 module.exports = { //运行环境 env: { browser: true, //浏览器端 es2021: true, //es2021 }, //规则继承 extends: [ //全部规则默认是关闭的,这个配置项开启推荐规则,推荐规则参照文档 //比如:函数不能重名、对象不能出现重复key \u0026#39;eslint:recommended\u0026#39;, //vue3语法规则 \u0026#39;plugin:vue/vue3-essential\u0026#39;, //ts语法规则 \u0026#39;plugin:@typescript-eslint/recommended\u0026#39;, ], //要为特定类型的文件指定处理器 overrides: [], //指定解析器:解析器 //Esprima 默认解析器 //Babel-ESLint babel解析器 //@typescript-eslint/parser ts解析器 parser: \u0026#39;@typescript-eslint/parser\u0026#39;, //指定解析器选项 parserOptions: { ecmaVersion: \u0026#39;latest\u0026#39;, //校验ECMA最新版本 sourceType: \u0026#39;module\u0026#39;, //设置为\u0026#34;script\u0026#34;（默认），或者\u0026#34;module\u0026#34;代码在ECMAScript模块中 }, //ESLint支持使用第三方插件。在使用插件之前，您必须使用npm安装它 //该eslint-plugin-前缀可以从插件名称被省略 plugins: [\u0026#39;vue\u0026#39;, \u0026#39;@typescript-eslint\u0026#39;], //eslint规则 rules: {}, } 1.1 vue3 环境代码校验插件 1 2 3 4 5 6 7 8 9 10 # 让所有与prettier规则存在冲突的Eslint rules失效，并使用prettier进行代码检查 \u0026#34;eslint-config-prettier\u0026#34;: \u0026#34;^8.6.0\u0026#34;, \u0026#34;eslint-plugin-import\u0026#34;: \u0026#34;^2.27.5\u0026#34;, \u0026#34;eslint-plugin-node\u0026#34;: \u0026#34;^11.1.0\u0026#34;, # 运行更漂亮的Eslint，使prettier规则优先级更高，Eslint优先级低 \u0026#34;eslint-plugin-prettier\u0026#34;: \u0026#34;^4.2.1\u0026#34;, # vue.js的Eslint插件（查找vue语法错误，发现错误指令，查找违规风格指南 \u0026#34;eslint-plugin-vue\u0026#34;: \u0026#34;^9.9.0\u0026#34;, # 该解析器允许使用Eslint校验所有babel code \u0026#34;@babel/eslint-parser\u0026#34;: \u0026#34;^7.19.1\u0026#34;, 安装指令\n1 pnpm install -D eslint-plugin-import eslint-plugin-vue eslint-plugin-node eslint-plugin-prettier eslint-config-prettier eslint-plugin-node @babel/eslint-parser 1.2 修改.eslintrc.cjs 配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // @see https://eslint.bootcss.com/docs/rules/ module.exports = { env: { browser: true, es2021: true, node: true, jest: true, }, /* 指定如何解析语法 */ parser: \u0026#39;vue-eslint-parser\u0026#39;, /** 优先级低于 parse 的语法解析配置 */ parserOptions: { ecmaVersion: \u0026#39;latest\u0026#39;, sourceType: \u0026#39;module\u0026#39;, parser: \u0026#39;@typescript-eslint/parser\u0026#39;, jsxPragma: \u0026#39;React\u0026#39;, ecmaFeatures: { jsx: true, }, }, /* 继承已有的规则 */ extends: [ \u0026#39;eslint:recommended\u0026#39;, \u0026#39;plugin:vue/vue3-essential\u0026#39;, \u0026#39;plugin:@typescript-eslint/recommended\u0026#39;, \u0026#39;plugin:prettier/recommended\u0026#39;, ], plugins: [\u0026#39;vue\u0026#39;, \u0026#39;@typescript-eslint\u0026#39;], /* * \u0026#34;off\u0026#34; 或 0 ==\u0026gt; 关闭规则 * \u0026#34;warn\u0026#34; 或 1 ==\u0026gt; 打开的规则作为警告（不影响代码执行） * \u0026#34;error\u0026#34; 或 2 ==\u0026gt; 规则作为一个错误（代码不能执行，界面报错） */ rules: { // eslint（https://eslint.bootcss.com/docs/rules/） \u0026#39;no-var\u0026#39;: \u0026#39;error\u0026#39;, // 要求使用 let 或 const 而不是 var \u0026#39;no-multiple-empty-lines\u0026#39;: [\u0026#39;warn\u0026#39;, { max: 1 }], // 不允许多个空行 \u0026#39;no-console\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;error\u0026#39; : \u0026#39;off\u0026#39;, \u0026#39;no-debugger\u0026#39;: process.env.NODE_ENV === \u0026#39;production\u0026#39; ? \u0026#39;error\u0026#39; : \u0026#39;off\u0026#39;, \u0026#39;no-unexpected-multiline\u0026#39;: \u0026#39;error\u0026#39;, // 禁止空余的多行 \u0026#39;no-useless-escape\u0026#39;: \u0026#39;off\u0026#39;, // 禁止不必要的转义字符 // typeScript (https://typescript-eslint.io/rules) \u0026#39;@typescript-eslint/no-unused-vars\u0026#39;: \u0026#39;error\u0026#39;, // 禁止定义未使用的变量 \u0026#39;@typescript-eslint/prefer-ts-expect-error\u0026#39;: \u0026#39;error\u0026#39;, // 禁止使用 @ts-ignore \u0026#39;@typescript-eslint/no-explicit-any\u0026#39;: \u0026#39;off\u0026#39;, // 禁止使用 any 类型 \u0026#39;@typescript-eslint/no-non-null-assertion\u0026#39;: \u0026#39;off\u0026#39;, \u0026#39;@typescript-eslint/no-namespace\u0026#39;: \u0026#39;off\u0026#39;, // 禁止使用自定义 TypeScript 模块和命名空间。 \u0026#39;@typescript-eslint/semi\u0026#39;: \u0026#39;off\u0026#39;, // eslint-plugin-vue (https://eslint.vuejs.org/rules/) \u0026#39;vue/multi-word-component-names\u0026#39;: \u0026#39;off\u0026#39;, // 要求组件名称始终为 “-” 链接的单词 \u0026#39;vue/script-setup-uses-vars\u0026#39;: \u0026#39;error\u0026#39;, // 防止\u0026lt;script setup\u0026gt;使用的变量\u0026lt;template\u0026gt;被标记为未使用 \u0026#39;vue/no-mutating-props\u0026#39;: \u0026#39;off\u0026#39;, // 不允许组件 prop的改变 \u0026#39;vue/attribute-hyphenation\u0026#39;: \u0026#39;off\u0026#39;, // 对模板中的自定义组件强制执行属性命名样式 }, } 1.3 .eslintignore 忽略文件 1 2 dist node_modules 1.4 运行脚本 package.json 新增两个运行脚本\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;lint\u0026#34;: \u0026#34;eslint src\u0026#34;, \u0026#34;fix\u0026#34;: \u0026#34;eslint src --fix\u0026#34;, } 二、配置prettier 有了 eslint，为什么还要有 prettier？eslint 针对的是 javascript，他是一个检测工具，包含 js 语法以及少部分格式问题，在 eslint 看来，语法对了就能保证代码正常运行，格式问题属于其次；\n而 prettier 属于格式化工具，它看不惯格式不统一，所以它就把 eslint 没干好的事接着干，另外，prettier 支持\n包含 js 在内的多种语言。\n总结起来，eslint 和 prettier 这俩兄弟一个保证 js 代码质量，一个保证代码美观。\n2.1 安装依赖包 1 pnpm install -D eslint-plugin-prettier prettier eslint-config-prettier 2.2 .prettierrc.json 添加规则 1 2 3 4 5 6 7 8 9 { \u0026#34;singleQuote\u0026#34;: true, \u0026#34;semi\u0026#34;: false, \u0026#34;bracketSpacing\u0026#34;: true, \u0026#34;htmlWhitespaceSensitivity\u0026#34;: \u0026#34;ignore\u0026#34;, \u0026#34;endOfLine\u0026#34;: \u0026#34;auto\u0026#34;, \u0026#34;trailingComma\u0026#34;: \u0026#34;all\u0026#34;, \u0026#34;tabWidth\u0026#34;: 2 } 2.3 .prettierignore 忽略文件 1 2 3 4 5 6 7 /dist/* /html/* .local /node_modules/** **/*.svg **/*.sh /public/* 通过 pnpm run lint 去检测语法，如果出现不规范格式,通过 pnpm run fix 修改\n三、配置 stylelint stylelint为 css 的 lint 工具。可格式化 css 代码，检查 css 语法错误与不合理的写法，指定 css 书写顺序等。\n我们的项目中使用 scss 作为预处理器，安装以下依赖：\n1 pnpm add sass sass-loader stylelint postcss postcss-scss postcss-html stylelint-config-prettier stylelint-config-recess-order stylelint-config-recommended-scss stylelint-config-standard stylelint-config-standard-vue stylelint-scss stylelint-order stylelint-config-standard-scss -D 3.1 .stylelintrc.cjs 配置文件 官网:https://stylelint.bootcss.com/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 // @see https://stylelint.bootcss.com/ module.exports = { extends: [ \u0026#39;stylelint-config-standard\u0026#39;, // 配置stylelint拓展插件 \u0026#39;stylelint-config-html/vue\u0026#39;, // 配置 vue 中 template 样式格式化 \u0026#39;stylelint-config-standard-scss\u0026#39;, // 配置stylelint scss插件 \u0026#39;stylelint-config-recommended-vue/scss\u0026#39;, // 配置 vue 中 scss 样式格式化 \u0026#39;stylelint-config-recess-order\u0026#39;, // 配置stylelint css属性书写顺序插件, \u0026#39;stylelint-config-prettier\u0026#39;, // 配置stylelint和prettier兼容 ], overrides: [ { files: [\u0026#39;**/*.(scss|css|vue|html)\u0026#39;], customSyntax: \u0026#39;postcss-scss\u0026#39;, }, { files: [\u0026#39;**/*.(html|vue)\u0026#39;], customSyntax: \u0026#39;postcss-html\u0026#39;, }, ], ignoreFiles: [ \u0026#39;**/*.js\u0026#39;, \u0026#39;**/*.jsx\u0026#39;, \u0026#39;**/*.tsx\u0026#39;, \u0026#39;**/*.ts\u0026#39;, \u0026#39;**/*.json\u0026#39;, \u0026#39;**/*.md\u0026#39;, \u0026#39;**/*.yaml\u0026#39;, ], /** * null =\u0026gt; 关闭该规则 * always =\u0026gt; 必须 */ rules: { \u0026#39;value-keyword-case\u0026#39;: null, // 在 css 中使用 v-bind，不报错 \u0026#39;no-descending-specificity\u0026#39;: null, // 禁止在具有较高优先级的选择器后出现被其覆盖的较低优先级的选择器 \u0026#39;function-url-quotes\u0026#39;: \u0026#39;always\u0026#39;, // 要求或禁止 URL 的引号 \u0026#34;always(必须加上引号)\u0026#34;|\u0026#34;never(没有引号)\u0026#34; \u0026#39;no-empty-source\u0026#39;: null, // 关闭禁止空源码 \u0026#39;selector-class-pattern\u0026#39;: null, // 关闭强制选择器类名的格式 \u0026#39;property-no-unknown\u0026#39;: null, // 禁止未知的属性(true 为不允许) \u0026#39;block-opening-brace-space-before\u0026#39;: \u0026#39;always\u0026#39;, //大括号之前必须有一个空格或不能有空白符 \u0026#39;value-no-vendor-prefix\u0026#39;: null, // 关闭 属性值前缀 --webkit-box \u0026#39;property-no-vendor-prefix\u0026#39;: null, // 关闭 属性前缀 -webkit-mask \u0026#39;selector-pseudo-class-no-unknown\u0026#39;: [ // 不允许未知的选择器 true, { ignorePseudoClasses: [\u0026#39;global\u0026#39;, \u0026#39;v-deep\u0026#39;, \u0026#39;deep\u0026#39;], // 忽略属性，修改element默认样式的时候能使用到 }, ], }, } 3.2 .stylelintignore 忽略文件 1 2 3 4 /node_modules/* /dist/* /html/* /public/* 3.3 运行脚本 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;lint:style\u0026#34;: \u0026#34;stylelint src/**/*.{css,scss,vue} --cache --fix\u0026#34; } 最后配置统一的 prettier 来格式化我们的 js 和 css，html 代码\n1 2 3 4 5 6 7 8 9 10 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite --open\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34;, \u0026#34;lint\u0026#34;: \u0026#34;eslint src\u0026#34;, \u0026#34;fix\u0026#34;: \u0026#34;eslint src --fix\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;prettier --write \\\u0026#34;./**/*.{html,vue,ts,js,json,md}\\\u0026#34;\u0026#34;, \u0026#34;lint:eslint\u0026#34;: \u0026#34;eslint src/**/*.{ts,vue} --cache --fix\u0026#34;, \u0026#34;lint:style\u0026#34;: \u0026#34;stylelint src/**/*.{css,scss,vue} --cache --fix\u0026#34; }, 当我们运行pnpm run format的时候，会把代码直接格式化\n四、配置 husky 在上面我们已经集成好了我们代码校验工具，但是需要每次手动的去执行命令才会格式化我们的代码。如果有人没有格式化就提交了远程仓库中，那这个规范就没什么用。所以我们需要强制让开发人员按照代码规范来提交。\n要做到这件事情，就需要利用 husky 在代码提交之前触发 git hook(git 在客户端的钩子)，然后执行pnpm run format来自动的格式化我们的代码。\n安装husky\n1 pnpm install -D husky 执行\n1 npx husky-init 会在根目录下生成个一个.husky 目录，在这个目录下面会有一个 pre-commit 文件，这个文件里面的命令在我们执行 commit 的时候就会执行\n在.husky/pre-commit文件添加如下命令：\n1 2 3 #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; pnpm run format 当我们对代码进行 commit 操作的时候，就会执行命令，对代码进行格式化，然后再提交。\n五、配置 commitlint 对于我们的 commit 信息，也是有统一规范的，不能随便写,要让每个人都按照统一的标准来执行，我们可以利用commitlint来实现。\n安装包\n1 pnpm add @commitlint/config-conventional @commitlint/cli -D 添加配置文件，新建commitlint.config.cjs(注意是 cjs)，然后添加下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 module.exports = { extends: [\u0026#39;@commitlint/config-conventional\u0026#39;], // 校验规则 rules: { \u0026#39;type-enum\u0026#39;: [ 2, \u0026#39;always\u0026#39;, [ \u0026#39;feat\u0026#39;, \u0026#39;fix\u0026#39;, \u0026#39;docs\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;refactor\u0026#39;, \u0026#39;perf\u0026#39;, \u0026#39;test\u0026#39;, \u0026#39;chore\u0026#39;, \u0026#39;revert\u0026#39;, \u0026#39;build\u0026#39;, ], ], \u0026#39;type-case\u0026#39;: [0], \u0026#39;type-empty\u0026#39;: [0], \u0026#39;scope-empty\u0026#39;: [0], \u0026#39;scope-case\u0026#39;: [0], \u0026#39;subject-full-stop\u0026#39;: [0, \u0026#39;never\u0026#39;], \u0026#39;subject-case\u0026#39;: [0, \u0026#39;never\u0026#39;], \u0026#39;header-max-length\u0026#39;: [0, \u0026#39;always\u0026#39;, 72], }, } 在package.json中配置 scripts 命令\n1 2 3 4 5 6 // 在scrips中添加下面的代码 { \u0026#34;scripts\u0026#34;: { \u0026#34;commitlint\u0026#34;: \u0026#34;commitlint --config commitlint.config.cjs -e -V\u0026#34; } } 配置结束，现在当我们填写commit信息的时候，前面就需要带着下面的subject\n1 2 3 4 5 6 7 8 9 10 \u0026#39;feat\u0026#39;,//新特性、新功能 \u0026#39;fix\u0026#39;,//修改bug \u0026#39;docs\u0026#39;,//文档修改 \u0026#39;style\u0026#39;,//代码格式修改, 注意不是 css 修改 \u0026#39;refactor\u0026#39;,//代码重构 \u0026#39;perf\u0026#39;,//优化相关，比如提升性能、体验 \u0026#39;test\u0026#39;,//测试用例修改 \u0026#39;chore\u0026#39;,//其他修改, 比如改变构建流程、或者增加依赖库、工具等 \u0026#39;revert\u0026#39;,//回滚到上一个版本 \u0026#39;build\u0026#39;,//编译相关的修改，例如发布版本、对项目构建或者依赖的改动 配置 husky\n1 npx husky add .husky/commit-msg 在生成的 commit-msg 文件中添加下面的命令\n1 2 3 #!/usr/bin/env sh . \u0026#34;$(dirname -- \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; pnpm commitlint 当我们 commit 提交信息时，就不能再随意写了，必须是 git commit -m \u0026lsquo;fix: xxx\u0026rsquo; 符合类型的才可以，需要注意的是类型的后面需要用英文的 :，并且冒号后面是需要空一格的，这个是不能省略的\n六、强制使用 pnpm 包管理器工具 团队开发项目的时候，需要统一包管理器工具,因为不同包管理器工具下载同一个依赖,可能版本不一样,\n导致项目出现 bug 问题,因此包管理器工具需要统一管理！！！\n在根目录创建scritps/preinstall.js文件，添加下面的内容\n1 2 3 4 5 6 7 if (!/pnpm/.test(process.env.npm_execpath || \u0026#39;\u0026#39;)) { console.warn( `\\u001b[33mThis repository must using pnpm as the package manager ` + ` for scripts to work properly.\\u001b[39m\\n`, ) process.exit(1) } 配置命令\n1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;preinstall\u0026#34;: \u0026#34;node ./scripts/preinstall.js\u0026#34; } 当我们使用 npm 或者 yarn 来安装包的时候，就会报错了。原理就是在 install 的时候会触发 preinstall（npm 提供的生命周期钩子）这个文件里面的代码。\n三、项目集成 3.1 集成 element-plus 硅谷甄选运营平台,UI 组件库采用的 element-plus，因此需要集成 element-plus 插件！！！\n官网地址:https://element-plus.gitee.io/zh-CN/\n1 pnpm install element-plus @element-plus/icons-vue 入口文件 main.ts 全局安装 element-plus,element-plus 默认支持语言英语设置为中文\n1 2 3 4 5 6 7 import ElementPlus from \u0026#39;element-plus\u0026#39; import \u0026#39;element-plus/dist/index.css\u0026#39; //@ts-ignore忽略当前文件ts类型的检测否则有红色提示(打包会失败) import zhCn from \u0026#39;element-plus/dist/locale/zh-cn.mjs\u0026#39; app.use(ElementPlus, { locale: zhCn, }) Element Plus 全局组件类型声明\n1 2 3 4 5 6 7 // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { // ... \u0026#34;types\u0026#34;: [\u0026#34;element-plus/global\u0026#34;] } } 配置完毕可以测试 element-plus 组件与图标的使用.\n3.2 src 别名的配置 在开发项目的时候文件与文件关系可能很复杂，因此我们需要给 src 文件夹配置一个别名！！！\n1 2 3 4 5 6 7 8 9 10 11 12 // vite.config.ts import { defineConfig } from \u0026#39;vite\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; import path from \u0026#39;path\u0026#39; export default defineConfig({ plugins: [vue()], resolve: { alias: { \u0026#39;@\u0026#39;: path.resolve(\u0026#39;./src\u0026#39;), // 相对路径别名配置，使用 @ 代替 src }, }, }) TypeScript 编译配置\n1 2 3 4 5 6 7 8 9 10 // tsconfig.json { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 解析非相对模块的基地址，默认是当前目录 \u0026#34;paths\u0026#34;: { //路径映射，相对于baseUrl \u0026#34;@/*\u0026#34;: [\u0026#34;src/*\u0026#34;] } } } 3.3 环境变量的配置 项目开发过程中，至少会经历开发环境、测试环境和生产环境(即正式环境)三个阶段。不同阶段请求的状态(如接口地址等)不尽相同，若手动切换接口地址是相当繁琐且易出错的。于是环境变量配置的需求就应运而生，我们只需做简单的配置，把环境状态切换的工作交给代码。\n开发环境（development） 顾名思义，开发使用的环境，每位开发人员在自己的 dev 分支上干活，开发到一定程度，同事会合并代码，进行联调。\n测试环境（testing） 测试同事干活的环境啦，一般会由测试同事自己来部署，然后在此环境进行测试\n生产环境（production） 生产环境是指正式提供对外服务的，一般会关掉错误报告，打开错误日志。(正式提供给客户使用的环境。)\n注意:一般情况下，一个环境对应一台服务器,也有的公司开发与测试环境是一台服务器！！！\n项目根目录分别添加 开发、生产和测试环境的文件!\n1 2 3 .env.development .env.production .env.test 文件内容\n1 2 3 4 # 变量必须以 VITE_ 为前缀才能暴露给外部读取 NODE_ENV = \u0026#39;development\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/dev-api\u0026#39; 1 2 3 NODE_ENV = \u0026#39;production\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/prod-api\u0026#39; 1 2 3 4 # 变量必须以 VITE_ 为前缀才能暴露给外部读取 NODE_ENV = \u0026#39;test\u0026#39; VITE_APP_TITLE = \u0026#39;硅谷甄选运营平台\u0026#39; VITE_APP_BASE_API = \u0026#39;/test-api\u0026#39; 配置运行命令：package.json\n1 2 3 4 5 6 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;vite --open\u0026#34;, \u0026#34;build:test\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build --mode test\u0026#34;, \u0026#34;build:pro\u0026#34;: \u0026#34;vue-tsc \u0026amp;\u0026amp; vite build --mode production\u0026#34;, \u0026#34;preview\u0026#34;: \u0026#34;vite preview\u0026#34; }, 通过 import.meta.env 获取环境变量\n3.4 SVG 图标配置 在开发项目的时候经常会用到 svg 矢量图,而且我们使用 SVG 以后，页面上加载的不再是图片资源,\n这对页面性能来说是个很大的提升，而且我们 SVG 文件比 img 要小的很多，放在项目中几乎不占用资源。\n安装 SVG 依赖插件\n1 pnpm install vite-plugin-svg-icons -D 在vite.config.ts中配置插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import { createSvgIconsPlugin } from \u0026#39;vite-plugin-svg-icons\u0026#39; import path from \u0026#39;path\u0026#39; export default () =\u0026gt; { return { plugins: [ createSvgIconsPlugin({ // Specify the icon folder to be cached iconDirs: [path.resolve(process.cwd(), \u0026#39;src/assets/icons\u0026#39;)], // Specify symbolId format symbolId: \u0026#39;icon-[dir]-[name]\u0026#39;, }), ], } } 入口文件导入\n1 import \u0026#39;virtual:svg-icons-register\u0026#39; 3.4.1 svg 封装为全局组件 因为项目很多模块需要使用图标,因此把它封装为全局组件！！！\n在 src/components 目录下创建一个 SvgIcon 组件:代表如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;svg :style=\u0026#34;{ width: width, height: height }\u0026#34;\u0026gt; \u0026lt;use :xlink:href=\u0026#34;prefix + name\u0026#34; :fill=\u0026#34;color\u0026#34;\u0026gt;\u0026lt;/use\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup lang=\u0026#34;ts\u0026#34;\u0026gt; defineProps({ //xlink:href属性值的前缀 prefix: { type: String, default: \u0026#39;#icon-\u0026#39;, }, //svg矢量图的名字 name: String, //svg图标的颜色 color: { type: String, default: \u0026#39;\u0026#39;, }, //svg宽度 width: { type: String, default: \u0026#39;16px\u0026#39;, }, //svg高度 height: { type: String, default: \u0026#39;16px\u0026#39;, }, }) \u0026lt;/script\u0026gt; \u0026lt;style scoped\u0026gt;\u0026lt;/style\u0026gt; 在 src 文件夹目录下创建一个 index.ts 文件：用于注册 components 文件夹内部全部全局组件！！！\n1 2 3 4 5 6 7 8 9 10 import SvgIcon from \u0026#39;./SvgIcon/index.vue\u0026#39; import type { App, Component } from \u0026#39;vue\u0026#39; const components: { [name: string]: Component } = { SvgIcon } export default { install(app: App) { Object.keys(components).forEach((key: string) =\u0026gt; { app.component(key, components[key]) }) }, } 在入口文件引入 src/index.ts 文件,通过 app.use 方法安装自定义插件\n1 2 import gloablComponent from \u0026#39;./components/index\u0026#39; app.use(gloablComponent) 3.5 集成 sass 我们目前在组件内部已经可以使用 scss 样式,因为在配置 styleLint 工具的时候，项目当中已经安装过 sass sass-loader,因此我们再组件内可以使用 scss 语法！！！需要加上 lang=\u0026ldquo;scss\u0026rdquo;\n1 \u0026lt;style scoped lang=\u0026#34;scss\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; 接下来我们为项目添加一些全局的样式\n在 src/styles 目录下创建一个 index.scss 文件，当然项目中需要用到清除默认样式，因此在 index.scss 引入 reset.scss\n1 @import reset.scss 在入口文件引入\n1 import \u0026#39;@/styles\u0026#39; 但是你会发现在 src/styles/index.scss 全局样式文件中没有办法使用$变量.因此需要给项目中引入全局变量$.\n在 style/variable.scss 创建一个 variable.scss 文件！\n在 vite.config.ts 文件配置如下:\n1 2 3 4 5 6 7 8 9 10 11 export default defineConfig((config) =\u0026gt; { css: { preprocessorOptions: { scss: { javascriptEnabled: true, additionalData: \u0026#39;@import \u0026#34;./src/styles/variable.scss\u0026#34;;\u0026#39;, }, }, }, } } @import \u0026quot;./src/styles/variable.less\u0026quot;;后面的;不要忘记，不然会报错!\n配置完毕你会发现 scss 提供这些全局变量可以在组件样式中使用了！！！\n3.6 mock 数据 安装依赖:https://www.npmjs.com/package/vite-plugin-mock\n1 pnpm install -D vite-plugin-mock mockjs 在 vite.config.js 配置文件启用插件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 import { UserConfigExport, ConfigEnv } from \u0026#39;vite\u0026#39; import { viteMockServe } from \u0026#39;vite-plugin-mock\u0026#39; import vue from \u0026#39;@vitejs/plugin-vue\u0026#39; export default ({ command }) =\u0026gt; { return { plugins: [ vue(), viteMockServe({ localEnabled: command === \u0026#39;serve\u0026#39;, }), ], } } 在根目录创建 mock 文件夹:去创建我们需要 mock 数据与接口！！！\n在 mock 文件夹内部创建一个 user.ts 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 //用户信息数据 function createUserList() { return [ { userId: 1, avatar: \u0026#39;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026#39;, username: \u0026#39;admin\u0026#39;, password: \u0026#39;111111\u0026#39;, desc: \u0026#39;平台管理员\u0026#39;, roles: [\u0026#39;平台管理员\u0026#39;], buttons: [\u0026#39;cuser.detail\u0026#39;], routes: [\u0026#39;home\u0026#39;], token: \u0026#39;Admin Token\u0026#39;, }, { userId: 2, avatar: \u0026#39;https://wpimg.wallstcn.com/f778738c-e4f8-4870-b634-56703b4acafe.gif\u0026#39;, username: \u0026#39;system\u0026#39;, password: \u0026#39;111111\u0026#39;, desc: \u0026#39;系统管理员\u0026#39;, roles: [\u0026#39;系统管理员\u0026#39;], buttons: [\u0026#39;cuser.detail\u0026#39;, \u0026#39;cuser.user\u0026#39;], routes: [\u0026#39;home\u0026#39;], token: \u0026#39;System Token\u0026#39;, }, ] } export default [ // 用户登录接口 { url: \u0026#39;/api/user/login\u0026#39;, //请求地址 method: \u0026#39;post\u0026#39;, //请求方式 response: ({ body }) =\u0026gt; { //获取请求体携带过来的用户名与密码 const { username, password } = body //调用获取用户信息函数,用于判断是否有此用户 const checkUser = createUserList().find( (item) =\u0026gt; item.username === username \u0026amp;\u0026amp; item.password === password, ) //没有用户返回失败信息 if (!checkUser) { return { code: 201, data: { message: \u0026#39;账号或者密码不正确\u0026#39; } } } //如果有返回成功信息 const { token } = checkUser return { code: 200, data: { token } } }, }, // 获取用户信息 { url: \u0026#39;/api/user/info\u0026#39;, method: \u0026#39;get\u0026#39;, response: (request) =\u0026gt; { //获取请求头携带token const token = request.headers.token //查看用户信息是否包含有次token用户 const checkUser = createUserList().find((item) =\u0026gt; item.token === token) //没有返回失败的信息 if (!checkUser) { return { code: 201, data: { message: \u0026#39;获取用户信息失败\u0026#39; } } } //如果有返回成功信息 return { code: 200, data: { checkUser } } }, }, ] 安装 axios\n1 pnpm install axios 最后通过 axios 测试接口！！！\n3.7 axios 二次封装 在开发项目的时候避免不了与后端进行交互,因此我们需要使用 axios 插件实现发送网络请求。在开发项目的时候\n我们经常会把 axios 进行二次封装。\n目的:\n1:使用请求拦截器，可以在请求拦截器中处理一些业务(开始进度条、请求头携带公共参数)\n2:使用响应拦截器，可以在响应拦截器中处理一些业务(进度条结束、简化服务器返回的数据、处理 http 网络错误)\n在根目录下创建 utils/request.ts\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import axios from \u0026#39;axios\u0026#39; import { ElMessage } from \u0026#39;element-plus\u0026#39; //创建axios实例 let request = axios.create({ baseURL: import.meta.env.VITE_APP_BASE_API, timeout: 5000, }) //请求拦截器 request.interceptors.request.use((config) =\u0026gt; { return config }) //响应拦截器 request.interceptors.response.use( (response) =\u0026gt; { return response.data }, (error) =\u0026gt; { //处理网络错误 let msg = \u0026#39;\u0026#39; let status = error.response.status switch (status) { case 401: msg = \u0026#39;token过期\u0026#39; break case 403: msg = \u0026#39;无权访问\u0026#39; break case 404: msg = \u0026#39;请求地址错误\u0026#39; break case 500: msg = \u0026#39;服务器出现问题\u0026#39; break default: msg = \u0026#39;无网络\u0026#39; } ElMessage({ type: \u0026#39;error\u0026#39;, message: msg, }) return Promise.reject(error) }, ) export default request 3.8 API 接口统一管理 在开发项目的时候,接口可能很多需要统一管理。在 src 目录下去创建 api 文件夹去统一管理项目的接口；\n比如:下面方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 //统一管理咱们项目用户相关的接口 import request from \u0026#39;@/utils/request\u0026#39; import type { loginFormData, loginResponseData, userInfoReponseData, } from \u0026#39;./type\u0026#39; //项目用户相关的请求地址 enum API { LOGIN_URL = \u0026#39;/admin/acl/index/login\u0026#39;, USERINFO_URL = \u0026#39;/admin/acl/index/info\u0026#39;, LOGOUT_URL = \u0026#39;/admin/acl/index/logout\u0026#39;, } //登录接口 export const reqLogin = (data: loginFormData) =\u0026gt; request.post\u0026lt;any, loginResponseData\u0026gt;(API.LOGIN_URL, data) //获取用户信息 export const reqUserInfo = () =\u0026gt; request.get\u0026lt;any, userInfoReponseData\u0026gt;(API.USERINFO_URL) //退出登录 export const reqLogout = () =\u0026gt; request.post\u0026lt;any, any\u0026gt;(API.LOGOUT_URL) 四、项目的资源地址 贾成豪老师代码仓库地址:https://gitee.com/jch1011/vue3_admin_template-bj1.git\n项目在线文档:\n服务器域名:http://sph-api.atguigu.cn\nswagger 文档:\nhttp://139.198.104.58:8209/swagger-ui.html\nhttp://139.198.104.58:8212/swagger-ui.html#/\necharts:国内镜像网站\nhttps://www.isqqw.com/echarts-doc/zh/option.html#title\nhttp://datav.aliyun.com/portal/school/atlas/area_selector\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E7%A1%85%E8%B0%B7%E7%94%84%E9%80%89%E7%AC%94%E8%AE%B0/","summary":"硅谷甄选 技术栈包含: vue3+TypeScript+vue-router+pinia+element-plus+axios+echarts 等技术栈。 一、vue3 组件通信方式 通信仓库地址: https://gitee.com/jch1011/vue3_communication.git 不管是 vue2 还是 vue3,组件通信方式很重要,不管是项目还是面试都是经常","title":"浏览器"},{"content":"Whistle 官网 Whistle 官网：https://wproxy.org/whistle/\nWhistle 的 GitHub：https://github.com/avwo/whistle\nWhistle 安装启动 1、Whistle 安装 （1）通过 npm 安装 Whistle\n2、启动 whistle 1 w2 start 然后在浏览器输入http://127.0.0.1:8899/ 即可打开代理配置的页面。\n3、配置代理 chrome浏览器配置代理：\n暂略。\nFirefox浏览器配置代理：\n4、安装证书并添加信任： 手机设置代理 连接好指定的wifi后，点击那个wifi里的设置，将「代理」那一项，设置为手动，然后输入ip（电脑上的ip）、端口号（8899）。然后就可以通过电脑上的whistle工具，查看手机的网页请求。\n注意，要保证手机和电脑在同一个网络下。\n捕获和拦截https请求 whistle安装证书后，可以拦截 https 请求。但是，我现在又不想拦截https请求了，该怎么卸载证书呢？\n我发现，证书无法卸载，正确的操作是：\n上图中，把红框部分，去掉勾选，就不捕获https了。谢谢azh童鞋。\n参考链接：\nAndroid 手机如何设置http代理？\n使用 Whistle 对 iOS HTTPS 进行抓包\n移动端调试神器:eruda 手机连接代理时，如何看console.log的日志信息?\n现在，代码里有console.log，如果是在电脑浏览器上看，可以直接在控制台查看console.log的内容。但是，如果手机连接代理，在手机上打开网页的话，要怎么查看console.log的内容呢？具体做法如下：\n（1）在 whistle中，新建一个名叫Eruda H5的代理，代理中的内容是：\n1 http://xxx.com htmlAppend://{eruda.html} (2)新建一个values，里面的内容是：\n1 2 3 4 \u0026lt;script src=\u0026#34;//cdn.bootcss.com/eruda/1.4.3/eruda.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; eruda.init() \u0026lt;/script\u0026gt; 然后就OK了。\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85%E5%92%8C%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7whistle/","summary":"Whistle 官网 Whistle 官网：https://wproxy.org/whistle/ Whistle 的 GitHub：https://github.com/avwo/whi","title":"网络抓包和代理工具：Whistle"},{"content":"一、CSS相关 1.1 左边定宽，右边自适应方案：float + margin，float + calc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 方案1 */ .left { width: 120px; float: left; } .right { margin-left: 120px; } /* 方案2 */ .left { width: 120px; float: left; } .right { width: calc(100% - 120px); float: left; } 1.2 左右两边定宽，中间自适应：float，float + calc, 圣杯布局（设置BFC，margin负值法），flex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 .wrap { width: 100%; height: 200px; } .wrap \u0026gt; div { height: 100%; } /* 方案1 */ .left { width: 120px; float: left; } .right { float: right; width: 120px; } .center { margin: 0 120px; } /* 方案2 */ .left { width: 120px; float: left; } .right { float: right; width: 120px; } .center { width: calc(100% - 240px); margin-left: 120px; } /* 方案3 */ .wrap { display: flex; } .left { width: 120px; } .right { width: 120px; } .center { flex: 1; } 1.3 左右居中 行内元素: text-align: center 定宽块状元素: 左右 margin 值为 auto 不定宽块状元素: table布局，position + transform 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /* 方案1 */ .wrap { text-align: center } .center { display: inline; /* or */ /* display: inline-block; */ } /* 方案2 */ .center { width: 100px; margin: 0 auto; } /* 方案2 */ .wrap { position: relative; } .center { position: absulote; left: 50%; transform: translateX(-50%); } 1.4 上下垂直居中 定高：margin，position + margin(负值) 不定高：position + transform，flex，IFC + vertical-align:middle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /* 定高方案1 */ .center { height: 100px; margin: 50px 0; } /* 定高方案2 */ .center { height: 100px; position: absolute; top: 50%; margin-top: -25px; } /* 不定高方案1 */ .center { position: absolute; top: 50%; transform: translateY(-50%); } /* 不定高方案2 */ .wrap { display: flex; align-items: center; } .center { width: 100%; } /* 不定高方案3 */ /* 设置 inline-block 则会在外层产生 IFC，高度设为 100% 撑开 wrap 的高度 */ .wrap::before { content: \u0026#39;\u0026#39;; height: 100%; display: inline-block; vertical-align: middle; } .wrap { text-align: center; } .center { display: inline-block; vertical-align: middle; } 1.5 盒模型：content（元素内容） + padding（内边距） + border（边框） + margin（外边距） 延伸： box-sizing\ncontent-box：默认值，总宽度 = margin + border + padding + width border-box：盒子宽度包含 padding 和 border，总宽度 = margin + width inherit：从父元素继承 box-sizing 属性 1.6 BFC、IFC、GFC、FFC：FC（Formatting Contexts），格式化上下文 BFC：块级格式化上下文，容器里面的子元素不会在布局上影响到外面的元素，反之也是如此(按照这个理念来想，只要脱离文档流，肯定就能产生 BFC)。产生 BFC 方式如下\nfloat 的值不为 none。 overflow 的值不为 visible。 position 的值不为 relative 和 static。 display 的值为 table-cell, table-caption, inline-block中的任何一个 用处？常见的多栏布局，结合块级别元素浮动，里面的元素则是在一个相对隔离的环境里运行\nIFC：内联格式化上下文，IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)。\nIFC中的line box一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同。 IFC中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div ）会产生两个匿名块与 div 分隔开，即产生两个 IFC ，每个 IFC 对外表现为块级元素，与 div 垂直排列。\n用处？\n水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生IFC，通过 text-align 则可以使其水平居中。 垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align: middle，其他行内元素则可以在此父元素下垂直居中 GFC：网格布局格式化上下文（display: grid） FFC：自适应格式化上下文（display: flex） 二、JS 基础（ES5） 2.1 原型 这里可以谈很多，只要围绕 [[ prototype ]] 谈，都没啥问题\n2.2 闭包 牵扯作用域，可以两者联系起来一起谈\n2.3 作用域 词法作用域，动态作用域\n2.4 this 不同情况的调用，this指向分别如何。顺带可以提一下 es6 中箭头函数没有 this, arguments, super 等，这些只依赖包含箭头函数最接近的函数\n2.5 call，apply，bind 三者用法和区别 参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call，apply 立即执行，bind 是return 出一个 this “固定”的函数，这也是为什么 bind 是强绑定的一个原因）\n注：“固定”这个词的含义，它指的固定是指只要传进去了 context，则 bind 中 return 出来的函数 this 便一直指向 context，除非 context 是个变量\n2.6 变量声明提升 js 代码在运行前都会进行 AST 解析，函数申明默认会提到当前作用域最前面，变量申明也会进行提升。但赋值不会得到提升。关于 AST 解析，这里也可以说是形成词法作用域的主要原因\n三、JS 基础（ES6） 3.1 let，const let 产生块级作用域（通常配合 for 循环或者 {} 进行使用产生块级作用域），const 申明的变量是常量（内存地址不变）\n3.2 Promise 这里你谈 promise的时候，除了将他解决的痛点以及常用的 API 之外，最好进行拓展把 eventloop 带进来好好讲一下，microtask(微任务)、macrotask(任务) 的执行顺序，如果看过 promise 源码，最好可以谈一谈 原生 Promise 是如何实现的。Promise 的关键点在于callback 的两个参数，一个是 resovle，一个是 reject。还有就是 Promise 的链式调用（Promise.then()，每一个 then 都是一个责任人）\n3.3 Generator 遍历器对象生成函数，最大的特点是可以交出函数的执行权\nfunction 关键字与函数名之间有一个星号； 函数体内部使用 yield表达式，定义不同的内部状态； next 指针移向下一个状态 这里你可以说说 Generator的异步编程，以及它的语法糖 async 和 awiat，传统的异步编程。ES6 之前，异步编程大致如下\n回调函数 事件监听 发布/订阅 传统异步编程方案之一：协程，多个线程互相协作，完成异步任务。\n3.4 async、await Generator 函数的语法糖。有更好的语义、更好的适用性、返回值是 Promise。\nasync =\u0026gt; * await =\u0026gt; yield 1 2 3 4 5 6 7 8 9 10 11 12 // 基本用法 async function timeout (ms) { await new Promise((resolve) =\u0026gt; { setTimeout(resolve, ms) }) } async function asyncConsole (value, ms) { await timeout(ms) console.log(value) } asyncConsole(\u0026#39;hello async and await\u0026#39;, 1000) 注：最好把2，3，4 连到一起讲\n3.5 AMD，CMD，CommonJs，ES6 Module：解决原始无模块化的痛点 AMD：requirejs 在推广过程中对模块定义的规范化产出，提前执行，推崇依赖前置 CMD：seajs 在推广过程中对模块定义的规范化产出，延迟执行，推崇依赖就近 CommonJs：模块输出的是一个值的 copy，运行时加载，加载的是一个对象（module.exports 属性），该对象只有在脚本运行完才会生成 ES6 Module：模块输出的是一个值的引用，编译时输出接口，ES6模块不是对象，它对外接口只是一种静态定义，在代码静态解析阶段就会生成。 四、框架相关 4.1 数据双向绑定原理：常见数据绑定的方案 Object.defineProperty（vue）：劫持数据的 getter 和 setter 脏值检测（angularjs）：通过特定事件进行轮循 发布/订阅模式：通过消息发布并将消息进行订阅 4.2 VDOM：三个 part 虚拟节点类，将真实 DOM 节点用 js 对象的形式进行展示，并提供 render 方法，将虚拟节点渲染成真实 DOM 节点 diff 比较：对虚拟节点进行 js 层面的计算，并将不同的操作都记录到 patch 对象 re-render：解析 patch 对象，进行 re-render 补充1：VDOM 的必要性？\n创建真实DOM的代价高：真实的 DOM 节点 node 实现的属性很多，而 vnode 仅仅实现一些必要的属性，相比起来，创建一个 vnode 的成本比较低。 触发多次浏览器重绘及回流：使用 vnode ，相当于加了一个缓冲，让一次数据变动所带来的所有 node 变化，先在 vnode 中进行修改，然后 diff 之后对所有产生差异的节点集中一次对 DOM tree 进行修改，以减少浏览器的重绘及回流。 补充2：vue 为什么采用 vdom？\n引入 Virtual DOM 在性能方面的考量仅仅是一方面。\n性能受场景的影响是非常大的，不同的场景可能造成不同实现方案之间成倍的性能差距，所以依赖细粒度绑定及 Virtual DOM 哪个的性能更好还真不是一个容易下定论的问题。 Vue 之所以引入了 Virtual DOM，更重要的原因是为了解耦 HTML依赖，这带来两个非常重要的好处是： 不再依赖 HTML 解析器进行模版解析，可以进行更多的 AOT 工作提高运行时效率：通过模版 AOT 编译，Vue 的运行时体积可以进一步压缩，运行时效率可以进一步提升； 可以渲染到 DOM 以外的平台，实现 SSR、同构渲染这些高级特性，Weex等框架应用的就是这一特性。 综上，Virtual DOM 在性能上的收益并不是最主要的，更重要的是它使得 Vue 具备了现代框架应有的高级特性。\n4.3 vue 和 react 区别 相同点：都支持 ssr，都有 vdom，组件化开发，实现 webComponents 规范，数据驱动等 不同点：vue 是双向数据流（当然为了实现单数据流方便管理组件状态，vuex 便出现了），react 是单向数据流。vue 的 vdom 是追踪每个组件的依赖关系，不会渲染整个组件树，react 每当应该状态被改变时，全部子组件都会 re-render 4.4 为什么用 vue 简洁、轻快、舒服\n五、网络基础类 5.1 跨域 很多种方法，但万变不离其宗，都是为了搞定同源策略。重用的有 jsonp、iframe、cors、img、HTML5 postMessage等等。其中用到 html 标签进行跨域的原理就是 html 不受同源策略影响。但只是接受 Get 的请求方式，这个得清楚。\n延伸1：img iframe script 来发送跨域请求有什么优缺点？\n1. iframe\n优点：跨域完毕之后DOM操作和互相之间的JavaScript调用都是没有问题的 缺点：1.若结果要以URL参数传递，这就意味着在结果数据量很大的时候需要分割传递，巨烦。2.还有一个是iframe本身带来的，母页面和iframe本身的交互本身就有安全性限制。 2. script\n优点：可以直接返回json格式的数据，方便处理 缺点：只接受GET请求方式 3. 图片ping\n优点：可以访问任何url，一般用来进行点击追踪，做页面分析常用的方法 缺点：不能访问响应文本，只能监听是否响应 延伸2：配合 webpack 进行反向代理？\nwebpack 在 devServer 选项里面提供了一个 proxy 的参数供开发人员进行反向代理\n1 2 3 4 5 6 7 \u0026#39;/api\u0026#39;: { target: \u0026#39;http://www.example.com\u0026#39;, // your target host changeOrigin: true, // needed for virtual hosted sites pathRewrite: { \u0026#39;^/api\u0026#39;: \u0026#39;\u0026#39; // rewrite path } }, 然后再配合 http-proxy-middleware 插件对 api 请求地址进行代理\n1 2 3 4 5 6 7 8 9 const express = require(\u0026#39;express\u0026#39;); const proxy = require(\u0026#39;http-proxy-middleware\u0026#39;); // proxy api requests const exampleProxy = proxy(options); // 这里的 options 就是 webpack 里面的 proxy 选项对应的每个选项 // mount `exampleProxy` in web server const app = express(); app.use(\u0026#39;/api\u0026#39;, exampleProxy); app.listen(3000); 然后再用 nginx 把允许跨域的源地址添加到报头里面即可\n说到 nginx ，可以再谈谈 CORS 配置，大致如下\n1 2 3 4 5 6 7 8 9 10 11 12 location / { if ($request_method = \u0026#39;OPTIONS\u0026#39;) { add_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;*\u0026#39;; add_header \u0026#39;Access-Control-Allow-Methods\u0026#39; \u0026#39;GET, POST, OPTIONS\u0026#39;; add_header \u0026#39;Access-Control-Allow-Credentials\u0026#39; \u0026#39;true\u0026#39;; add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;DNT, X-Mx-ReqToken, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type\u0026#39;; add_header \u0026#39;Access-Control-Max-Age\u0026#39; 86400; add_header \u0026#39;Content-Type\u0026#39; \u0026#39;text/plain charset=UTF-8\u0026#39;; add_header \u0026#39;Content-Length\u0026#39; 0; return 200; } } 5.2 http 无状态无连接 http 协议对于事务处理没有记忆能力 对同一个url请求没有上下文关系 每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况 服务器中没有保存客户端的状态，客户端必须每次带上自己的状态去请求服务器 人生若只如初见，请求过的资源下一次会继续进行请求 http协议无状态中的 状态 到底指的是什么？！\n【状态】的含义就是：客户端和服务器在某次会话中产生的数据 那么对应的【无状态】就意味着：这些数据不会被保留 通过增加cookie和session机制，现在的网络请求其实是有状态的 在没有状态的http协议下，服务器也一定会保留你每次网络请求对数据的修改，但这跟保留每次访问的数据是不一样的，保留的只是会话产生的结果，而没有保留会话 5.3 http-cache：就是 http 缓存 1. 首先得明确 http 缓存的好处\n减少了冗余的数据传输，减少网费 减少服务器端的压力 Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间 加快客户端加载网页的速度 2. 常见 http 缓存的类型\n私有缓存（一般为本地浏览器缓存） 代理缓存 3. 然后谈谈本地缓存\n本地缓存是指浏览器请求资源时命中了浏览器本地的缓存资源，浏览器并不会发送真正的请求给服务器了。它的执行过程是\n第一次浏览器发送请求给服务器时，此时浏览器还没有本地缓存副本，服务器返回资源给浏览器，响应码是200 OK，浏览器收到资源后，把资源和对应的响应头一起缓存下来 第二次浏览器准备发送请求给服务器时候，浏览器会先检查上一次服务端返回的响应头信息中的Cache-Control，它的值是一个相对值，单位为秒，表示资源在客户端缓存的最大有效期，过期时间为第一次请求的时间减去Cache-Control的值，过期时间跟当前的请求时间比较，如果本地缓存资源没过期，那么命中缓存，不再请求服务器 如果没有命中，浏览器就会把请求发送给服务器，进入缓存协商阶段。 与本地缓存相关的头有：Cache-Control、Expires，Cache-Control有多个可选值代表不同的意义，而Expires就是一个日期格式的绝对值。\n3.1 Cache-Control\nCache-Control是HTPP缓存策略中最重要的头，它是HTTP/1.1中出现的，它由如下几个值\nno-cache：不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载 no-store：直接禁止游览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源 public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。 private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。 max-age：从当前请求开始，允许获取的响应被重用的最长时间（秒）。 1 2 3 4 # 例如： Cache-Control: public, max-age=1000 # 表示资源可以被所有用户以及代理服务器缓存，最长时间为1000秒。 3.2 Expires\nExpires是HTTP/1.0出现的头信息，同样是用于决定本地缓存策略的头，它是一个绝对时间，时间格式是如Mon, 10 Jun 2015 21:31:12 GMT，只要发送请求时间是在Expires之前，那么本地缓存始终有效，否则就会去服务器发送请求获取新的资源。如果同时出现Cache-Control：max-age和Expires，那么max-age优先级更高。他们可以这样组合使用\n1 2 Cache-Control: public Expires: Wed, Jan 10 2018 00:27:04 GMT 3.3 所谓的缓存协商\n当第一次请求时服务器返回的响应头中存在以下情况时\n没有 Cache-Control 和 Expires Cache-Control 和 Expires 过期了 Cache-Control 的属性设置为 no-cache 时 那么浏览器第二次请求时就会与服务器进行协商，询问浏览器中的缓存资源是不是旧版本，需不需要更新，此时，服务器就会做出判断，如果缓存和服务端资源的最新版本是一致的，那么就无需再次下载该资源，服务端直接返回304 Not Modified 状态码，如果服务器发现浏览器中的缓存已经是旧版本了，那么服务器就会把最新资源的完整内容返回给浏览器，状态码就是200 Ok，那么服务端是根据什么来判断浏览器的缓存是不是最新的呢？其实是根据HTTP的另外两组头信息，分别是：Last-Modified/If-Modified-Since 与 ETag/If-None-Match。\nLast-Modified 与 If-Modified-Since\n浏览器第一次请求资源时，服务器会把资源的最新修改时间Last-Modified:Thu, 29 Dec 2011 18:23:55 GMT放在响应头中返回给浏览器 第二次请求时，浏览器就会把上一次服务器返回的修改时间放在请求头If-Modified-Since:Thu, 29 Dec 2011 18:23:55发送给服务器，服务器就会拿这个时间跟服务器上的资源的最新修改时间进行对比 如果两者相等或者大于服务器上的最新修改时间，那么表示浏览器的缓存是有效的，此时缓存会命中，服务器就不再返回内容给浏览器了，同时Last-Modified头也不会返回，因为资源没被修改，返回了也没什么意义。如果没命中缓存则最新修改的资源连同Last-Modified头一起返回\n1 2 3 4 # 第一次请求返回的响应头 Cache-Control:max-age=3600 Expires: Fri, Jan 12 2018 00:27:04 GMT Last-Modified: Wed, Jan 10 2018 00:27:04 GMT 1 2 # 第二次请求的请求头信息 If-Modified-Since: Wed, Jan 10 2018 00:27:04 GMT 这组头信息是基于资源的修改时间来判断资源有没有更新，另一种方式就是根据资源的内容来判断，就是接下来要讨论的 ETag 与 If-None-Match\nETag与If-None-Match\nETag/If-None-Match与Last-Modified/If-Modified-Since的流程其实是类似的，唯一的区别是它基于资源的内容的摘要信息（比如MD5 hash）来判断\n浏览器发送第二次请求时，会把第一次的响应头信息ETag的值放在If-None-Match的请求头中发送到服务器，与最新的资源的摘要信息对比，如果相等，取浏览器缓存，否则内容有更新，最新的资源连同最新的摘要信息返回。用ETag的好处是如果因为某种原因到时资源的修改时间没改变，那么用ETag就能区分资源是不是有被更新。\n1 2 3 4 # 第一次请求返回的响应头： Cache-Control: public, max-age=31536000 ETag: \u0026#34;15f0fff99ed5aae4edffdd6496d7131f\u0026#34; 1 2 3 # 第二次请求的请求头信息： If-None-Match: \u0026#34;15f0fff99ed5aae4edffdd6496d7131f\u0026#34; 5.4 cookie 和 session session： 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念 cookie：它是一个世纪存在的东西，http 协议中定义在 header 中的字段，可以认为是 session 的一种后端无状态实现 现在我们常说的 session，是为了绕开 cookie 的各种限制，通常借助 cookie本身和后端存储实现的，一种更高级的会话状态实现\nsession 的常见实现要借助cookie来发送 sessionID\n5.5 安全问题，如 XSS 和 CSRF XSS：跨站脚本攻击，是一种网站应用程序的安全漏洞攻击，是代码注入的一种。常见方式是将恶意代码注入合法代码里隐藏起来，再诱发恶意代码，从而进行各种各样的非法活动 防范：记住一点 “所有用户输入都是不可信的”，所以得做输入过滤和转义\nCSRF：跨站请求伪造，也称 XSRF，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。与 XSS 相比，XSS利用的是用户对指定网站的信任，CSRF利用的是网站对用户网页浏览器的信任。 防范：用户操作验证（验证码），额外验证机制（token使用）等\n","permalink":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%B2%BE%E7%AE%80%E7%89%88%E6%9C%AC/","summary":"一、CSS相关 1.1 左边定宽，右边自适应方案：float + margin，float + calc 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 方案1 */ .left { width: 120px; float: left; }","title":"面试题精简版本"},{"content":"前端代码规范-推荐资料 JS规范，重点推荐下面这两个 1、Airbnb JavaScript Style Guide：\n英文原版：https://github.com/airbnb/javascript\n中文版：https://github.com/lin-123/javascript\n2、clean code JavaScript：\n英文原版：https://github.com/ryanmcdermott/clean-code-javascript\n中文版1：https://github.com/alivebao/clean-code-js\n中文版2：https://github.com/beginor/clean-code-javascript\neslint规范 1、eslint-config-airbnb：\nhttps://www.npmjs.com/package/eslint-config-airbnb\nhttps://github.com/airbnb/javascript/tree/master/packages/eslint-config-airbnb\n2、凹凸实验室的eslint规范：\nhttps://www.npmjs.com/package/eslint-config-o2team-wx\n备注：o2team-wx 这一套规则是参考了 StandardJS 和 Airbnb 的 JS 规范，然后结合业务中的最佳实践整理输出的。\n其他相关资料 1、百度前端团队-前端各类规范集合：https://github.com/ecomfe/spec\n2、The mother of all demo apps：https://github.com/gothinkster/realworld\n3、JavaScript 代码规范：https://github.com/standard/standard/blob/master/docs/README-zhcn.md\n参考链接 文案、编程、Git 风格规范汇总：https://www.bihell.com/article/130\ngithubStars：https://blog.teefing.top/posts/2019/05/27/githubstars.html\n其他链接 http://blog.lovebug.cn/details/html/page02.html\nhttps://github.com/ecomfe/spec\nhttps://juejin.im/post/5e3d0362e51d4526d87c605d\nhttps://juejin.im/post/592d4a5b0ce463006b43b6da\nhttps://juejin.im/post/5b67e49551882508603d1431\nhttps://juejin.im/post/5e1abeede51d453c913c340e\nhttps://juejin.im/post/5d5d5197518825237330552d\nhttp://alloyteam.github.io/CodeGuide/\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/01-%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","summary":"前端代码规范-推荐资料 JS规范，重点推荐下面这两个 1、Airbnb JavaScript Style Guide： 英文原版：https://github.com/airbn","title":"01-前端代码规范"},{"content":"前言 要监控的内容：\n业务数据\n稳定性\n性能\n错误\n用户操作路径\n怎么监控：\nPV/UV、业务操作上报\n根据上报寻找异常\n将页面性能数据上报\n将页面产生错误上报\n跟踪用户操作路径\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/%E5%89%8D%E7%AB%AF%E7%9B%91%E6%8E%A7%E6%8A%80%E6%9C%AF/","summary":"前言 要监控的内容： 业务数据 稳定性 性能 错误 用户操作路径 怎么监控： PV/UV、业务操作上报 根据上报寻找异常 将页面性能数据上报 将页面产生错误上报 跟","title":"前端监控技术"},{"content":"egg-sequelize 连接多个数据库如何配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 config.sequelize = { datasources: [ { delegate: \u0026#39;model\u0026#39;, // 加载所有的模型到 app.model and ctx.model baseDir: \u0026#39;model\u0026#39;, // 要加载的模型目录`app/model/*.js` dialect: \u0026#39;mysql\u0026#39;, host: \u0026#39;10.52.18.8\u0026#39;, port: 3306, username: \u0026#39;root\u0026#39;, // 用户名 password: \u0026#39;root\u0026#39;, // 用户密码 database: \u0026#39;crt_crland_screen\u0026#39;, // 数据库名 dateStrings: true, // 解决时间格式 pool: { max: 20, min: 0, idle: 10000, }, }, { delegate: \u0026#39;appModel\u0026#39;, // 加载所有的模型到 app.logModel and ctx.logModel baseDir: \u0026#39;model_app\u0026#39;, // 要加载的模型目录 `app/model_log/*.js` // local dialect: \u0026#39;mysql\u0026#39;, host: \u0026#39;10.52.18.8\u0026#39;, port: 3306, username: \u0026#39;root\u0026#39;, // 用户名 password: \u0026#39;root\u0026#39;, // 用户密码 database: \u0026#39;hotel_report\u0026#39;, // 数据库名 dateStrings: true, // 解决时间格式 pool: { max: 20, min: 0, idle: 10000, }, }, ], }; 注意事项：\n很多人担心 controller 、service 、 model 需要怎么编写\ncontroller \\ service 正常编写\nmodel 需要注意 后续添加的数据库指定了baseDir（新的model 目录）\n配置的delegate 属性 ==\u0026gt; app.appModel / ctx.appModel （连接表 / 服务时记得把model 换成配置的 delegate ）\n​\n","permalink":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/egg.js-1/","summary":"egg-sequelize 连接多个数据库如何配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 config.sequelize = { datasources: [ { delegate: \u0026#39;model\u0026#39;, // 加载所有的模型到 app.model and ctx.model baseDir:","title":"egg.js"},{"content":"腾讯云服务器控制台： https://iaas.cloud.tencent.com/webshell?regionId=4\u0026amp;instanceId=ins-56hta1uv\u0026amp;username=root\u0026amp;port=22\n****LL612lv.\nNginx 查看80端口被占用的进程 1 lsof -i:80 通过kill命令干掉该进程 1 kill -9 进程号(pid) 重启Nginx 1 nginx -s reload 服务器 安全组配置 TCP / UDP :8080 协议/端口\n来源 0.0.0.0/0 任何ip都可访问 , 或设置特定ip/端口可访问\n","permalink":"https://bablvsj.github.io/posts/tech/linux/%E4%B8%AA%E4%BA%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE/","summary":"腾讯云服务器控制台： https://iaas.cloud.tencent.com/webshell?regionId=4\u0026amp;instanceId=ins-56hta1uv\u0026amp;username=root\u0026amp;port=22 ****LL612lv. Nginx 查看80端口被占用的进程 1 lsof -i:80 通过kill命令干掉该进程 1 kill -9 进程号(pid) 重启Nginx 1 nginx -s reload 服务器 安全组配","title":"云服务器Mind"},{"content":"前端人应该知道的 Centos/Nginx/Node的基本操作 Centos Centos 是一个基于 Linux 的开源免费操作系统，下面列出一些常用操作\n1 2 # 本地拷贝文件到远程服务器 scp output.txt root@47.93.242.155:/data/ output.txt:本地文件 root:登录远程服务器的账号 47.93.242.155:远程服务器的 IP /data/:远程服务器的目录 1 2 # 拷贝D盘https目录下的所有文件到 远程的 /data 目录 scp D:/https/* root@47.93.242.155:/data 本地链接远程 Centos 服务器 1 ssh \\-p 端口 用户名@服务器IP 例子:\n1 2 3 4 ssh -p 22 root@47.93.242.155 # 输入登录密码 # 成功 yum 切换为阿里源 1 2 3 4 5 6 cd /etc/yum.repos.d/ curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-8.repo # 重新生成缓存--查看执行结果，如果有aliyun 字样就算成功 yum makecache 其他 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 # 创建 /data/test 目录 mkdir /data/test # 创建 /data/newtest 目录 mkdir /data/newtest # 创建 /data/test/index.html 文件 touch /data/test/index.html # 编辑文件 vi /data/test/index.html # 查看文件内容 cat /data/www/index.html # 将 `test`目录下的所有文件复制到 `newtest`目录 下 cp –r /data/test/* /data/newtest # 删除 /data/newtest/index.html 文件 rm -rf /data/newtest/index.html # 将 `test`目录下的所有文件移动到新目录 `newtest`目录 下 mv /data/test/* /data/newtest # 查看当前目录的路径 pwd 复制代码 # 检查端口被哪个进程占用 netstat -lnp|grep 88 #88请换为你需要的端口，如：80 执行netstat \\-lnp|grep 端口号之后会打印出被占用的进程及其编号\n1 2 # 杀掉编号为1777的进程（请根据实际情况输入） kill -9 1777 查看当前 Centos 操作系统发行版信息\n1 cat /etc/redhat-release Nginx 服务器搭建 nginx-logo\nNginx 是一个高性能的 HTTP 和反向代理 web 服务器，使用 nginx 网站有：百度、京东、新浪、网易、腾讯、淘宝\u0026hellip;。\nCentos 下安装 Nginx 服务器 这里我们使用 yum 安装 Nginx 服务器。\n1 yum install -y nginx 启动 Nginx 服务器 安装后的 Nginx 没有启动，先启动 Nginx 服务器。\n1 nginx 此时，访问 http://\u0026lt;您的域名或IP\u0026gt; 可以看到 Nginx 的测试页面\n如果无法访问，请重试用 nginx \\-s reload 命令重启 Nginx\nnginx-index\n配置静态服务器访问路径 外网用户访问服务器的 Web 服务由 Nginx 提供，Nginx 需要配置静态资源的路径信息才能通过 url 正确访问到服务器上的静态资源。\n打开 Nginx 的默认配置文件 /etc/nginx/nginx.conf ，修改 Nginx 配置\n1 vi /etc/nginx/nginx.conf 将默认的 /usr/share/nginx/html; 修改为: /data/www;，如下：\n示例代码：/etc/nginx/nginx.conf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 user nginx; worker_processes auto; error_log /var/log/nginx/error.log; pid /run/nginx.pid; include /usr/share/nginx/modules/*.conf; events { worker_connections 1024; } http { log_format main \u0026#39;$remote_addr - $remote_user [$time_local] \u0026#34;$request\u0026#34; \u0026#39; \u0026#39;$status $body_bytes_sent \u0026#34;$http_referer\u0026#34; \u0026#39; \u0026#39;\u0026#34;$http_user_agent\u0026#34; \u0026#34;$http_x_forwarded_for\u0026#34;\u0026#39;; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf; server { listen 80 default_server; listen [::]:80 default_server; server_name _; # 修改为以下路径 root /data/www; include /etc/nginx/default.d/*.conf; location / { } error_page 404 /404.html; location = /40x.html { } error_page 500 502 503 504 /50x.html; location = /50x.html { } } } 配置文件将 /data/www/static 作为所有静态资源请求的根路径，如访问: http://\u0026lt;您的域名或IP\u0026gt;/static/index.js，将会去 /data/www/static/ 目录下去查找 index.js/index.html。现在我们需要重启 Nginx 让新的配置生效，如：\n1 nginx -s reload 创建第一个静态文件 现在让我们新建一个静态文件，查看服务是否运行正常。\n首先让我们在 /data 目录 下创建 www 目录，如：\n1 mkdir -p /data/www 在 /data/www 目录下创建我们的第一个静态文件 index.html\n1 2 3 touch /data/www/index.html vi /data/www/index.html 示例代码：/data/www/index.html\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;zh\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;第一个静态文件\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello world！\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 现在访问 http://\u0026lt;您的域名或IP\u0026gt;/index.html 应该可以看到页面输出 Hello world!\n到此，一个基于 Nginx 的静态服务器就搭建完成了，现在所有放在 /data/www 目录下的的静态资源都可以直接通过域名/IP 访问。\n如果无显示，请刷新浏览器页面\n配置 Nginx 反向代理 客户端对代理服务器是无感知的，客户端不需要做任何配置，用户只请求反向代理服务器，反向代理服务器选择目标服务器，获取数据后再返回给客户端。\n反向代理服务器和目标服务器对外而言就是一个服务器，只是暴露的是代理服务器地址，而隐藏了真实服务器的 IP 地址。\n20210416165016\n参考从原理到实战，彻底搞懂 Nginx！\n访问路径:/api/getUser\n1 当 nginx 配置文件 `proxy_pass` 的 **url 末尾 带`/`时**: 1 2 3 4 5 6 7 8 server { listen 80; server_name www.123.com; location /api/ { proxy_pass http://127.0.0.1:18081/; } } 代理到后端的路径为：http://127.0.0.1:18081/getUser，省略了匹配到的/api/路径；\n1 当 nginx 配置文件 `proxy_pass` 的 **url 末尾 不带`/`时**： 1 2 3 4 5 6 7 8 server { listen 80; server_name www.123.com; location /api/ { proxy_pass http://127.0.0.1:18081; } } 代理到后端的路径为：http://127.0.0.1:18081/api/getUser，连同匹配到的/api/路径，一起进行反向代理；\nCentos 下搭建 Node.js 环境 node-logo\nNode.js 是运行在服务端的 JavaScript, 是基于 Chrome JavaScript V8 引擎建立的平台。\n安装 Node.js 的几种方式\n方法一：从EPEL库安装Node.js\u0026ndash;yum install nodejs，不足:安装的node/npm版本较低,需要手动切换版本 方法二:使用官方编译过的二进制数据包安装,不足:安装步骤繁杂 方法三: 通过NVM安装,方便快捷不足:安装时国外的网不好 🥶 方法四:源码下载后编译安装,版本是最新的 yum install nodejs 方式安装 查看当前系统自带了哪些nodejs的版本\n1 sudo dnf module list nodejs centos-node-list\n可以看到有三个版本的 Node:10,12,14. 在版本 10 上有个[d]符号,它代表系统将会默认安装的版本。如果你想要切换默认安装的版本，可以执行下面的命令\n1 sudo dnf module enable nodejs:14 安装 Node\n1 sudo dnf install nodejs 查看 node 版本，可以发现是Node14的版本\n1 node --v NVM 方式安装 我们可能同时在进行 2 个项目，而 2 个不同的项目所使用的 node 版本又是不一样的，对于维护多个版本的node将会是一件非常麻烦的事情，而nvm就是为解决这个问题而产生的，它可以方便的在同一台设备上进行多个node版本之间切换\n注: 使用此方式，在后面的 Jenkins 脚本使用 npm/yarn 会提示找不到命令，我也不知道咋解决，求大佬科普 🤪\n下面是(2021/04)的最新稳定版: 可以在去NVM 官网看一下，替换成最新的链接\n1 curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.38.0/install.sh | cp 还需要运行下面的命令，以确认上一条命令的更改结果\n1 source ~/.bash_profile 查看 Node 版本列表\n1 nvm list-remote 安装一个长期支持的版本\n1 nvm install 14.16.1 确认是否安装成功\n1 2 3 nvm current node -v npm -v 通过 环境变量echo $PATH 查看安装的位置\n1 2 3 echo $PATH # 打印出的结果中，需要取出 `/root/.nvm/versions/node/v14.16.1/bin` 使用官方编译过的二进制数据包的方式安装 注: 使用此方式，在后面的 Jenkins 脚本使用 npm/yarn 能够正常运行\n下面是(2021/04)的最新稳定版: 可以在去Node.js 官网看一下，替换成最新的链接\n下载 14.16.0 到/data 目录\n1 2 cd /data wget https://nodejs.org/dist/v14.16.0/node-v14.16.0-linux-x64.tar.xz 下载完成后, 将其解压\n1 tar xvJf node-v14.16.0-linux-x64.tar.xz 将解压的 Node.js 目录移动到 /usr/local 目录下\n1 mv node-v14.16.0-linux-x64 /usr/local/node-v14 配置 node 软链接到 /bin 目录\n1 ln -s /usr/local/node-v14/bin/node /bin/node 配置和使用 npm npm 是 Node.js 的包管理和分发工具。它可以让 Node.js 开发者能够更加轻松的共享代码和共用代码片段\n下载 node 的压缩包中已经包含了 npm , 我们只需要将其软链接到 bin 目录下即可\n1 ln -s /usr/local/node-v14/bin/npm /bin/npm 配置环境变量 将 /usr/local/node-v14/bin 目录添加到 $PATH 环境变量中可以方便地使用通过 npm 全局安装的第三方工具\n1 echo \u0026#39;export PATH=/usr/local/node-v14/bin:$PATH\u0026#39; \u0026gt;\u0026gt; /etc/profile 使环境变量生效\n1 source /etc/profile 使用 npm 通过 npm 配置淘宝源\n1 2 npm config set registry https://registry.npm.taobao.org npm get registry 全局安装yarn并配置淘宝源\n1 2 3 npm install yarn -g yarn config set registry http://registry.npm.taobao.org/ yarn config get registry ","permalink":"https://bablvsj.github.io/posts/tech/linux/%E5%89%8D%E7%AB%AF%E4%BA%BA%E5%BA%94%E7%9F%A5%E7%9A%84-centosnginxnode-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/","summary":"前端人应该知道的 Centos/Nginx/Node的基本操作 Centos Centos 是一个基于 Linux 的开源免费操作系统，下面列出一些常用操作 1 2 # 本地拷贝文件到远程","title":"前端人应知的 CentosNginxNode 的基本操作"},{"content":"资源分享 新手学习Node.js\n推荐狼叔的《如何正确学习Node.js》，地址：https://github.com/i5ting/How-to-learn-node-correctly\nNode.js国内交流社区：https://cnodejs.org/\n推荐书籍：《Node.js实战》（第二版）、《Node.js调试指南》、《深入浅出Node.js》（有一定的基础后再看）、《更了不起的Node.js》（据说今年会出版）\npromise的各种用法：https://github.com/sindresorhus/promise-fun\n张鑫旭大佬一篇旧文\n话说我为什么要闭关学习：http://www.zhangxinxu.com/life/?p=98 一点感慨：就算张鑫旭大佬从事别的事业，肯定也是拔尖的。\n2018年8月中级前端开发推荐书籍：https://zhuanlan.zhihu.com/p/40761206 张鑫旭的《CSS世界》真是写的是真的好，准备翻出来看第三遍了。我最近看的书都是按照这个书单看的，前面基本还可以，从《Node.js:来一打C++扩展》后面开始感觉就有点get不到书里面的主题了。\n《编程语言的发展趋势：从没有分号，到DSL》\nPython - 100天从新手到大师：https://github.com/jackfrued/Python-100-Days\n国内10大前端团队网站：https://zhuanlan.zhihu.com/p/60091235\n腾讯新闻前端团队维护的一个周刊：https://github.com/Tnfe/TNFE-Weekly\n看到一篇to b产品UX \u0026amp; UI 设计总结不错。\n后台产品 UX \u0026amp; UI 设计总结（上）- 设计要点概括：https://zhuanlan.zhihu.com/p/28787738\nweb安全学习笔记：https://websec.readthedocs.io/\n可能是最全的前端动效库汇总：https://juejin.im/post/5cc089eae51d456e7d189f9d\n成都-颜乐乐：\n撸了一个 node 爬虫：TS+puppeteer+cheerio+fs-extra\nhttps://github.com/yanlele/node-spider 使用JavaScript写爬虫：https://zhuanlan.zhihu.com/p/53763115 mysql相关的书籍推荐：《深入浅出MySQL 数据库开发 优化与管理维护》\n猴子都能懂的Git入门：https://backlog.com/git-tutorial/cn/\n像玩游戏闯关一样学习git！: https://learngitbranching.js.org/\n知识积累 userAgent相关：判断微信内置浏览器的UserAgent\npromise的实现，关键词：Promises/A、Promises/B、bluebird\nlocation.pathname：获取 url 的后半部分。参考链接：#\n代码解读：callback \u0026amp;\u0026amp; callback()的含义\n对比 sass、less、stylus 这三个css预处理器，sass 比 less强大，stylus的书写方式比较奇怪。\n时间戳和年月日的转换：https://blog.csdn.net/qq_26747571/article/details/53289120?locationNum=10\u0026amp;fps=1\n对象数组通过对象的属性进行排序：https://blog.csdn.net/xiaobing_hope/article/details/68638706\n数组随机打乱顺序：https://www.zhihu.com/question/68330851/answer/262111061 最佳的打乱算法是Fisher-Yates算法。\ncss 动画实现闪烁效果：https://blog.csdn.net/wangxiuyan0228/article/details/80701523 动画水平/镜像翻转 参考链接1：https://www.oschina.net/question/2443483_247744\n代码实现举例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; @keyframes featuresicon { 0% { transform: scaleX(1); } 20% { transform: scaleX(1); } 50% { transform: scaleX(0); } 80% { transform: scaleX(1); } 100% { transform: scaleX(1); } } .cube { width: 40px; height: 40px; background: url(images/bg2.png) left 0 no-repeat; animation: featuresicon 1.3s linear alternate none infinite; } body { background-color: cornflowerblue; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;cube\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 参考链接2：https://blog.csdn.net/wjnf012/article/details/78679131\n代码实现：（立体感更强一点）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; *{ padding: 0; margin: 0; } .cube{ display: block; color: #ffffff; text-align: center; width: 40px; height: 40px; border-radius: 4px; /* background-color: #9a6ad8 */ background: url(images/bg.png) left 0 no-repeat; animation: proRotate 1.3s ease-in-out 500ms alternate none infinite; } @keyframes proRotate { 0%{transform:perspective(200px) rotateY(180deg);} 100%{transform:perspective(200px) rotateY(0deg);} } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;test_wrap\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;cube\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/html\u0026gt; 学习路线 Web前端入门的自学路线 新手入门前端，需要学习的基础内容有很多，如下。\n一、HTML、CSS基础、JavaScript语法基础。学完基础后，可以仿照电商网站（例如京东、小米）做首页的布局。\n二、JavaScript语法进阶。包括：作用域和闭包、this和对象原型等。相信我，JS语法，永远是面试中最重要的部分。\n三、jQuery、Ajax等。jQuery没有过时，它仍然是前端基础的一部分。\n四、ES6语法。这部分属于JS新增的语法，面试必问。其中，关于 promise、async 等内容要尤其关注。\n五、HTML5和CSS3。要熟悉其中的新特性。\n六、canvas。面试时，有的公司不一定会问canvas，靠运气。如果时间不够，这部分的内容可以先不学。但如果你会，绝对属于加分项。\n七、移动Web开发、Bootstrap等。要注意移动开发中的适配和兼容性问题。\n八、前端框架：Vue.js和React。这两个框架至少要会一个。入门时，建议先学Vue.js，上手相对容易。但无论如何，同时掌握 Vue 和 React 才是合格的前端同学。\n九、Node.js。属于加分项，如果时间不够，可以先不学，但至少要知道 node 环境的配置。\n十、前端工程化：构建工具 Webpack、构建工具 gulp、CSS 预处理器 Sass 等。注意，Sass 比 Less 用得多，gulp 比 grunt 用得多。\n十一、前端综合：HTTP协议、跨域通信、安全问题（CSRF、XSS）、浏览器渲染机制、异步和单线程、页面性能优化、防抖动（Debouncing）和节流阀（Throtting）、lazyload、前端错误监控、虚拟DOM等。\n十二、编辑器相关。Sublime Text 是每个学前端的人都要用到的编辑器。另外，前端常见的IDE有两个：WebStorm 和 Visual Studio Code。WebStorm 什么都好，可就是太卡顿；VS Code就相对轻量很多。个人总结一下：用VS Code 的人越来越多，用 WebStorm 的人越来越少。具体可以看：《第一次使用VS Code时你应该知道的一切配置》\n十三、TypeScript（简称TS）。ES 是 JS 的标准，TS 是 JS 的超集。TS属于进阶内容，建议把上面的基础掌握之后，再学TS。\n备注：框架有时候都很虚；熟练掌握 JavaScript 基础，才是行走江湖、驰骋千里的关键。\n推荐的前端图文教程 我在GitHub上有一个Web前端入门的学习教程，非常详细，地址是：\nhttps://github.com/qianguyihao/Web\n非常详细和贴心，你值得star。这个前端教程主要有三个作用：\n网上的大部分入门教程，都不太适合初学者，本项目争取照顾到每一位入门者的同理心。\n帮助前端同学提供一个精品学习路线和资源，提高学习效率，少走很多弯路。\n可以当做前端字典，随时翻阅，查漏补缺。\n推荐的技术博客 阮一峰\n张鑫旭\n推荐的书籍 《你不知道的JavaScript》 上面这套书有上、中、下三本，你都可以读一读。如果时间不够，那就先读第一本。\n《网络是怎样连接的》 程序员面试的时候，经常会被问的一个问题是：“在浏览器的地址栏输入url，按下回车后，发生了什么？”\n为了清楚这个问题，看上面这本书，足够了。如果你想入门计算机网络，这本书也是必读的。评价非常高。\n关于这个问题，也可以看下面这篇文章：浏览器输入 URL 后发生了什么？\n《CSS世界》 关于 CSS 的书籍，首先推荐这本书，我身边的大佬们都说这本书好。虽然我不是大牛，但我也觉得这本书很好。\n如果 js 熟练，说明你是有技术深度的前端；如果 css 熟练，说明你是有经验的前端。\n前端资讯订阅源 前端开发者必须要订阅的：\nDaily JS：https://medium.com/dailyjs - medium 上的博客。 JavaScript Weekly：https://javascriptweekly.com/ - 聚合类的技术周刊。 推荐链接 「颜值即正义」那些管UI小姐姐要来的网站\n前端面试图谱：https://yuchengkai.cn/docs/zh/\ncss的各种效果实现：https://lhammer.cn/You-need-to-know-css/#/\n现代 JavaScript 教程：https://zh.javascript.info/\n","permalink":"https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/20230806-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/","summary":"资源分享 新手学习Node.js 推荐狼叔的《如何正确学习Node.js》，地址：https://github.com/i5ting/How-t","title":"内容分享"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;template\u0026gt; \u0026lt;view\u0026gt; \u0026lt;view class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;search-icon\u0026#34; src=\u0026#34;../../../static/zfdygl-search@2x.png\u0026#34; mode=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入行业名称/代码\u0026#34; v-model=\u0026#34;searchIdCard\u0026#34; maxlength=\u0026#34;18\u0026#34; @input=\u0026#34;handInputSearch\u0026#34; @confirm=\u0026#34;searchIDcardConfirm\u0026#34;confirm-type=\u0026#34;搜索\u0026#34; /\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;view class=\u0026#34;search-content\u0026#34;\u0026gt; \u0026lt;view class=\u0026#34;li one-line-overflow\u0026#34; v-for=\u0026#34;(sItem,sIndex) in searchList\u0026#34; :key=\u0026#34;sIndex\u0026#34;\u0026gt; \u0026lt;text v-html=\u0026#34;sItem.industry_code\u0026#34;\u0026gt;\u0026lt;/text\u0026gt;- \u0026lt;text v-html=\u0026#34;sItem.industry_name\u0026#34;\u0026gt;\u0026lt;/text\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; methods:{ brightKeyword(val) { let keyword = this.searchIdCard.toString(); if (val.indexOf(keyword) !== -1) { return val.replace(keyword, `\u0026lt;span style=\u0026#34;color:#3995FF;font-weight:bold;\u0026#34;\u0026gt;${keyword}\u0026lt;/span\u0026gt;`) } else { return val } }, handInputSearch(e){ clearTimeout(this.searchTime); this.searchTime = setTimeout(() =\u0026gt; { this.searchForm.industry_code = e.detail.value; this.searchForm.parent_indu = \u0026#34;\u0026#34;; this.getDataist(this.searchForm); }, 500) }, getDataist(){ Service.apiIndustryList(fd).then(res =\u0026gt; { if (res.RetCode == 100) { this.searchList = []; res.data.industry.forEach(i =\u0026gt; { i.industry_name = this.brightKeyword(i.industry_name) i.industry_code = this.brightKeyword(i.industry_code) }) this.searchList = res.data.industry }).catch(error =\u0026gt; { console.log(error) }) } } ","permalink":"https://bablvsj.github.io/posts/tech/frontend/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E5%85%B3%E9%94%AE%E5%AD%97%E9%AB%98%E4%BA%AE/","summary":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;template\u0026gt; \u0026lt;view\u0026gt; \u0026lt;view class=\u0026#34;search\u0026#34;\u0026gt; \u0026lt;image class=\u0026#34;search-icon\u0026#34; src=\u0026#34;../../../static/zfdygl-search@2x.png\u0026#34; mode=\u0026#34;\u0026#34;\u0026gt;\u0026lt;/image\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=","title":"模糊查询关键字高亮"},{"content":"字体分类 常见的字体可以分为两类：衬线体、无衬线体。\n1、serif（衬线体）：在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同。\n常见的衬线体有：\n宋体、楷体\nTimes New Roman\n2、sans-serif（无衬线体）：笔划粗细基本一致，只剩下主干，造型简明有力，起源也很晚。适用于标题、广告等，识别性高。\n常见的无衬线体有：\n黑体 Windows 平台默认的中文字体：微软雅黑（Microsoft Yahei） Windows 平台默认的英文字体：Arial Mac \u0026amp; iOS 平台默认的中文字体：苹方（PingFang SC） Mac \u0026amp; iOS 平台默认的英文字体：San Francisco Android 平台默认字体：Droid Sans 字体族 CSS 中的字体族可以理解成是某一类字体。常见的字体族可以分为五类：\nserif：衬线体。 sans-serif：无衬线体。 monospace：等宽字体。每一个字母所占的宽度是相同的。写代码的字体尽量用等宽字体。 cursive：手写字体。比如徐静蕾手写体。 fantasy：梦幻字体。比如一些艺术字。 多字体 fallback 机制 多字体 fallback 机制：当指定的字体找不到（或者某些文字不支持这个字体）时，那就接着往后找。比如：\n1 2 3 .div1{ font-family: \u0026#34;PingFang SC\u0026#34;, \u0026#34;Microsoft Yahei\u0026#34;, monospace; } 上方 CSS 代码的意思是：让指定标签元素中的文字，在 Mac \u0026amp; iOS 平台用苹方字体，在 Win 平台用微软雅黑字体，如果这两个字体都没有，就随便找一个等宽的字体进行渲染。\nfont-weight：字体的加粗属性 font-weight 属性：在设置字体是否加粗时，属性值既可以直接填写 100 至 900 这样的数字，也可以填写normal、bold这样的单词。normal的值相当于 400，bold的值相当于 700。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 font-weight: 100; font-weight: 200; font-weight: 300; font-weight: 400; font-weight: 500; font-weight: 600; font-weight: 700; font-weight: 800; font-weight: 900; font-weight: normal; // 相当于 400 font-weight: bold; // 相当于 700 各大平台的默认字体加粗效果 Mac \u0026amp; iOS 平台的“苹方”字体：500 和600，加粗效果是不同的；\u0026gt;=600的加粗效果是相同的。\nWindows 平台的“微软雅黑”字体：只有 \u0026gt;=600 才会加粗，而且加粗效果相同。\nAndroid 平台的 Droid Sans 字体，只有 \u0026gt;=700才会加粗；而且加粗效果相同。\n推荐字体 Arual 这是一款设计师都爱用的英文字体，简单实用。\n最后一段 所谓「见微知著」，一个再不起眼的知识点，也是有很多学问的。光是“字体”这一点，就足够成为一门学科。\n2005年，苹果公司创始人乔布斯（Steve Jobs）在斯坦福大学的毕业典礼演讲上，有过这样一段话：\n当时的我从来没有期盼过我所学的这些东西，能够在我的生活中有什么实际的用处。\n但是到了十年之后，当我们在设计第一台 Macintosh 电脑时，这些所学都涌进了我的头脑。于是，我把这些设计融入到了 Mac 电脑之中，这也使这台 Mac 成为了第一台拥有漂亮字体的电脑。\n可以说，如果我当时没有退学，就不会有机会去参加我感兴趣的美术字课程，Mac 也就不会拥有那些美妙的排版和字体。而当 Windows 系统借鉴了Mac之后，似乎所有的电脑都应该是这个样子。\n当时的我没有办法把这些点点滴滴连接起来，但是，当我十年后回顾的时候，一切都变得豁然开朗。\n推荐阅读 常见的免费字体：http://zenozeng.github.io/Free-Chinese-Fonts/\niconfont\n乔布斯斯坦福大学演讲-翻译\n乔布斯斯坦福大学演讲-翻译\n阿里巴巴官方发布免费商用字体：阿里巴巴普惠体\n得到 | 从甲骨文至得到今楷，造字的人都是神\n《独立宣言》使用了什么字体？\n你的版权常识指南\n免费商用 | 这几款字体你值得拥有\n","permalink":"https://bablvsj.github.io/posts/tech/wait/01-html/03-%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%BC%80%E5%8F%91%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%AD%97%E4%BD%93%E7%9A%84%E5%B8%B8%E8%AF%86/","summary":"字体分类 常见的字体可以分为两类：衬线体、无衬线体。 1、serif（衬线体）：在字的笔画开始、结束的地方有额外的装饰，而且笔画的粗细会有所不同","title":"网页设计和开发中，关于字体的常识"},{"content":"命令总结\n命令参数的长格式与短格式示例\n长格式 短格式 man \u0026ndash;help man -h 一、常用系统工作命令 1．echo - 输出值 echo 命令用于在终端输出字符串或变量提取后的值，格式为“echo [字符串 | $变量]”。\n例如，把指定字符串“Linuxprobe.com”输出到终端屏幕的命令为： [root@linuxprobe ~]# echo Linuxprobe.Com 该命令会在终端屏幕上显示如下信息： Linuxprobe.Com\n下面，我们使用$变量的方式提取变量 SHELL 的值，并将其输出到屏幕上： [root@linuxprobe ~]# echo $SHELL /bin/bash\n2．date - 时间相关 date 命令用于显示及设置系统的时间或日期，格式为“date [选项] [+指定的格式]”。\n只需在date 命令以“+”号开头的参数，即可按照指定格式来输出系统的时间或日期。 例如，把打包后的文件自动按照“年-月-日”的格式打包成“backup-2017-9-1.tar.gz”， 用户只需要看一眼文件名称就能大概了解到每个文件的备份时间了。\ndate 命令中常见的参数格式及作用\n参数 作用 %t 跳格[Tab 键] %H 小时（00～23） %I 小时（00～12） %M 分钟（00～59） %S 秒（00～59） %j 今年中的第几天 按照默认格式查看当前系统时间的 date 命令 [root@linuxprobe ~]# date Mon Aug 24 16:11:23 CST 2017\n按照“年-月-日 小时:分钟:秒”的格式查看当前系统时间的 date 命令 [root@linuxprobe ~]# date \u0026ldquo;+%Y-%m-%d %H:%M:%S\u0026rdquo; 2017-08-24 16:29:12\n将系统的当前时间设置为 2017 年 9 月 1 日 8 点 30 分的 date 命令 [root@linuxprobe ~]# date -s \u0026ldquo;20170901 8:30:00\u0026rdquo; Fri Sep 1 08:30:00 CST 2017\n再次使用 date 命令并按照默认的格式查看当前的系统时 [root@linuxprobe ~]# date Fri Sep 1 08:30:01 CST 2017\ndate 命令中的参数%j 可用来查看今天是当年中的第几天。 [root@linuxprobe ~]# date \u0026ldquo;+%j\u0026rdquo; 244\n3．reboot - 系统重启 reboot 命令用于重启系统，其格式为 reboot。\n由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用 root 管理员来 重启，其命令如下： [root@linuxprobe ~]# reboot\n4．poweroff - 关闭系统 poweroff 命令用于关闭系统，其格式为 poweroff。\n该命令与 reboot 命令相同，都会涉及硬件资源的管理权限，因此默认只有 root 管理员才 可以关闭电脑，其命令如下： [root@linuxprobe ~]# poweroff\n5．wget - 下载网络文件 wget 命令用于在终端中下载网络文件，格式为“wget [参数] 下载地址”。 wget 命令的参数以及作用\n参数 作用 -b 后台下载模式 -P 下载到指定目录 -t 最大尝试次数 -c 断点续传 -p 下载页面内所有资源，包括图片、视频等 -r 递归下载 尝试使用 wget 命令从本书的配套站点中下载本书的最新 pdf 格式电子文档，这个文件的完整路径为 http://www.linuxprobe.com/docs/LinuxProbe.pdf ，执行该命令后的下载效果如下： [root@linuxprobe ~]# wget http://www.linuxprobe.com/docs/LinuxProbe.pdf \u0026ndash;2017-08-24 19:30:12 \u0026ndash; http://www.linuxprobe.com/docs/LinuxProbe.pdf Resolving www.linuxprobe.com (www.linuxprobe.com)\u0026hellip; 220.181.105.185 Connecting to www.linuxprobe.com (www.linuxprobe.com)|220.181.105.185|:80\u0026hellip; connected. HTTP request sent, awaiting response\u0026hellip; 200 OK Length: 45948568 (44M) [application/pdf] Saving to: ‘LinuxProbe.pdf’ 100%[===========================================\u0026gt;] 45,948,568 32.9MB/s in 1.3s 2017-08-24 19:30:14 (32.9 MB/s) - ‘LinuxProbe.pdf’ saved [45948568/45948568]\n接下来，我们使用 wget 命令递归下载 www.linuxprobe.com 网站内的所有页面数据以及文件，下载完后会自动保存到当前路径下一个名为 www.linuxprobe.com 的目录中。执行该操作的命令为 wget -r -p http://www.linuxprobe.com ，该命令的执行结果如下: [root@linuxprobe ~]# wget -r -p http://www.linuxprobe.com \u0026ndash;2017-08-24 19:31:41\u0026ndash; http://www.linuxprobe.com/ Resolving www.linuxprobe.com\u0026hellip; 106.185.25.197 Connecting to www.linuxprobe.com|106.185.25.197|:80\u0026hellip; connected. HTTP request sent, awaiting response\u0026hellip; 200 OK Length: unspecified [text/html] Saving to: \u0026lsquo;www.linuxprobe.com/index.html' ………………省略下载过程………………\n6．ps - 查看进程状态 ps 命令用于查看系统中的进程状态，格式为“ps [参数]”。\nps 命令与管道符技术搭配使用，用来抓取与某个指定服务进程相对应的 PID 号码。 ps 命令的参数以及作用\n参数 作用 -a 显示所有进程（包括其他用户的进程） -u 用户以及其他详细信息 -x 显示没有控制终端的进程 Linux 系统中，有 5 种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。\nR（运行）：进程正在运行或在运行队列中等待。 S（中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。 D（不可中断）：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。 Z（僵死）：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数后将进程释放。 T（停止）：进程收到停止信号后停止运行。 当执行 ps aux 命令后通常会看到如表 2-7 所示的进程状态，表 2-7 中只是列举了部分输出值，而且正常的输出值中不包括中文注释。\n进程状态\n进程的所有者 进 程ID 号 运算器占用率 内存占用率 虚拟内存使用量（单位是 KB） 占用的固定内存量（单位是KB） 所在终端 进程状态 被启动的时间 实际使用CPU的时间 命令名称与参数 USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND root 1 0.0 0.4 53684 7628 ? Ss 07 :22 0:02 /usr/lib/systemd/systemd root 2 0.0 0.0 0 0 ? S 07:22 0:00 [kthreadd] ………………省略部分输出信息……………… 7．top 命令 top 命令用于动态地监视进程活动与系统负载等信息，其格式为 top。 top 命令相当强大，能够动态地查看系统运维状态，完全将它看作 Linux 中的“强化版的 Windows 任务管理器”。top 命令的运行界面如下\n1 2 3 4 5 top - 19:19:51 up 11 min， 2 users, load average : 0.01, 0.17, 0.19 Tasks: 519 total, 2 running, 517 sleeping, 0 stopped, 0 zombie %Cpu(s): 1.1 us, 0.6 sy, 0.0 ni, 97.1 id, 1.1 wa, 0.0 hi, 0.0 si, 0.0 st KiB Mem: 3869044 total, 900604 used, 2968440 free, 924 buffers KiB Swap: 2097148 total, 0 used, 2097148 free, 278556 cached Mem top 命令执行结果的前 5 行为系统整体的统计信息，其所代表的含义如下。\n第 1 行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为 1 分钟、5分钟、15 分钟内的平均值，数值越小意味着负载越低）。 第 2 行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。 第 3 行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。 注：第 3 行中的数据均为 CPU 数据并以百分比格式显示，例如“97.1 id”意味着有 97.1%的 CPU 处理器资源处于空闲。 第 4 行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。 第 5 行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。 8．pidof 查询某个进程PID pidof 命令用于查询某个指定服务进程的 PID 值，格式为“pidof [参数] [服务名称]”。\n每个进程的进程号码值（PID）是唯一的，因此可以通过 PID 来区分不同的进程。例如， 可以使用如下命令来查询本机上 sshd 服务程序的 PID： [root@linuxprobe ~]# pidof sshd 2156\n9．kill - 中止单个进程 kill 命令用于终止某个指定 PID 的服务进程，格式为“kill [参数] [进程 PID]”。\n接下来，我们使用 kill 命令把上面用 pidof 命令查询到的 PID 所代表的进程终止掉，其命令如下所示。 这种操作的效果等同于强制停止 sshd 服务。 [root@linuxprobe ~]# kill 2156\n10．killall - 中止批量进程 killall 命令用于终止某个指定名称的服务所对应的全部进程，格式为：“killall [参数] [进程名称]”。\n通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用 killall 命令来批量结束某个服务程序带有的全部进程。下面以 httpd 服务程序为例，来结束其全部进程。由于 RHEL7 系统默认没有安装 httpd 服务程序，因此大家此时只需看操作过程和输出结果即可，等学习了相关内容之后再来实践。\n[root@linuxprobe ~]# pidof httpd 13581 13580 13579 13578 13577 13576 [root@linuxprobe ~]# killall httpd [root@linuxprobe ~]# pidof httpd [root@linuxprobe ~]#\n如果我们在系统终端中执行一个命令后想立即停止它，可以同时按下 Ctrl + C 组合键，这样将立即终止该命令的进程。 或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加上一个\u0026amp;符号，这样命令将进入系统后台来执行。\n二、系统状态检测命令 1．ifconfig - 网卡配置与网络状态 ifconfig 命令用于获取网卡配置与网络状态等信息，格式为“ifconfig [网络设备] [参数]”。\n使用 ifconfig 命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet 参数后面的 IP 地址、ether 参数后面的网卡物理地址（又称为 MAC 地址），以及 RX、TX 的接收数据包与发送数据包的个数及累计流量（即下面加粗的信息内容）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@linuxprobe ~]# ifconfig eno16777728: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.10.10 netmask 255.255.255.0 broadcast 192.168.10.255 inet6 fe80::20c:29ff:fec4:a409 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 00:0c:29:c4:a4:09 txqueuelen 1000 (Ethernet) RX packets 36 bytes 3176 (3.1 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 38 bytes 4757 (4.6 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 lo: flags=73\u0026lt;UP,LOOPBACK,RUNNING\u0026gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10\u0026lt;host\u0026gt; loop txqueuelen 0 (Local Loopback) RX packets 386 bytes 32780 (32.0 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 386 bytes 32780 (32.0 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 2．uname - 系统内核与系统版本 uname 命令用于查看系统内核与系统版本等信息，格式为“uname [-a]”。\n在使用 uname 命令时，一般会固定搭配上-a 参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。\n[root@linuxprobe ~]# uname -a Linux linuxprobe.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 x86_64 x86_64 x86_64 GNU/Linux\n顺带一提，如果要查看当前系统版本的详细信息，则需要查看 redhat-release 文件，其命令以及相应的结果如下： [root@linuxprobe ~]# cat /etc/redhat-release Red Hat Enterprise Linux Server release 7.0 (Maipo)\n3．uptime - 系统负载信息 uptime 用于查看系统的负载信息，格式为 uptime。\nuptime 命令真的很棒，它可以显示当前系统时间、系统已运行时间、启用终端数量以及平均负载值等信息。 负载值越低越好，尽量不要长期超过 1，在生产环境中不要超过 5。\n平均负载值指的是系统在最近 1 分钟、5 分钟、15 分钟内的压力情况； [root@linuxprobe ~]# uptime 22:49:55 up 10 min, 2 users, load average: 0.01, 0.19, 0.18\n4．free - 内存使用量 free 用于显示当前系统中内存的使用量信息，格式为“free [-h]”。\n可以结合使用 -h 参数以更人性化的方式输出当前内存的实时使用量信息。 [root@linuxprobe ~]# free -h 执行 free -h 命令后的输出信息\n内存总量 已用量 可用量 进程共享的内存量 磁盘缓存的内存量 缓存的内存量 total used free shared buffers cached Mem 1.8GB 1.3GB 542MB 9.8MB 1.6MB 413MB -/+ buffers/cache 869MB 957MB Swap 2.0GB 0 2.0GB 5．who - 登入主机的用户终端信息 who 用于查看当前登入主机的用户终端信息，格式为“who [参数]”。\n这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端信息。 [root@linuxprobe ~]# who 执行 who 命令的结果\n登录的用户名 终端设备 登录到系统的时间 root :0 2017-08-24 17:52 (:0) root pts/0 2017-08-24 17:52 (:0) 6．last - 系统的登录记录 last 命令用于查看所有系统的登录记录，格式为“last [参数]”。\n使用 last 命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此黑客可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！\n1 2 3 4 5 6 7 8 [root@linuxprobe ~]# last root pts/0 :0 Mon Aug 24 17:52 still logged in root :0 :0 Mon Aug 24 17:52 still logged in (unknown :0 :0 Mon Aug 24 17:50 - 17:52 (00:02) reboot system boot 3.10.0-123.el7.x Tue Aug 25 01:49 - 18:17 (-7:-32) root pts/0 :0 Mon Aug 24 15:40 - 08:54 (7+17:14) root pts/0 :0 Fri Jul 10 10:49 - 15:37 (45+04:47) ………………省略部分登录信息……………… 7．history - 显示历史执行过的命令 history 命令用于显示历史执行过的命令，格式为“history [-c]”。\nhistory 命令应该是作者最喜欢的命令。执行 history 命令能显示出当前用户在本地计算机中执行过的最近 1000 条命令记录。如果觉得 1000 不够用，还可以自定义/etc/profile 文件中的HISTSIZE 变量值。在使用 history 命令时，如果使用-c 参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [root@linuxprobe ~]# history 1 tar xzvf VMwareTools-9.9.0-2304977.tar.gz 2 cd vmware-tools-distrib/ 3 ls 4 ./vmware-install.pl -d 5 reboot 6 df -h 7 cd /run/media/ 8 ls 9 cd root/ 10 ls 11 cd VMware\\ Tools/ 12 ls 13 cp VMwareTools-9.9.0-2304977.tar.gz /home 14 cd /home 15 ls 16 tar xzvf VMwareTools-9.9.0-2304977.tar.gz 17 cd vmware-tools-distrib/ 18 ls 19 ./vmware-install.pl -d 20 reboot 21 history [root@linuxprobe ~]# !15 anaconda-ks.cfg Documents initial-setup-ks.cfg Pictures Templates Desktop Downloads Music Public Videos 历史命令会被保存到用户家目录中的.bash_history 文件中。Linux 系统中以点（.）开头的文件均代表隐藏文件，这些文件大多数为系统服务文件，可以用 cat 命令查看其文件内容。 [root@linuxprobe ~]# cat ~/.bash_history 要清空当前用户在本机上执行的 Linux 命令历史记录信息，可执行如下命令： [root@linuxprobe ~]# history -c\n8．sosreport - 系统配置及架构信息 sosreport 命令用于收集系统配置及架构信息并输出诊断文档，格式为 sosreport。\n当 Linux 系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，亦或让他们能提前了解某些复杂问题。在下面的输出信息中，加粗的部分是收集好的资料压缩文件以及校验码，将其发送给技术支持人员即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [root@linuxprobe ~]# sosreport sosreport (version 3.0) This command will collect diagnostic and configuration information from this Red Hat Enterprise Linux system and installed applications. An archive containing the collected information will be generated in /var/tmp and may be provided to a Red Hat support representative. Any information provided to Red Hat will be treated in accordance with the published support policies at: https://access.redhat.com/support/ The generated archive may contain data considered sensitive and its content should be reviewed by the originating organization before being passed to any third party. No changes will be made to system configuration. Press ENTER to continue, or CTRL-C to quit. 此处敲击回车来确认收集信息 Please enter your first initial and last name [linuxprobe.com]: 此处敲击回车来确认主机编号 Please enter the case number that you are generating this report for: 此处敲击回车来确认主机编号 Running plugins. Please wait ... Running 70/70: yum... Creating compressed archive... Your sosreport has been generated and saved in: /var/tmp/sosreport-linuxprobe.com-20170905230631.tar.xz The checksum is: 79436cdf791327040efde48c452c6322 Please send this file to your support representative. 三、工作目录切换命令 1．pwd - 当前所在工作目录 pwd 命令用于显示用户当前所处的工作目录，格式为“pwd [选项]”。 [root@linuxprobe etc]# pwd /etc\n2．cd - 切换工作路径 cd 命令用于切换工作路径，格式为“cd [目录名称]”。\n常见的切换目录方式： cd - 命令返回到上一次所处的目录 cd .. 命令进入上级目录 cd ~ 命令切换到当前用户的家目录 cd ~ username 切换到其他用户的家目录\n例如，可以使用“cd 路径”的方式切换进/etc 目录中： [root@linuxprobe ~]# cd /etc 同理，可使用下述命令切换到/bin 目录中： [root@linuxprobe etc]# cd /bin\n要返回到上一次的目录（即/etc 目录），可执行如下命令： [root@linuxprobe bin]# cd - /etc [root@linuxprobe etc]#\n通过下面的命令快速切换到用户的家目录： [root@linuxprobe etc]# cd ~ [root@linuxprobe ~]#\n3．ls - 显示目录中的文件信息 ls 命令用于显示目录中的文件信息，格式为“ls [选项] [文件] ”。\n所处的工作目录不同，当前工作目录下的文件肯定也不同。 使用 ls 命令的“-a”参数看到全部文件（包括隐藏文件）， 使用“-l”参数可以查看文件的属性、大小等详细信息。\n这两个参数整合之后，再执行 ls 命令即可查看当前目录中的所有文件并输出这些文件的属性信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 [root@linuxprobe ~]# ls -al total 60 dr-xr-x---. 14 root root 4096 May 4 07:56 . drwxr-xr-x. 17 root root 4096 May 4 15:55 .. -rw-------. 1 root root 1213 May 4 15:44 anaconda-ks.cfg -rw-------. 1 root root 957 May 4 07:54 .bash_history -rw-r--r--. 1 root root 18 Dec 28 2013 .bash_logout -rw-r--r--. 1 root root 176 Dec 28 2013 .bash_profile -rw-r--r--. 1 root root 176 Dec 28 2013 .bashrc drwx------. 10 root root 4096 May 4 07:56 .cache drwx------. 15 root root 4096 May 4 07:49 .config -rw-r--r--. 1 root root 100 Dec 28 2013 .cshrc drwx------. 3 root root 24 May 4 07:46 .dbus drwxr-xr-x. 2 root root 6 May 4 07:49 Desktop drwxr-xr-x. 2 root root 6 May 4 07:49 Documents drwxr-xr-x. 2 root root 6 May 4 07:49 Downloads -rw-------. 1 root root 16 May 4 07:49 .esd_auth -rw-------. 1 root root 628 May 4 07:56 .ICEauthority -rw-r--r--. 1 root root 1264 May 4 07:48 initial-setup-ks.cfg drwx------. 3 root root 18 May 4 07:49 .local drwxr-xr-x. 2 root root 6 May 4 07:49 Music drwxr-xr-x. 2 root root 6 May 4 07:49 Pictures drwxr-xr-x. 2 root root 6 May 4 07:49 Public -rw-r--r--. 1 root root 129 Dec 28 2013 .tcshrc drwxr-xr-x. 2 root root 6 May 4 07:49 Templates drwxr-xr-x. 2 root root 6 May 4 07:49 Videos -rw-------. 1 root root 1962 May 4 07:54 .viminfo 如果想要查看目录属性信息，则需要额外添加一个-d 参数。例如，可使用如下命令查看 /etc 目录的权限与属性信息： [root@linuxprobe ~]# ls -ld /etc drwxr-xr-x. 132 root root 8192 Jul 10 10:48 /etc\n四、文本文件编辑命令 1．cat - 文本文件_内容较少的 cat 命令用于查看纯文本文件（内容较少的），格式为“cat [选项] [文件]”。\nLinux 系统中有多个用于查看文本内容的命令，每个命令都有自己的特点，比如这个 cat命令就是用于查看内容较少的纯文本文件的。\n如果在查看文本内容时还想顺便显示行号的话，不妨在 cat 命令后面追加一个-n 参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@linuxprobe ~]# cat -n initial-setup-ks.cfg 1 #version=RHEL7 2 # X Window System configuration information 3 xconfig --startxonboot 4 5 # License agreement 6 eula --agreed 7 # System authorization information 8 auth --enableshadow --passalgo=sha512 9 # Use CDROM installation media 10 cdrom 11 # Run the Setup Agent on first boot 12 firstboot --enable 13 # Keyboard layouts 14 keyboard --vckeymap=us --xlayouts=\u0026#39;us\u0026#39; 15 # System language 16 lang en_US.UTF-8 ………………省略部分输出信息……………… 2．more - 文本文件_内容多的 more 命令用于查看纯文本文件（内容较多的），格式为“more [选项]文件”。\n对于长篇的文本内容，推荐使用 more 命令来查看。more命令会在最下面使用百分比的形式来提示您已经阅读了多少内容。您还可以使用空格键或回车键向下翻页：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [root@linuxprobe ~]# more initial-setup-ks.cfg #version=RHEL7 # X Window System configuration information xconfig --startxonboot # License agreement eula --agreed # System authorization information auth --enableshadow --passalgo=sha512 # Use CDROM installation media cdrom # Run the Setup Agent on first boot firstboot --enable # Keyboard layouts keyboard --vckeymap=us --xlayouts=\u0026#39;us\u0026#39; # System language lang en_US.UTF-8 ignoredisk --only-use=sda # Network information network --bootproto=dhcp --device=eno16777728 --onboot=off --ipv6=auto network --bootproto=dhcp --hostname=linuxprobe.com --More--(43%) 3．head - 文本文档的前 N 行 head 命令用于查看纯文本文档的前 N 行，格式为“head [选项] [文件]”。\n如果只想查看文本中前 20 行的内容，该怎么办呢？head 命令可以派上用场了： [root@linuxprobe ~]# head -n 20 initial-setup-ks.cfg\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 [root@linuxprobe ~]# head -n 20 initial-setup-ks.cfg #version=RHEL7 # X Window System configuration information xconfig --startxonboot # License agreement eula --agreed # System authorization information auth --enableshadow --passalgo=sha512 # Use CDROM installation media cdrom # Run the Setup Agent on first boot firstboot --enable # Keyboard layouts keyboard --vckeymap=us --xlayouts=\u0026#39;us\u0026#39; # System language lang en_US.UTF-8 ignoredisk --only-use=sda # Network information network --bootproto=dhcp --device=eno16777728 --onboot=off --ipv6=auto [root@linuxprobe ~]# 4．tail- 文本文档后 N 行/持续刷新内容 tail 命令用于查看纯文本文档的后 N 行或持续刷新内容，格式为“tail [选项] [文件]”。\n如需要查看文本内容的最后 20 行，只需要执行“tail -n 20 文件名”命令\ntail 命令最强悍的功能是可以持续刷新一个文件的内容，当想要实时查看最新日志文件时，这特别有用，此时的命令格式为“tail -f 文件名”：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@linuxprobe ~]# tail -f /var/log/messages May 4 07:56:38 localhost gnome-session: Window manager warning: Log level 16: STACK_OP_ADD: window 0x1e00001 already in stack May 4 07:56:38 localhost gnome-session: Window manager warning: Log level 16: STACK_OP_ADD: window 0x1e00001 already in stack May 4 07:56:38 localhost vmusr[12982]: [ warning] [Gtk] gtk_disable_setlocale() must be called before gtk_init() May 4 07:56:50 localhost systemd-logind: Removed session c1. Aug 1 01:05:31 localhost systemd: Time has been changed Aug 1 01:05:31 localhost systemd: Started LSB: Bring up/down networking. Aug 1 01:08:56 localhost dbus-daemon: dbus[1124]: [system] Activating service name=\u0026#39;com.redhat.SubscriptionManager\u0026#39; (using servicehelper) Aug 1 01:08:56 localhost dbus[1124]: [system] Activating service name=\u0026#39;com. redhat.SubscriptionManager\u0026#39; (using servicehelper) Aug 1 01:08:57 localhost dbus-daemon: dbus[1124]: [system] Successfully activated service \u0026#39;com.redhat.SubscriptionManager\u0026#39; Aug 1 01:08:57 localhost dbus[1124]: [system] Successfully activated service \u0026#39; com.redhat.SubscriptionManager\u0026#39; 5．tr - 替换文本文件中的字符 tr 命令用于替换文本文件中的字符，格式为“tr [原始字符] [目标字符]”。\n快速地替换文本中的一些词汇，就可以先使用 cat 命令读取待处理的文本，然后通过管道符把这些文本内容传递给 tr 命令进行替换操作即可。 例如，把某个文本内容中的英文全部替换为大写：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 [root@linuxprobe ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z] #VERSION=RHEL7 # SYSTEM AUTHORIZATION INFORMATION AUTH --ENABLESHADOW --PASSALGO=SHA512 # USE CDROM INSTALLATION MEDIA CDROM # RUN THE SETUP AGENT ON FIRST BOOT FIRSTBOOT --ENABLE IGNOREDISK --ONLY-USE=SDA # KEYBOARD LAYOUTS KEYBOARD --VCKEYMAP=US --XLAYOUTS=\u0026#39;US\u0026#39; # SYSTEM LANGUAGE LANG EN_US.UTF-8 # NETWORK INFORMATION NETWORK --BOOTPROTO=DHCP --DEVICE=ENO16777728 --ONBOOT=OFF --IPV6=AUTO NETWORK --HOSTNAME=LOCALHOST.LOCALDOMAIN # ROOT PASSWORD ROOTPW --ISCRYPTED $6$PDJJF42G8C6PL069$II.PX/YFAQPO0ENW2PA7MOMKJLYOAE2ZJMZ2UZJ7 BH3UO4OWTR1.WK/HXZ3XIGMZGJPCS/MGPYSSOI8HPCT8B/ # SYSTEM TIMEZONE TIMEZONE AMERICA/NEW_YORK --ISUTC USER --NAME=LINUXPROBE --PASSWORD=$6$A9V3INSTNBWEIR7D$JEGFYWBCDOOOKJ9SODECCDO. ZLF4OSH2AZ2SS2R05B6LZ2A0V2K.RJWSBALL2FEKQVGF640OA/TOK6J.7GUTO/ --ISCRYPTED -- GECOS=\u0026#34;LINUXPROBE\u0026#34; # X WINDOW SYSTEM CONFIGURATION INFORMATION XCONFIG --STARTXONBOOT # SYSTEM BOOTLOADER CONFIGURATION BOOTLOADER --LOCATION=MBR --BOOT-DRIVE=SDA AUTOPART --TYPE=LVM # PARTITION CLEARING INFORMATION CLEARPART --NONE --INITLABEL %PACKAGES @BASE @CORE @DESKTOP-DEBUGGING @DIAL-UP @FONTS @GNOME-DESKTOP @GUEST-AGENTS @GUEST-DESKTOP-AGENTS @INPUT-METHODS @INTERNET-BROWSER @MULTIMEDIA @PRINT-CLIENT @X11 %END 6．wc - 统计文本的字数行数字节数 wc 命令用于统计指定文本的行数、字数、字节数，格式为“wc [参数] 文本”。\nwc 的参数以及作用\n参数 作用 -l 只显示行数 -w 只显示单词数 -c 只显示字节数 在 Linux 系统中，passwd 是用于保存系统账户信息的文件，要统计当前系统中有多少个 用户，可以使用下面的命令来进行查询，是不是很神奇： [root@linuxprobe ~]# wc -l /etc/passwd 38 /etc/passwd\n7．stat - 文件具体存储信息和时间 stat 命令用于查看文件的具体存储信息和时间等信息，格式为“stat 文件名称”。\n命令 stat anaconda-ks.cfg 会显示出文件的三种时间状态：Access、Modify、Change。这三种时间的区别将在下面的 touch命令中详细详解：\n1 2 3 4 5 6 7 8 9 10 [root@linuxprobe ~]# stat anaconda-ks.cfg File: ‘anaconda-ks.cfg’ Size: 1213 Blocks: 8 IO Block: 4096 regular file Device: fd00h/64768d Inode: 68912908 Links: 1 Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root) Context: system_u:object_r:admin_home_t:s0 Access: 2017-07-14 01:46:18.721255659 -0400 Modify: 2017-05-04 15:44:36.916027026 -0400 Change: 2017-05-04 15:44:36.916027026 -0400 Birth: - 8．cut - 按“列”提取文本字符 cut 命令用于按“列”提取文本字符，格式为“cut [参数] 文本”。\n一般而言，按基于“行”的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。 但是如果按列搜索，不仅要使用-f 参数来设置需要看的列数，还需要使用-d 参数来设置间隔符号。 passwd 在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用 下述命令尝试提取出 passwd 文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 [root@linuxprobe ~]# head -n 2 /etc/passwd root❌0:0:root:/root:/bin/bash bin❌1:1:bin:/bin:/sbin/nologin [root@linuxprobe ~]# cut -d: -f1 /etc/passwd root bin daemon adm lp sync shutdown halt mail operator games ftp nobody dbus polkitd unbound colord usbmuxd avahi avahi-autoipd libstoragemgmt saslauth qemu rpc 9．diff - 比较多个文本文件的差异 diff 命令用于比较多个文本文件的差异，格式为“diff [参数] 文件”。\n可以使用 \u0026ndash;brief 参数来确认两个文件是否不同 可以使用 -c 参数来详细比较出多个文件的差异之处 先使用 cat 命令分别查看 diff_A.txt 和 diff_B.txt 文件的内容，然后进行比较： [root@linuxprobe ~]# cat diff_A.txt Welcome to linuxprobe.com Red Hat certified Free Linux Lessons Professional guidance Linux Course\n[root@linuxprobe ~]# cat diff_B.txt Welcome tooo linuxprobe.com Red Hat certified Free Linux LeSSonS ////////\u0026hellip;..//////// Professional guidance Linux Course\n接下来使用 diff \u0026ndash;brief 命令显示比较后的结果，判断文件是否相同： [root@linuxprobe ~]# diff \u0026ndash;brief diff_A.txt diff_B.txt Files diff_A.txt and diff_B.txt differ\n最后使用带有-c 参数的 diff 命令来描述文件内容具体的不同：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [root@linuxprobe ~]# diff -c diff_A.txt diff_B.txt *** diff_A.txt 2017-08-30 18:07:45.230864626 +0800 --- diff_B.txt 2017-08-30 18:08:52.203860389 +0800 *************** *** 1,5 **** ! Welcome to linuxprobe.com Red Hat certified ! Free Linux Lessons Professional guidance Linux Course --- 1,7 ---- ! Welcome tooo linuxprobe.com ! Red Hat certified ! Free Linux LeSSonS ! ////////.....//////// Professional guidance Linux Course 五、文件目录管理命令 1．touch - 创建空白文件/设置文件时间 touch 命令用于创建空白文件或设置文件的时间，格式为“touch [选项] [文件]”。\n比如，touch linuxprobe 命令可以创建出一个名为 linuxprobe 的空白文本文件。 对 touch 命令来讲，有难度的操作主要是体现在 设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime） 上面。 touch 命令的参数及其作用如表所示\n参数 作用 -a 仅修改“读取时间”（atime） -m 仅修改“修改时间”（mtime） -d 同时修改 atime 与 mtime 接下来我们先使用 ls 命令查看一个文件的修改时间，然后修改这个文件，最后再通过 touch 命令把修改后的文件时间设置成修改之间的时间（很多黑客就是这样做的呢）：\n1 2 3 4 5 6 7 8 9 10 11 12 [root@linuxprobe ~]# ls -l anaconda-ks.cfg //查看文件的修改时间 -rw-------. 1 root root 1213 May 4 15:44 anaconda-ks.cfg [root@linuxprobe ~]# echo \u0026#34;Visit the LinuxProbe.com to learn linux skills\u0026#34; \u0026gt;\u0026gt; anaconda-ks.cfg //修改文件 [root@linuxprobe ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1260 Aug 2 01:26 anaconda-ks.cfg [root@linuxprobe ~]# touch -d \u0026#34;2017-05-04 15:44\u0026#34; anaconda-ks.cfg //设置文件的修改时间 [root@linuxprobe ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1260 May 4 15:44 anaconda-ks.cfg 2．mkdir - 创建空白的目录 mkdir 命令用于创建空白的目录，格式为“mkdir [选项] 目录”。 [root@linuxprobe ~]# mkdir linuxprobe [root@linuxprobe ~]# cd linuxprobe\nmkdir命令还可以结合-p 参数来递归创建出具有嵌套叠层关系的文件目录。 [root@linuxprobe linuxprobe]# mkdir -p a/b/c/d/e [root@linuxprobe linuxprobe]# cd a [root@linuxprobe a]# cd b [root@linuxprobe b]#\n3．cp - 复制文件/目录 cp 命令用于复制文件或目录，格式为“cp [选项] 源文件 目标文件”。\n复制操作具体分为 3 种情况：\n如果目标文件是目录，则会把源文件复制到该目录中； 如果目标文件也是普通文件，则会询问是否要覆盖它； 如果目标文件不存在，则执行正常的复制操作 cp 命令的参数及其作用\n参数 作用 -a 仅修改“读取时间”（atime） -m 仅修改“修改时间”（mtime） -d 同时修改 atime 与 mtime -p 保留原始文件的属性 -d 若对象为“链接文件”，则保留该“链接文件”的属性 -i 若目标文件存在则询问是否覆盖 -a 相当于-pdr（p、d、r 为上述参数） 接下来，使用 touch 创建一个名为 install.log 的普通空白文件，然后将其复制为一份名为 x.log 的备份文件，最后再使用 ls 命令查看目录中的文件： [root@linuxprobe ~]# touch install.log [root@linuxprobe ~]# cp install.log x.log [root@linuxprobe ~]# ls install.log x.log\n4．mv - 剪切文件/文件重命名 mv 命令用于剪切文件或将文件重命名，格式为“mv [选项] 源文件 [目标路径|目标文件名]”。\n如果在同一个目录中对一个文件进行剪切操作，其实也就是对其进行重命名： [root@linuxprobe ~]# mv x.log linux.log [root@linuxprobe ~]# ls install.log linux.log\n5．rm - 删除文件/目录 rm 命令用于删除文件或目录，格式为“rm [选项] 文件”。 rm -f 强制删除 rm -r 删除一个目录\n我们来尝试删除前面创建的 install.log和 linux.log 文件： [root@linuxprobe ~]# rm install.log rm: remove regular empty file ‘install.log’? y [root@linuxprobe ~]# rm -f linux.log [root@linuxprobe ~]# ls [root@linuxprobe ~]#\n6．dd - 按指定大学复制文件 dd 命令用于按照指定大小和个数的数据块来复制文件或转换文件，格式为“dd [参数]”。\ndd 命令它能够让用户按照指定大小和个数的数据块来复制文件的内容。 当然如果愿意的话，还可以在复制过程中转换其中的数据。 Linux系统中有一个名为/dev/zero 的设备文件，每次在课堂上解释它时都充满哲学理论的色彩。因为这个文件不会占用系统存储空间，但却可以提供无穷无尽的数据，因此可以使用它作为 dd命令的输入文件，来生成一个指定大小的文件。\ndd 命令的参数及其作用\n参数 作用 if 输入的文件名称 of 输出的文件名称 bs 设置每个“块”的大小 count 设置要复制“块”的个数 例如我们可以用 dd 命令从/dev/zero 设备文件中取出一个大小为 560MB 的数据块，然后 保存成名为 560_file 的文件。 [root@linuxprobe ~]# dd if=/dev/zero of=560_file count=1 bs=560M 1+0 records in 1+0 records out 587202560 bytes (587 MB) copied, 27.1755 s, 21.6 MB/s\ndd 命令的功能不仅限于复制文件 如果您想把光驱设备中的光盘制作成 iso 格式的镜像文件，在 Windows 系统中需要借助于第三方软件才能做到，但在 Linux 系统中可以直接使用 dd 命令来压制出光盘镜像文件，将它编程一个可立即使用的 iso 镜像： [root@linuxprobe ~]# dd if=/dev/cdrom of=RHEL-server-7.0-x86_64-LinuxProbe.Com.iso 7311360+0 records in 7311360+0 records out 3743416320 bytes (3.7 GB) copied, 370.758 s, 10.1 MB/s\n考虑到有些读者会纠结 bs 块大小与 count 块个数的关系，下面举一个吃货的例子进行解释。假设小明的饭量（即需求）是一个固定的值，用来盛饭的勺子的大小即 bs 块大小，而用勺子盛饭的次数即 count 块个数。小明要想吃饱（满足需求），则需要在勺子大小（bs块大小）与用勺子盛饭的次数（count 块个数）之间进行平衡。勺子越大，用勺子盛饭的次数就越少。有上可见，bs 与 count 都是用来指定容量的大小，只要能满足需求，可随意组合搭配方式。\n7．file - 查看文件的类型 file 命令用于查看文件的类型，格式为“file 文件名”。\n[root@linuxprobe ~]# file anaconda-ks.cfg anaconda-ks.cfg: ASCII text [root@linuxprobe ~]# file /dev/sda /dev/sda: block special\n六、打包压缩与搜索命令 1．tar - 打包压缩或解压 tar 命令用于对文件进行打包压缩或解压，格式为“tar [选项] [文件]”。\n在 Linux 系统中，常见的文件格式比较多，其中主要使用的是.tar 或.tar.gz 或.tar.bz2 格式，其实这些格式大部分都是由 tar 命令来生成的。 tar 命令的参数及其作用\n参数 作用 -c 创建压缩文件 -x 解开压缩文件 -t 查看压缩包内有哪些文件 -z 用 Gzip 压缩或解压 -j 用 bzip2 压缩或解压 -v 显示压缩或解压的过程 -f 目标文件名 -p 保留原始的权限与属性 -P 使用绝对路径来压缩 -C 指定解压到的目录 首先，-c 参数用于创建压缩文件，-x 参数用于解压文件，因此这两个参数不能同时使用。 其次，-z 参数指定使用 Gzip 格式来压缩或解压文件，-j 参数指定使用 bzip2 格式来压缩或解 压文件。用户使用时则是根据文件的后缀来决定应使用何种格式参数进行解压。 推荐使用-v 参数向用户不断显示压缩或解压的过程。 -C 参数用于指定要解压到哪个指定的目录。 -f 参数特别重要，它必须放到参数的最后一位，代表要压缩或解压的软件包名称。\n刘遄老师一般使用“tar -czvf 压缩包名称.tar.gz 要打包的目录” 命令把指定的文件进行打包压缩；相应的解压命令为“tar -xzvf 压缩包名称.tar.gz”。\n下面我们来逐个演示下打包压缩与解压的操作。 先使用 tar 命令把/etc 目录通过 gzip 格式进行打包压缩，并把文件命名为 etc.tar.gz：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [root@linuxprobe ~]# tar -czvf etc.tar.gz /etc tar: Removing leading \u0026#39;/\u0026#39; from member names /etc/ /etc/fstab /etc/crypttab /etc/mtab /etc/fonts/ /etc/fonts/conf.d/ /etc/fonts/conf.d/65-0-madan.conf /etc/fonts/conf.d/59-liberation-sans.conf /etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf /etc/fonts/conf.d/59-liberation-mono.conf /etc/fonts/conf.d/66-sil-nuosu.conf ………………省略部分压缩过程信息……………… 接下来将打包后的压缩包文件指定解压到/root/etc 目录中（先使用 mkdir 命令来创建/root/etc 目录）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [root@linuxprobe ~]# mkdir /root/etc [root@linuxprobe ~]# tar xzvf etc.tar.gz -C /root/etc etc/ etc/fstab etc/crypttab etc/mtab etc/fonts/ etc/fonts/conf.d/ etc/fonts/conf.d/65-0-madan.conf etc/fonts/conf.d/59-liberation-sans.conf etc/fonts/conf.d/90-ttf-arphic-uming-embolden.conf etc/fonts/conf.d/59-liberation-mono.conf etc/fonts/conf.d/66-sil-nuosu.conf etc/fonts/conf.d/65-1-vlgothic-gothic.conf etc/fonts/conf.d/65-0-lohit-bengali.conf etc/fonts/conf.d/20-unhint-small-dejavu-sans.conf ………………省略部分解压过程信息……………… 2．grep - 执行关键词搜索 grep 命令用于在文本中执行关键词搜索，并显示匹配的结果，格式为“grep [选项] [文件]”。 grep 命令的参数及其作用\n参数 作用 -b 将可执行文件（binary）当作文本文件（text）来搜索 -c 仅显示找到的行数 -i 忽略大小写 -n 显示行号 -v 反向选择—仅列出没有“关键词”的行 两个最最常用的参数： -n 参数用来显示搜索到信息的行号； -v 参数用于反选信息（即没有包含关键词的所有信息行）\n这两个参数几乎能完成您日后 80%的工作需要，至于其他上百个参数，即使以后在工作期间遇到了，再使用 man grep 命令查询也来得及。\n在 Linux 系统中，/etc/passwd 文件是保存着所有的用户信息，而一旦用户的登录终端被设置成 /sbin/nologin，则不再允许登录系统，因此可以使用 grep 命令来查找出当前系统中不允许登录系统的所有用户信息： [root@linuxprobe ~]# grep /sbin/nologin /etc/passwd bin❌1:1:bin:/bin:/sbin/nologin daemon❌2:2:daemon:/sbin:/sbin/nologin adm❌3:4:adm:/var/adm:/sbin/nologin lp❌4:7:lp:/var/spool/lpd:/sbin/nologin mail❌8:12:mail:/var/spool/mail:/sbin/nologin operator❌11:0:operator:/root:/sbin/nologin ………………省略部分输出过程信息………………\n3．find - 查找文件 find 命令用于按照指定条件来查找文件，格式为“find [查找路径] 寻找条件 操作”。\n搜索工作一般都是通过 find 命令来完成的，它可以使用不同的文件特性作为寻找条件（如文件名、大小、修改时间、权限等信息），一旦匹配成功则默认将信息显示到屏幕上。\nfind 命令中的参数以及作用\n参数 作用 -name 匹配名称 -perm 匹配权限（mode 为完全匹配，-mode 为包含即可） -user 匹配所有者 -group 匹配所有组 -mtime -n +n 匹配修改内容的时间（-n 指 n 天以内，+n 指 n 天以前） -atime -n +n 匹配访问文件的时间（-n 指 n 天以内，+n 指 n 天以前） -ctime -n +n 匹配修改文件权限的时间（-n 指 n 天以内，+n 指 n 天以前） -nouser 匹配无所有者的文件 -nogroup 匹配无所有组的文件 -newer f1 !f2 匹配比文件 f1 新但比 f2 旧的文件 \u0026ndash;type b/d/c/p/l/f 匹配文件类型（后面的字幕参数依次表示块设备、目录、字符设备、管道、链接文件、文本文件） -size 匹配文件的大小（+50KB 为查找超过 50KB 的文件，而-50KB 为查找小于 -prune 忽略某个目录 -exec …… {}; 后面可跟用于进一步处理搜索结果的命令（下文会有演示） 这里需要重点讲解一下-exec 参数重要的作用。这个参数用于把 find 命令搜索到的结果交由紧随其后的命令作进一步处理，它十分类似于第 3 章将要讲解的管道符技术，并且由于 find命令对参数的特殊要求，因此虽然 exec 是长格式形式，但依然只需要一个减号（-）。 根据文件系统层次标准（Filesystem Hierarchy Standard）协议，Linux 系统中的配置文件会保存到/etc 目录中（详见第 6 章）。如果要想获取到该目录中所有以 host 开头的文件列表，可以执行如下命令： [root@linuxprobe ~]# find /etc -name \u0026ldquo;host*\u0026rdquo; -print /etc/avahi/hosts /etc/host.conf /etc/hosts /etc/hosts.allow /etc/hosts.deny /etc/selinux/targeted/modules/active/modules/hostname.pp /etc/hostname\n如果要在整个系统中搜索权限中包括 SUID 权限的所有文件（详见第 5 章），只需使用-4000 即可： [root@linuxprobe ~]# find / -perm -4000 -print /usr/bin/fusermount /usr/bin/su /usr/bin/umount /usr/bin/passwd /usr/sbin/userhelper /usr/sbin/usernetctl ………………省略部分输出信息………………\n复习题 1．在 RHEL 7 系统及众多的 Linux 系统中，最常使用的 Shell 终端是什么？ 答：Bash（Bourne-Again SHell）解释器。\n2．执行 Linux 系统命令时，添加参数的目的是什么？ 答：为了让 Linux 系统命令能够更贴合用户的实际需求进行工作。\n3．Linux 系统命令、命令参数及命令对象之间，普遍应该使用什么来间隔？ 答：应该使用一个或多个空格进行间隔。\n4．请写出用 echo 命令把 SHELL 变量值输出到屏幕终端的命令。 答：echo $SHELL。\n5．简述 Linux 系统中 5 种进程的名称及含义。 答：在 Linux 系统中，有下面 5 种进程名称。\n（运行）：进程正在运行或在运行队列中等待。 （中断）：进程处于休眠中，当某个条件形成后或者接收到信号时，则脱离该状态。 （不可中断）：进程不响应系统异步信号，即便用 kill 命令也不能将其中断。 （僵死）：进程已经终止，但进程描述符依然存在, 直到父进程调用 wait4()系统函数后将进程释放。 （停止）：进程收到停止信号后停止运行。 6．请尝试使用 Linux 系统命令关闭 PID 为 5529 的服务进程。 答：执行 kill 5529 命令即可；若知道服务的名称，则可以使用 killall 命令进行关闭。\n7．使用 ifconfig 命令查看网络状态信息时，需要重点查看的 4 项信息分别是什么？ 答：这 4 项重要信息分别是网卡名称、IP 地址、网卡物理地址以及 RX/TX 的收发流量数据大小。\n8．使用 uptime 命令查看系统负载时，对应的负载数值如果是 0.91、0.56、0.32，那么最近 15分钟内负载压力最大的是哪个时间段？ 答：通过负载数值可以看出，最近 1 分钟内的负载压力是最大的。\n9．使用 history 命令查看历史命令的执行记录时，命令前面的数字除了排序外还有什么用处？ 答：还可以用“!数字”的命令格式重复执行某一次的命令记录，从而避免了重复输入较长命令的麻烦。\n10．若想查看的文件具有较长的内容，那么使用 cat、more、head、tail 中的哪个命令最合适？ 答：文件内容较长，使用 more 命令；反之使用 cat 命令。\n11．在使用 mkdir 命令创建有嵌套关系的目录时，应该加上什么参数呢？ 答：应该加上-p 递归迭代参数，从而自动化创建有嵌套关系的目录。复习题\n12．在使用 rm 命令删除文件或目录时，可使用哪个参数来避免二次确认呢？ 答：可使用-f 参数，这样即可无需二次确认。\n13．若有一个名为 backup.tar.gz 的压缩包文件，那么解压的命令应该是什么？ 答：应该用 tar 命令进行解压，执行 tar -xzvf backup.tar.gz 命令即可。\n14．使用 grep 命令对某个文件进行关键词搜索时，若想要进行文件内容反选，应使用什么参数？ 答：可使用-v 参数来进行匹配内容的反向选择，即显示出不包含某个关键词的行。\n","permalink":"https://bablvsj.github.io/posts/tech/linux/20230809-linux-%E6%96%B0%E6%89%8B%E5%BF%85%E5%A4%87%E5%91%BD%E4%BB%A4/","summary":"命令总结 命令参数的长格式与短格式示例 长格式 短格式 man \u0026ndash;help man -h 一、常用系统工作命令 1．echo - 输出值 echo 命令用于在终端输出字符串或变量提取后的值，","title":"Linux 新手必备命令"},{"content":"个人说明 我是小布。\n2023，面朝大海，春暖花开！。 \u0026ndash;2022.12\n博客日志 2023-07-25: 引用hugo主题 PaperMod。\n2022-12-15: 引用hugo主题 hugo-theme-Reader。\n2022-12-10: 博客使用hugo构建。\n一些文章写的不错的博主 冴羽写四个系列：JavaScript深入系列、JavaScript专题系列、ES6系列、React系列。\n颜乐乐在头条做前端，博客内容很全，尤其是“单元测试”系列。\n致谢 网站开发有借鉴 子舒 Kevin 两位的网站\n版权声明：网站文章所有版权如无特殊说明，均归本人所有。允许转载，标明出处即可。\n","permalink":"https://bablvsj.github.io/about/","summary":"about","title":"关于"},{"content":"一、数据结构 数据结构 优点 缺点 运行时间 添加/删除 链表 数据的添加/删除都较为方便 访问数据比较耗费时间 O(n) O(1) 数组 访问数据十分简单 添加/删除数据比较耗费时间 O(1) O(n) 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 访问 添加 删除 链表 慢 快 快 数组 快 慢 慢 1.1 链表 数据结构 优点 缺点 普通链表 数据的添加和删除都较为方便 访问比较耗费时间 循环链表 想要保存数量固定的最新数据时使用 访问比较耗费时间 双向链表 可以前后遍历数据 十分方便 一是指针数的增加会导致存储空间需求增加；二是添加和删除数据时需要改变更多指针的指向。 1.2 数组 数据结构 优点 缺点 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 1.3 栈 后进先出 的结构，我们称为 Last In First Out，简称 LIFO。 链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。\n1.4 队列 像队列这种最先进去的数据最先被取来，即 先进先出 的结构，我们称为 First In First Out，简称 FIFO。\n1.5 哈希表 只能从头开始查询。这个操作便叫作 线性查找\n在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。\n如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。\n1.6 堆 堆是一种图的树形结构，被用于实现“优先队列”（priority queues）。\n优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。 在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。\n堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为 O(1)。\n假设数据量为n，根据堆的形状可知树的高度为 log2n ，那重构树的时间复杂度为O(logn)。\n添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度成正比，也是 O(logn)。\n1.7 二叉查找树 二叉查找树（又叫作二叉搜索树或二叉排序树）是一种数据结构，采用了图的树形结构。数据存储于二叉查找树的各个结点中。\n每个节点最多有两个子节点\n两个性质：\n第一个是每个结点的值均大于其左子树上任意一个结点的值。 第二个是每个结点的值均小于其右子树上任意一个结点的值。 所以二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。 反之，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。 比较的次数取决于树的高度。所以如果结点数为 n，而且树的形状又较为均衡的话，比较大小和移动的次数最多就是 log2n。因此，时间复杂度为 O(logn)。 但如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了 O(n)。\n二、排序 2.1 冒泡排序 第 1 轮需要比较 n -1 次，第 2 轮需要比较 n -2 次……第 n -1 轮需 要比较 1 次。因此，总的比较次数为 (n-1) +(n-2) +…+1 ≈ n2/2。 不过，交换数字的次数和输入数据的排列顺序有关。假设出现某种极端情况，如输 入数据正好以从小到大的顺序排列，那么便不需要任何交换操作； 反过来，输入数据要是以从大到小的顺序排列，那么每次比较数字后便都要进行交换。因此，冒泡排序的时间复杂度为O($n^2$)。\n1 2 3 4 5 6 7 8 9 10 let Arr = [100, 49, 22, 1, 4, 15, 59, 28, 29, 10,] for (let i = 0; i \u0026lt; Arr.length; i++) { for (let j = Arr.length; j \u0026gt; i; j--) { if (Arr[j] \u0026lt; Arr[j-1]) { let temp = Arr[j-1] Arr[j-1] = Arr[j] Arr[j] = temp } } } 2.2 选择排序 选择排序就是重复从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换 这一操作的算法。在序列中寻找最小值时使用的是线性查找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 for (let i = 0; i \u0026lt; Arr.length; i++) { let startIndex=i,startValue = Arr[i],min = Arr[i], minIndex = i; for (let j = i; j \u0026lt; Arr.length; j++) { if (Arr[j] \u0026lt; min) { min = Arr[j] minIndex = j } } if(startIndex !== minIndex ){ Arr[startIndex] = Arr[minIndex] Arr[minIndex] = startValue } } 选择排序使用了线性查找来寻找最小值，因此在第 1 轮中需要比较 n -1 个数字，第 2 轮需要比较 n -2 个数字……到第 n -1 轮的时候就只需比较 1 个数字了。因此，总的比 较次数与冒泡排序的相同，都是 (n-1)+(n-2)+…+1 ≈ n2/2 次。 每轮中交换数字的次数最多为 1 次。如果输入数据就是按从小到大的顺序排列的， 便不需要进行任何交换。选择排序的时间复杂度也和冒泡排序的一样，都为 O($n^2$)。\n2.3 插入排序 插入排序是一种从序列左端开始依次对数据进行排序的算法。在排序过程中，左侧的数据陆续归位，而右侧留下的就是还未被排序的数据。插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内合适的位置上。\n1 2 3 4 5 6 7 8 9 10 11 let tempArr = [] for (let i = 0; i \u0026lt; Arr.length; i++) { tempArr.push(Arr[i]) for (let j = tempArr.length - 1; j \u0026gt;0 ; j--) { if (tempArr[j] \u0026lt; tempArr[j - 1]) { let temp = tempArr[j - 1] tempArr[j - 1] = tempArr[j] tempArr[j] = temp } } } 具体来说，就是第 k 轮需要比较 k -1 次。因此，在最糟糕的情况下，第 2 轮需要操作 1 次，第 3 轮操作 2 次……第 n 轮操作 n -1次，所以时间复杂度和冒泡排序的一样，都为 O($n^2$)。\n2.4 堆排序 堆排序的特点是利用了数据结构中的堆\n堆排序一开始需要将 n 个数据存进堆里，所需时间为 O(nlogn)。 排序过程中，堆从空堆的状态开始，逐渐被数据填满。由于堆的高度小于 log2n，所以插入 1 个数据所需要的时间为 O(logn)。 每轮取出最大的数据并重构堆所需要的时间为 O(logn)。由于总共有 n 轮，所以重构后排序的时间也是 O(nlogn)。 因此，整体来看堆排序的时间复杂度为 O(nlogn)。 这样来看，堆排序的运行时间比之前讲到的冒泡排序、选择排序、插入排序的时间O($n^2$) 都要短，但由于要使用堆这个相对复杂的数据结构，所以实现起来也较为困难。\n2.5 归并排序 论哪一行都是 n 个数据，所以每行的运行时间都为 O(n)。 而将长度为 n 的序列对半分割直到只有一个数据为止时，可以分成 log2n 行，因此，总 共有 log2n 行。也就是说，总的运行时间为 O(nlogn)，这与前面讲到的堆排序相同。\n2.6 快速排序 快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分 为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。 [ 比基准值小的数 ] 基准值 [ 比基准值大的数 ] 接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序\n","permalink":"https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/20230809-%E7%AE%97%E6%B3%95/","summary":"一、数据结构 数据结构 优点 缺点 运行时间 添加/删除 链表 数据的添加/删除都较为方便 访问数据比较耗费时间 O(n) O(1) 数组 访问数据十分简单 添加/删除数据比较耗","title":"我的第一本算法书"},{"content":"","permalink":"https://bablvsj.github.io/message/","summary":"","title":"留言"}]