[{"content":"箭头函数没有自己的this对象 内部的this指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的this对象，内部的this就是定义时上层作用域中的this。\n也就是说，箭头函数内部的this指向是固定的，相比之下，普通函数的this指向是可变的。\n例题1 function foo() { setTimeout(() =\u0026gt; { console.log(\u0026#39;id:\u0026#39;, this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 42 上面代码中，setTimeout()的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以打印出来的是42。\n例题2 下面例子是回调函数分别为箭头函数和普通函数，对比它们内部的this指向。\nfunction Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =\u0026gt; this.s1++, 1000); // 普通函数 setInterval(function () { this.s2++; }, 1000); } var timer = new Timer(); setTimeout(() =\u0026gt; console.log(\u0026#39;s1: \u0026#39;, timer.s1), 3100); setTimeout(() =\u0026gt; console.log(\u0026#39;s2: \u0026#39;, timer.s2), 3100); // s1: 3 // s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。\nthis关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。\n箭头函数：没有自己的 this，它继承自包含它的最近的非箭头函数父作用域的 this 值。 普通函数： 函数的 this 值在运行时动态确定，取决于函数如何被调用。在全局作用域中，this 指向全局对象（在浏览器中通常是 window）。在对象方法中，this 指向调用方法的对象\n","permalink":"https://bablvsj.github.io/posts/work/interview/questions/20231227-this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/","summary":"箭头函数没有自己的this对象 内部的this指向函数运行时所在的对象，但是这一点对箭头函数不成立。它没有自己的this对象，内部的this就","title":"this指向问题"},{"content":"基础语法 数据列输出顺序 SELECT {列名...} 全表查询 select * from 表名\n查询 - 别名 别名语法 {原始字段名} as {别名} 来为查询结果的列名取一个便于理解的名称。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和年龄（age）信息，并为它们取别名为 学生姓名 和 学生年龄\nselect name as \u0026#39;学生姓名\u0026#39;, age as \u0026#39;学生年龄\u0026#39; from student; 查询 - 常量和运算 请编写一条 SQL 查询语句，从名为student的数据表中选择出所有学生的姓名（name）和分数（score），并且额外计算出分数的 2 倍（double_score）。\nselect name, score, score * 2 as double_score from student; 条件查询 - where SELECT 列1, 列2, ... FROM 表名 WHERE 条件; 请编写一条 SQL 查询语句，从名为student 的数据表中选择出所有学生的姓名（name）和成绩（score），要求学生姓名为 \u0026rsquo;lvsj\u0026rsquo;。\nselect name, score from student where name = \u0026#39;lvsj\u0026#39;; 条件查询 - 运算符 =、 !=、\u0026lt;、\u0026gt; \u0026ldquo;BETWEEN\u0026rdquo; 运算符来筛选出在某个范围内的值。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和年龄（age），要求学生姓名不等于 \u0026lsquo;热dog\u0026rsquo; 。\nselect name, age from student where name != \u0026#39;热dog\u0026#39;; 条件查询 空值 is null / is not null 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）、年龄（age）和成绩（score），要求学生年龄不为空值。\nselect name, age, score from student where age is not null; 模糊查询 like / not like **通配符：\n百分号（%）：表示任意长度的任意字符序列。 下划线（_）：表示任意单个字符。 还可以使用模糊查询匹配开头和结尾：\n-- 只查询以 \u0026#34;张\u0026#34; 开头的数据行 select name, age, position from employees where name like \u0026#39;张%\u0026#39;; -- 只查询以 \u0026#34;张\u0026#34; 结尾的数据行 select name, age, position from employees where name like \u0026#39;%张\u0026#39;; 同理，可以使用 not like 来查询不包含某关键字的信息。\n请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）和成绩（score），要求姓名（name）不包含 \u0026ldquo;李\u0026rdquo; 这个字。\nselect name, score from student where name not like \u0026#39;%李%\u0026#39;; 逻辑运算 AND / OR / NOT AND：表示逻辑与，要求同时满足多个条件，才返回 true。 OR：表示逻辑或，要求满足其中任意一个条件，就返回 true。 NOT：表示逻辑非，用于否定一个条件（本来是 true，用了 not 后转为 false） 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有学生的姓名（name）、成绩（score），要求学生的姓名包含 \u0026ldquo;李\u0026rdquo;，或者成绩（score）大于 500。\nselect name, score from student where name like \u0026#39;%李%\u0026#39; or score \u0026gt; 500; 去重 distinct 除了按照单字段去重外，DISTINCT 关键字还支持根据多个字段的组合来进行去重操作，确保多个字段的组合是唯一的。\n示例语法如下：\ndistinct 字段1, 字段2, 字段3, ... 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出所有不重复的班级 ID（class_id）和考试编号（exam_num）的组合。\nselect distinct class_id, exam_num from student; 排序 order by 在排序的基础上，我们还可以根据多个字段的值进行排序。当第一个字段的值相同时，再按照第二个字段的值进行排序，以此类推。\n示例语法如下：\norder by 字段1 [升序/降序], 字段2 [升序/降序], ... 请编写一条 SQL 查询语句，从名为 student 的数据表中选择出学生姓名（name）、年龄（age）和成绩（score），首先按照成绩从大到小排序，如果成绩相同，则按照年龄从小到大排序。\nselect name, age, score from student order by score desc, age asc; 截断和偏移 LIMIT关键字 请编写一条 SQL 查询语句，从名为 student 的数据表中选择学生姓名（name）和年龄（age），按照年龄从小到大排序，从第 2 条数据开始、截取 3 个学生的信息。\nselect name, age from student order by age asc limit 1, 3; 条件分支 case when 实例语法：\nCASE WHEN (条件1) THEN 结果1 WHEN (条件2) THEN 结果2 ... ELSE 其他结果 END 题目： 假设有一个学生表 student，包含以下字段：name（姓名）、age（年龄）。请你编写一个 SQL 查询，将学生按照年龄划分为三个年龄等级（age_level）：60 岁以上为 \u0026ldquo;老同学\u0026rdquo;，20 岁以上（不包括 60 岁以上）为 \u0026ldquo;年轻\u0026rdquo;，20 岁及以下、以及没有年龄信息为 \u0026ldquo;小同学\u0026rdquo;。\n返回结果应包含学生的姓名（name）和年龄等级（age_level），并按姓名升序排序。\nselect name, case when (age \u0026gt; 60) then \u0026#39;老同学\u0026#39; when (age \u0026gt; 20) then \u0026#39;年轻\u0026#39; else \u0026#39;小同学\u0026#39; end as age_level from student order by name asc; 函数 - 时间函数 常用的时间函数有：\nDATE：获取当前日期 DATETIME：获取当前日期时间 TIME：获取当前时间 假设有一个学生表 student，包含以下字段：name（姓名）、age（年龄）。 请你编写一个 SQL 查询，展示所有学生的姓名（name）和当前日期（列名为 \u0026ldquo;当前日期\u0026rdquo;）。\nselect name, date() as \u0026#39;当前日期\u0026#39; from student; 函数 - 字符串处理 \u0026#39;`UPPER` 将字段转换为大写\u0026#39; select name, upper(name) as upper_name from employees; \u0026#39;`LOWER` 将字段转换为小写\u0026#39; select name, lower(name) as lower_name from employees; \u0026#39;`LENGTH` 计算字段长度\u0026#39; select name, length(name) as name_length from employees; 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）。请你编写一个 SQL 查询，筛选出姓名为 \u0026lsquo;热dog\u0026rsquo; 的学生，展示其学号（id）、姓名（name）及其大写姓名（upper_name）。\nselect id, name, upper(name) as upper_name from student where name = \u0026#39;热dog\u0026#39; 函数 - 聚合函数 聚合函数是一类用于对数据集进行 汇总计算 的特殊函数。\n常见的聚合函数包括：\nCOUNT：计算指定列的行数或非空值的数量。 SUM：计算指定列的数值之和。 AVG：计算指定列的数值平均值。 MAX：找出指定列的最大值。 MIN：找出指定列的最小值。 示例 假设有一个订单表 orders，包含以下字段：order_id（订单号）、customer_id（客户编号）、amount（订单金额）。数据如下：\norder_id customer_id amount 1 A001 100 2 A002 200 3 A001 150 4 A003 50 1）使用聚合函数 COUNT 计算订单表中的总订单数：\nselect count(*) as order_num from orders; // order_num = 4 2）使用聚合函数 COUNT(DISTINCT 列名) 计算订单表中不同客户的数量：\nselect count(distinct customer_id) as customer_num FROM orders; // customer_num = 3 3）使用聚合函数 SUM 计算总订单金额：\nselect sum(amount) as total_amount from orders; // total_amount = 500 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、class_id（班级编号）、score（成绩）。请你编写一个 SQL 查询，汇总学生表中所有学生的总成绩（total_score）、平均成绩（avg_score）、最高成绩（max_score）和最低成绩（min_score）。\nselect sum(score) as total_score, avg(score) as avg_score, max(score) as max_score, min(score) as min_score from student; 分组聚合 - 单字段分组 分组聚合是一种对数据进行分类并对每个分类进行聚合计算的操作。它允许我们按照指定的列或字段对数据进行分组，然后对每个分组应用聚合函数，如 COUNT、SUM、AVG 等，以获得分组后的汇总结果。\n举个例子：某个学校可以按照班级将学生分组，并对每个班级进行统计。查看每个班级有多少学生、每个班级的平均成绩。这样我们就能够对学校各班的学生情况有一个整体的了解，而不是单纯看个别学生的信息。\n在 SQL 中，通常使用 GROUP BY 关键字对数据进行分组。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、class_id（班级编号）、score（成绩）。请你编写一个 SQL 查询，统计学生表中每个班级的平均成绩（avg_score）。\nselect class_id, avg(score) as avg_score from student group by class_id; 分组聚合 - 多字段分组 有时，单字段分组并不能满足我们的需求，比如想统计学校里每个班级每次考试的学生情况，这时就可以使用多字段分组。\n多字段分组和单字段分组的实现方式几乎一致，使用 GROUP BY 语法即可。\n假设有一个学生表 student，包含以下字段id（学号）、name（姓名）、class_id（班级编号）、exam_num（考试次数）、score（成绩）。请编写一个 SQL 查询，统计学生表中每个班级每次考试的总学生人数（total_num）。\nselect class_id, exam_num, count(*) as total_num from student group by class_id, exam_num 分组聚合 - having 子句 HAVING 子句用于在分组聚合后对分组进行过滤。它允许我们对分组后的结果进行条件筛选，只保留满足特定条件的分组。\nHAVING 子句与条件查询 WHERE 子句的区别在于，WHERE 子句用于在 分组之前 进行过滤，而 HAVING 子句用于在 分组之后 进行过滤。\n假设有一个学生表 student，包含以下字段：id（学号)、name（姓名）、class_id（班级编号)、score（成绩）。请编写一个 SQL 查询，统计学生表中班级的总成绩超过 150 分的班级编号（class_id）和总成绩（total_score），并将总成绩按从高到低排序。\nselect class_id, sum(score) as total_score from student group by class_id having total_score \u0026gt; 150 order by total_score desc 查询进阶 - 关联查询 cross join 关联查询是一种用于联合多个数据表中的数据的查询方式\nCROSS JOIN 是一种简单的关联查询，不需要任何条件来匹配行，它直接将左表的 每一行 与右表的 每一行 进行组合，返回的结果是两个表的笛卡尔积。\n示例 假设有一个员工表 employees，包含以下字段：emp_id（员工编号）、emp_name（员工姓名）、department（所属部门）、salary（工资）。数据如下：\nemp_id emp_name department salary 1 小明 技术部 5000 2 鸡哥 财务部 6000 3 李华 销售部 4500 假设还有一个部门表 departments，包含以下字段：department（部门名称）、manager（部门经理）、location（所在地）。数据如下：\ndepartment manager location 技术部 张三 上海 财务部 李四 北京 销售部 王五 广州 使用 CROSS JOIN 进行关联查询，将员工表和部门表的所有行组合在一起，获取员工姓名、工资、部门名称和部门经理，示例 SQL 代码如下：\nSELECT e.emp_name, e.salary, e.department, d.manager FROM employees e CROSS JOIN departments d; 注意，在多表关联查询的 SQL 中，我们最好在选择字段时指定字段所属表的名称（比如 e.emp_name），还可以通过给表起别名（比如 employees e）来简化 SQL 语句。\n查询结果：\nemp_name salary department manager 小明 5000 技术部 张三 小明 5000 财务部 李四 小明 5000 销售部 王五 鸡哥 6000 技术部 张三 鸡哥 6000 财务部 李四 鸡哥 6000 销售部 王五 李华 4500 技术部 张三 李华 4500 财务部 李四 李华 4500 销售部 王五 假设有一个学生表 student ，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）；还有一个班级表 class ，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，将学生表和班级表的所有行组合在一起，并返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）以及班级名称（class_name）。\n\u0026#39;错误示范\u0026#39; -- select -- s.name as student_name, -- s.age as student_age, -- s.calss_id, -- c.name as class_name -- from student s -- cross join class c; select s.name student_name, s.age student_age, s.class_id class_id, c.name class_name from student s join class c; inner join INNER JOIN 是一种常见的关联查询方式，它根据两个表之间的关联条件，将满足条件的行组合在一起。\nINNER JOIN 只返回两个表中满足关联条件的交集部分，即在两个表中都存在的匹配行。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）、level（班级级别）。\n请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level）。\nselect s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s join class c on s.class_id = c.id; outer join out join 是一种关联查询方式，它根据关联条件，将两个表中满足条件的行组合在一起，并包含没有匹配的行 。\n在 out join 中，包括 left out join 和 right out join 两种类型，它们分别表示查询左表和右表的所有行（即使没有被匹配），再加上满足条件的交集部分。\n有些数据库并不支持 right join 语法，那么如何实现 right join 呢？ 其实只需要把主表（from 后面的表）和关联表（ left join 后面的表）顺序进行调换即可！\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）、level（班级级别）。\n请你编写一个 SQL 查询，根据学生表和班级表之间的班级编号进行匹配，返回学生姓名（student_name）、学生年龄（student_age）、班级编号（class_id）、班级名称（class_name）、班级级别（class_level），要求必须返回所有学生的信息（即使对应的班级编号不存在）。\nselect s.name student_name, s.age student_age, s.class_id class_id, c.name class_name, c.level class_level from student s left join class c on s.class_id = c.id; 子查询 子查询是指在一个查询语句内部 嵌套 另一个完整的查询语句，内层查询被称为子查询。 子查询可以用于获取更复杂的查询结果或者用于过滤数据。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，使用子查询的方式来获取存在对应班级的学生的所有数据，返回学生姓名（name）、分数（score）、班级编号（class_id）字段。\nselect name, score, class_id from student where class_id in ( select distinct id from class ) 子查询 - exists 子查询中的一种特殊类型是 \u0026ldquo;exists\u0026rdquo; 子查询，用于检查主查询的结果集是否存在满足条件的记录，它返回布尔值（True 或 False），而不返回实际的数据。\n和 exists 相对的是 not exists，用于查找不满足存在条件的记录。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个班级表 class，包含以下字段：id（班级编号）、name（班级名称）。\n请你编写一个 SQL 查询，使用 exists 子查询的方式来获取 不存在对应班级的 学生的所有数据，返回学生姓名（name）、年龄（age）、班级编号（class_id）字段。\nselect name, age, class_id from student where not exists ( select 1 from class where student.class_id = class.id ) 组合查询 组合查询是一种将多个 SELECT 查询结果合并在一起的查询操作。\n包括两种常见的组合查询操作：UNION 和 UNION ALL。\nUNION 操作：它用于将两个或多个查询的结果集合并， 并去除重复的行 。即如果两个查询的结果有相同的行，则只保留一行。 UNION ALL 操作：它也用于将两个或多个查询的结果集合并， 但不去除重复的行 。即如果两个查询的结果有相同的行，则全部保留。 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。还有一个新学生表 student_new，包含的字段和学生表完全一致。\n请编写一条 SQL 语句，获取所有学生表和新学生表的学生姓名（name）、年龄（age）、分数（score）、班级编号（class_id）字段，要求保留重复的学生记录。\nselect name, age, score, class_id from student union all select name, age, score, class_id from student_new 开窗函数 - sum over 开窗函数是一种强大的查询工具，它允许我们在查询中对分组数据进行计算、 同时保留原始行的详细信息 。\n开窗函数可以与聚合函数（如 SUM、AVG、COUNT 等）结合使用，但与普通聚合函数不同，开窗函数不会导致结果集的行数减少。\n打个比方，可以将开窗函数想象成一种 \u0026ldquo;透视镜\u0026rdquo;，它能够将我们聚焦在某个特定的分组，同时还能看到整体的全景。\n本节我们先讲第一个开窗函数：sum over。\n该函数用法为：\nsum(计算字段名) over (partition by 分组字段名) 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并计算每个班级的学生平均分（class_avg_score）。\nselect id, name, age, score, class_id, avg(score) over ( partition by class_id ) as class_avg_score from student 开窗函数 - sum over order by 学习 sum over 函数的另一种用法：sum over order by，可以实现同组内数据的 累加求和 。\n示例用法如下：\nsum(计算字段名) over (partition by 分组字段名 order by 排序字段 排序规则) 举一个应用场景：老师在每个班级里依次点名，每点到一个学生，老师都会记录当前已点到的学生们的分数总和。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数升序的方式累加计算每个班级的学生总分（class_sum_score）。\nselect id, name, age, score, class_id, sum(score) over ( partition by class_id order by score asc ) as class_sum_score from student 开窗函数 - rank Rank 开窗函数是 SQL 中一种用于对查询结果集中的行进行 排名 的开窗函数。它可以根据指定的列或表达式对结果集中的行进行排序，并为每一行分配一个排名。在排名过程中，相同的值将被赋予相同的排名，而不同的值将被赋予不同的排名。\n当存在并列（相同排序值）时，Rank 会跳过后续排名，并保留相同的排名。\n**Rank 开窗函数的常见用法是在查询结果中查找前几名（Top N）或排名最高的行。\nRank 开窗函数的语法如下：\nrank() over ( partition by 列名1, 列名2, ... -- 可选，用于指定分组列 order by 列名3 [asc|desc], 列名4 [asc|desc], ... -- 用于指定排序列及排序方式 ) as rank_column 其中，partition by 子句可选，用于指定分组列，将结果集按照指定列进行分组；order by 子句用于指定排序列及排序方式，决定了计算 rank 时的排序规则。as rank_column 用于指定生成的 Rank 排名列的别名。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式计算每个班级内的学生的分数排名（ranking）。\nselect id, name, age, score, class_id, rank() over ( partition by class_id order by score desc ) as ranking from student 开窗函数 - row_number Row_Number 开窗函数是 SQL 中的一种用于为查询结果集中的每一行 分配唯一连续排名 的开窗函数。\n它与之前讲到的 Rank 函数不同，Row_Number 函数为每一行都分配一个唯一的整数值，不管是否存在并列（相同排序值）的情况。每一行都有一个唯一的行号，从 1 开始连续递增。\nrow_number 开窗函数的语法如下（几乎和 rank 函数一模一样）：\nrow_number() over ( partition by column1, column2, ... -- 可选，用于指定分组列 order by column3 [asc|desc], column4 [asc|desc], ... -- 用于指定排序列及排序方式 ) as row_number_column 其中，PARTITION BY子句可选，用于指定分组列，将结果集按照指定列进行分组。ORDER BY 子句用于指定排序列及排序方式，决定了计算 Row_Number 时的排序规则。AS row_number_column 用于指定生成的行号列的别名。\n假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式给每个班级内的学生分配一个编号（row_number）。\nselect id, name, age, score, class_id, ROW_NUMBER() over ( partition by class_id order by score desc ) as row_number from student 开窗函数 - lag / lead 开窗函数 Lag 和 Lead 的作用是获取在当前行之前或之后的行的值，这两个函数通常在需要比较相邻行数据或进行时间序列分析时非常有用。\n1）Lag 函数\nLag 函数用于获取 当前行之前 的某一列的值。它可以帮助我们查看上一行的数据。\nLag 函数的语法如下：\nlag(column_name, offset, default_value) over ( partition by partition_column order by sort_column ) 参数解释：\ncolumn_name：要获取值的列名。 offset：表示要向上偏移的行数。例如，offset为1表示获取上一行的值，offset为2表示获取上两行的值\u0026hellip; default_value：可选参数，用于指定当没有前一行时的默认值。 PARTITION BY和ORDER BY子句可选，用于分组和排序数据。 2）Lead 函数\nLead 函数用于获取 当前行之后 的某一列的值。它可以帮助我们查看下一行的数据。\nLead 函数的语法如下：\nlead(column_name, offset, default_value) over ( partition by partition_column order by sort_column) 参数解释：\ncolumn_name：要获取值的列名。 offset：表示要向下偏移的行数。例如，offset为1表示获取下一行的值，offset为2表示获取下两行的值\u0026hellip; default_value：可选参数，用于指定当没有后一行时的默认值。 PARTITION BY和ORDER BY子句可选，用于分组和排序数据。 假设有一个学生表 student，包含以下字段：id（学号）、name（姓名）、age（年龄）、score（分数）、class_id（班级编号）。 请你编写一个 SQL 查询，返回每个学生的详细信息（字段顺序和原始表的字段顺序一致），并且按照分数降序的方式获取每个班级内的学生的前一名学生姓名（prev_name）、后一名学生姓名（next_name）。\nselect id, name, age, score, class_id, lag(name, 1, null) over ( partition by class_id order by score desc ) as prev_name, lead(name, 1, null) over ( partition by class_id order by score desc ) as next_name from student 测验 冒险者和金币 假设有一家冒险者公会，他们有一张名为 rewards 的表格，用于记录每个冒险者在各个任务中获得的金币奖励情况。\n表格字段如下：\nadventurer_id：冒险者ID，唯一标识每个冒险者。 adventurer_name：冒险者姓名。 task_id：任务ID，唯一标识每个任务。 task_name：任务名称。 reward_coins：冒险者在该任务中获得的金币奖励数量。 请你编写一条 SQL 查询语句，依次输出每个冒险者的 id（adventurer_id）、冒险者姓名（adventurer_name）、获得的总金币奖励（total_reward_coins），并按照总金币奖励从高到低排序，其中只列出总金币奖励排名前 3 的冒险者。\nselect adventurer_id, adventurer_name, sum(reward_coins) as total_reward_coins from rewards group by adventurer_id,adventurer_name order by total_reward_coins desc limit 3; 魔法学院 假设有一家魔法学院，里面有许多学员在不同科目上进行学习和考试。请你设计一张名为magic_scores的表格，用于记录每位学员在不同科目中的考试成绩情况。表格字段如下：\nstudent_id：学员ID，唯一标识每位学员。 student_name：学员姓名。 subject_id：科目ID，唯一标识每个科目。 subject_name：科目名称。 score：学员在该科目的考试成绩。 请你编写一条 SQL 查询语句，依次输出每位学员的学院 ID（student_id）、学员姓名（student_name）、科目 ID（subject_id）、科目名称（subject_name）、学员在该科目的考试成绩（score）、该学员在每个科目中的成绩排名（score_rank），并将结果按照成绩从高到低进行排序。\nselect student_id, student_name, subject_id, subject_name, score, rank() over ( partition by subject_id order by score desc ) as score_rank from magic_scores 大浪淘鸡 在神秘的海岛上，有一只传说中的大浪淘鸡，它身躯高大威武，羽毛闪烁着神秘的光芒。岛上的居民都传说大浪淘鸡是海洋之神的化身，它能够操纵海浪，带来平静或狂暴的海洋。为了验证这个传说是否属实，岛上的居民决定对大浪淘鸡进行观测和记录。\n有一张 chicken_observation 的表格，用于记录居民观测大浪淘鸡的信息。表格字段如下：\nobservation_id：观测记录ID，唯一标识每条观测记录 observer_name：观测者姓名 observation_date：观测日期 observation_location：观测地点 wave_intensity：观测到的海浪强度，用整数表示，数值越大，海浪越狂暴 请你编写一条 SQL 查询语句，找出观测地点包含 \u0026ldquo;大浪淘鸡\u0026rdquo; 且海浪强度超过 5 的观测记录，并依次输出每位观测者的姓名（observer_name）、观测日期（observation_date）以及观测到的海浪强度（wave_intensity）。\nselect observer_name, observation_date, wave_intensity, observation_location from chicken_observation where (observation_location like \u0026#39;%大浪淘鸡%\u0026#39;) and (wave_intensity \u0026gt; 5) order by wave_intensity desc ","permalink":"https://bablvsj.github.io/posts/life/exams/sql%E4%B9%8B%E6%AF%8D/","summary":"SQL从入门到入门","title":"SQL之母"},{"content":"类型系统 TypeScript是静态类型 （根据类型检查的时机来分类） 动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误。JavaScript 是一门解释型语言，没有编译阶段，所以它是动态类型，以下这段代码在运行时才会报错：\nlet foo = 1; foo.split(\u0026#39; \u0026#39;); // Uncaught TypeError: foo.split is not a function // 运行时会报错（foo.split 不是一个函数），造成线上 bug 静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 TypeScript 是静态类型，这段 TypeScript 代码在编译阶段就会报错了：\nlet foo = 1; //类型推断 let foo: number = 1; foo.split(\u0026#39; \u0026#39;); // Property \u0026#39;split\u0026#39; does not exist on type \u0026#39;number\u0026#39;. // 编译时会报错（数字没有 split 方法），无法通过编译 TypeScript / JavaScript 都是弱类型 （根据是否允许隐式类型转换来分类） 安装typescript npm install -g typescript tsc -v // Version x.x.x TS基础 1.基础类型 布尔值 boolean let isDone: boolean = false; let createdByNewBoolean: Boolean = new Boolean(1); //非布尔值！ 返回的是一个 Boolean对象 let createdByBoolean: Boolean = Boolean(1) // 直接调用可返回一个 boolean 类型 数值 number let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; //ES6的二进制表示法 会被编译成十进制 let octalLiteral: number = 0o744; //ES6的八进制表示法 ... let notANumber: number = NaN; let infinityNumber: number = Infinity; 字符串 string let myName: string = \u0026#39;Tom\u0026#39;; let myAge: number = 25; // 模板字符串 let sentence: string = `Hello, my name is ${myName}. I\u0026#39;ll be ${myAge + 1} years old next month.`; null 和 undefined 在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\nlet u: undefined = undefined; let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n// 这样不会报错 let num: number = undefined; // 这样也不会报错 let u: undefined; let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量：\nlet u: void; let num: number = u; // Type \u0026#39;void\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. 任意值 any 什么是任意值类型 如果是一个普通类型，在赋值过程中改变类型是不被允许的：\nlet myFavoriteNumber: string = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. 但如果是 any 类型，则允许被赋值为任意类型。\nlet myFavoriteNumber: any = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 任意值的属性和方法 在任意值上访问任何属性都是允许的：\nlet anyThing: any = \u0026#39;hello\u0026#39;; console.log(anyThing.myName); console.log(anyThing.myName.firstName); 也允许调用任何方法：\nlet anyThing: any = \u0026#39;Tom\u0026#39;; anyThing.setName(\u0026#39;Jerry\u0026#39;); anyThing.setName(\u0026#39;Jerry\u0026#39;).sayHello(); anyThing.myName.setFirstName(\u0026#39;Cat\u0026#39;); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。\n未声明类型的变量 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\nlet something; something = \u0026#39;seven\u0026#39;; something = 7; something.setName(\u0026#39;Tom\u0026#39;); 等价于\nlet something: any; something = \u0026#39;seven\u0026#39;; something = 7; something.setName(\u0026#39;Tom\u0026#39;); unknow 类型 就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。\nlet value: unknown; value = true; // OK value = 42; // OK value = \u0026#34;Hello World\u0026#34;; // OK value = []; // OK value = {}; // OK value = Math.random; // OK value = null; // OK value = undefined; // OK value = new TypeError(); // OK value = Symbol(\u0026#34;type\u0026#34;); // OK 不能将 unknown的值 赋值给其他类型的变量，unknown类型只能被赋值给 any 类型和 unknown 类型本身\nlet value: unknown; let value1: unknown = value; // OK let value2: any = value; // OK let value3: boolean = value; // Error let value4: number = value; // Error let value5: string = value; // Error let value6: object = value; // Error let value7: any[] = value; // Error let value8: Function = value; // Error **unknown 应用场景\n// any 写法，不推荐 function divide(param: any) { return param / 2; } // unknown写法，推荐 function divide(param:unknown) { return param as number / 2 } 空值 void void 表示没有任何返回值的函数\nfunction alertName(): void { alert(\u0026#39;My name is Lv\u0026#39;); } 声明一个 void 类型的变量没用，因为你只能将它赋值为 undefined 和 null（只在 \u0026ndash;strictNullChecks 未指定时）：\nlet unusable: void = undefined; never 类型 never类型表示的是那些用不存在的值的类型。\n有些情况下值会永不存在，比如，\n如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值，因为抛出异常会直接中断程序运行。 函数中执行无限循环的代码，使得程序永远无法运行到函数返回值那一步。 // 异常 function fn(msg: string): never { throw new Error(msg) } // 死循环 千万别这么写，会内存溢出 function fn(): never { while (true) {} } never 类型是任何类型的子类型，也可以赋值给任何类型。\nlet test1: never; test1 = \u0026#39;lin\u0026#39; // 报错，Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;never\u0026#39; 没有类型是 never 的子类型，没有类型可以赋值给 never 类型（除了 never 本身之外）。 即使 any也不可以赋值给 never 。\nlet test1: never; let test2: any; test1 = test2 // 报错，Type \u0026#39;any\u0026#39; is not assignable to type \u0026#39;never\u0026#39; 数组的类型 类型+方括号 表示法 let fibonacci: number[] = [1, 1, 2, 3, 5]; 数组的项中不允许出现其他的类型：\nlet fibonacci: number[] = [1, \u0026#39;1\u0026#39;, 2, 3, 5]; // Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;number\u0026#39;. 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\nlet fibonacci: number[] = [1, 1, 2, 3, 5]; fibonacci.push(\u0026#39;8\u0026#39;); // Argument of type \u0026#39;\u0026#34;8\u0026#34;\u0026#39; is not assignable to parameter of type \u0026#39;number\u0026#39;. 数组泛型 array\u0026lt;elemType\u0026gt; 我们也可以使用数组泛型（Array Generic） Array\u0026lt;elemType\u0026gt;来表示数组：\nlet fibonacci: Array\u0026lt;number\u0026gt; = [1, 1, 2, 3, 5]; 用接口表示数组 interface NumberArray { [index: number]: number; } let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 元组 Tuple 类型 在单个变量中存储不同类型的值\nlet tupleType: [string, boolean]; tupleType = [\u0026#34;semlinker\u0026#34;, true]; 在元组初始化的时候，如果出现类型不匹配的话，比如：\ntupleType = [true, \u0026#34;semlinker\u0026#34;]; //报错 [0]: Type \u0026#39;true\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. [1]: Type \u0026#39;string\u0026#39; is not assignable to type \u0026#39;boolean\u0026#39;. 在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误。\n可以对元组使用数组的方法，比如使用 push 时，不会有越界报错\nlet tuple: [number, string] = [18, \u0026#39;lin\u0026#39;] tuple.push(100) // 但是只能 push 定义的 number 或者 string 类型 2.函数类型 function sum(x: number, y: number): number { return x + y; } //可选参数 function buildName(firstName: string, lastName?: string) { if (lastName) { return firstName + \u0026#39; \u0026#39; + lastName; } else { return firstName; } } let tomcat = buildName(\u0026#39;Tom\u0026#39;, \u0026#39;Cat\u0026#39;); let tom = buildName(\u0026#39;Tom\u0026#39;); //参数默认值 function buildName(firstName: string, lastName: string = \u0026#39;Cat\u0026#39;) { return firstName + \u0026#39; \u0026#39; + lastName; } let tomcat = buildName(\u0026#39;Tom\u0026#39;, \u0026#39;Cat\u0026#39;); let tom = buildName(\u0026#39;Tom\u0026#39;); //剩余参数 ...rest rest 参数只能是最后一个参数 function push(array, ...items) { items.forEach(function(item) { array.push(item); }); } let a: any[] = []; push(a, 1, 2, 3); 函数重载 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。\n利用联合类型，我们可以这么实现：\nfunction reverse(x: number | string): number | string | void { if (typeof x === \u0026#39;number\u0026#39;) { return Number(x.toString().split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)); } else if (typeof x === \u0026#39;string\u0026#39;) { return x.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n这时，我们可以使用重载定义多个 reverse 的函数类型：\nfunction reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string | void { if (typeof x === \u0026#39;number\u0026#39;) { return Number(x.toString().split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;)); } else if (typeof x === \u0026#39;string\u0026#39;) { return x.split(\u0026#39;\u0026#39;).reverse().join(\u0026#39;\u0026#39;); } } 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。\nTypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n其实写起来挺麻烦的，后面了解泛型之后写起来会简洁一些，不必太纠结函数重载，知道有这个概念即可，平时一般用泛型来解决类似问题。\n3.interface 接口 基本概念 TypeScript 中的接口是一个非常灵活的概念，常用于对「对象的形状（Shape）」进行描述。\ninterface Person { name: string; age: number; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, age: 25 }; 定义的变量比接口少了一些属性或多一些属性都是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致\n可选属性 ？ interface Person { name: string; age?: number; } let tom: Person = { name: \u0026#39;Tom\u0026#39; }; let tom: Person = { name: \u0026#39;Tom\u0026#39;, age:100, gender:\u0026#34;male\u0026#34; //报错 仍然不允许添加未定义的属性 }; 只读属性 readonly interface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { id: 89757, name: \u0026#39;Tom\u0026#39;, gender: \u0026#39;male\u0026#39; }; tom.id = 9527; // index.ts(14,5): error TS2540: Cannot assign to \u0026#39;id\u0026#39; because it is a constant or a read-only property. 只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候\ninterface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, gender: \u0026#39;male\u0026#39; }; tom.id = 89757; //第一错没有给id初始值，第二错id为只读属性 interface 描述函数类型 interface 也可以用来描述函数类型，代码如下：\ninterface ISum { (x:number,y:number):number } const add:ISum = (num1, num2) =\u0026gt; { return num1 + num2 } 任意属性 一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\ninterface Person { name: string; age?: number; [propName: string]: string | number; } let tom: Person = { name: \u0026#39;Tom\u0026#39;, age: 25, gender: \u0026#39;male\u0026#39; }; duck typing ( 鸭子类型 ) const fn: FunctionWithProps = (x) =\u0026gt; { return x } fn.fnName = \u0026#39;hello world\u0026#39; //React 的 `FunctionComponent（函数式组件）` interface FunctionComponent\u0026lt;P = {}\u0026gt; { (props: PropsWithChildren\u0026lt;P\u0026gt;, context?: any): ReactElement\u0026lt;any, any\u0026gt; | null; propTypes?: WeakValidationMap\u0026lt;P\u0026gt; | undefined; contextTypes?: ValidationMap\u0026lt;any\u0026gt; | undefined; defaultProps?: Partial\u0026lt;P\u0026gt; | undefined; displayName?: string | undefined; } 4.class 类 类的属性与方法 在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。\n我们可以用Class关键字来定义一个类 class Person { // 成员属性 name: string //构造函数 - 执行初始化操作 constructor(name: string) { this.name = name } speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lin\u0026#39;) // 新建实例 p1.name // 访问属性和方法 p1.speak() 继承 继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。\n我们可以通过 extends 关键字来实现继承\nclass Student extends Person { study() { console.log(`${this.name} needs study`) } } const s1 = new Student(\u0026#39;lin\u0026#39;) s1.study() super关键字 注意，上例中 Student 类没有定义自己的属性，可以不写 super ，但是如果 Student 类有自己的属性，就要用到 super 关键字来把父类的属性继承过来。\n比如，Student 类新增一个 grade(成绩) 属性，就要这么写：\nclass Student extends Person { grade: number constructor(name: string,grade:number) { super(name) this.grade = grade } } const s1 = new Student(\u0026#39;lin\u0026#39;, 100) //不写 super 会报错。 多态 子类对父类的方法进行了重写，子类和父类调同一个方法时会不一样。\nclass Student extends Person { speak() { return `Student ${super.speak()}` } } 私有字段 与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：\n私有字段以 # 字符开头，有时我们称之为私有名称； 每个私有字段名称都唯一地限定于其包含的类； 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）； 私有字段不能在包含的类之外访问，甚至不能被检测到。 class Person { #name: string; //私有字段 constructor(name: string) { this.#name = name; } greet() { console.log(`Hello, my name is ${this.#name}!`); } } let semlinker = new Person(\u0026#34;Semlinker\u0026#34;); semlinker.#name; // ~~~~~ // Property \u0026#39;#name\u0026#39; is not accessible outside class \u0026#39;Person\u0026#39; // because it has a private identifier. 只属于类自己 它的实例能否访问 继承它的子类能否访问 public 公有的 能 能 private 私有的 是 不能 不能 protected 受保护的 不能 能 static 不能 能 private\nclass Person { private name: string public constructor(name: string) { this.name = name } public speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lv\u0026#39;) p1.name //报错 “name” is private... class Student extends Person { study(){ console.log(`${this.name} needs study`) //报错 “name” is private... } } protected\nclass Person { protected name: string public constructor(name: string) { this.name = name } public speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person(\u0026#39;lv\u0026#39;) p1.name //报错 “name” is protected... class Student extends Person { study(){ console.log(`${this.name} needs study`) } } 访问器 我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。\nlet passcode = \u0026#34;Hello TypeScript\u0026#34;; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode \u0026amp;\u0026amp; passcode == \u0026#34;Hello TypeScript\u0026#34;) { this._fullName = newName; } else { console.log(\u0026#34;Error: Unauthorized update of employee!\u0026#34;); } } } let employee = new Employee(); employee.fullName = \u0026#34;Semlinker\u0026#34;; if (employee.fullName) { console.log(employee.fullName); } 抽象类 使用 abstract 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多个抽象方法。所谓的抽象方法，是指不包含具体实现的方法：\nabstract class Person { constructor(public name: string){} abstract say(words: string) :void; } // Cannot create an instance of an abstract class.(2511) const lolo = new Person(); // Error 抽象类不能被直接实例化，我们只能实例化实现了所有抽象方法的子类。\nabstract class Person { constructor(public name: string){} // 抽象方法 abstract say(words: string) :void; } class Developer extends Person { constructor(name: string) { super(name); } say(words: string): void { console.log(`${this.name} says ${words}`); } } const lolo = new Developer(\u0026#34;lolo\u0026#34;); lolo.say(\u0026#34;I love ts!\u0026#34;); // lolo says I love ts! 类方法重载 对于类的方法来说，它也支持重载。比如，示例中我们重载了 ProductService 类的 getProducts 成员方法：\nclass ProductService { getProducts(): void; getProducts(id: number): void; getProducts(id?: number) { if(typeof id === \u0026#39;number\u0026#39;) { console.log(`获取id为 ${id} 的产品信息`); } else { console.log(`获取所有的产品信息`); } } } const productService = new ProductService(); productService.getProducts(666); // 获取id为 666 的产品信息 productService.getProducts(); // 获取所有的产品信息 5.interface 和 class 的关系 interface 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。 interface 同样可以用来约束 class，要实现约束，需要用到 implements 关键字。\nimplements implements 是实现的意思，class 实现 interface。\n比如手机有播放音乐的功能，可以这么写：\ninterface MusicInterface { playMusic(): void } class Cellphone implements MusicInterface { playMusic() {} // 如果 Cellphone 类上不写 playMusic 方法，会报错。 } 定义了约束后，class 必须要满足接口上的所有条件。\n处理公共的属性和方法 不同的类有一些共同的属性和方法，使用继承很难完成。\n比如汽车（Car 类）也有播放音乐的功能，你可以这么做：\n用 Car 类继承 Cellphone 类 找一个 Car 类和 Cellphone 类的父类，父类有播放音乐的方法，他们俩继承这个父类 很显然这两种方法都不合常理。\n实际上，使用 implements，问题就会迎刃而解\ninterface MusicInterface { playMusic(): void } //Car 类和 Cellphone 类都约束了播放音乐的功能。 class Car implements MusicInterface { playMusic() {} } class Cellphone implements MusicInterface { playMusic() {} } 再比如，手机还有打电话的功能，就可以这么做，Cellphone 类 implements 两个 interface。\ninterface MusicInterface { playMusic(): void } interface CallInterface { makePhoneCall(): void } class Cellphone implements MusicInterface, CallInterface { playMusic() {} makePhoneCall() {} } interface 来约束 class，class 实现了 interface 规定的属性或方法，没有继承那么多条条框框，非常灵活。\n约束构造函数和静态属性 使用 implements 只能约束类实例上的属性和方法，要约束构造函数和静态属性，需要这么写。\n以我们上文提过的 Circl 类为例：\ninterface CircleStatic { new (radius: number): void pi: number } const Circle:CircleStatic = class Circle { static pi: 3.14 public radius: number public constructor(radius: number) { this.radius = radius } } const Circle:CircleStatic = class Circle { public radius: number //未定义静态属性 pi，会报错： \u0026#39;pi\u0026#39; is missing public constructor(radius:string){ //constructor 入参类型不对，会报错： type \u0026#39;number\u0026#39; is not... to type \u0026#39;string\u0026#39; this.radius = radius } } 6.Enum 枚举类型 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。\n数字枚举 enum Direction { NORTH, //0 SOUTH, EAST, WEST, //3 } let dir: Direction = Direction.NORTH; 设置 NORTH 的初始值，比如：\nenum Direction { NORTH = 3, SOUTH, EAST, WEST, }` 字符串枚举 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\nenum Direction { NORTH = \u0026#34;NORTH\u0026#34;, SOUTH = \u0026#34;SOUTH\u0026#34;, EAST = \u0026#34;EAST\u0026#34;, WEST = \u0026#34;WEST\u0026#34;, } 异构枚举 enum Enum { A, B, C = \u0026#34;C\u0026#34;, D = \u0026#34;D\u0026#34;, E = 8, F, } //反向映射 console.log(Enum.A) //输出：0 console.log(Enum[0]) // 输出：A 7.类型推论 TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\nlet myFavoriteNumber = \u0026#39;seven\u0026#39;; // let myFavoriteNumber: string = \u0026#39;seven\u0026#39; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type \u0026#39;number\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查\nlet myFavoriteNumber; myFavoriteNumber = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 虽然 TS 可以推导出最合适的类型，但最好还是在写的时候就定义好类型，下面的例子，可以用ts这么写：\n// let arr = [0, 1, null, \u0026#39;lin\u0026#39;]; type arrItem = number | string | null let arr: arrItem[] = [0, 1, null, \u0026#39;lin\u0026#39;]; let pets: Pets[] = [new Dog(), new Cat()] 8.内置类型 JS 八种内置类型 let name: string = \u0026#34;lin\u0026#34;; let age: number = 18; let isHandsome: boolean = true; let u: undefined = undefined; let n: null = null; let obj: object = {name: \u0026#39;lin\u0026#39;, age: 18}; let big: bigint = 100n; let sym: symbol = Symbol(\u0026#34;lin\u0026#34;); ECMAScript 的内置对象 比如，Array、Date、Error 等\nconst nums: Array\u0026lt;number\u0026gt; = [1,2,3] const date: Date = new Date() const err: Error = new Error(\u0026#39;Error!\u0026#39;); const reg: RegExp = /abc/; Math.pow(2, 9) DOM 和 BOM 比如 HTMLElement、NodeList、MouseEvent 等\nlet body: HTMLElement = document.body let allDiv: NodeList = document.querySelectorAll(\u0026#39;div\u0026#39;); document.addEventListener(\u0026#39;click\u0026#39;, (e: MouseEvent) =\u0026gt; { e.preventDefault() // Do something }); TS 进阶 1.高级类型（一） 联合类型 联合类型表示可以取值为多类型中的一种\nlet myFavoriteNumber: string | number; myFavoriteNumber = \u0026#39;seven\u0026#39;; myFavoriteNumber = 7; 只能访问此联合类型的所有类型里共有的属性或方法：\nfunction getLength(something: string | number): number { return something.length; } // index.ts(2,22): error TS2339: Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;string | number\u0026#39;. // Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;number\u0026#39;. 上例中，length 不是 string 和 number 的共有属性，所以会报错。 访问 string 和 number 的共有属性是没问题的：\nfunction getString(something: string | number): string { return something.toString(); } 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型\nlet myFavoriteNumber: string | number; myFavoriteNumber = \u0026#39;seven\u0026#39;; console.log(myFavoriteNumber.length); // 5 被推断为string myFavoriteNumber = 7; console.log(myFavoriteNumber.length); // 编译时报错 被推断为number // index.ts(5,30): error TS2339: Property \u0026#39;length\u0026#39; does not exist on type \u0026#39;number\u0026#39;. 交叉类型 \u0026amp; 运算符 在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 \u0026amp; 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\ninterface Person { name: string age: number } type Student = Person \u0026amp; { grade: number } 联合类型 | 是指可以取几种类型中的任意一种，而交叉类型 \u0026amp; 是指把几种类型合并起来。\n交叉类型和 interface 的 extends 非常类似，都是为了实现对象形状的组合和扩展。\n类型别名（ type ） 类型别名（type aliase），听名字就很好理解，就是给类型起个别名。\n就像 NBA 球员 扬尼斯-阿德托昆博，名字太长难记，我们叫他字母哥。\n就像我们项目中配置 alias，不用写相对路径就能很方便地引入文件\nimport componentA from \u0026#39;../../../../components/componentA/index.vue\u0026#39; 变成 import componentA from \u0026#39;@/components/componentA/index.vue 类型别名用 type 关键字来书写，有了类型别名，我们书写 TS 的时候可以更加方便简洁。\n比如下面这个例子，getName 这个函数接收的参数可能是字符串，可能是函数，就可以这么写。\ntype Name = string type NameResolver = () =\u0026gt; string type NameOrResolver = Name | NameResolver // 联合类型 function getName(n: NameOrResolver): Name { if (typeof n === \u0026#39;string\u0026#39;) { return n } else { return n() } } getName(\u0026#39;lin\u0026#39;) getName(() =\u0026gt; \u0026#39;lin\u0026#39;) 类型别名的用法：\ntype Name = string // 基本类型 type arrItem = number | string // 联合类型 const arr: arrItem[] = [1,\u0026#39;2\u0026#39;, 3] type Person = { name: Name } type Student = Person \u0026amp; { grade: number } // 交叉类型 type Teacher = Person \u0026amp; { major: string } type StudentAndTeacherList = [Student, Teacher] // 元组类型 const list:StudentAndTeacherList = [ { name: \u0026#39;lin\u0026#39;, grade: 100 }, { name: \u0026#39;liu\u0026#39;, major: \u0026#39;Chinese\u0026#39; } ] 接口与类型别名的区别 共同点 都可以用来描述对象或函数签名 //接口 interface Point { x: number; y: number; } interface SetPoint { (x: number, y: number): void; } //类型别名 type Point = { x: number; y: number; }; type SetPoint = (x: number, y: number) =\u0026gt; void; 都允许继承 // interface 继承 interface interface PartialPointX { x: number; } interface Point extends PartialPointX { y: number; } // type 继承 type type PartialPointX = { x: number; }; type Point = PartialPointX \u0026amp; { y: number; }; // interface 继承 type type Person = { name: string } interface Student extends Person { \u0026#34;interface用 extends 来继承\u0026#34; grade: number } // type 继承 interface interface Person { name: string } type Student = Person \u0026amp; { grade: number } \u0026#34;type用交叉类型来继承\u0026#34; 不同点 设计角度 interface（接口） 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。\ntype 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\ntype 用于其它类型 与 interface 不一样，**type 可以声明基本类型、联合类型、交叉类型、元组\n// primitive type Name = string; // object type PartialPointX = { x: number; }; type PartialPointY = { y: number; }; // union type PartialPoint = PartialPointX | PartialPointY; // tuple type Data = [number, string]; interface可以合并重复声明，type 不行 interface Person { name: string } interface Person { // 重复声明 interface，就合并了 age: number } const person: Person = { name: \u0026#39;lin\u0026#39;, age: 18 } type Person = { name: string } type Person = { // 报错，Duplicate identifier \u0026#39;Person\u0026#39; age: number } const person: Person = { name: \u0026#39;lin\u0026#39;, age: 18 } Implements 类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型：\ninterface Point { x: number; y: number; } class SomePoint implements Point { x = 1; y = 2; } type Point2 = { x: number; y: number; }; class SomePoint2 implements Point2 { x = 1; y = 2; } // 错误示例 type PartialPoint = { x: number; } | { y: number; }; // A class can only implement an object type or // intersection of object types with statically known members. class SomePartialPoint implements PartialPoint { // Error x = 1; y = 2; } 这两者的区别说了这么多，其实本不该把这两个东西拿来做对比，他们俩是完全不同的概念。\ninterface 是接口，用于描述一个对象。\ntype 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\n只是有时候两者都能实现同样的功能，才会经常被混淆\n平时开发中，一般使用组合或者交叉类型的时候，用 type。\n一般要用类的 extends 或 implements 时，用 interface。\n其他情况，比如定义一个对象或者函数，就看你心情了。\n类型保护 如果有一个 getLength 函数，入参是联合类型 number | string，返回入参的 length，\nfunction getLength(arg: number | string): number { return arg.length } 从上文可知，这么写会报错，因为 number 类型上没有 length 属性。\n这个时候，类型保护（Type Guards）出现了，可以使用 typeof 关键字判断变量的类型。\n我们把 getLength 方法改造一下，就可以精准地获取到 string 类型的 length 属性了，\nfunction getLength(arg: number | string): number { if(typeof arg === \u0026#39;string\u0026#39;) { return arg.length } else { return arg.toString().length } } 类型断言 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n尖括号语法 let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (\u0026lt;string\u0026gt;someValue).length; as语法 let someValue: any = \u0026#34;this is a string\u0026#34;; let strLength: number = (someValue as string).length; 注意，类型断言不是类型转换，把一个类型断言成联合类型中不存在的类型会报错。\n字面量类型 有时候，我们需要定义一些常量，就需要用到字面量类型，比如，\ntype ButtonSize = \u0026#39;mini\u0026#39; | \u0026#39;small\u0026#39; | \u0026#39;normal\u0026#39; | \u0026#39;large\u0026#39; type Sex = \u0026#39;男\u0026#39; | \u0026#39;女\u0026#39; const theSet: Sex = \u0026#34;不男不女\u0026#34; // Type \u0026#39;不男不女\u0026#39; is not assignable to type \u0026#39;sex\u0026#39; 这样就只能从这些定义的常量中取值，乱取值会报错。\n2.泛型 泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。\n它可以轻松解决输入输出要一致的问题。\n泛型基本使用 处理函数参数 其中 T 代表 Type，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。除了 T 之外，以下是常见泛型变量代表的意思：\nK（Key）：表示对象中的键类型； V（Value）：表示对象中的值类型； E（Element）：表示元素类型。 其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数：\nfunction identity \u0026lt;T, U\u0026gt;(value: T, message: U) : T { console.log(message); return value; } console.log(identity\u0026lt;Number, string\u0026gt;(68, \u0026#34;Semlinker\u0026#34;)); TS 类型推断，自动推导出类型。\nconsole.log(identity(68, \u0026#34;Semlinker\u0026#34;)); **ype 和 interface 都可以定义函数类型，也用泛型来写一下：\n// type type Print = \u0026lt;T\u0026gt;(arg: T) =\u0026gt; T const printFn:Print = function print(arg) { console.log(arg) return arg } // interface interface Iprint\u0026lt;T\u0026gt; { (arg: T): T } function print\u0026lt;T\u0026gt;(arg:T) { console.log(arg) return arg } const myPrint: Iprint\u0026lt;number\u0026gt; = print 默认参数 interface Iprint\u0026lt;T = number\u0026gt; { (arg: T): T } function print\u0026lt;T\u0026gt;(arg:T) { console.log(arg) return arg } const myPrint: Iprint = print 处理多个函数参数 传入一个只有两项的元组，交换元组的第 0 项和第 1 项，返回这个元组。\nfunction swap\u0026lt;T,U\u0026gt;(tuple:[T,U]):[U,T]{ return [tuple[1], tuple[0]] } const swap = \u0026lt;T,U\u0026gt;(tuple:[T,U]): [U,T] =\u0026gt;{ return [tuple[1],tuple[0]] } 函数副作用操作 调用 API 都清晰的知道返回类型是什么数据结构\ninterface UserInfo { name: string age: number } function request\u0026lt;T\u0026gt;(url:string): Promise\u0026lt;T\u0026gt; { return fetch(url).then(res =\u0026gt; res.json()) } request\u0026lt;UserInfo\u0026gt;(\u0026#39;user/info\u0026#39;).then(res =\u0026gt;{ console.log(res) }) 约束泛型 假设现在有这么一个函数，打印传入参数的长度，我们这么写：\nfunction printLength\u0026lt;T\u0026gt;(arg: T): T { console.log(arg.length) //不确定 T 是否有 length 属性，会报错： property \u0026#39;length\u0026#39; does not ... return arg } 那么现在我想约束这个泛型，一定要有 length 属性，怎么办？\n可以和 interface 结合，来约束类型。\ninterface ILength { length: number } function printLength\u0026lt;T extends ILength\u0026gt;(arg: T): T { console.log(arg.length) return arg } 泛型的一些应用 **泛型约束类 定义一个栈，有入栈和出栈两个方法，如果想入栈和出栈的元素类型统一，就可以这么写：\nclass Stack\u0026lt;T\u0026gt; { private data: T[] = [] push(item:T) { return this.data.push(item) } static pop():T | undefined { //给pop方法定义 static 关键字，报错 return this.data.pop() \u0026#39;泛型无法约束类的静态成员\u0026#39; } } const stack = new Stack\u0026lt;string\u0026gt;() stack.push(\u0026#39;124\u0026#39;) stack.push(123) // 类型number 不能复制给string stack.pop() **泛型约束接口 interface IKeyValue\u0026lt;T, U\u0026gt; { key: T value: U } const k1:IKeyValue\u0026lt;number, string\u0026gt; = { key: 18, value: \u0026#39;lin\u0026#39;} const k2:IKeyValue\u0026lt;string, number\u0026gt; = { key: \u0026#39;lin\u0026#39;, value: 18} **泛型定义数组 //之前我们这么写 const arr: number[] = [1,2,3] //现在可以这样写 const arr: Array\u0026lt;number\u0026gt; = [1,2,3] 小结 泛型的好处 函数和类可以轻松地支持多种类型，增强程序的拓展性\n不必写冗长的联合类型，增强代码的可读性\n灵活控制类型之间的约束\n泛型接口 interface GenericIdentityFn\u0026lt;T\u0026gt; { (arg: T): T; } 泛型类 class GenericNumber\u0026lt;T\u0026gt; { zeroValue: T; add: (x: T, y: T) =\u0026gt; T; } let myGenericNumber = new GenericNumber\u0026lt;number\u0026gt;(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function (x, y) { return x + y; }; 泛型工具类型 3.高级类型（二） 索引类型 从对象中抽取一些属性的值，然后拼接成数组，可以这么写\nconst userInfo = { name: \u0026#39;lin\u0026#39;, age: \u0026#39;18\u0026#39;, } function getValues(userInfo: any, keys: string[]) { return keys.map(key =\u0026gt; userInfo[key]) } // 抽取指定属性的值 console.log(getValues(userInfo, [\u0026#39;name\u0026#39;,\u0026#39;age\u0026#39;])) // [\u0026#39;lin\u0026#39;, \u0026#39;18\u0026#39;] // 抽取obj中没有的属性: console.log(getValues(userInfo, [\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;])) // [undefined, undefined] keyof（索引查询） keyof 操作符用于获取某种类型的所有键，其返回类型是联合类型。\ninterface Person { name: string; age: number; } type K1 = keyof Person; // \u0026#34;name\u0026#34; | \u0026#34;age\u0026#34; type K2 = keyof Person[]; // \u0026#34;length\u0026#34; | \u0026#34;toString\u0026#34; | \u0026#34;pop\u0026#34; | \u0026#34;push\u0026#34; | \u0026#34;concat\u0026#34; | \u0026#34;join\u0026#34; type K3 = keyof { [x: string]: Person }; // string | number T[K]（索引访问） T[K]，表示接口 T 的属性 K 所代表的类型\ninterface IPerson { name: string; age: number; } let type1: IPerson[\u0026#39;name\u0026#39;] // string let type2: IPerson[\u0026#39;age\u0026#39;] // number extends (泛型约束) T extends U，表示泛型变量可以通过继承某个类型，获得某些属性。\ninterface Lengthwise { length: number; } function loggingIdentity\u0026lt;T extends Lengthwise\u0026gt;(arg: T): T { console.log(arg.length); return arg; } 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\nloggingIdentity(3); // Error, number doesn\u0026#39;t have a .length property 这时我们需要传入符合约束类型的值，必须包含必须的属性\nloggingIdentity({length: 10, value: 3}); 检查动态属性 对 getValue 函数进行改造，实现对象上动态属性的检查。\n//改造前 const userInfo = { name: \u0026#39;lin\u0026#39;, age: \u0026#39;18\u0026#39;, } function getValues(userInfo: any, keys: string[]) { return keys.map(key =\u0026gt; userInfo[key]) } // 抽取指定属性的值 console.log(getValues(userInfo, [\u0026#39;name\u0026#39;,\u0026#39;age\u0026#39;])) // [\u0026#39;lin\u0026#39;, \u0026#39;18\u0026#39;] // 抽取obj中没有的属性: console.log(getValues(userInfo, [\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;])) // [undefined, undefined] //改造后 - 定义泛型 T、K，用于约束 userInfo 和 keys - 为 K 增加一个泛型约束,使 K 继承 userInfo 的所有属性的联合类型, 即`K extends keyof T` function getValues\u0026lt;T, K extends keyof T\u0026gt;(userInfo: T, keys: K[]): T[K][] { return keys.map(key =\u0026gt; userInfo[key]) } getValues(userInfo,[\u0026#39;sex\u0026#39;,\u0026#39;outlook\u0026#39;]) //这样当我们指定不在对象里的属性时，就会报错，Type \u0026#39;sex\u0026#39; is not assignable to type \u0026#39;\u0026#34;name\u0026#34;|\u0026#34;age\u0026#34;\u0026#39; 映射类型 TS允许将一个类型映射成另外一个类型。\nin in 用来遍历枚举类型\ntype Keys = \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; type Obj = { [p in Keys]: any } // -\u0026gt; { a: any, b: any, c: any } Partial Partial\u0026lt;T\u0026gt; 的作用就是将某个类型里的属性全部变为可选项 ?。\n/** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P]; }; 示例\ninterface Todo { title: string; description: string; } function updateTodo(todo: Todo, fieldsToUpdate: Partial\u0026lt;Todo\u0026gt;) { return { ...todo, ...fieldsToUpdate }; } const todo1 = { title: \u0026#34;Learn TS\u0026#34;, description: \u0026#34;Learn TypeScript\u0026#34;, }; const todo2 = updateTodo(todo1, { description: \u0026#34;Learn TypeScript Enum\u0026#34;, }); 上面的 updateTodo 方法中，我们利用 Partial\u0026lt;T\u0026gt; 工具类型，定义 fieldsToUpdate 的类型为 Partial\u0026lt;Todo\u0026gt;，即：\n{ title?: string | undefined; description?: string | undefined; } Partial 原理\nPartial 的实现用到了 in 和 keyof\n/** * Make all properties in T optional */ type Partial\u0026lt;T\u0026gt; = { [P in keyof T]?: T[P] } [P in keyof T]遍历T上的所有属性 ?:设置属性为可选的 T[P]设置类型为原来的类型 Readonly Readonly\u0026lt;T\u0026gt;将T的所有属性映射为只读的，例如：\ninterface IPerson { name: string age: number } type IReadOnly = Readonly\u0026lt;IPerson\u0026gt; let p1: IReadOnly = { name: \u0026#39;lin\u0026#39;, age: 18 } p1.name = \u0026#39;lv\u0026#39; //报错，Cannot assign to \u0026#39;name\u0026#39; because it is a read-only property. **Readonly 原理\n和 Partial 几乎完全一样\n/** * Make all properties in T readonly */ type Readonly\u0026lt;T\u0026gt; = { readonly [P in keyof T]: T[P] } typeof typeof 操作符用来获取一个变量声明或对象的类型。\ninterface Person { name: string; age: number; } const sem: Person = { name: \u0026#39;semlinker\u0026#39;, age: 33 }; type Sem= typeof sem; // -\u0026gt; Person function toArray(x: number): Array\u0026lt;number\u0026gt; { return [x]; } type Func = typeof toArray; // -\u0026gt; (x: number) =\u0026gt; number[] 条件类型 工具类型（Utility Types） 类型体操是什么？ 4.TS声明文件 TS 实战 todolist \u0026lt;div style=\u0026#34;padding: 50px; background: pink\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;todoMsg\u0026#34; /\u0026gt; \u0026lt;button @click=\u0026#34;add\u0026#34;\u0026gt;添加\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;clearHasDone\u0026#34;\u0026gt;清理\u0026lt;/button\u0026gt; \u0026lt;div v-if=\u0026#34;lists.length\u0026#34;\u0026gt; \u0026lt;div v-for=\u0026#34;(item, index) in lists\u0026#34; :key=\u0026#34;item.msg\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;item.done\u0026#34; /\u0026gt; \u0026lt;span :class=\u0026#34;{ done: item.done }\u0026#34;\u0026gt;{{ item.msg }}\u0026lt;/span\u0026gt; \u0026lt;span @click=\u0026#34;deleteItem(index)\u0026#34;\u0026gt;❎\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;span\u0026gt;全选\u0026lt;/span\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; v-model=\u0026#34;isAllDone\u0026#34; /\u0026gt; \u0026lt;span\u0026gt;{{ hasDone }} / {{ lists.length }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt;暂无数据\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; import { ElMessage } from \u0026#34;element-plus\u0026#34;; import { ref, computed } from \u0026#34;vue\u0026#34;; interface listType { done: boolean; msg: string; } const lists = ref\u0026lt;listType[]\u0026gt;([ { msg: \u0026#34;吃饭\u0026#34;, done: true }, { msg: \u0026#34;睡觉\u0026#34;, done: false }, { msg: \u0026#34;打游戏\u0026#34;, done: false } ]); const todoMsg = ref\u0026lt;string\u0026gt;(\u0026#34;\u0026#34;); const add = () =\u0026gt; { if (!todoMsg.value) { ElMessage.error(\u0026#34;请输入相关值！\u0026#34;); return; } let params: listType = { done: false, msg: todoMsg.value }; lists.value.push(params); todoMsg.value = \u0026#34;\u0026#34;; }; const clearHasDone = () =\u0026gt; { lists.value = lists.value.filter(item =\u0026gt; !item.done); }; const deleteItem = (index: number) =\u0026gt; { lists.value.splice(index, 1); }; const hasDone = computed(() =\u0026gt; { return lists.value.filter(item =\u0026gt; item.done).length; }); const isAllDone = computed\u0026lt;boolean\u0026gt;({ // 所有的事项是否完成，双向绑定到全选按钮 get() { // isAllDone 的获取方法，用于双向绑定数据 return hasDone.value === lists.value.length; }, set(value: boolean) { // isAllDone 的更改方法，用于实现全选 和 取消全选功能 lists.value.forEach(item =\u0026gt; { item.done = value; }); } }); 泛型约束后端接口参数类型 import axios from \u0026#39;axios\u0026#39; interface API { \u0026#39;/book/detail\u0026#39;: { id: number, }, \u0026#39;/book/comment\u0026#39;: { id: number comment: string } ... } function request\u0026lt;T extends keyof API\u0026gt;(url: T, obj: API[T]) { return axios.post(url, obj) } request(\u0026#39;/book/comment\u0026#39;, { id: 1, comment: \u0026#39;非常棒！\u0026#39; }) TS 封装 axios 请求 import { HttpResponse } from \u0026#39;@/common/interface\u0026#39; import Taro from \u0026#39;@tarojs/taro\u0026#39; import publicConfig from \u0026#39;@/config/index\u0026#39; import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, Canceler } from \u0026#39;axios-miniprogram\u0026#39; import errorHandle from \u0026#39;../common/errorHandle\u0026#39; const CancelToken = axios.CancelToken class HttpRequest { private baseUrl: string private pending: Record\u0026lt;string, Canceler\u0026gt; constructor(baseUrl: string) { this.baseUrl = baseUrl this.pending = {} } // 获取axios配置 getInsideConfig() { const config = { baseURL: this.baseUrl, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json;charset=utf-8\u0026#39; }, timeout: 10000 } return config } removePending(key: string, isRequest = false) { if (this.pending[key] \u0026amp;\u0026amp; isRequest) { this.pending[key](\u0026#39;取消重复请求\u0026#39;) } delete this.pending[key] } // 设定拦截器 interceptors(instance: AxiosInstance) { instance.interceptors.request.use( config =\u0026gt; { let isPublic = false publicConfig.publicPath.map(path =\u0026gt; { isPublic = isPublic || path.test(config.url || \u0026#39;\u0026#39;) }) const token = Taro.getStorageSync(\u0026#39;token\u0026#39;) if (!isPublic \u0026amp;\u0026amp; token) { config.headers.Authorization = \u0026#39;Bearer \u0026#39; + token } const key = config.url + \u0026#39;\u0026amp;\u0026#39; + config.method this.removePending(key, true) config.cancelToken = new CancelToken(c =\u0026gt; { this.pending[key] = c }) return config }, err =\u0026gt; { errorHandle(err) return Promise.reject(err) } ) // 响应请求的拦截器 instance.interceptors.response.use( res =\u0026gt; { const key = res.config.url + \u0026#39;\u0026amp;\u0026#39; + res.config.method this.removePending(key) if (res.status === 200) { return Promise.resolve(res.data) } else { return Promise.reject(res) } }, err =\u0026gt; { errorHandle(err) return Promise.reject(err) } ) } // 创建实例 request(options: AxiosRequestConfig) { const instance = axios.create() const newOptions = Object.assign(this.getInsideConfig(), options) this.interceptors(instance) return instance(newOptions) } get(url: string, config?: AxiosRequestConfig): Promise\u0026lt;AxiosResponse\u0026gt; | Promise\u0026lt;HttpResponse\u0026gt; { const options = Object.assign( { method: \u0026#39;get\u0026#39;, url: url }, config ) return this.request(options) } post(url: string, data?: unknown): Promise\u0026lt;AxiosResponse\u0026gt; | Promise\u0026lt;HttpResponse\u0026gt; { return this.request({ method: \u0026#39;post\u0026#39;, url: url, data: data }) } } export default HttpRequest waiting 七、TypeScript 数组 **数组解构\nlet x: number; let y: number; let z: number; let five_array = [0,1,2,3,4]; [x,y,z] = five_array; **数组展开运算符\nlet two_array = [0, 1]; let five_array = [...two_array, 2, 3, 4]; **数组遍历\nlet colors: string[] = [\u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34;]; for (let i of colors) { //获取每一个对象 console.log(i); } // for (let i in colors) 获取下标 八、TypeScript 对象 //公共数组 let person = { name: \u0026#34;Semlinker\u0026#34;, gender: \u0026#34;Male\u0026#34;, address: \u0026#34;Xiamen\u0026#34;, }; **对象解构\nlet {name, gender} = person **对象展开运算符\n组装对象 let personWithAge = { ...person, age: 33 }; 获取除了某些项外的其它项 let { name, ...rest } = person; 十三、配置文件 tsconfig.json 作用 用于标识 TypeScript 项目的根路径； 用于配置 TypeScript 编译器； 用于指定编译的文件。 重要字段 files - 设置要编译的文件的名称； include - 设置需要进行编译的文件，支持路径模式匹配； exclude - 设置无需进行编译的文件，支持路径模式匹配； compilerOptions - 设置与编译流程相关的选项 compilerOptions 选项 compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。\ncompilerOptions 每个选项的详细说明如下：\n{ \u0026#34;compilerOptions\u0026#34;: { /* 基本选项 */ \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, // 指定 ECMAScript 目标版本: \u0026#39;ES3\u0026#39; (default), \u0026#39;ES5\u0026#39;, \u0026#39;ES6\u0026#39;/\u0026#39;ES2015\u0026#39;, \u0026#39;ES2016\u0026#39;, \u0026#39;ES2017\u0026#39;, or \u0026#39;ESNEXT\u0026#39; \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, // 指定使用模块: \u0026#39;commonjs\u0026#39;, \u0026#39;amd\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;umd\u0026#39; or \u0026#39;es2015\u0026#39; \u0026#34;lib\u0026#34;: [], // 指定要包含在编译中的库文件 \u0026#34;allowJs\u0026#34;: true, // 允许编译 javascript 文件 \u0026#34;checkJs\u0026#34;: true, // 报告 javascript 文件中的错误 \u0026#34;jsx\u0026#34;: \u0026#34;preserve\u0026#34;, // 指定 jsx 代码的生成: \u0026#39;preserve\u0026#39;, \u0026#39;react-native\u0026#39;, or \u0026#39;react\u0026#39; \u0026#34;declaration\u0026#34;: true, // 生成相应的 \u0026#39;.d.ts\u0026#39; 文件 \u0026#34;sourceMap\u0026#34;: true, // 生成相应的 \u0026#39;.map\u0026#39; 文件 \u0026#34;outFile\u0026#34;: \u0026#34;./\u0026#34;, // 将输出文件合并为一个文件 \u0026#34;outDir\u0026#34;: \u0026#34;./\u0026#34;, // 指定输出目录 \u0026#34;rootDir\u0026#34;: \u0026#34;./\u0026#34;, // 用来控制输出目录结构 --outDir. \u0026#34;removeComments\u0026#34;: true, // 删除编译后的所有的注释 \u0026#34;noEmit\u0026#34;: true, // 不生成输出文件 \u0026#34;importHelpers\u0026#34;: true, // 从 tslib 导入辅助工具函数 \u0026#34;isolatedModules\u0026#34;: true, // 将每个文件做为单独的模块 （与 \u0026#39;ts.transpileModule\u0026#39; 类似）. /* 严格的类型检查选项 */ \u0026#34;strict\u0026#34;: true, // 启用所有严格类型检查选项 \u0026#34;noImplicitAny\u0026#34;: true, // 在表达式和声明上有隐含的 any类型时报错 \u0026#34;strictNullChecks\u0026#34;: true, // 启用严格的 null 检查 \u0026#34;noImplicitThis\u0026#34;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \u0026#34;alwaysStrict\u0026#34;: true, // 以严格模式检查每个模块，并在每个文件里加入 \u0026#39;use strict\u0026#39; /* 额外的检查 */ \u0026#34;noUnusedLocals\u0026#34;: true, // 有未使用的变量时，抛出错误 \u0026#34;noUnusedParameters\u0026#34;: true, // 有未使用的参数时，抛出错误 \u0026#34;noImplicitReturns\u0026#34;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, // 选择模块解析策略： \u0026#39;node\u0026#39; (Node.js) or \u0026#39;classic\u0026#39; (TypeScript pre-1.6) \u0026#34;baseUrl\u0026#34;: \u0026#34;./\u0026#34;, // 用于解析非相对模块名称的基目录 \u0026#34;paths\u0026#34;: {}, // 模块名到基于 baseUrl 的路径映射的列表 \u0026#34;rootDirs\u0026#34;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \u0026#34;typeRoots\u0026#34;: [], // 包含类型声明的文件列表 \u0026#34;types\u0026#34;: [], // 需要包含的类型声明文件名列表 \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \u0026#34;sourceRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \u0026#34;mapRoot\u0026#34;: \u0026#34;./\u0026#34;, // 指定调试器应该找到映射文件而不是生成文件的位置 \u0026#34;inlineSourceMap\u0026#34;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \u0026#34;inlineSources\u0026#34;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \u0026#34;experimentalDecorators\u0026#34;: true, // 启用装饰器 \u0026#34;emitDecoratorMetadata\u0026#34;: true // 为装饰器提供元数据的支持 } } 3.2 非空断言 在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。具体而言，x! 将从 x 值域中排除 null 和 undefined 。\n那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。\n1.忽略 undefined 和 null 类型 function myFunc(maybeString: string | undefined | null) { // Type \u0026#39;string | null | undefined\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. // Type \u0026#39;undefined\u0026#39; is not assignable to type \u0026#39;string\u0026#39;. const onlyString: string = maybeString; // Error const ignoreUndefinedAndNull: string = maybeString!; // Ok } 2.调用函数时忽略 undefined 类型 type NumGenerator = () =\u0026gt; number; function myFunc(numGenerator: NumGenerator | undefined) { // Object is possibly \u0026#39;undefined\u0026#39;.(2532) // Cannot invoke an object which is possibly \u0026#39;undefined\u0026#39;.(2722) const num1 = numGenerator(); // Error const num2 = numGenerator!(); //OK } 因为 ! 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：\nconst a: number | undefined = undefined; const b: number = a!; console.log(b); 以上 TS 代码会编译生成以下 ES5 代码：\nconst a: number | undefined = undefined; const b: number = a!; console.log(b); 虽然在 TS 代码中，我们使用了非空断言，使得 const b: number = a!; 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，! 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 undefined。\n3.3 确定赋值断言 在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：\nlet x: number; initialize(); // Variable \u0026#39;x\u0026#39; is used before being assigned.(2454) console.log(2 * x); // Error function initialize() { x = 10; } 很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：\nlet x!: number; initialize(); console.log(2 * x); // Ok function initialize() { x = 10; } 通过 let x!: number; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。\n","permalink":"https://bablvsj.github.io/posts/work/tech/codelanguage/20230815-typescript/","summary":"快速学习Ts","title":"TypeScript"},{"content":" 让子弹飞（申遗！）\n阿甘正传（“我妈妈经常说，生活就像巧克力，你永远不知道下一颗是什么口味。”）\n初恋这件小事（这就是初恋的感觉）\n楚门的世界（“如果再不能见到你，祝你早安、午安、晚安”）\n当幸福来敲门（“不要让别人告诉你，你不能做什么！”）\n地道战（抗日人民的脑洞真的很大）\n闻香识女人（这部电影的台词真叫一个绝！）\n肖申克的救赎（经典不解释）\n放牛班的春天（天籁之音）\n蜘蛛侠 1 （没看过漫画，比较喜欢老版电影）\n机器人总动员（瓦力超会卖萌）\n怦然心动（两个人的视角来讲述一个青春故事）\n入殓师（没有令人不适的镜头，可以放心观看，治愈系）\n三傻大闹宝莱坞（人物冲突处理到极致）\n海上钢琴师（音乐很棒）\n那些年 我们一起追过的女孩\n千与千寻（就挺奇幻的）\n夺宝奇兵系列（看敌人在耍大刀，无奈一枪放倒）\n封神三部曲 （第一部 狐狸出世纣王无道天下大乱 第二部 纣王率军伐西岐 第三部 姬发联合各诸侯反攻）\n钢铁侠 1 （个人认为漫威系列最佳）\n国王的演讲（带英国挺过二战的国王是个口吃，超长待机女王是他的长女）\n哈利波特 1 、2 （让我对魔法世界最有新鲜感的两部，后面就有点暗黑了）\n好想告诉你（电影+动画）\n黑客帝国系列（见证了两个导演从兄弟变为姐弟在变为姐妹）\n横空出世（“你愿意隐姓埋名一辈子吗？”）\n虎胆龙威系列（英文名Die hard超级贴切 喜欢布鲁斯威利斯被两头坑的无奈表情）\n歌舞青春 1 （歌挺好听的）\n环太平洋（音乐起！）\n回到未来系列（被致敬无数次的科幻经典）\n机器管家（一个想成为人类的机器人的人生）\n疾速追杀系列（“A fuxxing pencil!”）\n罗马假日(男女主颜值超高)\n玫瑰人生（ Edith Piaf 传记，喜欢她的歌可以看一看）\n七磅（片名出自威尼斯商人，主角的还“债”历程，同时也是自我的救赎）\n情书（光良的童话 MV 里面两个人看的那个电影，治愈系）\n速度与激情 3 （可能我是个异类？）\n天使爱美丽（色彩、音乐都很棒，文艺片）\n天堂电影院（一段忘年之交）\n头文字 D （“永远不要有跟人斗的心，你要赢的是你自己。”）\n我，机器人（威尔史密斯主演动作电影的入坑作，其他像黑衣人之类的也很棒）\n我是传奇 1 （有点丧尸版鲁滨逊漂流记的感觉）\n无间道（港版经典）\n西西里的美丽传说（又硬又难受，人言可畏）\n逍遥法外（又叫猫鼠游戏，小李子和汤姆汉克斯版）\n小鬼当家系列（脑洞超大，超搞笑）\n窈窕奶爸（罗宾威廉姆斯演技、口技超一流）\n云图（一旦看懂了，就挺妙）\n战争之王（点子超多的军火商的传奇故事）\n终结者 2 （👍）\n最后的武士（挺悲壮的故事）\n宝莲灯（动画，个人认为已经逼近迪士尼水准了）\n暴力街区 Banlieue 13 （跑酷鼻祖大卫贝尔主演）\n变相怪杰（金凯瑞的脸简直就像橡皮泥）\n不能说的秘密（曲子都是精品）\n宫崎骏作品（我是有少女心？）：\n天空之城（入坑作，我一直感觉是映射侵华战争）\n龙猫（超可爱！）\n幽灵公主（又叫魔法少女，久石让作曲超美）\n魔女宅急便（我也想养一只黑猫）\n哈尔的移动城堡（全程注意力在菜头上）\n周星驰主演的经典无厘头，和猫和老鼠一样，可以电视轮播偶尔看一眼：\n喜剧之王\n唐伯虎点秋香\n百变星君\n大话西游系列\n功夫\n国产凌凌漆\n","permalink":"https://bablvsj.github.io/posts/life/20221216-%E5%80%BC%E5%BE%97%E4%B8%80%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/","summary":"留出点时间，去看看电影。","title":"值得一看的电影"},{"content":"1、《百年孤独》 无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。\n2、《被讨厌的勇气》 我们终其一生就是要摆脱他人的期待，找到真正的自己；\n经历本身不会决定什么，我们给过去的经历“赋予了什么样的意义”，这直接决定了我们的生活。。。\n3、《社会契约论》 人生而自由，却又时时处在枷锁之中。自认为主宰一切，反而更像是一切的奴隶；\n人们能够争取自由，却永远无法恢复自由。\n4、《论人类不平等的起源和基础》 教育不仅使受教育的人之间产生差异，而且也使那些受教育的人在文化成熟方面产生差异。要知道：当巨人与矮子同时行走在一条道路上时，他们每多走一步，巨人相对矮子的优势就越大。\n5、《那不勒斯四部曲》 我的整个生命，只是一场为了提升社会地位的低俗斗争；\n假如一个人想一直做庶民，那他的孩子、孙子，都会命若草芥，不值一提。\n6、《活出生命的意义》 人所拥有的任何东西，都可以被剥夺，唯独人性最后的自由，——也就是在任何境遇中选择一己态度和生活方式的自由——不能被剥夺。\n7、《财富自由》 财富不是你快乐的理由，学会从通往财富的旅途中收获幸福才是。等到哪一天，消费再也无法控制你，你成了生活的主人时，生活自此也就充满了喜悦。\n《伟大的博弈》 《宏观经济学原理》 《微观经济学原理》 《货币银行学》 《稳定不稳定经济》 《明斯基时刻》\n商：《低风险创业》 心：《空谷幽兰》 文：《你永远无法叫醒一个装睡的人》 ","permalink":"https://bablvsj.github.io/posts/life/thinks/20210501-%E4%B8%80%E4%BA%9B%E9%97%B2%E4%B9%A6/","summary":"待看闲书，进入收藏夹。","title":"一些闲书"},{"content":"web3职务要求\n熟悉 JavaScript ，ES6 熟悉 web3 框架，etherjs 或 web3js 熟悉前端相关框架，了解 nodejs 工作流 了解 DOM 以及现代浏览器各种技术 熟悉 webgl ，three.js 加分 手写 HTML ，熟悉 CSS 编写，有一定审美 主动学习能力 [任职要求] 大学相关专业本科或研究生毕业 两年以上互联网 /web3 行业一线工作经验 英文文档阅读能力 熟悉 Linux ，熟悉开源，熟悉 git ，github ，pull request 工作流 有分布式办公经验，有独立解决问题的能力 有开源作品加分 发送简历请附带 github 地址 ","permalink":"https://bablvsj.github.io/posts/temp/","summary":"web3职务要求 熟悉 JavaScript ，ES6 熟悉 web3 框架，etherjs 或 web3js 熟悉前端相关框架，了解 nodejs 工作流 了解 DOM 以及现代浏览器各种技术 熟悉 webgl ，three.j","title":"待学"},{"content":"ES Modul ESM(EcmaScript Module) 是 JS 后面推出一个标准、规范化的模块 语法。现在已经得到大部分浏览器的支持了, 同时最新的 Node 也是支持 ESM 了。\n导出 // 导出变量 export const radius = 100 // 导出函数也可以 export function add(a,b){ return a + b } export const add = (a,b) =\u0026gt; { return a + b } export class Circle { constructor(r) { this.radius = radius; } area() { return Math.PI * this.radius ** 2; } } 导出多个\nexport const radius = 100 const sayHello = function () { console.log(\u0026#39;hello \u0026#39;, name); } export { radius, sayHello } 混合导出\n可以使用export和export default同时使用并且互不影响，只需要在导入时地方注意，如果文件里有混合导入，则必须先导入默认导出的，在导入单个导入的值。\nexport const radius = \u0026#34;蛙人\u0026#34; export default { fn() {}， msg: \u0026#34;hello 蛙人\u0026#34; } 导入 // index,js export const name = \u0026#34;lvbu\u0026#34; export const age = 24 import { name, age } from \u0026#39;./index.js\u0026#39; console.log(name, age) // \u0026#34;lvbu\u0026#34; 24 // 如果里面全是单个导出，我们就想全部直接导入则可以这样写 import * as person from \u0026#39;./index.js\u0026#39; console.log(person) // {name: \u0026#34;lvbu\u0026#34;, age: 24} 混合导入\n// index,js export const name = \u0026#34;lvbu\u0026#34; export const age = 24 export default { msg: \u0026#34;lvbu\u0026#34; } import msg, { name, age } from \u0026#39;./index.js\u0026#39; console.log(msg) // { msg: \u0026#34;lvbu\u0026#34; } // 别名 import {default as person, name, age} from \u0026#34;./index.js\u0026#34; console.log(person) // { msg: \u0026#34;lvbu\u0026#34; } 在HTML中引入ES Modules 要在浏览器中使用ES Modules，你可以在HTML文件中使用\u0026lt;script\u0026gt;标签，并将type属性设置为module。这告诉浏览器加载的脚本是ES Module。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;ES Modules in the Browser\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;module\u0026#34; src=\u0026#34;main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ``\n异步加载模块 有时，你可能需要异步加载模块，以避免阻止页面的加载。你可以使用import()函数来实现异步加载：\njavascript\n复制代码\n// main.js import(\u0026#39;./lazyModule.js\u0026#39;).then(module =\u0026gt; { // 使用异步加载的模块 }).catch(error =\u0026gt; { console.error(error); }); 这使得在需要时按需加载模块成为可能，提高了页面性能。\n跨域加载 ES Modules也支持跨域加载。你可以从其他域的服务器加载模块，只要服务器允许跨域请求。这为构建跨域应用程序提供了更多的可能性。\n// main.js import(\u0026#39;https://example.com/remoteModule.js\u0026#39;).then(module =\u0026gt; { // 使用远程加载的模块 }).catch(error =\u0026gt; { console.error(error); }); 浏览器中的ES Modules为前端开发提供了更多的灵活性和模块化的优势。你可以创建可重用的模块，异步加载它们，以及跨域加载模块，从而构建强大的客户端应用程序。在下一章中，我们将深入研究如何使用ES Modules构建现代前端应用。\nCommonJs 导出 // 导出一个对象 module.exports = { name:\u0026#34;xiaobu\u0026#34; age: 25, sex: 1 } // 导出任意值 module.exports.name = \u0026#34;lvbu\u0026#34; module.exports.sex = null module.exports.age = undefined 直接导出\nexports.name = \u0026#34;lvbu\u0026#34; exports.sex = 1 混合导出\n混合导出，exports和module.exports可以同时使用，不会存在问题。\nexports.name = \u0026#34;lvbu\u0026#34; module.exports.age = 25 导入 CommonJs中使用require语法可以导入，如果想要单个的值，可以通过解构对象来获取。\n// index.js module.exports.name = \u0026#34;lvbu\u0026#34; module.exports.age = 24 let data = require(\u0026#34;./index.js\u0026#34;) console.log(data) // { name: \u0026#34;lvbu\u0026#34;, age: 25 } 重复导入\n不管是CommonJs还是Es Module都不会重复导入，就是只要该文件内加载过一次这个文件了，我再次导入一次是不会生效的。\nlet data = require(\u0026#34;./index.js\u0026#34;) let data = require(\u0026#34;./index.js\u0026#34;) // 不会在执行了 动态导入\nCommonJs支持动态导入，什么意思呢，就是可以在语句中，使用require语法，来看如下案例。\nlet lists = [\u0026#34;./index.js\u0026#34;, \u0026#34;./config.js\u0026#34;] lists.forEach((url) =\u0026gt; require(url)) // 动态导入 if (lists.length) { require(lists[0]) // 动态导入 } ","permalink":"https://bablvsj.github.io/posts/work/interview/questions/20231228-es-modul-%E4%B8%8E-commonjs/","summary":"ES Modul ESM(EcmaScript Module) 是 JS 后面推出一个标准、规范化的模块 语法。现在已经得到大部分浏览器的支持了, 同时最新的 Node 也是支持 ESM 了。 导出 // 导出变量 export const radius = 100 // 导出函","title":"ES Modul 与 CommonJs"},{"content":"相同之处 Vite 和 Webpack 都是现代化的前端构建工具\n不同之处 1. 构建原理 Webpack 是\nwebpack\nentry - route - module \u0026ndash;\u0026gt; Bundle \u0026ndash;\u0026gt; Server ready\nvite\n浏览器开始原生支持 ES 模块。它是基于 ESModule 的，不允许 CommonJS 的代码，不需要去处理不同模块化的统一而遍历所有模块文件，而是按需加载的过程（ index.html 通过esmodule 新特性可以直接去请求 main.js，再通过 main.js 中引入的模块 Vite 再通过开发服务器去按需加载这些模块 ），以原生 ES 模块方式提供源码，这实际上时让浏览器接管了部分打包程序的工作，Vite 只需要在浏览器请求源码时进行转换并按需提供源码，因此能快速启动开发服务器。\nServer ready \u0026mdash; http request \u0026ndash;\u0026gt; entry \u0026ndash; dynamic import 动态引入 \u0026ndash; route - module\n","permalink":"https://bablvsj.github.io/posts/work/interview/questions/20231228-webpack%E4%B8%8Evite%E7%9A%84%E5%8C%BA%E5%88%AB/","summary":"相同之处 Vite 和 Webpack 都是现代化的前端构建工具 不同之处 1. 构建原理 Webpack 是 webpack entry - route - module \u0026ndash;\u0026gt; Bundle \u0026ndash;\u0026gt; Server ready vite 浏览器开始原生支持 ES 模块。它是基于 ESModule 的，不允许 CommonJS 的代码，","title":"webpack / vite的区别"},{"content":"个人说明 大家好，我是小布。是一名前端开发者，希望能做个很酷的东西，希望能一直酷下去！ Github: https://github.com/bablvsj/ E-mail: bandblvsj@163.com\n博客日志 2023-12-20: Markdown 样式优化 2023-07-25: 引用hugo主题 PaperMod。\n2022-12-15: 引用hugo主题 hugo-theme-Reader。\n2022-12-10: 博客使用hugo构建。\n致谢 网站开发有借鉴 子舒 Kevin 两位的网站\n版权声明：网站文章所有版权如无特殊说明，均归本人所有。允许转载，标明出处即可。\n","permalink":"https://bablvsj.github.io/about/","summary":"about","title":"关于"},{"content":"","permalink":"https://bablvsj.github.io/message/","summary":"","title":"留言"}]