<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JS基础 | Bablvsj's Blog</title><meta name=keywords content="每天一道面试题"><meta name=description content="1.判断数据类型 typeof typeof 'seymoe' // 'string' typeof true // 'boolean' typeof 10 // 'number' typeof Symbol() // 'symbol' typeof null // 'object' `无法判定是否为 null ` typeof undefined // 'undefined' typeof {} // 'object' typeof [] // 'object' typeof(() => {}) // 'function' 弊端： null 的判定有误差 数组、对"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%9F%BA%E7%A1%80/><link crossorigin=anonymous href=/assets/css/stylesheet.241265d51339977eb0f90d05780e286ec2789600ca4137f29552dec9dee06569.css integrity="sha256-JBJl1RM5l36w+Q0FeA4obsJ4lgDKQTfylVLeyd7gZWk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JS基础"><meta property="og:description" content="1.判断数据类型 typeof typeof 'seymoe' // 'string' typeof true // 'boolean' typeof 10 // 'number' typeof Symbol() // 'symbol' typeof null // 'object' `无法判定是否为 null ` typeof undefined // 'undefined' typeof {} // 'object' typeof [] // 'object' typeof(() => {}) // 'function' 弊端： null 的判定有误差 数组、对"><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%9F%BA%E7%A1%80/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-16T13:46:19+08:00"><meta property="article:modified_time" content="2023-08-16T13:46:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JS基础"><meta name=twitter:description content="1.判断数据类型 typeof typeof 'seymoe' // 'string' typeof true // 'boolean' typeof 10 // 'number' typeof Symbol() // 'symbol' typeof null // 'object' `无法判定是否为 null ` typeof undefined // 'undefined' typeof {} // 'object' typeof [] // 'object' typeof(() => {}) // 'function' 弊端： null 的判定有误差 数组、对"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"JS基础","item":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%9F%BA%E7%A1%80/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JS基础","name":"JS基础","description":"1.判断数据类型 typeof typeof \u0026#39;seymoe\u0026#39; // \u0026#39;string\u0026#39; typeof true // \u0026#39;boolean\u0026#39; typeof 10 // \u0026#39;number\u0026#39; typeof Symbol() // \u0026#39;symbol\u0026#39; typeof null // \u0026#39;object\u0026#39; `无法判定是否为 null ` typeof undefined // \u0026#39;undefined\u0026#39; typeof {} // \u0026#39;object\u0026#39; typeof [] // \u0026#39;object\u0026#39; typeof(() =\u0026gt; {}) // \u0026#39;function\u0026#39; 弊端： null 的判定有误差 数组、对","keywords":["每天一道面试题"],"articleBody":"1.判断数据类型 typeof\ntypeof 'seymoe' // 'string' typeof true // 'boolean' typeof 10 // 'number' typeof Symbol() // 'symbol' typeof null // 'object' `无法判定是否为 null ` typeof undefined // 'undefined' typeof {} // 'object' typeof [] // 'object' typeof(() =\u003e {}) // 'function' 弊端：\nnull 的判定有误差 数组、对象都判定为 object instanceof\n{} instanceof Object //true [] instanceof Array //true (()=\u003e{}) instanceof Function //true `instanceof 也不是万能的` let arr = [] let obj = {} arr instanceof Array // true arr instanceof Object // true obj instanceof Object // true Object.prototype.toString() 可以说是判定 JavaScript 中数据类型的终极解决方法：\nObject.prototype.toString.call({}) // '[object Object]' Object.prototype.toString.call([]) // '[object Array]' Object.prototype.toString.call(() =\u003e {}) // '[object Function]' Object.prototype.toString.call('seymoe') // '[object String]' Object.prototype.toString.call(1) // '[object Number]' Object.prototype.toString.call(true) // '[object Boolean]' Object.prototype.toString.call(Symbol()) // '[object Symbol]' Object.prototype.toString.call(null) // '[object Null]' Object.prototype.toString.call(undefined) // '[object Undefined]' Object.prototype.toString.call(new Date()) // '[object Date]' Object.prototype.toString.call(Math) // '[object Math]' Object.prototype.toString.call(new Set()) // '[object Set]' Object.prototype.toString.call(new WeakSet()) // '[object WeakSet]' Object.prototype.toString.call(new Map()) // '[object Map]' Object.prototype.toString.call(new WeakMap()) // '[object WeakMap]' 2.toString和String的区别 toString()可以将数据都转为字符串，但是null和undefined不可以转换。\nconsole.log(null.toString()) //报错 TypeError: Cannot read property 'toString' of null console.log(undefined.toString())//报错 TypeError: Cannot read property 'toString' of undefined toString()括号中可以写数字，代表进制\n二进制：.toString(2); 八进制：.toString(8); 十进制：.toString(10); 十六进制：.toString(16); String()可以将null和undefined转换为字符串，但是没法转进制字符串\nconsole.log(String(null));// null console.log(String(undefined));// undefined 3.JS 闭包经典使用场景和含闭包必刷题 闭包是什么？ 闭包是指有权访问另一个函数作用域中变量的函数\n形成闭包的原因 内部的函数存在外部作用域的引用就会导致闭包。\nvar a = 0 function foo(){ var b =14 function fo(){ console.log(a, b) } fo() } foo() 变量提升 问题：说一下你对JavaScript变量提升的理解。\n定义：\n在函数体内部，声明变量，会把该变量提升到函数体的最顶端。注意：只提升变量声明，不赋值。\n代码1：\nfn(); function fn() { var x = 1; var y = 2; } 上方代码中：\n（1）给fn创建函数上下文，找到fn中所有用var声明的变量（即x和y）； （2）将这些变量初始化为undefined； （3）将x赋值为1，将y赋值为2。\n代码2：\nfn2(); function fn2() { console.log(2); } 上方代码中：\n（1）创建全局上下文，找到所有用function声明的变量，在环境中“创建”这些变量。 （2）将这些变量初始化，并赋值为 function(){ console.log(2) }（并不是undefined） （3）开始执行代码fn2();\n代码3：（let的出现）\n{ let x = 1 x = 2 } 上方代码中：\n（1）找到所有用 let 声明的变量，在环境中「创建」这些变量 （2）开始执行代码（注意现在还没有初始化） （3）执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined） （4）执行 x = 2，对 x 进行「赋值」\n代码4：\nlet x = 'global' { console.log(x) // Uncaught ReferenceError: x is not defined let x = 1 } 原因有两个：\nconsole.log(x) 中的 x 指的是下面的 x，而不是全局的 x\n执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）\n看到这里，你应该明白了 let 到底有没有提升：\nlet 的「创建」过程被提升了，但是初始化没有提升。\nvar 的「创建」和「初始化」都被提升了。\nfunction 的「创建」「初始化」和「赋值」都被提升了。\n参考链接：\n我用了两个月的时间才理解 let this 问题：下方代码的打印结果是什么？\nfunction A() { this.name = 'smyhvae'; } A.prototype.test = function () { setTimeout(function () { console.log(this.name); }, 1) } var a = new A(); a.test(); 打印结果是window.name，但实际的结果是空的。\n总结1：this永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。即：谁调用，指向谁。\n举例：\nvar name = '全局'; function getName() { var name = '局部'; return this.name; }; alert(getName()); 上方代码的打印结果是：全局。\n分析：getName()这个函数其实是window调用的，所以this指向的window，因为外部有name这个变量，所以打印结果为全局。\n总结2：没有明确的当前对象时，this永远指向window。这个在setTimeout里比较常见。\nJS 的 new 操作符做了哪些事情 new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。\nJS 中的垃圾回收机制 必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必 须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。\n这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时 候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：\nvar a=\"hello world\"; var b=\"world\";var a=b;//这时，会释放掉\"hello world\"， **释放内存以便再引用垃圾回收的方法：\n标记清除、计数引用。\n**标记清除\n这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可 能用到他们。当离开环境时，就标记为离开环境。 垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。\n**引用计数法\n引用计数法的意思就是每个值没引用的次数， 当声明了一个变量，并用一个引用类型的值赋值给改变量， 则这个值的引用次数为 1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。 用引用计数法会存在内存泄露，下面来看原因：\nfunction problem() { var objA = new Object(); var objB = new Object(); objA.someOtherObject = objB; objB.anotherObject = objA; } 在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。特 别 是 在 DOM对 象 中 ， 也 容 易 存 在 这 种 问 题 ：\nvarelement=document.getElementById （ ’‘ ）； var myObj=new Object(); myObj.element=element; element.someObject=myObj; 这样就不会有垃圾回收的过程。\n手写区域 1.自己实现一个 bind 函数 原理：通过 apply 或者 call 方法来实现。\n(1)初始版本\nFunction.prototype.bind=function(obj,arg){ var arg = Array.prototype.slice.call(arguments,1); var context = this; return function(newArg){ arg = arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); } } (2) 考虑到原型链 为什么要考虑？因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型\nFunction.prototype.bind=function(obj,arg){ var arg = Array.prototype.slice.call(arguments,1); var context = this; var bound = function(newArg){ arg=arg.concat(Array.prototype.slice.call(newArg)); return context.apply(obj,arg); } var F=function(){} //这里需要一个寄生组合继承 F.prototype=context.prototype; bound.prototype=new F(); return bound; } 2.实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正 则对象）\n通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象 Number，String ，Boolean，以及 Date 对象，RegExp 对象的复制。 (1) 前文的方法\nfunction deepClone(obj){ var newObj= obj instanceof Array?[]:{}; for(var i in obj){ newObj[i]=typeof obj[i]=='object'? deepClone(obj[i]) : obj[i]; } return newObj; } 这种方法可以实现一般对象和数组对象的克隆，比如：\nvar arr=[1,2,3]; var newArr=deepClone(arr); //newArr-\u003e[1,2,3] var obj={x:1,y:2} var newObj=deepClone(obj); // newObj={x:1,y:2} 但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：\n//Number 包装对象 var num = new Number(1); typeof num // \"object\" var newNum=deepClone(num); //newNum -\u003e {} 空对象 //String 包装对象 var str=new String(\"hello\"); typeof str //\"object\" var newStr=deepClone(str); //newStr-\u003e {0:'h',1:'e',2:'l',3:'l',4:'o'}; //Boolean 包装对象 var bol=new Boolean(true); typeof bol //\"object\" var newBol=deepClone(bol); // newBol -\u003e{} 空对象 (2) valueof()函数 所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值， 因此默认的 valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。 对 于 原 始 值 或 者 包 装 类 ：\nfunction baseClone(base){ return base.valueOf(); } //Number var num = new Number(1); var newNum = baseClone(num); //newNum-\u003e1 //String var str = new String('hello'); var newStr = baseClone(str); // newStr-\u003e\"hello\" //Boolean var bol = new Boolean(true); var newBol = baseClone(bol); //newBol-\u003e true 其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， 这里用 valueOf 实现，语法上比较符合 规范。\n对于 Date 类型： 因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1 月 1 日以来的毫秒数.因此我们可以在 Date的原型上定义克隆的方法：\nDate.prototype.clone = function(){ return new Date(this.valueOf()); } var date=new Date('2010'); var newDate=date.clone(); // newDate-\u003e Fri Jan 01 2010 08:00:00 GMT+0800 对 于 正 则 对 象\nRegExp：RegExp.prototype.clone = function() { var pattern = this.valueOf(); var flags = ''; flags += pattern.global ? 'g' : ''; flags += pattern.ignoreCase ? 'i' : ''; flags += pattern.multiline ? 'm' : ''; return new RegExp(pattern.source, flags); }; var reg = new RegExp('/111/'); var newReg = reg.clone(); //newReg-\u003e /\\/111\\// ","wordCount":"3483","inLanguage":"en","datePublished":"2023-08-16T13:46:19+08:00","dateModified":"2023-08-16T13:46:19+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/js%E5%9F%BA%E7%A1%80/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>JS基础</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/>每天一道面试题</a></div>7 min&nbsp;·&nbsp;<span title='2023-08-16 13:46:19 +0800 +0800'>2023/08/16</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><ul><ul><li><a href=#1%e5%88%a4%e6%96%ad%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b aria-label=1.判断数据类型>1.判断数据类型</a></li><li><a href=#2tostring%e5%92%8cstring%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=2.toString和String的区别>2.<code>toString</code>和<code>String</code>的区别</a></li><li><a href=#3js-%e9%97%ad%e5%8c%85%e7%bb%8f%e5%85%b8%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e5%92%8c%e5%90%ab%e9%97%ad%e5%8c%85%e5%bf%85%e5%88%b7%e9%a2%98 aria-label="3.JS 闭包经典使用场景和含闭包必刷题">3.JS 闭包经典使用场景和含闭包必刷题</a><ul><li><a href=#%e9%97%ad%e5%8c%85%e6%98%af%e4%bb%80%e4%b9%88 aria-label=闭包是什么？>闭包是什么？</a></li><li><a href=#%e5%bd%a2%e6%88%90%e9%97%ad%e5%8c%85%e7%9a%84%e5%8e%9f%e5%9b%a0 aria-label=形成闭包的原因>形成闭包的原因</a></li></ul></li></ul><li><a href=#%e5%8f%98%e9%87%8f%e6%8f%90%e5%8d%87 aria-label=变量提升>变量提升</a></li><li><a href=#this aria-label=this>this</a></li><li><a href=#js-%e7%9a%84-new-%e6%93%8d%e4%bd%9c%e7%ac%a6%e5%81%9a%e4%ba%86%e5%93%aa%e4%ba%9b%e4%ba%8b%e6%83%85 aria-label="JS 的 new 操作符做了哪些事情">JS 的 new 操作符做了哪些事情</a></li><li><a href=#js-%e4%b8%ad%e7%9a%84%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6 aria-label="JS 中的垃圾回收机制">JS 中的垃圾回收机制</a></li></ul><li><a href=#%e6%89%8b%e5%86%99%e5%8c%ba%e5%9f%9f aria-label=手写区域>手写区域</a><ul><li><a href=#1%e8%87%aa%e5%b7%b1%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa-bind-%e5%87%bd%e6%95%b0 aria-label="1.自己实现一个 bind 函数">1.自己实现一个 bind 函数</a></li><li><a href=#2%e5%ae%9e%e7%8e%b0-js-%e4%b8%ad%e6%89%80%e6%9c%89%e5%af%b9%e8%b1%a1%e7%9a%84%e6%b7%b1%e5%ba%a6%e5%85%8b%e9%9a%86%e5%8c%85%e8%a3%85%e5%af%b9%e8%b1%a1date-%e5%af%b9%e8%b1%a1%e6%ad%a3 aria-label="2.实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正">2.实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正</a></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h4 id=1判断数据类型>1.判断数据类型<a hidden class=anchor aria-hidden=true href=#1判断数据类型>#</a></h4><p><strong>typeof</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>typeof</span> <span style=color:#79740e>&#39;seymoe&#39;</span>    <span style=color:#928374;font-style:italic>// &#39;string&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>typeof</span> <span style=color:#af3a03>true</span>        <span style=color:#928374;font-style:italic>// &#39;boolean&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>typeof</span> <span style=color:#8f3f71>10</span>          <span style=color:#928374;font-style:italic>// &#39;number&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>typeof</span> Symbol()    <span style=color:#928374;font-style:italic>// &#39;symbol&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>typeof</span> <span style=color:#af3a03>null</span>        <span style=color:#928374;font-style:italic>// &#39;object&#39; `无法判定是否为 null `
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>typeof</span> <span style=color:#af3a03>undefined</span>   <span style=color:#928374;font-style:italic>// &#39;undefined&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>typeof</span> {}          <span style=color:#928374;font-style:italic>// &#39;object&#39;  
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>typeof</span> []          <span style=color:#928374;font-style:italic>// &#39;object&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>typeof</span>(() =&gt; {})   <span style=color:#928374;font-style:italic>// &#39;function&#39;
</span></span></span></code></pre></div><p>弊端：</p><ul><li><code>null</code> 的判定有误差</li><li>数组、对象都判定为 object</li></ul><p><strong>instanceof</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>{} <span style=color:#af3a03>instanceof</span> <span style=color:#b57614>Object</span>           <span style=color:#928374;font-style:italic>//true
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>[] <span style=color:#af3a03>instanceof</span> <span style=color:#b57614>Array</span>            <span style=color:#928374;font-style:italic>//true
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>(()=&gt;{}) <span style=color:#af3a03>instanceof</span> <span style=color:#b57614>Function</span>   <span style=color:#928374;font-style:italic>//true
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#79740e>`instanceof 也不是万能的`</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> arr <span style=color:#af3a03>=</span> [] 
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> obj <span style=color:#af3a03>=</span> {} 
</span></span><span style=display:flex><span>arr <span style=color:#af3a03>instanceof</span> <span style=color:#b57614>Array</span> <span style=color:#928374;font-style:italic>// true 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>arr <span style=color:#af3a03>instanceof</span> <span style=color:#b57614>Object</span> <span style=color:#928374;font-style:italic>// true 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>obj <span style=color:#af3a03>instanceof</span> <span style=color:#b57614>Object</span> <span style=color:#928374;font-style:italic>// true
</span></span></span></code></pre></div><p><strong><code>Object.prototype.toString()</code> 可以说是判定 <code>JavaScript</code> 中数据类型的终极解决方法：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#b57614>Object</span>.prototype.toString.call({}) <span style=color:#928374;font-style:italic>// &#39;[object Object]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call([]) <span style=color:#928374;font-style:italic>// &#39;[object Array]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(() =&gt; {}) <span style=color:#928374;font-style:italic>// &#39;[object Function]&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#79740e>&#39;seymoe&#39;</span>) <span style=color:#928374;font-style:italic>// &#39;[object String]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#8f3f71>1</span>) <span style=color:#928374;font-style:italic>// &#39;[object Number]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#af3a03>true</span>) <span style=color:#928374;font-style:italic>// &#39;[object Boolean]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(Symbol()) <span style=color:#928374;font-style:italic>// &#39;[object Symbol]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#af3a03>null</span>) <span style=color:#928374;font-style:italic>// &#39;[object Null]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#af3a03>undefined</span>) <span style=color:#928374;font-style:italic>// &#39;[object Undefined]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#af3a03>new</span> <span style=color:#b57614>Date</span>()) <span style=color:#928374;font-style:italic>// &#39;[object Date]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#b57614>Math</span>) <span style=color:#928374;font-style:italic>// &#39;[object Math]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#af3a03>new</span> Set()) <span style=color:#928374;font-style:italic>// &#39;[object Set]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#af3a03>new</span> WeakSet()) <span style=color:#928374;font-style:italic>// &#39;[object WeakSet]&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#af3a03>new</span> Map()) <span style=color:#928374;font-style:italic>// &#39;[object Map]&#39; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>Object</span>.prototype.toString.call(<span style=color:#af3a03>new</span> WeakMap()) <span style=color:#928374;font-style:italic>// &#39;[object WeakMap]&#39;
</span></span></span></code></pre></div><h4 id=2tostring和string的区别>2.<code>toString</code>和<code>String</code>的区别<a hidden class=anchor aria-hidden=true href=#2tostring和string的区别>#</a></h4><p><code>toString()</code>可以将数据都转为字符串，但是<code>null</code>和<code>undefined</code>不可以转换。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>console.log(<span style=color:#af3a03>null</span>.toString()) <span style=color:#928374;font-style:italic>//报错 TypeError: Cannot read property &#39;toString&#39; of null
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(<span style=color:#af3a03>undefined</span>.toString())<span style=color:#928374;font-style:italic>//报错 TypeError: Cannot read property &#39;toString&#39; of undefined
</span></span></span></code></pre></div><p><code>toString()</code>括号中可以写数字，代表进制</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>二进制：.toString(<span style=color:#8f3f71>2</span>);
</span></span><span style=display:flex><span>八进制：.toString(<span style=color:#8f3f71>8</span>);
</span></span><span style=display:flex><span>十进制：.toString(<span style=color:#8f3f71>10</span>);
</span></span><span style=display:flex><span>十六进制：.toString(<span style=color:#8f3f71>16</span>);
</span></span></code></pre></div><p><code>String()</code>可以将<code>null</code>和<code>undefined</code>转换为字符串，但是没法转进制字符串</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>console.log(<span style=color:#b57614>String</span>(<span style=color:#af3a03>null</span>));<span style=color:#928374;font-style:italic>// null
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(<span style=color:#b57614>String</span>(<span style=color:#af3a03>undefined</span>));<span style=color:#928374;font-style:italic>// undefined
</span></span></span></code></pre></div><h4 id=3js-闭包经典使用场景和含闭包必刷题>3.JS 闭包经典使用场景和含闭包必刷题<a hidden class=anchor aria-hidden=true href=#3js-闭包经典使用场景和含闭包必刷题>#</a></h4><h5 id=闭包是什么>闭包是什么？<a hidden class=anchor aria-hidden=true href=#闭包是什么>#</a></h5><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong></p><h5 id=形成闭包的原因>形成闭包的原因<a hidden class=anchor aria-hidden=true href=#形成闭包的原因>#</a></h5><p><strong>内部的函数存在外部作用域的引用就会导致闭包</strong>。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>var</span> a <span style=color:#af3a03>=</span> <span style=color:#8f3f71>0</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> foo(){
</span></span><span style=display:flex><span>    <span style=color:#af3a03>var</span> b <span style=color:#af3a03>=</span><span style=color:#8f3f71>14</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>function</span> fo(){
</span></span><span style=display:flex><span>        console.log(a, b)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    fo()
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>foo()
</span></span></code></pre></div><h3 id=变量提升>变量提升<a hidden class=anchor aria-hidden=true href=#变量提升>#</a></h3><p><strong>问题</strong>：说一下你对JavaScript变量提升的理解。</p><p><strong>定义</strong>：</p><p>在函数体内部，声明变量，会把该变量提升到函数体的最顶端。注意：<strong>只提升变量声明，不赋值</strong>。</p><p><strong>代码1</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    fn();
</span></span><span style=display:flex><span>    <span style=color:#af3a03>function</span> fn() {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>var</span> x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>;
</span></span><span style=display:flex><span>        <span style=color:#af3a03>var</span> y <span style=color:#af3a03>=</span> <span style=color:#8f3f71>2</span>;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>上方代码中：</p><p>（1）给fn创建函数上下文，找到fn中<strong>所有</strong>用var声明的变量（即x和y）；
（2）将这些变量初始化为undefined；
（3）将x赋值为1，将y赋值为2。</p><p><strong>代码2</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    fn2();
</span></span><span style=display:flex><span>    <span style=color:#af3a03>function</span> fn2() {
</span></span><span style=display:flex><span>        console.log(<span style=color:#8f3f71>2</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>上方代码中：</p><p>（1）创建全局上下文，找到所有用function声明的变量，在环境中“创建”这些变量。
（2）将这些变量<strong>初始化</strong>，并<strong>赋值</strong>为 <code>function(){ console.log(2) }</code>（并不是undefined）
（3）开始执行代码<code>fn2();</code></p><p><strong>代码3</strong>：（let的出现）</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#af3a03>let</span> x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>
</span></span><span style=display:flex><span>  x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>2</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上方代码中：</p><p>（1）找到所有用 let 声明的变量，在环境中「创建」这些变量
（2）开始执行代码（注意现在还没有初始化）
（3）执行 x = 1，将 x 「初始化」为 1（这并不是一次赋值，如果代码是 let x，就将 x 初始化为 undefined）
（4）执行 x = 2，对 x 进行「赋值」</p><p>代码4：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#af3a03>let</span> x <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;global&#39;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  console.log(x) <span style=color:#928374;font-style:italic>// Uncaught ReferenceError: x is not defined
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>let</span> x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>原因有两个：</p><ul><li><p>console.log(x) 中的 x 指的是下面的 x，而不是全局的 x</p></li><li><p>执行 log 时 x 还没「初始化」，所以不能使用（也就是所谓的暂时死区）</p></li></ul><p>看到这里，你应该明白了 let 到底有没有提升：</p><ul><li><p>let 的「创建」过程被提升了，但是初始化没有提升。</p></li><li><p>var 的「创建」和「初始化」都被提升了。</p></li><li><p>function 的「创建」「初始化」和「赋值」都被提升了。</p></li></ul><p>参考链接：</p><ul><li><a href=https://zhuanlan.zhihu.com/p/28140450>我用了两个月的时间才理解 let</a></li></ul><h3 id=this>this<a hidden class=anchor aria-hidden=true href=#this>#</a></h3><p>问题：下方代码的打印结果是什么？</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    <span style=color:#af3a03>function</span> A() {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>this</span>.name <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;smyhvae&#39;</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    A.prototype.test <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span> () {
</span></span><span style=display:flex><span>        setTimeout(<span style=color:#af3a03>function</span> () {
</span></span><span style=display:flex><span>            console.log(<span style=color:#af3a03>this</span>.name);
</span></span><span style=display:flex><span>        }, <span style=color:#8f3f71>1</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>var</span> a <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> A();
</span></span><span style=display:flex><span>    a.test();
</span></span></code></pre></div><p>打印结果是window.name，但实际的结果是空的。</p><p><strong>总结1</strong>：this永远指向<strong>函数运行时所在的对象</strong>，而不是函数被创建时所在的对象。即：<strong>谁调用</strong>，指向谁。</p><p><strong>举例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    <span style=color:#af3a03>var</span> name <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;全局&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>function</span> getName() {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>var</span> name <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;局部&#39;</span>;
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> <span style=color:#af3a03>this</span>.name;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    alert(getName());
</span></span></code></pre></div><p>上方代码的打印结果是：<code>全局</code>。</p><p>分析：<code>getName()</code>这个函数其实是window调用的，所以this指向的window，因为外部有name这个变量，所以打印结果为<code>全局</code>。</p><p><strong>总结2</strong>：没有明确的当前对象时，this永远指向window。这个在setTimeout里比较常见。</p><h3 id=js-的-new-操作符做了哪些事情>JS 的 new 操作符做了哪些事情<a hidden class=anchor aria-hidden=true href=#js-的-new-操作符做了哪些事情>#</a></h3><p>new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。</p><h3 id=js-中的垃圾回收机制>JS 中的垃圾回收机制<a hidden class=anchor aria-hidden=true href=#js-中的垃圾回收机制>#</a></h3><p>必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 程序每次创建字符串、数组或对象时，解释器都必 须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。</p><p>这段话解释了为什么需要系统需要垃圾回收，JS 不像 C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript 的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时
候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>var</span> a<span style=color:#af3a03>=</span><span style=color:#79740e>&#34;hello world&#34;</span>; <span style=color:#af3a03>var</span> b<span style=color:#af3a03>=</span><span style=color:#79740e>&#34;world&#34;</span>;<span style=color:#af3a03>var</span> a<span style=color:#af3a03>=</span>b;<span style=color:#928374;font-style:italic>//这时，会释放掉&#34;hello world&#34;，
</span></span></span></code></pre></div><p>**释放内存以便再引用垃圾回收的方法：</p><p>标记清除、计数引用。</p><p>**标记清除</p><p>这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可
能用到他们。当离开环境时，就标记为离开环境。
垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。</p><p>**引用计数法</p><p>引用计数法的意思就是每个值没引用的次数， 当声明了一个变量，并用一个引用类型的值赋值给改变量，
则这个值的引用次数为 1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减 1，当这个值的引用次数为 0 的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为 0 的这些值。
用引用计数法会存在内存泄露，下面来看原因：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>function</span> problem() {
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> objA <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Object</span>(); <span style=color:#af3a03>var</span> objB <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Object</span>();
</span></span><span style=display:flex><span>	objA.someOtherObject <span style=color:#af3a03>=</span> objB; objB.anotherObject <span style=color:#af3a03>=</span> objA;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子里面，objA 和 objB 通过各自的属性相互引用，这样的话，两个对象的引用次数都为 2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为 0，这样的相互引用如果大量存在就会导致内存泄露。特 别 是 在 DOM对 象 中 ， 也 容 易 存 在 这 种 问 题 ：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>varelement<span style=color:#af3a03>=</span><span style=color:#b57614>document</span>.getElementById （ ’‘ ）；
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> myObj<span style=color:#af3a03>=</span><span style=color:#af3a03>new</span> <span style=color:#b57614>Object</span>();
</span></span><span style=display:flex><span>myObj.element<span style=color:#af3a03>=</span>element; element.someObject<span style=color:#af3a03>=</span>myObj;
</span></span></code></pre></div><p>这样就不会有垃圾回收的过程。</p><h2 id=手写区域>手写区域<a hidden class=anchor aria-hidden=true href=#手写区域>#</a></h2><h3 id=1自己实现一个-bind-函数>1.自己实现一个 bind 函数<a hidden class=anchor aria-hidden=true href=#1自己实现一个-bind-函数>#</a></h3><p>原理：通过 apply 或者 call 方法来实现。</p><p>(1)初始版本</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#b57614>Function</span>.prototype.bind<span style=color:#af3a03>=</span><span style=color:#af3a03>function</span>(obj,arg){
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> arg <span style=color:#af3a03>=</span> <span style=color:#b57614>Array</span>.prototype.slice.call(arguments,<span style=color:#8f3f71>1</span>);
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> context <span style=color:#af3a03>=</span> <span style=color:#af3a03>this</span>;
</span></span><span style=display:flex><span>	<span style=color:#af3a03>return</span> <span style=color:#af3a03>function</span>(newArg){ 
</span></span><span style=display:flex><span>			arg <span style=color:#af3a03>=</span> arg.concat(<span style=color:#b57614>Array</span>.prototype.slice.call(newArg));
</span></span><span style=display:flex><span>			<span style=color:#af3a03>return</span> context.apply(obj,arg);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>(2) 考虑到原型链
为什么要考虑？因为在 new 一个 bind 过生成的新函数的时候，必须的条件是要继承原函数的原型</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#b57614>Function</span>.prototype.bind<span style=color:#af3a03>=</span><span style=color:#af3a03>function</span>(obj,arg){
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> arg <span style=color:#af3a03>=</span> <span style=color:#b57614>Array</span>.prototype.slice.call(arguments,<span style=color:#8f3f71>1</span>); 
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> context <span style=color:#af3a03>=</span> <span style=color:#af3a03>this</span>;
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> bound <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(newArg){ 
</span></span><span style=display:flex><span>		arg<span style=color:#af3a03>=</span>arg.concat(<span style=color:#b57614>Array</span>.prototype.slice.call(newArg)); 
</span></span><span style=display:flex><span>		<span style=color:#af3a03>return</span> context.apply(obj,arg);
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> F<span style=color:#af3a03>=</span><span style=color:#af3a03>function</span>(){}
</span></span><span style=display:flex><span>	<span style=color:#928374;font-style:italic>//这里需要一个寄生组合继承
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>	F.prototype<span style=color:#af3a03>=</span>context.prototype;
</span></span><span style=display:flex><span>	bound.prototype<span style=color:#af3a03>=</span><span style=color:#af3a03>new</span> F(); 
</span></span><span style=display:flex><span>	<span style=color:#af3a03>return</span> bound;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2实现-js-中所有对象的深度克隆包装对象date-对象正>2.实现 JS 中所有对象的深度克隆（包装对象，Date 对象，正<a hidden class=anchor aria-hidden=true href=#2实现-js-中所有对象的深度克隆包装对象date-对象正>#</a></h3><p>则对象）</p><p>通过递归可以简单实现对象的深度克隆，但是这种方法不管是 ES6还是 ES5 实现，都有同样的缺陷，就是只能实现特定的 object 的深度复制（比如数组和函数），不能实现包装对象 Number，String ，Boolean，以及 Date 对象，RegExp 对象的复制。
(1) 前文的方法</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>function</span> deepClone(obj){
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> newObj<span style=color:#af3a03>=</span> obj <span style=color:#af3a03>instanceof</span> <span style=color:#b57614>Array</span><span style=color:#af3a03>?</span>[]<span style=color:#af3a03>:</span>{};
</span></span><span style=display:flex><span>	<span style=color:#af3a03>for</span>(<span style=color:#af3a03>var</span> i <span style=color:#af3a03>in</span> obj){
</span></span><span style=display:flex><span>		newObj[i]<span style=color:#af3a03>=</span><span style=color:#af3a03>typeof</span> obj[i]<span style=color:#af3a03>==</span><span style=color:#79740e>&#39;object&#39;</span><span style=color:#af3a03>?</span> deepClone(obj[i]) <span style=color:#af3a03>:</span> obj[i];
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#af3a03>return</span> newObj;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种方法可以实现一般对象和数组对象的克隆，比如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>var</span> arr<span style=color:#af3a03>=</span>[<span style=color:#8f3f71>1</span>,<span style=color:#8f3f71>2</span>,<span style=color:#8f3f71>3</span>];
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> newArr<span style=color:#af3a03>=</span>deepClone(arr);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//newArr-&gt;[1,2,3] 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> obj<span style=color:#af3a03>=</span>{x<span style=color:#af3a03>:</span><span style=color:#8f3f71>1</span>,y<span style=color:#af3a03>:</span><span style=color:#8f3f71>2</span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> newObj<span style=color:#af3a03>=</span>deepClone(obj);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// newObj={x:1,y:2}
</span></span></span></code></pre></div><p>但是不能实现例如包装对象 Number,String,Boolean,以及正则对象 RegExp 和 Date 对象的克隆，比如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#928374;font-style:italic>//Number 包装对象
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> num <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Number</span>(<span style=color:#8f3f71>1</span>); 
</span></span><span style=display:flex><span><span style=color:#af3a03>typeof</span> num <span style=color:#928374;font-style:italic>// &#34;object&#34;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> newNum<span style=color:#af3a03>=</span>deepClone(num);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//newNum -&gt; {} 空对象
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//String 包装对象
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> str<span style=color:#af3a03>=</span><span style=color:#af3a03>new</span> <span style=color:#b57614>String</span>(<span style=color:#79740e>&#34;hello&#34;</span>); 
</span></span><span style=display:flex><span><span style=color:#af3a03>typeof</span> str <span style=color:#928374;font-style:italic>//&#34;object&#34;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> newStr<span style=color:#af3a03>=</span>deepClone(str);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//newStr-&gt; {0:&#39;h&#39;,1:&#39;e&#39;,2:&#39;l&#39;,3:&#39;l&#39;,4:&#39;o&#39;};
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//Boolean 包装对象
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> bol<span style=color:#af3a03>=</span><span style=color:#af3a03>new</span> <span style=color:#b57614>Boolean</span>(<span style=color:#af3a03>true</span>); 
</span></span><span style=display:flex><span><span style=color:#af3a03>typeof</span> bol <span style=color:#928374;font-style:italic>//&#34;object&#34;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> newBol<span style=color:#af3a03>=</span>deepClone(bol);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// newBol -&gt;{} 空对象
</span></span></span></code></pre></div><p>(2) valueof()函数
所有对象都有 valueOf 方法，valueOf 方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值， 因此默认的 valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的 valueOf()方法只是简单返回这个对象本身。
对 于 原 始 值 或 者 包 装 类 ：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>function</span> baseClone(base){ 
</span></span><span style=display:flex><span>	<span style=color:#af3a03>return</span> base.valueOf();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//Number
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> num <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Number</span>(<span style=color:#8f3f71>1</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> newNum <span style=color:#af3a03>=</span> baseClone(num);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//newNum-&gt;1
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//String
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> str <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>String</span>(<span style=color:#79740e>&#39;hello&#39;</span>); 
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> newStr <span style=color:#af3a03>=</span> baseClone(str);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// newStr-&gt;&#34;hello&#34;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//Boolean
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> bol <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Boolean</span>(<span style=color:#af3a03>true</span>); 
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> newBol <span style=color:#af3a03>=</span> baseClone(bol);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//newBol-&gt; true
</span></span></span></code></pre></div><p>其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， 这里用 valueOf 实现，语法上比较符合
规范。</p><p>对于 Date 类型：
因为 valueOf 方法，日期类定义的 valueOf()方法会返回它的一个内部表示：1970 年 1 月 1 日以来的毫秒数.因此我们可以在 Date的原型上定义克隆的方法：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#b57614>Date</span>.prototype.clone <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>	<span style=color:#af3a03>return</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Date</span>(<span style=color:#af3a03>this</span>.valueOf());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> date<span style=color:#af3a03>=</span><span style=color:#af3a03>new</span> <span style=color:#b57614>Date</span>(<span style=color:#79740e>&#39;2010&#39;</span>); 
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> newDate<span style=color:#af3a03>=</span>date.clone();
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// newDate-&gt; Fri Jan 01 2010 08:00:00 GMT+0800
</span></span></span></code></pre></div><p>对 于 正 则 对 象</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#b57614>RegExp</span>：<span style=color:#b57614>RegExp</span>.prototype.clone <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>() { 
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> pattern <span style=color:#af3a03>=</span> <span style=color:#af3a03>this</span>.valueOf();
</span></span><span style=display:flex><span>	<span style=color:#af3a03>var</span> flags <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;&#39;</span>;
</span></span><span style=display:flex><span>	flags <span style=color:#af3a03>+=</span> pattern.global <span style=color:#af3a03>?</span> <span style=color:#79740e>&#39;g&#39;</span> <span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;&#39;</span>;
</span></span><span style=display:flex><span>	flags <span style=color:#af3a03>+=</span> pattern.ignoreCase <span style=color:#af3a03>?</span> <span style=color:#79740e>&#39;i&#39;</span> <span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;&#39;</span>;
</span></span><span style=display:flex><span>	flags <span style=color:#af3a03>+=</span> pattern.multiline <span style=color:#af3a03>?</span> <span style=color:#79740e>&#39;m&#39;</span> <span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;&#39;</span>;
</span></span><span style=display:flex><span>	<span style=color:#af3a03>return</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>RegExp</span>(pattern.source, flags);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> reg <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>RegExp</span>(<span style=color:#79740e>&#39;/111/&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> newReg <span style=color:#af3a03>=</span> reg.clone();
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//newReg-&gt;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#79740e>/\/111\//</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/>每天一道面试题</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AE%80%E8%BF%B0%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE%E5%8E%9F%E5%9E%8B%E7%BB%A7%E6%89%BF/><span class=title>« Prev</span><br><span>简述原型、原型链、(原型)继承</span></a>
<a class=next href=https://bablvsj.github.io/posts/interview/%E6%AF%8F%E5%A4%A9%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/css/><span class=title>Next »</span><br><span>Css库</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>