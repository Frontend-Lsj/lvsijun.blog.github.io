<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>钉钉面试 | Bablvsj's Blog</title><meta name=keywords content="面试题集"><meta name=description content="基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECM"><meta name=author content="Lvsj"><link rel=canonical href=https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%92%89%E9%92%89%E9%9D%A2%E8%AF%95/><link crossorigin=anonymous href=/assets/css/stylesheet.26af23b8b1c472aadb220beab8420315b9b18975751422bfb4256bd5bcdce878.css integrity="sha256-Jq8juLHEcqrbIgvquEIDFbmxiXV1FCK/tCVr1bzc6Hg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="钉钉面试"><meta property="og:description" content="基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECM"><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%92%89%E9%92%89%E9%9D%A2%E8%AF%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-04-01T17:11:35+08:00"><meta property="article:modified_time" content="2020-04-01T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="钉钉面试"><meta name=twitter:description content="基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECM"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"钉钉面试","item":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%92%89%E9%92%89%E9%9D%A2%E8%AF%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"钉钉面试","name":"钉钉面试","description":"基础知识主要包含以下几个方面： 基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECM","keywords":["面试题集"],"articleBody":"基础知识主要包含以下几个方面：\n基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解 语法：JavaScript、ECMAScript、CSS、TypeScript、HTML、Node.js 等语法的了解和使用 框架：React、Vue、Egg、Koa、Express、Webpack 等原理的了解和使用 工程：编译工具、格式工具、Git、NPM、单元测试、Nginx、PM2、CI / CD 了解和使用 网络：HTTP、TCP、UDP、WebSocket、Cookie、Session、跨域、缓存、协议的了解 性能：编译性能、监控、白屏检测、SEO、Service Worker 等了解 插件：Chrome 、Vue CLI 、Webpack 等插件设计思路的理解 系统：Mac、Windows、Linux 系统配置的实践 后端：Redis 缓存、数据库、Graphql、SSR、模板引擎等了解和使用 基础 1、列举你所了解的计算机存储设备类型？ 现代计算机以存储器为中心，主要由 CPU、I / O 设备以及主存储器三大部分组成。各个部分之间通过总线进行连接通信，具体如下图所示： 上图是一种多总线结构的示意图，CPU、主存以及 I / O 设备之间的所有数据都是通过总线进行并行传输，使用局部总线是为了提高 CPU 的吞吐量（CPU 不需要直接跟 I / O 设备通信），而使用高速总线（更贴近 CPU）和 DMA 总线则是为了提升高速 I / O 设备（外设存储器、局域网以及多媒体等）的执行效率。\n主存包括随机存储器 RAM 和只读存储器 ROM，其中 ROM 又可以分为 MROM（一次性）、PROM、EPROM、EEPROM 。ROM 中存储的程序（例如启动程序、固化程序）和数据（例如常量数据）在断电后不会丢失。RAM 主要分为静态 RAM（SRAM） 和动态 RAM（DRAM） 两种类型（DRAM 种类很多，包括 SDRAM、RDRAM、CDRAM 等），断电后数据会丢失，主要用于存储临时程序或者临时变量数据。DRAM 一般访问速度相对较慢。由于现代 CPU 读取速度要求相对较高，因此在 CPU 内核中都会设计 L1、L2 以及 L3 级别的多级高速缓存，这些缓存基本是由 SRAM 构成，一般访问速度较快。\n2、一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？ 高级程序设计语言不能直接被计算机理解并执行，需要通过翻译程序将其转换成特定处理器上可执行的指令，计算机 CPU 的简单工作原理如下所示： CPU 主要由控制单元、运算单元和存储单元组成（注意忽略了中断系统），各自的作用如下：\n控制单元：在节拍脉冲的作用下，将程序计数器（Program Counter，PC）指向的主存或者多级高速缓存中的指令地址送到地址总线，接着获取指令地址所对应的指令并放入指令寄存器 （Instruction Register，IR）中，然后通过指令译码器（Instruction Decoder，ID）分析指令需要进行的操作，最后通过操作控制器（Operation Controller，OC）向其他设备发出微操作控制信号。 运算单元：如果控制单元发出的控制信号存在算术运算（加、减、乘、除、增 1、减 1、取反等）或者逻辑运算（与、或、非、异或），那么需要通过运算单元获取存储单元的计算数据进行处理。 存储单元：包括片内缓存和寄存器组，是 CPU 中临时数据的存储地方。CPU 直接访问主存数据大概需要花费数百个机器周期，而访问寄存器或者片内缓存只需要若干个或者几十个机器周期，因此会使用内部寄存器或缓存来存储和获取临时数据（即将被运算或者运算之后的数据），从而提高 CPU 的运行效率。 除此之外，计算机系统执行程序指令时需要花费时间，其中取出一条指令并执行这条指令的时间叫指令周期。指令周期可以分为若干个阶段（取指周期、间址周期、执行周期和中断周期），每个阶段主要完成一项基本操作，完成基本操作的时间叫机器周期。机器周期是时钟周期的分频，例如最经典的 8051 单片机的机器周期为 12 个时钟周期。时钟周期是 CPU 工作的基本时间单位，也可以称为节拍脉冲或 T 周期（CPU 主频的倒数） 。假设 CPU 的主频是 1 GHz（1 Hz 表示每秒运行 1 次），那么表示时钟周期为 1 / 109 s。理论上 CPU 的主频越高，程序指令执行的速度越快。\n3、什么是指令和指令集？ 上图右侧主存中的指令是 CPU 可以支持的处理命令，一般包含算术指令（加和减）、逻辑指令（与、或和非）、数据指令（移动、输入、删除、加载和存储）、流程控制指令以及程序结束指令等，由于 CPU 只能识别二进制码，因此指令是由二进制码组成。除此之外，指令的集合称为指令集（例如汇编语言就是指令集的一种表现形式），常见的指令集有精简指令集（ARM）和复杂指令集（Inter X86）。一般指令集决定了 CPU 处理器的硬件架构，规定了处理器的相应操作。\n4、复杂指令集和精简指令集有什么区别？ 5、JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？ 早期的计算机只有机器语言时，程序设计必须用二进制数（0 和 1）来编写程序，并且要求程序员对计算机硬件和指令集非常了解，编程的难度较大，操作极易出错。为了解决机器语言的编程问题，慢慢开始出现了符号式的汇编语言（采用 ADD、SUB、MUL、DIV 等符号代表加减乘除）。为了使得计算机可以识别汇编语言，需要将汇编语言翻译成机器能够识别的机器语言（处理器的指令集）： 由于每一种机器的指令系统不同，需要不同的汇编语言程序与之匹配，因此程序员往往需要针对不同的机器了解其硬件结构和指令系统。为了可以抹平不同机器的指令系统，使得程序员可以更加关注程序设计本身，先后出现了各种面向问题的高级程序设计语言，例如 BASIC 和 C，具体过程如下图所示： 高级程序语言会先翻译成汇编语言或者其他中间语言，然后再根据不同的机器翻译成机器语言进行执行。除此之外，汇编语言虚拟机和机器语言机器之间还存在一层操作系统虚拟机，主要用于控制和管理操作系统的全部硬件和软件资源（随着超大规模集成电路技术的不断发展，一些操作系统的软件功能逐步由硬件来替换，例如目前的操作系统已经实现了部分程序的固化，简称固件，将程序永久性的存储在 ROM 中）。机器语言机器还可以继续分解成微程序机器，将每一条机器指令翻译成一组微指令（微程序）进行执行。\n上述虚拟机所提供的语言转换程序被称为编译器，主要作用是将某种语言编写的源程序转换成一个等价的机器语言程序，编译器的作用如下图所示： 例如 C 语言，可以先通过 gcc 编译器生成 Linux 和 Windows 下的目标 .o 和 .obj 文件（object 文件，即目标文件），然后将目标文件与底层系统库文件、应用程序库文件以及启动文件链接成可执行文件在目标机器上执行。\n温馨提示：感兴趣的同学可以了解一下 ARM 芯片的程序运行原理，包括使用 IDE 进行程序的编译（IDE 内置编译器，主流编译器包含 ARMCC、IAR 以及 GCC FOR ARM 等，其中一些编译器仅仅随着 IDE 进行捆绑发布，不提供独立使用的能力，而一些编译器则随着 IDE 进行发布的同时，还提供命令行接口的独立使用方式）、通过串口进行程序下载（下载到芯片的代码区初始启动地址映射的存储空间地址）、启动的存储空间地址映射（包括系统存储器、闪存 FLASH、内置 SRAM 等）、芯片的程序启动模式引脚 BOOT 的设置（例如调试代码时常常选择内置 SRAM、真正程序运行的时候选择闪存 FLASH）等。\n如果某种高级语言或者应用语言（例如用于人工智能的计算机设计语言）转换的目标语言不是特定计算机的汇编语言，而是面向另一种高级程序语言（很多研究性的编译器将 C 作为目标语言），那么还需要将目标高级程序语言再进行一次额外的编译才能得到最终的目标程序，这种编译器可称为源到源的转换器。\n除此之外，有些程序设计语言将编译的过程和最终转换成目标程序进行执行的过程混合在一起，这种语言转换程序通常被称为解释器，主要作用是将某种语言编写的源程序作为输入，将该源程序执行的结果作为输出，解释器的作用如下图所示：\nimage.png\n解释器和编译器有很多相似之处，都需要对源程序进行分析，并转换成目标机器可识别的机器语言进行执行。只是解释器是在转换源程序的同时立马执行对应的机器语言（转换和执行的过程不分离），而编译器得先把源程序全部转换成机器语言并产生目标文件，然后将目标文件写入相应的程序存储器进行执行（转换和执行的过程分离）。例如 Perl、Scheme、APL 使用解释器进行转换， C、C++ 则使用编译器进行转换，而 Java 和 JavaScript 的转换既包含了编译过程，也包含了解释过程。\n6、简单描述一下 Babel 的编译过程？ 7、JavaScript 中的数组和函数在内存中是如何存储的？ JavaScript 中的数组存储大致需要分为两种情况：\n同种类型数据的数组分配连续的内存空间 存在非同种类型数据的数组使用哈希映射分配内存空间 温馨提示：可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）。\n8、浏览器和 Node.js 中的事件循环机制有什么区别？ 阅读链接：面试分享：两年工作经验成功面试阿里P6总结**[2]** - 了解 Event Loop 吗？\n9、ES6 Modules 相对于 CommonJS 的优势是什么？ 10、高级程序设计语言是如何编译成机器语言的？ 11、编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？ 12、编译过程中虚拟机的作用是什么？ 13、什么是中间代码（IR），它的作用是什么？ 14、什么是交叉编译？ 编译器的设计是一个非常庞大和复杂的软件系统设计，在真正设计的时候需要解决两个相对重要的问题：\n如何分析不同高级程序语言设计的源程序 如何将源程序的功能等价映射到不同指令系统的目标机器 为了解决上述两项问题，编译器的设计最终被分解成前端（注意这里所说的不是 Web 前端）和后端两个编译阶段，前端用于解决第一个问题，而后端用于解决第二个问题，具体如下图所示： 上图中的中间表示（Intermediate Representation，IR）是程序结构的一种表现方式，它会比 AST（后续讲解）更加接近汇编语言或者指令集，同时也会保留源程序中的一些高级信息，除此之外 ，它的种类很多，包括三地址码（Three Address Code, TAC）****[3]、**静态单赋值形式（Static Single Assignment Form, SSA）****[4]**以及基于栈的 IR 等，具体作用包括：\n靠近前端部分主要适配不同的源程序，靠近后端部分主要适配不同的指令集，更易于编译器的错误调试，容易识别是 IR 之前还是之后出问题 如下左图所示，如果没有 IR，那么源程序到指令集之间需要进行一一适配，而有了中间表示，则可以使得编译器的职责更加分离，源程序的编译更多关注如何转换成 IR，而不是去适配不同的指令集 IR 本身可以做到多趟迭代从而优化源程序，在每一趟迭代的过程中可以研究代码并记录优化的细节，方便后续的迭代查找并利用这些优化信息，最终可以高效输出更优的目标程序 由于 IR 可以进行多趟迭代进行程序优化，因此在编译器中可插入一个新的优化阶段，如下图所示： 优化器可以对 IR 处理一遍或者多遍，从而生成更快执行速度（例如找到循环中不变的计算并对其进行优化从而减少运算次数）或者更小体积的目标程序，也可能用于产生更少异常或者更低功耗的目标程序。除此之外，前端和后端内部还可以细分为多个处理步骤，具体如下图所示： 优化器中的每一遍优化处理都可以使用一个或多个优化技术来改进代码，每一趟处理最终都是读写 IR 的操作，这样不仅仅可以使得优化可以更加高效，同时也可以降低优化的复杂度，还提高了优化的灵活性，可以使得编译器配置不同的优化选项，达到组合优化的效果。\n15、发布 / 订阅模式和观察者模式的区别是什么？ 阅读链接：基于Vue实现一个简易MVVM**[5]** - 观察者模式和发布/订阅模式\n16、装饰器模式一般会在什么场合使用？ 17、谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？ 18、列举你所了解的编程范式？ 编程范式（Programming paradigm）是指计算机编程的基本风格或者典型模式，可以简单理解为编程学科中实践出来的具有哲学和理论依据的一些经典原型。常见的编程范式有：\n面向过程（Process Oriented Programming，POP） 面向对象（Object Oriented Programming，OOP） 面向接口（Interface Oriented Programming， IOP） 面向切面（Aspect Oriented Programming，AOP） 函数式（Funtional Programming，FP） 响应式（Reactive Programming，RP） 函数响应式（Functional Reactive Programming，FRP） 阅读链接：：如果你对于编程范式的定义相对模糊，可以继续阅读 What is the precise definition of programming paradigm?****[6] 了解更多。\n不同的语言可以支持多种不同的编程范式，例如 C 语言支持 POP 范式，C++ 和 Java 语言支持 OOP 范式，Swift 语言则可以支持 FP 范式，而 Web 前端中的 JavaScript 可以支持上述列出的所有编程范式。\n19、什么是面向切面（AOP）的编程？ 20、什么是函数式编程？ 顾名思义，函数式编程是使用函数来进行高效处理数据或数据流的一种编程方式。在数学中，函数的三要素是定义域、值域和**对应关系。假设 A、B 是非空数集，对于集合 A 中的任意一个数 x，在集合 B 中都有唯一确定的数 f(x) 和它对应，那么可以将 f 称为从 A 到 B 的一个函数，记作：y = f(x)。在函数式编程中函数的概念和数学函数的概念类似，主要是描述形参 x 和返回值 y 之间的对应关系，**如下图所示：\n温馨提示：图片来自于简明 JavaScript 函数式编程——入门篇****[7]。\n在实际的编程中，可以将各种明确对应关系的函数进行传递、组合从而达到处理数据的最终目的。在此过程中，我们的关注点不在于如何去实现**对应关系，**而在于如何将各种已有的对应关系进行高效联动，从而可快速进行数据转换，达到最终的数据处理目的，提供开发效率。\n简单示例\n尽管你对函数式编程的概念有所了解，但是你仍然不知道函数式编程到底有什么特点。这里我们仍然拿 OOP 编程范式来举例，假设希望通过 OOP 编程来解决数学的加减乘除问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MathObject { constructor(private value: number) {} public add(num: number): MathObject { this.value += num; return this; } public multiply(num: number): MathObject { this.value *= num; return this; } public getValue(): number { return this.value; } } const a = new MathObject(1); a.add(1).multiply(2).add(a.multiply(2).getValue()); 复制代码 我们希望通过上述程序来解决 (1 + 2) * 2 + 1 * 2 的问题，但实际上计算出来的结果是 24，因为在代码内部有一个 this.value 的状态值需要跟踪，这会使得结果不符合预期。接下来我们采用函数式编程的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 function add(a: number, b: number): number { return a + b; } function multiply(a: number, b: number): number { return a * b; } const a: number = 1; const b: number = 2; add(multiply(add(a, b), b), multiply(a, b)); 复制代码 以上程序计算的结果是 8，完全符合预期。我们知道了 add 和 multiply 两个函数的实际对应关系，通过将对应关系进行有效的组合和传递，达到了最终的计算结果。除此之外，这两个函数还可以根据数学定律得出更优雅的组合方式：\n1 2 3 4 5 6 7 8 add(multiply(add(a, b), b), multiply(a, b)); // 根据数学定律分配律：a * b + a * c = a * (b + c)，得出： // (a + b) * b + a * b = (2a + b) * b // 简化上述函数的组合方式 multiply(add(add(a, a), b), b); 复制代码 我们完全不需要追踪类似于 OOP 编程范式中可能存在的内部状态数据，事实上对于数学定律中的结合律、交换律、同一律以及分配律，上述的函数式编程代码足可以胜任。\n原则\n通过上述简单的例子可以发现，要实现高可复用的函数**（对应关系）**，一定要遵循某些特定的原则，否则在使用的时候可能无法进行高效的传递和组合，例如\n高内聚低耦合 最小意外原则 单一职责原则 … 如果你之前经常进行无原则性的代码设计，那么在设计过程中可能会出现各种出乎意料的问题（这是为什么新手老是出现一些稀奇古怪问题的主要原因）。函数式编程可以有效的通过一些原则性的约束使你设计出更加健壮和优雅的代码，并且在不断的实践过程中进行经验式叠加，从而提高开发效率。\n特点\n虽然我们在使用函数的过程中更多的不再关注函数如何实现（对应关系），但是真正在使用和设计函数的时候需要注意以下一些特点：\n声明式（Declarative Programming） 一等公民（First Class Function） 纯函数（Pure Function） 无状态和数据不可变（Statelessness and Immutable Data） … 声明式\n我们以前设计的代码通常是命令式编程方式，这种编程方式往往注重具体的实现的过程（对应关系），而函数式编程则采用声明式的编程方式，往往注重如何去组合已有的**对应关系。**简单举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 命令式 const array = [0.8, 1.7, 2.5, 3.4]; const filterArray = []; for (let i = 0; i \u003c array.length; i++) { const integer = Math.floor(array[i]); if (integer \u003c 2) { continue; } filterArray.push(integer); } // 声明式 // map 和 filter 不会修改原有数组，而是产生新的数组返回 [0.8, 1.7, 2.5, 3.4].map((item) =\u003e Math.floor(item)).filter((item) =\u003e item \u003e 1); 复制代码 命令式代码一步一步的告诉计算机需要执行哪些语句，需要关心变量的实例化情况、循环的具体过程以及跟踪变量状态的变化过程。声明式代码更多的不再关心代码的具体执行过程，而是采用表达式的组合变换去处理问题，不再强调怎么做，而是指明**做什么。**声明式编程方式可以将我们设计代码的关注点彻底从过程式解放出来，从而提高开发效率。\n一等公民\n在 JavaScript 中，函数的使用非常灵活，例如可以对函数进行以下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 interface IHello { (name: string): string; key?: string; arr?: number[]; fn?(name: string): string; } // 函数声明提升 console.log(hello instanceof Object); // true // 函数声明提升 // hello 和其他引用类型的对象一样，都有属性和方法 hello.key = 'key'; hello.arr = [1, 2]; hello.fn = function (name: string) { return `hello.fn, ${name}`; }; // 函数声明提升 // 注意函数表达式不能在声明前执行，例如不能在这里使用 helloCopy('world') hello('world'); // 函数 // 创建新的函数对象，将函数的引用指向变量 hello // hello 仅仅是变量的名称 function hello(name: string): string { return `hello, ${name}`; } console.log(hello.key); // key console.log(hello.arr); // [1,2] console.log(hello.name); // hello // 函数表达式 const helloCopy: IHello = hello; helloCopy('world'); function transferHello(name: string, hello: Hello) { return hello('world'); } // 把函数对象当作实参传递 transferHello('world', helloCopy); // 把匿名函数当作实参传递 transferHello('world', function (name: string) { return `hello, ${name}`; }); 复制代码 通过以上示例可以看出，函数继承至对象并拥有对象的特性。在 JavaScript 中可以对函数进行参数传递、变量赋值或数组操作等等，因此把函数称为一等公民。函数式编程的核心就是对函数进行组合或传递，JavaScript 中函数这种灵活的特性是满足函数式编程的重要条件。\n纯函数\n纯函数是是指在相同的参数调用下，函数的返回值唯一不变。这跟数学中函数的映射关系类似，同样的 x 不可能映射多个不同的 y。使用函数式编程会使得函数的调用非常稳定，从而降低 Bug 产生的机率。当然要实现纯函数的这种特性，需要函数不能包含以下一些副作用：\n操作 Http 请求 可变数据（包括在函数内部改变输入参数） DOM 操作 打印日志 访问系统状态 操作文件系统 操作数据库 … 从以上常见的一些副作用可以看出，纯函数的实现需要遵循最小意外原则，为了确保函数的稳定唯一的输入和输出，尽量应该避免与函数外部的环境进行任何交互行为，从而防止外部环境对函数内部产生无法预料的影响。纯函数的实现应该自给自足，举几个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 如果使用 const 声明 min 变量（基本数据类型），则可以保证以下函数的纯粹性 let min: number = 1; // 非纯函数 // 依赖外部环境变量 min，一旦 min 发生变化则输入和返回不唯一 function isEqual(num: number): boolean { return num === min; } // 纯函数 function isEqual(num: number): boolean { return num === 1; } // 非纯函数 function request(url: string, params: T): Promise { // 会产生请求成功和请求失败两种结果，返回的结果可能不唯一 return $.getJson(url, params); } // 纯函数 function request(url: string, params: T) : () =\u003e Promise { return function() { return $.getJson(url, params); } } 复制代码 纯函数的特性使得函数式编程具备以下特性：\n可缓存性（Cacheable） 可移植性（Portable） 可测试性（Testable） 可缓存性和可测试性基于纯函数输入输出唯一不变的特性，可移植性则主要基于纯函数不依赖外部环境的特性。这里举一个可缓存的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 interface ICache { [arg: string]: T; } interface ISquare { (x: T): T; } // 简单的缓存函数（忽略通用性和健壮性） function memoize(fn: ISquare): ISquare { const cache: ICache = {}; return function (x: T) { const arg: string = JSON.stringify(x); cache[arg] = cache[arg] || fn.call(fn, x); return cache[arg]; }; } // 纯函数 function square(x: number): number { return x * x; } const memoSquare = memoize(square); memoSquare(4); // 不会再次调用纯函数 square，而是直接从缓存中获取值 // 由于输入和输出的唯一性，获取缓存结果可靠稳定 // 提升代码的运行效率 memoSquare(4); 复制代码 无状态和数据不可变\n在函数式编程的简单示例中已经可以清晰的感受到函数式编程绝对不能依赖内部状态，而在纯函数中则说明了函数式编程不能依赖外部的环境或状态，因为一旦依赖的状态变化，不能保证函数根据对应关系所计算的返回值因为状态的变化仍然保持不变。\n这里单独讲解一下数据不可变，在 JavaScript 中有很多数组操作的方法，举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 const arr = [1, 2, 3]; console.log(arr.slice(0, 2)); // [1, 2] console.log(arr); // [1, 2, 3] console.log(arr.slice(0, 2)); // [1, 2] console.log(arr); // [1, 2, 3] console.log(arr.splice(0, 1)); // [1] console.log(arr); // [2, 3] console.log(arr.splice(0, 1)); // [2] console.log(arr); // [3] 复制代码 这里的 slice 方法多次调用都不会改变原有数组，且会产生相同的输出。而 splice 每次调用都在修改原数组，且产生的输出也不相同。在函数式编程中，这种会改变原有数据的函数已经不再是纯函数，应该尽量避免使用。\n阅读链接：如果想要了解更深入的函数式编程知识点，可以额外阅读函数式编程指北****[8]。\n21、响应式编程的使用场景有哪些？ 响应式编程是一种基于观察者（发布 / 订阅）模式并且面向异步（Asynchronous）数据流（Data Stream）和变化传播的声明式编程范式。响应式编程主要适用的场景包含：\n用户和系统发起的连续事件处理，例如鼠标的点击、键盘的按键或者通信设备发起的信号等 非可靠的网络或者通信处理（例如 HTTP 网络的请求重试） 连续的异步 IO 处理 复杂的继发事务处理（例如一次事件涉及到多个继发的网络请求） 高并发的消息处理（例如 IM 聊天） … 语法 22、如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应? 23、如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip? 24、如何让 CSS 元素左侧自动溢出（… 溢出在左侧）？ The direction CSS property sets the direction of text, table columns, and horizontal overflow. Use rtl for languages written from right to left (like Hebrew or Arabic), and ltr for those written from left to right (like English and most other languages).\n具体查看：developer.mozilla.org/en-US/docs/…****[9]\n25、什么是沙箱？浏览器的沙箱有什么作用？ 26、如何处理浏览器中表单项的密码自动填充问题？ 27、Hash 和 History 路由的区别和优缺点？ 28、JavaScript 中对象的属性描述符有哪些？分别有什么作用？ 29、JavaScript 中 console 有哪些 api ? The console object provides access to the browser’s debugging console (e.g. the Web console**[10]** in Firefox). The specifics of how it works varies from browser to browser, but there is a de facto set of features that are typically provided.\n这里列出一些我常用的 API:\nconsole.log console.error console.time console.timeEnd console.group 具体查看：developer.mozilla.org/en-US/docs/…****[11]\n30、 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？ 在 JavaScript 中利用事件循环机制****[12]（Event Loop）可以在单线程中实现非阻塞式、异步的操作。例如\nNode.js 中的 Callback、EventEmitter**[13]、Stream**[14] ES6 中的 Promise**[15]、Generator**[16] ES2017 中的 Async**[17]** 三方库 RxJS、Q**[18]** 、Co、****[19]Bluebird[20] 我们重点来看一下常用的几种编程方式（Callback、Promise、Generator、Async）在语法糖上带来的优劣对比。\nCallback\nCallback（回调函数）是在 Web 前端开发中经常会使用的编程方式。这里举一个常用的定时器示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 export interface IObj { value: string; deferExec(): void; deferExecAnonymous(): void; console(): void; } export const obj: IObj = { value: 'hello', deferExecBind() { // 使用箭头函数可达到一样的效果 setTimeout(this.console.bind(this), 1000); }, deferExec() { setTimeout(this.console, 1000); }, console() { console.log(this.value); }, }; obj.deferExecBind(); // hello obj.deferExec(); // undefined 复制代码 回调函数经常会因为调用环境的变化而导致 this 的指向性变化。除此之外，使用回调函数来处理多个继发的异步任务时容易导致回调地狱（Callback Hell）:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 fs.readFile(fileA, 'utf-8', function (err, data) { fs.readFile(fileB, 'utf-8', function (err, data) { fs.readFile(fileC, 'utf-8', function (err, data) { fs.readFile(fileD, 'utf-8', function (err, data) { // 假设在业务中 fileD 的读写依次依赖 fileA、fileB 和 fileC // 或者经常也可以在业务中看到多个 HTTP 请求的操作有前后依赖（继发 HTTP 请求） // 这些异步任务之间纵向嵌套强耦合，无法进行横向复用 // 如果某个异步发生变化，那它的所有上层或下层回调可能都需要跟着变化（比如 fileA 和 fileB 的依赖关系倒置） // 因此称这种现象为 回调地狱 // .... }); }); }); }); 复制代码 回调函数不能通过 return 返回数据，比如我们希望调用带有回调参数的函数并返回异步执行的结果时，只能通过再次回调的方式进行参数传递：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 希望延迟 3s 后执行并拿到结果 function getAsyncResult(result: number) { setTimeout(() =\u003e { return result * 3; }, 1000); } // 尽管这是常规的编程思维方式 const result = getAsyncResult(3000); // 但是打印 undefined console.log('result: ', result); function getAsyncResultWithCb(result: number, cb: (result: number) =\u003e void) { setTimeout(() =\u003e { cb(result * 3); }, 1000); } // 通过回调的形式获取结果 getAsyncResultWithCb(3000, (result) =\u003e { console.log('result: ', result); // 9000 }); 复制代码 对于 JavaScript 中标准的异步 API 可能无法通过在外部进行 try...catch... 的方式进行错误捕获：\n1 2 3 4 5 6 7 8 9 10 11 12 13 try { setTimeout(() =\u003e { // 下述是异常代码 // 你可以在回调函数的内部进行 try...catch... console.log(a.b.c) }, 1000) } catch(err) { // 这里不会执行 // 进程会被终止 console.error(err) } 复制代码 上述示例讲述的都是 JavaScript 中标准的异步 API ，如果使用一些三方的异步 API 并且提供了回调能力时，这些 API 可能是非受信的，在真正使用的时候会因为执行反转（回调函数的执行权在三方库中）导致以下一些问题：\n使用者的回调函数设计没有进行错误捕获，而恰恰三方库进行了错误捕获却没有抛出错误处理信息，此时使用者很难感知到自己设计的回调函数是否有错误 使用者难以感知到三方库的回调时机和回调次数，这个回调函数执行的权利控制在三方库手中 使用者无法更改三方库提供的回调参数，回调参数可能无法满足使用者的诉求 … 举个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 interface ILib { params: T; emit(params: T): void; on(callback: (params: T) =\u003e void): void; } // 假设以下是一个三方库，并发布成了npm 包 export const lib: ILib = { params: '', emit(params) { this.params = params; }, on(callback) { try { // callback 回调执行权在 lib 上 // lib 库可以决定回调执行多次 callback(this.params); callback(this.params); callback(this.params); // lib 库甚至可以决定回调延迟执行 // 异步执行回调函数 setTimeout(() =\u003e { callback(this.params); }, 3000); } catch (err) { // 假设 lib 库的捕获没有抛出任何异常信息 } }, }; // 开发者引入 lib 库开始使用 lib.emit('hello'); lib.on((value) =\u003e { // 使用者希望 on 里的回调只执行一次 // 这里的回调函数的执行时机是由三方库 lib 决定 // 实际上打印四次，并且其中一次是异步执行 console.log(value); }); lib.on((value) =\u003e { // 下述是异常代码 // 但是执行下述代码不会抛出任何异常信息 // 开发者无法感知自己的代码设计错误 console.log(value.a.b.c) }); 复制代码 Promise\nCallback 的异步操作形式除了会造成回调地狱，还会造成难以测试的问题。ES6 中的 Promise （基于 Promise A +****[21] 规范的异步编程解决方案）利用**有限状态机****[22]**的原理来解决异步的处理问题，Promise 对象提供了统一的异步编程 API，它的特点如下：\nPromise 对象的执行状态不受外界影响。Promise 对象的异步操作有三种状态： pending（进行中）、 fulfilled（已成功）和 rejected（已失败） ，只有 Promise 对象本身的异步操作结果可以决定当前的执行状态，任何其他的操作无法改变状态的结果 Promise 对象的执行状态不可变。Promise 的状态只有两种变化可能：从 pending（进行中）变为 fulfilled（已成功）或从 pending（进行中）变为 rejected（已失败） 温馨提示：有限状态机提供了一种优雅的解决方式，异步的处理本身可以通过异步状态的变化来触发相应的操作，这会比回调函数在逻辑上的处理更加合理，也可以降低代码的复杂度。\nPromise 对象的执行状态不可变示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const promise = new Promise((resolve, reject) =\u003e { // 状态变更为 fulfilled 并返回结果 1 后不会再变更状态 resolve(1); // 不会变更状态 reject(4); }); promise .then((result) =\u003e { // 在 ES 6 中 Promise 的 then 回调执行是异步执行（微任务） // 在当前 then 被调用的那轮事件循环（Event Loop）的末尾执行 console.log('result: ', result); }) .catch((error) =\u003e { // 不执行 console.error('error: ', error); }); 复制代码 假设要实现两个继发的 HTTP 请求，第一个请求接口返回的数据是第二个请求接口的参数，使用回调函数的实现方式如下所示（这里使用 setTimeout 来指代异步请求）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 回调地狱 const doubble = (result: number, callback: (finallResult: number) =\u003e void) =\u003e { // Mock 第一个异步请求 setTimeout(() =\u003e { // Mock 第二个异步请求（假设第二个请求的参数依赖第一个请求的返回结果） setTimeout(() =\u003e { callback(result * 2); }, 2000); }, 1000); }; doubble(1000, (result) =\u003e { console.log('result: ', result); }); 复制代码 温馨提示：继发请求的依赖关系非常常见，例如人员基本信息管理系统的开发中，经常需要先展示组织树结构，并默认加载第一个组织下的人员列表信息。\n如果采用 Promise 的处理方式则可以规避上述常见的回调地狱问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const firstPromise = (result: number): Promise =\u003e { return new Promise((resolve, reject) =\u003e { // Mock 异步请求 // 将 resolve 改成 reject 会被 catch 捕获 setTimeout(() =\u003e resolve(result), 1000); }); }; const nextPromise = (result: number): Promise =\u003e { return new Promise((resolve, reject) =\u003e { // Mock 异步请求 // 将 resolve 改成 reject 会被 catch 捕获 setTimeout(() =\u003e resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u003e { return nextPromise(result); }) .then((result) =\u003e { // 2s 后打印 2000 console.log('result: ', result); }) // 任何一个 Promise 到达 rejected 状态都能被 catch 捕获 .catch((err) =\u003e { console.error('err: ', err); }); 复制代码 Promise 的错误回调可以同时捕获 firstPromise 和 nextPromise 两个函数的 rejected 状态。接下来考虑以下调用场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 const firstPromise = (result: number): Promise =\u003e { return new Promise((resolve, reject) =\u003e { // Mock 异步请求 setTimeout(() =\u003e resolve(result), 1000); }); }; const nextPromise = (result: number): Promise =\u003e { return new Promise((resolve, reject) =\u003e { // Mock 异步请求 setTimeout(() =\u003e resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u003e { nextPromise(result).then((result) =\u003e { // 后打印 console.log('nextPromise result: ', result); }); }) .then((result) =\u003e { // 先打印 // 由于上一个 then 没有返回值，这里打印 undefined console.log('firstPromise result: ', result); }) .catch((err) =\u003e { console.error('err: ', err); }); 复制代码 首先 Promise 可以注册多个 then（放在一个执行队列里），并且这些 then 会根据上一次返回值的结果依次执行。除此之外，各个 Promise 的 then 执行互不干扰。我们将示例进行简单的变换：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const firstPromise = (result: number): Promise =\u003e { return new Promise((resolve, reject) =\u003e { // Mock 异步请求 setTimeout(() =\u003e resolve(result), 1000); }); }; const nextPromise = (result: number): Promise =\u003e { return new Promise((resolve, reject) =\u003e { // Mock 异步请求 setTimeout(() =\u003e resolve(result * 2), 1000); }); }; firstPromise(1000) .then((result) =\u003e { // 返回了 nextPromise 的 then 执行后的结果 return nextPromise(result).then((result) =\u003e { return result; }); }) // 接着 nextPromise 的 then 执行的返回结果继续执行 .then((result) =\u003e { // 2s 后打印 2000 console.log('nextPromise result: ', result); }) .catch((err) =\u003e { console.error('err: ', err); }); 复制代码 上述例子中的执行结果是因为 then 的执行会返回一个新的 Promise 对象，并且如果 then 执行后返回的仍然是 Promise 对象，那么下一个 then 的链式调用会等待该 Promise 对象的状态发生变化后才会调用（能得到这个 Promise 处理的结果）。接下来重点看下 Promise 的错误处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 const promise = new Promise((resolve, reject) =\u003e { // 下述是异常代码 console.log(a.b.c); resolve('hello'); }); promise .then((result) =\u003e { console.log('result: ', result); }) // 去掉 catch 仍然会抛出错误，但不会退出进程终止脚本执行 .catch((err) =\u003e { // 执行 // ReferenceError: a is not defined console.error(err); }); setTimeout(() =\u003e { // 继续执行 console.log('hello world!'); }, 2000); 复制代码 从上述示例可以看出 Promise 的错误不会影响其他代码的执行，只会影响 Promise 内部的代码本身，因为Promise 会在内部对错误进行异常捕获，从而保证整体代码执行的稳定性。Promise 还提供了其他的一些 API 方便多任务的执行，包括\nPromise.all：适合多个异步任务并发执行但不允许其中任何一个任务失败 Promise.race ：适合多个异步任务抢占式执行 Promise.allSettled ：适合多个异步任务并发执行但允许某些任务失败 Promise 相对于 Callback 对于异步的处理更加优雅，并且能力也更加强大， 但是也存在一些自身的缺点：\n无法取消 Promise 的执行 无法在 Promise 外部通过 try...catch... 的形式进行错误捕获（Promise 内部捕获了错误） 状态单一，每次决断只能产生一种状态结果，需要不停的进行链式调用 温馨提示：手写 Promise 是面试官非常喜欢的一道笔试题，本质是希望面试者能够通过底层的设计正确了解 Promise 的使用方式，如果你对 Promise 的设计原理不熟悉，可以深入了解一下或者手动设计一个。\nGenerator\nPromise 解决了 Callback 的回调地狱问题，但也造成了代码冗余，如果一些异步任务不支持 Promise 语法，就需要进行一层 Promise 封装。Generator 将 JavaScript 的异步编程带入了一个全新的阶段，它使得异步代码的设计和执行看起来和同步代码一致。Generator 使用的简单示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const firstPromise = (result: number): Promise =\u003e { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e resolve(result * 2), 1000); }); }; const nextPromise = (result: number): Promise =\u003e { return new Promise((resolve, reject) =\u003e { setTimeout(() =\u003e resolve(result * 3), 1000); }); }; // 在 Generator 函数里执行的异步代码看起来和同步代码一致 function* gen(result: number): Generator","wordCount":"19749","inLanguage":"en","datePublished":"2020-04-01T17:11:35+08:00","dateModified":"2020-04-01T17:11:35+08:00","author":{"@type":"Person","name":"Lvsj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E9%92%89%E9%92%89%E9%9D%A2%E8%AF%95/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>钉钉面试</h1><div class=post-meta><span title='2020-04-01 17:11:35 +0800 +0800'>2020/04/01</span>&nbsp;·&nbsp;40 min&nbsp;·&nbsp;Lvsj<ul class=post-tags-meta><a href=https://bablvsj.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/>面试题集</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><ul><li><a href=#%e5%9f%ba%e7%a1%80 aria-label=基础>基础</a><ul><li><a href=#1%e5%88%97%e4%b8%be%e4%bd%a0%e6%89%80%e4%ba%86%e8%a7%a3%e7%9a%84%e8%ae%a1%e7%ae%97%e6%9c%ba%e5%ad%98%e5%82%a8%e8%ae%be%e5%a4%87%e7%b1%bb%e5%9e%8b aria-label=1、列举你所了解的计算机存储设备类型？>1、列举你所了解的计算机存储设备类型？</a></li><li><a href=#2%e4%b8%80%e8%88%ac%e4%bb%a3%e7%a0%81%e5%ad%98%e5%82%a8%e5%9c%a8%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%9a%84%e5%93%aa%e4%b8%aa%e8%ae%be%e5%a4%87%e4%b8%ad%e4%bb%a3%e7%a0%81%e5%9c%a8-cpu-%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%90%e8%a1%8c%e7%9a%84 aria-label="2、一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？">2、一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？</a></li><li><a href=#3%e4%bb%80%e4%b9%88%e6%98%af%e6%8c%87%e4%bb%a4%e5%92%8c%e6%8c%87%e4%bb%a4%e9%9b%86 aria-label=3、什么是指令和指令集？>3、什么是指令和指令集？</a></li><li><a href=#4%e5%a4%8d%e6%9d%82%e6%8c%87%e4%bb%a4%e9%9b%86%e5%92%8c%e7%b2%be%e7%ae%80%e6%8c%87%e4%bb%a4%e9%9b%86%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label=4、复杂指令集和精简指令集有什么区别？>4、复杂指令集和精简指令集有什么区别？</a></li><li><a href=#5javascript-%e6%98%af%e5%a6%82%e4%bd%95%e8%bf%90%e8%a1%8c%e7%9a%84%e8%a7%a3%e9%87%8a%e5%9e%8b%e8%af%ad%e8%a8%80%e5%92%8c%e7%bc%96%e8%af%91%e5%9e%8b%e8%af%ad%e8%a8%80%e7%9a%84%e5%b7%ae%e5%bc%82%e6%98%af%e4%bb%80%e4%b9%88 aria-label="5、JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？">5、JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？</a></li><li><a href=#6%e7%ae%80%e5%8d%95%e6%8f%8f%e8%bf%b0%e4%b8%80%e4%b8%8b-babel-%e7%9a%84%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b aria-label="6、简单描述一下 Babel 的编译过程？">6、简单描述一下 Babel 的编译过程？</a></li><li><a href=#7javascript-%e4%b8%ad%e7%9a%84%e6%95%b0%e7%bb%84%e5%92%8c%e5%87%bd%e6%95%b0%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8%e7%9a%84 aria-label="7、JavaScript 中的数组和函数在内存中是如何存储的？">7、JavaScript 中的数组和函数在内存中是如何存储的？</a></li><li><a href=#8%e6%b5%8f%e8%a7%88%e5%99%a8%e5%92%8c-nodejs-%e4%b8%ad%e7%9a%84%e4%ba%8b%e4%bb%b6%e5%be%aa%e7%8e%af%e6%9c%ba%e5%88%b6%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="8、浏览器和 Node.js 中的事件循环机制有什么区别？">8、浏览器和 Node.js 中的事件循环机制有什么区别？</a></li><li><a href=#9es6-modules-%e7%9b%b8%e5%af%b9%e4%ba%8e-commonjs-%e7%9a%84%e4%bc%98%e5%8a%bf%e6%98%af%e4%bb%80%e4%b9%88 aria-label="9、ES6 Modules 相对于 CommonJS 的优势是什么？">9、ES6 Modules 相对于 CommonJS 的优势是什么？</a></li><li><a href=#10%e9%ab%98%e7%ba%a7%e7%a8%8b%e5%ba%8f%e8%ae%be%e8%ae%a1%e8%af%ad%e8%a8%80%e6%98%af%e5%a6%82%e4%bd%95%e7%bc%96%e8%af%91%e6%88%90%e6%9c%ba%e5%99%a8%e8%af%ad%e8%a8%80%e7%9a%84 aria-label=10、高级程序设计语言是如何编译成机器语言的？>10、高级程序设计语言是如何编译成机器语言的？</a></li><li><a href=#11%e7%bc%96%e8%af%91%e5%99%a8%e4%b8%80%e8%88%ac%e7%94%b1%e5%93%aa%e5%87%a0%e4%b8%aa%e9%98%b6%e6%ae%b5%e7%bb%84%e6%88%90%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5%e4%b8%80%e8%88%ac%e5%9c%a8%e4%bb%80%e4%b9%88%e9%98%b6%e6%ae%b5%e8%bf%9b%e8%a1%8c aria-label=11、编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？>11、编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？</a></li><li><a href=#12%e7%bc%96%e8%af%91%e8%bf%87%e7%a8%8b%e4%b8%ad%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88 aria-label=12、编译过程中虚拟机的作用是什么？>12、编译过程中虚拟机的作用是什么？</a></li><li><a href=#13%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%ad%e9%97%b4%e4%bb%a3%e7%a0%81ir%e5%ae%83%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88 aria-label=13、什么是中间代码（IR），它的作用是什么？>13、什么是中间代码（IR），它的作用是什么？</a></li><li><a href=#14%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%a4%e5%8f%89%e7%bc%96%e8%af%91 aria-label=14、什么是交叉编译？>14、什么是交叉编译？</a></li><li><a href=#15%e5%8f%91%e5%b8%83--%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f%e5%92%8c%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88 aria-label="15、发布 / 订阅模式和观察者模式的区别是什么？">15、发布 / 订阅模式和观察者模式的区别是什么？</a></li><li><a href=#16%e8%a3%85%e9%a5%b0%e5%99%a8%e6%a8%a1%e5%bc%8f%e4%b8%80%e8%88%ac%e4%bc%9a%e5%9c%a8%e4%bb%80%e4%b9%88%e5%9c%ba%e5%90%88%e4%bd%bf%e7%94%a8 aria-label=16、装饰器模式一般会在什么场合使用？>16、装饰器模式一般会在什么场合使用？</a></li><li><a href=#17%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9%e5%a4%a7%e5%9e%8b%e9%a1%b9%e7%9b%ae%e7%9a%84%e4%bb%a3%e7%a0%81%e8%a7%a3%e8%80%a6%e8%ae%be%e8%ae%a1%e7%90%86%e8%a7%a3%e4%bb%80%e4%b9%88%e6%98%af-ioc%e4%b8%80%e8%88%ac-di-%e9%87%87%e7%94%a8%e4%bb%80%e4%b9%88%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e5%ae%9e%e7%8e%b0 aria-label="17、谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？">17、谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？</a></li><li><a href=#18%e5%88%97%e4%b8%be%e4%bd%a0%e6%89%80%e4%ba%86%e8%a7%a3%e7%9a%84%e7%bc%96%e7%a8%8b%e8%8c%83%e5%bc%8f aria-label=18、列举你所了解的编程范式？>18、列举你所了解的编程范式？</a></li><li><a href=#19%e4%bb%80%e4%b9%88%e6%98%af%e9%9d%a2%e5%90%91%e5%88%87%e9%9d%a2aop%e7%9a%84%e7%bc%96%e7%a8%8b aria-label=19、什么是面向切面（AOP）的编程？>19、什么是面向切面（AOP）的编程？</a></li><li><a href=#20%e4%bb%80%e4%b9%88%e6%98%af%e5%87%bd%e6%95%b0%e5%bc%8f%e7%bc%96%e7%a8%8b aria-label=20、什么是函数式编程？>20、什么是函数式编程？</a></li><li><a href=#21%e5%93%8d%e5%ba%94%e5%bc%8f%e7%bc%96%e7%a8%8b%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e6%9c%89%e5%93%aa%e4%ba%9b aria-label=21、响应式编程的使用场景有哪些？>21、响应式编程的使用场景有哪些？</a></li></ul></li><li><a href=#%e8%af%ad%e6%b3%95 aria-label=语法>语法</a><ul><li><a href=#22%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e4%b8%8a%e4%b8%ad%e4%b8%8b%e4%b8%89%e8%a1%8c%e5%b8%83%e5%b1%80%e9%a1%b6%e9%83%a8%e5%92%8c%e5%ba%95%e9%83%a8%e6%9c%80%e5%b0%8f%e9%ab%98%e5%ba%a6%e6%98%af-100px%e4%b8%ad%e9%97%b4%e8%87%aa%e9%80%82%e5%ba%94 aria-label="22、如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应?">22、如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应?</a></li><li><a href=#23%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e5%85%83%e7%b4%a0-css-%e6%a0%b7%e5%bc%8f%e6%ba%a2%e5%87%ba%e4%bb%8e%e8%80%8c%e5%8f%af%e4%bb%a5%e9%80%89%e6%8b%a9%e6%80%a7%e7%9a%84%e5%8a%a0-title-%e6%88%96%e8%80%85-tooltip aria-label="23、如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip?">23、如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip?</a></li><li><a href=#24%e5%a6%82%e4%bd%95%e8%ae%a9-css-%e5%85%83%e7%b4%a0%e5%b7%a6%e4%be%a7%e8%87%aa%e5%8a%a8%e6%ba%a2%e5%87%ba-%e6%ba%a2%e5%87%ba%e5%9c%a8%e5%b7%a6%e4%be%a7 aria-label="24、如何让 CSS 元素左侧自动溢出（&amp;hellip; 溢出在左侧）？">24、如何让 CSS 元素左侧自动溢出（&mldr; 溢出在左侧）？</a></li><li><a href=#25%e4%bb%80%e4%b9%88%e6%98%af%e6%b2%99%e7%ae%b1%e6%b5%8f%e8%a7%88%e5%99%a8%e7%9a%84%e6%b2%99%e7%ae%b1%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8 aria-label=25、什么是沙箱？浏览器的沙箱有什么作用？>25、什么是沙箱？浏览器的沙箱有什么作用？</a></li><li><a href=#26%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%ad%e8%a1%a8%e5%8d%95%e9%a1%b9%e7%9a%84%e5%af%86%e7%a0%81%e8%87%aa%e5%8a%a8%e5%a1%ab%e5%85%85%e9%97%ae%e9%a2%98 aria-label=26、如何处理浏览器中表单项的密码自动填充问题？>26、如何处理浏览器中表单项的密码自动填充问题？</a></li><li><a href=#27hash-%e5%92%8c-history-%e8%b7%af%e7%94%b1%e7%9a%84%e5%8c%ba%e5%88%ab%e5%92%8c%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label="27、Hash 和 History 路由的区别和优缺点？">27、Hash 和 History 路由的区别和优缺点？</a></li><li><a href=#28javascript-%e4%b8%ad%e5%af%b9%e8%b1%a1%e7%9a%84%e5%b1%9e%e6%80%a7%e6%8f%8f%e8%bf%b0%e7%ac%a6%e6%9c%89%e5%93%aa%e4%ba%9b%e5%88%86%e5%88%ab%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8 aria-label="28、JavaScript 中对象的属性描述符有哪些？分别有什么作用？">28、JavaScript 中对象的属性描述符有哪些？分别有什么作用？</a></li><li><a href=#29javascript-%e4%b8%ad-console-%e6%9c%89%e5%93%aa%e4%ba%9b-api- aria-label="29、JavaScript 中 console 有哪些 api ?">29、JavaScript 中 console 有哪些 api ?</a></li><li><a href=#30-%e7%ae%80%e5%8d%95%e5%af%b9%e6%af%94%e4%b8%80%e4%b8%8b-callbackpromisegeneratorasync-%e5%87%a0%e4%b8%aa%e5%bc%82%e6%ad%a5-api-%e7%9a%84%e4%bc%98%e5%8a%a3 aria-label="30、 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？">30、 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？</a></li><li><a href=#31-objectdefineproperty-%e6%9c%89%e5%93%aa%e5%87%a0%e4%b8%aa%e5%8f%82%e6%95%b0%e5%90%84%e8%87%aa%e9%83%bd%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8 aria-label="31、 Object.defineProperty 有哪几个参数？各自都有什么作用？">31、 Object.defineProperty 有哪几个参数？各自都有什么作用？</a></li><li><a href=#32-objectdefineproperty-%e5%92%8c-es6-%e7%9a%84-proxy-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="32、 Object.defineProperty 和 ES6 的 Proxy 有什么区别？">32、 Object.defineProperty 和 ES6 的 Proxy 有什么区别？</a></li><li><a href=#33-es6-%e4%b8%ad-symbolmapdecorator-%e7%9a%84%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e6%9c%89%e5%93%aa%e4%ba%9b%e6%88%96%e8%80%85%e4%bd%a0%e5%9c%a8%e5%93%aa%e4%ba%9b%e5%ba%93%e7%9a%84%e6%ba%90%e7%a0%81%e9%87%8c%e8%a7%81%e8%bf%87%e8%bf%99%e4%ba%9b-api-%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label="33、 ES6 中 Symbol、Map、Decorator 的使用场景有哪些？或者你在哪些库的源码里见过这些 API 的使用？">33、 ES6 中 Symbol、Map、Decorator 的使用场景有哪些？或者你在哪些库的源码里见过这些 API 的使用？</a></li><li><a href=#34-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8-typescript--typescript-%e7%9b%b8%e5%af%b9%e4%ba%8e-javascript-%e7%9a%84%e4%bc%98%e5%8a%bf%e6%98%af%e4%bb%80%e4%b9%88 aria-label="34、 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？">34、 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？</a></li><li><a href=#35-typescript-%e4%b8%ad-const-%e5%92%8c-readonly-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%9e%9a%e4%b8%be%e5%92%8c%e5%b8%b8%e9%87%8f%e6%9e%9a%e4%b8%be%e7%9a%84%e5%8c%ba%e5%88%ab%e6%8e%a5%e5%8f%a3%e5%92%8c%e7%b1%bb%e5%9e%8b%e5%88%ab%e5%90%8d%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="35、 TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？">35、 TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？</a></li><li><a href=#36-typescript-%e4%b8%ad-any-%e7%b1%bb%e5%9e%8b%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88 aria-label="36、 TypeScript 中 any 类型的作用是什么？">36、 TypeScript 中 any 类型的作用是什么？</a></li><li><a href=#37-typescript-%e4%b8%ad-anyneverunknown-%e5%92%8c-void-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="37、 TypeScript 中 any、never、unknown 和 void 有什么区别？">37、 TypeScript 中 any、never、unknown 和 void 有什么区别？</a></li><li><a href=#38-typescript-%e4%b8%ad-interface-%e5%8f%af%e4%bb%a5%e7%bb%99-function--array--classindexable%e5%81%9a%e5%a3%b0%e6%98%8e%e5%90%97 aria-label="38、 TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？">38、 TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？</a></li><li><a href=#39-typescript-%e4%b8%ad%e5%8f%af%e4%bb%a5%e4%bd%bf%e7%94%a8-stringnumberbooleansymbolobject-%e7%ad%89%e7%bb%99%e7%b1%bb%e5%9e%8b%e5%81%9a%e5%a3%b0%e6%98%8e%e5%90%97 aria-label="39、 TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？">39、 TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？</a></li><li><a href=#40-typescript-%e4%b8%ad%e7%9a%84-this-%e5%92%8c-javascript-%e4%b8%ad%e7%9a%84-this-%e6%9c%89%e4%bb%80%e4%b9%88%e5%b7%ae%e5%bc%82 aria-label="40、 TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？">40、 TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？</a></li><li><a href=#41-typescript-%e4%b8%ad%e4%bd%bf%e7%94%a8-unions-%e6%97%b6%e6%9c%89%e5%93%aa%e4%ba%9b%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9 aria-label="41、 TypeScript 中使用 Unions 时有哪些注意事项？">41、 TypeScript 中使用 Unions 时有哪些注意事项？</a></li><li><a href=#42-typescript-%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1-class-%e7%9a%84%e5%a3%b0%e6%98%8e aria-label="42、 TypeScript 如何设计 Class 的声明？">42、 TypeScript 如何设计 Class 的声明？</a></li><li><a href=#43-typescript-%e4%b8%ad%e5%a6%82%e4%bd%95%e8%81%94%e5%90%88%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b%e7%9a%84-key aria-label="43、 TypeScript 中如何联合枚举类型的 Key?">43、 TypeScript 中如何联合枚举类型的 Key?</a></li><li><a href=#44-typescript-%e4%b8%ad-_-%e7%ad%89%e7%ac%a6%e5%8f%b7%e7%9a%84%e5%90%ab%e4%b9%89 aria-label="44、 TypeScript 中 ?.、??、!.、_、** 等符号的含义？">44、 TypeScript 中 ?.、??、!.、_、** 等符号的含义？</a></li><li><a href=#45-typescript-%e4%b8%ad%e9%a2%84%e5%ae%9a%e4%b9%89%e7%9a%84%e6%9c%89%e6%9d%a1%e4%bb%b6%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b aria-label="45、 TypeScript 中预定义的有条件类型有哪些？">45、 TypeScript 中预定义的有条件类型有哪些？</a></li><li><a href=#46-%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-typescript-%e6%a8%a1%e5%9d%97%e7%9a%84%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6 aria-label="46、 简单介绍一下 TypeScript 模块的加载机制？">46、 简单介绍一下 TypeScript 模块的加载机制？</a></li><li><a href=#47-%e7%ae%80%e5%8d%95%e8%81%8a%e8%81%8a%e4%bd%a0%e5%af%b9-typescript-%e7%b1%bb%e5%9e%8b%e5%85%bc%e5%ae%b9%e6%80%a7%e7%9a%84%e7%90%86%e8%a7%a3%e6%8a%97%e5%8f%98%e5%8f%8c%e5%8f%98%e5%8d%8f%e5%8f%98%e5%92%8c%e9%80%86%e5%8f%98%e7%9a%84%e7%ae%80%e5%8d%95%e7%90%86%e8%a7%a3 aria-label="47、 简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？">47、 简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？</a></li><li><a href=#48-typescript-%e4%b8%ad%e5%af%b9%e8%b1%a1%e5%b1%95%e5%bc%80%e4%bc%9a%e6%9c%89%e4%bb%80%e4%b9%88%e5%89%af%e4%bd%9c%e7%94%a8%e5%90%97 aria-label="48、 TypeScript 中对象展开会有什么副作用吗？">48、 TypeScript 中对象展开会有什么副作用吗？</a></li><li><a href=#49-typescript-%e4%b8%ad-interfacetypeenum-%e5%a3%b0%e6%98%8e%e6%9c%89%e4%bd%9c%e7%94%a8%e5%9f%9f%e7%9a%84%e5%8a%9f%e8%83%bd%e5%90%97 aria-label="49、 TypeScript 中 interface、type、enum 声明有作用域的功能吗？">49、 TypeScript 中 interface、type、enum 声明有作用域的功能吗？</a></li><li><a href=#50-typescript-%e4%b8%ad%e5%90%8c%e5%90%8d%e7%9a%84-interface-%e6%88%96%e8%80%85%e5%90%8c%e5%90%8d%e7%9a%84-interface-%e5%92%8c-class-%e5%8f%af%e4%bb%a5%e5%90%88%e5%b9%b6%e5%90%97 aria-label="50、 TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？">50、 TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？</a></li><li><a href=#51-%e5%a6%82%e4%bd%95%e4%bd%bf-typescript-%e9%a1%b9%e7%9b%ae%e5%bc%95%e5%85%a5%e5%b9%b6%e8%af%86%e5%88%ab%e7%bc%96%e8%af%91%e4%b8%ba-javascript-%e7%9a%84-npm-%e5%ba%93%e5%8c%85 aria-label="51、 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？">51、 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？</a></li><li><a href=#52-typescript-%e7%9a%84-tsconfigjson-%e4%b8%ad%e6%9c%89%e5%93%aa%e4%ba%9b%e9%85%8d%e7%bd%ae%e9%a1%b9%e4%bf%a1%e6%81%af aria-label="52、 TypeScript 的 tsconfig.json 中有哪些配置项信息？">52、 TypeScript 的 tsconfig.json 中有哪些配置项信息？</a></li><li><a href=#53-typescript-%e4%b8%ad%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae%e6%a8%a1%e5%9d%97%e5%af%bc%e5%85%a5%e7%9a%84%e8%b7%af%e5%be%84%e5%88%ab%e5%90%8d aria-label="53、 TypeScript 中如何设置模块导入的路径别名？">53、 TypeScript 中如何设置模块导入的路径别名？</a></li></ul></li><li><a href=#%e6%a1%86%e6%9e%b6 aria-label=框架>框架</a><ul><li><a href=#54-react-class-%e7%bb%84%e4%bb%b6%e6%9c%89%e5%93%aa%e4%ba%9b%e5%91%a8%e6%9c%9f%e5%87%bd%e6%95%b0%e5%88%86%e5%88%ab%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8 aria-label="54、 React Class 组件有哪些周期函数？分别有什么作用？">54、 React Class 组件有哪些周期函数？分别有什么作用？</a></li><li><a href=#55-react-class-%e7%bb%84%e4%bb%b6%e4%b8%ad%e8%af%b7%e6%b1%82%e5%8f%af%e4%bb%a5%e5%9c%a8-componentwillmount-%e4%b8%ad%e5%8f%91%e8%b5%b7%e5%90%97%e4%b8%ba%e4%bb%80%e4%b9%88 aria-label="55、 React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？">55、 React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？</a></li><li><a href=#56-react-class-%e7%bb%84%e4%bb%b6%e5%92%8c-react-hook-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%9c%89%e5%93%aa%e4%ba%9b aria-label="56、 React Class 组件和 React Hook 的区别有哪些？">56、 React Class 组件和 React Hook 的区别有哪些？</a></li><li><a href=#57-react-%e4%b8%ad%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0%e5%92%8c%e8%87%aa%e5%ae%9a%e4%b9%89-hook-%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9 aria-label="57、 React 中高阶函数和自定义 Hook 的优缺点？">57、 React 中高阶函数和自定义 Hook 的优缺点？</a></li><li><a href=#58-%e7%ae%80%e8%a6%81%e8%af%b4%e6%98%8e-react-hook-%e4%b8%ad-usestate-%e5%92%8c-useeffect-%e7%9a%84%e8%bf%90%e8%a1%8c%e5%8e%9f%e7%90%86 aria-label="58、 简要说明 React Hook 中 useState 和 useEffect 的运行原理？">58、 简要说明 React Hook 中 useState 和 useEffect 的运行原理？</a></li><li><a href=#59-react-%e5%a6%82%e4%bd%95%e5%8f%91%e7%8e%b0%e9%87%8d%e6%b8%b2%e6%9f%93%e4%bb%80%e4%b9%88%e5%8e%9f%e5%9b%a0%e5%ae%b9%e6%98%93%e9%80%a0%e6%88%90%e9%87%8d%e6%b8%b2%e6%9f%93%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e9%87%8d%e6%b8%b2%e6%9f%93 aria-label="59、 React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？">59、 React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？</a></li><li><a href=#60-react-hook-%e4%b8%ad-useeffect-%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8f%82%e6%95%b0%e5%a6%82%e4%bd%95%e6%a3%80%e6%b5%8b%e6%95%b0%e7%bb%84%e4%be%9d%e8%b5%96%e9%a1%b9%e7%9a%84%e5%8f%98%e5%8c%96 aria-label="60、 React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？">60、 React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？</a></li><li><a href=#61-react-%e7%9a%84-useeffect-%e6%98%af%e5%a6%82%e4%bd%95%e7%9b%91%e5%90%ac%e6%95%b0%e7%bb%84%e4%be%9d%e8%b5%96%e9%a1%b9%e7%9a%84%e5%8f%98%e5%8c%96%e7%9a%84 aria-label="61、 React 的 useEffect 是如何监听数组依赖项的变化的？">61、 React 的 useEffect 是如何监听数组依赖项的变化的？</a></li><li><a href=#62-react-hook-%e5%92%8c%e9%97%ad%e5%8c%85%e6%9c%89%e4%bb%80%e4%b9%88%e5%85%b3%e8%81%94%e5%85%b3%e7%b3%bb aria-label="62、 React Hook 和闭包有什么关联关系？">62、 React Hook 和闭包有什么关联关系？</a></li><li><a href=#63-react-%e4%b8%ad-usestate-%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e6%95%b0%e6%8d%ae%e5%88%9d%e5%a7%8b%e5%8c%96%e7%9a%84 aria-label="63、 React 中 useState 是如何做数据初始化的？">63、 React 中 useState 是如何做数据初始化的？</a></li><li><a href=#64-%e5%88%97%e4%b8%be%e4%bd%a0%e5%b8%b8%e7%94%a8%e7%9a%84-react-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%8a%80%e5%b7%a7 aria-label="64、 列举你常用的 React 性能优化技巧？">64、 列举你常用的 React 性能优化技巧？</a></li><li><a href=#65-vue-2x-%e6%a8%a1%e6%9d%bf%e4%b8%ad%e7%9a%84%e6%8c%87%e4%bb%a4%e6%98%af%e5%a6%82%e4%bd%95%e8%a7%a3%e6%9e%90%e5%ae%9e%e7%8e%b0%e7%9a%84 aria-label="65、 Vue 2.x 模板中的指令是如何解析实现的？">65、 Vue 2.x 模板中的指令是如何解析实现的？</a></li><li><a href=#66-%e7%ae%80%e8%a6%81%e8%af%b4%e6%98%8e-vue-2x-%e7%9a%84%e5%85%a8%e9%93%be%e8%b7%af%e8%bf%90%e4%bd%9c%e6%9c%ba%e5%88%b6 aria-label="66、 简要说明 Vue 2.x 的全链路运作机制？">66、 简要说明 Vue 2.x 的全链路运作机制？</a></li><li><a href=#67-%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-element-ui-%e7%9a%84%e6%a1%86%e6%9e%b6%e8%ae%be%e8%ae%a1 aria-label="67、 简单介绍一下 Element UI 的框架设计？">67、 简单介绍一下 Element UI 的框架设计？</a></li><li><a href=#68-%e5%a6%82%e4%bd%95%e7%90%86%e8%a7%a3-vue-%e6%98%af%e4%b8%80%e4%b8%aa%e6%b8%90%e8%bf%9b%e5%bc%8f%e6%a1%86%e6%9e%b6 aria-label="68、 如何理解 Vue 是一个渐进式框架？">68、 如何理解 Vue 是一个渐进式框架？</a></li><li><a href=#69-vue-%e9%87%8c%e5%ae%9e%e7%8e%b0%e8%b7%a8%e7%bb%84%e4%bb%b6%e9%80%9a%e4%bf%a1%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b aria-label="69、 Vue 里实现跨组件通信的方式有哪些？">69、 Vue 里实现跨组件通信的方式有哪些？</a></li><li><a href=#70-vue-%e4%b8%ad%e5%93%8d%e5%ba%94%e5%bc%8f%e6%95%b0%e6%8d%ae%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e5%af%b9%e6%9f%90%e4%b8%aa%e5%af%b9%e8%b1%a1%e7%9a%84%e6%b7%b1%e5%b1%82%e6%ac%a1%e5%b1%9e%e6%80%a7%e7%9a%84%e7%9b%91%e5%90%ac%e7%9a%84 aria-label="70、 Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？">70、 Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？</a></li><li><a href=#71-mvvmmvc-%e5%92%8c-mvp-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%e5%90%84%e8%87%aa%e6%9c%89%e4%bb%80%e4%b9%88%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af aria-label="71、 MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、">71、 MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、</a></li><li><a href=#72-%e4%bb%80%e4%b9%88%e6%98%af-mvvm-%e6%a1%86%e6%9e%b6 aria-label="72、 什么是 MVVM 框架？">72、 什么是 MVVM 框架？</a></li></ul></li><li><a href=#%e5%b7%a5%e7%a8%8b aria-label=工程>工程</a><ul><li><a href=#73vue-cli-3x-%e6%9c%89%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bdvue-cli-3x-%e7%9a%84%e6%8f%92%e4%bb%b6%e7%b3%bb%e7%bb%9f%e4%ba%86%e8%a7%a3 aria-label="73、Vue CLI 3.x 有哪些功能？Vue CLI 3.x 的插件系统了解？">73、Vue CLI 3.x 有哪些功能？Vue CLI 3.x 的插件系统了解？</a></li><li><a href=#74vue-cli-3x-%e4%b8%ad%e7%9a%84-webpack-%e6%98%af%e5%a6%82%e4%bd%95%e7%bb%84%e8%a3%85%e5%a4%84%e7%90%86%e7%9a%84 aria-label="74、Vue CLI 3.x 中的 Webpack 是如何组装处理的？">74、Vue CLI 3.x 中的 Webpack 是如何组装处理的？</a></li><li><a href=#75vue-2x-%e5%a6%82%e4%bd%95%e6%94%af%e6%8c%81-typescript-%e8%af%ad%e6%b3%95 aria-label="75、Vue 2.x 如何支持 TypeScript 语法？">75、Vue 2.x 如何支持 TypeScript 语法？</a></li><li><a href=#76%e5%a6%82%e4%bd%95%e9%85%8d%e7%bd%ae%e7%8e%af%e5%a2%83%e4%bd%bf%e5%be%97-javascript-%e9%a1%b9%e7%9b%ae%e5%8f%af%e4%bb%a5%e6%94%af%e6%8c%81-typescript-%e8%af%ad%e6%b3%95 aria-label="76、如何配置环境使得 JavaScript 项目可以支持 TypeScript 语法？">76、如何配置环境使得 JavaScript 项目可以支持 TypeScript 语法？</a></li><li><a href=#77%e5%a6%82%e4%bd%95%e5%af%b9-typescript-%e8%bf%9b%e8%a1%8c-lint-%e6%a0%a1%e9%aa%8ceslint-%e5%92%8c-tslint-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="77、如何对 TypeScript 进行 Lint 校验？ESLint 和 TSLint 有什么区别？">77、如何对 TypeScript 进行 Lint 校验？ESLint 和 TSLint 有什么区别？</a></li><li><a href=#78nodejs-%e5%a6%82%e4%bd%95%e6%94%af%e6%8c%81-typescript-%e8%af%ad%e6%b3%95 aria-label="78、Node.js 如何支持 TypeScript 语法？">78、Node.js 如何支持 TypeScript 语法？</a></li><li><a href=#79typescript-%e5%a6%82%e4%bd%95%e8%87%aa%e5%8a%a8%e7%94%9f%e6%88%90%e5%ba%93%e5%8c%85%e7%9a%84%e5%a3%b0%e6%98%8e%e6%96%87%e4%bb%b6 aria-label="79、TypeScript 如何自动生成库包的声明文件？">79、TypeScript 如何自动生成库包的声明文件？</a></li><li><a href=#80babel-%e5%af%b9%e4%ba%8e-typescript-%e7%9a%84%e6%94%af%e6%8c%81%e6%9c%89%e5%93%aa%e4%ba%9b%e9%99%90%e5%88%b6 aria-label="80、Babel 对于 TypeScript 的支持有哪些限制？">80、Babel 对于 TypeScript 的支持有哪些限制？</a></li><li><a href=#81webpack-%e4%b8%ad-loader-%e5%92%8c-plugin-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88 aria-label="81、Webpack 中 Loader 和 Plugin 的区别是什么？">81、Webpack 中 Loader 和 Plugin 的区别是什么？</a></li><li><a href=#82%e5%9c%a8-webpack-%e4%b8%ad%e6%98%af%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0%e6%94%af%e6%8c%81%e7%b1%bb%e4%bc%bc%e4%ba%8e-jsx-%e8%af%ad%e6%b3%95%e7%9a%84-sourcemap-%e5%ae%9a%e4%bd%8d aria-label="82、在 Webpack 中是如何做到支持类似于 JSX 语法的 Sourcemap 定位？">82、在 Webpack 中是如何做到支持类似于 JSX 语法的 Sourcemap 定位？</a></li><li><a href=#83%e5%8f%91%e5%b8%83-npm-%e5%8c%85%e5%a6%82%e4%bd%95%e6%8c%87%e5%ae%9a%e5%bc%95%e5%85%a5%e5%9c%b0%e5%9d%80 aria-label="83、发布 Npm 包如何指定引入地址？">83、发布 Npm 包如何指定引入地址？</a></li><li><a href=#84%e5%a6%82%e4%bd%95%e5%8f%91%e5%b8%83%e5%bc%80%e5%8f%91%e9%a1%b9%e7%9b%ae%e7%9a%84%e7%89%b9%e5%ae%9a%e6%96%87%e4%bb%b6%e5%a4%b9%e4%b8%ba-npm-%e5%8c%85%e7%9a%84%e6%a0%b9%e7%9b%ae%e5%bd%95 aria-label="84、如何发布开发项目的特定文件夹为 Npm 包的根目录？">84、如何发布开发项目的特定文件夹为 Npm 包的根目录？</a></li><li><a href=#85%e5%a6%82%e4%bd%95%e5%8f%91%e5%b8%83%e4%b8%80%e4%b8%aa%e6%94%af%e6%8c%81-tree-shaking-%e6%9c%ba%e5%88%b6%e7%9a%84-npm-%e5%8c%85 aria-label="85、如何发布一个支持 Tree Shaking 机制的 Npm 包？">85、如何发布一个支持 Tree Shaking 机制的 Npm 包？</a></li><li><a href=#86npm-%e5%8c%85%e4%b8%ad-peerdependencies-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88 aria-label="86、Npm 包中 peerDependencies 的作用是什么？">86、Npm 包中 peerDependencies 的作用是什么？</a></li><li><a href=#87%e5%a6%82%e4%bd%95%e4%bc%98%e9%9b%85%e7%9a%84%e8%b0%83%e8%af%95%e9%9c%80%e8%a6%81%e5%8f%91%e5%b8%83%e7%9a%84-npm-%e5%8c%85 aria-label="87、如何优雅的调试需要发布的 Npm 包？">87、如何优雅的调试需要发布的 Npm 包？</a></li><li><a href=#88%e5%9c%a8%e8%ae%be%e8%ae%a1%e4%b8%80%e4%ba%9b%e5%ba%93%e5%8c%85%e6%97%b6%e5%a6%82%e4%bd%95%e7%94%9f%e6%88%90%e7%89%88%e6%9c%ac%e6%97%a5%e5%bf%97 aria-label=88、在设计一些库包时如何生成版本日志？>88、在设计一些库包时如何生成版本日志？</a></li><li><a href=#89%e4%ba%86%e8%a7%a3-git-submodule%e5%ad%90%e6%a8%a1%e5%9d%97%e5%90%97%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-git-%e5%ad%90%e6%a8%a1%e5%9d%97%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label="89、了解 Git （Submodule）子模块吗？简单介绍一下 Git 子模块的作用？">89、了解 Git （Submodule）子模块吗？简单介绍一下 Git 子模块的作用？</a></li><li><a href=#90git-%e5%a6%82%e4%bd%95%e4%bf%ae%e6%94%b9%e5%b7%b2%e7%bb%8f%e6%8f%90%e4%ba%a4%e7%9a%84-commit-%e4%bf%a1%e6%81%af aria-label="90、Git 如何修改已经提交的 Commit 信息？">90、Git 如何修改已经提交的 Commit 信息？</a></li><li><a href=#91git-%e5%a6%82%e4%bd%95%e6%92%a4%e9%94%80-commit-%e5%b9%b6%e4%bf%9d%e5%ad%98%e4%b9%8b%e5%89%8d%e7%9a%84%e4%bf%ae%e6%94%b9 aria-label="91、Git 如何撤销 Commit 并保存之前的修改？">91、Git 如何撤销 Commit 并保存之前的修改？</a></li><li><a href=#92git-%e5%a6%82%e4%bd%95-ignore-%e8%a2%ab-commit-%e8%bf%87%e7%9a%84%e6%96%87%e4%bb%b6 aria-label="92、Git 如何 ignore 被 commit 过的文件？">92、Git 如何 ignore 被 commit 过的文件？</a></li><li><a href=#93%e5%9c%a8%e4%bd%bf%e7%94%a8-git-%e7%9a%84%e6%97%b6%e5%80%99%e5%a6%82%e4%bd%95%e8%a7%84%e8%8c%83-git-%e7%9a%84%e6%8f%90%e4%ba%a4%e8%af%b4%e6%98%8ecommit-%e4%bf%a1%e6%81%af aria-label="93、在使用 Git 的时候如何规范 Git 的提交说明（Commit 信息）？">93、在使用 Git 的时候如何规范 Git 的提交说明（Commit 信息）？</a></li><li><a href=#94%e7%ae%80%e8%bf%b0%e7%ac%a6%e5%90%88-angular-%e8%a7%84%e8%8c%83%e7%9a%84%e6%8f%90%e4%ba%a4%e8%af%b4%e6%98%8e%e7%9a%84%e7%bb%93%e6%9e%84%e7%bb%84%e6%88%90 aria-label="94、简述符合 Angular 规范的提交说明的结构组成？">94、简述符合 Angular 规范的提交说明的结构组成？</a></li><li><a href=#95commit-%e4%bf%a1%e6%81%af%e5%a6%82%e4%bd%95%e5%92%8c-github-issues-%e5%85%b3%e8%81%94 aria-label="95、Commit 信息如何和 Github Issues 关联？">95、Commit 信息如何和 Github Issues 关联？</a></li><li><a href=#96git-hook-%e5%9c%a8%e9%a1%b9%e7%9b%ae%e4%b8%ad%e5%93%aa%e4%ba%9b%e4%bd%9c%e7%94%a8 aria-label="96、Git Hook 在项目中哪些作用？">96、Git Hook 在项目中哪些作用？</a></li><li><a href=#97git-hook-%e4%b8%ad%e5%ae%a2%e6%88%b7%e7%ab%af%e5%92%8c%e6%9c%8d%e5%8a%a1%e7%ab%af%e9%92%a9%e5%ad%90%e5%90%84%e8%87%aa%e7%94%a8%e4%ba%8e%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8 aria-label="97、Git Hook 中客户端和服务端钩子各自用于什么作用？">97、Git Hook 中客户端和服务端钩子各自用于什么作用？</a></li><li><a href=#98git-hook-%e4%b8%ad%e5%b8%b8%e7%94%a8%e7%9a%84%e9%92%a9%e5%ad%90%e6%9c%89%e5%93%aa%e4%ba%9b aria-label="98、Git Hook 中常用的钩子有哪些？">98、Git Hook 中常用的钩子有哪些？</a></li><li><a href=#99pre-commit-%e5%92%8c-commit-msg-%e9%92%a9%e5%ad%90%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%e5%90%84%e8%87%aa%e5%8f%af%e7%94%a8%e4%ba%8e%e5%81%9a%e4%bb%80%e4%b9%88 aria-label="99、pre-commit 和 commit-msg 钩子的区别是什么？各自可用于做什么？">99、pre-commit 和 commit-msg 钩子的区别是什么？各自可用于做什么？</a></li><li><a href=#100husky-%e4%bb%a5%e5%8f%8a-ghook-%e7%ad%89%e5%b7%a5%e5%85%b7%e5%88%b6%e4%bd%9c-git-hook-%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88 aria-label="100、husky 以及 ghook 等工具制作 Git Hook 的原理是什么？">100、husky 以及 ghook 等工具制作 Git Hook 的原理是什么？</a></li><li><a href=#101%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e9%80%9a%e7%94%a8%e7%9a%84-git-hook- aria-label="101、如何设计一个通用的 Git Hook ？">101、如何设计一个通用的 Git Hook ？</a></li><li><a href=#102git-hook-%e5%8f%af%e4%bb%a5%e9%87%87%e7%94%a8-node-%e8%84%9a%e6%9c%ac%e8%bf%9b%e8%a1%8c%e8%ae%be%e8%ae%a1%e5%90%97%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0 aria-label="102、Git Hook 可以采用 Node 脚本进行设计吗？如何做到？">102、Git Hook 可以采用 Node 脚本进行设计吗？如何做到？</a></li><li><a href=#103%e5%a6%82%e4%bd%95%e7%a1%ae%e4%bf%9d%e5%88%ab%e4%ba%ba%e4%b8%8a%e4%bc%a0%e7%9a%84%e4%bb%a3%e7%a0%81%e6%b2%a1%e6%9c%89-lint-%e9%94%99%e8%af%af%e5%a6%82%e4%bd%95%e7%a1%ae%e4%bf%9d%e4%bb%a3%e7%a0%81%e6%9e%84%e5%bb%ba%e6%b2%a1%e6%9c%89-lint-%e9%94%99%e8%af%af aria-label="103、如何确保别人上传的代码没有 Lint 错误？如何确保代码构建没有 Lint 错误？">103、如何确保别人上传的代码没有 Lint 错误？如何确保代码构建没有 Lint 错误？</a></li><li><a href=#104%e5%a6%82%e4%bd%95%e5%9c%a8-vs-code-%e4%b8%ad%e8%bf%9b%e8%a1%8c-lint-%e6%a0%a1%e9%aa%8c%e6%8f%90%e7%a4%ba%e5%a6%82%e4%bd%95%e5%9c%a8-vs-code-%e4%b8%ad%e8%bf%9b%e8%a1%8c-lint-%e4%bf%9d%e5%ad%98%e6%a0%bc%e5%bc%8f%e5%8c%96 aria-label="104、如何在 Vs Code 中进行 Lint 校验提示？如何在 Vs Code 中进行 Lint 保存格式化？">104、如何在 Vs Code 中进行 Lint 校验提示？如何在 Vs Code 中进行 Lint 保存格式化？</a></li><li><a href=#105eslint-%e5%92%8c-prettier-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%e4%b8%a4%e8%80%85%e5%9c%a8%e4%b8%80%e8%b5%b7%e5%b7%a5%e4%bd%9c%e6%97%b6%e4%bc%9a%e4%ba%a7%e7%94%9f%e9%97%ae%e9%a2%98%e5%90%97 aria-label="105、ESLint 和 Prettier 的区别是什么？两者在一起工作时会产生问题吗？">105、ESLint 和 Prettier 的区别是什么？两者在一起工作时会产生问题吗？</a></li><li><a href=#106%e5%a6%82%e4%bd%95%e6%9c%89%e6%95%88%e7%9a%84%e8%af%86%e5%88%ab-eslint-%e5%92%8c-prettier-%e5%8f%af%e8%83%bd%e4%ba%a7%e7%94%9f%e5%86%b2%e7%aa%81%e7%9a%84%e6%a0%bc%e5%bc%8f%e8%a7%84%e5%88%99%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e6%ad%a4%e7%b1%bb%e8%a7%84%e5%88%99%e5%86%b2%e7%aa%81%e9%97%ae%e9%a2%98 aria-label="106、如何有效的识别 ESLint 和 Prettier 可能产生冲突的格式规则？如何解决此类规则冲突问题？">106、如何有效的识别 ESLint 和 Prettier 可能产生冲突的格式规则？如何解决此类规则冲突问题？</a></li><li><a href=#107%e5%9c%a8%e9%80%9a%e5%b8%b8%e7%9a%84%e8%84%9a%e6%89%8b%e6%9e%b6%e9%a1%b9%e7%9b%ae%e4%b8%ad%e8%bf%9b%e8%a1%8c%e7%83%ad%e6%9b%b4%e6%96%b0hot-module-replacement%e6%97%b6%e5%a6%82%e4%bd%95%e5%81%9a%e5%88%b0-eslint-%e5%ae%9e%e6%97%b6%e6%89%93%e5%8d%b0%e6%a0%a1%e9%aa%8c%e9%94%99%e8%af%af%e4%bf%a1%e6%81%af aria-label="107、在通常的脚手架项目中进行热更新（hot module replacement）时如何做到 ESLint 实时打印校验错误信息？">107、在通常的脚手架项目中进行热更新（hot module replacement）时如何做到 ESLint 实时打印校验错误信息？</a></li><li><a href=#108%e8%b0%88%e8%b0%88%e4%bd%a0%e5%af%b9-sourcemap-%e7%9a%84%e4%ba%86%e8%a7%a3 aria-label="108、谈谈你对 SourceMap 的了解？">108、谈谈你对 SourceMap 的了解？</a></li><li><a href=#109%e5%a6%82%e4%bd%95%e8%b0%83%e8%af%95-nodejs-%e4%bb%a3%e7%a0%81%e5%a6%82%e4%bd%95%e8%b0%83%e8%af%95-nodejs-typescript-%e4%bb%a3%e7%a0%81%e5%9c%a8%e6%b5%8f%e8%a7%88%e5%99%a8%e4%b8%ad%e5%a6%82%e4%bd%95%e8%b0%83%e8%af%95-nodejs-%e4%bb%a3%e7%a0%81 aria-label="109、如何调试 Node.js 代码？如何调试 Node.js TypeScript 代码？在浏览器中如何调试 Node.js 代码？">109、如何调试 Node.js 代码？如何调试 Node.js TypeScript 代码？在浏览器中如何调试 Node.js 代码？</a></li><li><a href=#110%e5%88%97%e4%b8%be%e4%bd%a0%e7%9f%a5%e9%81%93%e7%9a%84%e6%89%80%e6%9c%89%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7%e5%b9%b6%e8%af%b4%e8%af%b4%e8%bf%99%e4%ba%9b%e5%b7%a5%e5%85%b7%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e8%bf%99%e4%ba%9b%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7%e5%9c%a8%e4%b8%8d%e5%90%8c%e7%9a%84%e5%9c%ba%e6%99%af%e4%b8%8b%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e9%80%89%e5%9e%8b aria-label=110、列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？>110、列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？</a></li><li><a href=#111vs-code-%e9%85%8d%e7%bd%ae%e4%b8%ad%e7%9a%84%e7%94%a8%e6%88%b7%e5%92%8c%e5%b7%a5%e4%bd%9c%e5%8c%ba%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab aria-label="111、VS Code 配置中的用户和工作区有什么区别？">111、VS Code 配置中的用户和工作区有什么区别？</a></li><li><a href=#112vs-code-%e7%9a%84%e6%8f%92%e4%bb%b6%e5%8f%af%e4%bb%a5%e5%8f%aa%e5%af%b9%e5%bd%93%e5%89%8d%e9%a1%b9%e7%9b%ae%e7%94%9f%e6%95%88%e5%90%97 aria-label="112、VS Code 的插件可以只对当前项目生效吗？">112、VS Code 的插件可以只对当前项目生效吗？</a></li><li><a href=#113%e4%bd%a0%e6%89%80%e7%9f%a5%e9%81%93%e7%9a%84%e6%b5%8b%e8%af%95%e6%9c%89%e5%93%aa%e4%ba%9b%e6%b5%8b%e8%af%95%e7%b1%bb%e5%9e%8b aria-label=113、你所知道的测试有哪些测试类型？>113、你所知道的测试有哪些测试类型？</a></li><li><a href=#114%e4%bd%a0%e6%89%80%e7%9f%a5%e9%81%93%e7%9a%84%e6%b5%8b%e8%af%95%e6%a1%86%e6%9e%b6%e6%9c%89%e5%93%aa%e4%ba%9b aria-label=114、你所知道的测试框架有哪些？>114、你所知道的测试框架有哪些？</a></li><li><a href=#115%e4%bb%80%e4%b9%88%e6%98%af-e2e-%e6%b5%8b%e8%af%95%e6%9c%89%e5%93%aa%e4%ba%9b-e2e-%e7%9a%84%e6%b5%8b%e8%af%95%e6%a1%86%e6%9e%b6 aria-label="115、什么是 e2e 测试？有哪些 e2e 的测试框架？">115、什么是 e2e 测试？有哪些 e2e 的测试框架？</a></li><li><a href=#116%e5%81%87%e8%ae%be%e7%8e%b0%e5%9c%a8%e6%9c%89%e4%b8%80%e4%b8%aa%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95%e5%a6%82%e4%bd%95%e5%af%b9%e8%af%a5%e7%ae%97%e6%b3%95%e8%bf%9b%e8%a1%8c%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95 aria-label=116、假设现在有一个插入排序算法，如何对该算法进行单元测试？>116、假设现在有一个插入排序算法，如何对该算法进行单元测试？</a></li></ul></li><li><a href=#%e7%bd%91%e7%bb%9c aria-label=网络>网络</a><ul><li><a href=#117cdn-%e6%9c%8d%e5%8a%a1%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%bd%91%e7%bb%9c%e5%8a%a0%e9%80%9f aria-label="117、CDN 服务如何实现网络加速？">117、CDN 服务如何实现网络加速？</a></li><li><a href=#118websocket-%e4%bd%bf%e7%94%a8%e7%9a%84%e6%98%af-tcp-%e8%bf%98%e6%98%af-udp-%e5%8d%8f%e8%ae%ae aria-label="118、WebSocket 使用的是 TCP 还是 UDP 协议？">118、WebSocket 使用的是 TCP 还是 UDP 协议？</a></li><li><a href=#119%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%95%e5%b7%a5%e5%8d%8a%e5%8f%8c%e5%b7%a5%e5%92%8c%e5%85%a8%e5%8f%8c%e5%b7%a5%e9%80%9a%e4%bf%a1 aria-label=119、什么是单工、半双工和全双工通信？>119、什么是单工、半双工和全双工通信？</a></li><li><a href=#120%e7%ae%80%e5%8d%95%e6%8f%8f%e8%bf%b0-http-%e5%8d%8f%e8%ae%ae%e5%8f%91%e9%80%81%e4%b8%80%e4%b8%aa%e5%b8%a6%e5%9f%9f%e5%90%8d%e7%9a%84-url-%e8%af%b7%e6%b1%82%e7%9a%84%e5%8d%8f%e8%ae%ae%e4%bc%a0%e8%be%93%e8%bf%87%e7%a8%8bdnstcpip%e9%93%be%e8%b7%af aria-label="120、简单描述 HTTP 协议发送一个带域名的 URL 请求的协议传输过程？（DNS、TCP、IP、链路）">120、简单描述 HTTP 协议发送一个带域名的 URL 请求的协议传输过程？（DNS、TCP、IP、链路）</a></li><li><a href=#121%e4%bb%80%e4%b9%88%e6%98%af%e6%ad%a3%e5%90%91%e4%bb%a3%e7%90%86%e4%bb%80%e4%b9%88%e6%98%af%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86 aria-label=121、什么是正向代理？什么是反向代理？>121、什么是正向代理？什么是反向代理？</a></li><li><a href=#122cookie-%e5%8f%af%e4%bb%a5%e5%9c%a8%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%94%9f%e6%88%90%e5%90%97cookie-%e5%9c%a8%e6%9c%8d%e5%8a%a1%e7%ab%af%e7%94%9f%e6%88%90%e5%90%8e%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b%e6%98%af%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84 aria-label="122、Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？">122、Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？</a></li><li><a href=#123sessioncookie-%e7%9a%84%e5%8c%ba%e5%88%ab%e5%92%8c%e5%85%b3%e8%81%94%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e4%b8%b4%e6%97%b6%e6%80%a7%e5%92%8c%e6%b0%b8%e4%b9%85%e6%80%a7%e7%9a%84-session-%e5%ad%98%e5%82%a8 aria-label="123、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？">123、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？</a></li><li><a href=#124%e8%ae%be%e7%bd%ae-cookie-%e6%97%b6%e5%80%99%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2-xss-%e6%94%bb%e5%87%bb aria-label="124、设置 Cookie 时候如何防止 XSS 攻击？">124、设置 Cookie 时候如何防止 XSS 攻击？</a></li><li><a href=#125%e7%ae%80%e5%8d%95%e6%8f%8f%e8%bf%b0%e4%b8%80%e4%b8%8b%e7%94%a8%e6%88%b7%e5%85%8d%e7%99%bb%e9%99%86%e7%9a%84%e5%ae%9e%e7%8e%b0%e8%bf%87%e7%a8%8b%e5%8f%af%e8%83%bd%e4%bc%9a%e5%87%ba%e7%8e%b0%e5%93%aa%e4%ba%9b%e5%ae%89%e5%85%a8%e6%80%a7%e9%97%ae%e9%a2%98%e4%b8%80%e8%88%ac%e5%a6%82%e4%bd%95%e5%af%b9%e7%94%a8%e6%88%b7%e7%99%bb%e5%bd%95%e7%9a%84%e5%af%86%e7%a0%81%e8%bf%9b%e8%a1%8c%e5%8a%a0%e5%af%86 aria-label=125、简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？>125、简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？</a></li><li><a href=#126http-%e4%b8%ad%e6%8f%90%e5%8d%87%e4%bc%a0%e8%be%93%e9%80%9f%e7%8e%87%e7%9a%84%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e7%94%a8%e7%9a%84%e5%86%85%e5%ae%b9%e7%bc%96%e7%a0%81%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b aria-label="126、HTTP 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？">126、HTTP 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？</a></li><li><a href=#127%e4%bc%a0%e8%be%93%e5%9b%be%e7%89%87%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%a6%82%e6%9e%9c%e7%aa%81%e7%84%b6%e4%b8%ad%e6%96%ad%e5%a6%82%e4%bd%95%e5%9c%a8%e6%81%a2%e5%a4%8d%e5%90%8e%e4%bb%8e%e4%b9%8b%e5%89%8d%e7%9a%84%e4%b8%ad%e6%96%ad%e4%b8%ad%e6%81%a2%e5%a4%8d%e4%bc%a0%e8%be%93 aria-label=127、传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？>127、传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？</a></li><li><a href=#128%e4%bb%80%e4%b9%88%e6%98%af%e4%bb%a3%e7%90%86%e4%bb%80%e4%b9%88%e6%98%af%e7%bd%91%e5%85%b3%e4%bb%a3%e7%90%86%e5%92%8c%e7%bd%91%e5%85%b3%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88 aria-label=128、什么是代理？什么是网关？代理和网关的作用是什么？>128、什么是代理？什么是网关？代理和网关的作用是什么？</a></li><li><a href=#129https-%e7%9b%b8%e6%af%94-http-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%9b%b4%e5%8a%a0%e5%ae%89%e5%85%a8%e5%8f%af%e9%9d%a0 aria-label="129、HTTPS 相比 HTTP 为什么更加安全可靠？">129、HTTPS 相比 HTTP 为什么更加安全可靠？</a></li><li><a href=#130%e4%bb%80%e4%b9%88%e6%98%af%e5%af%b9%e7%a7%b0%e5%af%86%e9%92%a5%e5%85%b1%e4%ba%ab%e5%af%86%e9%92%a5%e5%8a%a0%e5%af%86%e4%bb%80%e4%b9%88%e6%98%af%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%af%86%e9%92%a5%e5%85%ac%e5%bc%80%e5%af%86%e9%92%a5%e5%8a%a0%e5%af%86%e5%93%aa%e4%b8%aa%e6%9b%b4%e5%8a%a0%e5%ae%89%e5%85%a8 aria-label=130、什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？>130、什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？</a></li><li><a href=#131%e4%bd%a0%e8%a7%89%e5%be%97-http-%e5%8d%8f%e8%ae%ae%e7%9b%ae%e5%89%8d%e5%ad%98%e5%9c%a8%e5%93%aa%e4%ba%9b%e7%bc%ba%e7%82%b9 aria-label="131、你觉得 HTTP 协议目前存在哪些缺点？">131、你觉得 HTTP 协议目前存在哪些缺点？</a></li></ul></li><li><a href=#%e6%80%a7%e8%83%bd aria-label=性能>性能</a><ul><li><a href=#133%e5%9c%a8-react-%e4%b8%ad%e5%a6%82%e4%bd%95%e8%af%86%e5%88%ab%e4%b8%80%e4%b8%aa%e8%a1%a8%e5%8d%95%e9%a1%b9%e9%87%8c%e7%9a%84%e8%a1%a8%e5%8d%95%e5%81%9a%e5%88%b0%e4%ba%86%e6%9c%80%e5%b0%8f%e7%b2%92%e5%ba%a6--%e4%bb%a3%e4%bb%b7%e7%9a%84%e6%b8%b2%e6%9f%93 aria-label="133、在 React 中如何识别一个表单项里的表单做到了最小粒度 / 代价的渲染？">133、在 React 中如何识别一个表单项里的表单做到了最小粒度 / 代价的渲染？</a></li><li><a href=#134%e5%9c%a8-react-%e7%9a%84%e5%bc%80%e5%8f%91%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%bd%a0%e8%83%bd%e6%83%b3%e5%88%b0%e5%93%aa%e4%ba%9b%e6%8e%a7%e5%88%b6%e6%b8%b2%e6%9f%93%e6%88%90%e6%9c%ac%e7%9a%84%e6%96%b9%e6%b3%95 aria-label="134、在 React 的开发的过程中你能想到哪些控制渲染成本的方法？">134、在 React 的开发的过程中你能想到哪些控制渲染成本的方法？</a></li></ul></li><li><a href=#%e6%8f%92%e4%bb%b6 aria-label=插件>插件</a><ul><li><a href=#135vue-cli-3x-%e7%9a%84%e6%8f%92%e4%bb%b6%e7%b3%bb%e7%bb%9f%e6%98%af%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e7%9a%84 aria-label="135、Vue CLI 3.x 的插件系统是如何设计的？">135、Vue CLI 3.x 的插件系统是如何设计的？</a></li><li><a href=#136webpack-%e4%b8%ad%e7%9a%84%e6%8f%92%e4%bb%b6%e6%9c%ba%e5%88%b6%e6%98%af%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e7%9a%84 aria-label="136、Webpack 中的插件机制是如何设计的？">136、Webpack 中的插件机制是如何设计的？</a></li></ul></li><li><a href=#%e7%b3%bb%e7%bb%9f aria-label=系统>系统</a><ul><li><a href=#137rncrlf-%e5%92%8c-n-lf%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88vs-code-%e7%9a%84%e5%8f%b3%e4%b8%8b%e8%a7%92%e5%8f%af%e4%bb%a5%e5%88%87%e6%8d%a2 aria-label="137、\r\n（CRLF） 和 \n （LF）的区别是什么？(Vs Code 的右下角可以切换)">137、\r\n（CRLF） 和 \n （LF）的区别是什么？(Vs Code 的右下角可以切换)</a></li><li><a href=#138devnull-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e5%95%a5 aria-label="138、/dev/null 的作用是啥？">138、/dev/null 的作用是啥？</a></li><li><a href=#139%e5%a6%82%e4%bd%95%e5%9c%a8-mac-%e7%9a%84%e7%bb%88%e7%ab%af%e4%b8%ad%e8%ae%be%e7%bd%ae%e4%b8%80%e4%b8%aa%e5%91%bd%e4%bb%a4%e7%9a%84%e5%88%ab%e5%90%8d aria-label="139、如何在 Mac 的终端中设置一个命令的别名？">139、如何在 Mac 的终端中设置一个命令的别名？</a></li><li><a href=#140%e5%a6%82%e4%bd%95%e5%9c%a8-windows-%e4%b8%ad%e8%ae%be%e7%bd%ae%e7%8e%af%e5%a2%83%e5%8f%98%e9%87%8f aria-label="140、如何在 Windows 中设置环境变量？">140、如何在 Windows 中设置环境变量？</a></li><li><a href=#141mac-%e7%9a%84%e6%96%87%e4%bb%b6%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e9%bb%98%e8%ae%a4%e5%8c%ba%e5%88%86%e6%96%87%e4%bb%b6%e8%b7%af%e5%be%84%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%86%99%e5%90%97 aria-label="141、Mac 的文件操作系统默认区分文件路径的大小写吗？">141、Mac 的文件操作系统默认区分文件路径的大小写吗？</a></li><li><a href=#142%e7%bc%96%e5%86%99-shell-%e8%84%9a%e6%9c%ac%e6%97%b6%e5%a6%82%e4%bd%95%e8%ae%be%e7%bd%ae%e6%96%87%e4%bb%b6%e7%9a%84%e7%bb%9d%e5%af%b9%e8%b7%af%e5%be%84 aria-label="142、编写 Shell 脚本时如何设置文件的绝对路径？">142、编写 Shell 脚本时如何设置文件的绝对路径？</a></li></ul></li><li><a href=#%e5%90%8e%e7%ab%af aria-label=后端>后端</a><ul><li><a href=#143sessioncookie-%e7%9a%84%e5%8c%ba%e5%88%ab%e5%92%8c%e5%85%b3%e8%81%94%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e4%b8%b4%e6%97%b6%e6%80%a7%e5%92%8c%e6%b0%b8%e4%b9%85%e6%80%a7%e7%9a%84-session-%e5%ad%98%e5%82%a8 aria-label="143、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？">143、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？</a></li><li><a href=#144%e5%a6%82%e4%bd%95%e9%83%a8%e7%bd%b2-nodejs-%e5%ba%94%e7%94%a8%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e4%b8%ad-session-%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98 aria-label="144、如何部署 Node.js 应用？如何处理负载均衡中 Session 的一致性问题？">144、如何部署 Node.js 应用？如何处理负载均衡中 Session 的一致性问题？</a></li><li><a href=#145%e5%a6%82%e4%bd%95%e6%8f%90%e5%8d%87-nodejs-%e4%bb%a3%e7%a0%81%e7%9a%84%e8%bf%90%e8%a1%8c%e7%a8%b3%e5%ae%9a%e6%80%a7 aria-label="145、如何提升 Node.js 代码的运行稳定性？">145、如何提升 Node.js 代码的运行稳定性？</a></li><li><a href=#146graphql-%e4%b8%8e-restful-%e7%9a%84%e5%8c%ba%e5%88%ab%e5%ae%83%e6%9c%89%e4%bb%80%e4%b9%88%e4%bc%98%e7%82%b9 aria-label="146、GraphQL 与 Restful 的区别，它有什么优点？">146、GraphQL 与 Restful 的区别，它有什么优点？</a></li><li><a href=#147vue-ssr-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86vuex-%e7%9a%84%e6%95%b0%e6%8d%ae%e5%a6%82%e4%bd%95%e5%90%8c%e6%9e%84%e6%b8%b2%e6%9f%93 aria-label="147、Vue SSR 的工作原理？Vuex 的数据如何同构渲染？">147、Vue SSR 的工作原理？Vuex 的数据如何同构渲染？</a></li><li><a href=#148ssr-%e6%8a%80%e6%9c%af%e5%92%8c-spa-%e6%8a%80%e6%9c%af%e7%9a%84%e5%90%84%e8%87%aa%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9%e6%98%af%e4%bb%80%e4%b9%88 aria-label="148、SSR 技术和 SPA 技术的各自的优缺点是什么？">148、SSR 技术和 SPA 技术的各自的优缺点是什么？</a></li><li><a href=#149%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-nodejs-%e6%b8%b2%e6%9f%93-html-%e5%8e%8b%e5%8a%9b%e8%bf%87%e5%a4%a7%e9%97%ae%e9%a2%98 aria-label="149、如何处理 Node.js 渲染 HTML 压力过大问题？">149、如何处理 Node.js 渲染 HTML 压力过大问题？</a></li></ul></li></ul><li><a href=#%e4%b8%9a%e5%8a%a1%e6%80%9d%e8%80%83 aria-label=业务思考>业务思考</a><ul><li><a href=#%e5%b7%a5%e7%a8%8b%e5%8c%96 aria-label=工程化>工程化</a><ul><li><a href=#150%e4%bd%a0%e6%89%80%e7%9f%a5%e9%81%93%e7%9a%84-ci--cd-%e5%b7%a5%e5%85%b7%e6%9c%89%e5%93%aa%e4%ba%9b%e5%9c%a8%e9%a1%b9%e7%9b%ae%e4%b8%ad%e6%9c%89%e6%8e%a5%e8%a7%a6%e8%bf%87%e7%b1%bb%e4%bc%bc%e7%9a%84%e6%b5%81%e7%a8%8b%e5%90%97 aria-label="150、你所知道的 CI / CD 工具有哪些？在项目中有接触过类似的流程吗？">150、你所知道的 CI / CD 工具有哪些？在项目中有接触过类似的流程吗？</a></li><li><a href=#151%e5%a6%82%e6%9e%9c%e8%ae%a9%e4%bd%a0%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa-web-%e5%89%8d%e7%ab%af%e7%9a%84-ci--cd-%e5%b7%a5%e7%a8%8b%e7%a0%94%e5%8f%91%e5%b9%b3%e5%8f%b0%e4%bd%a0%e4%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1 aria-label="151、如果让你实现一个 Web 前端的 CI / CD 工程研发平台，你会如何设计？">151、如果让你实现一个 Web 前端的 CI / CD 工程研发平台，你会如何设计？</a></li><li><a href=#152%e5%a6%82%e6%9e%9c%e6%88%91%e4%bb%ac%e9%9c%80%e8%a6%81%e5%b0%86%e5%b7%b2%e6%9c%89%e9%a1%b9%e7%9b%ae%e4%b8%ad%e7%9a%84%e7%ba%bf%e4%b8%8a%e4%ba%a7%e7%89%a9%e8%b5%84%e6%ba%90%e4%be%8b%e5%a6%82%e5%9b%be%e7%89%87%e8%bd%ac%e6%8d%a2%e6%88%90%e6%9c%ac%e5%9c%b0%e7%a7%81%e6%9c%89%e5%8c%96%e8%b5%84%e6%ba%90%e4%bd%a0%e6%9c%89%e4%bb%80%e4%b9%88%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88 aria-label=152、如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？>152、如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？</a></li><li><a href=#153%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-vue-cli-3x-%e5%ae%9a%e5%88%b6%e4%b8%80%e4%b8%aa%e8%84%9a%e6%89%8b%e6%9e%b6%e6%af%94%e5%a6%82%e5%86%85%e9%83%a8%e8%87%aa%e5%8a%a8%e9%9b%86%e6%88%90%e4%ba%86-i18n-axioselement-ui%e8%b7%af%e7%94%b1%e5%ae%88%e5%8d%ab%e7%ad%89 aria-label="153、如何使用 Vue CLI 3.x 定制一个脚手架？比如内部自动集成了 i18n、 axios、Element UI、路由守卫等？">153、如何使用 Vue CLI 3.x 定制一个脚手架？比如内部自动集成了 i18n、 axios、Element UI、路由守卫等？</a></li><li><a href=#154jenkins-%e5%a6%82%e4%bd%95%e9%85%8d%e5%90%88-nodejs-%e8%84%9a%e6%9c%ac%e8%bf%9b%e8%a1%8c-ci--cd-%e8%ae%be%e8%ae%a1 aria-label="154、Jenkins 如何配合 Node.js 脚本进行 CI / CD 设计？">154、Jenkins 如何配合 Node.js 脚本进行 CI / CD 设计？</a></li></ul></li><li><a href=#%e9%80%9a%e7%94%a8%e6%80%a7 aria-label=通用性>通用性</a><ul><li><a href=#155%e5%a6%82%e6%9e%9c%e8%ae%a9%e4%bd%a0%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e9%80%9a%e7%94%a8%e7%9a%84%e9%a1%b9%e7%9b%ae%e8%84%9a%e6%89%8b%e6%9e%b6%e4%bd%a0%e4%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e9%80%9a%e7%94%a8%e7%9a%84%e8%84%9a%e6%89%8b%e6%9e%b6%e4%b8%80%e8%88%ac%e9%9c%80%e8%a6%81%e5%85%b7%e5%a4%87%e5%93%aa%e4%ba%9b%e8%83%bd%e5%8a%9b aria-label=155、如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？>155、如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？</a></li><li><a href=#156%e5%a6%82%e6%9e%9c%e8%ae%a9%e4%bd%a0%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e9%80%9a%e7%94%a8%e7%9a%84%e5%b7%a5%e5%85%b7%e5%ba%93%e4%bd%a0%e4%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e9%80%9a%e7%94%a8%e7%9a%84%e5%b7%a5%e5%85%b7%e5%ba%93%e4%b8%80%e8%88%ac%e9%9c%80%e8%a6%81%e5%85%b7%e5%a4%87%e5%93%aa%e4%ba%9b%e8%83%bd%e5%8a%9b aria-label=156、如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？>156、如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？</a></li><li><a href=#157%e5%81%87%e8%ae%be%e4%bd%a0%e8%87%aa%e5%b7%b1%e5%ae%9e%e7%8e%b0%e7%9a%84-react-%e6%88%96-vue-%e7%9a%84%e7%bb%84%e4%bb%b6%e5%ba%93%e8%a6%81%e8%ae%be%e8%ae%a1%e6%bc%94%e7%a4%ba%e6%96%87%e6%a1%a3%e4%bd%a0%e4%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e8%ae%be%e8%ae%a1%e7%9a%84%e6%96%87%e6%a1%a3%e9%9c%80%e8%a6%81%e5%ae%9e%e7%8e%b0%e5%93%aa%e4%ba%9b%e5%8a%9f%e8%83%bd aria-label="157、假设你自己实现的 React 或 Vue 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？">157、假设你自己实现的 React 或 Vue 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？</a></li><li><a href=#158%e5%9c%a8%e8%ae%be%e8%ae%a1%e5%b7%a5%e5%85%b7%e5%ba%93%e5%8c%85%e7%9a%84%e6%97%b6%e5%80%99%e4%bd%a0%e6%98%af%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1-api-%e6%96%87%e6%a1%a3%e7%9a%84 aria-label="158、在设计工具库包的时候你是如何设计 API 文档的？">158、在设计工具库包的时候你是如何设计 API 文档的？</a></li></ul></li><li><a href=#%e5%ba%94%e7%94%a8%e6%a1%86%e6%9e%b6 aria-label=应用框架>应用框架</a><ul><li><a href=#159%e8%b0%88%e8%b0%88-electronnwjscefflutter-%e5%92%8c%e5%8e%9f%e7%94%9f%e5%bc%80%e5%8f%91%e7%9a%84%e7%90%86%e8%a7%a3 aria-label="159、谈谈 Electron、Nw.js、CEF、Flutter 和原生开发的理解？">159、谈谈 Electron、Nw.js、CEF、Flutter 和原生开发的理解？</a></li><li><a href=#160%e8%b0%88%e8%b0%88%e6%a1%8c%e9%9d%a2%e7%ab%af%e5%ba%94%e7%94%a8%e4%b8%ad-hotfix-%e7%9a%84%e7%90%86%e8%a7%a3 aria-label="160、谈谈桌面端应用中 HotFix 的理解？">160、谈谈桌面端应用中 HotFix 的理解？</a></li><li><a href=#161%e4%bd%a0%e8%a7%89%e5%be%97%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e5%9c%ba%e6%99%af%e9%9c%80%e8%a6%81%e4%bd%bf%e7%94%a8%e5%be%ae%e5%89%8d%e7%ab%af%e6%a1%86%e6%9e%b6 aria-label=161、你觉得什么样的场景需要使用微前端框架？>161、你觉得什么样的场景需要使用微前端框架？</a></li></ul></li><li><a href=#%e4%b8%9a%e5%8a%a1 aria-label=业务>业务</a><ul><li><a href=#162%e4%bb%80%e4%b9%88%e6%98%af%e5%8d%95%e7%82%b9%e7%99%bb%e5%bd%95%e5%a6%82%e4%bd%95%e5%81%9a%e5%8d%95%e7%82%b9%e7%99%bb%e5%bd%95 aria-label=162、什么是单点登录？如何做单点登录？>162、什么是单点登录？如何做单点登录？</a></li><li><a href=#163%e5%a6%82%e4%bd%95%e5%81%9a%e4%b8%80%e4%b8%aa%e9%a1%b9%e7%9b%ae%e7%9a%84%e5%9b%bd%e9%99%85%e5%8c%96%e6%96%b9%e6%a1%88 aria-label=163、如何做一个项目的国际化方案？>163、如何做一个项目的国际化方案？</a></li><li><a href=#164%e5%a6%82%e4%bd%95%e5%81%9a%e4%b8%80%e4%b8%aa%e9%a1%b9%e7%9b%ae%e7%9a%84%e7%9b%91%e6%8e%a7%e5%92%8c%e5%9f%8b%e7%82%b9%e6%96%b9%e6%a1%88 aria-label=164、如何做一个项目的监控和埋点方案？>164、如何做一个项目的监控和埋点方案？</a></li><li><a href=#165%e5%a6%82%e4%bd%95%e5%bb%ba%e8%ae%be%e9%a1%b9%e7%9b%ae%e7%9a%84%e7%a8%b3%e5%ae%9a%e6%80%a7%e7%9b%91%e6%8e%a7%e7%81%b0%e5%ba%a6%e9%94%99%e8%af%af%e9%99%8d%e7%ba%a7%e5%9b%9e%e6%bb%9a aria-label=165、如何建设项目的稳定性（监控、灰度、错误降级、回滚&amp;hellip;）？>165、如何建设项目的稳定性（监控、灰度、错误降级、回滚&mldr;）？</a></li><li><a href=#166%e4%b8%80%e8%88%ac%e7%ae%a1%e7%90%86%e5%90%8e%e5%8f%b0%e5%9e%8b%e7%9a%84%e5%ba%94%e7%94%a8%e9%9c%80%e8%a6%81%e8%80%83%e8%99%91%e5%93%aa%e4%ba%9b%e6%80%a7%e8%83%bd%e6%96%b9%e9%9d%a2%e7%9a%84%e4%bc%98%e5%8c%96 aria-label=166、一般管理后台型的应用需要考虑哪些性能方面的优化？>166、一般管理后台型的应用需要考虑哪些性能方面的优化？</a></li><li><a href=#167%e7%ae%80%e8%bf%b0%e4%b8%80%e4%ba%9b%e6%8f%90%e5%8d%87%e9%a1%b9%e7%9b%ae%e4%bd%93%e9%aa%8c%e7%9a%84%e6%a1%88%e4%be%8b%e5%92%8c%e6%8a%80%e6%9c%af%e6%96%b9%e6%a1%88%e9%aa%a8%e6%9e%b6%e5%b1%8floading-%e5%a4%84%e7%90%86%e7%bc%93%e5%ad%98%e9%94%99%e8%af%af%e9%99%8d%e7%ba%a7%e8%af%b7%e6%b1%82%e9%87%8d%e8%af%95 aria-label="167、简述一些提升项目体验的案例和技术方案（骨架屏、Loading 处理、缓存、错误降级、请求重试&amp;hellip;）？">167、简述一些提升项目体验的案例和技术方案（骨架屏、Loading 处理、缓存、错误降级、请求重试&mldr;）？</a></li><li><a href=#168%e5%81%87%e8%ae%be%e9%9c%80%e8%a6%81%e5%af%b9%e9%a1%b5%e9%9d%a2%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e6%b0%b4%e5%8d%b0%e6%96%b9%e6%a1%88%e4%bd%a0%e4%bc%9a%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1 aria-label=168、假设需要对页面设计一个水印方案，你会如何设计？>168、假设需要对页面设计一个水印方案，你会如何设计？</a></li></ul></li><li><a href=#%e4%bd%8e%e4%bb%a3%e7%a0%81 aria-label=低代码>低代码</a><ul><li><a href=#169%e5%a6%82%e4%bd%95%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e9%80%9a%e7%94%a8%e7%9a%84-json-schema-%e5%8d%8f%e8%ae%ae%e4%bd%bf%e5%85%b6%e5%8f%af%e4%bb%a5%e5%8a%a8%e6%80%81%e6%b8%b2%e6%9f%93%e4%b8%80%e4%b8%aa%e9%80%9a%e7%94%a8%e7%9a%84%e8%81%94%e5%8a%a8%e8%a1%a8%e5%8d%95 aria-label="169、如何设计一个通用的 JSON Schema 协议使其可以动态渲染一个通用的联动表单？">169、如何设计一个通用的 JSON Schema 协议使其可以动态渲染一个通用的联动表单？</a></li><li><a href=#170%e4%b8%80%e8%88%ac%e7%9a%84%e4%bd%8e%e4%bb%a3%e7%a0%81%e5%b9%b3%e5%8f%b0%e9%9c%80%e8%a6%81%e5%85%b7%e5%a4%87%e5%93%aa%e4%ba%9b%e8%83%bd%e5%8a%9b aria-label=170、一般的低代码平台需要具备哪些能力？>170、一般的低代码平台需要具备哪些能力？</a></li></ul></li></ul></li><li><a href=#%e7%ac%94%e8%af%95%e5%ae%9e%e8%b7%b5 aria-label=笔试实践>笔试实践</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=数据结构>数据结构</a><ul><li><a href=#171%e4%bd%bf%e7%94%a8-typescript-%e8%af%ad%e6%b3%95%e5%b0%86%e6%b2%a1%e6%9c%89%e5%b1%82%e7%ba%a7%e7%9a%84%e6%89%81%e5%b9%b3%e6%95%b0%e6%8d%ae%e8%bd%ac%e6%8d%a2%e6%88%90%e6%a0%91%e5%bd%a2%e7%bb%93%e6%9e%84%e7%9a%84%e6%95%b0%e6%8d%ae aria-label="171、使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据">171、使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据</a></li></ul></li><li><a href=#%e6%a8%a1%e6%9d%bf%e8%a7%a3%e6%9e%90 aria-label=模板解析>模板解析</a><ul><li><a href=#172%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e7%ae%80%e6%98%93%e7%9a%84%e6%a8%a1%e6%9d%bf%e5%bc%95%e6%93%8e aria-label=172、实现一个简易的模板引擎>172、实现一个简易的模板引擎</a></li></ul></li><li><a href=#%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f aria-label=设计模式>设计模式</a><ul><li><a href=#173%e7%ae%80%e5%8d%95%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e5%8f%91%e5%b8%83--%e8%ae%a2%e9%98%85%e6%a8%a1%e5%bc%8f aria-label="173、简单实现一个发布 / 订阅模式">173、简单实现一个发布 / 订阅模式</a></li></ul></li><li><a href=#%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f aria-label=正则表达式>正则表达式</a><ul><li><a href=#174%e5%8c%b9%e9%85%8d%e5%87%ba%e5%ad%97%e7%ac%a6%e4%b8%b2%e4%b8%ad-const-a--requirexxx-%e4%b8%ad%e7%9a%84-xxx aria-label="174、匹配出字符串中 const a = require(&amp;lsquo;xxx&amp;rsquo;) 中的 xxx">174、匹配出字符串中 const a = require(&lsquo;xxx&rsquo;) 中的 xxx</a></li></ul></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>基础知识主要包含以下几个方面：</p><ul><li>基础：计算机原理、编译原理、数据结构、算法、设计模式、编程范式等基本知识了解</li><li>语法：JavaScript、ECMAScript、CSS、TypeScript、HTML、Node.js 等语法的了解和使用</li><li>框架：React、Vue、Egg、Koa、Express、Webpack 等原理的了解和使用</li><li>工程：编译工具、格式工具、Git、NPM、单元测试、Nginx、PM2、CI / CD 了解和使用</li><li>网络：HTTP、TCP、UDP、WebSocket、Cookie、Session、跨域、缓存、协议的了解</li><li>性能：编译性能、监控、白屏检测、SEO、Service Worker 等了解</li><li>插件：Chrome 、Vue CLI 、Webpack 等插件设计思路的理解</li><li>系统：Mac、Windows、Linux 系统配置的实践</li><li>后端：Redis 缓存、数据库、Graphql、SSR、模板引擎等了解和使用</li></ul><h3 id=基础>基础<a hidden class=anchor aria-hidden=true href=#基础>#</a></h3><h4 id=1列举你所了解的计算机存储设备类型>1、列举你所了解的计算机存储设备类型？<a hidden class=anchor aria-hidden=true href=#1列举你所了解的计算机存储设备类型>#</a></h4><p>现代计算机以存储器为中心，主要由 CPU、I / O 设备以及主存储器三大部分组成。各个部分之间通过总线进行连接通信，具体如下图所示：<img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9tjrQYnLEbJYj1tEaYMzCevMXGWXIeCssLUmOlmZXXLMic5zqwKUjK9Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
上图是一种多总线结构的示意图，CPU、主存以及 I / O 设备之间的所有数据都是通过总线进行并行传输，使用局部总线是为了提高 CPU 的吞吐量（CPU 不需要直接跟 I / O 设备通信），而使用高速总线（更贴近 CPU）和 DMA 总线则是为了提升高速 I / O 设备（外设存储器、局域网以及多媒体等）的执行效率。</p><p>主存包括随机存储器 RAM 和只读存储器 ROM，其中 ROM 又可以分为 MROM（一次性）、PROM、EPROM、EEPROM 。ROM 中存储的程序（例如启动程序、固化程序）和数据（例如常量数据）在断电后不会丢失。RAM 主要分为静态 RAM（SRAM） 和动态 RAM（DRAM） 两种类型（DRAM 种类很多，包括 SDRAM、RDRAM、CDRAM 等），断电后数据会丢失，主要用于存储临时程序或者临时变量数据。DRAM 一般访问速度相对较慢。由于现代 CPU 读取速度要求相对较高，因此在 CPU 内核中都会设计 L1、L2 以及 L3 级别的多级高速缓存，这些缓存基本是由 SRAM 构成，一般访问速度较快。</p><h4 id=2一般代码存储在计算机的哪个设备中代码在-cpu-中是如何运行的>2、一般代码存储在计算机的哪个设备中？代码在 CPU 中是如何运行的？<a hidden class=anchor aria-hidden=true href=#2一般代码存储在计算机的哪个设备中代码在-cpu-中是如何运行的>#</a></h4><p>高级程序设计语言不能直接被计算机理解并执行，需要通过翻译程序将其转换成特定处理器上可执行的指令，计算机 CPU 的简单工作原理如下所示：<img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9waSNBvYkJGLRqhuUIbXAdlhv1b1ia29K791Q8mjzN5icibeFSEBeI5u5g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
CPU 主要由控制单元、运算单元和存储单元组成（注意忽略了中断系统），各自的作用如下：</p><ul><li><strong>控制单元</strong>：在节拍脉冲的作用下，将程序计数器（Program Counter，PC）指向的主存或者多级高速缓存中的指令地址送到地址总线，接着获取指令地址所对应的指令并放入指令寄存器 （Instruction Register，IR）中，然后通过指令译码器（Instruction Decoder，ID）分析指令需要进行的操作，最后通过操作控制器（Operation Controller，OC）向其他设备发出微操作控制信号。</li><li><strong>运算单元</strong>：如果控制单元发出的控制信号存在算术运算（加、减、乘、除、增 1、减 1、取反等）或者逻辑运算（与、或、非、异或），那么需要通过运算单元获取存储单元的计算数据进行处理。</li><li><strong>存储单元</strong>：包括片内缓存和寄存器组，是 CPU 中临时数据的存储地方。CPU 直接访问主存数据大概需要花费数百个机器周期，而访问寄存器或者片内缓存只需要若干个或者几十个机器周期，因此会使用内部寄存器或缓存来存储和获取临时数据（即将被运算或者运算之后的数据），从而提高 CPU 的运行效率。</li></ul><p>除此之外，计算机系统执行程序指令时需要花费时间，其中取出一条指令并执行这条指令的时间叫指令周期。指令周期可以分为若干个阶段（取指周期、间址周期、执行周期和中断周期），每个阶段主要完成一项基本操作，完成基本操作的时间叫机器周期。机器周期是时钟周期的分频，例如最经典的 8051 单片机的机器周期为 12 个时钟周期。时钟周期是 CPU 工作的基本时间单位，也可以称为节拍脉冲或 T 周期（CPU 主频的倒数） 。假设 CPU 的主频是 1 GHz（1 Hz 表示每秒运行 1 次），那么表示时钟周期为 1 / 109 s。理论上 CPU 的主频越高，程序指令执行的速度越快。</p><h4 id=3什么是指令和指令集>3、什么是指令和指令集？<a hidden class=anchor aria-hidden=true href=#3什么是指令和指令集>#</a></h4><p>上图右侧主存中的指令是 CPU 可以支持的处理命令，一般包含算术指令（加和减）、逻辑指令（与、或和非）、数据指令（移动、输入、删除、加载和存储）、流程控制指令以及程序结束指令等，由于 CPU 只能识别二进制码，因此指令是由二进制码组成。除此之外，指令的集合称为指令集（例如汇编语言就是指令集的一种表现形式），常见的指令集有精简指令集（ARM）和复杂指令集（Inter X86）。一般指令集决定了 CPU 处理器的硬件架构，规定了处理器的相应操作。</p><h4 id=4复杂指令集和精简指令集有什么区别>4、复杂指令集和精简指令集有什么区别？<a hidden class=anchor aria-hidden=true href=#4复杂指令集和精简指令集有什么区别>#</a></h4><h4 id=5javascript-是如何运行的解释型语言和编译型语言的差异是什么>5、JavaScript 是如何运行的？解释型语言和编译型语言的差异是什么？<a hidden class=anchor aria-hidden=true href=#5javascript-是如何运行的解释型语言和编译型语言的差异是什么>#</a></h4><p>早期的计算机只有机器语言时，程序设计必须用二进制数（0 和 1）来编写程序，并且要求程序员对计算机硬件和指令集非常了解，编程的难度较大，操作极易出错。为了解决机器语言的编程问题，慢慢开始出现了符号式的汇编语言（采用 ADD、SUB、MUL、DIV 等符号代表加减乘除）。为了使得计算机可以识别汇编语言，需要将汇编语言翻译成机器能够识别的机器语言（处理器的指令集）：<img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9icFK2bAkCYah92oDZGQX5VouMVpvPZllRCnQtRer1qX4ibwia08fVT0qg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
由于每一种机器的指令系统不同，需要不同的汇编语言程序与之匹配，因此程序员往往需要针对不同的机器了解其硬件结构和指令系统。为了可以抹平不同机器的指令系统，使得程序员可以更加关注程序设计本身，先后出现了各种面向问题的高级程序设计语言，例如 BASIC 和 C，具体过程如下图所示：<img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9lxtv7INkAPa20ra3hRCKibibeBzLkRYWF2CU05e9EHrSfFW7FC9iaedBg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
高级程序语言会先翻译成汇编语言或者其他中间语言，然后再根据不同的机器翻译成机器语言进行执行。除此之外，汇编语言虚拟机和机器语言机器之间还存在一层操作系统虚拟机，主要用于控制和管理操作系统的全部硬件和软件资源（随着超大规模集成电路技术的不断发展，一些操作系统的软件功能逐步由硬件来替换，例如目前的操作系统已经实现了部分程序的固化，简称固件，将程序永久性的存储在 ROM 中）。机器语言机器还可以继续分解成微程序机器，将每一条机器指令翻译成一组微指令（微程序）进行执行。</p><p>上述虚拟机所提供的语言转换程序被称为编译器，主要作用是将某种语言编写的源程序转换成一个等价的机器语言程序，编译器的作用如下图所示：<img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9sicpnPMVsm2pcQH78jsSjW6NXIExeDKQEtgVCbfb2FoTRfJlHA4HGtQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
例如 C 语言，可以先通过 gcc 编译器生成 Linux 和 Windows 下的目标 .o 和 .obj 文件（object 文件，即目标文件），然后将目标文件与底层系统库文件、应用程序库文件以及启动文件链接成可执行文件在目标机器上执行。</p><blockquote><p>温馨提示：感兴趣的同学可以了解一下 ARM 芯片的程序运行原理，包括使用 IDE 进行程序的编译（IDE 内置编译器，主流编译器包含 ARMCC、IAR 以及 GCC FOR ARM 等，其中一些编译器仅仅随着 IDE 进行捆绑发布，不提供独立使用的能力，而一些编译器则随着 IDE 进行发布的同时，还提供命令行接口的独立使用方式）、通过串口进行程序下载（下载到芯片的代码区初始启动地址映射的存储空间地址）、启动的存储空间地址映射（包括系统存储器、闪存 FLASH、内置 SRAM 等）、芯片的程序启动模式引脚 BOOT 的设置（例如调试代码时常常选择内置 SRAM、真正程序运行的时候选择闪存 FLASH）等。</p></blockquote><p>如果某种高级语言或者应用语言（例如用于人工智能的计算机设计语言）转换的目标语言不是特定计算机的汇编语言，而是面向另一种高级程序语言（很多研究性的编译器将 C 作为目标语言），那么还需要将目标高级程序语言再进行一次额外的编译才能得到最终的目标程序，这种编译器可称为源到源的转换器。</p><p>除此之外，有些程序设计语言将编译的过程和最终转换成目标程序进行执行的过程混合在一起，这种语言转换程序通常被称为解释器，主要作用是将某种语言编写的源程序作为输入，将该源程序执行的结果作为输出，解释器的作用如下图所示：</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9Erup3gMaojIOKxYPk26gibJTIt9JrXzibJf8dHiaqlbaGficF7ibmHu0ZmA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
image.png</p><p>解释器和编译器有很多相似之处，都需要对源程序进行分析，并转换成目标机器可识别的机器语言进行执行。只是解释器是在转换源程序的同时立马执行对应的机器语言（转换和执行的过程不分离），而编译器得先把源程序全部转换成机器语言并产生目标文件，然后将目标文件写入相应的程序存储器进行执行（转换和执行的过程分离）。例如 Perl、Scheme、APL 使用解释器进行转换， C、C++ 则使用编译器进行转换，而 Java 和 JavaScript 的转换既包含了编译过程，也包含了解释过程。</p><h4 id=6简单描述一下-babel-的编译过程>6、简单描述一下 Babel 的编译过程？<a hidden class=anchor aria-hidden=true href=#6简单描述一下-babel-的编译过程>#</a></h4><h4 id=7javascript-中的数组和函数在内存中是如何存储的>7、JavaScript 中的数组和函数在内存中是如何存储的？<a hidden class=anchor aria-hidden=true href=#7javascript-中的数组和函数在内存中是如何存储的>#</a></h4><p>JavaScript 中的数组存储大致需要分为两种情况：</p><ul><li>同种类型数据的数组分配连续的内存空间</li><li>存在非同种类型数据的数组使用哈希映射分配内存空间</li></ul><blockquote><p>温馨提示：可以想象一下连续的内存空间只需要根据索引（指针）直接计算存储位置即可。如果是哈希映射那么首先需要计算索引值，然后如果索引值有冲突的场景下还需要进行二次查找（需要知道哈希的存储方式）。</p></blockquote><h4 id=8浏览器和-nodejs-中的事件循环机制有什么区别>8、浏览器和 Node.js 中的事件循环机制有什么区别？<a hidden class=anchor aria-hidden=true href=#8浏览器和-nodejs-中的事件循环机制有什么区别>#</a></h4><blockquote><p>阅读链接：<strong>面试分享：两年工作经验成功面试阿里P6总结</strong>**[2]** - 了解 Event Loop 吗？</p></blockquote><h4 id=9es6-modules-相对于-commonjs-的优势是什么>9、ES6 Modules 相对于 CommonJS 的优势是什么？<a hidden class=anchor aria-hidden=true href=#9es6-modules-相对于-commonjs-的优势是什么>#</a></h4><h4 id=10高级程序设计语言是如何编译成机器语言的>10、高级程序设计语言是如何编译成机器语言的？<a hidden class=anchor aria-hidden=true href=#10高级程序设计语言是如何编译成机器语言的>#</a></h4><h4 id=11编译器一般由哪几个阶段组成数据类型检查一般在什么阶段进行>11、编译器一般由哪几个阶段组成？数据类型检查一般在什么阶段进行？<a hidden class=anchor aria-hidden=true href=#11编译器一般由哪几个阶段组成数据类型检查一般在什么阶段进行>#</a></h4><h4 id=12编译过程中虚拟机的作用是什么>12、编译过程中虚拟机的作用是什么？<a hidden class=anchor aria-hidden=true href=#12编译过程中虚拟机的作用是什么>#</a></h4><h4 id=13什么是中间代码ir它的作用是什么>13、什么是中间代码（IR），它的作用是什么？<a hidden class=anchor aria-hidden=true href=#13什么是中间代码ir它的作用是什么>#</a></h4><h4 id=14什么是交叉编译>14、什么是交叉编译？<a hidden class=anchor aria-hidden=true href=#14什么是交叉编译>#</a></h4><p>编译器的设计是一个非常庞大和复杂的软件系统设计，在真正设计的时候需要解决两个相对重要的问题：</p><ul><li>如何分析不同高级程序语言设计的源程序</li><li>如何将源程序的功能等价映射到不同指令系统的目标机器</li></ul><p>为了解决上述两项问题，编译器的设计最终被分解成前端（注意这里所说的不是 Web 前端）和后端两个编译阶段，前端用于解决第一个问题，而后端用于解决第二个问题，具体如下图所示：<img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9u6UfQmibvrbE07ONNmsqPIDW8AkAZfauSwwUsb2CwTMTQ3FCDEbBoAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
上图中的中间表示（Intermediate Representation，IR）是程序结构的一种表现方式，它会比 AST（后续讲解）更加接近汇编语言或者指令集，同时也会保留源程序中的一些高级信息，除此之外 ，它的种类很多，包括<strong>三地址码（Three Address Code, TAC）****[3]</strong>、**静态单赋值形式（Static Single Assignment Form, SSA）****[4]**以及基于栈的 IR 等，具体作用包括：</p><ul><li>靠近前端部分主要适配不同的源程序，靠近后端部分主要适配不同的指令集，更易于编译器的错误调试，容易识别是 IR 之前还是之后出问题</li><li>如下左图所示，如果没有 IR，那么源程序到指令集之间需要进行一一适配，而有了中间表示，则可以使得编译器的职责更加分离，源程序的编译更多关注如何转换成 IR，而不是去适配不同的指令集</li><li>IR 本身可以做到多趟迭代从而优化源程序，在每一趟迭代的过程中可以研究代码并记录优化的细节，方便后续的迭代查找并利用这些优化信息，最终可以高效输出更优的目标程序</li></ul><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9eVJspsrtGMvyb6eLbSmibS2hrdtwYMicMs4YqfdibhkKVsx5N6Y1CySCg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
由于 IR 可以进行多趟迭代进行程序优化，因此在编译器中可插入一个新的优化阶段，如下图所示：<img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9E0d50e5y5eT75iceMTYsTBQS5gLyWnYazaJO9RLtqibCAbThv4OhQ3Hw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
优化器可以对 IR 处理一遍或者多遍，从而生成更快执行速度（例如找到循环中不变的计算并对其进行优化从而减少运算次数）或者更小体积的目标程序，也可能用于产生更少异常或者更低功耗的目标程序。除此之外，前端和后端内部还可以细分为多个处理步骤，具体如下图所示：<img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9Vntkww6KPoJ8WiareyS84Uqmic7icHrZCOmaly74Nf0W8yb7jLU0pKK5Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片>
优化器中的每一遍优化处理都可以使用一个或多个优化技术来改进代码，每一趟处理最终都是读写 IR 的操作，这样不仅仅可以使得优化可以更加高效，同时也可以降低优化的复杂度，还提高了优化的灵活性，可以使得编译器配置不同的优化选项，达到组合优化的效果。</p><h4 id=15发布--订阅模式和观察者模式的区别是什么>15、发布 / 订阅模式和观察者模式的区别是什么？<a hidden class=anchor aria-hidden=true href=#15发布--订阅模式和观察者模式的区别是什么>#</a></h4><blockquote><p>阅读链接：<strong>基于Vue实现一个简易MVVM</strong>**[5]** - 观察者模式和发布/订阅模式</p></blockquote><h4 id=16装饰器模式一般会在什么场合使用>16、装饰器模式一般会在什么场合使用？<a hidden class=anchor aria-hidden=true href=#16装饰器模式一般会在什么场合使用>#</a></h4><h4 id=17谈谈你对大型项目的代码解耦设计理解什么是-ioc一般-di-采用什么设计模式实现>17、谈谈你对大型项目的代码解耦设计理解？什么是 Ioc？一般 DI 采用什么设计模式实现？<a hidden class=anchor aria-hidden=true href=#17谈谈你对大型项目的代码解耦设计理解什么是-ioc一般-di-采用什么设计模式实现>#</a></h4><h4 id=18列举你所了解的编程范式>18、列举你所了解的编程范式？<a hidden class=anchor aria-hidden=true href=#18列举你所了解的编程范式>#</a></h4><p>编程范式（Programming paradigm）是指计算机编程的基本风格或者典型模式，可以简单理解为编程学科中实践出来的具有哲学和理论依据的一些经典原型。常见的编程范式有：</p><ul><li>面向过程（Process Oriented Programming，POP）</li><li>面向对象（Object Oriented Programming，OOP）</li><li>面向接口（Interface Oriented Programming， IOP）</li><li>面向切面（Aspect Oriented Programming，AOP）</li><li>函数式（Funtional Programming，FP）</li><li>响应式（Reactive Programming，RP）</li><li>函数响应式（Functional Reactive Programming，FRP）</li></ul><blockquote><p>阅读链接：：如果你对于编程范式的定义相对模糊，可以继续阅读 <strong>What is the precise definition of programming paradigm?****[6]</strong> 了解更多。</p></blockquote><p>不同的语言可以支持多种不同的编程范式，例如 C 语言支持 POP 范式，C++ 和 Java 语言支持 OOP 范式，Swift 语言则可以支持 FP 范式，而 Web 前端中的 JavaScript 可以支持上述列出的所有编程范式。</p><h4 id=19什么是面向切面aop的编程>19、什么是面向切面（AOP）的编程？<a hidden class=anchor aria-hidden=true href=#19什么是面向切面aop的编程>#</a></h4><h4 id=20什么是函数式编程>20、什么是函数式编程？<a hidden class=anchor aria-hidden=true href=#20什么是函数式编程>#</a></h4><p>顾名思义，函数式编程是使用函数来进行高效处理数据或数据流的一种编程方式。在数学中，函数的三要素是定义域、值域和**对应关系。<strong>假设 A、B 是非空数集，对于集合 A 中的任意一个数 x，在集合 B 中都有唯一确定的数 f(x) 和它对应，那么可以将 f 称为从 A 到 B 的一个函数，记作：y = f(x)。在函数式编程中函数的概念和数学函数的概念类似，主要是描述形参 x 和返回值 y 之间的</strong>对应关系，**如下图所示：</p><p><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz/bwG40XYiaOKmQnUneWLhr6ic2rfibM8kVia9DhFoYepiaEFKDyx79bMTlGk3CdkJiaurBjpuHyicdNHzMwY29yR7RK6eA/640?wx_fmt=other&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt=图片></p><blockquote><p>温馨提示：图片来自于<strong>简明 JavaScript 函数式编程——入门篇****[7]</strong>。</p></blockquote><p>在实际的编程中，可以将各种明确<strong>对应关系</strong>的函数进行传递、组合从而达到处理数据的最终目的。在此过程中，我们的关注点不在于如何去实现**对应关系，**而在于如何将各种已有的对应关系进行高效联动，从而可快速进行数据转换，达到最终的数据处理目的，提供开发效率。</p><p><strong>简单示例</strong></p><p>尽管你对函数式编程的概念有所了解，但是你仍然不知道函数式编程到底有什么特点。这里我们仍然拿 OOP 编程范式来举例，假设希望通过 OOP 编程来解决数学的加减乘除问题：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>class MathObject {
</span></span><span style=display:flex><span>  constructor(private value: number) {}
</span></span><span style=display:flex><span>  public add(num: number): MathObject {
</span></span><span style=display:flex><span>    this.value += num;
</span></span><span style=display:flex><span>    return this;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  public multiply(num: number): MathObject {
</span></span><span style=display:flex><span>    this.value *= num;
</span></span><span style=display:flex><span>    return this;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  public getValue(): number {
</span></span><span style=display:flex><span>    return this.value;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const a = new MathObject(1);
</span></span><span style=display:flex><span>a.add(1).multiply(2).add(a.multiply(2).getValue()); 
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>我们希望通过上述程序来解决 (1 + 2) * 2 + 1 * 2 的问题，但实际上计算出来的结果是 24，因为在代码内部有一个 <code>this.value</code> 的状态值需要跟踪，这会使得结果不符合预期。接下来我们采用函数式编程的方式：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function add(a: number, b: number): number {
</span></span><span style=display:flex><span>  return a + b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function multiply(a: number, b: number): number {
</span></span><span style=display:flex><span>  return a * b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const a: number = 1;
</span></span><span style=display:flex><span>const b: number = 2;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>add(multiply(add(a, b), b), multiply(a, b));
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>以上程序计算的结果是 8，完全符合预期。我们知道了 <code>add</code> 和 <code>multiply</code> 两个函数的实际<strong>对应关系</strong>，通过将<strong>对应关系</strong>进行有效的组合和传递，达到了最终的计算结果。除此之外，这两个函数还可以根据数学定律得出更优雅的组合方式：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>add(multiply(add(a, b), b), multiply(a, b));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 根据数学定律分配律：a * b  +  a * c = a * (b + c)，得出：
</span></span><span style=display:flex><span>// (a + b) * b + a * b = (2a + b) * b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 简化上述函数的组合方式
</span></span><span style=display:flex><span>multiply(add(add(a, a), b), b);
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>我们完全不需要追踪类似于 OOP 编程范式中可能存在的内部状态数据，事实上对于数学定律中的结合律、交换律、同一律以及分配律，上述的函数式编程代码足可以胜任。</p><p><strong>原则</strong></p><p>通过上述简单的例子可以发现，要实现高可复用的函数**（对应关系）**，一定要遵循某些特定的原则，否则在使用的时候可能无法进行高效的传递和组合，例如</p><ul><li>高内聚低耦合</li><li>最小意外原则</li><li>单一职责原则</li><li>&mldr;</li></ul><p>如果你之前经常进行无原则性的代码设计，那么在设计过程中可能会出现各种出乎意料的问题（这是为什么新手老是出现一些稀奇古怪问题的主要原因）。函数式编程可以有效的通过一些原则性的约束使你设计出更加健壮和优雅的代码，并且在不断的实践过程中进行经验式叠加，从而提高开发效率。</p><p><strong>特点</strong></p><p>虽然我们在使用函数的过程中更多的不再关注函数如何实现（<strong>对应关系）</strong>，但是真正在使用和设计函数的时候需要注意以下一些特点：</p><ul><li>声明式（Declarative Programming）</li><li>一等公民（First Class Function）</li><li>纯函数（Pure Function）</li><li>无状态和数据不可变（Statelessness and Immutable Data）</li><li>&mldr;</li></ul><p><strong>声明式</strong></p><p>我们以前设计的代码通常是命令式编程方式，这种编程方式往往注重具体的实现的过程（<strong>对应关系</strong>），而函数式编程则采用声明式的编程方式，往往注重如何去组合已有的**对应关系。**简单举个例子：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 命令式
</span></span><span style=display:flex><span>const array = [0.8, 1.7, 2.5, 3.4];
</span></span><span style=display:flex><span>const filterArray = [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>for (let i = 0; i &lt; array.length; i++) {
</span></span><span style=display:flex><span>  const integer = Math.floor(array[i]);
</span></span><span style=display:flex><span>  if (integer &lt; 2) {
</span></span><span style=display:flex><span>    continue;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  filterArray.push(integer);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 声明式
</span></span><span style=display:flex><span>// map 和 filter 不会修改原有数组，而是产生新的数组返回
</span></span><span style=display:flex><span>[0.8, 1.7, 2.5, 3.4].map((item) =&gt; Math.floor(item)).filter((item) =&gt; item &gt; 1);
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>命令式代码一步一步的告诉计算机需要执行哪些语句，需要关心变量的实例化情况、循环的具体过程以及跟踪变量状态的变化过程。声明式代码更多的不再关心代码的具体执行过程，而是采用表达式的组合变换去处理问题，不再强调<strong>怎么做</strong>，而是指明**做什么。**声明式编程方式可以将我们设计代码的关注点彻底从过程式解放出来，从而提高开发效率。</p><p><strong>一等公民</strong></p><p>在 JavaScript 中，函数的使用非常灵活，例如可以对函数进行以下操作：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">49
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">50
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface IHello {
</span></span><span style=display:flex><span>  (name: string): string;
</span></span><span style=display:flex><span>  key?: string;
</span></span><span style=display:flex><span>  arr?: number[];
</span></span><span style=display:flex><span>  fn?(name: string): string;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 函数声明提升
</span></span><span style=display:flex><span>console.log(hello instanceof Object); // true
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 函数声明提升
</span></span><span style=display:flex><span>// hello 和其他引用类型的对象一样，都有属性和方法
</span></span><span style=display:flex><span>hello.key = &#39;key&#39;;
</span></span><span style=display:flex><span>hello.arr = [1, 2];
</span></span><span style=display:flex><span>hello.fn = function (name: string) {
</span></span><span style=display:flex><span>  return `hello.fn, ${name}`;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 函数声明提升
</span></span><span style=display:flex><span>// 注意函数表达式不能在声明前执行，例如不能在这里使用 helloCopy(&#39;world&#39;)
</span></span><span style=display:flex><span>hello(&#39;world&#39;); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 函数
</span></span><span style=display:flex><span>// 创建新的函数对象，将函数的引用指向变量 hello
</span></span><span style=display:flex><span>// hello 仅仅是变量的名称
</span></span><span style=display:flex><span>function hello(name: string): string {
</span></span><span style=display:flex><span>  return `hello, ${name}`;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.log(hello.key); // key
</span></span><span style=display:flex><span>console.log(hello.arr); // [1,2]
</span></span><span style=display:flex><span>console.log(hello.name); // hello
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 函数表达式
</span></span><span style=display:flex><span>const helloCopy: IHello = hello;
</span></span><span style=display:flex><span>helloCopy(&#39;world&#39;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function transferHello(name: string, hello: Hello) {
</span></span><span style=display:flex><span>  return hello(&#39;world&#39;);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 把函数对象当作实参传递
</span></span><span style=display:flex><span>transferHello(&#39;world&#39;, helloCopy);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 把匿名函数当作实参传递
</span></span><span style=display:flex><span>transferHello(&#39;world&#39;, function (name: string) {
</span></span><span style=display:flex><span>  return `hello, ${name}`;
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>通过以上示例可以看出，函数继承至对象并拥有对象的特性。在 JavaScript 中可以对函数进行参数传递、变量赋值或数组操作等等，因此把函数称为一等公民。函数式编程的核心就是对函数进行组合或传递，JavaScript 中函数这种灵活的特性是满足函数式编程的重要条件。</p><p><strong>纯函数</strong></p><p>纯函数是是指在相同的参数调用下，函数的返回值唯一不变。这跟数学中函数的映射关系类似，同样的 x 不可能映射多个不同的 y。使用函数式编程会使得函数的调用非常稳定，从而降低 Bug 产生的机率。当然要实现纯函数的这种特性，需要函数不能包含以下一些副作用：</p><ul><li>操作 Http 请求</li><li>可变数据（包括在函数内部改变输入参数）</li><li>DOM 操作</li><li>打印日志</li><li>访问系统状态</li><li>操作文件系统</li><li>操作数据库</li><li>&mldr;</li></ul><p>从以上常见的一些副作用可以看出，纯函数的实现需要遵循最小意外原则，为了确保函数的稳定唯一的输入和输出，尽量应该避免与函数外部的环境进行任何交互行为，从而防止外部环境对函数内部产生无法预料的影响。纯函数的实现应该自给自足，举几个例子：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 如果使用 const 声明 min 变量（基本数据类型），则可以保证以下函数的纯粹性
</span></span><span style=display:flex><span>let min: number = 1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 非纯函数
</span></span><span style=display:flex><span>// 依赖外部环境变量 min，一旦 min 发生变化则输入和返回不唯一
</span></span><span style=display:flex><span>function isEqual(num: number): boolean {
</span></span><span style=display:flex><span>  return num === min;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 纯函数
</span></span><span style=display:flex><span>function isEqual(num: number): boolean {
</span></span><span style=display:flex><span>  return num === 1;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 非纯函数
</span></span><span style=display:flex><span>function request&lt;T, S&gt;(url: string, params: T): Promise&lt;S&gt; {
</span></span><span style=display:flex><span>  // 会产生请求成功和请求失败两种结果，返回的结果可能不唯一
</span></span><span style=display:flex><span>  return $.getJson(url, params);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 纯函数
</span></span><span style=display:flex><span>function request&lt;T, S&gt;(url: string, params: T) : () =&gt; Promise&lt;S&gt; {
</span></span><span style=display:flex><span>  return function() {
</span></span><span style=display:flex><span>    return $.getJson(url, params);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>纯函数的特性使得函数式编程具备以下特性：</p><ul><li>可缓存性（Cacheable）</li><li>可移植性（Portable）</li><li>可测试性（Testable）</li></ul><p>可缓存性和可测试性基于纯函数输入输出唯一不变的特性，可移植性则主要基于纯函数不依赖外部环境的特性。这里举一个可缓存的例子：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface ICache&lt;T&gt; {
</span></span><span style=display:flex><span>  [arg: string]: T;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>interface ISquare&lt;T&gt; {
</span></span><span style=display:flex><span>  (x: T): T;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 简单的缓存函数（忽略通用性和健壮性）
</span></span><span style=display:flex><span>function memoize&lt;T&gt;(fn: ISquare&lt;T&gt;): ISquare&lt;T&gt; {
</span></span><span style=display:flex><span>  const cache: ICache&lt;T&gt; = {};
</span></span><span style=display:flex><span>  return function (x: T) {
</span></span><span style=display:flex><span>    const arg: string = JSON.stringify(x);
</span></span><span style=display:flex><span>    cache[arg] = cache[arg] || fn.call(fn, x);
</span></span><span style=display:flex><span>    return cache[arg];
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 纯函数
</span></span><span style=display:flex><span>function square(x: number): number {
</span></span><span style=display:flex><span>  return x * x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const memoSquare = memoize&lt;number&gt;(square);
</span></span><span style=display:flex><span>memoSquare(4);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 不会再次调用纯函数 square，而是直接从缓存中获取值
</span></span><span style=display:flex><span>// 由于输入和输出的唯一性，获取缓存结果可靠稳定
</span></span><span style=display:flex><span>// 提升代码的运行效率
</span></span><span style=display:flex><span>memoSquare(4);
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p><strong>无状态和数据不可变</strong></p><p>在函数式编程的简单示例中已经可以清晰的感受到函数式编程绝对不能依赖内部状态，而在纯函数中则说明了函数式编程不能依赖外部的环境或状态，因为一旦依赖的状态变化，不能保证函数根据对应关系所计算的返回值因为状态的变化仍然保持不变。</p><p>这里单独讲解一下数据不可变，在 JavaScript 中有很多数组操作的方法，举个例子：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const arr = [1, 2, 3];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.log(arr.slice(0, 2)); // [1, 2]
</span></span><span style=display:flex><span>console.log(arr); // [1, 2, 3]
</span></span><span style=display:flex><span>console.log(arr.slice(0, 2)); // [1, 2]
</span></span><span style=display:flex><span>console.log(arr); // [1, 2, 3]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.log(arr.splice(0, 1)); // [1]
</span></span><span style=display:flex><span>console.log(arr); // [2, 3]
</span></span><span style=display:flex><span>console.log(arr.splice(0, 1)); // [2]
</span></span><span style=display:flex><span>console.log(arr); // [3]
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>这里的 <code>slice</code> 方法多次调用都不会改变原有数组，且会产生相同的输出。而 <code>splice</code> 每次调用都在修改原数组，且产生的输出也不相同。在函数式编程中，这种会改变原有数据的函数已经不再是纯函数，应该尽量避免使用。</p><blockquote><p>阅读链接：如果想要了解更深入的函数式编程知识点，可以额外阅读<strong>函数式编程指北****[8]</strong>。</p></blockquote><h4 id=21响应式编程的使用场景有哪些>21、响应式编程的使用场景有哪些？<a hidden class=anchor aria-hidden=true href=#21响应式编程的使用场景有哪些>#</a></h4><p>响应式编程是一种基于<strong>观察者（发布 / 订阅）模式</strong>并且面向<strong>异步</strong>（Asynchronous）<strong>数据流</strong>（Data Stream）和<strong>变化传播</strong>的声明式编程范式。响应式编程主要适用的场景包含：</p><ul><li>用户和系统发起的连续事件处理，例如鼠标的点击、键盘的按键或者通信设备发起的信号等</li><li>非可靠的网络或者通信处理（例如 HTTP 网络的请求重试）</li><li>连续的异步 IO 处理</li><li>复杂的继发事务处理（例如一次事件涉及到多个继发的网络请求）</li><li>高并发的消息处理（例如 IM 聊天）</li><li>&mldr;</li></ul><h3 id=语法>语法<a hidden class=anchor aria-hidden=true href=#语法>#</a></h3><h4 id=22如何实现一个上中下三行布局顶部和底部最小高度是-100px中间自适应>22、如何实现一个上中下三行布局，顶部和底部最小高度是 100px，中间自适应?<a hidden class=anchor aria-hidden=true href=#22如何实现一个上中下三行布局顶部和底部最小高度是-100px中间自适应>#</a></h4><h4 id=23如何判断一个元素-css-样式溢出从而可以选择性的加-title-或者-tooltip>23、如何判断一个元素 CSS 样式溢出，从而可以选择性的加 title 或者 Tooltip?<a hidden class=anchor aria-hidden=true href=#23如何判断一个元素-css-样式溢出从而可以选择性的加-title-或者-tooltip>#</a></h4><h4 id=24如何让-css-元素左侧自动溢出-溢出在左侧>24、如何让 CSS 元素左侧自动溢出（&mldr; 溢出在左侧）？<a hidden class=anchor aria-hidden=true href=#24如何让-css-元素左侧自动溢出-溢出在左侧>#</a></h4><p>The <strong><code>direction</code></strong> CSS property sets the direction of text, table columns, and horizontal overflow. Use <code>rtl</code> for languages written from right to left (like Hebrew or Arabic), and <code>ltr</code> for those written from left to right (like English and most other languages).</p><p>具体查看：<strong>developer.mozilla.org/en-US/docs/…****[9]</strong></p><h4 id=25什么是沙箱浏览器的沙箱有什么作用>25、什么是沙箱？浏览器的沙箱有什么作用？<a hidden class=anchor aria-hidden=true href=#25什么是沙箱浏览器的沙箱有什么作用>#</a></h4><h4 id=26如何处理浏览器中表单项的密码自动填充问题>26、如何处理浏览器中表单项的密码自动填充问题？<a hidden class=anchor aria-hidden=true href=#26如何处理浏览器中表单项的密码自动填充问题>#</a></h4><h4 id=27hash-和-history-路由的区别和优缺点>27、Hash 和 History 路由的区别和优缺点？<a hidden class=anchor aria-hidden=true href=#27hash-和-history-路由的区别和优缺点>#</a></h4><h4 id=28javascript-中对象的属性描述符有哪些分别有什么作用>28、JavaScript 中对象的属性描述符有哪些？分别有什么作用？<a hidden class=anchor aria-hidden=true href=#28javascript-中对象的属性描述符有哪些分别有什么作用>#</a></h4><h4 id=29javascript-中-console-有哪些-api->29、JavaScript 中 console 有哪些 api ?<a hidden class=anchor aria-hidden=true href=#29javascript-中-console-有哪些-api->#</a></h4><p>The <strong><code>console</code></strong> object provides access to the browser&rsquo;s debugging console (e.g. the <strong>Web console</strong>**[10]** in Firefox). The specifics of how it works varies from browser to browser, but there is a <em>de facto</em> set of features that are typically provided.</p><p>这里列出一些我常用的 API:</p><ul><li>console.log</li><li>console.error</li><li>console.time</li><li>console.timeEnd</li><li>console.group</li></ul><p>具体查看：<strong>developer.mozilla.org/en-US/docs/…****[11]</strong></p><h4 id=30-简单对比一下-callbackpromisegeneratorasync-几个异步-api-的优劣>30、 简单对比一下 Callback、Promise、Generator、Async 几个异步 API 的优劣？<a hidden class=anchor aria-hidden=true href=#30-简单对比一下-callbackpromisegeneratorasync-几个异步-api-的优劣>#</a></h4><p>在 JavaScript 中利用<strong>事件循环机制****[12]</strong>（Event Loop）可以在单线程中实现非阻塞式、异步的操作。例如</p><ul><li>Node.js 中的 Callback、<strong>EventEmitter</strong>**[13]<strong>、<strong>Stream</strong>**[14]</strong></li><li>ES6 中的 <strong>Promise</strong>**[15]<strong>、<strong>Generator</strong>**[16]</strong></li><li>ES2017 中的 <strong>Async</strong>**[17]**</li><li>三方库 RxJS、<strong>Q</strong>**[18]** 、<strong>Co、****[19]<strong><strong>Bluebird</strong></strong>[20]</strong></li></ul><p>我们重点来看一下常用的几种编程方式（Callback、Promise、Generator、Async）在语法糖上带来的优劣对比。</p><p><strong>Callback</strong></p><p>Callback（回调函数）是在 Web 前端开发中经常会使用的编程方式。这里举一个常用的定时器示例：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>export interface IObj {
</span></span><span style=display:flex><span>  value: string;
</span></span><span style=display:flex><span>  deferExec(): void;
</span></span><span style=display:flex><span>  deferExecAnonymous(): void;
</span></span><span style=display:flex><span>  console(): void;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export const obj: IObj = {
</span></span><span style=display:flex><span>  value: &#39;hello&#39;,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  deferExecBind() {
</span></span><span style=display:flex><span>    // 使用箭头函数可达到一样的效果
</span></span><span style=display:flex><span>    setTimeout(this.console.bind(this), 1000);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  deferExec() {
</span></span><span style=display:flex><span>    setTimeout(this.console, 1000);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  console() {
</span></span><span style=display:flex><span>    console.log(this.value);
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>obj.deferExecBind(); // hello
</span></span><span style=display:flex><span>obj.deferExec(); // undefined
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>回调函数经常会因为调用环境的变化而导致 <code>this</code> 的指向性变化。除此之外，使用回调函数来处理多个继发的异步任务时容易导致回调地狱（Callback Hell）:</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>fs.readFile(fileA, &#39;utf-8&#39;, function (err, data) {
</span></span><span style=display:flex><span>  fs.readFile(fileB, &#39;utf-8&#39;, function (err, data) {
</span></span><span style=display:flex><span>    fs.readFile(fileC, &#39;utf-8&#39;, function (err, data) {
</span></span><span style=display:flex><span>      fs.readFile(fileD, &#39;utf-8&#39;, function (err, data) {
</span></span><span style=display:flex><span>        // 假设在业务中 fileD 的读写依次依赖 fileA、fileB 和 fileC
</span></span><span style=display:flex><span>        // 或者经常也可以在业务中看到多个 HTTP 请求的操作有前后依赖（继发 HTTP 请求）
</span></span><span style=display:flex><span>        // 这些异步任务之间纵向嵌套强耦合，无法进行横向复用
</span></span><span style=display:flex><span>        // 如果某个异步发生变化，那它的所有上层或下层回调可能都需要跟着变化（比如 fileA 和 fileB 的依赖关系倒置）
</span></span><span style=display:flex><span>        // 因此称这种现象为 回调地狱
</span></span><span style=display:flex><span>        // ....
</span></span><span style=display:flex><span>      });
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>回调函数不能通过 <code>return</code> 返回数据，比如我们希望调用带有回调参数的函数并返回异步执行的结果时，只能通过再次回调的方式进行参数传递：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 希望延迟 3s 后执行并拿到结果
</span></span><span style=display:flex><span>function getAsyncResult(result: number) {
</span></span><span style=display:flex><span>  setTimeout(() =&gt; {
</span></span><span style=display:flex><span>    return result * 3;
</span></span><span style=display:flex><span>  }, 1000);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 尽管这是常规的编程思维方式
</span></span><span style=display:flex><span>const result = getAsyncResult(3000);
</span></span><span style=display:flex><span>// 但是打印 undefined
</span></span><span style=display:flex><span>console.log(&#39;result: &#39;, result);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function getAsyncResultWithCb(result: number, cb: (result: number) =&gt; void) {
</span></span><span style=display:flex><span>  setTimeout(() =&gt; {
</span></span><span style=display:flex><span>    cb(result * 3);
</span></span><span style=display:flex><span>  }, 1000);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 通过回调的形式获取结果
</span></span><span style=display:flex><span>getAsyncResultWithCb(3000, (result) =&gt; {
</span></span><span style=display:flex><span>  console.log(&#39;result: &#39;, result); // 9000
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>对于 JavaScript 中标准的异步 API 可能无法通过在外部进行 <code>try...catch...</code> 的方式进行错误捕获：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>try {
</span></span><span style=display:flex><span>  setTimeout(() =&gt; {
</span></span><span style=display:flex><span>    // 下述是异常代码
</span></span><span style=display:flex><span>    // 你可以在回调函数的内部进行 try...catch...
</span></span><span style=display:flex><span>    console.log(a.b.c)
</span></span><span style=display:flex><span>  }, 1000)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>} catch(err) {
</span></span><span style=display:flex><span>  // 这里不会执行
</span></span><span style=display:flex><span>  // 进程会被终止
</span></span><span style=display:flex><span>  console.error(err)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>上述示例讲述的都是 JavaScript 中标准的异步 API ，如果使用一些三方的异步 API 并且提供了回调能力时，这些 API 可能是非受信的，在真正使用的时候会因为<strong>执行反转</strong>（回调函数的执行权在三方库中）导致以下一些问题：</p><ul><li>使用者的回调函数设计没有进行错误捕获，而恰恰三方库进行了错误捕获却没有抛出错误处理信息，此时使用者很难感知到自己设计的回调函数是否有错误</li><li>使用者难以感知到三方库的回调时机和回调次数，这个回调函数执行的权利控制在三方库手中</li><li>使用者无法更改三方库提供的回调参数，回调参数可能无法满足使用者的诉求</li><li>&mldr;</li></ul><p>举个简单的例子：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">44
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">45
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">46
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">47
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">48
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">49
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>interface ILib&lt;T&gt; {
</span></span><span style=display:flex><span>  params: T;
</span></span><span style=display:flex><span>  emit(params: T): void;
</span></span><span style=display:flex><span>  on(callback: (params: T) =&gt; void): void;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 假设以下是一个三方库，并发布成了npm 包
</span></span><span style=display:flex><span>export const lib: ILib&lt;string&gt; = {
</span></span><span style=display:flex><span>  params: &#39;&#39;,
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  emit(params) {
</span></span><span style=display:flex><span>    this.params = params;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  on(callback) {
</span></span><span style=display:flex><span>    try {
</span></span><span style=display:flex><span>      // callback 回调执行权在 lib 上
</span></span><span style=display:flex><span>      // lib 库可以决定回调执行多次
</span></span><span style=display:flex><span>      callback(this.params);
</span></span><span style=display:flex><span>      callback(this.params);
</span></span><span style=display:flex><span>      callback(this.params);
</span></span><span style=display:flex><span>      // lib 库甚至可以决定回调延迟执行
</span></span><span style=display:flex><span>      // 异步执行回调函数
</span></span><span style=display:flex><span>      setTimeout(() =&gt; {
</span></span><span style=display:flex><span>        callback(this.params);
</span></span><span style=display:flex><span>      }, 3000);
</span></span><span style=display:flex><span>    } catch (err) {
</span></span><span style=display:flex><span>      // 假设 lib 库的捕获没有抛出任何异常信息
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 开发者引入 lib 库开始使用
</span></span><span style=display:flex><span>lib.emit(&#39;hello&#39;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>lib.on((value) =&gt; {
</span></span><span style=display:flex><span>  // 使用者希望 on 里的回调只执行一次
</span></span><span style=display:flex><span> // 这里的回调函数的执行时机是由三方库 lib 决定
</span></span><span style=display:flex><span>  // 实际上打印四次，并且其中一次是异步执行
</span></span><span style=display:flex><span>  console.log(value);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>lib.on((value) =&gt; {
</span></span><span style=display:flex><span>  // 下述是异常代码
</span></span><span style=display:flex><span>  // 但是执行下述代码不会抛出任何异常信息
</span></span><span style=display:flex><span>  // 开发者无法感知自己的代码设计错误
</span></span><span style=display:flex><span>  console.log(value.a.b.c)
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p><strong>Promise</strong></p><p>Callback 的异步操作形式除了会造成回调地狱，还会造成难以测试的问题。ES6 中的 Promise （基于 <strong>Promise A +****[21]</strong> 规范的异步编程解决方案）利用**有限状态机****[22]**的原理来解决异步的处理问题，Promise 对象提供了统一的异步编程 API，它的特点如下：</p><ul><li>Promise 对象的执行状态不受外界影响。Promise 对象的异步操作有三种状态： <code>pending</code>（进行中）、 <code>fulfilled</code>（已成功）和 <code>rejected</code>（已失败） ，只有 Promise 对象本身的异步操作结果可以决定当前的执行状态，任何其他的操作无法改变状态的结果</li><li>Promise 对象的执行状态不可变。Promise 的状态只有两种变化可能：从 <code>pending</code>（进行中）变为 <code>fulfilled</code>（已成功）或从 <code>pending</code>（进行中）变为 <code>rejected</code>（已失败）</li></ul><blockquote><p>温馨提示：有限状态机提供了一种优雅的解决方式，异步的处理本身可以通过异步状态的变化来触发相应的操作，这会比回调函数在逻辑上的处理更加合理，也可以降低代码的复杂度。</p></blockquote><p>Promise 对象的执行状态不可变示例如下：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const promise = new Promise&lt;number&gt;((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>  // 状态变更为 fulfilled 并返回结果 1 后不会再变更状态
</span></span><span style=display:flex><span>  resolve(1);
</span></span><span style=display:flex><span>  // 不会变更状态
</span></span><span style=display:flex><span>  reject(4);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>promise
</span></span><span style=display:flex><span>  .then((result) =&gt; {
</span></span><span style=display:flex><span>    // 在 ES 6 中 Promise 的 then 回调执行是异步执行（微任务）
</span></span><span style=display:flex><span>    // 在当前 then 被调用的那轮事件循环（Event Loop）的末尾执行
</span></span><span style=display:flex><span>    console.log(&#39;result: &#39;, result);
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  .catch((error) =&gt; {
</span></span><span style=display:flex><span>    // 不执行
</span></span><span style=display:flex><span>    console.error(&#39;error: &#39;, error);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>假设要实现两个继发的 HTTP 请求，第一个请求接口返回的数据是第二个请求接口的参数，使用回调函数的实现方式如下所示（这里使用 <code>setTimeout</code> 来指代异步请求）：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 回调地狱
</span></span><span style=display:flex><span>const doubble = (result: number, callback: (finallResult: number) =&gt; void) =&gt; {
</span></span><span style=display:flex><span>  // Mock 第一个异步请求
</span></span><span style=display:flex><span>  setTimeout(() =&gt; {
</span></span><span style=display:flex><span>    // Mock 第二个异步请求（假设第二个请求的参数依赖第一个请求的返回结果）
</span></span><span style=display:flex><span>    setTimeout(() =&gt; {
</span></span><span style=display:flex><span>      callback(result * 2);
</span></span><span style=display:flex><span>    }, 2000);
</span></span><span style=display:flex><span>  }, 1000);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>doubble(1000, (result) =&gt; {
</span></span><span style=display:flex><span>  console.log(&#39;result: &#39;, result);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><blockquote><p>温馨提示：继发请求的依赖关系非常常见，例如人员基本信息管理系统的开发中，经常需要先展示组织树结构，并默认加载第一个组织下的人员列表信息。</p></blockquote><p>如果采用 Promise 的处理方式则可以规避上述常见的回调地狱问题：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // Mock 异步请求
</span></span><span style=display:flex><span>    // 将 resolve 改成 reject 会被 catch 捕获
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // Mock 异步请求
</span></span><span style=display:flex><span>    // 将 resolve 改成 reject 会被 catch 捕获
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>firstPromise(1000)
</span></span><span style=display:flex><span>  .then((result) =&gt; {
</span></span><span style=display:flex><span>    return nextPromise(result);
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  .then((result) =&gt; {
</span></span><span style=display:flex><span>    // 2s 后打印 2000
</span></span><span style=display:flex><span>    console.log(&#39;result: &#39;, result);
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  // 任何一个 Promise 到达 rejected 状态都能被 catch 捕获
</span></span><span style=display:flex><span>  .catch((err) =&gt; {
</span></span><span style=display:flex><span>    console.error(&#39;err: &#39;, err);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>Promise 的错误回调可以同时捕获 <code>firstPromise</code> 和 <code>nextPromise</code> 两个函数的 <code>rejected</code> 状态。接下来考虑以下调用场景：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // Mock 异步请求
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // Mock 异步请求
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>firstPromise(1000)
</span></span><span style=display:flex><span>  .then((result) =&gt; {
</span></span><span style=display:flex><span>    nextPromise(result).then((result) =&gt; {
</span></span><span style=display:flex><span>      // 后打印
</span></span><span style=display:flex><span>      console.log(&#39;nextPromise result: &#39;, result);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  .then((result) =&gt; {
</span></span><span style=display:flex><span>    // 先打印
</span></span><span style=display:flex><span>    // 由于上一个 then 没有返回值，这里打印 undefined
</span></span><span style=display:flex><span>    console.log(&#39;firstPromise result: &#39;, result);
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  .catch((err) =&gt; {
</span></span><span style=display:flex><span>    console.error(&#39;err: &#39;, err);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>首先 Promise 可以注册多个 <code>then</code>（放在一个执行队列里），并且这些 <code>then</code> 会根据上一次返回值的结果依次执行。除此之外，各个 Promise 的 <code>then</code> 执行互不干扰。我们将示例进行简单的变换：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // Mock 异步请求
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // Mock 异步请求
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>firstPromise(1000)
</span></span><span style=display:flex><span>  .then((result) =&gt; {
</span></span><span style=display:flex><span>    // 返回了 nextPromise 的 then 执行后的结果
</span></span><span style=display:flex><span>    return nextPromise(result).then((result) =&gt; {
</span></span><span style=display:flex><span>      return result;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  // 接着 nextPromise 的 then 执行的返回结果继续执行
</span></span><span style=display:flex><span>  .then((result) =&gt; {
</span></span><span style=display:flex><span>    // 2s 后打印 2000
</span></span><span style=display:flex><span>    console.log(&#39;nextPromise result: &#39;, result);
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  .catch((err) =&gt; {
</span></span><span style=display:flex><span>    console.error(&#39;err: &#39;, err);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>上述例子中的执行结果是因为 <code>then</code> 的执行会返回一个新的 Promise 对象，并且如果 <code>then</code> 执行后返回的仍然是 Promise 对象，那么下一个 <code>then</code> 的链式调用会等待该 Promise 对象的状态发生变化后才会调用（能得到这个 Promise 处理的结果）。接下来重点看下 Promise 的错误处理：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const promise = new Promise&lt;string&gt;((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>  // 下述是异常代码
</span></span><span style=display:flex><span>  console.log(a.b.c);
</span></span><span style=display:flex><span>  resolve(&#39;hello&#39;);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>promise
</span></span><span style=display:flex><span>  .then((result) =&gt; {
</span></span><span style=display:flex><span>    console.log(&#39;result: &#39;, result);
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  // 去掉 catch 仍然会抛出错误，但不会退出进程终止脚本执行
</span></span><span style=display:flex><span>  .catch((err) =&gt; {
</span></span><span style=display:flex><span>    // 执行
</span></span><span style=display:flex><span>    // ReferenceError: a is not defined
</span></span><span style=display:flex><span>    console.error(err);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>setTimeout(() =&gt; {
</span></span><span style=display:flex><span>  // 继续执行
</span></span><span style=display:flex><span>  console.log(&#39;hello world!&#39;);
</span></span><span style=display:flex><span>}, 2000);
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>从上述示例可以看出 Promise 的错误不会影响其他代码的执行，只会影响 Promise 内部的代码本身，因为Promise 会在内部对错误进行异常捕获，从而保证整体代码执行的稳定性。Promise 还提供了其他的一些 API 方便多任务的执行，包括</p><ul><li><code>Promise.all</code>：适合多个异步任务并发执行但不允许其中任何一个任务失败</li><li><code>Promise.race</code> ：适合多个异步任务抢占式执行</li><li><code>Promise.allSettled</code> ：适合多个异步任务并发执行但允许某些任务失败</li></ul><p>Promise 相对于 Callback 对于异步的处理更加优雅，并且能力也更加强大， 但是也存在一些自身的缺点：</p><ul><li>无法取消 Promise 的执行</li><li>无法在 Promise 外部通过 <code>try...catch...</code> 的形式进行错误捕获（Promise 内部捕获了错误）</li><li>状态单一，每次决断只能产生一种状态结果，需要不停的进行链式调用</li></ul><blockquote><p>温馨提示：手写 Promise 是面试官非常喜欢的一道笔试题，本质是希望面试者能够通过底层的设计正确了解 Promise 的使用方式，如果你对 Promise 的设计原理不熟悉，可以深入了解一下或者手动设计一个。</p></blockquote><p><strong>Generator</strong></p><p>Promise 解决了 Callback 的回调地狱问题，但也造成了代码冗余，如果一些异步任务不支持 Promise 语法，就需要进行一层 Promise 封装。Generator 将 JavaScript 的异步编程带入了一个全新的阶段，它使得异步代码的设计和执行看起来和同步代码一致。Generator 使用的简单示例如下：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">34
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 在 Generator 函数里执行的异步代码看起来和同步代码一致
</span></span><span style=display:flex><span>function* gen(result: number): Generator&lt;Promise&lt;number&gt;, Promise&lt;number&gt;, number&gt; {
</span></span><span style=display:flex><span>  // 异步代码
</span></span><span style=display:flex><span>  const firstResult = yield firstPromise(result)
</span></span><span style=display:flex><span>  console.log(&#39;firstResult: &#39;, firstResult) // 2
</span></span><span style=display:flex><span> // 异步代码
</span></span><span style=display:flex><span>  const nextResult = yield nextPromise(firstResult)
</span></span><span style=display:flex><span>  console.log(&#39;nextResult: &#39;, nextResult) // 6
</span></span><span style=display:flex><span>  return nextPromise(firstResult)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const g = gen(1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 手动执行 Generator 函数
</span></span><span style=display:flex><span>g.next().value.then((res: number) =&gt; {
</span></span><span style=display:flex><span>  // 将 firstPromise 的返回值传递给第一个 yield 表单式对应的 firstResult
</span></span><span style=display:flex><span>  return g.next(res).value
</span></span><span style=display:flex><span>}).then((res: number) =&gt; {
</span></span><span style=display:flex><span>  // 将 nextPromise 的返回值传递给第二个 yield 表单式对应的 nextResult
</span></span><span style=display:flex><span>  return g.next(res).value
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>通过上述代码，可以看出 Generator 相对于 Promise 具有以下优势：</p><ul><li>丰富了状态类型，Generator 通过 <code>next</code> 可以产生不同的状态信息，也可以通过 <code>return</code> 结束函数的执行状态，相对于 Promise 的 <code>resolve</code> 不可变状态更加丰富</li><li>Generator 函数内部的异步代码执行看起来和同步代码执行一致，非常利于代码的维护</li><li>Generator 函数内部的执行逻辑和相应的状态变化逻辑解耦，降低了代码的复杂度</li></ul><p><code>next</code> 可以不停的改变状态使得 <code>yield</code> 得以继续执行的代码可以变得非常有规律，例如从上述的<strong>手动执行 Generator 函数</strong>可以看出，完全可以将其封装成一个自动执行的执行器，具体如下所示：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">37
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">38
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">39
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">40
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">41
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">42
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">43
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">44
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type Gen =  Generator&lt;Promise&lt;number&gt;, Promise&lt;number&gt;, number&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function* gen(): Gen {
</span></span><span style=display:flex><span>  const firstResult = yield firstPromise(1)
</span></span><span style=display:flex><span>  console.log(&#39;firstResult: &#39;, firstResult) // 2
</span></span><span style=display:flex><span>  const nextResult = yield nextPromise(firstResult)
</span></span><span style=display:flex><span>  console.log(&#39;nextResult: &#39;, nextResult) // 6
</span></span><span style=display:flex><span>  return nextPromise(firstResult)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// Generator 自动执行器
</span></span><span style=display:flex><span>function co(gen: () =&gt; Gen) {
</span></span><span style=display:flex><span>  const g = gen()
</span></span><span style=display:flex><span>  function next(data: number) {
</span></span><span style=display:flex><span>    const result = g.next(data)
</span></span><span style=display:flex><span>    if(result.done) {
</span></span><span style=display:flex><span>      return result.value
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    result.value.then(data =&gt; {
</span></span><span style=display:flex><span>      // 通过递归的方式处理相同的逻辑
</span></span><span style=display:flex><span>      next(data)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  // 第一次调用 next 主要用于启动 Generator 函数
</span></span><span style=display:flex><span>  // 内部指针会从函数头部开始执行，直到遇到第一个 yield 表达式
</span></span><span style=display:flex><span>  // 因此第一次 next 传递的参数没有任何含义（这里传递只是为了防止 TS 报错）
</span></span><span style=display:flex><span>  next(0)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>co(gen)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><blockquote><p>温馨提示：<strong>TJ Holowaychuk</strong>**[23]** 设计了一个 Generator 自动执行器 <strong>Co</strong>**[24]<strong>，使用 Co 的前提是 <code>yield</code> 命令后必须是 Promise 对象或者 Thunk 函数。Co 还可以支持并发的异步处理，具体可查看官方的 <strong>API 文档</strong>**[25]</strong>。</p></blockquote><p>需要注意的是 Generator 函数的返回值是一个 Iterator 遍历器对象，具体如下所示：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type Gen = Generator&lt;Promise&lt;number&gt;&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function* gen(): Gen {
</span></span><span style=display:flex><span>  yield firstPromise(1);
</span></span><span style=display:flex><span>  yield nextPromise(2);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 注意使用 next 是继发执行，而这里是并发执行
</span></span><span style=display:flex><span>Promise.all([...gen()]).then((res) =&gt; {
</span></span><span style=display:flex><span>  console.log(&#39;res: &#39;, res);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>for (const promise of gen()) {
</span></span><span style=display:flex><span>  promise.then((res) =&gt; {
</span></span><span style=display:flex><span>    console.log(&#39;res: &#39;, res);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>Generator 函数的错误处理相对复杂一些，极端情况下需要对执行和 Generator 函数进行双重错误捕获，具体如下所示：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">33
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">34
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">35
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">36
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">37
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // 需要注意这里的reject 没有被捕获
</span></span><span style=display:flex><span>    setTimeout(() =&gt; reject(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type Gen = Generator&lt;Promise&lt;number&gt;&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>function* gen(): Gen {
</span></span><span style=display:flex><span>  try {
</span></span><span style=display:flex><span>    yield firstPromise(1);
</span></span><span style=display:flex><span>    yield nextPromise(2);
</span></span><span style=display:flex><span>  } catch (err) {
</span></span><span style=display:flex><span>    console.error(&#39;Generator 函数错误捕获: &#39;, err);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>try {
</span></span><span style=display:flex><span>  const g = gen();
</span></span><span style=display:flex><span>  g.next();
</span></span><span style=display:flex><span>  // 返回 Promise 后还需要通过 Promise.prototype.catch 进行错误捕获
</span></span><span style=display:flex><span>  g.next();
</span></span><span style=display:flex><span>  // Generator 函数错误捕获
</span></span><span style=display:flex><span>  g.throw(&#39;err&#39;);
</span></span><span style=display:flex><span>  // 执行器错误捕获
</span></span><span style=display:flex><span>  g.throw(&#39;err&#39;);
</span></span><span style=display:flex><span>} catch (err) {
</span></span><span style=display:flex><span>  console.error(&#39;执行错误捕获: &#39;, err);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>在使用 <code>g.throw</code> 的时候还需要注意以下一些事项：</p><ul><li>如果 Generator 函数本身没有捕获错误，那么 Generator 函数内部抛出的错误可以在执行处进行错误捕获</li><li>如果 Generator 函数内部和执行处都没有进行错误捕获，则终止进程并抛出错误信息</li><li>如果没有执行过 <code>g.next</code>，则 <code>g.throw</code> 不会在 Gererator 函数中被捕获（因为执行指针没有启动 Generator 函数的执行），此时可以在执行处进行执行错误捕获</li></ul><p><strong>Async</strong></p><p>Async 是 Generator 函数的语法糖，相对于 Generator 而言 Async 的特性如下：</p><ul><li>内置执行器：Generator 函数需要设计手动执行器或者通用执行器（例如 Co 执行器）进行执行，Async 语法则内置了自动执行器，设计代码时无须关心执行步骤</li><li><code>yield</code> 命令无约束：在 Generator 中使用 Co 执行器时 <code>yield</code> 后必须是 Promise 对象或者 Thunk 函数，而 Async 语法中的 <code>await</code> 后可以是 Promise 对象或者原始数据类型对象、数字、字符串、布尔值等（此时会对其进行 <code>Promise.resolve()</code> 包装处理）</li><li>返回 Promise： <code>async</code> 函数的返回值是 Promise 对象（返回原始数据类型会被 Promise 进行封装）， 因此还可以作为 <code>await</code> 的命令参数，相对于 Generator 返回 Iterator 遍历器更加简洁实用</li></ul><p>举个简单的示例：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>async function co() {
</span></span><span style=display:flex><span>  const firstResult = await firstPromise(1);
</span></span><span style=display:flex><span>  // 1s 后打印 2
</span></span><span style=display:flex><span>  console.log(&#39;firstResult: &#39;, firstResult); 
</span></span><span style=display:flex><span>  // 等待 firstPromise 的状态发生变化后执行
</span></span><span style=display:flex><span>  const nextResult = await nextPromise(firstResult);
</span></span><span style=display:flex><span>  // 2s 后打印 6
</span></span><span style=display:flex><span>  console.log(&#39;nextResult: &#39;, nextResult); 
</span></span><span style=display:flex><span>  return nextResult;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>co();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>co().then((res) =&gt; {
</span></span><span style=display:flex><span>  console.log(&#39;res: &#39;, res); // 6
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>通过上述示例可以看出，<code>async</code> 函数的特性如下：</p><ul><li>调用 <code>async</code> 函数后返回的是一个 Promise 对象，通过 <code>then</code> 回调可以拿到 async 函数内部 <code>return</code> 语句的返回值</li><li>调用 <code>async</code> 函数后返回的 Promise 对象必须等待内部所有 <code>await</code> 对应的 Promise 执行完（这使得 <code>async</code> 函数可能是阻塞式执行）后才会发生状态变化，除非中途遇到了 <code>return</code> 语句</li><li><code>await</code> 命令后如果是 Promise 对象，则返回 Promise 对象处理后的结果，如果是原始数据类型，则直接返回原始数据类型</li></ul><p>上述代码是阻塞式执行，<code>nextPromise</code> 需要等待 <code>firstPromise</code> 执行完成后才能继续执行，如果希望两者能够并发执行，则可以进行下述设计：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>async function co() {
</span></span><span style=display:flex><span>  return await Promise.all([firstPromise(1), nextPromise(1)]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>co().then((res) =&gt; {
</span></span><span style=display:flex><span>  console.log(&#39;res: &#39;, res); // [2,3]
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>除了使用 Promise 自带的并发执行 API，也可以通过让所有的 Promise 提前并发执行来处理：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">32
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    console.log(&#39;firstPromise&#39;);
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 2), 10000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    console.log(&#39;nextPromise&#39;);
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>async function co() {
</span></span><span style=display:flex><span>  // 执行 firstPromise
</span></span><span style=display:flex><span>  const first = firstPromise(1);
</span></span><span style=display:flex><span>  // 和 firstPromise 同时执行 nextPromise
</span></span><span style=display:flex><span>  const next = nextPromise(1);
</span></span><span style=display:flex><span>  // 等待 firstPromise 结果回来
</span></span><span style=display:flex><span>  const firstResult = await first;
</span></span><span style=display:flex><span>  console.log(&#39;firstResult: &#39;, firstResult);
</span></span><span style=display:flex><span>  // 等待 nextPromise 结果回来
</span></span><span style=display:flex><span>  const nextResult = await next;
</span></span><span style=display:flex><span>  console.log(&#39;nextResult: &#39;, nextResult);
</span></span><span style=display:flex><span>  return nextResult;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>co().then((res) =&gt; {
</span></span><span style=display:flex><span>  console.log(&#39;res: &#39;, res); // 3
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p>Async 的错误处理相对于 Generator 会更加简单，具体示例如下所示：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // Promise 决断错误
</span></span><span style=display:flex><span>    setTimeout(() =&gt; reject(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>async function co() {
</span></span><span style=display:flex><span>  const firstResult = await firstPromise(1);
</span></span><span style=display:flex><span>  console.log(&#39;firstResult: &#39;, firstResult);
</span></span><span style=display:flex><span>  const nextResult = await nextPromise(1);
</span></span><span style=display:flex><span>  console.log(&#39;nextResult: &#39;, nextResult);
</span></span><span style=display:flex><span>  return nextResult;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>co()
</span></span><span style=display:flex><span>  .then((res) =&gt; {
</span></span><span style=display:flex><span>    console.log(&#39;res: &#39;, res);
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  .catch((err) =&gt; {
</span></span><span style=display:flex><span>    console.error(&#39;err: &#39;, err); // err: 2
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><p><code>async</code> 函数内部抛出的错误，会导致函数返回的 Promise 对象变为 <code>rejected</code> 状态，从而可以通过 <code>catch</code> 捕获， 上述代码只是一个粗粒度的容错处理，如果希望 <code>firstPromise</code> 错误后可以继续执行 <code>nextPromise</code>，则可以通过 <code>try...catch...</code> 在 <code>async</code> 函数里进行局部错误捕获：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">30
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">31
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">32
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">33
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const firstPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    // Promise 决断错误
</span></span><span style=display:flex><span>    setTimeout(() =&gt; reject(result * 2), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nextPromise = (result: number): Promise&lt;number&gt; =&gt; {
</span></span><span style=display:flex><span>  return new Promise((resolve, reject) =&gt; {
</span></span><span style=display:flex><span>    setTimeout(() =&gt; resolve(result * 3), 1000);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>async function co() {
</span></span><span style=display:flex><span>  try {
</span></span><span style=display:flex><span>    await firstPromise(1);
</span></span><span style=display:flex><span>  } catch (err) {
</span></span><span style=display:flex><span>    console.error(&#39;err: &#39;, err); // err: 2
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  // nextPromise 继续执行
</span></span><span style=display:flex><span>  const nextResult = await nextPromise(1);
</span></span><span style=display:flex><span>  return nextResult;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>co()
</span></span><span style=display:flex><span>  .then((res) =&gt; {
</span></span><span style=display:flex><span>    console.log(&#39;res: &#39;, res); // res: 3
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>  .catch((err) =&gt; {
</span></span><span style=display:flex><span>    console.error(&#39;err: &#39;, err);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><blockquote><p>温馨提示：Callback 是 Node.js 中经常使用的编程方式，Node.js 中很多原生的 API 都是采用 Callback 的形式进行异步设计，早期的 Node.js 经常会有 Callback 和 Promise 混用的情况，并且在很长一段时间里都没有很好的支持 Async 语法。如果你对 Node.js 和它的替代品 Deno 感兴趣，可以观看 Ryan Dahl 在 TS Conf 2019 中的经典演讲 <strong>Deno is a New Way to JavaScript</strong>**[26]**。</p></blockquote><h4 id=31-objectdefineproperty-有哪几个参数各自都有什么作用>31、 Object.defineProperty 有哪几个参数？各自都有什么作用？<a hidden class=anchor aria-hidden=true href=#31-objectdefineproperty-有哪几个参数各自都有什么作用>#</a></h4><h4 id=32-objectdefineproperty-和-es6-的-proxy-有什么区别>32、 Object.defineProperty 和 ES6 的 Proxy 有什么区别？<a hidden class=anchor aria-hidden=true href=#32-objectdefineproperty-和-es6-的-proxy-有什么区别>#</a></h4><h4 id=33-es6-中-symbolmapdecorator-的使用场景有哪些或者你在哪些库的源码里见过这些-api-的使用>33、 ES6 中 Symbol、Map、Decorator 的使用场景有哪些？或者你在哪些库的源码里见过这些 API 的使用？<a hidden class=anchor aria-hidden=true href=#33-es6-中-symbolmapdecorator-的使用场景有哪些或者你在哪些库的源码里见过这些-api-的使用>#</a></h4><h4 id=34-为什么要使用-typescript--typescript-相对于-javascript-的优势是什么>34、 为什么要使用 TypeScript ? TypeScript 相对于 JavaScript 的优势是什么？<a hidden class=anchor aria-hidden=true href=#34-为什么要使用-typescript--typescript-相对于-javascript-的优势是什么>#</a></h4><h4 id=35-typescript-中-const-和-readonly-的区别枚举和常量枚举的区别接口和类型别名的区别>35、 TypeScript 中 const 和 readonly 的区别？枚举和常量枚举的区别？接口和类型别名的区别？<a hidden class=anchor aria-hidden=true href=#35-typescript-中-const-和-readonly-的区别枚举和常量枚举的区别接口和类型别名的区别>#</a></h4><h4 id=36-typescript-中-any-类型的作用是什么>36、 TypeScript 中 any 类型的作用是什么？<a hidden class=anchor aria-hidden=true href=#36-typescript-中-any-类型的作用是什么>#</a></h4><h4 id=37-typescript-中-anyneverunknown-和-void-有什么区别>37、 TypeScript 中 any、never、unknown 和 void 有什么区别？<a hidden class=anchor aria-hidden=true href=#37-typescript-中-anyneverunknown-和-void-有什么区别>#</a></h4><h4 id=38-typescript-中-interface-可以给-function--array--classindexable做声明吗>38、 TypeScript 中 interface 可以给 Function / Array / Class（Indexable）做声明吗？<a hidden class=anchor aria-hidden=true href=#38-typescript-中-interface-可以给-function--array--classindexable做声明吗>#</a></h4><h4 id=39-typescript-中可以使用-stringnumberbooleansymbolobject-等给类型做声明吗>39、 TypeScript 中可以使用 String、Number、Boolean、Symbol、Object 等给类型做声明吗？<a hidden class=anchor aria-hidden=true href=#39-typescript-中可以使用-stringnumberbooleansymbolobject-等给类型做声明吗>#</a></h4><h4 id=40-typescript-中的-this-和-javascript-中的-this-有什么差异>40、 TypeScript 中的 this 和 JavaScript 中的 this 有什么差异？<a hidden class=anchor aria-hidden=true href=#40-typescript-中的-this-和-javascript-中的-this-有什么差异>#</a></h4><h4 id=41-typescript-中使用-unions-时有哪些注意事项>41、 TypeScript 中使用 Unions 时有哪些注意事项？<a hidden class=anchor aria-hidden=true href=#41-typescript-中使用-unions-时有哪些注意事项>#</a></h4><h4 id=42-typescript-如何设计-class-的声明>42、 TypeScript 如何设计 Class 的声明？<a hidden class=anchor aria-hidden=true href=#42-typescript-如何设计-class-的声明>#</a></h4><h4 id=43-typescript-中如何联合枚举类型的-key>43、 TypeScript 中如何联合枚举类型的 Key?<a hidden class=anchor aria-hidden=true href=#43-typescript-中如何联合枚举类型的-key>#</a></h4><h4 id=44-typescript-中-_-等符号的含义>44、 TypeScript 中 ?.、??、!.、_、** 等符号的含义？<a hidden class=anchor aria-hidden=true href=#44-typescript-中-_-等符号的含义>#</a></h4><h4 id=45-typescript-中预定义的有条件类型有哪些>45、 TypeScript 中预定义的有条件类型有哪些？<a hidden class=anchor aria-hidden=true href=#45-typescript-中预定义的有条件类型有哪些>#</a></h4><h4 id=46-简单介绍一下-typescript-模块的加载机制>46、 简单介绍一下 TypeScript 模块的加载机制？<a hidden class=anchor aria-hidden=true href=#46-简单介绍一下-typescript-模块的加载机制>#</a></h4><h4 id=47-简单聊聊你对-typescript-类型兼容性的理解抗变双变协变和逆变的简单理解>47、 简单聊聊你对 TypeScript 类型兼容性的理解？抗变、双变、协变和逆变的简单理解？<a hidden class=anchor aria-hidden=true href=#47-简单聊聊你对-typescript-类型兼容性的理解抗变双变协变和逆变的简单理解>#</a></h4><h4 id=48-typescript-中对象展开会有什么副作用吗>48、 TypeScript 中对象展开会有什么副作用吗？<a hidden class=anchor aria-hidden=true href=#48-typescript-中对象展开会有什么副作用吗>#</a></h4><h4 id=49-typescript-中-interfacetypeenum-声明有作用域的功能吗>49、 TypeScript 中 interface、type、enum 声明有作用域的功能吗？<a hidden class=anchor aria-hidden=true href=#49-typescript-中-interfacetypeenum-声明有作用域的功能吗>#</a></h4><h4 id=50-typescript-中同名的-interface-或者同名的-interface-和-class-可以合并吗>50、 TypeScript 中同名的 interface 或者同名的 interface 和 class 可以合并吗？<a hidden class=anchor aria-hidden=true href=#50-typescript-中同名的-interface-或者同名的-interface-和-class-可以合并吗>#</a></h4><h4 id=51-如何使-typescript-项目引入并识别编译为-javascript-的-npm-库包>51、 如何使 TypeScript 项目引入并识别编译为 JavaScript 的 npm 库包？<a hidden class=anchor aria-hidden=true href=#51-如何使-typescript-项目引入并识别编译为-javascript-的-npm-库包>#</a></h4><h4 id=52-typescript-的-tsconfigjson-中有哪些配置项信息>52、 TypeScript 的 tsconfig.json 中有哪些配置项信息？<a hidden class=anchor aria-hidden=true href=#52-typescript-的-tsconfigjson-中有哪些配置项信息>#</a></h4><h4 id=53-typescript-中如何设置模块导入的路径别名>53、 TypeScript 中如何设置模块导入的路径别名？<a hidden class=anchor aria-hidden=true href=#53-typescript-中如何设置模块导入的路径别名>#</a></h4><h3 id=框架>框架<a hidden class=anchor aria-hidden=true href=#框架>#</a></h3><h4 id=54-react-class-组件有哪些周期函数分别有什么作用>54、 React Class 组件有哪些周期函数？分别有什么作用？<a hidden class=anchor aria-hidden=true href=#54-react-class-组件有哪些周期函数分别有什么作用>#</a></h4><h4 id=55-react-class-组件中请求可以在-componentwillmount-中发起吗为什么>55、 React Class 组件中请求可以在 componentWillMount 中发起吗？为什么？<a hidden class=anchor aria-hidden=true href=#55-react-class-组件中请求可以在-componentwillmount-中发起吗为什么>#</a></h4><h4 id=56-react-class-组件和-react-hook-的区别有哪些>56、 React Class 组件和 React Hook 的区别有哪些？<a hidden class=anchor aria-hidden=true href=#56-react-class-组件和-react-hook-的区别有哪些>#</a></h4><h4 id=57-react-中高阶函数和自定义-hook-的优缺点>57、 React 中高阶函数和自定义 Hook 的优缺点？<a hidden class=anchor aria-hidden=true href=#57-react-中高阶函数和自定义-hook-的优缺点>#</a></h4><h4 id=58-简要说明-react-hook-中-usestate-和-useeffect-的运行原理>58、 简要说明 React Hook 中 useState 和 useEffect 的运行原理？<a hidden class=anchor aria-hidden=true href=#58-简要说明-react-hook-中-usestate-和-useeffect-的运行原理>#</a></h4><h4 id=59-react-如何发现重渲染什么原因容易造成重渲染如何避免重渲染>59、 React 如何发现重渲染、什么原因容易造成重渲染、如何避免重渲染？<a hidden class=anchor aria-hidden=true href=#59-react-如何发现重渲染什么原因容易造成重渲染如何避免重渲染>#</a></h4><h4 id=60-react-hook-中-useeffect-有哪些参数如何检测数组依赖项的变化>60、 React Hook 中 useEffect 有哪些参数，如何检测数组依赖项的变化？<a hidden class=anchor aria-hidden=true href=#60-react-hook-中-useeffect-有哪些参数如何检测数组依赖项的变化>#</a></h4><h4 id=61-react-的-useeffect-是如何监听数组依赖项的变化的>61、 React 的 useEffect 是如何监听数组依赖项的变化的？<a hidden class=anchor aria-hidden=true href=#61-react-的-useeffect-是如何监听数组依赖项的变化的>#</a></h4><h4 id=62-react-hook-和闭包有什么关联关系>62、 React Hook 和闭包有什么关联关系？<a hidden class=anchor aria-hidden=true href=#62-react-hook-和闭包有什么关联关系>#</a></h4><h4 id=63-react-中-usestate-是如何做数据初始化的>63、 React 中 useState 是如何做数据初始化的？<a hidden class=anchor aria-hidden=true href=#63-react-中-usestate-是如何做数据初始化的>#</a></h4><h4 id=64-列举你常用的-react-性能优化技巧>64、 列举你常用的 React 性能优化技巧？<a hidden class=anchor aria-hidden=true href=#64-列举你常用的-react-性能优化技巧>#</a></h4><h4 id=65-vue-2x-模板中的指令是如何解析实现的>65、 Vue 2.x 模板中的指令是如何解析实现的？<a hidden class=anchor aria-hidden=true href=#65-vue-2x-模板中的指令是如何解析实现的>#</a></h4><h4 id=66-简要说明-vue-2x-的全链路运作机制>66、 简要说明 Vue 2.x 的全链路运作机制？<a hidden class=anchor aria-hidden=true href=#66-简要说明-vue-2x-的全链路运作机制>#</a></h4><h4 id=67-简单介绍一下-element-ui-的框架设计>67、 简单介绍一下 Element UI 的框架设计？<a hidden class=anchor aria-hidden=true href=#67-简单介绍一下-element-ui-的框架设计>#</a></h4><h4 id=68-如何理解-vue-是一个渐进式框架>68、 如何理解 Vue 是一个渐进式框架？<a hidden class=anchor aria-hidden=true href=#68-如何理解-vue-是一个渐进式框架>#</a></h4><h4 id=69-vue-里实现跨组件通信的方式有哪些>69、 Vue 里实现跨组件通信的方式有哪些？<a hidden class=anchor aria-hidden=true href=#69-vue-里实现跨组件通信的方式有哪些>#</a></h4><h4 id=70-vue-中响应式数据是如何做到对某个对象的深层次属性的监听的>70、 Vue 中响应式数据是如何做到对某个对象的深层次属性的监听的？<a hidden class=anchor aria-hidden=true href=#70-vue-中响应式数据是如何做到对某个对象的深层次属性的监听的>#</a></h4><h4 id=71-mvvmmvc-和-mvp-的区别是什么各自有什么应用场景>71、 MVVM、MVC 和 MVP 的区别是什么？各自有什么应用场景？、<a hidden class=anchor aria-hidden=true href=#71-mvvmmvc-和-mvp-的区别是什么各自有什么应用场景>#</a></h4><h4 id=72-什么是-mvvm-框架>72、 什么是 MVVM 框架？<a hidden class=anchor aria-hidden=true href=#72-什么是-mvvm-框架>#</a></h4><h3 id=工程>工程<a hidden class=anchor aria-hidden=true href=#工程>#</a></h3><h4 id=73vue-cli-3x-有哪些功能vue-cli-3x-的插件系统了解>73、Vue CLI 3.x 有哪些功能？Vue CLI 3.x 的插件系统了解？<a hidden class=anchor aria-hidden=true href=#73vue-cli-3x-有哪些功能vue-cli-3x-的插件系统了解>#</a></h4><h4 id=74vue-cli-3x-中的-webpack-是如何组装处理的>74、Vue CLI 3.x 中的 Webpack 是如何组装处理的？<a hidden class=anchor aria-hidden=true href=#74vue-cli-3x-中的-webpack-是如何组装处理的>#</a></h4><h4 id=75vue-2x-如何支持-typescript-语法>75、Vue 2.x 如何支持 TypeScript 语法？<a hidden class=anchor aria-hidden=true href=#75vue-2x-如何支持-typescript-语法>#</a></h4><h4 id=76如何配置环境使得-javascript-项目可以支持-typescript-语法>76、如何配置环境使得 JavaScript 项目可以支持 TypeScript 语法？<a hidden class=anchor aria-hidden=true href=#76如何配置环境使得-javascript-项目可以支持-typescript-语法>#</a></h4><h4 id=77如何对-typescript-进行-lint-校验eslint-和-tslint-有什么区别>77、如何对 TypeScript 进行 Lint 校验？ESLint 和 TSLint 有什么区别？<a hidden class=anchor aria-hidden=true href=#77如何对-typescript-进行-lint-校验eslint-和-tslint-有什么区别>#</a></h4><h4 id=78nodejs-如何支持-typescript-语法>78、Node.js 如何支持 TypeScript 语法？<a hidden class=anchor aria-hidden=true href=#78nodejs-如何支持-typescript-语法>#</a></h4><h4 id=79typescript-如何自动生成库包的声明文件>79、TypeScript 如何自动生成库包的声明文件？<a hidden class=anchor aria-hidden=true href=#79typescript-如何自动生成库包的声明文件>#</a></h4><h4 id=80babel-对于-typescript-的支持有哪些限制>80、Babel 对于 TypeScript 的支持有哪些限制？<a hidden class=anchor aria-hidden=true href=#80babel-对于-typescript-的支持有哪些限制>#</a></h4><h4 id=81webpack-中-loader-和-plugin-的区别是什么>81、Webpack 中 Loader 和 Plugin 的区别是什么？<a hidden class=anchor aria-hidden=true href=#81webpack-中-loader-和-plugin-的区别是什么>#</a></h4><h4 id=82在-webpack-中是如何做到支持类似于-jsx-语法的-sourcemap-定位>82、在 Webpack 中是如何做到支持类似于 JSX 语法的 Sourcemap 定位？<a hidden class=anchor aria-hidden=true href=#82在-webpack-中是如何做到支持类似于-jsx-语法的-sourcemap-定位>#</a></h4><h4 id=83发布-npm-包如何指定引入地址>83、发布 Npm 包如何指定引入地址？<a hidden class=anchor aria-hidden=true href=#83发布-npm-包如何指定引入地址>#</a></h4><h4 id=84如何发布开发项目的特定文件夹为-npm-包的根目录>84、如何发布开发项目的特定文件夹为 Npm 包的根目录？<a hidden class=anchor aria-hidden=true href=#84如何发布开发项目的特定文件夹为-npm-包的根目录>#</a></h4><h4 id=85如何发布一个支持-tree-shaking-机制的-npm-包>85、如何发布一个支持 Tree Shaking 机制的 Npm 包？<a hidden class=anchor aria-hidden=true href=#85如何发布一个支持-tree-shaking-机制的-npm-包>#</a></h4><h4 id=86npm-包中-peerdependencies-的作用是什么>86、Npm 包中 peerDependencies 的作用是什么？<a hidden class=anchor aria-hidden=true href=#86npm-包中-peerdependencies-的作用是什么>#</a></h4><h4 id=87如何优雅的调试需要发布的-npm-包>87、如何优雅的调试需要发布的 Npm 包？<a hidden class=anchor aria-hidden=true href=#87如何优雅的调试需要发布的-npm-包>#</a></h4><h4 id=88在设计一些库包时如何生成版本日志>88、在设计一些库包时如何生成版本日志？<a hidden class=anchor aria-hidden=true href=#88在设计一些库包时如何生成版本日志>#</a></h4><h4 id=89了解-git-submodule子模块吗简单介绍一下-git-子模块的作用>89、了解 Git （Submodule）子模块吗？简单介绍一下 Git 子模块的作用？<a hidden class=anchor aria-hidden=true href=#89了解-git-submodule子模块吗简单介绍一下-git-子模块的作用>#</a></h4><h4 id=90git-如何修改已经提交的-commit-信息>90、Git 如何修改已经提交的 Commit 信息？<a hidden class=anchor aria-hidden=true href=#90git-如何修改已经提交的-commit-信息>#</a></h4><h4 id=91git-如何撤销-commit-并保存之前的修改>91、Git 如何撤销 Commit 并保存之前的修改？<a hidden class=anchor aria-hidden=true href=#91git-如何撤销-commit-并保存之前的修改>#</a></h4><h4 id=92git-如何-ignore-被-commit-过的文件>92、Git 如何 ignore 被 commit 过的文件？<a hidden class=anchor aria-hidden=true href=#92git-如何-ignore-被-commit-过的文件>#</a></h4><h4 id=93在使用-git-的时候如何规范-git-的提交说明commit-信息>93、在使用 Git 的时候如何规范 Git 的提交说明（Commit 信息）？<a hidden class=anchor aria-hidden=true href=#93在使用-git-的时候如何规范-git-的提交说明commit-信息>#</a></h4><h4 id=94简述符合-angular-规范的提交说明的结构组成>94、简述符合 Angular 规范的提交说明的结构组成？<a hidden class=anchor aria-hidden=true href=#94简述符合-angular-规范的提交说明的结构组成>#</a></h4><h4 id=95commit-信息如何和-github-issues-关联>95、Commit 信息如何和 Github Issues 关联？<a hidden class=anchor aria-hidden=true href=#95commit-信息如何和-github-issues-关联>#</a></h4><h4 id=96git-hook-在项目中哪些作用>96、Git Hook 在项目中哪些作用？<a hidden class=anchor aria-hidden=true href=#96git-hook-在项目中哪些作用>#</a></h4><h4 id=97git-hook-中客户端和服务端钩子各自用于什么作用>97、Git Hook 中客户端和服务端钩子各自用于什么作用？<a hidden class=anchor aria-hidden=true href=#97git-hook-中客户端和服务端钩子各自用于什么作用>#</a></h4><h4 id=98git-hook-中常用的钩子有哪些>98、Git Hook 中常用的钩子有哪些？<a hidden class=anchor aria-hidden=true href=#98git-hook-中常用的钩子有哪些>#</a></h4><h4 id=99pre-commit-和-commit-msg-钩子的区别是什么各自可用于做什么>99、pre-commit 和 commit-msg 钩子的区别是什么？各自可用于做什么？<a hidden class=anchor aria-hidden=true href=#99pre-commit-和-commit-msg-钩子的区别是什么各自可用于做什么>#</a></h4><h4 id=100husky-以及-ghook-等工具制作-git-hook-的原理是什么>100、husky 以及 ghook 等工具制作 Git Hook 的原理是什么？<a hidden class=anchor aria-hidden=true href=#100husky-以及-ghook-等工具制作-git-hook-的原理是什么>#</a></h4><h4 id=101如何设计一个通用的-git-hook->101、如何设计一个通用的 Git Hook ？<a hidden class=anchor aria-hidden=true href=#101如何设计一个通用的-git-hook->#</a></h4><h4 id=102git-hook-可以采用-node-脚本进行设计吗如何做到>102、Git Hook 可以采用 Node 脚本进行设计吗？如何做到？<a hidden class=anchor aria-hidden=true href=#102git-hook-可以采用-node-脚本进行设计吗如何做到>#</a></h4><h4 id=103如何确保别人上传的代码没有-lint-错误如何确保代码构建没有-lint-错误>103、如何确保别人上传的代码没有 Lint 错误？如何确保代码构建没有 Lint 错误？<a hidden class=anchor aria-hidden=true href=#103如何确保别人上传的代码没有-lint-错误如何确保代码构建没有-lint-错误>#</a></h4><h4 id=104如何在-vs-code-中进行-lint-校验提示如何在-vs-code-中进行-lint-保存格式化>104、如何在 Vs Code 中进行 Lint 校验提示？如何在 Vs Code 中进行 Lint 保存格式化？<a hidden class=anchor aria-hidden=true href=#104如何在-vs-code-中进行-lint-校验提示如何在-vs-code-中进行-lint-保存格式化>#</a></h4><h4 id=105eslint-和-prettier-的区别是什么两者在一起工作时会产生问题吗>105、ESLint 和 Prettier 的区别是什么？两者在一起工作时会产生问题吗？<a hidden class=anchor aria-hidden=true href=#105eslint-和-prettier-的区别是什么两者在一起工作时会产生问题吗>#</a></h4><h4 id=106如何有效的识别-eslint-和-prettier-可能产生冲突的格式规则如何解决此类规则冲突问题>106、如何有效的识别 ESLint 和 Prettier 可能产生冲突的格式规则？如何解决此类规则冲突问题？<a hidden class=anchor aria-hidden=true href=#106如何有效的识别-eslint-和-prettier-可能产生冲突的格式规则如何解决此类规则冲突问题>#</a></h4><h4 id=107在通常的脚手架项目中进行热更新hot-module-replacement时如何做到-eslint-实时打印校验错误信息>107、在通常的脚手架项目中进行热更新（hot module replacement）时如何做到 ESLint 实时打印校验错误信息？<a hidden class=anchor aria-hidden=true href=#107在通常的脚手架项目中进行热更新hot-module-replacement时如何做到-eslint-实时打印校验错误信息>#</a></h4><h4 id=108谈谈你对-sourcemap-的了解>108、谈谈你对 SourceMap 的了解？<a hidden class=anchor aria-hidden=true href=#108谈谈你对-sourcemap-的了解>#</a></h4><h4 id=109如何调试-nodejs-代码如何调试-nodejs-typescript-代码在浏览器中如何调试-nodejs-代码>109、如何调试 Node.js 代码？如何调试 Node.js TypeScript 代码？在浏览器中如何调试 Node.js 代码？<a hidden class=anchor aria-hidden=true href=#109如何调试-nodejs-代码如何调试-nodejs-typescript-代码在浏览器中如何调试-nodejs-代码>#</a></h4><h4 id=110列举你知道的所有构建工具并说说这些工具的优缺点这些构建工具在不同的场景下应该如何选型>110、列举你知道的所有构建工具并说说这些工具的优缺点？这些构建工具在不同的场景下应该如何选型？<a hidden class=anchor aria-hidden=true href=#110列举你知道的所有构建工具并说说这些工具的优缺点这些构建工具在不同的场景下应该如何选型>#</a></h4><h4 id=111vs-code-配置中的用户和工作区有什么区别>111、VS Code 配置中的用户和工作区有什么区别？<a hidden class=anchor aria-hidden=true href=#111vs-code-配置中的用户和工作区有什么区别>#</a></h4><h4 id=112vs-code-的插件可以只对当前项目生效吗>112、VS Code 的插件可以只对当前项目生效吗？<a hidden class=anchor aria-hidden=true href=#112vs-code-的插件可以只对当前项目生效吗>#</a></h4><h4 id=113你所知道的测试有哪些测试类型>113、你所知道的测试有哪些测试类型？<a hidden class=anchor aria-hidden=true href=#113你所知道的测试有哪些测试类型>#</a></h4><h4 id=114你所知道的测试框架有哪些>114、你所知道的测试框架有哪些？<a hidden class=anchor aria-hidden=true href=#114你所知道的测试框架有哪些>#</a></h4><h4 id=115什么是-e2e-测试有哪些-e2e-的测试框架>115、什么是 e2e 测试？有哪些 e2e 的测试框架？<a hidden class=anchor aria-hidden=true href=#115什么是-e2e-测试有哪些-e2e-的测试框架>#</a></h4><h4 id=116假设现在有一个插入排序算法如何对该算法进行单元测试>116、假设现在有一个插入排序算法，如何对该算法进行单元测试？<a hidden class=anchor aria-hidden=true href=#116假设现在有一个插入排序算法如何对该算法进行单元测试>#</a></h4><h3 id=网络>网络<a hidden class=anchor aria-hidden=true href=#网络>#</a></h3><h4 id=117cdn-服务如何实现网络加速>117、CDN 服务如何实现网络加速？<a hidden class=anchor aria-hidden=true href=#117cdn-服务如何实现网络加速>#</a></h4><h4 id=118websocket-使用的是-tcp-还是-udp-协议>118、WebSocket 使用的是 TCP 还是 UDP 协议？<a hidden class=anchor aria-hidden=true href=#118websocket-使用的是-tcp-还是-udp-协议>#</a></h4><h4 id=119什么是单工半双工和全双工通信>119、什么是单工、半双工和全双工通信？<a hidden class=anchor aria-hidden=true href=#119什么是单工半双工和全双工通信>#</a></h4><h4 id=120简单描述-http-协议发送一个带域名的-url-请求的协议传输过程dnstcpip链路>120、简单描述 HTTP 协议发送一个带域名的 URL 请求的协议传输过程？（DNS、TCP、IP、链路）<a hidden class=anchor aria-hidden=true href=#120简单描述-http-协议发送一个带域名的-url-请求的协议传输过程dnstcpip链路>#</a></h4><h4 id=121什么是正向代理什么是反向代理>121、什么是正向代理？什么是反向代理？<a hidden class=anchor aria-hidden=true href=#121什么是正向代理什么是反向代理>#</a></h4><h4 id=122cookie-可以在服务端生成吗cookie-在服务端生成后的工作流程是什么样的>122、Cookie 可以在服务端生成吗？Cookie 在服务端生成后的工作流程是什么样的？<a hidden class=anchor aria-hidden=true href=#122cookie-可以在服务端生成吗cookie-在服务端生成后的工作流程是什么样的>#</a></h4><h4 id=123sessioncookie-的区别和关联如何进行临时性和永久性的-session-存储>123、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？<a hidden class=anchor aria-hidden=true href=#123sessioncookie-的区别和关联如何进行临时性和永久性的-session-存储>#</a></h4><h4 id=124设置-cookie-时候如何防止-xss-攻击>124、设置 Cookie 时候如何防止 XSS 攻击？<a hidden class=anchor aria-hidden=true href=#124设置-cookie-时候如何防止-xss-攻击>#</a></h4><h4 id=125简单描述一下用户免登陆的实现过程可能会出现哪些安全性问题一般如何对用户登录的密码进行加密>125、简单描述一下用户免登陆的实现过程？可能会出现哪些安全性问题？一般如何对用户登录的密码进行加密？<a hidden class=anchor aria-hidden=true href=#125简单描述一下用户免登陆的实现过程可能会出现哪些安全性问题一般如何对用户登录的密码进行加密>#</a></h4><h4 id=126http-中提升传输速率的方式有哪些常用的内容编码方式有哪些>126、HTTP 中提升传输速率的方式有哪些？常用的内容编码方式有哪些？<a hidden class=anchor aria-hidden=true href=#126http-中提升传输速率的方式有哪些常用的内容编码方式有哪些>#</a></h4><h4 id=127传输图片的过程中如果突然中断如何在恢复后从之前的中断中恢复传输>127、传输图片的过程中如果突然中断，如何在恢复后从之前的中断中恢复传输？<a hidden class=anchor aria-hidden=true href=#127传输图片的过程中如果突然中断如何在恢复后从之前的中断中恢复传输>#</a></h4><h4 id=128什么是代理什么是网关代理和网关的作用是什么>128、什么是代理？什么是网关？代理和网关的作用是什么？<a hidden class=anchor aria-hidden=true href=#128什么是代理什么是网关代理和网关的作用是什么>#</a></h4><h4 id=129https-相比-http-为什么更加安全可靠>129、HTTPS 相比 HTTP 为什么更加安全可靠？<a hidden class=anchor aria-hidden=true href=#129https-相比-http-为什么更加安全可靠>#</a></h4><h4 id=130什么是对称密钥共享密钥加密什么是非对称密钥公开密钥加密哪个更加安全>130、什么是对称密钥（共享密钥）加密？什么是非对称密钥（公开密钥）加密？哪个更加安全？<a hidden class=anchor aria-hidden=true href=#130什么是对称密钥共享密钥加密什么是非对称密钥公开密钥加密哪个更加安全>#</a></h4><h4 id=131你觉得-http-协议目前存在哪些缺点>131、你觉得 HTTP 协议目前存在哪些缺点？<a hidden class=anchor aria-hidden=true href=#131你觉得-http-协议目前存在哪些缺点>#</a></h4><h3 id=性能>性能<a hidden class=anchor aria-hidden=true href=#性能>#</a></h3><h4 id=133在-react-中如何识别一个表单项里的表单做到了最小粒度--代价的渲染>133、在 React 中如何识别一个表单项里的表单做到了最小粒度 / 代价的渲染？<a hidden class=anchor aria-hidden=true href=#133在-react-中如何识别一个表单项里的表单做到了最小粒度--代价的渲染>#</a></h4><h4 id=134在-react-的开发的过程中你能想到哪些控制渲染成本的方法>134、在 React 的开发的过程中你能想到哪些控制渲染成本的方法？<a hidden class=anchor aria-hidden=true href=#134在-react-的开发的过程中你能想到哪些控制渲染成本的方法>#</a></h4><h3 id=插件>插件<a hidden class=anchor aria-hidden=true href=#插件>#</a></h3><h4 id=135vue-cli-3x-的插件系统是如何设计的>135、Vue CLI 3.x 的插件系统是如何设计的？<a hidden class=anchor aria-hidden=true href=#135vue-cli-3x-的插件系统是如何设计的>#</a></h4><h4 id=136webpack-中的插件机制是如何设计的>136、Webpack 中的插件机制是如何设计的？<a hidden class=anchor aria-hidden=true href=#136webpack-中的插件机制是如何设计的>#</a></h4><h3 id=系统>系统<a hidden class=anchor aria-hidden=true href=#系统>#</a></h3><h4 id=137rncrlf-和-n-lf的区别是什么vs-code-的右下角可以切换>137、\r\n（CRLF） 和 \n （LF）的区别是什么？(Vs Code 的右下角可以切换)<a hidden class=anchor aria-hidden=true href=#137rncrlf-和-n-lf的区别是什么vs-code-的右下角可以切换>#</a></h4><h4 id=138devnull-的作用是啥>138、/dev/null 的作用是啥？<a hidden class=anchor aria-hidden=true href=#138devnull-的作用是啥>#</a></h4><h4 id=139如何在-mac-的终端中设置一个命令的别名>139、如何在 Mac 的终端中设置一个命令的别名？<a hidden class=anchor aria-hidden=true href=#139如何在-mac-的终端中设置一个命令的别名>#</a></h4><h4 id=140如何在-windows-中设置环境变量>140、如何在 Windows 中设置环境变量？<a hidden class=anchor aria-hidden=true href=#140如何在-windows-中设置环境变量>#</a></h4><h4 id=141mac-的文件操作系统默认区分文件路径的大小写吗>141、Mac 的文件操作系统默认区分文件路径的大小写吗？<a hidden class=anchor aria-hidden=true href=#141mac-的文件操作系统默认区分文件路径的大小写吗>#</a></h4><h4 id=142编写-shell-脚本时如何设置文件的绝对路径>142、编写 Shell 脚本时如何设置文件的绝对路径？<a hidden class=anchor aria-hidden=true href=#142编写-shell-脚本时如何设置文件的绝对路径>#</a></h4><h3 id=后端>后端<a hidden class=anchor aria-hidden=true href=#后端>#</a></h3><h4 id=143sessioncookie-的区别和关联如何进行临时性和永久性的-session-存储>143、Session、Cookie 的区别和关联？如何进行临时性和永久性的 Session 存储？<a hidden class=anchor aria-hidden=true href=#143sessioncookie-的区别和关联如何进行临时性和永久性的-session-存储>#</a></h4><h4 id=144如何部署-nodejs-应用如何处理负载均衡中-session-的一致性问题>144、如何部署 Node.js 应用？如何处理负载均衡中 Session 的一致性问题？<a hidden class=anchor aria-hidden=true href=#144如何部署-nodejs-应用如何处理负载均衡中-session-的一致性问题>#</a></h4><h4 id=145如何提升-nodejs-代码的运行稳定性>145、如何提升 Node.js 代码的运行稳定性？<a hidden class=anchor aria-hidden=true href=#145如何提升-nodejs-代码的运行稳定性>#</a></h4><h4 id=146graphql-与-restful-的区别它有什么优点>146、GraphQL 与 Restful 的区别，它有什么优点？<a hidden class=anchor aria-hidden=true href=#146graphql-与-restful-的区别它有什么优点>#</a></h4><h4 id=147vue-ssr-的工作原理vuex-的数据如何同构渲染>147、Vue SSR 的工作原理？Vuex 的数据如何同构渲染？<a hidden class=anchor aria-hidden=true href=#147vue-ssr-的工作原理vuex-的数据如何同构渲染>#</a></h4><h4 id=148ssr-技术和-spa-技术的各自的优缺点是什么>148、SSR 技术和 SPA 技术的各自的优缺点是什么？<a hidden class=anchor aria-hidden=true href=#148ssr-技术和-spa-技术的各自的优缺点是什么>#</a></h4><h4 id=149如何处理-nodejs-渲染-html-压力过大问题>149、如何处理 Node.js 渲染 HTML 压力过大问题？<a hidden class=anchor aria-hidden=true href=#149如何处理-nodejs-渲染-html-压力过大问题>#</a></h4><h2 id=业务思考>业务思考<a hidden class=anchor aria-hidden=true href=#业务思考>#</a></h2><p>业务思考更多的是结合基础知识的广度和深度进行的具体业务实践，主要包含以下几个方面：</p><ul><li>工程化：代码部署、CI / CD 流程设计、Jenkins、Gitlab、Docker 等</li><li>通用性：脚手架、SDK、组件库等框架设计</li><li>应用框架：Hybrid 混合、微前端、BFF、Monorepo</li><li>可视化：</li><li>低代码：通用表单设计、通用布局设计、通用页面设计、JSON Schema 协议设计等</li><li>测试：E2E 测试、单元测试、测试覆盖率、测试报告等</li><li>业务：数据、体验、复杂度、监控</li></ul><h3 id=工程化>工程化<a hidden class=anchor aria-hidden=true href=#工程化>#</a></h3><h4 id=150你所知道的-ci--cd-工具有哪些在项目中有接触过类似的流程吗>150、你所知道的 CI / CD 工具有哪些？在项目中有接触过类似的流程吗？<a hidden class=anchor aria-hidden=true href=#150你所知道的-ci--cd-工具有哪些在项目中有接触过类似的流程吗>#</a></h4><h4 id=151如果让你实现一个-web-前端的-ci--cd-工程研发平台你会如何设计>151、如果让你实现一个 Web 前端的 CI / CD 工程研发平台，你会如何设计？<a hidden class=anchor aria-hidden=true href=#151如果让你实现一个-web-前端的-ci--cd-工程研发平台你会如何设计>#</a></h4><h4 id=152如果我们需要将已有项目中的线上产物资源例如图片转换成本地私有化资源你有什么解决方案>152、如果我们需要将已有项目中的线上产物资源（例如图片）转换成本地私有化资源，你有什么解决方案？<a hidden class=anchor aria-hidden=true href=#152如果我们需要将已有项目中的线上产物资源例如图片转换成本地私有化资源你有什么解决方案>#</a></h4><h4 id=153如何使用-vue-cli-3x-定制一个脚手架比如内部自动集成了-i18n-axioselement-ui路由守卫等>153、如何使用 Vue CLI 3.x 定制一个脚手架？比如内部自动集成了 i18n、 axios、Element UI、路由守卫等？<a hidden class=anchor aria-hidden=true href=#153如何使用-vue-cli-3x-定制一个脚手架比如内部自动集成了-i18n-axioselement-ui路由守卫等>#</a></h4><h4 id=154jenkins-如何配合-nodejs-脚本进行-ci--cd-设计>154、Jenkins 如何配合 Node.js 脚本进行 CI / CD 设计？<a hidden class=anchor aria-hidden=true href=#154jenkins-如何配合-nodejs-脚本进行-ci--cd-设计>#</a></h4><h3 id=通用性>通用性<a hidden class=anchor aria-hidden=true href=#通用性>#</a></h3><h4 id=155如果让你设计一个通用的项目脚手架你会如何设计一个通用的脚手架一般需要具备哪些能力>155、如果让你设计一个通用的项目脚手架，你会如何设计？一个通用的脚手架一般需要具备哪些能力？<a hidden class=anchor aria-hidden=true href=#155如果让你设计一个通用的项目脚手架你会如何设计一个通用的脚手架一般需要具备哪些能力>#</a></h4><h4 id=156如果让你设计一个通用的工具库你会如何设计一个通用的工具库一般需要具备哪些能力>156、如果让你设计一个通用的工具库，你会如何设计？一个通用的工具库一般需要具备哪些能力？<a hidden class=anchor aria-hidden=true href=#156如果让你设计一个通用的工具库你会如何设计一个通用的工具库一般需要具备哪些能力>#</a></h4><h4 id=157假设你自己实现的-react-或-vue-的组件库要设计演示文档你会如何设计设计的文档需要实现哪些功能>157、假设你自己实现的 React 或 Vue 的组件库要设计演示文档，你会如何设计？设计的文档需要实现哪些功能？<a hidden class=anchor aria-hidden=true href=#157假设你自己实现的-react-或-vue-的组件库要设计演示文档你会如何设计设计的文档需要实现哪些功能>#</a></h4><h4 id=158在设计工具库包的时候你是如何设计-api-文档的>158、在设计工具库包的时候你是如何设计 API 文档的？<a hidden class=anchor aria-hidden=true href=#158在设计工具库包的时候你是如何设计-api-文档的>#</a></h4><h3 id=应用框架>应用框架<a hidden class=anchor aria-hidden=true href=#应用框架>#</a></h3><h4 id=159谈谈-electronnwjscefflutter-和原生开发的理解>159、谈谈 Electron、Nw.js、CEF、Flutter 和原生开发的理解？<a hidden class=anchor aria-hidden=true href=#159谈谈-electronnwjscefflutter-和原生开发的理解>#</a></h4><h4 id=160谈谈桌面端应用中-hotfix-的理解>160、谈谈桌面端应用中 HotFix 的理解？<a hidden class=anchor aria-hidden=true href=#160谈谈桌面端应用中-hotfix-的理解>#</a></h4><h4 id=161你觉得什么样的场景需要使用微前端框架>161、你觉得什么样的场景需要使用微前端框架？<a hidden class=anchor aria-hidden=true href=#161你觉得什么样的场景需要使用微前端框架>#</a></h4><h3 id=业务>业务<a hidden class=anchor aria-hidden=true href=#业务>#</a></h3><h4 id=162什么是单点登录如何做单点登录>162、什么是单点登录？如何做单点登录？<a hidden class=anchor aria-hidden=true href=#162什么是单点登录如何做单点登录>#</a></h4><h4 id=163如何做一个项目的国际化方案>163、如何做一个项目的国际化方案？<a hidden class=anchor aria-hidden=true href=#163如何做一个项目的国际化方案>#</a></h4><h4 id=164如何做一个项目的监控和埋点方案>164、如何做一个项目的监控和埋点方案？<a hidden class=anchor aria-hidden=true href=#164如何做一个项目的监控和埋点方案>#</a></h4><h4 id=165如何建设项目的稳定性监控灰度错误降级回滚>165、如何建设项目的稳定性（监控、灰度、错误降级、回滚&mldr;）？<a hidden class=anchor aria-hidden=true href=#165如何建设项目的稳定性监控灰度错误降级回滚>#</a></h4><h4 id=166一般管理后台型的应用需要考虑哪些性能方面的优化>166、一般管理后台型的应用需要考虑哪些性能方面的优化？<a hidden class=anchor aria-hidden=true href=#166一般管理后台型的应用需要考虑哪些性能方面的优化>#</a></h4><h4 id=167简述一些提升项目体验的案例和技术方案骨架屏loading-处理缓存错误降级请求重试>167、简述一些提升项目体验的案例和技术方案（骨架屏、Loading 处理、缓存、错误降级、请求重试&mldr;）？<a hidden class=anchor aria-hidden=true href=#167简述一些提升项目体验的案例和技术方案骨架屏loading-处理缓存错误降级请求重试>#</a></h4><h4 id=168假设需要对页面设计一个水印方案你会如何设计>168、假设需要对页面设计一个水印方案，你会如何设计？<a hidden class=anchor aria-hidden=true href=#168假设需要对页面设计一个水印方案你会如何设计>#</a></h4><h3 id=低代码>低代码<a hidden class=anchor aria-hidden=true href=#低代码>#</a></h3><h4 id=169如何设计一个通用的-json-schema-协议使其可以动态渲染一个通用的联动表单>169、如何设计一个通用的 JSON Schema 协议使其可以动态渲染一个通用的联动表单？<a hidden class=anchor aria-hidden=true href=#169如何设计一个通用的-json-schema-协议使其可以动态渲染一个通用的联动表单>#</a></h4><h4 id=170一般的低代码平台需要具备哪些能力>170、一般的低代码平台需要具备哪些能力？<a hidden class=anchor aria-hidden=true href=#170一般的低代码平台需要具备哪些能力>#</a></h4><h2 id=笔试实践>笔试实践<a hidden class=anchor aria-hidden=true href=#笔试实践>#</a></h2><p>笔试更多的是考验应聘者的逻辑思维能力和代码书写风格，主要包含以下几个方面：</p><ul><li>正则表达式</li><li>算法</li><li>数据结构</li><li>设计模式</li><li>框架的部分原理实现</li><li>TypeScript 语法</li><li>模板解析</li></ul><h3 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h3><h4 id=171使用-typescript-语法将没有层级的扁平数据转换成树形结构的数据>171、使用 TypeScript 语法将没有层级的扁平数据转换成树形结构的数据<a hidden class=anchor aria-hidden=true href=#171使用-typescript-语法将没有层级的扁平数据转换成树形结构的数据>#</a></h4><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">22
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">23
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">24
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">25
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">26
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">27
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">28
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">29
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 扁平数据
</span></span><span style=display:flex><span>[{
</span></span><span style=display:flex><span>  name: &#39;文本1&#39;,
</span></span><span style=display:flex><span>  parent: null,
</span></span><span style=display:flex><span>  id: 1,
</span></span><span style=display:flex><span>}, {
</span></span><span style=display:flex><span>  name: &#39;文本2&#39;,
</span></span><span style=display:flex><span>  id: 2,
</span></span><span style=display:flex><span>  parent: 1
</span></span><span style=display:flex><span>}, {
</span></span><span style=display:flex><span>  name: &#39;文本3&#39;,
</span></span><span style=display:flex><span>  parent: 2,
</span></span><span style=display:flex><span>  id: 3,
</span></span><span style=display:flex><span>}]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 树状数据
</span></span><span style=display:flex><span>[{
</span></span><span style=display:flex><span>  name: &#39;文本1&#39;,
</span></span><span style=display:flex><span>  id: 1,
</span></span><span style=display:flex><span>  children: [{
</span></span><span style=display:flex><span>    name: &#39;文本2&#39;,
</span></span><span style=display:flex><span>    id: 2,
</span></span><span style=display:flex><span>    children: [{
</span></span><span style=display:flex><span>      name: &#39;文本3&#39;,
</span></span><span style=display:flex><span>      id: 3
</span></span><span style=display:flex><span>    }]
</span></span><span style=display:flex><span>  }]
</span></span><span style=display:flex><span>}]
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><h3 id=模板解析>模板解析<a hidden class=anchor aria-hidden=true href=#模板解析>#</a></h3><h4 id=172实现一个简易的模板引擎>172、实现一个简易的模板引擎<a hidden class=anchor aria-hidden=true href=#172实现一个简易的模板引擎>#</a></h4><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const template = &#39;嗨，{{ info.name.value }}您好，今天是星期 {{ day.value }}&#39;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const data = {
</span></span><span style=display:flex><span>  info: {
</span></span><span style=display:flex><span>    name: {
</span></span><span style=display:flex><span>      value: &#39;张三&#39;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  day: {
</span></span><span style=display:flex><span>    value: &#39;三&#39;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>render(template, data); // 嗨，张三您好，今天是星期三
</span></span><span style=display:flex><span>复制代码
</span></span></code></pre></td></tr></table></div></div><h3 id=设计模式>设计模式<a hidden class=anchor aria-hidden=true href=#设计模式>#</a></h3><h4 id=173简单实现一个发布--订阅模式>173、简单实现一个发布 / 订阅模式<a hidden class=anchor aria-hidden=true href=#173简单实现一个发布--订阅模式>#</a></h4><h3 id=正则表达式>正则表达式<a hidden class=anchor aria-hidden=true href=#正则表达式>#</a></h3><h4 id=174匹配出字符串中-const-a--requirexxx-中的-xxx>174、匹配出字符串中 const a = require(&lsquo;xxx&rsquo;) 中的 xxx<a hidden class=anchor aria-hidden=true href=#174匹配出字符串中-const-a--requirexxx-中的-xxx>#</a></h4></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/>面试题集</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/06-%E8%B7%A8%E5%9F%9F%E9%80%9A%E4%BF%A1%E7%B1%BB/><span class=title>« Prev</span><br><span>跨域通信类</span></a>
<a class=next href=https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/05-02.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/><span class=title>Next »</span><br><span>面向对象：类的定义和继承的几种方式</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>