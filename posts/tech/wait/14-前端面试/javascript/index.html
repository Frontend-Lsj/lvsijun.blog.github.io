<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JavaScript | Bablvsj's Blog</title><meta name=keywords content="面试"><meta name=description content="JavaScript - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/javascript/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JavaScript"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/javascript/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-05-01T17:11:35+08:00"><meta property="article:modified_time" content="2020-05-01T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="JavaScript"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"JavaScript","item":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/javascript/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JavaScript","name":"JavaScript","description":"","keywords":["面试"],"articleBody":"JavaScript JavaScript的组成\nJavaScript 由以下三部分组成： ECMAScript（核心）：JavaScript 语言基础 DOM（文档对象模型）：规定了访问HTML和XML的接口 BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法 JS的基本数据类型和引用数据类型\n基本数据类型：undefined、null、boolean、number、string、symbol 引用数据类型：object、array、function 检测浏览器版本版本有哪些方式？\n根据 navigator.userAgent // UA.toLowerCase().indexOf(‘chrome’) 根据 window 对象的成员 // ‘ActiveXObject’ in window 介绍JS有哪些内置对象？\n数据封装类对象：Object、Array、Boolean、Number、String 其他对象：Function、Arguments、Math、Date、RegExp、Error ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect 说几条写JavaScript的基本规范？\n代码缩进，建议使用“四个空格”缩进 代码段使用花括号{}包裹 语句结束使用分号; 变量和函数在使用前进行声明 以大写字母开头命名构造函数，全大写命名常量 规范定义JSON对象，补全双引号 用{}和[]声明对象和数组 如何编写高性能的JavaScript？\n遵循严格模式：“use strict”; 将js脚本放在页面底部，加快渲染页面 将js脚本将脚本成组打包，减少请求 使用非阻塞方式下载js脚本 尽量使用局部变量来保存全局变量 尽量减少使用闭包 使用 window 对象属性方法时，省略 window 尽量减少对象成员嵌套 缓存 DOM 节点的访问 通过避免使用 eval() 和 Function() 构造器 给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数 尽量使用直接量创建对象和数组 最小化重绘(repaint)和回流(reflow) 描述浏览器的渲染过程，DOM树和渲染树的区别？\n浏览器的渲染过程：\n解析HTML构建 DOM(DOM树)，并行请求 css/image/js CSS 文件下载完成，开始构建 CSSOM(CSS树) CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树) 布局(Layout)：计算出每个节点在屏幕中的位置 显示(Painting)：通过显卡把页面画到屏幕上 DOM树 和 渲染树 的区别：\nDOM树与HTML标签一一对应，包括head和隐藏元素 渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性 重绘和回流（重排）的区别和关系？\n重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘 回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流 注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值 回流必将引起重绘，而重绘不一定会引起回流 如何最小化重绘(repaint)和回流(reflow)？\n需要要对元素进行复杂的操作时，可以先隐藏(display:“none”)，操作完成后再显示 需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document 缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流 尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流） 避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面） 尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color 批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx script 的位置是否会影响首屏显示时间？\n在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。 浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则 因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间 解释JavaScript中的作用域与变量声明提升？\nJavaScript作用域：\n在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域； 而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。 JavaScript变量声明提升：\n在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。 声明语句中的赋值部分并不会被提升，只有名称被提升 函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明 如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数 介绍JavaScript的原型，原型链？有什么特点？\n原型：\nJavaScript的所有对象中都包含了一个 [proto] 内部属性，这个属性所对应的就是该对象的原型 JavaScript的函数对象，除了原型 [proto] 之外，还预置了 prototype 属性 当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [proto]。 原型链：\n当一个对象调用的属性/方法自身不存在时，就会去自己 [proto] 关联的前辈 prototype 对象上去找 如果没找到，就会去该 prototype 原型 [proto] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链” 原型特点：\nJavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变 JavaScript有几种类型的值？，你能画一下他们的内存图吗\n原始数据类型（Undefined，Null，Boolean，Number、String）– 栈 引用数据类型（对象、数组和函数）– 堆 两种类型的区别是：存储位置不同： 原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据； 引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能； 引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。 当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 JavaScript如何实现一个类，怎么实例化这个类？\n构造函数法（this + prototype） – 用 new 关键字 生成实例对象 缺点：用到了 this 和 prototype，编写复杂，可读性差 function Mobile(name, price){ this.name = name; this.price = price; } Mobile.prototype.sell = function(){ alert(this.name + \"，售价 $\" + this.price); } var iPhone7 = new Mobile(\"iPhone7\", 1000); iPhone7.sell(); Object.create 法 – 用 Object.create() 生成实例对象 缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据 var Person = { firstname: \"Mark\", lastname: \"Yun\", age: 25, introduce: function(){ alert('I am ' + Person.firstname + ' ' + Person.lastname); } }; var person = Object.create(Person); person.introduce(); // Object.create 要求 IE9+，低版本浏览器可以自行部署： if (!Object.create) { Object.create = function (o) { function F() {} F.prototype = o; return new F(); }; } 极简主义法（消除 this 和 prototype） – 调用 createNew() 得到实例对象 优点：容易理解，结构清晰优雅，符合传统的\"面向对象编程\"的构造 var Cat = { age: 3, // 共享数据 -- 定义在类对象内，createNew() 外 createNew: function () { var cat = {}; // var cat = Animal.createNew(); // 继承 Animal 类 cat.name = \"小咪\"; var sound = \"喵喵喵\"; // 私有属性--定义在 createNew() 内，输出对象外 cat.makeSound = function () { alert(sound); // 暴露私有属性 }; cat.changeAge = function(num){ Cat.age = num; // 修改共享数据 }; return cat; // 输出对象 } }; var cat = Cat.createNew(); cat.makeSound(); ES6 语法糖 class – 用 new 关键字 生成实例对象 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return '(' + this.x + ', ' + this.y + ')'; } } var point = new Point(2, 3); Javascript如何实现继承？\n构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上 function Cat(name,color){ Animal.apply(this, arguments); this.name = name; this.color = color; } 实例继承：将子对象的 prototype 指向父对象的一个实例 Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; 拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象 function extend(Child, Parent) { var p = Parent.prototype; var c = Child.prototype; for (var i in p) { c[i] = p[i]; } c.uber = p; } 原型继承：将子对象的 prototype 指向父对象的 prototype function extend(Child, Parent) { var F = function(){}; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child; Child.uber = Parent.prototype; } ES6 语法糖 extends：class ColorPoint extends Point {} class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + ' ' + super.toString(); // 调用父类的toString() } } Javascript作用链域?\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链 谈谈this对象的理解\nthis 总是指向函数的直接调用者 如果有 new 关键字，this 指向 new 出来的实例对象 在事件中，this指向触发这个事件的对象 IE下 attachEvent 中的this总是指向全局对象Window eval是做什么的？\neval的功能是把对应的字符串解析成JS代码并运行\n应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行） 由JSON字符串转换为JSON对象的时候可以用 eval(’(’+ str +’)’); 什么是 Window 对象? 什么是 Document 对象?\nWindow 对象表示当前浏览器的窗口，是JavaScript的顶级对象。 我们创建的所有对象、函数、变量都是 Window 对象的成员。 Window 对象的方法和属性是在全局范围内有效的。 Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点） Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问 Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问 介绍 DOM 的发展\nDOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关 DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[’login’] DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象 DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo) DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator 介绍DOM0，DOM2，DOM3事件处理方式区别\nDOM0级事件处理方式： btn.onclick = func; btn.onclick = null; DOM2级事件处理方式： btn.addEventListener('click', func, false); btn.removeEventListener('click', func, false); btn.attachEvent(\"onclick\", func); btn.detachEvent(\"onclick\", func); DOM3级事件处理方式： eventUtil.addListener(input, \"textInput\", func); eventUtil 是自定义对象，textInput 是DOM3级事件 事件的三个阶段\n捕获、目标、冒泡 介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？\n按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段 事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数 注意1：前提是事件被确实触发 注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖” 事件执行顺序：判断的关键是否目标元素 非目标元素：根据W3C的标准执行：捕获-\u003e目标元素-\u003e冒泡（不依据事件绑定顺序） 目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准） 最终顺序：父元素捕获-\u003e目标元素事件1-\u003e目标元素事件2-\u003e子元素捕获-\u003e子元素冒泡-\u003e父元素冒泡 注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系 在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？\n该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数） 如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获 如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡 事件的代理/委托\n事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件 优点： 可以减少事件注册，节省大量内存占用 可以将事件应用于动态添加的子元素上 缺点： 使用不当会造成事件在不应该触发时触发 示例： ulEl.addEventListener('click', function(e){ var target = event.target || event.srcElement; if(!!target \u0026\u0026 target.nodeName.toUpperCase() === \"LI\"){ console.log(target.innerHTML); } }, false); IE与火狐的事件机制有什么区别？ 如何阻止冒泡？\nIE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获 IE的事件处理和W3C的事件处理有哪些区别？\n绑定事件\nW3C: targetEl.addEventListener(‘click’, handler, false); IE: targetEl.attachEvent(‘onclick’, handler); 删除事件\nW3C: targetEl.removeEventListener(‘click’, handler, false); IE: targetEl.detachEvent(event, handler); 事件对象\nW3C: var e = arguments.callee.caller.arguments[0] IE: window.event 事件目标\nW3C: e.target IE: window.event.srcElement 阻止事件默认行为\nW3C: e.preventDefault() IE: window.event.returnValue = false 阻止事件传播\nW3C: e.stopPropagation() IE: window.event.cancelBubble = true W3C事件的 target 与 currentTarget 的区别？\ntarget 只会出现在事件流的目标阶段 currentTarget 可能出现在事件流的任何阶段 当事件流处在目标阶段时，二者的指向相同 当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级) 如何派发事件(dispatchEvent)？（如何进行事件广播？）\nW3C: 使用 dispatchEvent 方法 IE: 使用 fireEvent 方法 var fireEvent = function(element, event){ if (document.createEventObject){ var mockEvent = document.createEventObject(); return element.fireEvent('on' + event, mockEvent) }else{ var mockEvent = document.createEvent('HTMLEvents'); mockEvent.initEvent(event, true, true); return !element.dispatchEvent(mockEvent); } } 什么是函数节流？介绍一下应用场景和原理？\n函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。 只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。 但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）\n函数节流用于 onresize, onscroll 等短时间内会多次触发的事件\n函数节流的原理：使用定时器做时间节流。 当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。 如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器， 再 setTimeout 一个新的定时器重复以上流程。\n函数节流简单实现：\nfunction throttle(method, context) { clearTimeout(methor.tId); method.tId = setTimeout(function(){ method.call(context); }， 100); // 两次调用至少间隔 100ms } // 调用 window.onresize = function(){ throttle(myFunc, window); } 区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？\n客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY) 页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY) 屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY) 如何获得一个DOM元素的绝对位置？\nelem.offsetLeft：返回元素相对于其定位父级左侧的距离 elem.offsetTop：返回元素相对于其定位父级顶部的距离 elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素 分析 [‘1’, ‘2’, ‘3’].map(parseInt) 答案是多少？\n答案:[1, NaN, NaN] parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析 map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引 因此，map 遍历 [“1”, “2”, “3”]，相应 parseInt 接收参数如下 parseInt('1', 0); // 1 parseInt('2', 1); // NaN parseInt('3', 2); // NaN 所以，parseInt 参数 radix 不合法，导致返回值为 NaN new 操作符具体干了什么？\n创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this 用原生JavaScript的实现过什么功能吗？\n封装选择器、调用第三方API、设置和获取样式 解释一下这段代码的意思吗？\n[].forEach.call($$(\"*\"), function(el){ el.style.outline = \"1px solid #\" + (~~(Math.random()*(1\u003c\u003c24))).toString(16); }) 解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓outline 1. `$$(sel)` // $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel) 2. `[].forEach.call(NodeLists)` // 使用 call 函数将数组遍历函数 forEach 应到节点元素列表 3. `el.style.outline = \"1px solid #333\"` // 样式 outline 位于盒模型之外，不影响元素布局位置 4. `(1\u003c\u003c24)` // parseInt(\"ffffff\", 16) == 16777215 == 2^24 - 1 // 1\u003c\u003c24 == 2^24 == 16777216 5. `Math.random()*(1\u003c\u003c24)` // 表示一个位于 0 到 16777216 之间的随机浮点数 6. `~~Math.random()*(1\u003c\u003c24)` // `~~` 作用相当于 parseInt 取整 7. `(~~(Math.random()*(1\u003c\u003c24))).toString(16)` // 转换为一个十六进制- ** JavaScript实现异步编程的方法？**\n回调函数 事件监听 发布/订阅 Promises对象 Async函数[ES7] web开发中会话跟踪的方法有哪些\ncookie session url重写 隐藏input ip地址 介绍js的基本数据类型\nUndefined、Null、Boolean、Number、String 介绍js有哪些内置对象？\nObject 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 说几条写JavaScript的基本规范？\n不要在同一行声明多个变量 请使用 ===/!==来比较true/false或者数值 使用对象字面量替代new Array这种形式 不要使用全局函数 Switch语句必须带有default分支 函数不应该有时候有返回值，有时候没有返回值 If语句必须使用大括号 for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污 JavaScript原型，原型链 ? 有什么特点？\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时\n如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念\n关系：instance.constructor.prototype = instance.__proto__\n特点：\nJavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的\n就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象\nJavaScript有几种类型的值？，你能画一下他们的内存图吗？\n栈：原始数据类型（Undefined，Null，Boolean，Number、String）\n堆：引用数据类型（对象、数组和函数）\n两种类型的区别是：存储位置不同；\n原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；\n引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其\n在栈中的地址，取得地址后从堆中获得实体\nJavascript如何实现继承？\n构造继承\n原型继承\n实例继承\n拷贝继承\n原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式\nfunction Parent(){ this.name = 'wang'; } function Child(){ this.age = 28; } Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 } javascript创建对象的几种方式？\njavascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用\n对象字面量的方式 person={firstname:\"Mark\",lastname:\"Yun\",age:25,eyecolor:\"black\"}; 用function来模拟无参的构造函数 function Person(){} var person=new Person();//定义一个function，如果使用new\"实例化\",该function可以看作是一个Class person.name=\"Mark\"; person.age=\"25\"; person.work=function(){ alert(person.name+\" hello...\"); } person.work(); 用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） function Pet(name,age,hobby){ this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function(){ alert(\"我叫\"+this.name+\",我喜欢\"+this.hobby+\",是个程序员\"); } } var maidou =new Pet(\"麦兜\",25,\"coding\");//实例化、创建对象 maidou.eat();//调用eat方法 用工厂方式来创建（内置对象） var wcDog =new Object(); wcDog.name=\"旺财\"; wcDog.age=3; wcDog.work=function(){ alert(\"我是\"+wcDog.name+\",汪汪汪......\"); } wcDog.work(); 用原型方式来创建 function Dog(){ } Dog.prototype.name=\"旺财\"; Dog.prototype.eat=function(){ alert(this.name+\"是个吃货\"); } var wangcai =new Dog(); wangcai.eat(); 用混合方式来创建 function Car(name,price){ this.name=name; this.price=price; } Car.prototype.sell=function(){ alert(\"我是\"+this.name+\"，我现在卖\"+this.price+\"万元\"); } var camry =new Car(\"凯美瑞\",27); camry.sell(); Javascript作用链域?\n全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找 直至全局函数，这种组织形式就是作用域链 谈谈This对象的理解\nthis总是指向函数的直接调用者（而非间接调用者） 如果有new关键字，this指向new出来的那个对象 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window eval是做什么的？\n它的功能是把对应的字符串解析成JS代码并运行 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行） 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(’(’+ str +’)’) null，undefined 的区别？\nundefined 表示不存在这个值。\nundefined :是一个表示\"无\"的原始值或者说表示\"缺少值\"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined\n例如变量被声明了，但没有赋值时，就等于undefined\nnull 表示一个对象被定义了，值为“空值”\nnull : 是一个对象(空对象, 没有任何属性和方法)\n例如作为函数的参数，表示该函数的参数不是对象；\n在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined\n写一个通用的事件侦听器函数\n// event(事件)工具集，来源：github.com/markyun markyun.Event = { // 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != 'function') { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); }; } }, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent('on' + type, function() { handler.call(element); }); } else { element['on' + type] = handler; } }, // 移除事件 removeEvent : function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.datachEvent) { element.detachEvent('on' + type, handler); } else { element['on' + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; } }, // 取消事件的默认行为 preventDefault : function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev \u0026\u0026 Event == ev.constructor) { break; } c = c.caller; } } return ev; } }; [“1”, “2”, “3”].map(parseInt) 答案是多少？\n[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。 map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？\n我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件 ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 什么是闭包（closure），为什么要用它？\n闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域\n闭包的特性：\n函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 javascript 代码中的\"use strict\";是什么意思 ? 使用它区别是什么？\nuse strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为 如何判断一个对象是否属于某个类？\n// 使用instanceof （待完善） if(a instanceof Person){ alert('yes'); } new操作符具体干了什么呢?\n创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型 属性和方法被加入到 this 引用的对象中 新创建的对象由 this 所引用，并且最后隐式的返回 this var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); js延迟加载的方式有哪些？\ndefer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax 是什么? 如何创建一个Ajax？\najax的全称：Asynchronous Javascript And XML\n异步传输+js+xml\n所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验\n创建XMLHttpRequest对象,也就是创建一个异步调用对象\n建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n设置响应HTTP请求状态变化的函数\n发送HTTP请求\n获取异步调用返回的数据\n用JavaScript和DOM实现局部刷新\n同步和异步的区别?\n同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容 异步加载JS的方式有哪些？\ndefer，只支持IE async： 创建script，插入到DOM中，加载完毕后callBack documen.write和 innerHTML的区别\ndocument.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点?\n（1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 那些操作会造成内存泄漏？\n内存泄漏指任何对象在您不再拥有或需要它之后仍然存在 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 渐进增强和优雅降级\n渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。\n优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容\nJavascript垃圾回收方法\n标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境” 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting)\n在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间\njs继承方式及其优缺点\n原型链继承的缺点\n一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承）\n借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承\n组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 defer和async\ndefer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 用过哪些设计模式？\n工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例 function createObject(name,age,profession){//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () { return this.name + ' at ' + this.age + ' engaged in ' + this.profession; }; return obj; } var test1 = createObject('trigkit4',22,'programmer');//第一个实例var test2 = createObject('mike',25,'engineer');//第二个实例 构造函数模式\n使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于 构造函数方法没有显示的创建对象 (new Object());\n直接将属性和方法赋值给 this 对象;\n没有 renturn 语句\n说说你对闭包的理解\n使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念\n闭包有三个特性：\n1.函数嵌套函数\n2.函数内部可以引用外部的参数和变量\n3.参数和变量不会被垃圾回收机制回收\n请解释一下 JavaScript 的同源策略\n概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议 指一段脚本只能读取来自同一来源的窗口和文档的属性 为什么要有同源限制？\n我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点 现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制\nObject.prototype.clone = function(){ var o = this.constructor === Array ? [] : {}; for(var e in this){ o[e] = typeof this[e] === \"object\" ? this[e].clone() : this[e]; } return o; } 说说严格模式的限制\n严格模式主要有以下限制：\n变量必须声明后再使用\n函数的参数不能有同名属性，否则报错\n不能使用with语句\n不能对只读属性赋值，否则报错\n不能使用前缀0表示八进制数，否则报错\n不能删除不可删除的属性，否则报错\n不能删除变量delete prop，会报错，只能删除属性delete global[prop]\neval不会在它的外层作用域引入变量\neval和arguments不能被重新赋值\narguments不会自动反映函数参数的变化\n不能使用arguments.callee\n不能使用arguments.caller\n禁止this指向全局对象\n不能使用fn.caller和fn.arguments获取函数调用的堆栈\n增加了保留字（比如protected、static和interface）\n如何删除一个cookie\n将时间设为当前时间往前一点 var date = new Date(); date.setDate(date.getDate() - 1);//真正的删除 setDate()方法用于设置一个月的某一天\nexpires的设置 document.cookie = 'user='+ encodeURIComponent('name') + ';expires = ' + new Date(0) 编写一个方法 求一个字符串的字节长度\n假设：一个英文字符占用一个字节，一个中文字符占用两个字节 function GetBytes(str){ var len = str.length; var bytes = len; for(var i=0; i","wordCount":"14487","inLanguage":"en","datePublished":"2020-05-01T17:11:35+08:00","dateModified":"2020-05-01T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/javascript/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>JavaScript</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/%E9%9D%A2%E8%AF%95/>面试</a></div>29 min&nbsp;·&nbsp;<span title='2020-05-01 17:11:35 +0800 +0800'>2020/05/01</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#javascript aria-label=JavaScript>JavaScript</a></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=javascript>JavaScript<a hidden class=anchor aria-hidden=true href=#javascript>#</a></h3><hr><p><strong>JavaScript的组成</strong></p><ul><li>JavaScript 由以下三部分组成：<ul><li>ECMAScript（核心）：JavaScript 语言基础</li><li>DOM（文档对象模型）：规定了访问HTML和XML的接口</li><li>BOM（浏览器对象模型）：提供了浏览器窗口之间进行交互的对象和方法</li></ul></li></ul><p><strong>JS的基本数据类型和引用数据类型</strong></p><ul><li>基本数据类型：undefined、null、boolean、number、string、symbol</li><li>引用数据类型：object、array、function</li></ul><p><strong>检测浏览器版本版本有哪些方式？</strong></p><ul><li>根据 navigator.userAgent // UA.toLowerCase().indexOf(&lsquo;chrome&rsquo;)</li><li>根据 window 对象的成员 // &lsquo;ActiveXObject&rsquo; in window</li></ul><p><strong>介绍JS有哪些内置对象？</strong></p><ul><li>数据封装类对象：Object、Array、Boolean、Number、String</li><li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li><li>ES6新增对象：Symbol、Map、Set、Promises、Proxy、Reflect</li></ul><p><strong>说几条写JavaScript的基本规范？</strong></p><ul><li>代码缩进，建议使用“四个空格”缩进</li><li>代码段使用花括号{}包裹</li><li>语句结束使用分号;</li><li>变量和函数在使用前进行声明</li><li>以大写字母开头命名构造函数，全大写命名常量</li><li>规范定义JSON对象，补全双引号</li><li>用{}和[]声明对象和数组</li></ul><p><strong>如何编写高性能的JavaScript？</strong></p><ul><li>遵循严格模式：&ldquo;use strict&rdquo;;</li><li>将js脚本放在页面底部，加快渲染页面</li><li>将js脚本将脚本成组打包，减少请求</li><li>使用非阻塞方式下载js脚本</li><li>尽量使用局部变量来保存全局变量</li><li>尽量减少使用闭包</li><li>使用 window 对象属性方法时，省略 window</li><li>尽量减少对象成员嵌套</li><li>缓存 DOM 节点的访问</li><li>通过避免使用 eval() 和 Function() 构造器</li><li>给 setTimeout() 和 setInterval() 传递函数而不是字符串作为参数</li><li>尽量使用直接量创建对象和数组</li><li>最小化重绘(repaint)和回流(reflow)</li></ul><p><strong>描述浏览器的渲染过程，DOM树和渲染树的区别？</strong></p><ul><li><p>浏览器的渲染过程：</p><ul><li>解析HTML构建 DOM(DOM树)，并行请求 css/image/js</li><li>CSS 文件下载完成，开始构建 CSSOM(CSS树)</li><li>CSSOM 构建结束后，和 DOM 一起生成 Render Tree(渲染树)</li><li>布局(Layout)：计算出每个节点在屏幕中的位置</li><li>显示(Painting)：通过显卡把页面画到屏幕上</li></ul></li><li><p>DOM树 和 渲染树 的区别：</p><ul><li>DOM树与HTML标签一一对应，包括head和隐藏元素</li><li>渲染树不包括head和隐藏元素，大段文本的每一个行都是独立节点，每一个节点都有对应的css属性</li></ul></li></ul><p><strong>重绘和回流（重排）的区别和关系？</strong></p><ul><li>重绘：当渲染树中的元素外观（如：颜色）发生改变，不影响布局时，产生重绘</li><li>回流：当渲染树中的元素的布局（如：尺寸、位置、隐藏/状态状态）发生改变时，产生重绘回流</li><li>注意：JS获取Layout属性值（如：offsetLeft、scrollTop、getComputedStyle等）也会引起回流。因为浏览器需要通过回流计算最新值</li><li>回流必将引起重绘，而重绘不一定会引起回流</li></ul><p><strong>如何最小化重绘(repaint)和回流(reflow)？</strong></p><ul><li>需要要对元素进行复杂的操作时，可以先隐藏(display:&ldquo;none&rdquo;)，操作完成后再显示</li><li>需要创建多个DOM节点时，使用DocumentFragment创建完后一次性的加入document</li><li>缓存Layout属性值，如：var left = elem.offsetLeft; 这样，多次使用 left 只产生一次回流</li><li>尽量避免用table布局（table元素一旦触发回流就会导致table里所有的其它元素回流）</li><li>避免使用css表达式(expression)，因为每次调用都会重新计算值（包括加载页面）</li><li>尽量使用 css 属性简写，如：用 border 代替 border-width, border-style, border-color</li><li>批量修改元素样式：elem.className 和 elem.style.cssText 代替 elem.style.xxx</li></ul><p><strong>script 的位置是否会影响首屏显示时间？</strong></p><ul><li>在解析 HTML 生成 DOM 过程中，js 文件的下载是并行的，不需要 DOM 处理到 script 节点。因此，script的位置不影响首屏显示的开始时间。</li><li>浏览器解析 HTML 是自上而下的线性过程，script作为 HTML 的一部分同样遵循这个原则</li><li>因此，script 会延迟 DomContentLoad，只显示其上部分首屏内容，从而影响首屏显示的完成时间</li></ul><p><strong>解释JavaScript中的作用域与变量声明提升？</strong></p><ul><li><p>JavaScript作用域：</p><ul><li>在Java、C等语言中，作用域为for语句、if语句或{}内的一块区域，称为作用域；</li><li>而在 JavaScript 中，作用域为function(){}内的区域，称为函数作用域。</li></ul></li><li><p>JavaScript变量声明提升：</p><ul><li>在JavaScript中，函数声明与变量声明经常被JavaScript引擎隐式地提升到当前作用域的顶部。</li><li>声明语句中的赋值部分并不会被提升，只有名称被提升</li><li>函数声明的优先级高于变量，如果变量名跟函数名相同且未赋值，则函数声明会覆盖变量声明</li><li>如果函数有多个同名参数，那么最后一个参数（即使没有定义）会覆盖前面的同名参数</li></ul></li></ul><p><strong>介绍JavaScript的原型，原型链？有什么特点？</strong></p><ul><li><p>原型：</p><ul><li>JavaScript的所有对象中都包含了一个 [<strong>proto</strong>] 内部属性，这个属性所对应的就是该对象的原型</li><li>JavaScript的函数对象，除了原型 [<strong>proto</strong>] 之外，还预置了 prototype 属性</li><li>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [<strong>proto</strong>]。</li></ul></li><li><p>原型链：</p><ul><li>当一个对象调用的属性/方法自身不存在时，就会去自己 [<strong>proto</strong>] 关联的前辈 prototype 对象上去找</li><li>如果没找到，就会去该 prototype 原型 [<strong>proto</strong>] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”</li></ul></li><li><p>原型特点：</p><ul><li>JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</li></ul></li></ul><p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗</strong></p><ul><li>原始数据类型（Undefined，Null，Boolean，Number、String）&ndash; 栈</li><li>引用数据类型（对象、数组和函数）&ndash; 堆</li><li>两种类型的区别是：存储位置不同：</li><li>原始数据类型是直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据；</li><li>引用数据类型存储在堆(heap)中的对象，占据空间大、大小不固定，如果存储在栈中，将会影响程序运行的性能；</li><li>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。</li><li>当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul><p><strong>JavaScript如何实现一个类，怎么实例化这个类？</strong></p><ul><li>构造函数法（this + prototype） &ndash; 用 new 关键字 生成实例对象<ul><li>缺点：用到了 this 和 prototype，编写复杂，可读性差</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>  <span style=color:#af3a03>function</span> Mobile(name, price){
</span></span><span style=display:flex><span>     <span style=color:#af3a03>this</span>.name <span style=color:#af3a03>=</span> name;
</span></span><span style=display:flex><span>     <span style=color:#af3a03>this</span>.price <span style=color:#af3a03>=</span> price;
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   Mobile.prototype.sell <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>      alert(<span style=color:#af3a03>this</span>.name <span style=color:#af3a03>+</span> <span style=color:#79740e>&#34;，售价 $&#34;</span> <span style=color:#af3a03>+</span> <span style=color:#af3a03>this</span>.price);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   <span style=color:#af3a03>var</span> iPhone7 <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Mobile(<span style=color:#79740e>&#34;iPhone7&#34;</span>, <span style=color:#8f3f71>1000</span>);
</span></span><span style=display:flex><span>   iPhone7.sell();
</span></span></code></pre></div><ul><li>Object.create 法 &ndash; 用 Object.create() 生成实例对象</li><li>缺点：不能实现私有属性和私有方法，实例对象之间也不能共享数据</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span> <span style=color:#af3a03>var</span> Person <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>     firstname<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;Mark&#34;</span>,
</span></span><span style=display:flex><span>     lastname<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;Yun&#34;</span>,
</span></span><span style=display:flex><span>     age<span style=color:#af3a03>:</span> <span style=color:#8f3f71>25</span>,
</span></span><span style=display:flex><span>     introduce<span style=color:#af3a03>:</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>         alert(<span style=color:#79740e>&#39;I am &#39;</span> <span style=color:#af3a03>+</span> Person.firstname <span style=color:#af3a03>+</span> <span style=color:#79740e>&#39; &#39;</span> <span style=color:#af3a03>+</span> Person.lastname);
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>var</span> person <span style=color:#af3a03>=</span> <span style=color:#b57614>Object</span>.create(Person);
</span></span><span style=display:flex><span> person.introduce();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#928374;font-style:italic>// Object.create 要求 IE9+，低版本浏览器可以自行部署：
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span> <span style=color:#af3a03>if</span> (<span style=color:#af3a03>!</span><span style=color:#b57614>Object</span>.create) {
</span></span><span style=display:flex><span>　   <span style=color:#b57614>Object</span>.create <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span> (o) {
</span></span><span style=display:flex><span>　　　 <span style=color:#af3a03>function</span> F() {}
</span></span><span style=display:flex><span>　　　 F.prototype <span style=color:#af3a03>=</span> o;
</span></span><span style=display:flex><span>　　　 <span style=color:#af3a03>return</span> <span style=color:#af3a03>new</span> F();
</span></span><span style=display:flex><span>　　};
</span></span><span style=display:flex><span>　}
</span></span></code></pre></div><ul><li>极简主义法（消除 this 和 prototype） &ndash; 调用 createNew() 得到实例对象<ul><li>优点：容易理解，结构清晰优雅，符合传统的"面向对象编程"的构造</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span> <span style=color:#af3a03>var</span> Cat <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>   age<span style=color:#af3a03>:</span> <span style=color:#8f3f71>3</span>, <span style=color:#928374;font-style:italic>// 共享数据 -- 定义在类对象内，createNew() 外
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>   createNew<span style=color:#af3a03>:</span> <span style=color:#af3a03>function</span> () {
</span></span><span style=display:flex><span>     <span style=color:#af3a03>var</span> cat <span style=color:#af3a03>=</span> {};
</span></span><span style=display:flex><span>     <span style=color:#928374;font-style:italic>// var cat = Animal.createNew(); // 继承 Animal 类
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>     cat.name <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;小咪&#34;</span>;
</span></span><span style=display:flex><span>     <span style=color:#af3a03>var</span> sound <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;喵喵喵&#34;</span>; <span style=color:#928374;font-style:italic>// 私有属性--定义在 createNew() 内，输出对象外
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>     cat.makeSound <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span> () {
</span></span><span style=display:flex><span>       alert(sound);  <span style=color:#928374;font-style:italic>// 暴露私有属性
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>     };
</span></span><span style=display:flex><span>     cat.changeAge <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(num){
</span></span><span style=display:flex><span>       Cat.age <span style=color:#af3a03>=</span> num; <span style=color:#928374;font-style:italic>// 修改共享数据
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>     };
</span></span><span style=display:flex><span>     <span style=color:#af3a03>return</span> cat; <span style=color:#928374;font-style:italic>// 输出对象
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>   }
</span></span><span style=display:flex><span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>var</span> cat <span style=color:#af3a03>=</span> Cat.createNew();
</span></span><span style=display:flex><span> cat.makeSound();
</span></span></code></pre></div><ul><li>ES6 语法糖 class &ndash; 用 new 关键字 生成实例对象</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>     <span style=color:#af3a03>class</span> Point {
</span></span><span style=display:flex><span>       constructor(x, y) {
</span></span><span style=display:flex><span>         <span style=color:#af3a03>this</span>.x <span style=color:#af3a03>=</span> x;
</span></span><span style=display:flex><span>         <span style=color:#af3a03>this</span>.y <span style=color:#af3a03>=</span> y;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       toString() {
</span></span><span style=display:flex><span>         <span style=color:#af3a03>return</span> <span style=color:#79740e>&#39;(&#39;</span> <span style=color:#af3a03>+</span> <span style=color:#af3a03>this</span>.x <span style=color:#af3a03>+</span> <span style=color:#79740e>&#39;, &#39;</span> <span style=color:#af3a03>+</span> <span style=color:#af3a03>this</span>.y <span style=color:#af3a03>+</span> <span style=color:#79740e>&#39;)&#39;</span>;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>var</span> point <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Point(<span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>);
</span></span></code></pre></div><p><strong>Javascript如何实现继承？</strong></p><ul><li>构造函数绑定：使用 call 或 apply 方法，将父对象的构造函数绑定在子对象上</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#af3a03>function</span> Cat(name,color){
</span></span><span style=display:flex><span> 　Animal.apply(<span style=color:#af3a03>this</span>, arguments);
</span></span><span style=display:flex><span> 　<span style=color:#af3a03>this</span>.name <span style=color:#af3a03>=</span> name;
</span></span><span style=display:flex><span> 　<span style=color:#af3a03>this</span>.color <span style=color:#af3a03>=</span> color;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>实例继承：将子对象的 prototype 指向父对象的一个实例</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>Cat.prototype <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Animal();
</span></span><span style=display:flex><span>Cat.prototype.constructor <span style=color:#af3a03>=</span> Cat;
</span></span></code></pre></div><ul><li>拷贝继承：如果把父对象的所有属性和方法，拷贝进子对象</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    <span style=color:#af3a03>function</span> extend(Child, Parent) {
</span></span><span style=display:flex><span>  　　　<span style=color:#af3a03>var</span> p <span style=color:#af3a03>=</span> Parent.prototype;
</span></span><span style=display:flex><span>  　　　<span style=color:#af3a03>var</span> c <span style=color:#af3a03>=</span> Child.prototype;
</span></span><span style=display:flex><span>  　　　<span style=color:#af3a03>for</span> (<span style=color:#af3a03>var</span> i <span style=color:#af3a03>in</span> p) {
</span></span><span style=display:flex><span>  　　　   c[i] <span style=color:#af3a03>=</span> p[i];
</span></span><span style=display:flex><span>  　　　}
</span></span><span style=display:flex><span>  　　　c.uber <span style=color:#af3a03>=</span> p;
</span></span><span style=display:flex><span>  　 }
</span></span></code></pre></div><ul><li>原型继承：将子对象的 prototype 指向父对象的 prototype</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    <span style=color:#af3a03>function</span> extend(Child, Parent) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>var</span> F <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){};
</span></span><span style=display:flex><span>      　F.prototype <span style=color:#af3a03>=</span> Parent.prototype;
</span></span><span style=display:flex><span>      　Child.prototype <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> F();
</span></span><span style=display:flex><span>      　Child.prototype.constructor <span style=color:#af3a03>=</span> Child;
</span></span><span style=display:flex><span>      　Child.uber <span style=color:#af3a03>=</span> Parent.prototype;
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><ul><li>ES6 语法糖 extends：class ColorPoint extends Point {}</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    <span style=color:#af3a03>class</span> ColorPoint <span style=color:#af3a03>extends</span> Point {
</span></span><span style=display:flex><span>       constructor(x, y, color) {
</span></span><span style=display:flex><span>          <span style=color:#af3a03>super</span>(x, y); <span style=color:#928374;font-style:italic>// 调用父类的constructor(x, y)
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>          <span style=color:#af3a03>this</span>.color <span style=color:#af3a03>=</span> color;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       toString() {
</span></span><span style=display:flex><span>          <span style=color:#af3a03>return</span> <span style=color:#af3a03>this</span>.color <span style=color:#af3a03>+</span> <span style=color:#79740e>&#39; &#39;</span> <span style=color:#af3a03>+</span> <span style=color:#af3a03>super</span>.toString(); <span style=color:#928374;font-style:italic>// 调用父类的toString()
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>       }
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p><strong>Javascript作用链域?</strong></p><ul><li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li><li>如果当前作用域没有找到属性或方法，会向上层作用域查找，直至全局函数，这种形式就是作用域链</li></ul><p><strong>谈谈this对象的理解</strong></p><ul><li>this 总是指向函数的直接调用者</li><li>如果有 new 关键字，this 指向 new 出来的实例对象</li><li>在事件中，this指向触发这个事件的对象</li><li>IE下 attachEvent 中的this总是指向全局对象Window</li></ul><p><strong>eval是做什么的？</strong></p><p><strong>eval的功能是把对应的字符串解析成JS代码并运行</strong></p><ul><li>应该避免使用eval，不安全，非常耗性能（先解析成js语句，再执行）</li><li>由JSON字符串转换为JSON对象的时候可以用 eval(&rsquo;(&rsquo;+ str +&rsquo;)&rsquo;);</li></ul><p><strong>什么是 Window 对象? 什么是 Document 对象?</strong></p><ul><li>Window 对象表示当前浏览器的窗口，是JavaScript的顶级对象。</li><li>我们创建的所有对象、函数、变量都是 Window 对象的成员。</li><li>Window 对象的方法和属性是在全局范围内有效的。</li><li>Document 对象是 HTML 文档的根节点与所有其他节点（元素节点，文本节点，属性节点, 注释节点）</li><li>Document 对象使我们可以通过脚本对 HTML 页面中的所有元素进行访问</li><li>Document 对象是 Window 对象的一部分，可通过 window.document 属性对其进行访问</li></ul><p><strong>介绍 DOM 的发展</strong></p><ul><li>DOM：文档对象模型（Document Object Model），定义了访问HTML和XML文档的标准，与编程语言及平台无关</li><li>DOM0：提供了查询和操作Web文档的内容API。未形成标准，实现混乱。如：document.forms[&rsquo;login&rsquo;]</li><li>DOM1：W3C提出标准化的DOM，简化了对文档中任意部分的访问和操作。如：JavaScript中的Document对象</li><li>DOM2：原来DOM基础上扩充了鼠标事件等细分模块，增加了对CSS的支持。如：getComputedStyle(elem, pseudo)</li><li>DOM3：增加了XPath模块和加载与保存（Load and Save）模块。如：XPathEvaluator</li></ul><p><strong>介绍DOM0，DOM2，DOM3事件处理方式区别</strong></p><ul><li>DOM0级事件处理方式：<ul><li><code>btn.onclick = func;</code></li><li><code>btn.onclick = null;</code></li></ul></li><li>DOM2级事件处理方式：<ul><li><code>btn.addEventListener('click', func, false);</code></li><li><code>btn.removeEventListener('click', func, false);</code></li><li><code>btn.attachEvent("onclick", func);</code></li><li><code>btn.detachEvent("onclick", func);</code></li></ul></li><li>DOM3级事件处理方式：<ul><li><code>eventUtil.addListener(input, "textInput", func);</code></li><li><code>eventUtil</code> 是自定义对象，<code>textInput</code> 是DOM3级事件</li></ul></li></ul><p><strong>事件的三个阶段</strong></p><ul><li>捕获、目标、冒泡</li></ul><p><strong>介绍事件“捕获”和“冒泡”执行顺序和事件的执行次数？</strong></p><ul><li>按照W3C标准的事件：首是进入捕获阶段，直到达到目标元素，再进入冒泡阶段</li><li>事件执行次数（DOM2-addEventListener）：元素上绑定事件的个数<ul><li>注意1：前提是事件被确实触发</li><li>注意2：事件绑定几次就算几个事件，即使类型和功能完全一样也不会“覆盖”</li></ul></li><li>事件执行顺序：判断的关键是否目标元素<ul><li>非目标元素：根据W3C的标准执行：捕获->目标元素->冒泡（不依据事件绑定顺序）</li><li>目标元素：依据事件绑定顺序：先绑定的事件先执行（不依据捕获冒泡标准）</li><li>最终顺序：父元素捕获->目标元素事件1->目标元素事件2->子元素捕获->子元素冒泡->父元素冒泡</li><li>注意：子元素事件执行前提 事件确实“落”到子元素布局区域上，而不是简单的具有嵌套关系</li></ul></li></ul><p><strong>在一个DOM上同时绑定两个点击事件：一个用捕获，一个用冒泡。事件会执行几次，先执行冒泡还是捕获？</strong></p><ul><li>该DOM上的事件如果被触发，会执行两次（执行次数等于绑定次数）</li><li>如果该DOM是目标元素，则按事件绑定顺序执行，不区分冒泡/捕获</li><li>如果该DOM是处于事件流中的非目标元素，则先执行捕获，后执行冒泡</li></ul><p><strong>事件的代理/委托</strong></p><ul><li>事件委托是指将事件绑定目标元素的到父元素上，利用冒泡机制触发该事件<ul><li>优点：<ul><li>可以减少事件注册，节省大量内存占用</li><li>可以将事件应用于动态添加的子元素上</li></ul></li><li>缺点：
使用不当会造成事件在不应该触发时触发</li><li>示例：</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>ulEl.addEventListener(&#39;click&#39;, function(e){
</span></span><span style=display:flex><span>    var target = event.target || event.srcElement;
</span></span><span style=display:flex><span>    if(!!target &amp;&amp; target.nodeName.toUpperCase() === &#34;LI&#34;){
</span></span><span style=display:flex><span>        console.log(target.innerHTML);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}, false);
</span></span></code></pre></div><p><strong>IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p><ul><li>IE只事件冒泡，不支持事件捕获；火狐同时支持件冒泡和事件捕获</li></ul><p><strong>IE的事件处理和W3C的事件处理有哪些区别？</strong></p><ul><li><p>绑定事件</p><ul><li>W3C: targetEl.addEventListener(&lsquo;click&rsquo;, handler, false);</li><li>IE: targetEl.attachEvent(&lsquo;onclick&rsquo;, handler);</li></ul></li><li><p>删除事件</p><ul><li>W3C: targetEl.removeEventListener(&lsquo;click&rsquo;, handler, false);</li><li>IE: targetEl.detachEvent(event, handler);</li></ul></li><li><p>事件对象</p><ul><li>W3C: var e = arguments.callee.caller.arguments[0]</li><li>IE: window.event</li></ul></li><li><p>事件目标</p><ul><li>W3C: e.target</li><li>IE: window.event.srcElement</li></ul></li><li><p>阻止事件默认行为</p><ul><li>W3C: e.preventDefault()</li><li>IE: window.event.returnValue = false</li></ul></li><li><p>阻止事件传播</p><ul><li>W3C: e.stopPropagation()</li><li>IE: window.event.cancelBubble = true</li></ul></li></ul><p><strong>W3C事件的 target 与 currentTarget 的区别？</strong></p><ul><li>target 只会出现在事件流的目标阶段</li><li>currentTarget 可能出现在事件流的任何阶段</li><li>当事件流处在目标阶段时，二者的指向相同</li><li>当事件流处于捕获或冒泡阶段时：currentTarget 指向当前事件活动的对象(一般为父级)</li></ul><p><strong>如何派发事件(dispatchEvent)？（如何进行事件广播？）</strong></p><ul><li>W3C: 使用 dispatchEvent 方法</li><li>IE: 使用 fireEvent 方法</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#af3a03>var</span> fireEvent <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(element, event){
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span> (<span style=color:#b57614>document</span>.createEventObject){
</span></span><span style=display:flex><span>        <span style=color:#af3a03>var</span> mockEvent <span style=color:#af3a03>=</span> <span style=color:#b57614>document</span>.createEventObject();
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> element.fireEvent(<span style=color:#79740e>&#39;on&#39;</span> <span style=color:#af3a03>+</span> event, mockEvent)
</span></span><span style=display:flex><span>    }<span style=color:#af3a03>else</span>{
</span></span><span style=display:flex><span>        <span style=color:#af3a03>var</span> mockEvent <span style=color:#af3a03>=</span> <span style=color:#b57614>document</span>.createEvent(<span style=color:#79740e>&#39;HTMLEvents&#39;</span>);
</span></span><span style=display:flex><span>        mockEvent.initEvent(event, <span style=color:#af3a03>true</span>, <span style=color:#af3a03>true</span>);
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> <span style=color:#af3a03>!</span>element.dispatchEvent(mockEvent);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>什么是函数节流？介绍一下应用场景和原理？</strong></p><ul><li><p>函数节流(throttle)是指阻止一个函数在很短时间间隔内连续调用。
只有当上一次函数执行后达到规定的时间间隔，才能进行下一次调用。
但要保证一个累计最小调用间隔（否则拖拽类的节流都将无连续效果）</p></li><li><p>函数节流用于 onresize, onscroll 等短时间内会多次触发的事件</p></li><li><p>函数节流的原理：使用定时器做时间节流。
当触发一个事件时，先用 setTimout 让这个事件延迟一小段时间再执行。
如果在这个时间间隔内又触发了事件，就 clearTimeout 原来的定时器，
再 setTimeout 一个新的定时器重复以上流程。</p></li><li><p>函数节流简单实现：</p></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#af3a03>function</span> throttle(method, context) {
</span></span><span style=display:flex><span>     clearTimeout(methor.tId);
</span></span><span style=display:flex><span>     method.tId <span style=color:#af3a03>=</span> setTimeout(<span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>         method.call(context);
</span></span><span style=display:flex><span>     }， <span style=color:#8f3f71>100</span>); <span style=color:#928374;font-style:italic>// 两次调用至少间隔 100ms
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>}
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 调用
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>window</span>.onresize <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>    throttle(myFunc, <span style=color:#b57614>window</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>区分什么是“客户区坐标”、“页面坐标”、“屏幕坐标”？</strong></p><ul><li>客户区坐标：鼠标指针在可视区中的水平坐标(clientX)和垂直坐标(clientY)</li><li>页面坐标：鼠标指针在页面布局中的水平坐标(pageX)和垂直坐标(pageY)</li><li>屏幕坐标：设备物理屏幕的水平坐标(screenX)和垂直坐标(screenY)</li></ul><p><strong>如何获得一个DOM元素的绝对位置？</strong></p><ul><li>elem.offsetLeft：返回元素相对于其定位父级左侧的距离</li><li>elem.offsetTop：返回元素相对于其定位父级顶部的距离</li><li>elem.getBoundingClientRect()：返回一个DOMRect对象，包含一组描述边框的只读属性，单位像素</li></ul><p><strong>分析 [&lsquo;1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;].map(parseInt) 答案是多少？</strong></p><ul><li>答案:[1, NaN, NaN]</li></ul><ul><li>parseInt(string, radix) 第2个参数 radix 表示进制。省略 radix 或 radix = 0，则数字将以十进制解析</li><li>map 每次为 parseInt 传3个参数(elem, index, array)，其中 index 为数组索引</li><li>因此，map 遍历 [&ldquo;1&rdquo;, &ldquo;2&rdquo;, &ldquo;3&rdquo;]，相应 parseInt 接收参数如下</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>parseInt(&#39;1&#39;, 0);  // 1
</span></span><span style=display:flex><span>parseInt(&#39;2&#39;, 1);  // NaN
</span></span><span style=display:flex><span>parseInt(&#39;3&#39;, 2);  // NaN
</span></span></code></pre></div><ul><li>所以，parseInt 参数 radix 不合法，导致返回值为 NaN</li></ul><p><strong>new 操作符具体干了什么？</strong></p><ul><li>创建实例对象，this 变量引用该对象，同时还继承了构造函数的原型</li><li>属性和方法被加入到 this 引用的对象中</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul><p><strong>用原生JavaScript的实现过什么功能吗？</strong></p><ul><li>封装选择器、调用第三方API、设置和获取样式</li></ul><p><strong>解释一下这段代码的意思吗？</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>  [].forEach.call($$(<span style=color:#79740e>&#34;*&#34;</span>), <span style=color:#af3a03>function</span>(el){
</span></span><span style=display:flex><span>      el.style.outline <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;1px solid #&#34;</span> <span style=color:#af3a03>+</span> (<span style=color:#af3a03>~~</span>(<span style=color:#b57614>Math</span>.random()<span style=color:#af3a03>*</span>(<span style=color:#8f3f71>1</span><span style=color:#af3a03>&lt;&lt;</span><span style=color:#8f3f71>24</span>))).toString(<span style=color:#8f3f71>16</span>);
</span></span><span style=display:flex><span>  })
</span></span></code></pre></div><ul><li>解释：获取页面所有的元素，遍历这些元素，为它们添加1像素随机颜色的轮廓outline</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#8f3f71>1.</span> <span style=color:#79740e>`$$(sel)`</span> <span style=color:#928374;font-style:italic>// $$函数被许多现代浏览器命令行支持，等价于 document.querySelectorAll(sel)
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#8f3f71>2.</span> <span style=color:#79740e>`[].forEach.call(NodeLists)`</span> <span style=color:#928374;font-style:italic>// 使用 call 函数将数组遍历函数 forEach 应到节点元素列表
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#8f3f71>3.</span> <span style=color:#79740e>`el.style.outline = &#34;1px solid #333&#34;`</span> <span style=color:#928374;font-style:italic>// 样式 outline 位于盒模型之外，不影响元素布局位置
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#8f3f71>4.</span> <span style=color:#79740e>`(1&lt;&lt;24)`</span> <span style=color:#928374;font-style:italic>// parseInt(&#34;ffffff&#34;, 16) == 16777215 == 2^24 - 1 // 1&lt;&lt;24 == 2^24 == 16777216
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#8f3f71>5.</span> <span style=color:#79740e>`Math.random()*(1&lt;&lt;24)`</span> <span style=color:#928374;font-style:italic>// 表示一个位于 0 到 16777216 之间的随机浮点数
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#8f3f71>6.</span> <span style=color:#79740e>`~~Math.random()*(1&lt;&lt;24)`</span> <span style=color:#928374;font-style:italic>// `~~` 作用相当于 parseInt 取整
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#8f3f71>7.</span> <span style=color:#79740e>`(~~(Math.random()*(1&lt;&lt;24))).toString(16)`</span> <span style=color:#928374;font-style:italic>// 转换为一个十六进制- 
</span></span></span></code></pre></div><p>** JavaScript实现异步编程的方法？**</p><ul><li>回调函数</li><li>事件监听</li><li>发布/订阅</li><li>Promises对象</li><li>Async函数[ES7]</li></ul><p><strong>web开发中会话跟踪的方法有哪些</strong></p><ul><li>cookie</li><li>session</li><li>url重写</li><li>隐藏input</li><li>ip地址</li></ul><p><strong>介绍js的基本数据类型</strong></p><ul><li>Undefined、Null、Boolean、Number、String</li></ul><p><strong>介绍js有哪些内置对象？</strong></p><ul><li>Object 是 JavaScript 中所有对象的父对象</li><li>数据封装类对象：Object、Array、Boolean、Number 和 String</li><li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li></ul><p><strong>说几条写JavaScript的基本规范？</strong></p><ul><li>不要在同一行声明多个变量</li><li>请使用 ===/!==来比较true/false或者数值</li><li>使用对象字面量替代new Array这种形式</li><li>不要使用全局函数</li><li>Switch语句必须带有default分支</li><li>函数不应该有时候有返回值，有时候没有返回值</li><li>If语句必须使用大括号</li><li>for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污</li></ul><p><strong>JavaScript原型，原型链 ? 有什么特点？</strong></p><ul><li><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时</p></li><li><p>如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念</p></li><li><p>关系：<code>instance.constructor.prototype = instance.__proto__</code></p></li><li><p>特点：</p><ul><li>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</li></ul></li><li><p>当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的</p></li><li><p>就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象</p></li></ul><p><strong>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</strong></p><ul><li><p>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</p></li><li><p>堆：引用数据类型（对象、数组和函数）</p></li><li><p>两种类型的区别是：存储位置不同；</p></li><li><p>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</p></li><li><p>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定,如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其</p></li><li><p>在栈中的地址，取得地址后从堆中获得实体</p></li></ul><p><img loading=lazy src=https://camo.githubusercontent.com/d1947e624a0444d1032a85800013df487adc5550/687474703a2f2f7777772e77337363686f6f6c2e636f6d2e636e2f692f63745f6a735f76616c75652e676966 alt></p><p><strong>Javascript如何实现继承？</strong></p><ul><li><p>构造继承</p></li><li><p>原型继承</p></li><li><p>实例继承</p></li><li><p>拷贝继承</p></li><li><p>原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式</p></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> function Parent(){
</span></span><span style=display:flex><span>        this.name = &#39;wang&#39;;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    function Child(){
</span></span><span style=display:flex><span>        this.age = 28;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Child.prototype = new Parent();//继承了Parent，通过原型
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    var demo = new Child();
</span></span><span style=display:flex><span>    alert(demo.age);
</span></span><span style=display:flex><span>    alert(demo.name);//得到被继承的属性
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p><strong>javascript创建对象的几种方式？</strong></p><blockquote><p>javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用</p></blockquote><ul><li>对象字面量的方式</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>person={firstname:&#34;Mark&#34;,lastname:&#34;Yun&#34;,age:25,eyecolor:&#34;black&#34;};
</span></span></code></pre></div><ul><li>用function来模拟无参的构造函数</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> function Person(){}
</span></span><span style=display:flex><span>    var person=new Person();//定义一个function，如果使用new&#34;实例化&#34;,该function可以看作是一个Class
</span></span><span style=display:flex><span>        person.name=&#34;Mark&#34;;
</span></span><span style=display:flex><span>        person.age=&#34;25&#34;;
</span></span><span style=display:flex><span>        person.work=function(){
</span></span><span style=display:flex><span>        alert(person.name+&#34; hello...&#34;);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>person.work();
</span></span></code></pre></div><ul><li>用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function Pet(name,age,hobby){
</span></span><span style=display:flex><span>       this.name=name;//this作用域：当前对象
</span></span><span style=display:flex><span>       this.age=age;
</span></span><span style=display:flex><span>       this.hobby=hobby;
</span></span><span style=display:flex><span>       this.eat=function(){
</span></span><span style=display:flex><span>          alert(&#34;我叫&#34;+this.name+&#34;,我喜欢&#34;+this.hobby+&#34;,是个程序员&#34;);
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    var maidou =new Pet(&#34;麦兜&#34;,25,&#34;coding&#34;);//实例化、创建对象
</span></span><span style=display:flex><span>    maidou.eat();//调用eat方法
</span></span></code></pre></div><ul><li>用工厂方式来创建（内置对象）</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>var wcDog =new Object();
</span></span><span style=display:flex><span>     wcDog.name=&#34;旺财&#34;;
</span></span><span style=display:flex><span>     wcDog.age=3;
</span></span><span style=display:flex><span>     wcDog.work=function(){
</span></span><span style=display:flex><span>       alert(&#34;我是&#34;+wcDog.name+&#34;,汪汪汪......&#34;);
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     wcDog.work();
</span></span></code></pre></div><ul><li>用原型方式来创建</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function Dog(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     Dog.prototype.name=&#34;旺财&#34;;
</span></span><span style=display:flex><span>     Dog.prototype.eat=function(){
</span></span><span style=display:flex><span>     alert(this.name+&#34;是个吃货&#34;);
</span></span><span style=display:flex><span>     }
</span></span><span style=display:flex><span>     var wangcai =new Dog();
</span></span><span style=display:flex><span>     wangcai.eat();
</span></span></code></pre></div><ul><li>用混合方式来创建</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> function Car(name,price){
</span></span><span style=display:flex><span>      this.name=name;
</span></span><span style=display:flex><span>      this.price=price; 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>     Car.prototype.sell=function(){
</span></span><span style=display:flex><span>       alert(&#34;我是&#34;+this.name+&#34;，我现在卖&#34;+this.price+&#34;万元&#34;);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    var camry =new Car(&#34;凯美瑞&#34;,27);
</span></span><span style=display:flex><span>    camry.sell(); 
</span></span></code></pre></div><p><strong>Javascript作用链域?</strong></p><ul><li>全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节</li><li>当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找</li><li>直至全局函数，这种组织形式就是作用域链</li></ul><p><strong>谈谈This对象的理解</strong></p><ul><li>this总是指向函数的直接调用者（而非间接调用者）</li><li>如果有new关键字，this指向new出来的那个对象</li><li>在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window</li></ul><p><strong>eval是做什么的？</strong></p><ul><li>它的功能是把对应的字符串解析成JS代码并运行</li><li>应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）</li><li>由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&rsquo;(&rsquo;+ str +&rsquo;)&rsquo;)</li></ul><p><strong>null，undefined 的区别？</strong></p><ul><li><p>undefined 表示不存在这个值。</p></li><li><p>undefined :是一个表示"无"的原始值或者说表示"缺少值"，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined</p></li><li><p>例如变量被声明了，但没有赋值时，就等于undefined</p></li><li><p>null 表示一个对象被定义了，值为“空值”</p></li><li><p>null : 是一个对象(空对象, 没有任何属性和方法)</p></li><li><p>例如作为函数的参数，表示该函数的参数不是对象；</p></li><li><p>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</p></li></ul><p><strong>写一个通用的事件侦听器函数</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> // event(事件)工具集，来源：github.com/markyun
</span></span><span style=display:flex><span>    markyun.Event = {
</span></span><span style=display:flex><span>        // 页面加载完成后
</span></span><span style=display:flex><span>        readyEvent : function(fn) {
</span></span><span style=display:flex><span>            if (fn==null) {
</span></span><span style=display:flex><span>                fn=document;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            var oldonload = window.onload;
</span></span><span style=display:flex><span>            if (typeof window.onload != &#39;function&#39;) {
</span></span><span style=display:flex><span>                window.onload = fn;
</span></span><span style=display:flex><span>            } else {
</span></span><span style=display:flex><span>                window.onload = function() {
</span></span><span style=display:flex><span>                    oldonload();
</span></span><span style=display:flex><span>                    fn();
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        // 视能力分别使用dom0||dom2||IE方式 来绑定事件
</span></span><span style=display:flex><span>        // 参数： 操作的元素,事件名称 ,事件处理程序
</span></span><span style=display:flex><span>        addEvent : function(element, type, handler) {
</span></span><span style=display:flex><span>            if (element.addEventListener) {
</span></span><span style=display:flex><span>                //事件类型、需要执行的函数、是否捕捉
</span></span><span style=display:flex><span>                element.addEventListener(type, handler, false);
</span></span><span style=display:flex><span>            } else if (element.attachEvent) {
</span></span><span style=display:flex><span>                element.attachEvent(&#39;on&#39; + type, function() {
</span></span><span style=display:flex><span>                    handler.call(element);
</span></span><span style=display:flex><span>                });
</span></span><span style=display:flex><span>            } else {
</span></span><span style=display:flex><span>                element[&#39;on&#39; + type] = handler;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        // 移除事件
</span></span><span style=display:flex><span>        removeEvent : function(element, type, handler) {
</span></span><span style=display:flex><span>            if (element.removeEventListener) {
</span></span><span style=display:flex><span>                element.removeEventListener(type, handler, false);
</span></span><span style=display:flex><span>            } else if (element.datachEvent) {
</span></span><span style=display:flex><span>                element.detachEvent(&#39;on&#39; + type, handler);
</span></span><span style=display:flex><span>            } else {
</span></span><span style=display:flex><span>                element[&#39;on&#39; + type] = null;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
</span></span><span style=display:flex><span>        stopPropagation : function(ev) {
</span></span><span style=display:flex><span>            if (ev.stopPropagation) {
</span></span><span style=display:flex><span>                ev.stopPropagation();
</span></span><span style=display:flex><span>            } else {
</span></span><span style=display:flex><span>                ev.cancelBubble = true;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        // 取消事件的默认行为
</span></span><span style=display:flex><span>        preventDefault : function(event) {
</span></span><span style=display:flex><span>            if (event.preventDefault) {
</span></span><span style=display:flex><span>                event.preventDefault();
</span></span><span style=display:flex><span>            } else {
</span></span><span style=display:flex><span>                event.returnValue = false;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        // 获取事件目标
</span></span><span style=display:flex><span>        getTarget : function(event) {
</span></span><span style=display:flex><span>            return event.target || event.srcElement;
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
</span></span><span style=display:flex><span>        getEvent : function(e) {
</span></span><span style=display:flex><span>            var ev = e || window.event;
</span></span><span style=display:flex><span>            if (!ev) {
</span></span><span style=display:flex><span>                var c = this.getEvent.caller;
</span></span><span style=display:flex><span>                while (c) {
</span></span><span style=display:flex><span>                    ev = c.arguments[0];
</span></span><span style=display:flex><span>                    if (ev &amp;&amp; Event == ev.constructor) {
</span></span><span style=display:flex><span>                        break;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    c = c.caller;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            return ev;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    };
</span></span></code></pre></div><p><strong>[&ldquo;1&rdquo;, &ldquo;2&rdquo;, &ldquo;3&rdquo;].map(parseInt) 答案是多少？</strong></p><ul><li>[1, NaN, NaN] 因为 parseInt 需要两个参数 (val, radix)，其中 radix 表示解析时用的基数。</li><li>map 传了 3 个 (element, index, array)，对应的 radix 不合法导致解析失败。</li></ul><p><strong>事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？</strong></p><ul><li>我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为</li><li>事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件</li><li>ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;）</li></ul><p><strong>什么是闭包（closure），为什么要用它？</strong></p><ul><li><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域</p></li><li><p>闭包的特性：</p><ul><li>函数内再嵌套函数</li><li>内部函数可以引用外层的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ul></li></ul><p><strong>javascript 代码中的"use strict";是什么意思 ? 使用它区别是什么？</strong></p><ul><li>use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行,使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为</li></ul><p><strong>如何判断一个对象是否属于某个类？</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 使用instanceof （待完善）
</span></span><span style=display:flex><span>   if(a instanceof Person){
</span></span><span style=display:flex><span>       alert(&#39;yes&#39;);
</span></span><span style=display:flex><span>   }
</span></span></code></pre></div><p><strong>new操作符具体干了什么呢?</strong></p><ul><li>创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型</li><li>属性和方法被加入到 this 引用的对象中</li><li>新创建的对象由 this 所引用，并且最后隐式的返回 this</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>var obj  = {};
</span></span><span style=display:flex><span>obj.__proto__ = Base.prototype;
</span></span><span style=display:flex><span>Base.call(obj);
</span></span></code></pre></div><p><strong>js延迟加载的方式有哪些？</strong></p><ul><li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li></ul><p><strong>Ajax 是什么? 如何创建一个Ajax？</strong></p><blockquote><p>ajax的全称：Asynchronous Javascript And XML</p></blockquote><ul><li><p>异步传输+js+xml</p></li><li><p>所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验</p></li><li><p>创建XMLHttpRequest对象,也就是创建一个异步调用对象</p></li><li><p>建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息</p></li><li><p>设置响应HTTP请求状态变化的函数</p></li><li><p>发送HTTP请求</p></li><li><p>获取异步调用返回的数据</p></li><li><p>用JavaScript和DOM实现局部刷新</p></li></ul><p><strong>同步和异步的区别?</strong></p><ul><li>同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作</li><li>异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容</li></ul><p><strong>异步加载JS的方式有哪些？</strong></p><ul><li>defer，只支持IE</li><li>async：</li><li>创建script，插入到DOM中，加载完毕后callBack</li></ul><p><strong>documen.write和 innerHTML的区别</strong></p><ul><li>document.write只能重绘整个页面</li><li>innerHTML可以重绘页面的一部分</li></ul><p><strong>DOM操作——怎样添加、移除、移动、复制、创建和查找节点?</strong></p><ul><li>（1）创建新节点<ul><li>createDocumentFragment() //创建一个DOM片段</li><li>createElement() //创建一个具体的元素</li><li>createTextNode() //创建一个文本节点</li></ul></li><li>（2）添加、移除、替换、插入<ul><li>appendChild()</li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore() //在已有的子节点前插入一个新的子节点</li></ul></li><li>（3）查找<ul><li>getElementsByTagName() //通过标签名称</li><li>getElementsByName() // 通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li><li>getElementById() //通过元素Id，唯一性</li></ul></li></ul><p><strong>那些操作会造成内存泄漏？</strong></p><ul><li>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在</li><li>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</li><li>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏</li><li>闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</li></ul><p><strong>渐进增强和优雅降级</strong></p><ul><li><p>渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p></li><li><p>优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容</p></li></ul><p><strong>Javascript垃圾回收方法</strong></p><ul><li>标记清除（mark and sweep）</li></ul><blockquote><ul><li>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”</li><li>垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了</li></ul></blockquote><p><strong>引用计数(reference counting)</strong></p><blockquote><p>在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间</p></blockquote><p><strong>js继承方式及其优缺点</strong></p><ul><li><p>原型链继承的缺点</p><ul><li>一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。</li></ul></li><li><p>借用构造函数（类式继承）</p><ul><li>借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承</li></ul></li><li><p>组合式继承</p><ul><li>组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。</li></ul></li></ul><p><strong>defer和async</strong></p><ul><li>defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行</li></ul><p><strong>用过哪些设计模式？</strong></p><ul><li>工厂模式：<ul><li>主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复</li><li>工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例</li></ul></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function createObject(name,age,profession){//集中实例化的函数var obj = new Object();
</span></span><span style=display:flex><span>    obj.name = name;
</span></span><span style=display:flex><span>    obj.age = age;
</span></span><span style=display:flex><span>    obj.profession = profession;
</span></span><span style=display:flex><span>    obj.move = function () {
</span></span><span style=display:flex><span>        return this.name + &#39; at &#39; + this.age + &#39; engaged in &#39; + this.profession;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    return obj;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>var test1 = createObject(&#39;trigkit4&#39;,22,&#39;programmer&#39;);//第一个实例var test2 = createObject(&#39;mike&#39;,25,&#39;engineer&#39;);//第二个实例
</span></span></code></pre></div><ul><li><p>构造函数模式</p><ul><li>使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于</li></ul></li><li><p>构造函数方法没有显示的创建对象 (new Object());</p></li><li><p>直接将属性和方法赋值给 this 对象;</p></li><li><p>没有 renturn 语句</p></li></ul><p><strong>说说你对闭包的理解</strong></p><ul><li><p>使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念</p></li><li><p>闭包有三个特性：</p><ul><li><p>1.函数嵌套函数</p></li><li><p>2.函数内部可以引用外部的参数和变量</p></li><li><p>3.参数和变量不会被垃圾回收机制回收</p></li></ul></li></ul><p><strong>请解释一下 JavaScript 的同源策略</strong></p><ul><li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</li><li>指一段脚本只能读取来自同一来源的窗口和文档的属性</li></ul><p><strong>为什么要有同源限制？</strong></p><ul><li>我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。</li><li>缺点<ul><li>现在网站的JS都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节</li></ul></li></ul><p><strong>实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>Object.prototype.clone = function(){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            var o = this.constructor === Array ? [] : {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            for(var e in this){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                    o[e] = typeof this[e] === &#34;object&#34; ? this[e].clone() : this[e];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            return o;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span></code></pre></div><p><strong>说说严格模式的限制</strong></p><ul><li><p>严格模式主要有以下限制：</p></li><li><p>变量必须声明后再使用</p></li><li><p>函数的参数不能有同名属性，否则报错</p></li><li><p>不能使用with语句</p></li><li><p>不能对只读属性赋值，否则报错</p></li><li><p>不能使用前缀0表示八进制数，否则报错</p></li><li><p>不能删除不可删除的属性，否则报错</p></li><li><p>不能删除变量delete prop，会报错，只能删除属性delete global[prop]</p></li><li><p>eval不会在它的外层作用域引入变量</p></li><li><p>eval和arguments不能被重新赋值</p></li><li><p>arguments不会自动反映函数参数的变化</p></li><li><p>不能使用arguments.callee</p></li><li><p>不能使用arguments.caller</p></li><li><p>禁止this指向全局对象</p></li><li><p>不能使用fn.caller和fn.arguments获取函数调用的堆栈</p></li><li><p>增加了保留字（比如protected、static和interface）</p></li></ul><p><strong>如何删除一个cookie</strong></p><ul><li>将时间设为当前时间往前一点</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>var date = new Date();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>date.setDate(date.getDate() - 1);//真正的删除
</span></span></code></pre></div><p>setDate()方法用于设置一个月的某一天</p><ul><li>expires的设置</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  document.cookie = &#39;user=&#39;+ encodeURIComponent(&#39;name&#39;)  + &#39;;expires = &#39; + new Date(0)
</span></span></code></pre></div><p><strong>编写一个方法 求一个字符串的字节长度</strong></p><ul><li>假设：一个英文字符占用一个字节，一个中文字符占用两个字节</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>function GetBytes(str){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        var len = str.length;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        var bytes = len;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        for(var i=0; i&lt;len; i++){
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            if (str.charCodeAt(i) &gt; 255) bytes++;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return bytes;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>alert(GetBytes(&#34;你好,as&#34;));
</span></span></code></pre></div><p><strong>请解释什么是事件代理</strong></p><ul><li>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能</li></ul><p><strong>attribute和property的区别是什么？</strong></p><ul><li><p>attribute是dom元素在文档中作为html标签拥有的属性；</p></li><li><p>property就是dom元素在js中作为对象拥有的属性。</p></li><li><p>对于html的标准属性来说，attribute和property是同步的，是会自动更新的</p></li><li><p>但是对于自定义的属性来说，他们是不同步的</p></li></ul><p><strong>页面编码和被请求的资源编码如果不一致如何处理？</strong></p><ul><li>后端响应头设置 charset</li><li>前端页面<code>&lt;meta></code>设置 charset</li></ul><p><strong>把<code>&lt;script></code>放在<code>&lt;/body></code>之前和之后有什么区别？浏览器会如何解析它们？</strong></p><ul><li>按照HTML标准，在<code>&lt;/body></code>结束后出现<code>&lt;script></code>或任何元素的开始标签，都是解析错误</li><li>虽然不符合HTML标准，但浏览器会自动容错，使实际效果与写在<code>&lt;/body></code>之前没有区别</li><li>浏览器的容错机制会忽略script之前的<code>&lt;/body></code>，视作<code>&lt;script></code>仍在 body 体内。省略<code>&lt;/body></code>和<code>&lt;/html></code>闭合标签符合HTML标准，服务器可以利用这一标准尽可能少输出内容</li></ul><p><strong>延迟加载JS的方式有哪些？</strong></p><ul><li>设置<code>&lt;script></code>属性 defer=&ldquo;defer&rdquo; （脚本将在页面完成解析时执行）</li><li>动态创建 script DOM：document.createElement(&lsquo;script&rsquo;);</li><li>XmlHttpRequest 脚本注入</li><li>延迟加载工具 LazyLoad</li></ul><p><strong>异步加载JS的方式有哪些？</strong></p><ul><li>设置<code>&lt;script></code>属性 async=&ldquo;async&rdquo; （一旦脚本可用，则会异步执行）</li><li>动态创建 script DOM：document.createElement(&lsquo;script&rsquo;);</li><li>XmlHttpRequest 脚本注入</li><li>异步加载库 LABjs</li><li>模块加载器 Sea.js</li></ul><p><strong>JavaScript 中，调用函数有哪几种方式？</strong></p><ul><li>方法调用模式 Foo.foo(arg1, arg2);</li><li>函数调用模式 foo(arg1, arg2);</li><li>构造器调用模式 (new Foo())(arg1, arg2);</li><li>call/applay调用模式 Foo.foo.call(that, arg1, arg2);</li><li>bind调用模式 Foo.foo.bind(that)(arg1, arg2)();</li></ul><p><strong>简单实现 Function.bind 函数？</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>  <span style=color:#af3a03>if</span> (<span style=color:#af3a03>!</span><span style=color:#b57614>Function</span>.prototype.bind) {
</span></span><span style=display:flex><span>    <span style=color:#b57614>Function</span>.prototype.bind <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(that) {
</span></span><span style=display:flex><span>      <span style=color:#af3a03>var</span> func <span style=color:#af3a03>=</span> <span style=color:#af3a03>this</span>, args <span style=color:#af3a03>=</span> arguments;
</span></span><span style=display:flex><span>      <span style=color:#af3a03>return</span> <span style=color:#af3a03>function</span>() {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> func.apply(that, <span style=color:#b57614>Array</span>.prototype.slice.call(args, <span style=color:#8f3f71>1</span>));
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// 只支持 bind 阶段的默认参数：
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  func.bind(that, arg1, arg2)();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// 不支持以下调用阶段传入的参数：
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  func.bind(that)(arg1, arg2);
</span></span></code></pre></div><p>** 列举一下JavaScript数组和对象有哪些原生方法 **</p><ul><li><p>数组：</p><ul><li>arr.concat(arr1, arr2, arrn);</li><li>arr.join(",");</li><li>arr.sort(func);</li><li>arr.pop();</li><li>arr.push(e1, e2, en);</li><li>arr.shift();</li><li>unshift(e1, e2, en);</li><li>arr.reverse();</li><li>arr.slice(start, end);</li><li>arr.splice(index, count, e1, e2, en);</li><li>arr.indexOf(el);</li><li>arr.includes(el); // ES6</li></ul></li><li><p>对象：</p><ul><li>object.hasOwnProperty(prop);</li><li>object.propertyIsEnumerable(prop);</li><li>object.valueOf();</li><li>object.toString();</li><li>object.toLocaleString();</li><li>Class.prototype.isPropertyOf(object);</li></ul></li></ul><p><strong>Array.splice() 与 Array.splice() 的区别？</strong></p><ul><li><p>slice &ndash; “读取”数组指定的元素，不会对原数组进行修改</p><ul><li>语法：arr.slice(start, end)</li><li>start 指定选取开始位置（含）</li><li>end 指定选取结束位置（不含）</li></ul></li><li><p>splice</p><ul><li>“操作”数组指定的元素，会修改原数组，返回被删除的元素</li><li>语法：arr.splice(index, count, [insert Elements])</li><li>index 是操作的起始位置</li><li>count = 0 插入元素，count > 0 删除元素</li><li>[insert Elements] 向数组新插入的元素</li></ul></li></ul><p><strong>JavaScript 对象生命周期的理解？</strong></p><ul><li>当创建一个对象时，JavaScript 会自动为该对象分配适当的内存</li><li>垃圾回收器定期扫描对象，并计算引用了该对象的其他对象的数量</li><li>如果被引用数量为 0，或惟一引用是循环的，那么该对象的内存即可回收</li></ul><p><strong>哪些操作会造成内存泄漏？</strong></p><ul><li><p>JavaScript 内存泄露指对象在不需要使用它时仍然存在，导致占用的内存不能使用或回收</p></li><li><p>未使用 var 声明的全局变量</p></li><li><p>闭包函数(Closures)</p></li><li><p>循环引用(两个对象相互引用)</p></li><li><p>控制台日志(console.log)</p></li><li><p>移除存在绑定事件的DOM元素(IE)</p></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/%E9%9D%A2%E8%AF%95/>面试</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/thinks/20210501-book/><span class=title>« Prev</span><br><span>一些闲书</span></a>
<a class=next href=https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/202308-%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/><span class=title>Next »</span><br><span>手写代码</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>