<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>浏览器 | Bablvsj's Blog</title><meta name=keywords content="面试题集"><meta name=description content="浏览器 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="浏览器"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-01T17:11:35+08:00"><meta property="article:modified_time" content="2020-01-01T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="浏览器"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"浏览器","item":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"浏览器","name":"浏览器","description":"","keywords":["面试题集"],"articleBody":"二、跨域 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败\n2.1 JSONP JSONP 的原理很简单，就是利用 script标签没有跨域限制的漏洞。通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时\n\u003cscript src=\"http://domain/api?param1=a\u0026param2=b\u0026callback=jsonp\"\u003e\u003c/script\u003e \u003cscript\u003e function jsonp(data) { console.log(data) } \u003c/script\u003e JSONP 使用简单且兼容性不错，但是只限于 get 请求 2.2 CORS CORS需要浏览器和后端同时支持 浏览器会自动进行 CORS 通信，实现CORS通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源 2.3 document.domain 该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = 'test.com' 表示二级域名都相同就可以实现跨域 2.4 postMessage 这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息\n// 发送消息端 window.parent.postMessage('message', 'http://test.com'); // 接收消息端 var mc = new MessageChannel(); mc.addEventListener('message', (event) =\u003e { var origin = event.origin || event.originalEvent.origin; if (origin === 'http://test.com') { console.log('验证通过') } }); 三、Event loop 3.1 JS中的event loop 众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）\nJS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为 console.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); console.log('script end'); 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 jobs，macrotask 称为 task\nconsole.log('script start'); setTimeout(function() { console.log('setTimeout'); }, 0); new Promise((resolve) =\u003e { console.log('Promise') resolve() }).then(function() { console.log('promise1'); }).then(function() { console.log('promise2'); }); console.log('script end'); // script start =\u003e Promise =\u003e script end =\u003e promise1 =\u003e promise2 =\u003e setTimeout 以上代码虽然 setTimeout 写在 Promise 之前，但是因为 Promise 属于微任务而 setTimeout 属于宏任务\n微任务\nprocess.nextTick promise Object.observe MutationObserver 宏任务\nscript setTimeout setInterval setImmediate I/O UI rendering 宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务\n所以正确的一次 Event loop 顺序是这样的\n执行同步代码，这属于宏任务 执行栈为空，查询是否有微任务需要执行 执行所有微任务 必要的话渲染 UI 然后开始下一轮 Event loop，执行宏任务中的异步代码 通过上述的 Event loop 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的响应界面响应，我们可以把操作 DOM 放入微任务中\n3.2 Node 中的 Event loop Node 中的 Event loop 和浏览器中的不相同。 Node 的 Event loop 分为6个阶段，它们会按照顺序反复运行 ┌───────────────────────┐ ┌─\u003e│ timers │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ I/O callbacks │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ │ │ idle, prepare │ │ └──────────┬────────────┘ ┌───────────────┐ │ ┌──────────┴────────────┐ │ incoming: │ │ │ poll │\u003c──connections─── │ │ └──────────┬────────────┘ │ data, etc. │ │ ┌──────────┴────────────┐ └───────────────┘ │ │ check │ │ └──────────┬────────────┘ │ ┌──────────┴────────────┐ └──┤ close callbacks │ └───────────────────────┘ timer\ntimers 阶段会执行 setTimeout 和 setInterval 一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟 I/O\nI/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调 idle, prepare idle, prepare 阶段内部实现\npoll\npoll 阶段很重要，这一阶段中，系统会做两件事情\n执行到点的定时器 执行 poll 队列中的事件 并且当 poll 中没有定时器的情况下，会发现以下两件事情\n如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制 如果 poll 队列为空，会有两件事发生 如果有 setImmediate 需要执行，poll 阶段会停止并且进入到 check 阶段执行 setImmediate 如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调 如果有别的定时器需要被执行，会回到 timer 阶段执行回调。 check\ncheck 阶段执行 setImmediate close callbacks\nclose callbacks 阶段执行 close 事件 并且在 Node 中，有些情况下的定时器执行顺序是随机的 setTimeout(() =\u003e { console.log('setTimeout'); }, 0); setImmediate(() =\u003e { console.log('setImmediate'); }) // 这里可能会输出 setTimeout，setImmediate // 可能也会相反的输出，这取决于性能 // 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate // 否则会执行 setTimeout 上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行\nsetTimeout(()=\u003e{ console.log('timer1') Promise.resolve().then(function() { console.log('promise1') }) }, 0) setTimeout(()=\u003e{ console.log('timer2') Promise.resolve().then(function() { console.log('promise2') }) }, 0) // 以上代码在浏览器和 node 中打印情况是不同的 // 浏览器中一定打印 timer1, promise1, timer2, promise2 // node 中可能打印 timer1, timer2, promise1, promise2 // 也可能打印 timer1, promise1, timer2, promise2 Node 中的 process.nextTick 会先于其他 microtask 执行\nsetTimeout(() =\u003e { console.log(\"timer1\"); Promise.resolve().then(function() { console.log(\"promise1\"); }); }, 0); process.nextTick(() =\u003e { console.log(\"nextTick\"); }); // nextTick, timer1, promise1 四、Service Worker Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API\n目前该技术通常用来做缓存文件，提高首屏速度\n// index.js if (navigator.serviceWorker) { navigator.serviceWorker .register(\"sw.js\") .then(function(registration) { console.log(\"service worker 注册成功\"); }) .catch(function(err) { console.log(\"servcie worker 注册失败\"); }); } // sw.js // 监听 `install` 事件，回调中缓存所需文件 self.addEventListener(\"install\", e =\u003e { e.waitUntil( caches.open(\"my-cache\").then(function(cache) { return cache.addAll([\"./index.html\", \"./index.js\"]); }) ); }); // 拦截所有请求事件 // 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据 self.addEventListener(\"fetch\", e =\u003e { e.respondWith( caches.match(e.request).then(function(response) { if (response) { return response; } console.log(\"fetch source\"); }) ); }); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了\n在 Cache 中也可以发现我们所需的文件已被缓存\n当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的\n五、渲染机制 浏览器的渲染机制一般分为以下几个步骤\n处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢 当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM 5.1 图层 一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用\n通过以下几个常用属性可以生成新图层\n3D 变换：translate3d、translateZ will-change video、iframe 标签 通过动画实现的 opacity 动画转换 position: fixed 5.2 重绘（Repaint）和回流（Reflow） 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流\n所以以下几个动作可能会导致性能问题：\n改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 很多人不知道的是，重绘和回流其实和 Event loop 有关\n当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调 减少重绘和回流\n使用 translate 替代 top 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame CSS 选择符从右往左匹配查找，避免 DOM 深度过深 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变为图层 ","wordCount":"3456","inLanguage":"en","datePublished":"2020-01-01T17:11:35+08:00","dateModified":"2020-01-01T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E6%B5%8F%E8%A7%88%E5%99%A8/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>浏览器</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/>面试题集</a></div>7 min&nbsp;·&nbsp;<span title='2020-01-01 17:11:35 +0800 +0800'>2020/01/01</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e4%ba%8c%e8%b7%a8%e5%9f%9f aria-label=二、跨域>二、跨域</a><ul><li><a href=#21-jsonp aria-label="2.1 JSONP">2.1 JSONP</a></li><li><a href=#22-cors aria-label="2.2 CORS">2.2 CORS</a></li><li><a href=#23-documentdomain aria-label="2.3 document.domain">2.3 document.domain</a></li><li><a href=#24-postmessage aria-label="2.4 postMessage">2.4 postMessage</a></li></ul></li><li><a href=#%e4%b8%89event-loop aria-label="三、Event loop">三、Event loop</a><ul><li><a href=#31-js%e4%b8%ad%e7%9a%84event-loop aria-label="3.1 JS中的event loop">3.1 JS中的event loop</a></li><li><a href=#32-node-%e4%b8%ad%e7%9a%84-event-loop aria-label="3.2 Node 中的 Event loop">3.2 Node 中的 Event loop</a></li></ul></li><li><a href=#%e5%9b%9bservice-worker aria-label="四、Service Worker">四、Service Worker</a></li><li><a href=#%e4%ba%94%e6%b8%b2%e6%9f%93%e6%9c%ba%e5%88%b6 aria-label=五、渲染机制>五、渲染机制</a><ul><li><a href=#51-%e5%9b%be%e5%b1%82 aria-label="5.1 图层">5.1 图层</a></li><li><a href=#52-%e9%87%8d%e7%bb%98repaint%e5%92%8c%e5%9b%9e%e6%b5%81reflow aria-label="5.2 重绘（Repaint）和回流（Reflow）">5.2 重绘（Repaint）和回流（Reflow）</a></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=二跨域>二、跨域<a hidden class=anchor aria-hidden=true href=#二跨域>#</a></h2><blockquote><p>因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败</p></blockquote><h3 id=21-jsonp>2.1 JSONP<a hidden class=anchor aria-hidden=true href=#21-jsonp>#</a></h3><blockquote><p>JSONP 的原理很简单，就是利用 script标签没有跨域限制的漏洞。通过 script 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时</p></blockquote><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#9d0006>script</span> <span style=color:#79740e;font-weight:700>src</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp&#34;</span>&gt;&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#9d0006>script</span>&gt;
</span></span><span style=display:flex><span>    <span style=color:#af3a03>function</span> jsonp(data) {
</span></span><span style=display:flex><span>    	console.log(data)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span></code></pre></div><ul><li>JSONP 使用简单且兼容性不错，但是只限于 get 请求</li></ul><h3 id=22-cors>2.2 CORS<a hidden class=anchor aria-hidden=true href=#22-cors>#</a></h3><ul><li><code>CORS</code>需要浏览器和后端同时支持</li><li>浏览器会自动进行 <code>CORS</code> 通信，实现CORS通信的关键是后端。只要后端实现了 <code>CORS</code>，就实现了跨域。</li><li>服务端设置 <code>Access-Control-Allow-Origin</code> 就可以开启 <code>CORS</code>。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源</li></ul><h3 id=23-documentdomain>2.3 document.domain<a hidden class=anchor aria-hidden=true href=#23-documentdomain>#</a></h3><ul><li>该方式只能用于二级域名相同的情况下，比如 <code>a.test.com</code> 和 <code>b.test.com</code> 适用于该方式。</li><li>只需要给页面添加 <code>document.domain = 'test.com'</code> 表示二级域名都相同就可以实现跨域</li></ul><h3 id=24-postmessage>2.4 postMessage<a hidden class=anchor aria-hidden=true href=#24-postmessage>#</a></h3><blockquote><p>这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息</p></blockquote><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>// 发送消息端
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#b57614>window</span>.parent.postMessage(<span style=color:#79740e>&#39;message&#39;</span>, <span style=color:#79740e>&#39;http://test.com&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 接收消息端
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>var</span> mc <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> MessageChannel();
</span></span><span style=display:flex><span>mc.addEventListener(<span style=color:#79740e>&#39;message&#39;</span>, (event) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>var</span> origin <span style=color:#af3a03>=</span> event.origin <span style=color:#af3a03>||</span> event.originalEvent.origin; 
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span> (origin <span style=color:#af3a03>===</span> <span style=color:#79740e>&#39;http://test.com&#39;</span>) {
</span></span><span style=display:flex><span>        console.log(<span style=color:#79740e>&#39;验证通过&#39;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=三event-loop>三、Event loop<a hidden class=anchor aria-hidden=true href=#三event-loop>#</a></h2><h3 id=31-js中的event-loop>3.1 JS中的event loop<a hidden class=anchor aria-hidden=true href=#31-js中的event-loop>#</a></h3><blockquote><p>众所周知 JS 是门非阻塞单线程语言，因为在最初 JS 就是为了和浏览器交互而诞生的。如果 JS 是门多线程的语言话，我们在多个线程中处理 DOM 就可能会发生问题（一个线程中新加节点，另一个线程中删除节点）</p></blockquote><ul><li>JS 在执行的过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task（有多种 task） 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>console.log(<span style=color:#79740e>&#39;script start&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>setTimeout(<span style=color:#af3a03>function</span>() {
</span></span><span style=display:flex><span>  console.log(<span style=color:#79740e>&#39;setTimeout&#39;</span>);
</span></span><span style=display:flex><span>}, <span style=color:#8f3f71>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.log(<span style=color:#79740e>&#39;script end&#39;</span>);
</span></span></code></pre></div><blockquote><p>不同的任务源会被分配到不同的 <code>Task</code> 队列中，任务源可以分为 微任务（<code>microtask</code>） 和 宏任务（<code>macrotask</code>）。在 <code>ES6</code> 规范中，<code>microtask</code> 称为 jobs，macrotask 称为 task</p></blockquote><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>console.log(<span style=color:#79740e>&#39;script start&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>setTimeout(<span style=color:#af3a03>function</span>() {
</span></span><span style=display:flex><span>  console.log(<span style=color:#79740e>&#39;setTimeout&#39;</span>);
</span></span><span style=display:flex><span>}, <span style=color:#8f3f71>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>new</span> <span style=color:#b57614>Promise</span>((resolve) =&gt; {
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;Promise&#39;</span>)
</span></span><span style=display:flex><span>    resolve()
</span></span><span style=display:flex><span>}).then(<span style=color:#af3a03>function</span>() {
</span></span><span style=display:flex><span>  console.log(<span style=color:#79740e>&#39;promise1&#39;</span>);
</span></span><span style=display:flex><span>}).then(<span style=color:#af3a03>function</span>() {
</span></span><span style=display:flex><span>  console.log(<span style=color:#79740e>&#39;promise2&#39;</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>console.log(<span style=color:#79740e>&#39;script end&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// script start =&gt; Promise =&gt; script end =&gt; promise1 =&gt; promise2 =&gt; setTimeout
</span></span></span></code></pre></div><blockquote><p>以上代码虽然 <code>setTimeout</code> 写在 <code>Promise</code> 之前，但是因为 <code>Promise</code> 属于微任务而 <code>setTimeout</code> 属于宏任务</p></blockquote><p><strong>微任务</strong></p><ul><li><code>process.nextTick</code></li><li><code>promise</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><p><strong>宏任务</strong></p><ul><li><code>script</code></li><li><code>setTimeout</code></li><li><code>setInterval</code></li><li><code>setImmediate</code></li><li><code>I/O</code></li><li><code>UI rendering</code></li></ul><blockquote><p>宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务</p></blockquote><p><strong>所以正确的一次 Event loop 顺序是这样的</strong></p><ul><li>执行同步代码，这属于宏任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 <code>Event loop</code>，执行宏任务中的异步代码</li></ul><blockquote><p>通过上述的 <code>Event loop</code> 顺序可知，如果宏任务中的异步代码有大量的计算并且需要操作 <code>DOM</code> 的话，为了更快的响应界面响应，我们可以把操作 <code>DOM</code> 放入微任务中</p></blockquote><h3 id=32-node-中的-event-loop>3.2 Node 中的 Event loop<a hidden class=anchor aria-hidden=true href=#32-node-中的-event-loop>#</a></h3><ul><li><code>Node</code> 中的 <code>Event loop</code> 和浏览器中的不相同。</li><li><code>Node</code> 的 <code>Event loop</code> 分为<code>6</code>个阶段，它们会按照顺序反复运行</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>┌───────────────────────┐
</span></span><span style=display:flex><span>┌─<span style=color:#af3a03>&gt;</span>│        timers         │
</span></span><span style=display:flex><span>│  └──────────┬────────────┘
</span></span><span style=display:flex><span>│  ┌──────────┴────────────┐
</span></span><span style=display:flex><span>│  │     I<span style=color:#af3a03>/</span>O callbacks     │
</span></span><span style=display:flex><span>│  └──────────┬────────────┘
</span></span><span style=display:flex><span>│  ┌──────────┴────────────┐
</span></span><span style=display:flex><span>│  │     idle, prepare     │
</span></span><span style=display:flex><span>│  └──────────┬────────────┘      ┌───────────────┐
</span></span><span style=display:flex><span>│  ┌──────────┴────────────┐      │   incoming<span style=color:#af3a03>:</span>   │
</span></span><span style=display:flex><span>│  │         poll          │<span style=color:#af3a03>&lt;</span>──connections───     │
</span></span><span style=display:flex><span>│  └──────────┬────────────┘      │   data, etc.  │
</span></span><span style=display:flex><span>│  ┌──────────┴────────────┐      └───────────────┘
</span></span><span style=display:flex><span>│  │        check          │
</span></span><span style=display:flex><span>│  └──────────┬────────────┘
</span></span><span style=display:flex><span>│  ┌──────────┴────────────┐
</span></span><span style=display:flex><span>└──┤    close callbacks    │
</span></span><span style=display:flex><span>   └───────────────────────┘
</span></span></code></pre></div><p><strong>timer</strong></p><ul><li><code>timers</code> 阶段会执行 <code>setTimeout</code> 和 <code>setInterval</code></li><li>一个 timer 指定的时间并不是准确时间，而是在达到这个时间后尽快执行回调，可能会因为系统正在执行别的事务而延迟</li></ul><p><strong>I/O</strong></p><ul><li><code>I/O</code> 阶段会执行除了 <code>close</code> 事件，定时器和 <code>setImmediate</code> 的回调</li></ul><p>idle, prepare
idle, prepare 阶段内部实现</p><p><strong>poll</strong></p><ul><li><p><code>poll</code> 阶段很重要，这一阶段中，系统会做两件事情</p><ul><li>执行到点的定时器</li><li>执行 <code>poll</code> 队列中的事件</li></ul></li><li><p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p><ul><li>如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果 poll 队列为空，会有两件事发生</li><li>如果有 <code>setImmediate</code> 需要执行，<code>poll</code> 阶段会停止并且进入到 <code>check</code> 阶段执行 <code>setImmediate</code></li><li>如果没有 <code>setImmediate</code> 需要执行，会等待回调被加入到队列中并立即执行回调</li><li>如果有别的定时器需要被执行，会回到 <code>timer</code> 阶段执行回调。</li></ul></li></ul><p><strong>check</strong></p><ul><li><code>check</code> 阶段执行 <code>setImmediate</code></li></ul><p><strong>close callbacks</strong></p><ul><li><code>close callbacks</code> 阶段执行 <code>close</code> 事件</li><li>并且在 <code>Node</code> 中，有些情况下的定时器执行顺序是随机的</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>setTimeout(() =&gt; {
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;setTimeout&#39;</span>);
</span></span><span style=display:flex><span>}, <span style=color:#8f3f71>0</span>);
</span></span><span style=display:flex><span>setImmediate(() =&gt; {
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;setImmediate&#39;</span>);
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 这里可能会输出 setTimeout，setImmediate
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 可能也会相反的输出，这取决于性能
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 否则会执行 setTimeout
</span></span></span></code></pre></div><blockquote><p>上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行</p></blockquote><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>setTimeout(()=&gt;{
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;timer1&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#b57614>Promise</span>.resolve().then(<span style=color:#af3a03>function</span>() {
</span></span><span style=display:flex><span>        console.log(<span style=color:#79740e>&#39;promise1&#39;</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}, <span style=color:#8f3f71>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>setTimeout(()=&gt;{
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;timer2&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#b57614>Promise</span>.resolve().then(<span style=color:#af3a03>function</span>() {
</span></span><span style=display:flex><span>        console.log(<span style=color:#79740e>&#39;promise2&#39;</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}, <span style=color:#8f3f71>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 以上代码在浏览器和 node 中打印情况是不同的
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 浏览器中一定打印 timer1, promise1, timer2, promise2
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// node 中可能打印 timer1, timer2, promise1, promise2
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 也可能打印 timer1, promise1, timer2, promise2
</span></span></span></code></pre></div><blockquote><p><code>Node</code> 中的 <code>process.nextTick</code> 会先于其他 <code>microtask</code> 执行</p></blockquote><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>setTimeout(() =&gt; {
</span></span><span style=display:flex><span> console.log(<span style=color:#79740e>&#34;timer1&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#b57614>Promise</span>.resolve().then(<span style=color:#af3a03>function</span>() {
</span></span><span style=display:flex><span>   console.log(<span style=color:#79740e>&#34;promise1&#34;</span>);
</span></span><span style=display:flex><span> });
</span></span><span style=display:flex><span>}, <span style=color:#8f3f71>0</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>process.nextTick(() =&gt; {
</span></span><span style=display:flex><span> console.log(<span style=color:#79740e>&#34;nextTick&#34;</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// nextTick, timer1, promise1
</span></span></span></code></pre></div><h2 id=四service-worker>四、Service Worker<a hidden class=anchor aria-hidden=true href=#四service-worker>#</a></h2><blockquote><p>Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理。它们旨在（除其他之外）使得能够创建有效的离线体验，拦截网络请求并基于网络是否可用以及更新的资源是否驻留在服务器上来采取适当的动作。他们还允许访问推送通知和后台同步API</p></blockquote><p><strong>目前该技术通常用来做缓存文件，提高首屏速度</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>// index.js
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>if</span> (navigator.serviceWorker) {
</span></span><span style=display:flex><span>  navigator.serviceWorker
</span></span><span style=display:flex><span>    .register(<span style=color:#79740e>&#34;sw.js&#34;</span>)
</span></span><span style=display:flex><span>    .then(<span style=color:#af3a03>function</span>(registration) {
</span></span><span style=display:flex><span>      console.log(<span style=color:#79740e>&#34;service worker 注册成功&#34;</span>);
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    .<span style=color:#af3a03>catch</span>(<span style=color:#af3a03>function</span>(err) {
</span></span><span style=display:flex><span>      console.log(<span style=color:#79740e>&#34;servcie worker 注册失败&#34;</span>);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// sw.js
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 监听 `install` 事件，回调中缓存所需文件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>self.addEventListener(<span style=color:#79740e>&#34;install&#34;</span>, e =&gt; {
</span></span><span style=display:flex><span>  e.waitUntil(
</span></span><span style=display:flex><span>    caches.open(<span style=color:#79740e>&#34;my-cache&#34;</span>).then(<span style=color:#af3a03>function</span>(cache) {
</span></span><span style=display:flex><span>      <span style=color:#af3a03>return</span> cache.addAll([<span style=color:#79740e>&#34;./index.html&#34;</span>, <span style=color:#79740e>&#34;./index.js&#34;</span>]);
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 拦截所有请求事件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>self.addEventListener(<span style=color:#79740e>&#34;fetch&#34;</span>, e =&gt; {
</span></span><span style=display:flex><span>  e.respondWith(
</span></span><span style=display:flex><span>    caches.match(e.request).then(<span style=color:#af3a03>function</span>(response) {
</span></span><span style=display:flex><span>      <span style=color:#af3a03>if</span> (response) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> response;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      console.log(<span style=color:#79740e>&#34;fetch source&#34;</span>);
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><blockquote><p>打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了</p></blockquote><p><img loading=lazy src="https://user-gold-cdn.xitu.io/2018/3/28/1626b1e8eba68e1c?w=1770&h=722&f=png&s=192277" alt></p><blockquote><p>在 Cache 中也可以发现我们所需的文件已被缓存</p></blockquote><p><img loading=lazy src="https://user-gold-cdn.xitu.io/2018/3/28/1626b20dfc4fcd26?w=1118&h=728&f=png&s=85610" alt></p><p>当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的</p><h2 id=五渲染机制>五、渲染机制<a hidden class=anchor aria-hidden=true href=#五渲染机制>#</a></h2><p><strong>浏览器的渲染机制一般分为以下几个步骤</strong></p><ul><li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li><li>处理 <code>CSS</code> 构建 <code>CSSOM</code> 树。</li><li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li></ul><p><img loading=lazy src="https://user-gold-cdn.xitu.io/2018/4/11/162b2ab2ec70ac5b?w=900&h=352&f=png&s=49983" alt></p><ul><li>在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且构建 CSSOM 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 CSS 选择器，执行速度越慢</li><li>当 HTML 解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM</li></ul><h3 id=51-图层>5.1 图层<a hidden class=anchor aria-hidden=true href=#51-图层>#</a></h3><blockquote><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用</p></blockquote><p><strong>通过以下几个常用属性可以生成新图层</strong></p><ul><li>3D 变换：<code>translate3d</code>、<code>translateZ</code></li><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li><li>通过动画实现的 <code>opacity</code> 动画转换</li><li><code>position: fixed</code></li></ul><h3 id=52-重绘repaint和回流reflow>5.2 重绘（Repaint）和回流（Reflow）<a hidden class=anchor aria-hidden=true href=#52-重绘repaint和回流reflow>#</a></h3><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><p><strong>所以以下几个动作可能会导致性能问题</strong>：</p><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p><ul><li>当 Event loop 执行完 <code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz </code>的刷新率，每 <code>16ms </code>才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code> 才会触发一次，并且自带节流功能。</li><li>判断是否触发了<code> media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li></ul><p><strong>减少重绘和回流</strong></p><ul><li>使用 <code>translate</code> 替代 <code>top</code></li><li>使用 <code>visibility</code> 替换<code> display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code> 选择符从右往左匹配查找，避免 <code>DOM</code> 深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video </code>标签，浏览器会自动将该节点变为图层</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86/>面试题集</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/20230801-%E6%A8%A1%E5%9D%97%E5%8C%96/><span class=title>« Prev</span><br><span>模块化</span></a>
<a class=next href=https://bablvsj.github.io/posts/tech/wait/14-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/%E7%A1%85%E8%B0%B7%E7%94%84%E9%80%89%E7%AC%94%E8%AE%B0/><span class=title>Next »</span><br><span>浏览器</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>