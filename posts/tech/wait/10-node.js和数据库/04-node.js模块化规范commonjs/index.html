<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>04-Node.js模块化规范：CommonJS | Bablvsj's Blog</title><meta name=keywords content="Node"><meta name=description content="04-Node.js模块化规范：CommonJS - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/04-node.js%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83commonjs/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="04-Node.js模块化规范：CommonJS"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/04-node.js%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83commonjs/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-01T17:11:35+08:00"><meta property="article:modified_time" content="2020-01-01T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="04-Node.js模块化规范：CommonJS"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"04-Node.js模块化规范：CommonJS","item":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/04-node.js%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83commonjs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"04-Node.js模块化规范：CommonJS","name":"04-Node.js模块化规范：CommonJS","description":"","keywords":["Node"],"articleBody":"前言 网站越来越复杂，js代码、js文件也越来越多，会遇到一些问题：\n文件依赖\n全局污染、命名冲突\n程序模块化包括：\n日期模块\n数学计算模块\n日志模块\n登陆认证模块\n报表展示模块等。\n所有这些模块共同组成了程序软件系统。\n一次编写，多次使用，才是提高效率的核心。\n模块化的理解 什么是模块化 概念：将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起。\n模块的内部数据、实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。\n最早的时候，我们会把所有的代码都写在一个js文件里，那么，耦合性会很高（关联性强），不利于维护；而且会造成全局污染，很容易命名冲突。\n模块化的好处 避免命名冲突，减少命名空间污染\n降低耦合性；更好地分离、按需加载\n高复用性：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能。\n高可维护性：软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁。使用模块化的开发，方式更容易维护。\n部署方便\n模块化规范 模块化规范的引入 假设我们引入模块化，首先可能会想到的思路是：在一个文件中引入多个js文件。如下：\n\u003cbody\u003e \u003cscript src=\"zepto.js\"\u003e\u003c/script\u003e \u003cscript src=\"fastClick.js\"\u003e\u003c/script\u003e \u003cscript src=\"util/login.js\"\u003e\u003c/script\u003e \u003cscript src=\"util/base.js\"\u003e\u003c/script\u003e \u003cscript src=\"util/city.js\"\u003e\u003c/script\u003e \u003c/body\u003e 但是这样做会带来很多问题：\n请求过多：引入十个js文件，就有十次http请求。\n依赖模糊：不同的js文件可能会相互依赖，如果改其中的一个文件，另外一个文件可能会报错。\n以上两点，最终导致：难以维护。\n于是，这就引入了模块化规范。\n模块化的概念解读 模块化起源于 Node.js。Node.js 中把很多 js 打包成 package，需要的时候直接通过 require 的方式进行调用（CommonJS），这就是模块化的方式。\n那如何把这种模块化思维应用到前端来呢？这就产生了两种伟大的 js：RequireJS 和 SeaJS。\n模块化规范 服务器端规范：\nCommonJS规范：是 Node.js 使用的模块化规范。 CommonJS 就是一套约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。\n浏览器端规范：\nAMD规范：是 RequireJS 在推广过程中对模块化定义的规范化产出。 - 异步加载模块； - 依赖前置、提前执行：require([`foo`,`bar`],function(foo,bar){}); //也就是说把所有的包都 require 成功，再继续执行代码。 - define 定义模块：define([`require`,`foo`],function(){return}); CMD规范：是 SeaJS 在推广过程中对模块化定义的规范化产出。淘宝团队开发。 同步加载模块； 依赖就近，延迟执行：require(./a) 直接引入。或者Require.async 异步引入。 //依赖就近：执行到这一部分的时候，再去加载对应的文件。 define 定义模块， export 导出：define(function(require, export, module){}); PS：面试时，经常会问AMD 和 CMD 的区别。\n另外，还有ES6规范：import \u0026 export。\n这篇文章，我们来讲一下CommonJS，它是 Node.js 使用的模块化规范。\nCommonJS 的基本语法 CommonJS 的介绍 CommonJS：是 Node.js 使用的模块化规范。也就是说，Node.js 就是基于 CommonJS 这种模块化规范来编写的。\nCommonJS 规范规定：每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的 module.exports 对象。\n在 CommonJS 中，每个文件都可以当作一个模块：\n在服务器端：模块的加载是运行时同步加载的。\n在浏览器端: 模块需要提前编译打包处理。首先，既然同步的，很容易引起阻塞；其次，浏览器不认识require语法，因此，需要提前编译打包。\n模块的暴露和引入 Node.js 中只有模块级作用域，两个模块之间的变量、方法，默认是互不冲突，互不影响，这样就导致一个问题：模块 A 要怎样使用模块B中的变量\u0026方法呢？这就需要通过 exports 关键字来实现。\nNode.js中，每个模块都有一个 exports 接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他的模块才可以使用。\n接下来详细讲一讲模块的暴露、模块的引入。\n暴露模块的方式一： exports exports对象用来导出当前模块的公共方法或属性。别的模块通过 require 函数调用当前模块时，得到的就是当前模块的 exports 对象。\n语法格式：\n// 相当于是：给 exports 对象添加属性 exports.xxx = value 这个 value 可以是任意的数据类型。\n注意：暴露的关键词是exports，不是export。其实，这里的 exports 类似于 ES6 中的 export 的用法，都是用来导出一个指定名字的对象。\n代码举例：\nconst name = 'qianguyihao'; const foo = function (value) { return value * 2; }; exports.name = name; exports.foo = foo; 暴露模块的方式二： module.exports module.exports用来导出一个默认对象，没有指定对象名。\n语法格式：\n// 方式一：导出整个 exports 对象 module.exports = value; // 方式二：给 exports 对象添加属性 module.exports.xxx = value; 这个 value 可以是任意的数据类型。\n代码举例：\n// 方式1 module.exports = { name: '我是 module1', foo(){ console.log(this.name); } } // 我们不能再继续写 module.exports = value2。因为重新赋值，会把 exports 对象 之前的赋值覆盖掉。 // 方式2 const age = 28; module.exports.age = age; module.exports 还可以修改模块的原始导出对象。比如当前模块原本导出的是一个对象，我们可以通过 module.exports 修改为导出一个函数。如下：\nmodule.exports = function () { console.log('hello world') } exports 和 module.exports 的区别 最重要的区别：\n使用exports时，只能单个设置属性 exports.a = a;\n使用module.exports时，既单个设置属性 module.exports.a，也可以整个赋值 module.exports = obj。\n其他要点：\nNode中每个模块的最后，都会执行 return: module.exports。\nNode中每个模块都会把 module.exports指向的对象赋值给一个变量 exports，也就是说 exports = module.exports。\nmodule.exports = XXX，表示当前模块导出一个单一成员，结果就是XXX。\n如果需要导出多个成员，则必须使用 exports.add = XXX; exports.foo = XXX。或者使用 module.exports.add = XXX; module.export.foo = XXX。\n问题: 暴露的模块到底是谁？ 答案：暴露的本质是exports对象。【重要】\n比如，方式一的 exports.a = a 可以理解成是，给 exports 对象添加属性。方式二的 module.exports = a可以理解成是给整个 exports 对象赋值。方式二的 module.exports.c = c可以理解成是给 exports 对象添加属性。\nNode.js 中每个模块都有一个 module 对象，module 对象中的有一个 exports 属性称之为接口对象。我们需要把模块之间公共的方法或属性挂载在这个接口对象中，方便其他的模块使用。\n引入模块的方式：require require函数用来在一个模块中引入另外一个模块。传入模块名，返回模块导出对象。\n语法格式：\nconst module1 = require('模块名'); 解释：\n内置模块：require的是包名。\n下载的第三方模块：require的是包名。\n自定义模块：require的是文件路径。文件路径既可以用绝对路径，也可以用相对路径。后缀名.js可以省略。\n代码举例：\nconst module1 = require('./main.js'); const module2 = require('./main'); const module3 = require('Demo/src/main.js'); require()函数的两个作用：\n执行导入的模块中的代码。\n返回导入模块中的接口对象。\n主模块 主模块是整个程序执行的入口，可以调度其他模块。\n# 运行main.js启动程序。此时，main.js就是主模块 $ node main.js 模块的初始化 一个模块中的 JS 代码仅在模块第一次被使用时执行一次，并且在使用的过程中进行初始化，然后会被缓存起来，便于后续继续使用。\n代码举例：\n（1）calModule.js:\nvar a = 1; ​ function add () { return ++a; } ​ exports.add = add; （2）main.js：（在 main.js 中引入 hello.js 模块）\nvar addModule1 = require('./calModule') var addModule2 = require('./calModule') ​ console.log(addModule1.add()); console.log(addModule2.add()); 在命令行执行 node main.js 运行程序，打印结果：\n2 3 从打印结果中可以看出，calModule.js这个模块虽然被引用了两次，但只初始化了一次。\nCommonJS 在服务器端的实现举例 1、初始化项目 在工程文件中新建如下目录和文件：\nmodules | module1.js | module2.js | module3.js app.js 然后在根目录下新建如下命令：\nnpm init 然后根据提示，依次输入如下内容：\n包名：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。\n版本：可以用默认的版本 1.0.0，也可以自己修改包名。\n其他的参数，一路回车即可。效果如下：\n于是，根目录下会自动生成package.json这个文件。点进去看一下：\n{ \"name\": \"commonjs_node\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"app.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"smyhvae\", \"license\": \"ISC\" } 2、导入第三方包 uniq这个第三方包的作用是保证唯一性（我们拿它来举例）。我们在当前工程目录下，输入如下命令进行安装：\nnpm install uniq 安装成功后，根目录下会自动生成相应的文件：\n需要说明的是，我的node版本是 v8.10.0（v8以上），对应的 npm 版本是 v5.6.0，版本比较高，因此，当我输入完npm install uniq之后，package.json中就会自动添加uniq包的依赖：\n如果有些童鞋的npm版本较低，就需要手动去添加依赖；另一种方式是，可以使用npm install uniq --save命令，这个多出来的--save就可以自动添加依赖。\n我们去官网看一下uniq的用法：\nlet uniq = require('uniq'); let arr = [1, 1, 2, 2, 3, 5]; uniq(arr); console.log(arr); //输出结果：[ 1, 2, 3, 5 ] 可以看出，这个包可以起到数组去重的作用。\n3、自定义模块 （1）module1.js：\n//暴露方式一：module.exports = value //暴露一个对象出去 module.exports = { name: '我是 module1', foo(){ console.log(this.name); } } //我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。 （2）module2.js：\n//暴露方式一：module.exports = value //暴露一个函数出去 module.exports = function(){ console.log('我是 module2'); } 注意，此时暴露出去的 exports 对象 等价于整个函数。\n（3）module3.js：\n//暴露方式二：exports.xxx = value //可以往 export 对象中不断地添加属性，进行暴露 exports.foo1 = function(){ console.log('module3 中的 foo1 方法'); } exports.foo2 = function(){ console.log('module3 中的 foo2 方法'); } exports.arr = [1,1,2,2,3,5,11]; （4）app.js：（将其他模块汇集到主模块）\n//将其他模块汇集到主模块 let uniq = require('uniq'); //引入时，第三方模块要放在自定义模块的上面 let module1 = require('./modules/module1'); let module2 = require('./modules/module2'); let module3 = require('./modules/module3'); //调用module1对象的方法 module1.foo(); //调用module2的函数 module2(); //注意，在定义时，module2对象等价于整个函数function。所以，module2()的意思是，直接调用了函数。 //调用module3中的属性 module3.foo1(); module3.foo2(); uniq(module3.arr); //将module3中的数组进行去重操作 console.log(module3.arr); //打印数组去重后的结果 这样的话，我们的代码就写完了。\n我们在命令行中输入node app.js，就可以把代码跑起来了。打印结果如下：\n我是 module1 我是 module2 module3 中的 foo1 方法 module3 中的 foo2 方法 [ 1, 11, 2, 3, 5 ] CommonJS 基于浏览器端的实现举例 1、初始化项目 在工程文件中新建如下目录和文件：\njs dist //打包生成文件的目录 src //源码所在的目录 | module1.js | module2.js | module3.js | app.js //应用主源文件 index.html //因为CommonJS是基于浏览器端，js文件要跑在浏览器的页面上，所以要有这个html页面 然后在根目录下新建如下命令：\nnpm init 然后根据提示，依次输入如下内容：\n包名：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。\n版本：可以用默认的版本 1.0.0，也可以自己修改包名。\n其他的参数，一路回车即可。\n于是，根目录下会自动生成package.json这个文件。点进去看一下：\n{ \"name\": \"commonjs_browser\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\" }, \"author\": \"\", \"license\": \"ISC\" } 2、下载第三方包：Browserify 这里需要用到Browserify这个工具进行编译打包。Browserify 称为 CommonJS 的浏览器端的打包工具。\n输入如下命令进行安装：（两个命令都要输入）\nnpm install browserify -g //全局 npm install browserify --save-dev //局部。 上面的代码中，-dev表示开发依赖。这里解释一下相关概念：\n开发依赖：当前这个包，只在开发环境下使用。\n运行依赖：当前这个包，是在生产环境下使用。\n3、自定义模块 \u0026 代码运行 （1）module1.js：\n//暴露方式一：module.exports = value //暴露一个对象出去 module.exports = { name: '我是 module1', foo(){ console.log(this.name); } } //我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。 （2）module2.js：\n//暴露方式一：module.exports = value //暴露一个函数出去 module.exports = function(){ console.log('我是 module2'); } 注意，此时暴露出去的 exports 对象 等价于整个函数。\n（3）module3.js：\n//暴露方式二：exports.xxx = value //可以往export对象中不断地添加属性，进行暴露 exports.foo1 = function(){ console.log('module3 中的 foo1 方法'); } exports.foo2 = function(){ console.log('module3 中的 foo2 方法'); } （4）app.js：（将其他模块汇集到主模块）\nlet module1 = require('./module1'); // ./ 指的是当前路径 let module2 = require('./module2'); let module3 = require('./module3'); module1.foo(); module2(); module3.foo1(); module3.foo2(); 引入的路径解释：\n./是相对路径，指的是当前路径（app.js的当前路径是src） 到此，我们的主要代码就写完了。\n但是，如果我们直接在index.html中，像下面这样写，是不行的：（因为浏览器不认识 require 关键字）\n\u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"\u003e \u003ctitle\u003eDocument\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript src=\"./js/src/app.js\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 为了能够让index.html引入app.js，我们需要输入如下命令：\n打包处理js:\nbrowserify js/src/app.js -o js/dist/bundle.js 然后在index.html中引入打包后的文件：\n\u003cscript type=\"text/javascript\" src=\"js/dist/bundle.js\"\u003e\u003c/script\u003e ","wordCount":"5124","inLanguage":"en","datePublished":"2020-01-01T17:11:35+08:00","dateModified":"2020-01-01T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/04-node.js%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83commonjs/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>04-Node.js模块化规范：CommonJS</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/node/>Node</a></div>11 min&nbsp;·&nbsp;<span title='2020-01-01 17:11:35 +0800 +0800'>2020/01/01</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a></li><li><a href=#%e6%a8%a1%e5%9d%97%e5%8c%96%e7%9a%84%e7%90%86%e8%a7%a3 aria-label=模块化的理解>模块化的理解</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e6%a8%a1%e5%9d%97%e5%8c%96 aria-label=什么是模块化>什么是模块化</a></li><li><a href=#%e6%a8%a1%e5%9d%97%e5%8c%96%e7%9a%84%e5%a5%bd%e5%a4%84 aria-label=模块化的好处>模块化的好处</a></li></ul></li><li><a href=#%e6%a8%a1%e5%9d%97%e5%8c%96%e8%a7%84%e8%8c%83 aria-label=模块化规范>模块化规范</a><ul><li><a href=#%e6%a8%a1%e5%9d%97%e5%8c%96%e8%a7%84%e8%8c%83%e7%9a%84%e5%bc%95%e5%85%a5 aria-label=模块化规范的引入>模块化规范的引入</a></li><li><a href=#%e6%a8%a1%e5%9d%97%e5%8c%96%e7%9a%84%e6%a6%82%e5%bf%b5%e8%a7%a3%e8%af%bb aria-label=模块化的概念解读>模块化的概念解读</a></li><li><a href=#%e6%a8%a1%e5%9d%97%e5%8c%96%e8%a7%84%e8%8c%83-1 aria-label=模块化规范>模块化规范</a></li></ul></li><li><a href=#commonjs-%e7%9a%84%e5%9f%ba%e6%9c%ac%e8%af%ad%e6%b3%95 aria-label="CommonJS 的基本语法">CommonJS 的基本语法</a><ul><li><a href=#commonjs-%e7%9a%84%e4%bb%8b%e7%bb%8d aria-label="CommonJS 的介绍">CommonJS 的介绍</a></li><li><a href=#%e6%a8%a1%e5%9d%97%e7%9a%84%e6%9a%b4%e9%9c%b2%e5%92%8c%e5%bc%95%e5%85%a5 aria-label=模块的暴露和引入>模块的暴露和引入</a></li><li><a href=#%e6%9a%b4%e9%9c%b2%e6%a8%a1%e5%9d%97%e7%9a%84%e6%96%b9%e5%bc%8f%e4%b8%80-exports aria-label="暴露模块的方式一： exports">暴露模块的方式一： exports</a></li><li><a href=#%e6%9a%b4%e9%9c%b2%e6%a8%a1%e5%9d%97%e7%9a%84%e6%96%b9%e5%bc%8f%e4%ba%8c-moduleexports aria-label="暴露模块的方式二： module.exports">暴露模块的方式二： module.exports</a></li><li><a href=#exports-%e5%92%8c-moduleexports-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="exports 和 module.exports 的区别">exports 和 module.exports 的区别</a></li><li><a href=#%e9%97%ae%e9%a2%98-%e6%9a%b4%e9%9c%b2%e7%9a%84%e6%a8%a1%e5%9d%97%e5%88%b0%e5%ba%95%e6%98%af%e8%b0%81 aria-label="问题: 暴露的模块到底是谁？">问题: 暴露的模块到底是谁？</a></li><li><a href=#%e5%bc%95%e5%85%a5%e6%a8%a1%e5%9d%97%e7%9a%84%e6%96%b9%e5%bc%8frequire aria-label=引入模块的方式：require>引入模块的方式：require</a></li><li><a href=#%e4%b8%bb%e6%a8%a1%e5%9d%97 aria-label=主模块>主模块</a></li><li><a href=#%e6%a8%a1%e5%9d%97%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96 aria-label=模块的初始化>模块的初始化</a></li></ul></li><li><a href=#commonjs-%e5%9c%a8%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%ab%af%e7%9a%84%e5%ae%9e%e7%8e%b0%e4%b8%be%e4%be%8b aria-label="CommonJS 在服务器端的实现举例">CommonJS 在服务器端的实现举例</a><ul><li><a href=#1%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%b9%e7%9b%ae aria-label=1、初始化项目>1、初始化项目</a></li><li><a href=#2%e5%af%bc%e5%85%a5%e7%ac%ac%e4%b8%89%e6%96%b9%e5%8c%85 aria-label=2、导入第三方包>2、导入第三方包</a></li><li><a href=#3%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a8%a1%e5%9d%97 aria-label=3、自定义模块>3、自定义模块</a></li></ul></li><li><a href=#commonjs-%e5%9f%ba%e4%ba%8e%e6%b5%8f%e8%a7%88%e5%99%a8%e7%ab%af%e7%9a%84%e5%ae%9e%e7%8e%b0%e4%b8%be%e4%be%8b aria-label="CommonJS 基于浏览器端的实现举例">CommonJS 基于浏览器端的实现举例</a><ul><li><a href=#1%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%b9%e7%9b%ae-1 aria-label=1、初始化项目>1、初始化项目</a></li><li><a href=#2%e4%b8%8b%e8%bd%bd%e7%ac%ac%e4%b8%89%e6%96%b9%e5%8c%85browserify aria-label=2、下载第三方包：Browserify>2、下载第三方包：Browserify</a></li><li><a href=#3%e8%87%aa%e5%ae%9a%e4%b9%89%e6%a8%a1%e5%9d%97--%e4%bb%a3%e7%a0%81%e8%bf%90%e8%a1%8c aria-label="3、自定义模块 &amp;amp; 代码运行">3、自定义模块 & 代码运行</a></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>网站越来越复杂，js代码、js文件也越来越多，会遇到<strong>一些问题</strong>：</p><ul><li><p>文件依赖</p></li><li><p>全局污染、命名冲突</p></li></ul><p>程序模块化包括：</p><ul><li><p>日期模块</p></li><li><p>数学计算模块</p></li><li><p>日志模块</p></li><li><p>登陆认证模块</p></li><li><p>报表展示模块等。</p></li></ul><p>所有这些模块共同组成了程序软件系统。</p><p>一次编写，多次使用，才是提高效率的核心。</p><h2 id=模块化的理解>模块化的理解<a hidden class=anchor aria-hidden=true href=#模块化的理解>#</a></h2><h3 id=什么是模块化>什么是模块化<a hidden class=anchor aria-hidden=true href=#什么是模块化>#</a></h3><p><strong>概念</strong>：将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并组合在一起。</p><p>模块的内部数据、实现是私有的, 只是向外部暴露一些接口(方法)与外部其它模块通信。</p><p>最早的时候，我们会把所有的代码都写在一个js文件里，那么，耦合性会很高（关联性强），不利于维护；而且会造成全局污染，很容易命名冲突。</p><h3 id=模块化的好处>模块化的好处<a hidden class=anchor aria-hidden=true href=#模块化的好处>#</a></h3><ul><li><p>避免命名冲突，减少命名空间污染</p></li><li><p>降低耦合性；更好地分离、按需加载</p></li><li><p><strong>高复用性</strong>：代码方便重用，别人开发的模块直接拿过来就可以使用，不需要重复开发类似的功能。</p></li><li><p><strong>高可维护性</strong>：软件的声明周期中最长的阶段其实并不是开发阶段，而是维护阶段，需求变更比较频繁。使用模块化的开发，方式更容易维护。</p></li><li><p>部署方便</p></li></ul><h2 id=模块化规范>模块化规范<a hidden class=anchor aria-hidden=true href=#模块化规范>#</a></h2><h3 id=模块化规范的引入>模块化规范的引入<a hidden class=anchor aria-hidden=true href=#模块化规范的引入>#</a></h3><p>假设我们引入模块化，首先可能会想到的思路是：在一个文件中引入多个js文件。如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#9d0006>body</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>script</span> <span style=color:#79740e;font-weight:700>src</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;zepto.js&#34;</span>&gt;&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>script</span> <span style=color:#79740e;font-weight:700>src</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;fastClick.js&#34;</span>&gt;&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>script</span> <span style=color:#79740e;font-weight:700>src</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;util/login.js&#34;</span>&gt;&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>script</span> <span style=color:#79740e;font-weight:700>src</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;util/base.js&#34;</span>&gt;&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>script</span> <span style=color:#79740e;font-weight:700>src</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;util/city.js&#34;</span>&gt;&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#9d0006>body</span>&gt;
</span></span></code></pre></div><p>但是这样做会带来很多问题：</p><ul><li><p>请求过多：引入十个js文件，就有十次http请求。</p></li><li><p>依赖模糊：不同的js文件可能会相互依赖，如果改其中的一个文件，另外一个文件可能会报错。</p></li></ul><p>以上两点，最终导致：<strong>难以维护</strong>。</p><p>于是，这就引入了模块化规范。</p><h3 id=模块化的概念解读>模块化的概念解读<a hidden class=anchor aria-hidden=true href=#模块化的概念解读>#</a></h3><p>模块化起源于 Node.js。Node.js 中把很多 js 打包成 package，需要的时候直接通过 require 的方式进行调用（CommonJS），这就是模块化的方式。</p><p>那如何把这种模块化思维应用到前端来呢？这就产生了两种伟大的 js：RequireJS 和 SeaJS。</p><h3 id=模块化规范-1>模块化规范<a hidden class=anchor aria-hidden=true href=#模块化规范-1>#</a></h3><p>服务器端规范：</p><ul><li><a href=http://www.commonjs.org/><strong>CommonJS规范</strong></a>：是 Node.js 使用的模块化规范。</li></ul><p>CommonJS 就是一套约定标准，不是技术。用于约定我们的代码应该是怎样的一种结构。</p><p>浏览器端规范：</p><ul><li><a href=https://github.com/amdjs/amdjs-api><strong>AMD规范</strong></a>：是 <strong><a href=http://requirejs.org/>RequireJS</a></strong> 在推广过程中对模块化定义的规范化产出。</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>-</span> 异步加载模块；
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>-</span> 依赖前置、提前执行：<span style=color:#af3a03>require</span>([<span style=color:#af3a03>`</span>foo<span style=color:#af3a03>`</span>,<span style=color:#af3a03>`</span>bar<span style=color:#af3a03>`</span>],<span style=color:#b57614>function</span>(foo,bar){});   <span style=color:#af3a03>//</span>也就是说把所有的包都 <span style=color:#af3a03>require</span> 成功，再继续执行代码。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>-</span> define 定义模块：<span style=color:#b57614>define</span>([<span style=color:#af3a03>`</span><span style=color:#af3a03>require</span><span style=color:#af3a03>`</span>,<span style=color:#af3a03>`</span>foo<span style=color:#af3a03>`</span>],<span style=color:#b57614>function</span>(){<span style=color:#af3a03>return</span>});
</span></span></code></pre></div><ul><li><strong><a href>CMD规范</a></strong>：是 <strong><a href=http://seajs.org/>SeaJS</a></strong> 在推广过程中对模块化定义的规范化产出。淘宝团队开发。</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>
</span></span><span style=display:flex><span>  同步加载模块；
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  依赖就近，延迟执行：require(./a) 直接引入。或者Require.async 异步引入。   //依赖就近：执行到这一部分的时候，再去加载对应的文件。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  define 定义模块， export 导出：define(function(require, export, module){});
</span></span></code></pre></div><p>PS：面试时，经常会问AMD 和 CMD 的区别。</p><p>另外，还有ES6规范：import & export。</p><p>这篇文章，我们来讲一下<code>CommonJS</code>，它是 Node.js 使用的模块化规范。</p><h2 id=commonjs-的基本语法>CommonJS 的基本语法<a hidden class=anchor aria-hidden=true href=#commonjs-的基本语法>#</a></h2><h3 id=commonjs-的介绍>CommonJS 的介绍<a hidden class=anchor aria-hidden=true href=#commonjs-的介绍>#</a></h3><p><a href=http://www.commonjs.org/>CommonJS</a>：是 Node.js 使用的模块化规范。也就是说，Node.js 就是基于 CommonJS 这种模块化规范来编写的。</p><p>CommonJS 规范规定：每个模块内部，module 变量代表当前模块。这个变量是一个对象，它的 exports 属性（即 module.exports）是对外的接口对象。加载某个模块，其实是加载该模块的 module.exports 对象。</p><p>在 CommonJS 中，每个文件都可以当作一个模块：</p><ul><li><p>在服务器端：模块的加载是运行时同步加载的。</p></li><li><p>在浏览器端: 模块需要提前编译打包处理。首先，既然同步的，很容易引起阻塞；其次，浏览器不认识<code>require</code>语法，因此，需要提前编译打包。</p></li></ul><h3 id=模块的暴露和引入>模块的暴露和引入<a hidden class=anchor aria-hidden=true href=#模块的暴露和引入>#</a></h3><p>Node.js 中只有模块级作用域，两个模块之间的变量、方法，默认是互不冲突，互不影响，这样就导致一个问题：模块 A 要怎样使用模块B中的变量&方法呢？这就需要通过 <code>exports</code> 关键字来实现。</p><p>Node.js中，每个模块都有一个 exports 接口对象，我们可以把公共的变量、方法挂载到这个接口对象中，其他的模块才可以使用。</p><p>接下来详细讲一讲模块的暴露、模块的引入。</p><h3 id=暴露模块的方式一-exports>暴露模块的方式一： exports<a hidden class=anchor aria-hidden=true href=#暴露模块的方式一-exports>#</a></h3><p><code>exports</code>对象用来导出当前模块的公共方法或属性。别的模块通过 require 函数调用当前模块时，得到的就是当前模块的 exports 对象。</p><p><strong>语法格式</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#928374;font-style:italic>// 相当于是：给 exports 对象添加属性
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>exports.xxx <span style=color:#af3a03>=</span> value
</span></span></code></pre></div><p>这个 value 可以是任意的数据类型。</p><p><strong>注意</strong>：暴露的关键词是<code>exports</code>，不是<code>export</code>。其实，这里的 exports 类似于 ES6 中的 export 的用法，都是用来导出一个指定名字的对象。</p><p><strong>代码举例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>const</span> name <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;qianguyihao&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> foo <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span> (value) {
</span></span><span style=display:flex><span>	<span style=color:#af3a03>return</span> value <span style=color:#af3a03>*</span> <span style=color:#8f3f71>2</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exports.name <span style=color:#af3a03>=</span> name;
</span></span><span style=display:flex><span>exports.foo <span style=color:#af3a03>=</span> foo;
</span></span></code></pre></div><h3 id=暴露模块的方式二-moduleexports>暴露模块的方式二： module.exports<a hidden class=anchor aria-hidden=true href=#暴露模块的方式二-moduleexports>#</a></h3><p><code>module.exports</code>用来导出一个默认对象，没有指定对象名。</p><p>语法格式：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>// 方式一：导出整个 exports 对象
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module.exports <span style=color:#af3a03>=</span> value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 方式二：给 exports 对象添加属性
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module.exports.xxx <span style=color:#af3a03>=</span> value;
</span></span></code></pre></div><p>这个 value 可以是任意的数据类型。</p><p>代码举例：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#928374;font-style:italic>// 方式1
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module.exports <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;我是 module1&#39;</span>,
</span></span><span style=display:flex><span>    foo(){
</span></span><span style=display:flex><span>        console.log(<span style=color:#af3a03>this</span>.name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 我们不能再继续写 module.exports = value2。因为重新赋值，会把 exports 对象 之前的赋值覆盖掉。
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 方式2
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>const</span> age <span style=color:#af3a03>=</span> <span style=color:#8f3f71>28</span>;
</span></span><span style=display:flex><span>module.exports.age <span style=color:#af3a03>=</span> age;
</span></span></code></pre></div><p><code>module.exports</code> 还可以修改模块的原始导出对象。比如当前模块原本导出的是一个对象，我们可以通过 module.exports 修改为导出一个函数。如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>module.exports <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span> () {
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;hello world&#39;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=exports-和-moduleexports-的区别>exports 和 module.exports 的区别<a hidden class=anchor aria-hidden=true href=#exports-和-moduleexports-的区别>#</a></h3><p>最重要的区别：</p><ul><li><p>使用exports时，只能单个设置属性 <code>exports.a = a;</code></p></li><li><p>使用module.exports时，既单个设置属性 <code>module.exports.a</code>，也可以整个赋值 <code>module.exports = obj</code>。</p></li></ul><p>其他要点：</p><ul><li><p>Node中每个模块的最后，都会执行 <code>return: module.exports</code>。</p></li><li><p>Node中每个模块都会把 <code>module.exports</code>指向的对象赋值给一个变量 <code>exports</code>，也就是说 <code>exports = module.exports</code>。</p></li><li><p><code>module.exports = XXX</code>，表示当前模块导出一个单一成员，结果就是XXX。</p></li><li><p>如果需要导出多个成员，则必须使用 <code>exports.add = XXX; exports.foo = XXX</code>。或者使用 <code>module.exports.add = XXX; module.export.foo = XXX</code>。</p></li></ul><h3 id=问题-暴露的模块到底是谁>问题: 暴露的模块到底是谁？<a hidden class=anchor aria-hidden=true href=#问题-暴露的模块到底是谁>#</a></h3><p><strong>答案</strong>：暴露的本质是<code>exports</code>对象。【重要】</p><p>比如，方式一的 <code>exports.a = a</code> 可以理解成是，<strong>给 exports 对象添加属性</strong>。方式二的 <code>module.exports = a</code>可以理解成是给整个 exports 对象赋值。方式二的 <code>module.exports.c = c</code>可以理解成是给 exports 对象添加属性。</p><p>Node.js 中每个模块都有一个 module 对象，module 对象中的有一个 exports 属性称之为<strong>接口对象</strong>。我们需要把模块之间公共的方法或属性挂载在这个接口对象中，方便其他的模块使用。</p><h3 id=引入模块的方式require>引入模块的方式：require<a hidden class=anchor aria-hidden=true href=#引入模块的方式require>#</a></h3><p>require函数用来在一个模块中引入另外一个模块。传入模块名，返回模块导出对象。</p><p><strong>语法格式</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>const</span> module1 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;模块名&#39;</span>);
</span></span></code></pre></div><p>解释：</p><ul><li><p>内置模块：require的是<strong>包名</strong>。</p></li><li><p>下载的第三方模块：require的是<strong>包名</strong>。</p></li><li><p>自定义模块：require的是<strong>文件路径</strong>。文件路径既可以用绝对路径，也可以用相对路径。后缀名<code>.js</code>可以省略。</p></li></ul><p><strong>代码举例</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>const</span> module1 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./main.js&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> module2 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./main&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> module3 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;Demo/src/main.js&#39;</span>);
</span></span></code></pre></div><p><strong>require()函数的两个作用</strong>：</p><ul><li><p>执行导入的模块中的代码。</p></li><li><p>返回导入模块中的接口对象。</p></li></ul><h3 id=主模块>主模块<a hidden class=anchor aria-hidden=true href=#主模块>#</a></h3><p>主模块是整个程序执行的入口，可以调度其他模块。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#928374;font-style:italic># 运行main.js启动程序。此时，main.js就是主模块</span>
</span></span><span style=display:flex><span>$ node main.js
</span></span></code></pre></div><h3 id=模块的初始化>模块的初始化<a hidden class=anchor aria-hidden=true href=#模块的初始化>#</a></h3><p>一个模块中的 JS 代码仅在模块<strong>第一次被使用时</strong>执行一次，并且在使用的过程中进行初始化，然后会被缓存起来，便于后续继续使用。</p><p>代码举例：</p><p>（1）calModule.js:</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>var</span> a <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>;
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> add () {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> <span style=color:#af3a03>++</span>a;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>exports.add <span style=color:#af3a03>=</span> add;
</span></span></code></pre></div><p>（2）main.js：（在 main.js 中引入 hello.js 模块）</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>var</span> addModule1 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./calModule&#39;</span>)
</span></span><span style=display:flex><span><span style=color:#af3a03>var</span> addModule2 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./calModule&#39;</span>)
</span></span><span style=display:flex><span>​
</span></span><span style=display:flex><span>console.log(addModule1.add());
</span></span><span style=display:flex><span>console.log(addModule2.add());
</span></span></code></pre></div><p>在命令行执行 <code>node main.js</code> 运行程序，打印结果：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#8f3f71>2</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>3</span>
</span></span></code></pre></div><p>从打印结果中可以看出，<code>calModule.js</code>这个模块虽然被引用了两次，但只初始化了一次。</p><h2 id=commonjs-在服务器端的实现举例>CommonJS 在服务器端的实现举例<a hidden class=anchor aria-hidden=true href=#commonjs-在服务器端的实现举例>#</a></h2><h3 id=1初始化项目>1、初始化项目<a hidden class=anchor aria-hidden=true href=#1初始化项目>#</a></h3><p>在工程文件中新建如下目录和文件：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>modules
</span></span><span style=display:flex><span>    | module1.js
</span></span><span style=display:flex><span>    | module2.js
</span></span><span style=display:flex><span>    | module3.js
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>app.js
</span></span></code></pre></div><p>然后在根目录下新建如下命令：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  npm init
</span></span></code></pre></div><p>然后根据提示，依次输入如下内容：</p><ul><li><p><strong>包名</strong>：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。</p></li><li><p><strong>版本</strong>：可以用默认的版本 1.0.0，也可以自己修改包名。</p></li></ul><p>其他的参数，一路回车即可。效果如下：</p><p><img loading=lazy src=http://img.smyhvae.com/20180410_1425.png alt></p><p>于是，根目录下会自动生成<code>package.json</code>这个文件。点进去看一下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;name&#34;</span>: <span style=color:#79740e>&#34;commonjs_node&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;version&#34;</span>: <span style=color:#79740e>&#34;1.0.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;description&#34;</span>: <span style=color:#79740e>&#34;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;main&#34;</span>: <span style=color:#79740e>&#34;app.js&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;scripts&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#9d0006>&#34;test&#34;</span>: <span style=color:#79740e>&#34;echo \&#34;Error: no test specified\&#34; &amp;&amp; exit 1&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;author&#34;</span>: <span style=color:#79740e>&#34;smyhvae&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;license&#34;</span>: <span style=color:#79740e>&#34;ISC&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2导入第三方包>2、导入第三方包<a hidden class=anchor aria-hidden=true href=#2导入第三方包>#</a></h3><p><code>uniq</code>这个第三方包的作用是保证唯一性（我们拿它来举例）。我们在当前工程目录下，输入如下命令进行安装：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  npm install uniq
</span></span></code></pre></div><p>安装成功后，根目录下会自动生成相应的文件：</p><p><img loading=lazy src=http://img.smyhvae.com/20180410_1450.png alt></p><p>需要说明的是，我的node版本是 v8.10.0（v8以上），对应的 npm 版本是 v5.6.0，版本比较高，因此，当我输入完<code>npm install uniq</code>之后，<code>package.json</code>中就会自动添加<code>uniq</code>包的依赖：</p><p><img loading=lazy src=http://img.smyhvae.com/20180410_1855.png alt></p><p>如果有些童鞋的npm版本较低，就需要手动去添加依赖；另一种方式是，可以使用<code>npm install uniq --save</code>命令，这个多出来的<code>--save</code>就可以自动添加依赖。</p><p>我们去<a href=https://www.npmjs.com/package/uniq>官网</a>看一下<code>uniq</code>的用法：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>  <span style=color:#af3a03>let</span> uniq <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;uniq&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>let</span> arr <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>, <span style=color:#8f3f71>5</span>];
</span></span><span style=display:flex><span>  uniq(arr);
</span></span><span style=display:flex><span>  console.log(arr);  <span style=color:#928374;font-style:italic>//输出结果：[ 1, 2, 3, 5 ]
</span></span></span></code></pre></div><p>可以看出，这个包可以起到数组去重的作用。</p><h3 id=3自定义模块>3、自定义模块<a hidden class=anchor aria-hidden=true href=#3自定义模块>#</a></h3><p>（1）module1.js：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露方式一：module.exports = value
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露一个对象出去
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module.exports <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;我是 module1&#39;</span>,
</span></span><span style=display:flex><span>    foo(){
</span></span><span style=display:flex><span>        console.log(<span style=color:#af3a03>this</span>.name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。
</span></span></span></code></pre></div><p>（2）module2.js：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露方式一：module.exports = value
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露一个函数出去
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module.exports <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;我是 module2&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意，此时暴露出去的 exports 对象 等价于整个函数。</p><p>（3）module3.js：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露方式二：exports.xxx = value
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//可以往 export 对象中不断地添加属性，进行暴露
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>exports.foo1 <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;module3 中的 foo1 方法&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exports.foo2 <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;module3 中的 foo2 方法&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exports.arr <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>,<span style=color:#8f3f71>1</span>,<span style=color:#8f3f71>2</span>,<span style=color:#8f3f71>2</span>,<span style=color:#8f3f71>3</span>,<span style=color:#8f3f71>5</span>,<span style=color:#8f3f71>11</span>];
</span></span></code></pre></div><p>（4）app.js：（将其他模块汇集到主模块）</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>//将其他模块汇集到主模块
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> uniq <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;uniq&#39;</span>); <span style=color:#928374;font-style:italic>//引入时，第三方模块要放在自定义模块的上面
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> module1 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./modules/module1&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> module2 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./modules/module2&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> module3 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./modules/module3&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//调用module1对象的方法
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module1.foo();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//调用module2的函数
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module2();  <span style=color:#928374;font-style:italic>//注意，在定义时，module2对象等价于整个函数function。所以，module2()的意思是，直接调用了函数。
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//调用module3中的属性
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module3.foo1();
</span></span><span style=display:flex><span>module3.foo2();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>uniq(module3.arr); <span style=color:#928374;font-style:italic>//将module3中的数组进行去重操作
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(module3.arr); <span style=color:#928374;font-style:italic>//打印数组去重后的结果
</span></span></span></code></pre></div><p>这样的话，我们的代码就写完了。</p><p>我们在命令行中输入<code>node app.js</code>，就可以把代码跑起来了。打印结果如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>我是 module1
</span></span><span style=display:flex><span>我是 module2
</span></span><span style=display:flex><span>module3 中的 foo1 方法
</span></span><span style=display:flex><span>module3 中的 foo2 方法
</span></span><span style=display:flex><span><span style=color:#af3a03>[</span> 1, 11, 2, 3, <span style=color:#8f3f71>5</span> <span style=color:#af3a03>]</span>
</span></span></code></pre></div><h2 id=commonjs-基于浏览器端的实现举例>CommonJS 基于浏览器端的实现举例<a hidden class=anchor aria-hidden=true href=#commonjs-基于浏览器端的实现举例>#</a></h2><h3 id=1初始化项目-1>1、初始化项目<a hidden class=anchor aria-hidden=true href=#1初始化项目-1>#</a></h3><p>在工程文件中新建如下目录和文件：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>js
</span></span><span style=display:flex><span>    dist //打包生成文件的目录
</span></span><span style=display:flex><span>    src //源码所在的目录
</span></span><span style=display:flex><span>      | module1.js
</span></span><span style=display:flex><span>      | module2.js
</span></span><span style=display:flex><span>      | module3.js
</span></span><span style=display:flex><span>      | app.js //应用主源文件
</span></span><span style=display:flex><span>index.html    //因为CommonJS是基于浏览器端，js文件要跑在浏览器的页面上，所以要有这个html页面
</span></span></code></pre></div><p>然后在根目录下新建如下命令：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>  npm init
</span></span></code></pre></div><p>然后根据提示，依次输入如下内容：</p><ul><li><p><strong>包名</strong>：可以自己起包名，也可以用默认的包名。注意，包名里不能有中文，不能有大写。</p></li><li><p><strong>版本</strong>：可以用默认的版本 1.0.0，也可以自己修改包名。</p></li></ul><p>其他的参数，一路回车即可。</p><p>于是，根目录下会自动生成<code>package.json</code>这个文件。点进去看一下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;name&#34;</span>: <span style=color:#79740e>&#34;commonjs_browser&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;version&#34;</span>: <span style=color:#79740e>&#34;1.0.0&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;description&#34;</span>: <span style=color:#79740e>&#34;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;main&#34;</span>: <span style=color:#79740e>&#34;index.js&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;scripts&#34;</span>: {
</span></span><span style=display:flex><span>    <span style=color:#9d0006>&#34;test&#34;</span>: <span style=color:#79740e>&#34;echo \&#34;Error: no test specified\&#34; &amp;&amp; exit 1&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;author&#34;</span>: <span style=color:#79740e>&#34;&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#9d0006>&#34;license&#34;</span>: <span style=color:#79740e>&#34;ISC&#34;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2下载第三方包browserify>2、下载第三方包：Browserify<a hidden class=anchor aria-hidden=true href=#2下载第三方包browserify>#</a></h3><p>这里需要用到<a href=http://browserify.org/>Browserify</a>这个工具进行编译打包。Browserify 称为 CommonJS 的浏览器端的打包工具。</p><p>输入如下命令进行安装：（两个命令都要输入）</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>    npm install browserify <span style=color:#af3a03>-</span>g          <span style=color:#928374;font-style:italic>//全局
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    npm install browserify <span style=color:#af3a03>--</span>save<span style=color:#af3a03>-</span>dev  <span style=color:#928374;font-style:italic>//局部。
</span></span></span></code></pre></div><p>上面的代码中，<code>-dev</code>表示开发依赖。这里解释一下相关概念：</p><ul><li><p>开发依赖：当前这个包，只在开发环境下使用。</p></li><li><p>运行依赖：当前这个包，是在生产环境下使用。</p></li></ul><h3 id=3自定义模块--代码运行>3、自定义模块 & 代码运行<a hidden class=anchor aria-hidden=true href=#3自定义模块--代码运行>#</a></h3><p>（1）module1.js：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露方式一：module.exports = value
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露一个对象出去
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module.exports <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;我是 module1&#39;</span>,
</span></span><span style=display:flex><span>    foo(){
</span></span><span style=display:flex><span>        console.log(<span style=color:#af3a03>this</span>.name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//我们不能再继续写 module.exports = xxx。因为重新赋值，会把之前的赋值覆盖掉。
</span></span></span></code></pre></div><p>（2）module2.js：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露方式一：module.exports = value
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露一个函数出去
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>module.exports <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;我是 module2&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>注意，此时暴露出去的 exports 对象 等价于整个函数。</p><p>（3）module3.js：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#928374;font-style:italic>//暴露方式二：exports.xxx = value
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//可以往export对象中不断地添加属性，进行暴露
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>exports.foo1 <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;module3 中的 foo1 方法&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>exports.foo2 <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span>(){
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>&#39;module3 中的 foo2 方法&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>（4）app.js：（将其他模块汇集到主模块）</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#af3a03>let</span> module1 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./module1&#39;</span>);  <span style=color:#928374;font-style:italic>// ./ 指的是当前路径
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> module2 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./module2&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> module3 <span style=color:#af3a03>=</span> require(<span style=color:#79740e>&#39;./module3&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>module1.foo();
</span></span><span style=display:flex><span>module2();
</span></span><span style=display:flex><span>module3.foo1();
</span></span><span style=display:flex><span>module3.foo2();
</span></span></code></pre></div><p>引入的路径解释：</p><ul><li><code>./</code>是相对路径，指的是当前路径（app.js的当前路径是src）</li></ul><p>到此，我们的主要代码就写完了。</p><p>但是，如果我们直接在index.html中，像下面这样写，是不行的：（因为浏览器不认识 require 关键字）</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span><span style=color:#427b58>&lt;!DOCTYPE html&gt;</span>
</span></span><span style=display:flex><span>&lt;<span style=color:#9d0006>html</span> <span style=color:#79740e;font-weight:700>lang</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;en&#34;</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#9d0006>head</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>meta</span> <span style=color:#79740e;font-weight:700>charset</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;UTF-8&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>meta</span> <span style=color:#79740e;font-weight:700>name</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;viewport&#34;</span> <span style=color:#79740e;font-weight:700>content</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;width=device-width, initial-scale=1.0&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>meta</span> <span style=color:#79740e;font-weight:700>http-equiv</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;X-UA-Compatible&#34;</span> <span style=color:#79740e;font-weight:700>content</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;ie=edge&#34;</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>title</span>&gt;Document&lt;/<span style=color:#9d0006>title</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#9d0006>head</span>&gt;
</span></span><span style=display:flex><span>&lt;<span style=color:#9d0006>body</span>&gt;
</span></span><span style=display:flex><span>    &lt;<span style=color:#9d0006>script</span> <span style=color:#79740e;font-weight:700>src</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;./js/src/app.js&#34;</span>&gt;&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#9d0006>body</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#9d0006>html</span>&gt;
</span></span></code></pre></div><p>为了能够让index.html引入app.js，我们需要输入如下命令：</p><p>打包处理js:</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>    browserify js/src/app.js -o js/dist/bundle.js
</span></span></code></pre></div><p>然后在index.html中引入打包后的文件：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>    &lt;<span style=color:#9d0006>script</span> <span style=color:#79740e;font-weight:700>type</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;text/javascript&#34;</span> <span style=color:#79740e;font-weight:700>src</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;js/dist/bundle.js&#34;</span>&gt;&lt;/<span style=color:#9d0006>script</span>&gt;
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/node/>Node</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/tech/wait/mysql%E6%95%B0%E6%8D%AE%E5%BA%93/04-mysql%E5%AD%97%E6%AE%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/><span class=title>« Prev</span><br><span>04-MySQL字段的数据类型</span></a>
<a class=next href=https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/04-react%E7%BB%84%E4%BB%B6%E4%BA%8C%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%92%8C%E5%87%BD%E6%95%B0/><span class=title>Next »</span><br><span>04-React组件（二）：常见属性和函数</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>