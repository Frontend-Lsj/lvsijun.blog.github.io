<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>01-Node.js介绍 | Bablvsj's Blog</title><meta name=keywords content="Node"><meta name=description content="01-Node.js介绍 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/01-node.js%E4%BB%8B%E7%BB%8D/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="01-Node.js介绍"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/01-node.js%E4%BB%8B%E7%BB%8D/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-01-01T17:11:35+08:00"><meta property="article:modified_time" content="2020-01-01T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="01-Node.js介绍"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"01-Node.js介绍","item":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/01-node.js%E4%BB%8B%E7%BB%8D/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"01-Node.js介绍","name":"01-Node.js介绍","description":"","keywords":["Node"],"articleBody":"todo rpc 和 Node.js 的关系\n《吊打面试官》系列 Node.js 全栈秒杀系统\n前言 Node 的重要性已经不言而喻，很多互联网公司都已经有大量的高性能系统运行在 Node 之上。Node 凭借其单线程、异步等举措实现了极高的性能基准。此外，目前最为流行的 Web 开发模式是前后端分离的形式，即前端开发者与后端开发者在自己喜欢的 IDE 上独立进行开发，然后通过 HTTP 或是 RPC 等方式实现数据与流程的交互。这种开发模式在 Node 的强大功能的引领下变得越来越高效，也越来越受到各个互联网公司的青睐。\n前端同学为什么要学习后端/后端同学为什么要学习前端 了解前后端交互流程。\n前端同学能够和后台开发的程序员更佳紧密地结合、更顺畅地沟通。\n当网站的业务逻辑需要前置时，前端人员需要学习一些后台开发的技术，以完成相应的任务；；反过来也一样。\n拓宽知识视野和技术栈，能够站在全局的角度审视整个项目。\n前端同学为什么要学 Node.js 1、Node.js 使用 JavaScript 语言开发服务器端应用，便于前端同学上手（一些公司甚至要求前端工程师掌握 Node.js 开发）。\n2、实现了前后端的语法统一，有利于和前端代码整合，甚至共用部分代码。\n比如说，针对接口返回的各种字段，前后端都必须要做校验。此时，如果用 Node.js 来做后台开发的话，前后端可以共用校验的代码。\n3、Node.js 性能高、生态系统活跃，提供了大量的开源库。\n4、Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现。 Jeff Atwood 是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。\n后端同学为什么要学 Node.js 因为前端同学在学 Node.js。\n什么是 Node.js 官方定义 Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O的模型，使其轻量又高效。Node.js 的包管理工具 npm 是全球最大的开源库生态系统。\nNode.js 不是一门语言，也不是 JavaScript 的框架，也不是像Nginx一样的Web服务器 ，Node.js 是 JavaScript 在服务器端的运行环境（平台）。\nNode.js 的组成 在 Node.js 里运行 JavaScript，跟在 Chrome 里运行 JavaScript 有什么不同？\n二者采用的是同样的 JS 引擎。在 Node.js 里写 JS，和在前端写 JS，几乎没有不同。在写法上的区别在于：Node.js 没有浏览器、页面标签相关的 API，但是新增了一些 Node.js 相关的 API。通俗来说，对于开发者而言，在前端写 JS 是用于控制浏览器；而 Node.js 环境写 JS 可以控制整个计算机。\n我们知道，JavaScript 的组成分为三个部分：\nECMAScript\nDOM：标签元素相关的API\nBOM：浏览器相关的API\nECMAScript 是 JS 的语法；DOM 和 BOM 浏览器端为 JS 提供的 API。\n而 Node.js 的组成分为：\nECMAScript。ECMAScript 的所有语法在 Node 环境中都可以使用。\nNode 环境提供的一些附加 API(包括文件、网络等相关的 API)。\n如下图所示：\n补充 与 PHP、JSP、Python、Perl、Ruby 的“既是语言，也是平台”不同，Node.js 的使用 JavaScript 进行编程，运行在 Chrome 的 V8 引擎上。\n与 PHP、JSP 等相比（PHP、JSP、.net 都需要运行在服务器程序上，Apache、Nginx、Tomcat、IIS。 ），Node.js 跳过了 Apache、Naginx、IIS 等 HTTP 服务器，它自己不用建设在任何服务器软件之上。Node.js 的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js 没有 web 容器。\nJS 语言非常灵活，使得它在严谨性方面不如 Java 等传统的静态语言。JS 是一门动态语言，而且融合了面向对象和函数式编程这两种编程范式。\n随着 ES6、ES7 等 JS 语法规范的出现，以及浏览器对这些规范的支持，使得我们可以用更为现代化的 JS 语言特性，来编写现代化的应用。\nNode.js 的架构和依赖 Node.js 的架构如下：\nNode.js 内部采用 Google Chrome 的 V8 引擎，作为 JavaScript 语言解释器；同时结合自行开发的 libuv 库，扩展了 JS 在后端的能力（比如 I/O 操作、文件读写、数据库操作等）。使得 JS 既可以在前端进行 DOM 操作（浏览器前端），又可以在后端调用操作系统资源，是目前最简单的全栈式语言。\n其次，Node 生态系统活跃，提供了大量的开源库，使得 JavaScript 语言能与操作系统进行更多的交互。\nNode.js 运行环境的核心：V8 引擎 和 libuv 库 Node.js 是 JavaScript 在服务器端的运行环境，在这个意义上，Node.js 的地位其实就是 JavaScript 在服务器端的虚拟机，类似于 Java 语言中的 Java 虚拟机。\nV8 引擎 ：编译和执行 JS 代码、管理内存、垃圾回收。V8 给 JS 提供了运行环境，可以说是 JS 的虚拟机。V8 引擎本身是用 C++ 写的。\nlibuv： libuv 是一个专注于异步 I/O 的跨平台类库，目前主要在 Node.js 上使用。它是 Node.js 最初的作者 Ryan Dahl 为 Node.js 写的底层类库，也可以称之为虚拟机。libuv 本身是用 C 写的。\nJava 虚拟机和 V8 引擎，是由同一人开发 Chrome 浏览器成功的背后，离不开 JS 的 V8 引擎。作为虚拟机，V8 的性能表现优异，它的开发者是 Lars Bak。在 Lars 的工作履历里，绝大部分都是与虚拟机相关的工作。在开发 V8 之前，他曾经在 Sun 公司工作，担任 HotSpot 团队的技术领导，主要致力于开发高性能的 Java 虚拟机。在这之前，他也曾为 Self、Smalltalk 语言开发过高性能虚拟机。这些无与伦比的经历让 V8 一出世就超越了当时所有的 JS 虚拟机。\nV8 的性能优势使得用 JavaScript 写高性能后台服务程序成为可能。在这样的契机下，Ryan Dahl 选择了 JavaScript，选择了 V8，在事件驱动、非阻塞 I/O 模型的设计下实现了 Node。\nV8 的内存限制 在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4GB，32 位系统下约为 0.7GB）。在这样的限制下，将会导致 Node 无法直接操作大内存对象。\n造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。V8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在 Node 中，这却限制了开发者随心所欲使用大内存的想法。\nNode 的发展历史 2008 年左右，随着 Ajax 的逐渐普及，Web 开发逐渐走向复杂化，系统化；\nNode.js 诞生于 2009 年，由 Joyent 的员工 Ryan Dahl 开发而成。2009 年 5 月，Ryan Dahl 在 GitHub 中开源了 Node 的最初版本，同年 11 月，在 JSConf 大会上展示了 Node 项目；\n2010 年 1 月，NPM 包管理工具诞生，使得程序员能够更方便地发布和分享 Node.js 的第三方库。\nNode.js 最初只支持 Linux 和 Mac OS 操作系统。2011 年 7 月，微软参与合作，Node.js 终于支持了 Windows 平台。PS：不过，node 的生产环境基本是在 Linux 下。\n目前官网最新版本已经更新到 14.x.x 版本，最新稳定的是 12.18.0。\n据 Node.js 创始人 Ryan Dahl 回忆，他最初希望采用 Ruby，但是 Ruby 的虚拟机效率不行。\n注意：是 Node 选择了 JavaScript，不是 JavaScript 发展出来了一个 Node。\nNode.js 的应用 Node.js 拥有强大的开发者社区，现在已经发展出比较成熟的技术体系，以及庞大的生态。它被广泛地应用在 Web 服务、开发工作流、客户端应用等诸多领域。其中，在 Web 服务领域，业界对 Node.js 的接受程度最高。\n1、BFF 中间层 BFF，即 Backend For Frontend（服务于前端的后端）。玉伯在《从前端技术进化到体验科技》这篇文章中点出了 BFF 层的概念：\nBFF 模式下，整体分工很清晰，后端通过 Java/C++ 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。\n在 Web 服务里，搭建一个中间层，前端访问中间层的接口，中间层再访问后台的 Java/C++ 服务。这类服务的特点是不需要太强的服务器运算能力，但对程序的灵活性有较高的要求。这两个特点，正好和 Node.js 的优势相吻合。Node.js 非常适合用来做 BFF 层，优势如下：\n对于前端来说：让前端有能力自由组装后台数据，这样可以减少大量的业务沟通成本，加快业务的迭代速度；并且，前端同学能够自主决定与后台的通讯方式。\n对于后台和运维来说，好处是：安全性（不会把主服务器暴露在外面）、降低主服务器的复杂度等。\n2、服务端渲染 客户端渲染（CSR / Client side render）：前端通过一大堆接口请求数据，然后通过 JS 动态处理和生成页面结构和展示。优点是前后端分离、减小服务器压力、局部刷新。缺点是不利于 SEO（如果你的页面然后通过 Ajax 异步获取内容，抓取工具并不会等待异步完成后再行抓取页面内容）、首屏渲染慢。\n服务端渲染（SSR / Server Side Render）：服务器返回的不是接口数据，而是一整个页面（或整个楼层）的 HTML 字符串，浏览器直接显示即可。也就是说，在服务器端直接就渲染好了，然后一次性打包返回给前端。优点是有利于 SEO、首屏渲染很快。\n总结： 搜索引擎优化 + 首屏速度优化 = 服务端渲染。\n备注：这里的「服务端渲染」只是让 Node.js 做中间层，不会替代后端的，后台同学请放心。\n参考链接：\nVue 服务端渲染的概念\nhttps://blog.csdn.net/u012036171/article/details/88833200\nhttps://juejin.im/post/5c068fd8f265da61524d2abc\n方应杭\n历史回顾：\n（1）一开始，页面很简单，html 是后端渲染的（比如PHP、ASP、JSP等方式）。后端发现页面中的 js 好麻烦（虽然简单，但是坑多），于是让公司招聘专门写 js 的人，简称「前端切图仔」。\n（2）随着 Node.js 和前端 MVC 的兴起，以及前端越来越复杂，慢慢演变成了「前后端分离」。\n（3）前端的 SPA 应用流行之后，发现 SEO 问题很大，而且首屏渲染速度很慢，但是自己选的路再难走也要走下去，于是用 Node.js 在服务端渲染被看成是一条出路。\n（4）以前在一起的时候，是后端做部分前端的工作；现在在一起的时候，是前端做部分后端的工作。\n3、做小型服务、小型网站的后端（基于 Express、Koa 框架） 现在很多公司的后台管理系统，都是用 Node.js 来开发接口，毕竟，后台管理系统对性能和并发的要求不是太高。有了 Node.js 之后，通过 JS 直接操作 DB，做增删改查，生成接口，极大降低了前端同学的学习门槛。\n当然，有时候做 Node.js 开发，是因为：后台人力不够，所以把后台开发的一部分工作量，转移给前端同学。\n4、做项目构建工具 前端正在广泛使用的构建工具 gulp、Webpack，就是基于 Node.js 来实现的。\n5、 做 PC 端的软件（基于 Electron 框架） Electron 框架就是基于 Node.js 的。也可以说：Electron 是 Node.js 在PC客户端的技术。\n有一点你可能会感到惊讶：程序员们都在用的代码编辑器 VS Code 软件， 就是用 JS 语言实现的。\n还有一个例子是：电子游戏直播网站 Twitch，号称是国外游戏直播的鼻祖，它在 PC 端的客户端软件，就是用 Electron 框架的。你会发现，Twitch 的网站视觉，和 PC 端的视觉，几乎是一样的。如果两端都采用 JS 语言，就可以极大的复用现有的工程。\n知名度较高的 Node.js 开源项目 express：Node.js 中著名的 web 服务框架。\nKoa：下一代的 Node.js 的 Web 服务框架。所谓的“下一代”是相对于 Express 而言的。\nEgg：2016 年，阿里巴巴研发了知名的 Egg.js 开源项目，号称企业级 Web 服务框架。Egg.js 是基于 Koa 开发的。\nmocha：是现在最流行的 JavaScript 测试框架，在浏览器和 Node 环境都可以使用。\nPM2：node 多进程管理。\njade：非常优秀的模板引擎，不仅限于 js 语言。\nCoffeeScript：用简洁的方式展示 JavaScript 优秀的部分。\nAtom：编辑器。\nVS Code：最酷炫的编辑器。\nsocket.io：实时通信框架。\n总结 或许，能用 Node.js 做的后台应用，Java/C++ 也能做；但是 Node.js 可以让我们多一种选择。\n短期来看，Node.js 很难像 Java/C++ 那样，成为后台的主力开发语言。这并非是因为 Node.js 的性能问题，主要是因为，Node.js 还比较年轻，经验积累太少，框架的支持度不够。搞企业级服务，Node.js 敌不过 Java/C++，所以目前只能搞「轻量级」；但未来可期。\n限制语言能力的不是语言本身，而是生态。\n最后一段：前端同学会 Node.js 就真的全栈了吗？ 一个人的精力是有限的，既擅长前端、又精通后端的人，毕竟是极少数。\n林肯说过：“你可以在所有的时间欺骗一部分人，也可以在一段时间欺骗所有的人，但你不可能在所有的时间欺骗所有的人”。\n同样的，我也说过：“你可以在这一段时间擅长前端技术，也可以在另一段时间擅长后台技术，但你不可能在同一段时间同时擅长前端和后台，更不可能在所有的时间同时擅长前端和后台。”\n所谓的全栈，只是一个伪命题。个人不一定需要全栈，企业和项目也不强制要求全栈，分工协作，才最高效。\n对于个人而言，虽然全栈很难，但是 Node.js 的出现，让 JS 语言实现了前后端语法的统一，让 JS 语言的技术栈更佳全面。\n涉及到后台开发相关的技术，无论如何，也绕不开框架设计、开发调试、数据库操作、高并发处理、大规模存储、性能优化、容灾方案、RPC 调用、进程管理、操作系统调度、网络安全、系统运维、日常维护、甚至是 Linux 内核、驱动开发等过硬的知识技能和经验积累。等你亲身经历过这些，才算明白：语言只是一种工具。\n","wordCount":"5132","inLanguage":"en","datePublished":"2020-01-01T17:11:35+08:00","dateModified":"2020-01-01T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/tech/wait/10-node.js%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93/01-node.js%E4%BB%8B%E7%BB%8D/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>01-Node.js介绍</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/node/>Node</a></div>11 min&nbsp;·&nbsp;<span title='2020-01-01 17:11:35 +0800 +0800'>2020/01/01</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#todo aria-label=todo>todo</a></li><li><a href=#%e5%89%8d%e8%a8%80 aria-label=前言>前言</a><ul><li><a href=#%e5%89%8d%e7%ab%af%e5%90%8c%e5%ad%a6%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ad%a6%e4%b9%a0%e5%90%8e%e7%ab%af%e5%90%8e%e7%ab%af%e5%90%8c%e5%ad%a6%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ad%a6%e4%b9%a0%e5%89%8d%e7%ab%af aria-label=前端同学为什么要学习后端/后端同学为什么要学习前端>前端同学为什么要学习后端/后端同学为什么要学习前端</a></li><li><a href=#%e5%89%8d%e7%ab%af%e5%90%8c%e5%ad%a6%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ad%a6-nodejs aria-label="前端同学为什么要学 Node.js">前端同学为什么要学 Node.js</a></li><li><a href=#%e5%90%8e%e7%ab%af%e5%90%8c%e5%ad%a6%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%ad%a6-nodejs aria-label="后端同学为什么要学 Node.js">后端同学为什么要学 Node.js</a></li></ul></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af-nodejs aria-label="什么是 Node.js">什么是 Node.js</a><ul><li><a href=#%e5%ae%98%e6%96%b9%e5%ae%9a%e4%b9%89 aria-label=官方定义>官方定义</a></li><li><a href=#nodejs-%e7%9a%84%e7%bb%84%e6%88%90 aria-label="Node.js 的组成">Node.js 的组成</a></li><li><a href=#%e8%a1%a5%e5%85%85 aria-label=补充>补充</a></li></ul></li><li><a href=#nodejs-%e7%9a%84%e6%9e%b6%e6%9e%84%e5%92%8c%e4%be%9d%e8%b5%96 aria-label="Node.js 的架构和依赖">Node.js 的架构和依赖</a><ul><li><a href=#nodejs-%e8%bf%90%e8%a1%8c%e7%8e%af%e5%a2%83%e7%9a%84%e6%a0%b8%e5%bf%83v8-%e5%bc%95%e6%93%8e-%e5%92%8c-libuv-%e5%ba%93 aria-label="Node.js 运行环境的核心：V8 引擎 和 libuv 库">Node.js 运行环境的核心：V8 引擎 和 libuv 库</a></li><li><a href=#java-%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%92%8c-v8-%e5%bc%95%e6%93%8e%e6%98%af%e7%94%b1%e5%90%8c%e4%b8%80%e4%ba%ba%e5%bc%80%e5%8f%91 aria-label="Java 虚拟机和 V8 引擎，是由同一人开发">Java 虚拟机和 V8 引擎，是由同一人开发</a></li><li><a href=#v8-%e7%9a%84%e5%86%85%e5%ad%98%e9%99%90%e5%88%b6 aria-label="V8 的内存限制">V8 的内存限制</a></li></ul></li><li><a href=#node-%e7%9a%84%e5%8f%91%e5%b1%95%e5%8e%86%e5%8f%b2 aria-label="Node 的发展历史">Node 的发展历史</a></li><li><a href=#nodejs-%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="Node.js 的应用">Node.js 的应用</a><ul><li><a href=#1bff-%e4%b8%ad%e9%97%b4%e5%b1%82 aria-label="1、BFF 中间层">1、BFF 中间层</a></li><li><a href=#2%e6%9c%8d%e5%8a%a1%e7%ab%af%e6%b8%b2%e6%9f%93 aria-label=2、服务端渲染>2、服务端渲染</a></li><li><a href=#3%e5%81%9a%e5%b0%8f%e5%9e%8b%e6%9c%8d%e5%8a%a1%e5%b0%8f%e5%9e%8b%e7%bd%91%e7%ab%99%e7%9a%84%e5%90%8e%e7%ab%af%e5%9f%ba%e4%ba%8e-expresskoa-%e6%a1%86%e6%9e%b6 aria-label="3、做小型服务、小型网站的后端（基于 Express、Koa 框架）">3、做小型服务、小型网站的后端（基于 Express、Koa 框架）</a></li><li><a href=#4%e5%81%9a%e9%a1%b9%e7%9b%ae%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7 aria-label=4、做项目构建工具>4、做项目构建工具</a></li><li><a href=#5-%e5%81%9a-pc-%e7%ab%af%e7%9a%84%e8%bd%af%e4%bb%b6%e5%9f%ba%e4%ba%8e-electron-%e6%a1%86%e6%9e%b6 aria-label="5、 做 PC 端的软件（基于 Electron 框架）">5、 做 PC 端的软件（基于 Electron 框架）</a></li><li><a href=#%e7%9f%a5%e5%90%8d%e5%ba%a6%e8%be%83%e9%ab%98%e7%9a%84-nodejs-%e5%bc%80%e6%ba%90%e9%a1%b9%e7%9b%ae aria-label="知名度较高的 Node.js 开源项目">知名度较高的 Node.js 开源项目</a></li><li><a href=#%e6%80%bb%e7%bb%93 aria-label=总结>总结</a></li></ul></li><li><a href=#%e6%9c%80%e5%90%8e%e4%b8%80%e6%ae%b5%e5%89%8d%e7%ab%af%e5%90%8c%e5%ad%a6%e4%bc%9a-nodejs-%e5%b0%b1%e7%9c%9f%e7%9a%84%e5%85%a8%e6%a0%88%e4%ba%86%e5%90%97 aria-label="最后一段：前端同学会 Node.js 就真的全栈了吗？">最后一段：前端同学会 Node.js 就真的全栈了吗？</a></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=todo>todo<a hidden class=anchor aria-hidden=true href=#todo>#</a></h2><ul><li><p>rpc 和 Node.js 的关系</p></li><li><p><a href=https://mp.weixin.qq.com/s/uWeAsJ-P253je15A49uKIQ>《吊打面试官》系列 Node.js 全栈秒杀系统</a></p></li></ul><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>Node 的重要性已经不言而喻，很多互联网公司都已经有大量的高性能系统运行在 Node 之上。Node 凭借其单线程、异步等举措实现了极高的性能基准。此外，目前最为流行的 Web 开发模式是前后端分离的形式，即前端开发者与后端开发者在自己喜欢的 IDE 上独立进行开发，然后通过 HTTP 或是 RPC 等方式实现数据与流程的交互。这种开发模式在 Node 的强大功能的引领下变得越来越高效，也越来越受到各个互联网公司的青睐。</p><h3 id=前端同学为什么要学习后端后端同学为什么要学习前端>前端同学为什么要学习后端/后端同学为什么要学习前端<a hidden class=anchor aria-hidden=true href=#前端同学为什么要学习后端后端同学为什么要学习前端>#</a></h3><ul><li><p>了解前后端交互流程。</p></li><li><p>前端同学能够和后台开发的程序员更佳紧密地结合、更顺畅地沟通。</p></li><li><p>当网站的业务逻辑需要前置时，前端人员需要学习一些后台开发的技术，以完成相应的任务；；反过来也一样。</p></li><li><p>拓宽知识视野和技术栈，能够站在全局的角度审视整个项目。</p></li></ul><h3 id=前端同学为什么要学-nodejs>前端同学为什么要学 Node.js<a hidden class=anchor aria-hidden=true href=#前端同学为什么要学-nodejs>#</a></h3><p>1、Node.js 使用 JavaScript 语言开发服务器端应用，<strong>便于前端同学上手</strong>（一些公司甚至要求前端工程师掌握 Node.js 开发）。</p><p>2、实现了前后端的语法统一，<strong>有利于和前端代码整合</strong>，甚至共用部分代码。</p><p>比如说，针对接口返回的各种字段，前后端都必须要做校验。此时，如果用 Node.js 来做后台开发的话，前后端可以共用校验的代码。</p><p>3、Node.js 性能高、生态系统活跃，提供了大量的开源库。</p><p>4、Jeff Atwood 在 2007 年提出了著名的 Atwood 定律：<strong>任何能够用 JavaScript 实现的应用系统，最终都必将用 JavaScript 实现</strong>。 Jeff Atwood 是谁不重要（他是 Stack Overflow 网站的联合创始人），重要的是这条定律。</p><h3 id=后端同学为什么要学-nodejs>后端同学为什么要学 Node.js<a hidden class=anchor aria-hidden=true href=#后端同学为什么要学-nodejs>#</a></h3><p>因为前端同学在学 Node.js。</p><h2 id=什么是-nodejs>什么是 Node.js<a hidden class=anchor aria-hidden=true href=#什么是-nodejs>#</a></h2><h3 id=官方定义>官方定义<a hidden class=anchor aria-hidden=true href=#官方定义>#</a></h3><p><a href=https://nodejs.org/zh-cn/>Node.js</a> 是一个基于 <strong>Chrome V8 引擎</strong>的 JavaScript 运行环境。Node.js 使用了一个<strong>事件驱动</strong>、<strong>非阻塞式 I/O</strong>的模型，使其轻量又高效。Node.js 的包管理工具 npm 是全球最大的开源库生态系统。</p><p>Node.js 不是一门语言，也不是 JavaScript 的框架，也不是像Nginx一样的Web服务器 ，<strong>Node.js 是 JavaScript 在服务器端的运行环境（平台）</strong>。</p><h3 id=nodejs-的组成>Node.js 的组成<a hidden class=anchor aria-hidden=true href=#nodejs-的组成>#</a></h3><p>在 Node.js 里运行 JavaScript，跟在 Chrome 里运行 JavaScript 有什么不同？</p><p>二者采用的是同样的 JS 引擎。在 Node.js 里写 JS，和在前端写 JS，几乎没有不同。在写法上的区别在于：Node.js 没有浏览器、页面标签相关的 API，但是新增了一些 Node.js 相关的 API。通俗来说，对于开发者而言，在前端写 JS 是用于控制浏览器；而 Node.js 环境写 JS 可以控制整个计算机。</p><p>我们知道，JavaScript 的组成分为三个部分：</p><ul><li><p>ECMAScript</p></li><li><p>DOM：标签元素相关的API</p></li><li><p>BOM：浏览器相关的API</p></li></ul><p>ECMAScript 是 JS 的语法；DOM 和 BOM 浏览器端为 JS 提供的 API。</p><p>而 Node.js 的组成分为：</p><ul><li><p><strong>ECMAScript</strong>。ECMAScript 的所有语法在 Node 环境中都可以使用。</p></li><li><p><strong>Node 环境</strong>提供的一些<strong>附加 API</strong>(包括文件、网络等相关的 API)。</p></li></ul><p>如下图所示：</p><p><img loading=lazy src=http://img.smyhvae.com/20200409_1545.png alt></p><h3 id=补充>补充<a hidden class=anchor aria-hidden=true href=#补充>#</a></h3><p>与 PHP、JSP、Python、Perl、Ruby 的“既是语言，也是平台”不同，Node.js 的使用 JavaScript 进行编程，运行在 Chrome 的 V8 引擎上。</p><p>与 PHP、JSP 等相比（PHP、JSP、.net 都需要运行在服务器程序上，Apache、Nginx、Tomcat、IIS。
），Node.js 跳过了 Apache、Naginx、IIS 等 HTTP 服务器，它自己不用建设在任何服务器软件之上。Node.js 的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。Node.js 没有 web 容器。</p><p>JS 语言非常灵活，使得它在严谨性方面不如 Java 等传统的静态语言。JS 是一门动态语言，而且融合了面向对象和函数式编程这两种编程范式。</p><p>随着 ES6、ES7 等 JS 语法规范的出现，以及浏览器对这些规范的支持，使得我们可以用更为现代化的 JS 语言特性，来编写现代化的应用。</p><h2 id=nodejs-的架构和依赖>Node.js 的架构和依赖<a hidden class=anchor aria-hidden=true href=#nodejs-的架构和依赖>#</a></h2><p>Node.js 的架构如下：</p><p><img loading=lazy src=http://img.smyhvae.com/20180301_1540.png alt></p><p>Node.js 内部采用 Google Chrome 的 V8 引擎，作为 JavaScript 语言解释器；同时结合自行开发的 libuv 库，<strong>扩展了 JS 在后端的能力（比如 I/O 操作、文件读写、数据库操作等）</strong>。使得 JS 既可以在前端进行 DOM 操作（浏览器前端），又可以在后端调用操作系统资源，是目前最简单的全栈式语言。</p><p>其次，Node 生态系统活跃，提供了大量的开源库，使得 JavaScript 语言能与操作系统进行更多的交互。</p><h3 id=nodejs-运行环境的核心v8-引擎-和-libuv-库>Node.js 运行环境的核心：V8 引擎 和 libuv 库<a hidden class=anchor aria-hidden=true href=#nodejs-运行环境的核心v8-引擎-和-libuv-库>#</a></h3><p>Node.js 是 JavaScript 在服务器端的运行环境，在这个意义上，Node.js 的地位其实就是 JavaScript 在服务器端的虚拟机，类似于 Java 语言中的 Java 虚拟机。</p><ul><li><p><a href=https://v8.dev/>V8 引擎</a> ：编译和执行 JS 代码、管理内存、垃圾回收。V8 给 JS 提供了运行环境，可以说是 JS 的虚拟机。V8 引擎本身是用 C++ 写的。</p></li><li><p><a href=https://zh.wikipedia.org/wiki/Libuv>libuv</a>： libuv 是一个专注于异步 I/O 的跨平台类库，目前主要在 Node.js 上使用。它是 Node.js 最初的作者 Ryan Dahl 为 Node.js 写的底层类库，也可以称之为虚拟机。libuv 本身是用 C 写的。</p></li></ul><h3 id=java-虚拟机和-v8-引擎是由同一人开发>Java 虚拟机和 V8 引擎，是由同一人开发<a hidden class=anchor aria-hidden=true href=#java-虚拟机和-v8-引擎是由同一人开发>#</a></h3><p>Chrome 浏览器成功的背后，离不开 JS 的 V8 引擎。作为虚拟机，V8 的性能表现优异，它的开发者是 Lars Bak。在 Lars 的工作履历里，绝大部分都是与虚拟机相关的工作。在开发 V8 之前，他曾经在 Sun 公司工作，担任 HotSpot 团队的技术领导，主要致力于开发高性能的 Java 虚拟机。在这之前，他也曾为 Self、Smalltalk 语言开发过高性能虚拟机。这些无与伦比的经历让 V8 一出世就超越了当时所有的 JS 虚拟机。</p><p><img loading=lazy src=http://img.smyhvae.com/20200617_1120.png alt></p><p>V8 的性能优势使得用 JavaScript 写高性能后台服务程序成为可能。在这样的契机下，Ryan Dahl 选择了 JavaScript，选择了 V8，在事件驱动、非阻塞 I/O 模型的设计下实现了 Node。</p><h3 id=v8-的内存限制>V8 的内存限制<a hidden class=anchor aria-hidden=true href=#v8-的内存限制>#</a></h3><p>在一般的后端开发语言中，在基本的内存使用上没有什么限制，然而在 Node 中通过 JavaScript 使用内存时就会发现只能使用部分内存（64 位系统下约为 1.4GB，32 位系统下约为 0.7GB）。在这样的限制下，将会导致 Node 无法直接操作大内存对象。</p><p>造成这个问题的主要原因在于 Node 基于 V8 构建，所以在 Node 中使用的 JavaScript 对象基本上都是通过 V8 自己的方式来进行分配和管理的。V8 的这套内存管理机制在浏览器的应用场景下使用起来绰绰有余，足以胜任前端页面中的所有需求。但在 Node 中，这却限制了开发者随心所欲使用大内存的想法。</p><h2 id=node-的发展历史>Node 的发展历史<a hidden class=anchor aria-hidden=true href=#node-的发展历史>#</a></h2><ul><li><p>2008 年左右，随着 Ajax 的逐渐普及，Web 开发逐渐走向复杂化，系统化；</p></li><li><p>Node.js 诞生于 2009 年，由 Joyent 的员工 Ryan Dahl 开发而成。2009 年 5 月，Ryan Dahl 在 GitHub 中开源了 Node 的最初版本，同年 11 月，在 JSConf 大会上展示了 Node 项目；</p></li><li><p>2010 年 1 月，NPM 包管理工具诞生，使得程序员能够更方便地发布和分享 Node.js 的第三方库。</p></li><li><p>Node.js 最初只支持 Linux 和 Mac OS 操作系统。2011 年 7 月，微软参与合作，Node.js 终于支持了 Windows 平台。PS：不过，node 的生产环境基本是在 Linux 下。</p></li><li><p>目前官网最新版本已经更新到 14.x.x 版本，最新稳定的是 12.18.0。</p></li></ul><p>据 Node.js 创始人 Ryan Dahl 回忆，他最初希望采用 Ruby，但是 Ruby 的虚拟机效率不行。</p><p>注意：是 Node 选择了 JavaScript，不是 JavaScript 发展出来了一个 Node。</p><h2 id=nodejs-的应用>Node.js 的应用<a hidden class=anchor aria-hidden=true href=#nodejs-的应用>#</a></h2><p>Node.js 拥有强大的开发者社区，现在已经发展出比较成熟的技术体系，以及庞大的生态。它被广泛地应用在 Web 服务、开发工作流、客户端应用等诸多领域。其中，在 <strong>Web 服务</strong>领域，业界对 Node.js 的接受程度最高。</p><h3 id=1bff-中间层>1、BFF 中间层<a hidden class=anchor aria-hidden=true href=#1bff-中间层>#</a></h3><p>BFF，即 Backend For Frontend（服务于前端的后端）。玉伯在《<a href=https://mp.weixin.qq.com/s/IYddaaw2ps1wR2VT1dZWPg>从前端技术进化到体验科技</a>》这篇文章中点出了 BFF 层的概念：</p><blockquote><p>BFF 模式下，整体分工很清晰，<strong>后端通过 Java/C++ 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据</strong>，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。<strong>领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效</strong>。</p></blockquote><p>在 Web 服务里，搭建一个中间层，前端访问中间层的接口，中间层再访问后台的 Java/C++ 服务。这类服务的特点是不需要太强的服务器运算能力，但对程序的灵活性有较高的要求。这两个特点，正好和 Node.js 的优势相吻合。Node.js 非常适合用来做 BFF 层，优势如下：</p><ul><li><p>对于前端来说：让前端<strong>有能力自由组装后台数据</strong>，这样可以减少大量的业务沟通成本，加快业务的迭代速度；并且，前端同学能够<strong>自主决定</strong>与后台的通讯方式。</p></li><li><p>对于后台和运维来说，好处是：安全性（不会把主服务器暴露在外面）、降低主服务器的复杂度等。</p></li></ul><h3 id=2服务端渲染>2、服务端渲染<a hidden class=anchor aria-hidden=true href=#2服务端渲染>#</a></h3><p><strong>客户端渲染</strong>（CSR / Client side render）：前端通过一大堆接口请求数据，然后通过 JS 动态处理和生成页面结构和展示。优点是<strong>前后端分离</strong>、减小服务器压力、局部刷新。缺点是不利于 SEO（如果你的页面然后通过 Ajax 异步获取内容，抓取工具并不会等待异步完成后再行抓取页面内容）、首屏渲染慢。</p><p><strong>服务端渲染</strong>（SSR / Server Side Render）：服务器返回的不是接口数据，而是一整个页面（或整个楼层）的 HTML 字符串，浏览器直接显示即可。也就是说，在服务器端直接就渲染好了，然后一次性打包返回给前端。优点是<strong>有利于 SEO、首屏渲染很快</strong>。</p><p><strong>总结： 搜索引擎优化 + 首屏速度优化 = 服务端渲染</strong>。</p><p>备注：这里的「服务端渲染」只是让 Node.js 做中间层，不会替代后端的，后台同学请放心。</p><p>参考链接：</p><ul><li><p><a href=https://ssr.vuejs.org/zh/>Vue 服务端渲染的概念</a></p></li><li><p><a href=https://blog.csdn.net/u012036171/article/details/88833200>https://blog.csdn.net/u012036171/article/details/88833200</a></p></li><li><p><a href=https://juejin.im/post/5c068fd8f265da61524d2abc>https://juejin.im/post/5c068fd8f265da61524d2abc</a></p></li><li><p><a href=https://www.zhihu.com/question/59578433/answer/326694511>方应杭</a></p></li></ul><p>历史回顾：</p><p>（1）一开始，页面很简单，html 是后端渲染的（比如PHP、ASP、JSP等方式）。后端发现页面中的 js 好麻烦（虽然简单，但是坑多），于是让公司招聘专门写 js 的人，简称「前端切图仔」。</p><p>（2）随着 Node.js 和前端 MVC 的兴起，以及前端越来越复杂，慢慢演变成了「前后端分离」。</p><p>（3）前端的 SPA 应用流行之后，发现 SEO 问题很大，而且首屏渲染速度很慢，但是自己选的路再难走也要走下去，于是用 Node.js 在服务端渲染被看成是一条出路。</p><p>（4）以前在一起的时候，是后端做部分前端的工作；现在在一起的时候，是前端做部分后端的工作。</p><h3 id=3做小型服务小型网站的后端基于-expresskoa-框架>3、做小型服务、小型网站的后端（基于 Express、Koa 框架）<a hidden class=anchor aria-hidden=true href=#3做小型服务小型网站的后端基于-expresskoa-框架>#</a></h3><p>现在很多公司的后台管理系统，都是用 Node.js 来开发接口，毕竟，后台管理系统对性能和并发的要求不是太高。有了 Node.js 之后，通过 JS 直接操作 DB，做增删改查，生成接口，极大降低了前端同学的学习门槛。</p><p>当然，有时候做 Node.js 开发，是因为：后台人力不够，所以把后台开发的一部分工作量，转移给前端同学。</p><h3 id=4做项目构建工具>4、做项目构建工具<a hidden class=anchor aria-hidden=true href=#4做项目构建工具>#</a></h3><p>前端正在广泛使用的构建工具 gulp、Webpack，就是基于 Node.js 来实现的。</p><h3 id=5-做-pc-端的软件基于-electron-框架>5、 做 PC 端的软件（基于 Electron 框架）<a hidden class=anchor aria-hidden=true href=#5-做-pc-端的软件基于-electron-框架>#</a></h3><p>Electron 框架就是基于 Node.js 的。也可以说：Electron 是 Node.js 在PC客户端的技术。</p><p>有一点你可能会感到惊讶：程序员们都在用的代码编辑器 VS Code 软件， 就是用 JS 语言实现的。</p><p>还有一个例子是：电子游戏直播网站 <a href=https://www.twitch.tv/>Twitch</a>，号称是国外游戏直播的鼻祖，它在 PC 端的客户端软件，就是用 Electron 框架的。你会发现，Twitch 的网站视觉，和 PC 端的视觉，几乎是一样的。如果两端都采用 JS 语言，就可以极大的复用现有的工程。</p><h3 id=知名度较高的-nodejs-开源项目>知名度较高的 Node.js 开源项目<a hidden class=anchor aria-hidden=true href=#知名度较高的-nodejs-开源项目>#</a></h3><p><img loading=lazy src=http://img.smyhvae.com/20180301_2009.png alt></p><ul><li><p>express：Node.js 中著名的 web 服务框架。</p></li><li><p>Koa：下一代的 Node.js 的 Web 服务框架。所谓的“下一代”是相对于 Express 而言的。</p></li><li><p><a href=https://eggjs.org/zh-cn/>Egg</a>：2016 年，阿里巴巴研发了知名的 Egg.js 开源项目，号称企业级 Web 服务框架。Egg.js 是基于 Koa 开发的。</p></li></ul><ul><li><p>mocha：是现在最流行的 JavaScript 测试框架，在浏览器和 Node 环境都可以使用。</p></li><li><p>PM2：node 多进程管理。</p></li><li><p>jade：非常优秀的模板引擎，不仅限于 js 语言。</p></li><li><p>CoffeeScript：用简洁的方式展示 JavaScript 优秀的部分。</p></li><li><p>Atom：编辑器。</p></li><li><p>VS Code：最酷炫的编辑器。</p></li><li><p>socket.io：实时通信框架。</p></li></ul><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p>或许，能用 Node.js 做的后台应用，Java/C++ 也能做；但是 Node.js 可以让我们多一种选择。</p><p>短期来看，Node.js 很难像 Java/C++ 那样，成为后台的主力开发语言。这并非是因为 Node.js 的性能问题，主要是因为，Node.js 还比较年轻，经验积累太少，框架的支持度不够。搞企业级服务，Node.js 敌不过 Java/C++，所以目前只能搞「轻量级」；但未来可期。</p><p>限制语言能力的不是语言本身，而是生态。</p><h2 id=最后一段前端同学会-nodejs-就真的全栈了吗>最后一段：前端同学会 Node.js 就真的全栈了吗？<a hidden class=anchor aria-hidden=true href=#最后一段前端同学会-nodejs-就真的全栈了吗>#</a></h2><p>一个人的精力是有限的，既擅长前端、又精通后端的人，毕竟是极少数。</p><p>林肯说过：“你可以在所有的时间欺骗一部分人，也可以在一段时间欺骗所有的人，但你不可能在所有的时间欺骗所有的人”。</p><p>同样的，我也说过：“你可以在这一段时间擅长前端技术，也可以在另一段时间擅长后台技术，但你不可能在<strong>同一段时间</strong>同时擅长前端和后台，更不可能在<strong>所有的时间</strong>同时擅长前端和后台。”</p><p>所谓的全栈，只是一个伪命题。个人不一定需要全栈，企业和项目也不强制要求全栈，分工协作，才最高效。</p><p>对于个人而言，虽然全栈很难，但是 Node.js 的出现，<strong>让 JS 语言实现了前后端语法的统一，让 JS 语言的技术栈更佳全面</strong>。</p><p>涉及到后台开发相关的技术，无论如何，也绕不开<strong>框架设计、开发调试、数据库操作、高并发处理、大规模存储、性能优化、容灾方案、RPC 调用、进程管理、操作系统调度、网络安全、系统运维、日常维护、甚至是 Linux 内核、驱动开发</strong>等过硬的知识技能和经验积累。等你亲身经历过这些，才算明白：语言只是一种工具。</p><h2 id=heading><a hidden class=anchor aria-hidden=true href=#heading>#</a></h2></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/node/>Node</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/tech/wait/zzz-%E5%86%85%E5%AE%B9%E5%88%86%E4%BA%AB/01-2020%E5%B9%B4web%E5%89%8D%E7%AB%AF%E6%9C%80%E6%96%B0%E5%AF%BC%E8%88%AA/><span class=title>« Prev</span><br><span>01-2020年Web前端最新导航</span></a>
<a class=next href=https://bablvsj.github.io/posts/tech/wait/12-react%E5%9F%BA%E7%A1%80/01-react%E4%BB%8B%E7%BB%8D/><span class=title>Next »</span><br><span>01-React介绍</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>