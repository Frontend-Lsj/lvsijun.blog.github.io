<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>前端跨域Nginx、CORS | Bablvsj's Blog</title><meta name=keywords content="前端疑难杂症"><meta name=description content="前端跨域Nginx、CORS - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/2-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9Fnginxcors/><link crossorigin=anonymous href=/assets/css/stylesheet.241265d51339977eb0f90d05780e286ec2789600ca4137f29552dec9dee06569.css integrity="sha256-JBJl1RM5l36w+Q0FeA4obsJ4lgDKQTfylVLeyd7gZWk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="前端跨域Nginx、CORS"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/2-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9Fnginxcors/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-02-01T17:11:35+08:00"><meta property="article:modified_time" content="2020-02-01T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="前端跨域Nginx、CORS"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"前端跨域Nginx、CORS","item":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/2-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9Fnginxcors/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"前端跨域Nginx、CORS","name":"前端跨域Nginx、CORS","description":"","keywords":["前端疑难杂症"],"articleBody":"什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。\n广义的跨域：\n1.) 资源跳转： A链接、重定向、表单提交 2.) 资源嵌入： 、","wordCount":"3757","inLanguage":"en","datePublished":"2020-02-01T17:11:35+08:00","dateModified":"2020-02-01T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/2-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9Fnginxcors/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>前端跨域Nginx、CORS</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/>前端疑难杂症</a></div>8 min&nbsp;·&nbsp;<span title='2020-02-01 17:11:35 +0800 +0800'>2020/02/01</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e8%b7%a8%e5%9f%9f aria-label=什么是跨域？><strong>什么是跨域？</strong></a></li><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e5%90%8c%e6%ba%90%e7%ad%96%e7%95%a5 aria-label=什么是同源策略？>什么是同源策略？</a></li><li><a href=#%e5%b8%b8%e8%a7%81%e8%b7%a8%e5%9f%9f%e5%9c%ba%e6%99%af aria-label=常见跨域场景><strong>常见跨域场景</strong></a><ul><li><a href=#%e5%90%84%e8%b7%a8%e5%9f%9f%e6%96%b9%e6%a1%88%e5%8c%ba%e5%88%ab aria-label=各跨域方案区别>各跨域方案区别</a></li><li><a href=#1jsonp----%e7%bc%ba%e7%82%b9%e5%8f%aa%e8%83%bd%e5%ae%9e%e7%8e%b0get%e4%b8%80%e7%a7%8d%e8%af%b7%e6%b1%82 aria-label="1、jsonp   （ 缺点：只能实现get一种请求）">1、jsonp （ 缺点：只能实现get一种请求）</a></li><li><a href=#2%e8%b7%a8%e5%9f%9f%e8%b5%84%e6%ba%90%e5%85%b1%e4%ba%abcors-%e8%ae%be%e7%bd%aeaccess-control-allow-origin aria-label="2、跨域资源共享（CORS） 设置Access-Control-Allow-Origin">2、跨域资源共享（CORS） 设置Access-Control-Allow-Origin</a><ul><li><a href=#1-%e5%89%8d%e7%ab%af%e8%ae%be%e7%bd%ae aria-label="1）、 前端设置："><strong>1）、 前端设置：</strong></a></li><li><a href=#2-%e6%9c%8d%e5%8a%a1%e7%ab%af%e8%ae%be%e7%bd%ae aria-label="2）、 服务端设置："><strong>2）、 服务端设置：</strong></a></li></ul></li><li><a href=#3nginx%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e6%8e%a5%e5%8f%a3%e8%b7%a8%e5%9f%9f aria-label=3、nginx反向代理接口跨域>3、nginx反向代理接口跨域</a><ul><li><a href=#1-nginx%e9%85%8d%e7%bd%ae%e8%a7%a3%e5%86%b3iconfont%e8%b7%a8%e5%9f%9f aria-label="1）、 nginx配置解决iconfont跨域">1）、 nginx配置解决iconfont跨域</a></li><li><a href=#2nginx%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86%e6%8e%a5%e5%8f%a3%e8%b7%a8%e5%9f%9f aria-label=2）、nginx反向代理接口跨域>2）、nginx反向代理接口跨域</a></li></ul></li><li><a href=#4-vue%e6%a1%86%e6%9e%b6%e7%9a%84%e8%b7%a8%e5%9f%9fvueconfigjs%e6%96%87%e4%bb%b6%e9%85%8d%e7%bd%ae aria-label="4、 vue框架的跨域（vue.config.js文件配置）">4、 vue框架的跨域（vue.config.js文件配置）</a></li><li><a href=#%e6%89%a9%e5%b1%95%e7%9f%a5%e8%af%86-nginx-%e6%ad%a3%e5%90%91%e4%bb%a3%e7%90%86-%e4%bb%a3%e7%90%86%e5%ae%a2%e6%88%b7%e7%ab%af%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86-%e4%bb%a3%e7%90%86%e6%9c%8d%e5%8a%a1%e5%99%a8 aria-label="扩展知识： nginx 正向代理 代理客户端，反向代理 代理服务器。">扩展知识： nginx <strong>正向代理 代理客户端，反向代理 代理服务器。</strong></a><ul><li><a href=#1nginx-%e6%ad%a3%e5%90%91%e4%bb%a3%e7%90%86 aria-label="1、nginx 正向代理">1、nginx 正向代理</a></li><li><a href=#2nginx%e5%8f%8d%e5%90%91%e4%bb%a3%e7%90%86 aria-label=2、nginx反向代理>2、nginx反向代理</a></li></ul></li></ul></li><li><a href=#nginx%e5%ae%8c%e6%95%b4%e9%85%8d%e7%bd%ae aria-label=Nginx完整配置>Nginx完整配置</a></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=什么是跨域><strong>什么是跨域？</strong><a hidden class=anchor aria-hidden=true href=#什么是跨域>#</a></h3><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p><p>广义的跨域：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>1.) 资源跳转： A链接、重定向、表单提交
</span></span><span style=display:flex><span>2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链
</span></span><span style=display:flex><span>3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等
</span></span></code></pre></div><h3 id=什么是同源策略>什么是同源策略？<a hidden class=anchor aria-hidden=true href=#什么是同源策略>#</a></h3><p>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span> Cookie、LocalStorage 和 IndexDB 无法读取
</span></span><span style=display:flex><span>2.) DOM 和 Js对象无法获得
</span></span><span style=display:flex><span>3.) AJAX 请求不能发送
</span></span></code></pre></div><h3 id=常见跨域场景><strong>常见跨域场景</strong><a hidden class=anchor aria-hidden=true href=#常见跨域场景>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>URL                                      说明                    是否允许通信
</span></span><span style=display:flex><span>http://www.domain.com/a.js
</span></span><span style=display:flex><span>http://www.domain.com/b.js         同一域名，不同文件或路径           允许
</span></span><span style=display:flex><span>http://www.domain.com/lab/c.js
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>http://www.domain.com:8000/a.js
</span></span><span style=display:flex><span>http://www.domain.com/b.js         同一域名，不同端口                不允许
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>http://www.domain.com/a.js
</span></span><span style=display:flex><span>https://www.domain.com/b.js        同一域名，不同协议                不允许
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>http://www.domain.com/a.js
</span></span><span style=display:flex><span>http://192.168.4.12/b.js           域名和域名对应相同ip              不允许
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>http://www.domain.com/a.js
</span></span><span style=display:flex><span>http://x.domain.com/b.js           主域相同，子域不同                不允许
</span></span><span style=display:flex><span>http://domain.com/c.js
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>http://www.domain1.com/a.js
</span></span><span style=display:flex><span>http://www.domain2.com/b.js        不同域名                         不允许
</span></span></code></pre></div><h4 id=各跨域方案区别>各跨域方案区别<a hidden class=anchor aria-hidden=true href=#各跨域方案区别>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>jsonp（只支持get请求，支持老的IE浏览器）适合加载不同域名的js、css，img等静态资源；
</span></span><span style=display:flex><span>CORS（支持所有类型的HTTP请求，但浏览器IE10以下不支持）适合做ajax各种跨域请求；
</span></span><span style=display:flex><span>Nginx代理跨域和nodejs中间件跨域原理都相似，都是搭建一个服务器，直接在服务器端请求HTTP接口，适合前后端分离的前端项目调后端接口。
</span></span><span style=display:flex><span>document.domain+iframe适合主域名相同，子域名不同的跨域请求。
</span></span><span style=display:flex><span>postMessage、websocket都是HTML5新特性，兼容性不是很好，只适用于主流浏览器和IE10+。
</span></span></code></pre></div><h4 id=1jsonp----缺点只能实现get一种请求>1、jsonp （ 缺点：只能实现get一种请求）<a hidden class=anchor aria-hidden=true href=#1jsonp----缺点只能实现get一种请求>#</a></h4><p>1.）jquery ajax：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>$.ajax({
</span></span><span style=display:flex><span>    url: &#39;http://www.domain2.com:8080/login&#39;,
</span></span><span style=display:flex><span>    type: &#39;get&#39;,
</span></span><span style=display:flex><span>    dataType: &#39;jsonp&#39;,  // 请求方式为jsonp
</span></span><span style=display:flex><span>    jsonpCallback: &#34;handleCallback&#34;,    // 自定义回调函数名
</span></span><span style=display:flex><span>    data: {}
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>2.）vue.js：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>this.$http.jsonp(&#39;http://www.domain2.com:8080/login&#39;, {
</span></span><span style=display:flex><span>    params: {},
</span></span><span style=display:flex><span>    jsonp: &#39;handleCallback&#39;
</span></span><span style=display:flex><span>}).then((res) =&gt; {
</span></span><span style=display:flex><span>    console.log(res); 
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h4 id=2跨域资源共享cors-设置access-control-allow-origin>2、跨域资源共享（CORS） 设置Access-Control-Allow-Origin<a hidden class=anchor aria-hidden=true href=#2跨域资源共享cors-设置access-control-allow-origin>#</a></h4><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p><p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。</p><h5 id=1-前端设置><strong>1）、 前端设置：</strong><a hidden class=anchor aria-hidden=true href=#1-前端设置>#</a></h5><p>原生ajax</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>// 前端设置是否带cookie
</span></span><span style=display:flex><span>xhr.withCredentials = true;
</span></span></code></pre></div><p>示例代码：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 前端设置是否带cookie
</span></span><span style=display:flex><span>xhr.withCredentials = true;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>xhr.open(&#39;post&#39;, &#39;http://www.domain2.com:8080/login&#39;, true);
</span></span><span style=display:flex><span>xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded&#39;);
</span></span><span style=display:flex><span>xhr.send(&#39;user=admin&#39;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>xhr.onreadystatechange = function() {
</span></span><span style=display:flex><span>    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
</span></span><span style=display:flex><span>        alert(xhr.responseText);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h5 id=2-服务端设置><strong>2）、 服务端设置：</strong><a hidden class=anchor aria-hidden=true href=#2-服务端设置>#</a></h5><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p><p>1.）Java后台：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>/*
</span></span><span style=display:flex><span> * 导入包：import javax.servlet.http.HttpServletResponse;
</span></span><span style=display:flex><span> * 接口参数中定义：HttpServletResponse response
</span></span><span style=display:flex><span> */
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&#39;/&#39;
</span></span><span style=display:flex><span>response.setHeader(&#34;Access-Control-Allow-Origin&#34;, &#34;http://www.domain1.com&#34;); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 允许前端带认证cookie：启用此项后，上面的域名不能为&#39;*&#39;，必须指定具体的域名，否则浏览器会提示
</span></span><span style=display:flex><span>response.setHeader(&#34;Access-Control-Allow-Credentials&#34;, &#34;true&#34;); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>// 提示OPTIONS预检时，后端需要设置的两个常用自定义头
</span></span><span style=display:flex><span>response.setHeader(&#34;Access-Control-Allow-Headers&#34;, &#34;Content-Type,X-Requested-With&#34;);
</span></span></code></pre></div><p>2.）Nodejs后台示例：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>var http = require(&#39;http&#39;);
</span></span><span style=display:flex><span>var server = http.createServer();
</span></span><span style=display:flex><span>var qs = require(&#39;querystring&#39;);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>server.on(&#39;request&#39;, function(req, res) {
</span></span><span style=display:flex><span>    var postData = &#39;&#39;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 数据块接收中
</span></span><span style=display:flex><span>    req.addListener(&#39;data&#39;, function(chunk) {
</span></span><span style=display:flex><span>        postData += chunk;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    // 数据接收完毕
</span></span><span style=display:flex><span>    req.addListener(&#39;end&#39;, function() {
</span></span><span style=display:flex><span>        postData = qs.parse(postData);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        // 跨域后台设置
</span></span><span style=display:flex><span>        res.writeHead(200, {
</span></span><span style=display:flex><span>            &#39;Access-Control-Allow-Credentials&#39;: &#39;true&#39;,     // 后端允许发送Cookie
</span></span><span style=display:flex><span>            &#39;Access-Control-Allow-Origin&#39;: &#39;http://www.domain1.com&#39;,    // 允许访问的域（协议+域名+端口）
</span></span><span style=display:flex><span>            /* 
</span></span><span style=display:flex><span>             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，
</span></span><span style=display:flex><span>             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问
</span></span><span style=display:flex><span>             */
</span></span><span style=display:flex><span>            &#39;Set-Cookie&#39;: &#39;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&#39;  // HttpOnly的
</span></span></code></pre></div><h4 id=3nginx反向代理接口跨域>3、nginx反向代理接口跨域<a hidden class=anchor aria-hidden=true href=#3nginx反向代理接口跨域>#</a></h4><h5 id=1-nginx配置解决iconfont跨域>1）、 nginx配置解决iconfont跨域<a hidden class=anchor aria-hidden=true href=#1-nginx配置解决iconfont跨域>#</a></h5><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>location / {
</span></span><span style=display:flex><span>  add_header Access-Control-Allow-Origin *;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=2nginx反向代理接口跨域>2）、nginx反向代理接口跨域<a hidden class=anchor aria-hidden=true href=#2nginx反向代理接口跨域>#</a></h5><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span> server {
</span></span><span style=display:flex><span>    listen	<span style=color:#8f3f71>80</span> 				#监听80端口，访问域名为www.<span style=color:#8f3f71>123.</span>com，不加端口号时默认为80端口
</span></span><span style=display:flex><span>	listen <span style=color:#af3a03>*:</span><span style=color:#8f3f71>80</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>*:</span><span style=color:#8f3f71>8080</span> 	#监听所有80端口和8080端口
</span></span><span style=display:flex><span>	listen  IP_address		#监听指定ip地址所有端口
</span></span><span style=display:flex><span>	listen port     		#监听该端口的所有IP连接
</span></span><span style=display:flex><span>	server_name  www.<span style=color:#8f3f71>123.</span>com www.baidu.com;  #多个用空格隔开
</span></span><span style=display:flex><span>     #访问该域名时会跳转到127.<span style=color:#8f3f71>0.0</span>.<span style=color:#8f3f71>1</span><span style=color:#af3a03>:</span><span style=color:#8f3f71>8080</span>路径
</span></span><span style=display:flex><span>     #通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端 server_name <span style=color:#af3a03>*</span>.<span style=color:#8f3f71>123.</span>com www.<span style=color:#8f3f71>123.</span><span style=color:#af3a03>*</span>
</span></span><span style=display:flex><span>     #正则表达式，用“<span style=color:#af3a03>~</span>”作为正则表达式字符串的开始标记
</span></span><span style=display:flex><span>	 #server_name <span style=color:#af3a03>~^</span>www\d<span style=color:#af3a03>+</span>\.<span style=color:#8f3f71>123</span>\.com$;
</span></span><span style=display:flex><span>     #“<span style=color:#af3a03>~</span>”表示匹配正则表达式，以www开头（“<span style=color:#af3a03>^</span>”表示开头），紧跟着一个0<span style=color:#af3a03>~</span><span style=color:#8f3f71>9</span>之间的数字，再紧跟“.<span style=color:#8f3f71>123.</span>co”，最后跟着“m”($表示结尾)
</span></span><span style=display:flex><span>     #基于 IP 地址的虚拟主机配置 <span style=color:#af3a03>==</span> 域名匹配 （不考虑通配符和正则表达式） server_name <span style=color:#8f3f71>192.168</span>.<span style=color:#8f3f71>1.1</span>
</span></span><span style=display:flex><span>     匹配顺序：
</span></span><span style=display:flex><span> 		①、准确匹配 server_name
</span></span><span style=display:flex><span>        ②、通配符在开始时匹配 server_name 成功
</span></span><span style=display:flex><span>        ③、通配符在结尾时匹配 server_name 成功
</span></span><span style=display:flex><span>        ④、正则表达式匹配 server_name 成功
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	location <span style=color:#af3a03>/</span> {    #用于匹配 URL    
</span></span><span style=display:flex><span>		proxy_pass http<span style=color:#af3a03>:</span><span style=color:#8f3f71>127.0</span>.<span style=color:#8f3f71>0.1</span><span style=color:#af3a03>:</span><span style=color:#8f3f71>8080</span>;   #用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式
</span></span><span style=display:flex><span>		index  index.html index.htm index.jsp; #用于设置网站的默认首页 可有多个用空格隔开  index.html index.jsp
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=4-vue框架的跨域vueconfigjs文件配置>4、 vue框架的跨域（vue.config.js文件配置）<a hidden class=anchor aria-hidden=true href=#4-vue框架的跨域vueconfigjs文件配置>#</a></h4><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>module.exports = {
</span></span><span style=display:flex><span>    entry: {},
</span></span><span style=display:flex><span>    module: {},
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    devServer: {
</span></span><span style=display:flex><span>        historyApiFallback: true,
</span></span><span style=display:flex><span>        proxy: [{
</span></span><span style=display:flex><span>            context: &#39;/login&#39;,
</span></span><span style=display:flex><span>            target: &#39;http://www.domain2.com:8080&#39;,  // 代理跨域目标接口
</span></span><span style=display:flex><span>            changeOrigin: true,
</span></span><span style=display:flex><span>            secure: false,  // 当代理某些https服务报错时用
</span></span><span style=display:flex><span>            cookieDomainRewrite: &#39;www.domain1.com&#39;  // 可以为false，表示不修改
</span></span><span style=display:flex><span>        }],
</span></span><span style=display:flex><span>        noInfo: true
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=扩展知识-nginx-正向代理-代理客户端反向代理-代理服务器>扩展知识： nginx <strong>正向代理 代理客户端，反向代理 代理服务器。</strong><a hidden class=anchor aria-hidden=true href=#扩展知识-nginx-正向代理-代理客户端反向代理-代理服务器>#</a></h4><h5 id=1nginx-正向代理>1、nginx 正向代理<a hidden class=anchor aria-hidden=true href=#1nginx-正向代理>#</a></h5><h5 id=2nginx反向代理>2、nginx反向代理<a hidden class=anchor aria-hidden=true href=#2nginx反向代理>#</a></h5><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span> server {
</span></span><span style=display:flex><span>    listen	<span style=color:#8f3f71>80</span> 				#监听80端口，访问域名为www.<span style=color:#8f3f71>123.</span>com，不加端口号时默认为80端口
</span></span><span style=display:flex><span>	listen <span style=color:#af3a03>*:</span><span style=color:#8f3f71>80</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>*:</span><span style=color:#8f3f71>8080</span> 	#监听所有80端口和8080端口
</span></span><span style=display:flex><span>	listen  IP_address		#监听指定ip地址所有端口
</span></span><span style=display:flex><span>	listen port     		#监听该端口的所有IP连接
</span></span><span style=display:flex><span>	server_name  www.<span style=color:#8f3f71>123.</span>com www.baidu.com;  #多个用空格隔开
</span></span><span style=display:flex><span>     #访问该域名时会跳转到127.<span style=color:#8f3f71>0.0</span>.<span style=color:#8f3f71>1</span><span style=color:#af3a03>:</span><span style=color:#8f3f71>8080</span>路径
</span></span><span style=display:flex><span>     #通配符只能用在由三段字符组成的首段或者尾端，或者由两端字符组成的尾端 server_name <span style=color:#af3a03>*</span>.<span style=color:#8f3f71>123.</span>com www.<span style=color:#8f3f71>123.</span><span style=color:#af3a03>*</span>
</span></span><span style=display:flex><span>     #正则表达式，用“<span style=color:#af3a03>~</span>”作为正则表达式字符串的开始标记
</span></span><span style=display:flex><span>	 #server_name <span style=color:#af3a03>~^</span>www\d<span style=color:#af3a03>+</span>\.<span style=color:#8f3f71>123</span>\.com$;
</span></span><span style=display:flex><span>     #“<span style=color:#af3a03>~</span>”表示匹配正则表达式，以www开头（“<span style=color:#af3a03>^</span>”表示开头），紧跟着一个0<span style=color:#af3a03>~</span><span style=color:#8f3f71>9</span>之间的数字，再紧跟“.<span style=color:#8f3f71>123.</span>co”，最后跟着“m”($表示结尾)
</span></span><span style=display:flex><span>     #基于 IP 地址的虚拟主机配置 <span style=color:#af3a03>==</span> 域名匹配 （不考虑通配符和正则表达式） server_name <span style=color:#8f3f71>192.168</span>.<span style=color:#8f3f71>1.1</span>
</span></span><span style=display:flex><span>     匹配顺序：
</span></span><span style=display:flex><span> 		①、准确匹配 server_name
</span></span><span style=display:flex><span>        ②、通配符在开始时匹配 server_name 成功
</span></span><span style=display:flex><span>        ③、通配符在结尾时匹配 server_name 成功
</span></span><span style=display:flex><span>        ④、正则表达式匹配 server_name 成功
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	location <span style=color:#af3a03>/</span> {    #用于匹配 URL    
</span></span><span style=display:flex><span>		proxy_pass http<span style=color:#af3a03>:</span><span style=color:#8f3f71>127.0</span>.<span style=color:#8f3f71>0.1</span><span style=color:#af3a03>:</span><span style=color:#8f3f71>8080</span>;   #用于设置被代理服务器的地址。可以是主机名称、IP地址加端口号的形式
</span></span><span style=display:flex><span>		index  index.html index.htm index.jsp; #用于设置网站的默认首页 可有多个用空格隔开  index.html index.jsp
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=nginx完整配置>Nginx完整配置<a hidden class=anchor aria-hidden=true href=#nginx完整配置>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span>user  nginx;
</span></span><span style=display:flex><span>worker_processes  <span style=color:#8f3f71>1</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>error_log  <span style=color:#af3a03>/</span><span style=color:#af3a03>var</span>/log/nginx/error.log warn;
</span></span><span style=display:flex><span>pid        <span style=color:#af3a03>/</span><span style=color:#af3a03>var</span>/run/nginx.pid;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>events {
</span></span><span style=display:flex><span>    worker_connections  <span style=color:#8f3f71>1024</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>http {
</span></span><span style=display:flex><span>    include       <span style=color:#af3a03>/</span>etc<span style=color:#af3a03>/</span>nginx<span style=color:#af3a03>/</span>mime.types;
</span></span><span style=display:flex><span>    default_type  application<span style=color:#af3a03>/</span>octet<span style=color:#af3a03>-</span>stream;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    log_format  main  <span style=color:#79740e>&#39;$remote_addr - $remote_user [$time_local] &#34;$request&#34; &#39;</span>
</span></span><span style=display:flex><span>                      <span style=color:#79740e>&#39;$status $body_bytes_sent &#34;$http_referer&#34; &#39;</span>
</span></span><span style=display:flex><span>                      <span style=color:#79740e>&#39;&#34;$http_user_agent&#34; &#34;$http_x_forwarded_for&#34;&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    access_log  <span style=color:#af3a03>/</span><span style=color:#af3a03>var</span>/log/nginx/access.log  main;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    sendfile        on;
</span></span><span style=display:flex><span>    #tcp_nopush     on;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    keepalive_timeout  <span style=color:#8f3f71>65</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    #gzip  on;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    # include <span style=color:#af3a03>/</span>etc<span style=color:#af3a03>/</span>nginx<span style=color:#af3a03>/</span>conf.d<span style=color:#af3a03>/*</span>.conf; # 引入default.conf配置文件
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    server {
</span></span><span style=display:flex><span>        listen       <span style=color:#8f3f71>80</span>;
</span></span><span style=display:flex><span>        server_name  www.zhengqing520.com;# 服务器地址或绑定域名
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        #charset koi8<span style=color:#af3a03>-</span>r;
</span></span><span style=display:flex><span>        #access_log  <span style=color:#af3a03>/</span><span style=color:#af3a03>var</span>/log/nginx/host.access.log  main;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        # start <span style=color:#af3a03>------------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        location <span style=color:#af3a03>/</span> {
</span></span><span style=display:flex><span>            root   <span style=color:#af3a03>/</span>usr<span style=color:#af3a03>/</span>share<span style=color:#af3a03>/</span>nginx<span style=color:#af3a03>/</span>html;
</span></span><span style=display:flex><span>            try_files $uri $uri<span style=color:#af3a03>/</span> @router;
</span></span><span style=display:flex><span>            index  index.html index.htm;
</span></span><span style=display:flex><span>            # proxy_pass http<span style=color:#af3a03>:</span><span style=color:#928374;font-style:italic>//zhengqingya.gitee.io; # 代理的ip地址和端口号
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>            # proxy_connect_timeout <span style=color:#8f3f71>600</span>; #代理的连接超时时间（单位：毫秒）
</span></span><span style=display:flex><span>            # proxy_read_timeout <span style=color:#8f3f71>600</span>; #代理的读取资源超时时间（单位：毫秒）
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        location @router {
</span></span><span style=display:flex><span>            rewrite <span style=color:#af3a03>^</span>.<span style=color:#af3a03>*</span>$ <span style=color:#af3a03>/</span>index.html last;  
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        location <span style=color:#af3a03>^~</span> /api {  # ^~/api/表示匹配前缀为api的请求
</span></span><span style=display:flex><span>            proxy_pass  http<span style=color:#af3a03>:</span><span style=color:#928374;font-style:italic>//www.zhengqing520.com:9528/api/;  
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>        	# 注：proxy_pass的结尾有<span style=color:#af3a03>/</span>， <span style=color:#af3a03>-&gt;</span> 效果：会在请求时将<span style=color:#af3a03>/</span>api<span style=color:#af3a03>/*</span>后面的路径直接拼接到后面
</span></span><span style=display:flex><span>            # proxy_set_header作用：设置发送到后端服务器(上面proxy_pass)的请求头值  
</span></span><span style=display:flex><span>               # 【当Host设置为 $http_host 时，则不改变请求头的值;
</span></span><span style=display:flex><span>               #  当Host设置为 $proxy_host 时，则会重新设置请求头中的Host信息;
</span></span><span style=display:flex><span>               #  当为$host变量时，它的值在请求包含Host请求头时为Host字段的值，在请求未携带Host请求头时为虚拟主机的主域名;
</span></span><span style=display:flex><span>               #  当为$host<span style=color:#af3a03>:</span>$proxy_port时，即携带端口发送 ex<span style=color:#af3a03>:</span> $host<span style=color:#af3a03>:</span><span style=color:#8f3f71>8080</span> 】
</span></span><span style=display:flex><span>            proxy_set_header Host $host; 
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>            proxy_set_header X<span style=color:#af3a03>-</span>Real<span style=color:#af3a03>-</span>IP $remote_addr; 
</span></span><span style=display:flex><span>        	# 在web服务器端获得用户的真实ip 需配置条件	① 【 $remote_addr值 <span style=color:#af3a03>=</span> 用户ip 】
</span></span><span style=display:flex><span>            proxy_set_header X<span style=color:#af3a03>-</span>Forwarded<span style=color:#af3a03>-</span>For $proxy_add_x_forwarded_for;
</span></span><span style=display:flex><span>       		 # 在web服务器端获得用户的真实ip 需配置条件②
</span></span><span style=display:flex><span>            proxy_set_header REMOTE<span style=color:#af3a03>-</span>HOST $remote_addr;
</span></span><span style=display:flex><span>            # proxy_set_header X<span style=color:#af3a03>-</span>Forwarded<span style=color:#af3a03>-</span>For $http_x_forwarded_for; 
</span></span><span style=display:flex><span>            # $http_x_forwarded_for变量 <span style=color:#af3a03>=</span> X<span style=color:#af3a03>-</span>Forwarded<span style=color:#af3a03>-</span>For变量
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        location <span style=color:#af3a03>^~</span> <span style=color:#79740e>/blog/</span> { # <span style=color:#af3a03>^~</span><span style=color:#79740e>/blog/</span> 表示匹配前缀为blog<span style=color:#af3a03>/</span>后的请求
</span></span><span style=display:flex><span>            proxy_pass  http<span style=color:#af3a03>:</span><span style=color:#928374;font-style:italic>//zhengqingya.gitee.io/blog/;   
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>      
</span></span><span style=display:flex><span>            proxy_set_header Host $proxy_host; # 改变请求头值 <span style=color:#af3a03>-&gt;</span> 转发到码云才会成功
</span></span><span style=display:flex><span>            proxy_set_header  X<span style=color:#af3a03>-</span>Real<span style=color:#af3a03>-</span>IP  $remote_addr;
</span></span><span style=display:flex><span>            proxy_set_header  X<span style=color:#af3a03>-</span>Forwarded<span style=color:#af3a03>-</span>For $proxy_add_x_forwarded_for;
</span></span><span style=display:flex><span>            proxy_set_header X<span style=color:#af3a03>-</span>NginX<span style=color:#af3a03>-</span><span style=color:#b57614>Proxy</span> <span style=color:#af3a03>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>        # end <span style=color:#af3a03>---------------------------------------------------------------------------------------------</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        #error_page  <span style=color:#8f3f71>404</span>              <span style=color:#af3a03>/</span><span style=color:#8f3f71>404.</span>html;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        # redirect server error pages to the <span style=color:#af3a03>static</span> page <span style=color:#af3a03>/</span><span style=color:#8f3f71>50</span>x.html
</span></span><span style=display:flex><span>        #
</span></span><span style=display:flex><span>        error_page   <span style=color:#8f3f71>500</span> <span style=color:#8f3f71>502</span> <span style=color:#8f3f71>503</span> <span style=color:#8f3f71>504</span>  <span style=color:#af3a03>/</span><span style=color:#8f3f71>50</span>x.html;
</span></span><span style=display:flex><span>        location <span style=color:#af3a03>=</span> /50x.html {
</span></span><span style=display:flex><span>            root   <span style=color:#af3a03>/</span>usr<span style=color:#af3a03>/</span>share<span style=color:#af3a03>/</span>nginx<span style=color:#af3a03>/</span>html;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/>前端疑难杂症</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/4-this%E6%8C%87%E5%90%91applycallbind/><span class=title>« Prev</span><br><span>this指向、apply、call、bind</span></a>
<a class=next href=https://bablvsj.github.io/posts/tech/frontend/01-%E5%89%8D%E7%AB%AF%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/%E5%8E%9F%E5%9E%8B%E5%8E%9F%E5%9E%8B%E9%93%BE/><span class=title>Next »</span><br><span>原型、原型链</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>