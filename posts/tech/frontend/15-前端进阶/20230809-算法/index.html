<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>我的第一本算法书 | Bablvsj's Blog</title><meta name=keywords content="算法"><meta name=description content="我的第一本算法书 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/20230809-%E7%AE%97%E6%B3%95/><link crossorigin=anonymous href=/assets/css/stylesheet.241265d51339977eb0f90d05780e286ec2789600ca4137f29552dec9dee06569.css integrity="sha256-JBJl1RM5l36w+Q0FeA4obsJ4lgDKQTfylVLeyd7gZWk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="我的第一本算法书"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/20230809-%E7%AE%97%E6%B3%95/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="我的第一本算法书"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"我的第一本算法书","item":"https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/20230809-%E7%AE%97%E6%B3%95/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"我的第一本算法书","name":"我的第一本算法书","description":"","keywords":["算法"],"articleBody":"一、数据结构 数据结构 优点 缺点 运行时间 添加/删除 链表 数据的添加/删除都较为方便 访问数据比较耗费时间 O(n) O(1) 数组 访问数据十分简单 添加/删除数据比较耗费时间 O(1) O(n) 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 访问 添加 删除 链表 慢 快 快 数组 快 慢 慢 1.1 链表 数据结构 优点 缺点 普通链表 数据的添加和删除都较为方便 访问比较耗费时间 循环链表 想要保存数量固定的最新数据时使用 访问比较耗费时间 双向链表 可以前后遍历数据 十分方便 一是指针数的增加会导致存储空间需求增加；二是添加和删除数据时需要改变更多指针的指向。 1.2 数组 数据结构 优点 缺点 链表 数据的添加和删除都较为方便 访问比较耗费时间 链表 数据的添加和删除都较为方便 访问比较耗费时间 1.3 栈 后进先出 的结构，我们称为 Last In First Out，简称 LIFO。 链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。\n1.4 队列 像队列这种最先进去的数据最先被取来，即 先进先出 的结构，我们称为 First In First Out，简称 FIFO。\n1.5 哈希表 只能从头开始查询。这个操作便叫作 线性查找\n在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。\n如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。\n1.6 堆 堆是一种图的树形结构，被用于实现“优先队列”（priority queues）。\n优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。 在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。\n堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为 O(1)。\n假设数据量为n，根据堆的形状可知树的高度为 log2n ，那重构树的时间复杂度为O(logn)。\n添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度成正比，也是 O(logn)。\n1.7 二叉查找树 二叉查找树（又叫作二叉搜索树或二叉排序树）是一种数据结构，采用了图的树形结构。数据存储于二叉查找树的各个结点中。\n每个节点最多有两个子节点\n两个性质：\n第一个是每个结点的值均大于其左子树上任意一个结点的值。 第二个是每个结点的值均小于其右子树上任意一个结点的值。 所以二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。 反之，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。 比较的次数取决于树的高度。所以如果结点数为 n，而且树的形状又较为均衡的话，比较大小和移动的次数最多就是 log2n。因此，时间复杂度为 O(logn)。 但如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了 O(n)。\n二、排序 2.1 冒泡排序 第 1 轮需要比较 n -1 次，第 2 轮需要比较 n -2 次……第 n -1 轮需 要比较 1 次。因此，总的比较次数为 (n-1) +(n-2) +…+1 ≈ n2/2。 不过，交换数字的次数和输入数据的排列顺序有关。假设出现某种极端情况，如输 入数据正好以从小到大的顺序排列，那么便不需要任何交换操作； 反过来，输入数据要是以从大到小的顺序排列，那么每次比较数字后便都要进行交换。因此，冒泡排序的时间复杂度为O($n^2$)。\nlet Arr = [100, 49, 22, 1, 4, 15, 59, 28, 29, 10,] for (let i = 0; i \u003c Arr.length; i++) { for (let j = Arr.length; j \u003e i; j--) { if (Arr[j] \u003c Arr[j-1]) { let temp = Arr[j-1] Arr[j-1] = Arr[j] Arr[j] = temp } } } 2.2 选择排序 选择排序就是重复从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换 这一操作的算法。在序列中寻找最小值时使用的是线性查找。\nfor (let i = 0; i \u003c Arr.length; i++) { let startIndex=i,startValue = Arr[i],min = Arr[i], minIndex = i; for (let j = i; j \u003c Arr.length; j++) { if (Arr[j] \u003c min) { min = Arr[j] minIndex = j } } if(startIndex !== minIndex ){ Arr[startIndex] = Arr[minIndex] Arr[minIndex] = startValue } } 选择排序使用了线性查找来寻找最小值，因此在第 1 轮中需要比较 n -1 个数字，第 2 轮需要比较 n -2 个数字……到第 n -1 轮的时候就只需比较 1 个数字了。因此，总的比 较次数与冒泡排序的相同，都是 (n-1)+(n-2)+…+1 ≈ n2/2 次。 每轮中交换数字的次数最多为 1 次。如果输入数据就是按从小到大的顺序排列的， 便不需要进行任何交换。选择排序的时间复杂度也和冒泡排序的一样，都为 O($n^2$)。\n2.3 插入排序 插入排序是一种从序列左端开始依次对数据进行排序的算法。在排序过程中，左侧的数据陆续归位，而右侧留下的就是还未被排序的数据。插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内合适的位置上。\nlet tempArr = [] for (let i = 0; i \u003c Arr.length; i++) { tempArr.push(Arr[i]) for (let j = tempArr.length - 1; j \u003e0 ; j--) { if (tempArr[j] \u003c tempArr[j - 1]) { let temp = tempArr[j - 1] tempArr[j - 1] = tempArr[j] tempArr[j] = temp } } } 具体来说，就是第 k 轮需要比较 k -1 次。因此，在最糟糕的情况下，第 2 轮需要操作 1 次，第 3 轮操作 2 次……第 n 轮操作 n -1次，所以时间复杂度和冒泡排序的一样，都为 O($n^2$)。\n2.4 堆排序 堆排序的特点是利用了数据结构中的堆\n堆排序一开始需要将 n 个数据存进堆里，所需时间为 O(nlogn)。 排序过程中，堆从空堆的状态开始，逐渐被数据填满。由于堆的高度小于 log2n，所以插入 1 个数据所需要的时间为 O(logn)。 每轮取出最大的数据并重构堆所需要的时间为 O(logn)。由于总共有 n 轮，所以重构后排序的时间也是 O(nlogn)。 因此，整体来看堆排序的时间复杂度为 O(nlogn)。 这样来看，堆排序的运行时间比之前讲到的冒泡排序、选择排序、插入排序的时间O($n^2$) 都要短，但由于要使用堆这个相对复杂的数据结构，所以实现起来也较为困难。\n2.5 归并排序 论哪一行都是 n 个数据，所以每行的运行时间都为 O(n)。 而将长度为 n 的序列对半分割直到只有一个数据为止时，可以分成 log2n 行，因此，总 共有 log2n 行。也就是说，总的运行时间为 O(nlogn)，这与前面讲到的堆排序相同。\n2.6 快速排序 快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分 为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。 [ 比基准值小的数 ] 基准值 [ 比基准值大的数 ] 接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序\n","wordCount":"2609","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/tech/frontend/15-%E5%89%8D%E7%AB%AF%E8%BF%9B%E9%98%B6/20230809-%E7%AE%97%E6%B3%95/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>我的第一本算法书</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></div>6 min</div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e4%b8%80%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=一、数据结构>一、数据结构</a><ul><li><a href=#11-%e9%93%be%e8%a1%a8 aria-label="1.1 链表">1.1 链表</a></li><li><a href=#12-%e6%95%b0%e7%bb%84 aria-label="1.2 数组">1.2 数组</a></li><li><a href=#13-%e6%a0%88 aria-label="1.3 栈">1.3 栈</a></li><li><a href=#14-%e9%98%9f%e5%88%97 aria-label="1.4 队列">1.4 队列</a></li><li><a href=#15-%e5%93%88%e5%b8%8c%e8%a1%a8 aria-label="1.5 哈希表">1.5 哈希表</a></li><li><a href=#16-%e5%a0%86 aria-label="1.6 堆">1.6 堆</a></li><li><a href=#17-%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91 aria-label="1.7 二叉查找树">1.7 二叉查找树</a></li></ul></li><li><a href=#%e4%ba%8c%e6%8e%92%e5%ba%8f aria-label=二、排序>二、排序</a><ul><li><a href=#21-%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f aria-label="2.1 冒泡排序">2.1 冒泡排序</a></li><li><a href=#22--%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f aria-label="2.2  选择排序">2.2 选择排序</a></li><li><a href=#23--%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f aria-label="2.3  插入排序">2.3 插入排序</a></li><li><a href=#24--%e5%a0%86%e6%8e%92%e5%ba%8f aria-label="2.4  堆排序">2.4 堆排序</a></li><li><a href=#25--%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f aria-label="2.5  归并排序">2.5 归并排序</a></li><li><a href=#26--%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f aria-label="2.6  快速排序">2.6 快速排序</a></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h4 id=一数据结构>一、数据结构<a hidden class=anchor aria-hidden=true href=#一数据结构>#</a></h4><table><thead><tr><th style=text-align:left>数据结构</th><th style=text-align:left>优点</th><th style=text-align:left>缺点</th><th style=text-align:left>运行时间</th><th style=text-align:left>添加/删除</th></tr></thead><tbody><tr><td style=text-align:left>链表</td><td style=text-align:left>数据的添加/删除都较为方便</td><td style=text-align:left>访问数据比较耗费时间</td><td style=text-align:left>O(n)</td><td style=text-align:left>O(1)</td></tr><tr><td style=text-align:left>数组</td><td style=text-align:left>访问数据十分简单</td><td style=text-align:left>添加/删除数据比较耗费时间</td><td style=text-align:left>O(1)</td><td style=text-align:left>O(n)</td></tr><tr><td style=text-align:left>链表</td><td style=text-align:left>数据的添加和删除都较为方便</td><td style=text-align:left>访问比较耗费时间</td><td></td><td></td></tr><tr><td style=text-align:left>链表</td><td style=text-align:left>数据的添加和删除都较为方便</td><td style=text-align:left>访问比较耗费时间</td><td></td><td></td></tr><tr><td style=text-align:left>链表</td><td style=text-align:left>数据的添加和删除都较为方便</td><td style=text-align:left>访问比较耗费时间</td><td></td><td></td></tr></tbody></table><table><thead><tr><th style=text-align:left></th><th style=text-align:left>访问</th><th style=text-align:left>添加</th><th style=text-align:left>删除</th></tr></thead><tbody><tr><td style=text-align:left>链表</td><td style=text-align:left>慢</td><td style=text-align:left>快</td><td style=text-align:left>快</td></tr><tr><td style=text-align:left>数组</td><td style=text-align:left>快</td><td style=text-align:left>慢</td><td style=text-align:left>慢</td></tr></tbody></table><h5 id=11-链表>1.1 链表<a hidden class=anchor aria-hidden=true href=#11-链表>#</a></h5><table><thead><tr><th style=text-align:left>数据结构</th><th style=text-align:left>优点</th><th style=text-align:left>缺点</th></tr></thead><tbody><tr><td style=text-align:left>普通链表</td><td style=text-align:left>数据的添加和删除都较为方便</td><td style=text-align:left>访问比较耗费时间</td></tr><tr><td style=text-align:left>循环链表</td><td style=text-align:left>想要保存数量固定的最新数据时使用</td><td style=text-align:left>访问比较耗费时间</td></tr><tr><td style=text-align:left>双向链表</td><td style=text-align:left>可以前后遍历数据 十分方便</td><td style=text-align:left>一是指针数的增加会导致存储空间需求增加；二是添加和删除数据时需要改变更多指针的指向。</td></tr></tbody></table><h5 id=12-数组>1.2 数组<a hidden class=anchor aria-hidden=true href=#12-数组>#</a></h5><table><thead><tr><th style=text-align:left>数据结构</th><th style=text-align:left>优点</th><th style=text-align:left>缺点</th></tr></thead><tbody><tr><td style=text-align:left>链表</td><td style=text-align:left>数据的添加和删除都较为方便</td><td style=text-align:left>访问比较耗费时间</td></tr><tr><td style=text-align:left>链表</td><td style=text-align:left>数据的添加和删除都较为方便</td><td style=text-align:left>访问比较耗费时间</td></tr></tbody></table><h5 id=13-栈>1.3 栈<a hidden class=anchor aria-hidden=true href=#13-栈>#</a></h5><p><strong>后进先出</strong> 的结构，我们称为 Last In First Out，简称 LIFO。
链表和数组一样，栈的数据也是线性排列，但在栈中，添加和删除数据的操作只能在一端进行，访问数据也只能访问到顶端的数据。想要访问中间的数据时，就必须通过出栈操作将目标数据移到栈顶才行。</p><h5 id=14-队列>1.4 队列<a hidden class=anchor aria-hidden=true href=#14-队列>#</a></h5><p>像队列这种最先进去的数据最先被取来，即 <strong>先进先出</strong> 的结构，我们称为 First In
First Out，简称 FIFO。</p><h5 id=15-哈希表>1.5 哈希表<a hidden class=anchor aria-hidden=true href=#15-哈希表>#</a></h5><p>只能从头开始查询。这个操作便叫作 <strong>线性查找</strong></p><p>在哈希表中，我们可以利用哈希函数快速访问到数组中的目标数据。如果发生哈希冲突，就使用链表进行存储。</p><p>如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。因此，给数组设定合适的空间非常重要。</p><h5 id=16-堆>1.6 堆<a hidden class=anchor aria-hidden=true href=#16-堆>#</a></h5><p>堆是一种图的树形结构，被用于实现“优先队列”（priority queues）。</p><p>优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。
在堆的树形结构中，各个顶点被称为“结点”（node），数据就存储在这些结点中。</p><p>堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为 O(1)。</p><p>假设数据量为n，根据堆的形状可知树的高度为 log2n ，那重构树的时间复杂度为O(logn)。</p><p>添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度成正比，也是 O(logn)。</p><h5 id=17-二叉查找树>1.7 二叉查找树<a hidden class=anchor aria-hidden=true href=#17-二叉查找树>#</a></h5><p>二叉查找树（又叫作二叉搜索树或二叉排序树）是一种数据结构，采用了图的树形结构。数据存储于二叉查找树的各个结点中。</p><p>每个节点最多有两个子节点</p><p>两个性质：</p><ul><li>第一个是每个结点的值均大于其左子树上任意一个结点的值。</li><li>第二个是每个结点的值均小于其右子树上任意一个结点的值。
所以二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。
反之，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。</li></ul><p>比较的次数取决于树的高度。所以如果结点数为 n，而且树的形状又较为均衡的话，比较大小和移动的次数最多就是 log2n。因此，时间复杂度为 O(logn)。
但如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了 O(n)。</p><h4 id=二排序>二、排序<a hidden class=anchor aria-hidden=true href=#二排序>#</a></h4><h5 id=21-冒泡排序>2.1 冒泡排序<a hidden class=anchor aria-hidden=true href=#21-冒泡排序>#</a></h5><p>第 1 轮需要比较 n -1 次，第 2 轮需要比较 n -2 次……第 n -1 轮需
要比较 1 次。因此，总的比较次数为 (n-1) +(n-2) +…+1 ≈ n2/2。
不过，交换数字的次数和输入数据的排列顺序有关。假设出现某种极端情况，如输
入数据正好以从小到大的顺序排列，那么便不需要任何交换操作；
反过来，输入数据要是以从大到小的顺序排列，那么每次比较数字后便都要进行交换。因此，冒泡排序的时间复杂度为O($n^2$)。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#af3a03>let</span> Arr <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>100</span>, <span style=color:#8f3f71>49</span>, <span style=color:#8f3f71>22</span>, <span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>4</span>, <span style=color:#8f3f71>15</span>, <span style=color:#8f3f71>59</span>, <span style=color:#8f3f71>28</span>, <span style=color:#8f3f71>29</span>, <span style=color:#8f3f71>10</span>,]  
</span></span><span style=display:flex><span><span style=color:#af3a03>for</span> (<span style=color:#af3a03>let</span> i <span style=color:#af3a03>=</span> <span style=color:#8f3f71>0</span>; i <span style=color:#af3a03>&lt;</span> Arr.length; i<span style=color:#af3a03>++</span>) {  
</span></span><span style=display:flex><span>    <span style=color:#af3a03>for</span> (<span style=color:#af3a03>let</span> j <span style=color:#af3a03>=</span> Arr.length; j <span style=color:#af3a03>&gt;</span> i; j<span style=color:#af3a03>--</span>) {  
</span></span><span style=display:flex><span>        <span style=color:#af3a03>if</span> (Arr[j] <span style=color:#af3a03>&lt;</span> Arr[j<span style=color:#af3a03>-</span><span style=color:#8f3f71>1</span>]) {  
</span></span><span style=display:flex><span>            <span style=color:#af3a03>let</span> temp <span style=color:#af3a03>=</span> Arr[j<span style=color:#af3a03>-</span><span style=color:#8f3f71>1</span>]  
</span></span><span style=display:flex><span>            Arr[j<span style=color:#af3a03>-</span><span style=color:#8f3f71>1</span>] <span style=color:#af3a03>=</span> Arr[j]  
</span></span><span style=display:flex><span>            Arr[j] <span style=color:#af3a03>=</span> temp  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=22--选择排序>2.2 选择排序<a hidden class=anchor aria-hidden=true href=#22--选择排序>#</a></h5><p>选择排序就是重复<strong>从待排序的数据中寻找最小值，将其与序列最左边的数字进行交换</strong>
这一操作的算法。在序列中寻找最小值时使用的是线性查找。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#af3a03>for</span> (<span style=color:#af3a03>let</span> i <span style=color:#af3a03>=</span> <span style=color:#8f3f71>0</span>; i <span style=color:#af3a03>&lt;</span> Arr.length; i<span style=color:#af3a03>++</span>) {  
</span></span><span style=display:flex><span>    <span style=color:#af3a03>let</span> startIndex<span style=color:#af3a03>=</span>i,startValue <span style=color:#af3a03>=</span> Arr[i],min <span style=color:#af3a03>=</span> Arr[i], minIndex <span style=color:#af3a03>=</span> i;  
</span></span><span style=display:flex><span>    <span style=color:#af3a03>for</span> (<span style=color:#af3a03>let</span> j <span style=color:#af3a03>=</span> i; j <span style=color:#af3a03>&lt;</span> Arr.length; j<span style=color:#af3a03>++</span>) {  
</span></span><span style=display:flex><span>        <span style=color:#af3a03>if</span> (Arr[j] <span style=color:#af3a03>&lt;</span> min) {  
</span></span><span style=display:flex><span>            min <span style=color:#af3a03>=</span> Arr[j]  
</span></span><span style=display:flex><span>            minIndex <span style=color:#af3a03>=</span> j  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span>(startIndex <span style=color:#af3a03>!==</span> minIndex ){  
</span></span><span style=display:flex><span>        Arr[startIndex] <span style=color:#af3a03>=</span> Arr[minIndex]  
</span></span><span style=display:flex><span>        Arr[minIndex] <span style=color:#af3a03>=</span> startValue  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>选择排序使用了线性查找来寻找最小值，因此在第 1 轮中需要比较 n -1 个数字，第
2 轮需要比较 n -2 个数字……到第 n -1 轮的时候就只需比较 1 个数字了。因此，总的比
较次数与冒泡排序的相同，都是 (n-1)+(n-2)+…+1 ≈ n2/2 次。
每轮中交换数字的次数最多为 1 次。如果输入数据就是按从小到大的顺序排列的，
便不需要进行任何交换。选择排序的时间复杂度也和冒泡排序的一样，都为 O($n^2$)。</p><h5 id=23--插入排序>2.3 插入排序<a hidden class=anchor aria-hidden=true href=#23--插入排序>#</a></h5><p>插入排序是一种<strong>从序列左端开始依次对数据进行排序</strong>的算法。在排序过程中，左侧的数据陆续归位，而右侧留下的就是还未被排序的数据。插入排序的思路就是从右侧的未排序区域内取出一个数据，然后将它插入到已排序区域内合适的位置上。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-javascript data-lang=javascript><span style=display:flex><span><span style=color:#af3a03>let</span> tempArr <span style=color:#af3a03>=</span> []  
</span></span><span style=display:flex><span><span style=color:#af3a03>for</span> (<span style=color:#af3a03>let</span> i <span style=color:#af3a03>=</span> <span style=color:#8f3f71>0</span>; i <span style=color:#af3a03>&lt;</span> Arr.length; i<span style=color:#af3a03>++</span>) {  
</span></span><span style=display:flex><span>    tempArr.push(Arr[i])  
</span></span><span style=display:flex><span>    <span style=color:#af3a03>for</span> (<span style=color:#af3a03>let</span> j <span style=color:#af3a03>=</span> tempArr.length <span style=color:#af3a03>-</span> <span style=color:#8f3f71>1</span>; j <span style=color:#af3a03>&gt;</span><span style=color:#8f3f71>0</span> ; j<span style=color:#af3a03>--</span>) {  
</span></span><span style=display:flex><span>        <span style=color:#af3a03>if</span> (tempArr[j] <span style=color:#af3a03>&lt;</span> tempArr[j <span style=color:#af3a03>-</span> <span style=color:#8f3f71>1</span>]) {  
</span></span><span style=display:flex><span>            <span style=color:#af3a03>let</span> temp <span style=color:#af3a03>=</span> tempArr[j <span style=color:#af3a03>-</span> <span style=color:#8f3f71>1</span>]  
</span></span><span style=display:flex><span>            tempArr[j <span style=color:#af3a03>-</span> <span style=color:#8f3f71>1</span>] <span style=color:#af3a03>=</span> tempArr[j]  
</span></span><span style=display:flex><span>            tempArr[j] <span style=color:#af3a03>=</span> temp  
</span></span><span style=display:flex><span>        }  
</span></span><span style=display:flex><span>    }  
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>具体来说，就是第 k 轮需要比较 k -1 次。因此，在最糟糕的情况下，第 2 轮需要操作 1 次，第 3 轮操作 2 次……第 n 轮操作 n -1次，所以时间复杂度和冒泡排序的一样，都为 O($n^2$)。</p><h5 id=24--堆排序>2.4 堆排序<a hidden class=anchor aria-hidden=true href=#24--堆排序>#</a></h5><p>堆排序的特点是利用了数据结构中的堆</p><p>堆排序一开始需要将 n 个数据存进堆里，所需时间为 O(nlogn)。
排序过程中，堆从空堆的状态开始，逐渐被数据填满。由于堆的高度小于 log2n，所以插入 1 个数据所需要的时间为 O(logn)。
每轮取出最大的数据并重构堆所需要的时间为 O(logn)。由于总共有 n 轮，所以重构后排序的时间也是 O(nlogn)。
因此，整体来看堆排序的时间复杂度为 O(nlogn)。
这样来看，堆排序的运行时间比之前讲到的冒泡排序、选择排序、插入排序的时间O($n^2$) 都要短，但由于要使用堆这个相对复杂的数据结构，所以实现起来也较为困难。</p><h5 id=25--归并排序>2.5 归并排序<a hidden class=anchor aria-hidden=true href=#25--归并排序>#</a></h5><p>论哪一行都是 n 个数据，所以每行的运行时间都为 O(n)。
而将长度为 n 的序列对半分割直到只有一个数据为止时，可以分成 log2n 行，因此，总
共有 log2n 行。也就是说，总的运行时间为 O(nlogn)，这与前面讲到的堆排序相同。</p><h5 id=26--快速排序>2.6 快速排序<a hidden class=anchor aria-hidden=true href=#26--快速排序>#</a></h5><p>快速排序算法首先会在序列中随机选择一个基准值（pivot），然后将除了基准值以外的数分
为“比基准值小的数”和“比基准值大的数”这两个类别，再将其排列成以下形式。
[ 比基准值小的数 ] 基准值 [ 比基准值大的数 ]
接着，对两个“[ ]”中的数据进行排序之后，整体的排序便完成了。对“[ ]”里面的数据进行排序时同样也会使用快速排序</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/%E7%AE%97%E6%B3%95/>算法</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/tech/linux/20230809-linux-%E6%96%B0%E6%89%8B%E5%BF%85%E5%A4%87%E5%91%BD%E4%BB%A4/><span class=title>« Prev</span><br><span>Linux 新手必备命令</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>