<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>你不知道的JavaScript-上 | Bablvsj's Blog</title><meta name=keywords content="JavaScript"><meta name=description content="作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（T"><meta name=author content="Lvsj"><link rel=canonical href=https://bablvsj.github.io/posts/tech/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-%E4%B8%8A/><link crossorigin=anonymous href=/assets/css/stylesheet.26af23b8b1c472aadb220beab8420315b9b18975751422bfb4256bd5bcdce878.css integrity="sha256-Jq8juLHEcqrbIgvquEIDFbmxiXV1FCK/tCVr1bzc6Hg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="你不知道的JavaScript-上"><meta property="og:description" content="作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（T"><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/tech/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-%E4%B8%8A/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-09T14:55:19+08:00"><meta property="article:modified_time" content="2023-08-09T14:55:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="你不知道的JavaScript-上"><meta name=twitter:description content="作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（T"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"你不知道的JavaScript-上","item":"https://bablvsj.github.io/posts/tech/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-%E4%B8%8A/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"你不知道的JavaScript-上","name":"你不知道的JavaScript-上","description":"作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。 分词/词法分析（T","keywords":["JavaScript"],"articleBody":"作用域和闭包 第1章 作用域是什么 1.1 编译原理 传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。\n分词/词法分析（Tokenizing/Lexing） 由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元（token）。例如，程序 var a = 2;。这段程序通常会被分解成为这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。\n分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。 解析/语法分析（Parsing） 这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。\n代码生成 将 AST 转换为可执行代码的过程称被称为代码生成。\n比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。\n首先，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。\n对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。\n简单地说，任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。\n1.2 理解作用域 LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。 赋值操作还有其他几种形式，因此在概念上最好将其理解为 赋值操作的目标是谁（LHS） 以及谁是赋值操作的源头（RHS）。\nLHS 赋值操作，如a = 2；对a进行了 LHS查询\nRHS 查找源头，如 console.log(b)，对b进行了RHS查询\n如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。\n赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。\nLHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。\n不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式 地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛 出 ReferenceError 异常（严格模式下）。\n小测及答案 1 2 3 4 5 6 7 8 9 function foo(a) { var b = a; return a + b; } var c = foo( 2 ); 1. 找出所有的 LHS 查询（这里有 3 处！） c = ..;、a = 2（隐式变量分配）、b = .. 2. 找出所有的 RHS 查询（这里有 4 处！） foo(2..、= a;、a ..、.. b 第2章 词法作用域 2.1 词法阶段 词法作用域就是定义在词法阶段的作用域。\n查找\n作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。\n无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\nJavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。\n这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。\n第3章 函数作用域和块作用域 3.2隐藏内部实现 **最小授权或最小暴露原则： 应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。\n这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 //示例代码 function doSomething(a) { b = a + doSomethingElse( a * 2 ); console.log( b * 3 ); } function doSomethingElse(a) { return a - 1; } var b; doSomething( 2 ); // 15 // 优化后 function doSomething(a) { function doSomethingElse(a) { return a - 1; } var b; b = a + doSomethingElse( a * 2 ); console.log( b * 3 ); } doSomething( 2 ); // 15 b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。\n规避冲突\n“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。\n1 2 3 4 5 6 7 8 9 10 function foo() { function bar(a) { i = 3; // 修改 for 循环所属作用域中的 i console.log( a + i ); } for (var i=0; i\u003c10; i++) { bar( i * 2 ); // 糟糕，无限循环了！ } } foo(); 3.3 函数作用域 函数声明\n1 2 3 4 5 6 7 var a = 2; function foo() { var a = 3; console.log( a ); // 3 } foo(); console.log( a ); // 2 函数表达式\n1 2 3 4 5 6 var a = 2; (function foo(){ var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2 函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。 比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。 换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。\n3.3.1 匿名和具名 对于函数表达式你最熟悉的场景可能就是回调参数了，比如：\n1 2 3 setTimeout( function() { console.log(\"I waited 1 second!\"); }, 1000 ); 这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。 匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它有几个缺点需要考虑。\n匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用， 比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑 自身。 匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明 行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：\n1 2 3 setTimeout( function timeoutHandler() { // \u003c-- 快看，我有名字了！ console.log( \"I waited 1 second!\" ); }, 1000 ); 3.3.2 立即执行函数表达式 IIFE\n1 2 3 4 5 6 var a = 2; (function foo() { var a = 3; console.log( a ); // 3 })(); console.log( a ); // 2 比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。\n传递参数\n1 2 3 4 5 6 7 var a = 2; (function IIFE( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 })( window ); console.log( a ); // 2 IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Definition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。\n1 2 3 4 5 6 7 8 var a = 2; (function IIFE( def ) { def( window ); })(function def( global ) { var a = 3; console.log( a ); // 3 console.log( global.a ); // 2 }); 函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值。\n3.4 块作用域 with / try catch / let / cost\n第4章 提升 任何声明在某个作用域内的变量，都将附属于这个作用域。\n4.1 先有鸡还是先有蛋 1 2 3 4 5 6 7 8 9 10 11 12 13 14 例1： a = 2; var a; console.log( a ); // 2 形如： var a; a = 2; console.log(a) 例2： console.log( a ); // undefined var a = 2; 形如： var a; console.log(a) a = 2; 提升：变量和函数声明从它们在代码中出现的位置被“移动”到了最上面的过程。 就是先有声明后有赋值。\n4.3 函数优先 函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。\n1 2 3 4 5 6 7 8 foo(); // 1 var foo; function foo() { console.log( 1 ); } foo = function() { console.log( 2 ); }; var foo 尽管出现在 function foo()… 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。\n尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的\n1 2 3 4 5 6 7 8 9 10 foo(); // 3 function foo() { console.log( 1 ); } var foo = function() { console.log( 2 ); }; function foo() { console.log( 3 ); } 第5章 作用域闭包 JavaScript中闭包无处不在，你只需要能够识别并拥抱它。\n5.1 实质问题 1 2 3 4 5 6 7 8 9 function foo() { var a = 2; function bar() { console.log( a ); } return bar; } var baz = foo(); baz(); // 2 —— 朋友，这就是闭包的效果。 函数 bar() 的词法作用域能够访问 foo() 的内部作用域。\n而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n1 2 3 4 5 6 7 8 9 10 function foo() { var a = 2; function baz() { console.log( a ); // 2 } bar( baz ); } function bar(fn) { fn(); // 妈妈快看呀，这就是闭包！ } 1 2 3 4 5 6 7 8 9 10 11 12 13 var fn; function foo() { var a = 2; function baz() { console.log( a ); } fn = baz; // 将 baz 分配给全局变量 } function bar() { fn(); // 妈妈快看呀，这就是闭包！ } foo(); bar(); // 2 5.3 现在我懂了 深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。 这就是闭包。\n通常认为 IIFE 是典型的闭包例子，但根据先前对闭包的定义，我并不是很同意这个观点。\n1 2 3 4 var a = 2; (function IIFE() { console.log( a ); })(); 虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有 a）。a 是通过普通的词法作用域查找而非闭包被发现的。\n5.4 循环和闭包 当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。\n1 2 3 4 5 6 for (var i=1; i\u003c=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 ); } // 6 6 6 6 6 代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？ 缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，**实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。\nIIFE 会通过声明并立即执行一个函数来创建作用域。我们来试一下：\n1 2 3 4 5 6 7 8 for (var i=1; i\u003c=5; i++) { (function (){ setTimeout( function timer() { console.log( i ); }, i*1000 ); })(); } // 6 6 6 6 6 如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。\n它需要有自己的变量，用来在每个迭代中储存 i 的值：\n1 2 3 4 5 6 7 8 for (var i=1; i\u003c=5; i++) { (function (j){ setTimeout( function timer() { console.log( j ); }, i*1000 ); })(i); } // 1 2 3 4 5 重返块作用域\nlet 声明 ，本质上这是将一个块转换成一个可以被关闭的作用域\nfor 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。\n1 2 3 4 5 6 for (let i=1; i\u003c=5; i++) { setTimeout( function timer() { console.log( i ); }, i*1000 ); } // 1 2 3 4 5 5.5 模块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function CoolModule() { var something = \"cool\"; var another = [1, 2, 3]; function doSomething() { console.log( something ); } function doAnother() { console.log( another.join( \" ! \" ) ); } return { doSomething: doSomething, doAnother: doAnother }; } var foo = CoolModule(); foo.doSomething(); // cool foo.doAnother(); // 1 ! 2 ! 3 这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。\n模块模式需要具备两个必要条件。\n必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。 一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。\n","wordCount":"5259","inLanguage":"en","datePublished":"2023-08-09T14:55:19+08:00","dateModified":"2023-08-09T14:55:19+08:00","author":{"@type":"Person","name":"Lvsj"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/tech/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript-%E4%B8%8A/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>你不知道的JavaScript-上</h1><div class=post-meta><span title='2023-08-09 14:55:19 +0800 +0800'>2023/08/09</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Lvsj<ul class=post-tags-meta><a href=https://bablvsj.github.io/tags/javascript/>JavaScript</a></ul></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e9%97%ad%e5%8c%85 aria-label=作用域和闭包>作用域和闭包</a><ul><li><a href=#%e7%ac%ac1%e7%ab%a0-%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%98%af%e4%bb%80%e4%b9%88 aria-label="第1章 作用域是什么">第1章 作用域是什么</a><ul><li><a href=#11-%e7%bc%96%e8%af%91%e5%8e%9f%e7%90%86 aria-label="1.1 编译原理">1.1 编译原理</a></li><li><a href=#12-%e7%90%86%e8%a7%a3%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label="1.2 理解作用域">1.2 理解作用域</a></li><li><a href=#%e5%b0%8f%e6%b5%8b%e5%8f%8a%e7%ad%94%e6%a1%88 aria-label=小测及答案>小测及答案</a></li></ul></li><li><a href=#%e7%ac%ac2%e7%ab%a0-%e8%af%8d%e6%b3%95%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label="第2章 词法作用域">第2章 词法作用域</a><ul><li><a href=#21-%e8%af%8d%e6%b3%95%e9%98%b6%e6%ae%b5 aria-label="2.1 词法阶段">2.1 词法阶段</a></li></ul></li><li><a href=#%e7%ac%ac3%e7%ab%a0-%e5%87%bd%e6%95%b0%e4%bd%9c%e7%94%a8%e5%9f%9f%e5%92%8c%e5%9d%97%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label="第3章 函数作用域和块作用域">第3章 函数作用域和块作用域</a><ul><li><a href=#32%e9%9a%90%e8%97%8f%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0 aria-label=3.2隐藏内部实现>3.2隐藏内部实现</a></li><li><a href=#33-%e5%87%bd%e6%95%b0%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label="3.3 函数作用域">3.3 函数作用域</a></li><li><a href=#34-%e5%9d%97%e4%bd%9c%e7%94%a8%e5%9f%9f aria-label="3.4 块作用域">3.4 块作用域</a></li></ul></li><li><a href=#%e7%ac%ac4%e7%ab%a0-%e6%8f%90%e5%8d%87 aria-label="第4章 提升">第4章 提升</a><ul><li><a href=#41-%e5%85%88%e6%9c%89%e9%b8%a1%e8%bf%98%e6%98%af%e5%85%88%e6%9c%89%e8%9b%8b aria-label="4.1 先有鸡还是先有蛋">4.1 先有鸡还是先有蛋</a></li><li><a href=#43-%e5%87%bd%e6%95%b0%e4%bc%98%e5%85%88 aria-label="4.3 函数优先">4.3 函数优先</a></li></ul></li><li><a href=#%e7%ac%ac5%e7%ab%a0-%e4%bd%9c%e7%94%a8%e5%9f%9f%e9%97%ad%e5%8c%85 aria-label="第5章 作用域闭包">第5章 作用域闭包</a><ul><li><a href=#51-%e5%ae%9e%e8%b4%a8%e9%97%ae%e9%a2%98 aria-label="5.1 实质问题">5.1 实质问题</a></li><li><a href=#53-%e7%8e%b0%e5%9c%a8%e6%88%91%e6%87%82%e4%ba%86 aria-label="5.3 现在我懂了">5.3 现在我懂了</a></li><li><a href=#54-%e5%be%aa%e7%8e%af%e5%92%8c%e9%97%ad%e5%8c%85 aria-label="5.4 循环和闭包">5.4 循环和闭包</a></li><li><a href=#55-%e6%a8%a1%e5%9d%97 aria-label="5.5 模块">5.5 模块</a></li></ul></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h3 id=作用域和闭包>作用域和闭包<a hidden class=anchor aria-hidden=true href=#作用域和闭包>#</a></h3><h4 id=第1章-作用域是什么>第1章 作用域是什么<a hidden class=anchor aria-hidden=true href=#第1章-作用域是什么>#</a></h4><h5 id=11-编译原理>1.1 编译原理<a hidden class=anchor aria-hidden=true href=#11-编译原理>#</a></h5><p>传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p><ul><li><p>分词/词法分析（Tokenizing/Lexing）
由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为<strong>词法单元</strong>（token）。例如，程序 var a = 2;。这段程序通常会被分解成为这些词法单元：var、a、=、2 、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</p><pre><code>分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。
</code></pre></li><li><p>解析/语法分析（Parsing）
这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）。</p></li><li><p>代码生成
将 AST 转换为可执行代码的过程称被称为代码生成。</p></li></ul><p>比起那些编译过程只有三个步骤的语言的编译器，<strong>JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。</strong></p><p>首先，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。</p><p>对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法（比如 JIT，可以延迟编译甚至实施重编译）来保证性能最佳。</p><p>简单地说，<strong>任何 JavaScript 代码片段在执行前都要进行编译（通常就在执行前）</strong>。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。</p><h5 id=12-理解作用域>1.2 理解作用域<a hidden class=anchor aria-hidden=true href=#12-理解作用域>#</a></h5><p>LHS 和 RHS 的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。
赋值操作还有其他几种形式，因此在概念上最好将其理解为
<strong>赋值操作的目标是谁（LHS）</strong> 以及<strong>谁是赋值操作的源头（RHS）</strong>。</p><p><strong>LHS</strong>
赋值操作，如a = 2；对a进行了 LHS查询</p><p>RHS
查找源头，如 console.log(b)，对b进行了RHS查询</p><p>如果查找的目的是对变量进行赋值，那么就会使用 LHS 查询；如果目的是获取变量的值，就会使用 RHS 查询。</p><p>赋值操作符会导致 LHS 查询。＝操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。</p><p>LHS 和 RHS 查询都会在当前执行作用域中开始，如果有需要（也就是说它们没有找到所需的标识符），就会向上级作用域继续查找目标标识符，这样每次上升一级作用域（一层楼），最后抵达全局作用域（顶层），无论找到或没找到都将停止。</p><p>不成功的 RHS 引用会导致抛出 ReferenceError 异常。不成功的 LHS 引用会导致自动隐式
地创建一个全局变量（非严格模式下），该变量使用 LHS 引用的目标作为标识符，或者抛
出 ReferenceError 异常（严格模式下）。</p><h5 id=小测及答案>小测及答案<a hidden class=anchor aria-hidden=true href=#小测及答案>#</a></h5><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo(a) {
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> b = a;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>return</span> a + b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> c = foo( <span style=color:#ff0;font-weight:700>2</span> );
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>1.</span> 找出所有的 LHS 查询<span style=color:red>（</span>这里有 <span style=color:#ff0;font-weight:700>3</span> 处<span style=color:red>！）</span>
</span></span><span style=display:flex><span>c = ..;<span style=color:red>、</span>a = <span style=color:#ff0;font-weight:700>2</span><span style=color:red>（</span>隐式变量分配<span style=color:red>）、</span>b = ..
</span></span><span style=display:flex><span><span style=color:#ff0;font-weight:700>2.</span> 找出所有的 RHS 查询<span style=color:red>（</span>这里有 <span style=color:#ff0;font-weight:700>4</span> 处<span style=color:red>！）</span>
</span></span><span style=display:flex><span>foo(<span style=color:#ff0;font-weight:700>2.</span>.<span style=color:red>、</span>= a;<span style=color:red>、</span>a ..<span style=color:red>、</span>.. b
</span></span></code></pre></td></tr></table></div></div><h4 id=第2章-词法作用域>第2章 词法作用域<a hidden class=anchor aria-hidden=true href=#第2章-词法作用域>#</a></h4><h5 id=21-词法阶段>2.1 词法阶段<a hidden class=anchor aria-hidden=true href=#21-词法阶段>#</a></h5><p>词法作用域就是定义在词法阶段的作用域。</p><p><strong>查找</strong></p><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”（内部的标识符“遮蔽”了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p><p>JavaScript 中有两个机制可以“欺骗”词法作用域：eval(..) 和 with。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。</p><p>这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。不要使用它们。</p><h4 id=第3章-函数作用域和块作用域>第3章 函数作用域和块作用域<a hidden class=anchor aria-hidden=true href=#第3章-函数作用域和块作用域>#</a></h4><h5 id=32隐藏内部实现>3.2隐藏内部实现<a hidden class=anchor aria-hidden=true href=#32隐藏内部实现>#</a></h5><p>**最小授权或最小暴露原则：
应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的 API 设计。</p><p>这个原则可以延伸到如何选择作用域来包含变量和函数。如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">18
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">19
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">20
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">21
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#007f7f>//示例代码
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>function</span> doSomething(a) {
</span></span><span style=display:flex><span>	b = a + doSomethingElse( a * <span style=color:#ff0;font-weight:700>2</span> );
</span></span><span style=display:flex><span>	console.log( b * <span style=color:#ff0;font-weight:700>3</span> );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> doSomethingElse(a) {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> a - <span style=color:#ff0;font-weight:700>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> b;
</span></span><span style=display:flex><span>doSomething( <span style=color:#ff0;font-weight:700>2</span> ); <span style=color:#007f7f>// 15
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>
</span></span><span style=display:flex><span><span style=color:#007f7f>// 优化后
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>function</span> doSomething(a) {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>function</span> doSomethingElse(a) {
</span></span><span style=display:flex><span>		<span style=color:#fff;font-weight:700>return</span> a - <span style=color:#ff0;font-weight:700>1</span>;
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> b;
</span></span><span style=display:flex><span>	b = a + doSomethingElse( a * <span style=color:#ff0;font-weight:700>2</span> );
</span></span><span style=display:flex><span>	console.log( b * <span style=color:#ff0;font-weight:700>3</span> );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>doSomething( <span style=color:#ff0;font-weight:700>2</span> ); <span style=color:#007f7f>// 15
</span></span></span></code></pre></td></tr></table></div></div><p>b 和 doSomethingElse(..) 都无法从外部被访问，而只能被 doSomething(..) 所控制。功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现。</p><p><strong>规避冲突</strong></p><p>“隐藏”作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途却不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>function</span> bar(a) {
</span></span><span style=display:flex><span>		i = <span style=color:#ff0;font-weight:700>3</span>; <span style=color:#007f7f>// 修改 for 循环所属作用域中的 i
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>		console.log( a + i );
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>var</span> i=<span style=color:#ff0;font-weight:700>0</span>; i&lt;<span style=color:#ff0;font-weight:700>10</span>; i++) {
</span></span><span style=display:flex><span>		bar( i * <span style=color:#ff0;font-weight:700>2</span> ); <span style=color:#007f7f>// 糟糕，无限循环了！
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>foo();
</span></span></code></pre></td></tr></table></div></div><h5 id=33-函数作用域>3.3 函数作用域<a hidden class=anchor aria-hidden=true href=#33-函数作用域>#</a></h5><p>函数声明</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() { 
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>3</span>;
</span></span><span style=display:flex><span>	console.log( a ); <span style=color:#007f7f>// 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span><span style=display:flex><span>foo(); 
</span></span><span style=display:flex><span>console.log( a ); <span style=color:#007f7f>// 2
</span></span></span></code></pre></td></tr></table></div></div><p>函数表达式</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>(<span style=color:#fff;font-weight:700>function</span> foo(){
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>3</span>;
</span></span><span style=display:flex><span>	console.log( a ); <span style=color:#007f7f>// 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>})(); 
</span></span><span style=display:flex><span>console.log( a ); <span style=color:#007f7f>// 2
</span></span></span></code></pre></td></tr></table></div></div><p>函数声明和函数表达式之间最重要的区别是它们的名称标识符将会绑定在何处。
比较一下前面两个代码片段。第一个片段中 foo 被绑定在所在作用域中，可以直接通过foo() 来调用它。第二个片段中 foo 被绑定在函数表达式自身的函数中而不是所在作用域中。
换句话说，(function foo(){ .. }) 作为函数表达式意味着 foo 只能在 .. 所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</p><p>3.3.1 匿名和具名
对于函数表达式你最熟悉的场景可能就是回调参数了，比如：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>setTimeout( <span style=color:#fff;font-weight:700>function</span>() {
</span></span><span style=display:flex><span>	console.log(<span style=color:#0ff;font-weight:700>&#34;I waited 1 second!&#34;</span>);
</span></span><span style=display:flex><span>}, <span style=color:#ff0;font-weight:700>1000</span> );
</span></span></code></pre></td></tr></table></div></div><p>这叫作匿名函数表达式，因为 function().. 没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在 JavaScript 的语法中这是非法的。
匿名函数表达式书写起来简单快捷，很多库和工具也倾向鼓励使用这种风格的代码。但是它有几个缺点需要考虑。</p><ol><li>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</li><li>如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，
比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑
自身。</li><li>匿名函数省略了对于代码可读性 / 可理解性很重要的函数名。一个描述性的名称可以让代码不言自明</li></ol><p>行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。给函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>setTimeout( <span style=color:#fff;font-weight:700>function</span> timeoutHandler() { <span style=color:#007f7f>// &lt;-- 快看，我有名字了！
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	console.log( <span style=color:#0ff;font-weight:700>&#34;I waited 1 second!&#34;</span> );
</span></span><span style=display:flex><span>}, <span style=color:#ff0;font-weight:700>1000</span> );
</span></span></code></pre></td></tr></table></div></div><p>3.3.2 立即执行函数表达式 IIFE</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>(<span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>3</span>;
</span></span><span style=display:flex><span>	console.log( a ); <span style=color:#007f7f>// 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>})();
</span></span><span style=display:flex><span>console.log( a ); <span style=color:#007f7f>// 2
</span></span></span></code></pre></td></tr></table></div></div><p>比如 (function foo(){ .. })()。第一个 ( ) 将函数变成表达式，第二个 ( ) 执行了这个函数。</p><p>传递参数</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>(<span style=color:#fff;font-weight:700>function</span> IIFE( global ) {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>3</span>;
</span></span><span style=display:flex><span>	console.log( a ); <span style=color:#007f7f>// 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	console.log( global.a ); <span style=color:#007f7f>// 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>})( <span style=color:#fff;font-weight:700>window</span> );
</span></span><span style=display:flex><span>console.log( a ); <span style=color:#007f7f>// 2
</span></span></span></code></pre></td></tr></table></div></div><p>IIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE执行之后当作参数传递进去。这种模式在 UMD（Universal Module Definition）项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>(<span style=color:#fff;font-weight:700>function</span> IIFE( def ) {
</span></span><span style=display:flex><span>	def( <span style=color:#fff;font-weight:700>window</span> );
</span></span><span style=display:flex><span>})(<span style=color:#fff;font-weight:700>function</span> def( global ) {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>3</span>;
</span></span><span style=display:flex><span>	console.log( a ); <span style=color:#007f7f>// 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	console.log( global.a ); <span style=color:#007f7f>// 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>});
</span></span></code></pre></td></tr></table></div></div><p>函数表达式 def 定义在片段的第二部分，然后当作参数（这个参数也叫作 def）被传递进IIFE 函数定义的第一部分中。最后，参数 def（也就是传递进去的函数）被调用，并将window 传入当作 global 参数的值。</p><h5 id=34-块作用域>3.4 块作用域<a hidden class=anchor aria-hidden=true href=#34-块作用域>#</a></h5><p>with / try catch / let / cost</p><h4 id=第4章-提升>第4章 提升<a hidden class=anchor aria-hidden=true href=#第4章-提升>#</a></h4><p><strong>任何声明在某个作用域内的变量，都将附属于这个作用域。</strong></p><h5 id=41-先有鸡还是先有蛋>4.1 先有鸡还是先有蛋<a hidden class=anchor aria-hidden=true href=#41-先有鸡还是先有蛋>#</a></h5><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>例1<span style=color:red>：</span>
</span></span><span style=display:flex><span>	a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a;
</span></span><span style=display:flex><span>	console.log( a );   <span style=color:#007f7f>// 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	形如<span style=color:red>：</span> <span style=color:#fff;font-weight:700>var</span> a;
</span></span><span style=display:flex><span>		   a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>		   console.log(a)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>例2<span style=color:red>：</span>
</span></span><span style=display:flex><span>	console.log( a ); <span style=color:#007f7f>// undefined
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>	形如<span style=color:red>：</span>  <span style=color:#fff;font-weight:700>var</span> a;
</span></span><span style=display:flex><span>			console.log(a)
</span></span><span style=display:flex><span>			a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span></code></pre></td></tr></table></div></div><p><strong>提升</strong>：变量和函数声明从它们在代码中出现的位置被“移动”到了最上面的过程。
就是先有声明后有赋值。</p><h5 id=43-函数优先>4.3 函数优先<a hidden class=anchor aria-hidden=true href=#43-函数优先>#</a></h5><p>函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>foo(); <span style=color:#007f7f>// 1
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>var</span> foo;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>	console.log( <span style=color:#ff0;font-weight:700>1</span> );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>foo = <span style=color:#fff;font-weight:700>function</span>() {
</span></span><span style=display:flex><span>	console.log( <span style=color:#ff0;font-weight:700>2</span> );
</span></span><span style=display:flex><span>};
</span></span></code></pre></td></tr></table></div></div><p>var foo 尽管出现在 function foo()&mldr; 的声明之前，但它是重复的声明（因此被忽略了），因为函数声明会被提升到普通变量之前。</p><p>尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>foo(); <span style=color:#007f7f>// 3
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>	console.log( <span style=color:#ff0;font-weight:700>1</span> );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> foo = <span style=color:#fff;font-weight:700>function</span>() {
</span></span><span style=display:flex><span>	console.log( <span style=color:#ff0;font-weight:700>2</span> );
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>	console.log( <span style=color:#ff0;font-weight:700>3</span> );
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><h4 id=第5章-作用域闭包>第5章 作用域闭包<a hidden class=anchor aria-hidden=true href=#第5章-作用域闭包>#</a></h4><p>JavaScript中闭包无处不在，你只需要能够识别并拥抱它。</p><h5 id=51-实质问题>5.1 实质问题<a hidden class=anchor aria-hidden=true href=#51-实质问题>#</a></h5><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">9
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>function</span> bar() {
</span></span><span style=display:flex><span>		console.log( a );
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> bar;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> baz = foo();
</span></span><span style=display:flex><span>baz(); <span style=color:#007f7f>// 2 —— 朋友，这就是闭包的效果。
</span></span></span></code></pre></td></tr></table></div></div><p>函数 bar() 的词法作用域能够访问 foo() 的内部作用域。</p><p>而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>function</span> baz() {
</span></span><span style=display:flex><span>		console.log( a ); <span style=color:#007f7f>// 2
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>	}
</span></span><span style=display:flex><span>	bar( baz );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> bar(fn) {
</span></span><span style=display:flex><span>	fn(); <span style=color:#007f7f>// 妈妈快看呀，这就是闭包！
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> fn;
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> foo() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>function</span> baz() {
</span></span><span style=display:flex><span>		console.log( a );
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	fn = baz; <span style=color:#007f7f>// 将 baz 分配给全局变量
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> bar() {
</span></span><span style=display:flex><span>	fn(); <span style=color:#007f7f>// 妈妈快看呀，这就是闭包！
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>}
</span></span><span style=display:flex><span>foo();
</span></span><span style=display:flex><span>bar(); <span style=color:#007f7f>// 2
</span></span></span></code></pre></td></tr></table></div></div><h5 id=53-现在我懂了>5.3 现在我懂了<a hidden class=anchor aria-hidden=true href=#53-现在我懂了>#</a></h5><p>深入到引擎的内部原理中，内置的工具函数 setTimeout(..) 持有对一个参数的引用，这个参数也许叫作 fn 或者 func，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 timer 函数，而词法作用域在这个过程中保持完整。
这就是闭包。</p><p>通常认为 IIFE 是典型的闭包例子，但根据先前对闭包的定义，我并不是很同意这个观点。</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> a = <span style=color:#ff0;font-weight:700>2</span>;
</span></span><span style=display:flex><span>(<span style=color:#fff;font-weight:700>function</span> IIFE() {
</span></span><span style=display:flex><span>	console.log( a );
</span></span><span style=display:flex><span>})();
</span></span></code></pre></td></tr></table></div></div><p>虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。它在定义时所在的作用域中执行（而外部作用域，也就是全局作用域也持有 a）。a 是通过普通的词法作用域查找而非闭包被发现的。</p><h5 id=54-循环和闭包>5.4 循环和闭包<a hidden class=anchor aria-hidden=true href=#54-循环和闭包>#</a></h5><p>当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个 6 出来。</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>var</span> i=<span style=color:#ff0;font-weight:700>1</span>; i&lt;=<span style=color:#ff0;font-weight:700>5</span>; i++) {
</span></span><span style=display:flex><span>	setTimeout( <span style=color:#fff;font-weight:700>function</span> timer() {
</span></span><span style=display:flex><span>		console.log( i );
</span></span><span style=display:flex><span>	}, i*<span style=color:#ff0;font-weight:700>1000</span> );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#007f7f>// 6 6 6 6 6
</span></span></span></code></pre></td></tr></table></div></div><p>代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？
缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。但是根据作用域的工作原理，**实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。</p><p>IIFE 会通过声明并立即执行一个函数来创建作用域。我们来试一下：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>var</span> i=<span style=color:#ff0;font-weight:700>1</span>; i&lt;=<span style=color:#ff0;font-weight:700>5</span>; i++) {
</span></span><span style=display:flex><span>	(<span style=color:#fff;font-weight:700>function</span> (){
</span></span><span style=display:flex><span>		setTimeout( <span style=color:#fff;font-weight:700>function</span> timer() {
</span></span><span style=display:flex><span>			console.log( i );
</span></span><span style=display:flex><span>		}, i*<span style=color:#ff0;font-weight:700>1000</span> );
</span></span><span style=display:flex><span>	})();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#007f7f>// 6 6 6 6 6
</span></span></span></code></pre></td></tr></table></div></div><p>如果作用域是空的，那么仅仅将它们进行封闭是不够的。仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。</p><p>它需要有自己的变量，用来在每个迭代中储存 i 的值：</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>var</span> i=<span style=color:#ff0;font-weight:700>1</span>; i&lt;=<span style=color:#ff0;font-weight:700>5</span>; i++) {
</span></span><span style=display:flex><span>	(<span style=color:#fff;font-weight:700>function</span> (j){
</span></span><span style=display:flex><span>		setTimeout( <span style=color:#fff;font-weight:700>function</span> timer() {
</span></span><span style=display:flex><span>			console.log( j );
</span></span><span style=display:flex><span>		}, i*<span style=color:#ff0;font-weight:700>1000</span> );
</span></span><span style=display:flex><span>	})(i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#007f7f>// 1 2 3 4 5
</span></span></span></code></pre></td></tr></table></div></div><p><strong>重返块作用域</strong></p><p>let 声明 ，本质上这是将一个块转换成一个可以被关闭的作用域</p><p>for 循环头部的 let 声明还会有一个特殊的行为。这个行为指出变量在循环过程中不止被声明一次，每次迭代都会声明。随后的每个迭代都会使用上一个迭代结束时的值来初始化这个变量。</p><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">6
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>for</span> (<span style=color:#fff;font-weight:700>let</span> i=<span style=color:#ff0;font-weight:700>1</span>; i&lt;=<span style=color:#ff0;font-weight:700>5</span>; i++) {
</span></span><span style=display:flex><span>	setTimeout( <span style=color:#fff;font-weight:700>function</span> timer() {
</span></span><span style=display:flex><span>		console.log( i );
</span></span><span style=display:flex><span>	}, i*<span style=color:#ff0;font-weight:700>1000</span> );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#007f7f>// 1 2 3 4 5
</span></span></span></code></pre></td></tr></table></div></div><h5 id=55-模块>5.5 模块<a hidden class=anchor aria-hidden=true href=#55-模块>#</a></h5><div class=highlight><div style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 1
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 2
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 3
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 4
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 5
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 6
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 7
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 8
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272"> 9
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">10
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">11
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">12
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">13
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">14
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">15
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">16
</span><span style="white-space:pre;user-select:none;margin-right:.4em;padding:0 .4em;color:#727272">17
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#fff;font-weight:700>function</span> CoolModule() {
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> something = <span style=color:#0ff;font-weight:700>&#34;cool&#34;</span>;
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>var</span> another = [<span style=color:#ff0;font-weight:700>1</span>, <span style=color:#ff0;font-weight:700>2</span>, <span style=color:#ff0;font-weight:700>3</span>];
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>function</span> doSomething() {
</span></span><span style=display:flex><span>		console.log( something );
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>function</span> doAnother() {
</span></span><span style=display:flex><span>		console.log( another.join( <span style=color:#0ff;font-weight:700>&#34; ! &#34;</span> ) );
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#fff;font-weight:700>return</span> {
</span></span><span style=display:flex><span>		doSomething: doSomething,
</span></span><span style=display:flex><span>		doAnother: doAnother
</span></span><span style=display:flex><span>	};
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#fff;font-weight:700>var</span> foo = CoolModule();
</span></span><span style=display:flex><span>foo.doSomething(); <span style=color:#007f7f>// cool
</span></span></span><span style=display:flex><span><span style=color:#007f7f></span>foo.doAnother(); <span style=color:#007f7f>// 1 ! 2 ! 3
</span></span></span></code></pre></td></tr></table></div></div><p>这个模式在 JavaScript 中被称为模块。最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。</p><p>模块模式需要具备两个必要条件。</p><ol><li>必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</li></ol><p>一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/javascript/>JavaScript</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/tech/codelanguage/20230815-typescript/><span class=title>« Prev</span><br><span>TypeScript</span></a>
<a class=next href=https://bablvsj.github.io/posts/exams/c++/><span class=title>Next »</span><br><span>C++</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>