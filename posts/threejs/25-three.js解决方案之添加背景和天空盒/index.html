<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>25 Three.js解决方案之添加背景和天空盒 | Bablvsj&#39;s Blog</title>
<meta name="keywords" content="Three.js">
<meta name="description" content="25 Three.js解决方案之添加背景和天空盒 - Bablvsj&#39;s Blog">
<meta name="author" content="">
<link rel="canonical" href="https://bablvsj.github.io/posts/threejs/25-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5525cc669fcb4f094a55bfc3ebfc5a6e73445e090010c66ab49c2cad14735f57.css" integrity="sha256-VSXMZp/LTwlKVb/D6/xabnNEXgkAEMZqtJwsrRRzX1c=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://bablvsj.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://bablvsj.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://bablvsj.github.io/img/Q.gif">
<link rel="apple-touch-icon" href="https://bablvsj.github.io/Q.gif">
<link rel="mask-icon" href="https://bablvsj.github.io/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="stylesheet" href="/css/syntax.css">


<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="25 Three.js解决方案之添加背景和天空盒" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bablvsj.github.io/posts/threejs/25-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T17:11:35+08:00" />
<meta property="article:modified_time" content="2023-12-19T17:11:35+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="25 Three.js解决方案之添加背景和天空盒"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "文章",
      "item": "https://bablvsj.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "25 Three.js解决方案之添加背景和天空盒",
      "item": "https://bablvsj.github.io/posts/threejs/25-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "25 Three.js解决方案之添加背景和天空盒",
  "name": "25 Three.js解决方案之添加背景和天空盒",
  "description": "",
  "keywords": [
    "Three.js"
  ],
  "articleBody": "在我们之前所有演示的案例中，场景中的背景往往使用默认的黑色，或者是其他纯颜色。\n下面我们讲解一下 Three.Screen 的背景设置方式。\n设置场景背景 场景(Three.Screen)有一个属性 .background。我们可以通过设置这个属性来给场景添加背景。\n.background属性值类型\n场景背景属性值一共有 3 种类型：\n默认为 null\n.background 属性值为 null，场景显示为黑色\n某颜色 Three.Color\nThree.Color 可接受 字符串或数字类型的颜色值，例如:\nnew Three.Color(’#333') new Three.Color(‘green’) new Three.Color(0x333333) 某纹理 Three.Texture\n设置背景色示例代码：\nconst scene = new Three.Scene() scene.background = new Three.Color(0x333333) 设置背景纹理图片示例代码：\nconst scene = new Three.Scene() const textureLoader = new Three.TextureLoader() scene.background = textureLoader.load(require('@/assets/imgs/blue_sky.jpg').default) 或者是\nconst textureLoader = new Three.TextureLoader() textureLoader.load(require('@/assets/imgs/blue_sky.jpg').default, (texture) =\u003e { scene.background = texture }) 上面设置场景纹理背景图，实际运行后你会发现虽然背景图显示了，但是背景图却有可能是变形着的。\n这是由于背景图片本身就一个宽高比，而画布(Canvas)本身也有一个宽高比。\n实际上是渲染器渲染尺寸的宽高，例如每次浏览器窗口尺寸发生变化时，我们都会重新设置 渲染尺寸\nrenderer.setSize(width, height, false) 判断高宽比，不让背景图变形且可以铺满整个背景\n假设我们不能接受背景图变形，那么我们就需要计算一下 2 者的宽高比，然后找出合适的比例进行修改。\n这个不让背景图变形的计算过程是：\n计算出画布宽高比，例如 canvasAspect 计算出背景图宽高比，例如 imgAspect 然后计算 imgAspect/canvasAspect，得到 最终背景图在不变形的前提下的缩放比，例如 const resultAspect = imgAspect / canvasAspect 然后依次设置背景图纹理的偏移(offset.x、offset.y)，以及判断是否需要重复平铺背景图(repeat.x、repeat.y) 示例代码如下：\nconst textureRef = useRef(null) ... const textureLoader = new Three.TextureLoader() textureLoader.load(require('@/assets/imgs/blue_sky.jpg').default, (texture) =\u003e { textureRef.current = texture scene.background = textureRef.current handleResize() //此处是当纹理图片加载完成后，需要调用执行一下 handleResize() }) ... const handleResize = () =\u003e { const canvasAspect = width / height //第1步：计算出画布宽高比 if (textureRef.current !== null) { const bgTexture = textureRef.current const imgAspect = bgTexture.image.width / bgTexture.image.height //第2步：计算出背景图宽高比 const resultAspect = imgAspect / canvasAspect //第3步：计算出最终背景图宽缩放宽高比 //第4步：设置背景图纹理的偏移和重复 bgTexture.offset.x = resultAspect \u003e 1 ? (1 - 1 / resultAspect) / 2 : 0 bgTexture.repeat.x = resultAspect \u003e 1 ? 1 / resultAspect : 1 bgTexture.offset.y = resultAspect \u003e 1 ? 0 : (1 - resultAspect) / 2 bgTexture.repeat.y = resultAspect \u003e 1 ? 1 : resultAspect } } 完整的示例代码如下：\nimport { useRef, useEffect } from \"react\" import * as Three from 'three' import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\" import { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\" import './index.scss' const HelloSkybox = () =\u003e { const canvasRef = useRef(null) const textureRef = useRef(null) useEffect(() =\u003e { if (canvasRef.current === null) { return } const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current }) const scene = new Three.Scene() const textureLoader = new Three.TextureLoader() textureLoader.load(require('@/assets/imgs/blue_sky.jpg').default, (texture) =\u003e { textureRef.current = texture scene.background = textureRef.current handleResize() }) scene.background = textureRef.current const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100) camera.position.set(10, 0, 10) const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1) scene.add(light) const loader = new GLTFLoader() loader.load(require('@/assets/model/hello.glb').default, (gltf) =\u003e { scene.add(gltf.scene) }) const control = new OrbitControls(camera, canvasRef.current) control.update() const render = () =\u003e { renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) const handleResize = () =\u003e { if (canvasRef.current === null) { return } const width = canvasRef.current.clientWidth const height = canvasRef.current.clientHeight const canvasAspect = width / height if (textureRef.current !== null) { const bgTexture = textureRef.current const imgAspect = bgTexture.image.width / bgTexture.image.height const resultAspect = imgAspect / canvasAspect bgTexture.offset.x = resultAspect \u003e 1 ? (1 - 1 / resultAspect) / 2 : 0 bgTexture.repeat.x = resultAspect \u003e 1 ? 1 / resultAspect : 1 bgTexture.offset.y = resultAspect \u003e 1 ? 0 : (1 - resultAspect) / 2 bgTexture.repeat.y = resultAspect \u003e 1 ? 1 : resultAspect } camera.aspect = canvasAspect camera.updateProjectionMatrix() renderer.setSize(width, height, false) } handleResize() window.addEventListener('resize', handleResize) return () =\u003e { window.removeEventListener('resize', handleResize) } }, []) return ( ) } export default HelloSkybox 请注意，上面讲述的是将背景图片加载进 Three.js 中，并当做纹理来使用。我们可以通过修改纹理各种属性来修改和控制背景图。\n上面示例代码中仅仅是对纹理的偏移和重复进行了设置\n但是，假设就仅仅为了达到上述效果，实际上我们根本不用搞这么复杂，直接给网页中 标签设置一个背景图片即可。\n第1步：添加渲染器参数 alpha:true\nconst renderer = new Three.WebGLRenderer({ canvas: canvasRef.current, alpha: true }) **第2步：给画布标签()添加背景图** 第1种添加方式：通过 css 添加\n.full-screen { display: block; width: inherit; height: inherit; background: url(./imgs/blue_sky.jpg) no-repeat center center; background-size: cover; } 请注意：上面 .scss 中我们给背景设置的图片路径，其实指向项目的 public 目录\n第2种添加方式：通过 JS 添加\nconst canvasStyle = { background: `url(${require('@/assets/imgs/blue_sky.jpg').default}) center center no-repeat`, backgroundSize: 'cover' } React 在编译时，会自动将 style={canvasStyle} 中的样式转化为 CSS 样式\n至此，关于如何设置场景背景图片，讲解完毕。\n接下来要讲解一个常见的 Three.js 应用场景：SkyBox(天空盒)。\n天空盒(Skybox) 假设我们身处一个立方体内部，我们可以观察到立方体内部 6 个面的背景贴图。\n这不就是我们身处某个房间内吗？\n这类应用场景，通常被称呼为 Skybox，也就是 天空盒。\n这也是我们日常听到对最多的 Web 3D 应用：VR 看房\n上面对于天空盒的解释正确吗？\n答：正确但不严谨！\n通常我们所说天空盒(Skybox) 一个非常重要的特性就是：像天空一样大的盒子\n进一步解释就是：这个盒子空间像天空一样无边无际，永远不到头。\n说直白点，天空盒就好像我们平时的场景(Three.Scene)，无论缩小到什么限度，还是放大到什么限度，永远走不出场景之外。\n而本文下面所有的示例，其实都是针对场景背景添加纹理贴图，所以下面示例中的天空盒(skybox)空间等同于场景本身。\n天空盒一共有 2 种形式的贴图资源：\n全景图(hdri)，又名 天空图 立方体贴图(cubemap) 第1种实现天空盒的方法：全景图(hdri) 很明显，我们最容易想到的实现方式为：\n我们把整个 Three.Screen 当做立方体，也就是将整个场景当做立方体\n再次重复一遍：我们并不是在场景中创建一个立方体，而是直接将整个场景当做立方体\n假设你要给场景中某个立方体设置类似的效果，那么你要做的事情是：\n创建纹理，使用立方体纹理加载器(Three.CubeTextureLoader)加载图片资源\n创建材质，除了设置材质的纹理之外，还要设置 .side 属性，将值为 Three.BackSide，例如\nnew MeshPhongMaterial({ map:xxxx, side: Three.BackSide }) 最终创建立方体网格(Three.Mesh)\n请注意：绝大多数 VR 看房，都是将场景当做立方体即可。\n按照指定顺序，获取(加载) 6 个面的纹理贴图，得到纹理\n请注意，这次加载我们并不使用 Three.TextureLoader，而是采用立方体专有的纹理加载器 Three.CubeTextureLoader\n将得到的纹理作为场景背景\n设置相机坐标 z 的值，确保我们可以看到物体，例如\ncamera.position.set(0, 0, 10) 然后正常渲染，我们就会感觉此刻身在房间中\n示例代码：\n房间图片素材：\n我们使用网上找到的某房间 6 个面的纹理贴图\nhttps://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-x.jpg https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-x.jpg https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-y.jpg https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-y.jpg https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-z.jpg https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-z.jpg 实际代码：\nconst cubeTextureLoader = new Three.CubeTextureLoader() cubeTextureLoader.load([ 'https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-x.jpg', 'https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-x.jpg', 'https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-y.jpg', 'https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-y.jpg', 'https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-z.jpg', 'https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-z.jpg' ], (texture) =\u003e { scene.background = texture }) 针对贴图资源顺序的补充说明：\n在上面示例代码中，我们可以看到加载立方体 6 面图片贴图资源的顺序是固定的，依次为：\npos-x.jpg、neg-x.jpg、pos-y.jpg、neg-y.jpg、pos-z.jpg、neg-z.jpg\n“pos” 是单词 “positive” 的缩写，在 3D 坐标系中意思是 正\npositive：积极的、正向的、乐观的\n“neg” 是单词 “negative” 的缩写，在 3D 坐标系中意思是 负\nnegative：消极的、负面的\n左手坐标系统 VS 右手坐标系统 我们先介绍一下 右手坐标系统，你就自然明白什么是左手坐标系统了。\n我们看一下百度百科的介绍：\n右手系(right-hand system)是在空间中规定直角坐标系的方法之一。此坐标系中x轴，y轴和z轴的正方向是如下规定的：把右手放在原点的位置，使大拇指，食指和中指互成直角，把大拇指指向x轴的正方向，食指指向y轴的正方向时，中指所指的方向就是z轴的正方向。\n同样的操作你换做左手，那么就是左手坐标系统。\n左手坐标系统和右手坐标系统在 Y 轴、Z 轴 方面没有区别，但是在 X 轴上是彼此相反的。\n对于立方体贴图，使用的是左手系统！\n因此上面图片名称的含义为：\n名称 含义 对应立方体内部的面来说 对于站在立方体内部中间的人来说 pos-x X 轴正方向 左面 视觉左方 neg-x X 轴负方向 右面 视觉右方 pos-y Y 轴正方向 上面 视觉上方 neg-y Y 轴负方向 下面 视觉下方 pos-z Z 轴正方向 后面 视觉后方 neg-z Z 轴负方向 前面 视觉前方 请注意，立方体的前面或后面完全是由观察者所处的位置来决定的。\n如果你在立方体外面去看立方体，那么正面看到的是立方体的正面，看不到的是立方体的背面。\n但是我们现在做的是站在立方体内部去观察立方体，所以此刻 “立方体的正面” 实际上对于我们观察者而言是在我们身后，也就是我们的视觉后方。\n对于Three.js渲染使用的是 右手坐标系统！\n不过你不用担心左右方向相反这个事情，因为在 Three.js 内部在渲染的时候会自动帮我们将左右对调。\n重复一遍：\n一般立方体模型贴图使用左手坐标系统 Three.js 整体使用右手坐标系统 但在渲染立方体内部贴图时，Three.js 会自动帮我们做好左右兑换 因此我们在传递纹理贴图时，贴图顺序使用的是左手坐标系统 糟糕，我也是今天学习到这里才彻底明白坐标系统，我可能在之前的文章中对于 上下左右前后 讲解错了，但是我暂时记不清是哪一章节。\n第2种实现天空盒的方法：立方体贴图(cubemap) 我们第1种实现天空盒，实际上使用的是 6 个面的图片资源组合成了一个 3D 空间。\n接下来我们学习使用一张 360° 球形相机拍摄的照片，来实现 3D 空间立方体。\n首先你从网上找到一张 360° 的场景图片资源：\nhttps://threejsfundamentals.org/threejs/resources/images/equirectangularmaps/tears_of_steel_bridge_2k.jpg\n请注意，这类图片尺寸宽高比例为 2:1，经常称呼这类图片为 “全景图”\n实现思路：\n使用纹理加载器加载该图片资源\n这种 2:1 的图片，被称为 “等矩形图像”\n实例化一个 Three.WebGLCubeRenderTarget，构造函数中的 size 属性为图片资源的高\nWebGLCubeRenderTarget 继承于 WebGLRenderTarget，属于离屏渲染的一种特例(专门针对立方体模型)\n在 WebGLRenderTarget 的源码中可以看到这句代码：super( size, size, options );\nWebGLRenderTarget 构造函数需要传递 width 和 height，但是 WebGLCubeRenderTarget 构造函数只需传入 1 个 size，因为正方体，所以宽高一样。\n调用该实例化对象的 fromEquirectangularTexture() 函数\n将等距图像 转化为 立方体模型贴图\n可以简单理解成：就是将 1 整张图片转化为 6个面的立方体模型贴图，并进行渲染\n将场景背景设置为该实例对象\n这样相当于将场景背景图的值设置为 WebGLCubeRenderTarget 的渲染结果\n具体代码：\nconst textureLoader = new Three.TextureLoader() textureLoader.load(require('@/assets/imgs/tears_of_steel_bridge.jpg').default, (texture) =\u003e { const crt = new Three.WebGLCubeRenderTarget(texture.image.height) crt.fromEquirectangularTexture(renderer,texture) scene.background = crt.texture } ) 补充说明：scene.background 的类型为 WebGLBackground\n请留意上述代码中 scene.background = crt.texture，事实上在以前的一些教程中可以写成 scene.background = crt，WebGLBackground 会在内部进行判断，如果 background 类型为 WebGLRenderTarget，则使用该实例的 .texture 属性值。\n但是在最新版 r127 中已经删除了该判断代码，所以现在必须写成 scene.background = crt.texture。\n就这个问题，我已向官网教程进行了修改提交：https://github.com/gfxfundamentals/threejsfundamentals/pull/205\n补充说明：全景图(hdri) 与 立方体贴图(cubemap) 互转 网上有人提供了 全景图与立方体模型图 之间的转化工具包：\n在线地址：https://matheowis.github.io/HDRI-to-CubeMap/\n项目源码：https://github.com/aunyks/hdri-to-cubemap\n你以为本文结束了？没有！\n我们上面示例都是 天空盒(skybox)，那如果是真的一个立方体呢？\n天空盒 是没有尺寸，空间无限大的，而普通立方体则是有尺寸的。\n下面示例我们将创建一个立方体，然后对立方体内部进行贴图，并渲染和观察立方体盒子内部。\n普通立方体内部贴图和渲染 ",
  "wordCount" : "4214",
  "inLanguage": "en",
  "datePublished": "2023-12-19T17:11:35+08:00",
  "dateModified": "2023-12-19T17:11:35+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://bablvsj.github.io/posts/threejs/25-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Bablvsj's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://bablvsj.github.io/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://bablvsj.github.io" accesskey="h" title="Bablvsj&#39;s Blog (Alt + H)">Bablvsj&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://bablvsj.github.io/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/tags" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/about" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/search" title="🔍 (Alt &#43; /)" accesskey=/>
                    <span>🔍</span>
                </a>
            </li>
        </ul>
    </nav>
</header>


<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      25 Three.js解决方案之添加背景和天空盒
    </h1>
    <div class="post-meta">
      
<div class="post-tags-meta">
    <a href="https://bablvsj.github.io/tags/three.js/">Three.js</a>
</div>

9 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 CST'>2023/12/19</span>


      
    </div>
    
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        
        <div class="inner"><ul>
                <li>
                    <a href="#%e8%ae%be%e7%bd%ae%e5%9c%ba%e6%99%af%e8%83%8c%e6%99%af" aria-label="设置场景背景">设置场景背景</a></li>
                <li>
                    <a href="#%e5%a4%a9%e7%a9%ba%e7%9b%92skybox" aria-label="天空盒(Skybox)">天空盒(Skybox)</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e7%ac%ac1%e7%a7%8d%e5%ae%9e%e7%8e%b0%e5%a4%a9%e7%a9%ba%e7%9b%92%e7%9a%84%e6%96%b9%e6%b3%95%e5%85%a8%e6%99%af%e5%9b%behdri" aria-label="第1种实现天空盒的方法：全景图(hdri)">第1种实现天空盒的方法：全景图(hdri)</a></li></ul>
                    
                <li>
                    <a href="#%e5%b7%a6%e6%89%8b%e5%9d%90%e6%a0%87%e7%b3%bb%e7%bb%9f-vs-%e5%8f%b3%e6%89%8b%e5%9d%90%e6%a0%87%e7%b3%bb%e7%bb%9f" aria-label="左手坐标系统 VS 右手坐标系统">左手坐标系统 VS 右手坐标系统</a><ul>
                        
                <li>
                    <a href="#%e7%ac%ac2%e7%a7%8d%e5%ae%9e%e7%8e%b0%e5%a4%a9%e7%a9%ba%e7%9b%92%e7%9a%84%e6%96%b9%e6%b3%95%e7%ab%8b%e6%96%b9%e4%bd%93%e8%b4%b4%e5%9b%becubemap" aria-label="第2种实现天空盒的方法：立方体贴图(cubemap)">第2种实现天空盒的方法：立方体贴图(cubemap)</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e%e5%85%a8%e6%99%af%e5%9b%behdri-%e4%b8%8e-%e7%ab%8b%e6%96%b9%e4%bd%93%e8%b4%b4%e5%9b%becubemap-%e4%ba%92%e8%bd%ac" aria-label="补充说明：全景图(hdri) 与 立方体贴图(cubemap) 互转">补充说明：全景图(hdri) 与 立方体贴图(cubemap) 互转</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%99%ae%e9%80%9a%e7%ab%8b%e6%96%b9%e4%bd%93%e5%86%85%e9%83%a8%e8%b4%b4%e5%9b%be%e5%92%8c%e6%b8%b2%e6%9f%93" aria-label="普通立方体内部贴图和渲染">普通立方体内部贴图和渲染</a>
                </li>
            </ul>
        </div>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>在我们之前所有演示的案例中，场景中的背景往往使用默认的黑色，或者是其他纯颜色。</p>
<p>下面我们讲解一下 Three.Screen 的背景设置方式。</p>
<br>
<h2 id="设置场景背景">设置场景背景<a hidden class="anchor" aria-hidden="true" href="#设置场景背景">#</a></h2>
<p>场景(Three.Screen)有一个属性 .background。我们可以通过设置这个属性来给场景添加背景。</p>
<br>
<p><strong>.background属性值类型</strong></p>
<p>场景背景属性值一共有 3 种类型：</p>
<ol>
<li>
<p>默认为 null</p>
<blockquote>
<p>.background 属性值为 null，场景显示为黑色</p>
</blockquote>
</li>
<li>
<p>某颜色 Three.Color</p>
<blockquote>
<p>Three.Color 可接受 字符串或数字类型的颜色值，例如:</p>
<ol>
<li>new Three.Color(&rsquo;#333')</li>
<li>new Three.Color(&lsquo;green&rsquo;)</li>
<li>new Three.Color(0x333333)</li>
</ol>
</blockquote>
</li>
<li>
<p>某纹理 Three.Texture</p>
</li>
</ol>
<br>
<p><strong>设置背景色示例代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const scene = new Three.Scene()
</span></span><span style="display:flex;"><span>scene.background = new Three.Color(0x333333)
</span></span></code></pre></div><br>
<p><strong>设置背景纹理图片示例代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const scene = new Three.Scene()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const textureLoader = new Three.TextureLoader()
</span></span><span style="display:flex;"><span>scene.background = textureLoader.load(require(&#39;@/assets/imgs/blue_sky.jpg&#39;).default)
</span></span></code></pre></div><p>或者是</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const textureLoader = new Three.TextureLoader()
</span></span><span style="display:flex;"><span>textureLoader.load(require(&#39;@/assets/imgs/blue_sky.jpg&#39;).default, (texture) =&gt; {
</span></span><span style="display:flex;"><span>    scene.background = texture
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><br>
<p>上面设置场景纹理背景图，实际运行后你会发现虽然背景图显示了，但是背景图却有可能是变形着的。</p>
<p>这是由于背景图片本身就一个宽高比，而画布(Canvas)本身也有一个宽高比。</p>
<blockquote>
<p>实际上是渲染器渲染尺寸的宽高，例如每次浏览器窗口尺寸发生变化时，我们都会重新设置 渲染尺寸</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>renderer.setSize(width, height, false)
</span></span></code></pre></div></blockquote>
<br>
<p><strong>判断高宽比，不让背景图变形且可以铺满整个背景</strong></p>
<p>假设我们不能接受背景图变形，那么我们就需要计算一下 2 者的宽高比，然后找出合适的比例进行修改。</p>
<p>这个不让背景图变形的计算过程是：</p>
<ol>
<li>计算出画布宽高比，例如 canvasAspect</li>
<li>计算出背景图宽高比，例如 imgAspect</li>
<li>然后计算 imgAspect/canvasAspect，得到 最终背景图在不变形的前提下的缩放比，例如 const resultAspect = imgAspect / canvasAspect</li>
<li>然后依次设置背景图纹理的偏移(offset.x、offset.y)，以及判断是否需要重复平铺背景图(repeat.x、repeat.y)</li>
</ol>
<br>
<p><strong>示例代码如下：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const textureRef = useRef&lt;Three.Texture | null&gt;(null)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const textureLoader = new Three.TextureLoader()
</span></span><span style="display:flex;"><span>textureLoader.load(require(&#39;@/assets/imgs/blue_sky.jpg&#39;).default, (texture) =&gt; {
</span></span><span style="display:flex;"><span>    textureRef.current = texture
</span></span><span style="display:flex;"><span>    scene.background = textureRef.current
</span></span><span style="display:flex;"><span>    handleResize() //此处是当纹理图片加载完成后，需要调用执行一下 handleResize()
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const handleResize = () =&gt; {
</span></span><span style="display:flex;"><span>    const canvasAspect = width / height  //第1步：计算出画布宽高比
</span></span><span style="display:flex;"><span>    if (textureRef.current !== null) {
</span></span><span style="display:flex;"><span>        const bgTexture = textureRef.current
</span></span><span style="display:flex;"><span>        const imgAspect = bgTexture.image.width / bgTexture.image.height  //第2步：计算出背景图宽高比
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const resultAspect = imgAspect / canvasAspect  //第3步：计算出最终背景图宽缩放宽高比
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        //第4步：设置背景图纹理的偏移和重复
</span></span><span style="display:flex;"><span>        bgTexture.offset.x = resultAspect &gt; 1 ? (1 - 1 / resultAspect) / 2 : 0
</span></span><span style="display:flex;"><span>        bgTexture.repeat.x = resultAspect &gt; 1 ? 1 / resultAspect : 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        bgTexture.offset.y = resultAspect &gt; 1 ? 0 : (1 - resultAspect) / 2
</span></span><span style="display:flex;"><span>        bgTexture.repeat.y = resultAspect &gt; 1 ? 1 : resultAspect
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><br>
<p><strong>完整的示例代码如下：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>import { useRef, useEffect } from &#34;react&#34;
</span></span><span style="display:flex;"><span>import * as Three from &#39;three&#39;
</span></span><span style="display:flex;"><span>import { OrbitControls } from &#34;three/examples/jsm/controls/OrbitControls&#34;
</span></span><span style="display:flex;"><span>import { GLTFLoader } from &#34;three/examples/jsm/loaders/GLTFLoader&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import &#39;./index.scss&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const HelloSkybox = () =&gt; {
</span></span><span style="display:flex;"><span>    const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)
</span></span><span style="display:flex;"><span>    const textureRef = useRef&lt;Three.Texture | null&gt;(null)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const scene = new Three.Scene()
</span></span><span style="display:flex;"><span>        const textureLoader = new Three.TextureLoader()
</span></span><span style="display:flex;"><span>        textureLoader.load(require(&#39;@/assets/imgs/blue_sky.jpg&#39;).default, (texture) =&gt; {
</span></span><span style="display:flex;"><span>            textureRef.current = texture
</span></span><span style="display:flex;"><span>            scene.background = textureRef.current
</span></span><span style="display:flex;"><span>            handleResize()
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        scene.background = textureRef.current
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
</span></span><span style="display:flex;"><span>        camera.position.set(10, 0, 10)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1)
</span></span><span style="display:flex;"><span>        scene.add(light)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const loader = new GLTFLoader()
</span></span><span style="display:flex;"><span>        loader.load(require(&#39;@/assets/model/hello.glb&#39;).default, (gltf) =&gt; {
</span></span><span style="display:flex;"><span>            scene.add(gltf.scene)
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const control = new OrbitControls(camera, canvasRef.current)
</span></span><span style="display:flex;"><span>        control.update()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const render = () =&gt; {
</span></span><span style="display:flex;"><span>            renderer.render(scene, camera)
</span></span><span style="display:flex;"><span>            window.requestAnimationFrame(render)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        window.requestAnimationFrame(render)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const handleResize = () =&gt; {
</span></span><span style="display:flex;"><span>            if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            const width = canvasRef.current.clientWidth
</span></span><span style="display:flex;"><span>            const height = canvasRef.current.clientHeight
</span></span><span style="display:flex;"><span>            const canvasAspect = width / height
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            if (textureRef.current !== null) {
</span></span><span style="display:flex;"><span>                const bgTexture = textureRef.current
</span></span><span style="display:flex;"><span>                const imgAspect = bgTexture.image.width / bgTexture.image.height
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                const resultAspect = imgAspect / canvasAspect
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                bgTexture.offset.x = resultAspect &gt; 1 ? (1 - 1 / resultAspect) / 2 : 0
</span></span><span style="display:flex;"><span>                bgTexture.repeat.x = resultAspect &gt; 1 ? 1 / resultAspect : 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                bgTexture.offset.y = resultAspect &gt; 1 ? 0 : (1 - resultAspect) / 2
</span></span><span style="display:flex;"><span>                bgTexture.repeat.y = resultAspect &gt; 1 ? 1 : resultAspect
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            camera.aspect = canvasAspect
</span></span><span style="display:flex;"><span>            camera.updateProjectionMatrix()
</span></span><span style="display:flex;"><span>            renderer.setSize(width, height, false)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        handleResize()
</span></span><span style="display:flex;"><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return () =&gt; {
</span></span><span style="display:flex;"><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }, [])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return (
</span></span><span style="display:flex;"><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export default HelloSkybox
</span></span></code></pre></div><br>
<p>请注意，上面讲述的是将背景图片加载进 Three.js 中，并当做纹理来使用。我们可以通过修改纹理各种属性来修改和控制背景图。</p>
<blockquote>
<p>上面示例代码中仅仅是对纹理的偏移和重复进行了设置</p>
</blockquote>
<p>但是，假设就仅仅为了达到上述效果，实际上我们根本不用搞这么复杂，直接给网页中 &lt;canvas&gt; 标签设置一个背景图片即可。</p>
<br>
<p><strong>第1步：添加渲染器参数 alpha:true</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current, alpha: true })
</span></span></code></pre></div><br>
**第2步：给画布标签(<canvas\>)添加背景图**
<p>第1种添加方式：通过 css 添加</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>.full-screen {
</span></span><span style="display:flex;"><span>    display: block;
</span></span><span style="display:flex;"><span>    width: inherit;
</span></span><span style="display:flex;"><span>    height: inherit;
</span></span><span style="display:flex;"><span>    background: url(./imgs/blue_sky.jpg) no-repeat center center;
</span></span><span style="display:flex;"><span>    background-size: cover;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>请注意：上面 .scss 中我们给背景设置的图片路径，其实指向项目的 public 目录</p>
</blockquote>
<br>
<p>第2种添加方式：通过 JS 添加</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const canvasStyle = {
</span></span><span style="display:flex;"><span>    background: `url(${require(&#39;@/assets/imgs/blue_sky.jpg&#39;).default}) center center no-repeat`,
</span></span><span style="display:flex;"><span>    backgroundSize: &#39;cover&#39;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>&lt;canvas ref={canvasRef} className=&#39;full-screen&#39; style={canvasStyle} /&gt;
</span></span></code></pre></div><blockquote>
<p>React 在编译时，会自动将 <code>style={canvasStyle}</code> 中的样式转化为 CSS  样式</p>
</blockquote>
<br>
<p>至此，关于如何设置场景背景图片，讲解完毕。</p>
<p>接下来要讲解一个常见的 Three.js 应用场景：SkyBox(天空盒)。</p>
<br>
<h2 id="天空盒skybox">天空盒(Skybox)<a hidden class="anchor" aria-hidden="true" href="#天空盒skybox">#</a></h2>
<p>假设我们身处一个立方体内部，我们可以观察到立方体内部 6 个面的背景贴图。</p>
<blockquote>
<p>这不就是我们身处某个房间内吗？</p>
</blockquote>
<p>这类应用场景，通常被称呼为 Skybox，也就是 天空盒。</p>
<p>这也是我们日常听到对最多的  Web 3D 应用：VR 看房</p>
<br>
<p>上面对于天空盒的解释正确吗？</p>
<p>答：正确但不严谨！</p>
<br>
<p>通常我们所说天空盒(Skybox) 一个非常重要的特性就是：像天空一样大的盒子</p>
<p>进一步解释就是：这个盒子空间像天空一样无边无际，永远不到头。</p>
<blockquote>
<p>说直白点，天空盒就好像我们平时的场景(Three.Scene)，无论缩小到什么限度，还是放大到什么限度，永远走不出场景之外。</p>
</blockquote>
<p>而本文下面所有的示例，其实都是针对场景背景添加纹理贴图，所以下面示例中的天空盒(skybox)空间等同于场景本身。</p>
<br>
<p><strong>天空盒一共有 2 种形式的贴图资源：</strong></p>
<ol>
<li>全景图(hdri)，又名 天空图</li>
<li>立方体贴图(cubemap)</li>
</ol>
<br>
<h4 id="第1种实现天空盒的方法全景图hdri">第1种实现天空盒的方法：全景图(hdri)<a hidden class="anchor" aria-hidden="true" href="#第1种实现天空盒的方法全景图hdri">#</a></h4>
<p>很明显，我们最容易想到的实现方式为：</p>
<ol>
<li>
<p>我们把整个 Three.Screen 当做立方体，也就是将整个场景当做立方体</p>
<blockquote>
<p>再次重复一遍：我们并不是在场景中创建一个立方体，而是直接将整个场景当做立方体</p>
<p>假设你要给场景中某个立方体设置类似的效果，那么你要做的事情是：</p>
<ol>
<li>
<p>创建纹理，使用立方体纹理加载器(Three.CubeTextureLoader)加载图片资源</p>
</li>
<li>
<p>创建材质，除了设置材质的纹理之外，还要设置 .side 属性，将值为 Three.BackSide，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>new MeshPhongMaterial({ map:xxxx, side: Three.BackSide })
</span></span></code></pre></div></li>
<li>
<p>最终创建立方体网格(Three.Mesh)</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>请注意：绝大多数 VR 看房，都是将场景当做立方体即可。</p>
</blockquote>
</li>
<li>
<p>按照指定顺序，获取(加载) 6 个面的纹理贴图，得到纹理</p>
<blockquote>
<p>请注意，这次加载我们并不使用 Three.TextureLoader，而是采用立方体专有的纹理加载器 Three.CubeTextureLoader</p>
</blockquote>
</li>
<li>
<p>将得到的纹理作为场景背景</p>
</li>
<li>
<p>设置相机坐标 z 的值，确保我们可以看到物体，例如</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>camera.position.set(0, 0, 10)
</span></span></code></pre></div></li>
<li>
<p>然后正常渲染，我们就会感觉此刻身在房间中</p>
</li>
</ol>
<br>
<p><strong>示例代码：</strong></p>
<p>房间图片素材：</p>
<p>我们使用网上找到的某房间 6 个面的纹理贴图</p>
<ol>
<li><a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-x.jpg">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-x.jpg</a></li>
<li><a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-x.jpg">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-x.jpg</a></li>
<li><a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-y.jpg">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-y.jpg</a></li>
<li><a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-y.jpg">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-y.jpg</a></li>
<li><a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-z.jpg">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-z.jpg</a></li>
<li><a href="https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-z.jpg">https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-z.jpg</a></li>
</ol>
<br>
<p>实际代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const cubeTextureLoader = new Three.CubeTextureLoader()
</span></span><span style="display:flex;"><span>cubeTextureLoader.load([
</span></span><span style="display:flex;"><span>    &#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-x.jpg&#39;,
</span></span><span style="display:flex;"><span>    &#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-x.jpg&#39;,
</span></span><span style="display:flex;"><span>    &#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-y.jpg&#39;,
</span></span><span style="display:flex;"><span>    &#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-y.jpg&#39;,
</span></span><span style="display:flex;"><span>    &#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/pos-z.jpg&#39;,
</span></span><span style="display:flex;"><span>    &#39;https://threejsfundamentals.org/threejs/resources/images/cubemaps/computer-history-museum/neg-z.jpg&#39;
</span></span><span style="display:flex;"><span>], (texture) =&gt; {
</span></span><span style="display:flex;"><span>    scene.background = texture
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><br>
<p><strong>针对贴图资源顺序的补充说明：</strong></p>
<p>在上面示例代码中，我们可以看到加载立方体 6 面图片贴图资源的顺序是固定的，依次为：</p>
<p>pos-x.jpg、neg-x.jpg、pos-y.jpg、neg-y.jpg、pos-z.jpg、neg-z.jpg</p>
<br>
<p><strong>&ldquo;pos&rdquo; 是单词 &ldquo;positive&rdquo; 的缩写，在 3D 坐标系中意思是 正</strong></p>
<blockquote>
<p>positive：积极的、正向的、乐观的</p>
</blockquote>
<p><strong>&ldquo;neg&rdquo; 是单词 &ldquo;negative&rdquo; 的缩写，在 3D 坐标系中意思是 负</strong></p>
<blockquote>
<p>negative：消极的、负面的</p>
</blockquote>
<br>
<h3 id="左手坐标系统-vs-右手坐标系统">左手坐标系统 VS 右手坐标系统<a hidden class="anchor" aria-hidden="true" href="#左手坐标系统-vs-右手坐标系统">#</a></h3>
<p>我们先介绍一下 右手坐标系统，你就自然明白什么是左手坐标系统了。</p>
<p>我们看一下百度百科的介绍：</p>
<p>右手系(right-hand system)是在空间中规定直角坐标系的方法之一。此坐标系中x轴，y轴和z轴的正方向是如下规定的：把右手放在原点的位置，使大拇指，食指和中指互成直角，把大拇指指向x轴的正方向，食指指向y轴的正方向时，中指所指的方向就是z轴的正方向。</p>
<br>
<p>同样的操作你换做左手，那么就是左手坐标系统。</p>
<p><strong>左手坐标系统和右手坐标系统在 Y 轴、Z 轴 方面没有区别，但是在 X 轴上是彼此相反的。</strong></p>
<br>
<p><strong>对于立方体贴图，使用的是左手系统！</strong></p>
<p>因此上面图片名称的含义为：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>对应立方体内部的面来说</th>
<th>对于站在立方体内部中间的人来说</th>
</tr>
</thead>
<tbody>
<tr>
<td>pos-x</td>
<td>X 轴正方向</td>
<td>左面</td>
<td>视觉左方</td>
</tr>
<tr>
<td>neg-x</td>
<td>X 轴负方向</td>
<td>右面</td>
<td>视觉右方</td>
</tr>
<tr>
<td>pos-y</td>
<td>Y 轴正方向</td>
<td>上面</td>
<td>视觉上方</td>
</tr>
<tr>
<td>neg-y</td>
<td>Y 轴负方向</td>
<td>下面</td>
<td>视觉下方</td>
</tr>
<tr>
<td>pos-z</td>
<td>Z 轴正方向</td>
<td>后面</td>
<td>视觉后方</td>
</tr>
<tr>
<td>neg-z</td>
<td>Z 轴负方向</td>
<td>前面</td>
<td>视觉前方</td>
</tr>
</tbody>
</table>
<blockquote>
<p>请注意，立方体的前面或后面完全是由观察者所处的位置来决定的。</p>
<p>如果你在立方体外面去看立方体，那么正面看到的是立方体的正面，看不到的是立方体的背面。</p>
<p>但是我们现在做的是站在立方体内部去观察立方体，所以此刻 “立方体的正面” 实际上对于我们观察者而言是在我们身后，也就是我们的视觉后方。</p>
</blockquote>
<br>
<p><strong>对于Three.js渲染使用的是 右手坐标系统！</strong></p>
<p><strong>不过你不用担心左右方向相反这个事情，因为在 Three.js 内部在渲染的时候会自动帮我们将左右对调。</strong></p>
<blockquote>
<p>重复一遍：</p>
<ol>
<li>一般立方体模型贴图使用左手坐标系统</li>
<li>Three.js 整体使用右手坐标系统</li>
<li>但在渲染立方体内部贴图时，Three.js 会自动帮我们做好左右兑换</li>
<li>因此我们在传递纹理贴图时，贴图顺序使用的是左手坐标系统</li>
</ol>
</blockquote>
<br>
<blockquote>
<p>糟糕，我也是今天学习到这里才彻底明白坐标系统，我可能在之前的文章中对于 上下左右前后 讲解错了，但是我暂时记不清是哪一章节。</p>
</blockquote>
<br>
<h4 id="第2种实现天空盒的方法立方体贴图cubemap">第2种实现天空盒的方法：立方体贴图(cubemap)<a hidden class="anchor" aria-hidden="true" href="#第2种实现天空盒的方法立方体贴图cubemap">#</a></h4>
<p>我们第1种实现天空盒，实际上使用的是 6 个面的图片资源组合成了一个 3D 空间。</p>
<p>接下来我们学习使用一张 360° 球形相机拍摄的照片，来实现 3D 空间立方体。</p>
<br>
<p>首先你从网上找到一张 360° 的场景图片资源：</p>
<p><a href="https://threejsfundamentals.org/threejs/resources/images/equirectangularmaps/tears_of_steel_bridge_2k.jpg">https://threejsfundamentals.org/threejs/resources/images/equirectangularmaps/tears_of_steel_bridge_2k.jpg</a></p>
<blockquote>
<p>请注意，这类图片尺寸宽高比例为 2:1，经常称呼这类图片为 “全景图”</p>
</blockquote>
<br>
<p><strong>实现思路：</strong></p>
<ol>
<li>
<p>使用纹理加载器加载该图片资源</p>
<blockquote>
<p>这种 2:1 的图片，被称为 “等矩形图像”</p>
</blockquote>
</li>
<li>
<p>实例化一个 Three.WebGLCubeRenderTarget，构造函数中的 size 属性为图片资源的高</p>
<blockquote>
<p>WebGLCubeRenderTarget 继承于 WebGLRenderTarget，属于离屏渲染的一种特例(专门针对立方体模型)</p>
</blockquote>
<blockquote>
<p>在 WebGLRenderTarget 的源码中可以看到这句代码：super( size, size, options );</p>
<p>WebGLRenderTarget 构造函数需要传递 width 和 height，但是 WebGLCubeRenderTarget 构造函数只需传入 1 个 size，因为正方体，所以宽高一样。</p>
</blockquote>
</li>
<li>
<p>调用该实例化对象的 fromEquirectangularTexture() 函数</p>
<blockquote>
<p>将等距图像 转化为 立方体模型贴图</p>
<blockquote>
<p>可以简单理解成：就是将 1 整张图片转化为 6个面的立方体模型贴图，并进行渲染</p>
</blockquote>
</blockquote>
</li>
<li>
<p>将场景背景设置为该实例对象</p>
<blockquote>
<p>这样相当于将场景背景图的值设置为 WebGLCubeRenderTarget  的渲染结果</p>
</blockquote>
</li>
</ol>
<br>
<p><strong>具体代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const textureLoader = new Three.TextureLoader()
</span></span><span style="display:flex;"><span>textureLoader.load(require(&#39;@/assets/imgs/tears_of_steel_bridge.jpg&#39;).default,
</span></span><span style="display:flex;"><span>    (texture) =&gt; {
</span></span><span style="display:flex;"><span>        const crt = new Three.WebGLCubeRenderTarget(texture.image.height)
</span></span><span style="display:flex;"><span>        crt.fromEquirectangularTexture(renderer,texture)
</span></span><span style="display:flex;"><span>        scene.background = crt.texture
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><blockquote>
<p>补充说明：scene.background 的类型为 WebGLBackground</p>
<p>请留意上述代码中 <code>scene.background = crt.texture</code>，事实上在以前的一些教程中可以写成 <code>scene.background = crt</code>，WebGLBackground 会在内部进行判断，如果 background 类型为 WebGLRenderTarget，则使用该实例的 .texture 属性值。</p>
<p>但是在最新版 r127 中已经删除了该判断代码，所以现在必须写成 <code>scene.background = crt.texture</code>。</p>
<p>就这个问题，我已向官网教程进行了修改提交：<a href="https://github.com/gfxfundamentals/threejsfundamentals/pull/205">https://github.com/gfxfundamentals/threejsfundamentals/pull/205</a></p>
</blockquote>
<br>
<h3 id="补充说明全景图hdri-与-立方体贴图cubemap-互转">补充说明：全景图(hdri) 与 立方体贴图(cubemap) 互转<a hidden class="anchor" aria-hidden="true" href="#补充说明全景图hdri-与-立方体贴图cubemap-互转">#</a></h3>
<p>网上有人提供了 全景图与立方体模型图 之间的转化工具包：</p>
<p>在线地址：<a href="https://matheowis.github.io/HDRI-to-CubeMap/">https://matheowis.github.io/HDRI-to-CubeMap/</a></p>
<p>项目源码：<a href="https://github.com/aunyks/hdri-to-cubemap">https://github.com/aunyks/hdri-to-cubemap</a></p>
<br>
<p>你以为本文结束了？没有！</p>
<p>我们上面示例都是 天空盒(skybox)，那如果是真的一个立方体呢？</p>
<blockquote>
<p>天空盒 是没有尺寸，空间无限大的，而普通立方体则是有尺寸的。</p>
</blockquote>
<p>下面示例我们将创建一个立方体，然后对立方体内部进行贴图，并渲染和观察立方体盒子内部。</p>
<br>
<h2 id="普通立方体内部贴图和渲染">普通立方体内部贴图和渲染<a hidden class="anchor" aria-hidden="true" href="#普通立方体内部贴图和渲染">#</a></h2>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://bablvsj.github.io/tags/three.js/">Three.js</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://bablvsj.github.io/posts/threejs/24-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/">
    <span class="title">« Prev</span>
    <br>
    <span>24 Three.js解决方案之加载.gltf模型</span>
  </a>
  <a class="next" href="https://bablvsj.github.io/posts/threejs/26-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E9%80%8F%E6%98%8E%E5%BA%A6bug/">
    <span class="title">Next »</span>
    <br>
    <span>26 Three.js解决方案之透明度bug</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://bablvsj.github.io">Bablvsj&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <div class="flex-c-d">
        <a class="flex-d-c" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"
            target="_blank"> <span>本站由</span><img width="60" src="/images/upyun.png">提供CDN加速/云存储服务</a>
    </div>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
