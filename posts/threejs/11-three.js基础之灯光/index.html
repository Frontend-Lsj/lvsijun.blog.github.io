<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>11 Three.js基础之灯光 | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="11 Three.js基础之灯光 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/11-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%81%AF%E5%85%89/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="11 Three.js基础之灯光"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/11-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%81%AF%E5%85%89/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="11 Three.js基础之灯光"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"11 Three.js基础之灯光","item":"https://bablvsj.github.io/posts/threejs/11-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%81%AF%E5%85%89/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"11 Three.js基础之灯光","name":"11 Three.js基础之灯光","description":"","keywords":["Three.js"],"articleBody":"灯光的种类 在场景中添加灯光后，灯光照射在物体上产生明暗、光亮和阴影，从而让物体显得更加立体有光泽。\n在有些文档或教程中，会把 灯光 称呼为 光源，这只是对 light 这个单词的不同翻译而已\n如果我在本系列文章中，有时候使用 “灯光”，有时候使用 “光源”，请勿见怪。\n向场景中添加灯光 这个行为，在传统 3D 软件制作中通常被称为 “打灯”\n若场景中的物体由非反光材质构成，即使场景中没有任何光源，渲染后依然可以看见该物体。\n非反光材质为 MeshBasicMaterial\n若场景中的物体由反光材质构成，假设场景中没有任何光源，渲染出的结果将是一片漆黑，什么物体都看不见。\n反光材质为 MeshPhongMaterial 等\n灯光的种类 在 Three.js 中，有 6 种基础类型的灯光，他们都继承于 Three.Light 。\n灯光类型(都继承于Light) 灯光名称 是否支持阴影 是否作用于全局(无处不在) 是否有照射目标 AmbientLight 环境光、氛围光 否 是 无 DirectionalLight 平行光 是 否 有 HemisphereLight 半球光源、户外光源 否 是 无 PointLight 点光源 是 否 有 RectAreaLight 矩形面光源 否 否 无 SpotLight 聚光灯光源 是 否 有 补充说明1：环境光\n有个别文档或教程中，会把 HemisphereLight 也称呼为 “环境光”。\n事实上 AmbientLight 和 HemisphereLight 的作用都是提供环境光，只是 HemisphereLight 的环境光更加真实，当然渲染所需性能也更多。\n补充说明2：是否支持阴影\n**所有的光照射到物体上后，都会产生阴影。**但 这里说的不是 是否会产生阴影，而是说 “是否支持阴影”。\n一共有 3 种光不支持阴影：AmbientLight、HemisphereLight、RectAreaLight\n其他种类的光，都支持阴影：DirectionalLight、PointLight、SpotLight\n关于 Three.js 中的 阴影 (LightShadown、DirectionalLightShadown、PointLightShadown、SpotLightShadown)，我们会在后面单独开辟一节来讲解。\n关于“阴影”的进一步补充：\n在之前所有的示例中，当场景上有反光物体且有灯光时，物体会产生明暗，但是请注意：\n这个“物体显示出的明暗”并不是真正的“阴影”。\n在 Three.js 中 有真正的阴影对象，这个会在后面的 “Three.js基础之阴影” 一文中有详细说明。\n这个“物体显示出的明暗”并不是完全符合我们日常的“光影明暗”。\n这是因为我们目前所有示例都使用的是“简单光照模型”，也就是说光照射在物体上后并不进行漫反射，所以渲染出的“明暗”并不完全自然合理。\n默认渲染器并不会渲染阴影、默认支持阴影的灯光也不会投射阴影，若想产生真正的阴影，还需开启阴影渲染和投射。\n具体如何开启，也会在后面的 “Three.js基础之阴影” 一文中有详细说明。\n补充说明3：是否作用域全局\n只有环境光(AmbientLight、HemisphereLight)作用于全局，其他光则照耀范围都是有限的。\n补充说明4：什么叫 “是否有照射目标？”\n答：就是这个光除了光源本身之外，还包含一个 target 属性，并且可以通过设置 target.position 的位置。对于有照射目标的灯光，在场景中不光要添加灯光本身，还可以添加 灯光照射目标。\n注意是 “可以添加” 灯光目标，而不是说 “必须也要添加” 灯光目标。\n请注意上面表格中，关于 “是否产生阴影” 和 “是否有照射目标”，这 2 项 是完全相同的，也就是说，只有包含照射目标的光，才会产生阴影。\n在 Three.js 中，有 3 种 光探针 类型的环境光。\n灯光类型 灯光名称 LightProbe 光探针 AmbientLightProbe(继承于LightProbe) 环境光探针 HemisphereLightProbe(继承于LightProbe) 半球光探针 关于 光探针，是另外一套比较复杂的光的算法方式。\n根据我网上搜索到的一些信息，大概可以描述为：\n传统的 环境光(AmbientLight、HemisphereLight) 渲染时需要的计算量比较大，对于渲染静止物体来说还可以，但是渲染 运动类型 的物体时所消耗的性能过高，而 光探针类型的环境光(AmbientLightProbe、HemisphereLightProbe) 则更加适合 运动类型 的物体。\n光的辅助对象 场景中的光本身是不可见的，为了让我们方便观测光源，Three.js 提供了 光的辅助对象：DirectionalLightHelper、HemisphereLightHelper、PointLightHelper、RectAreaLightHelper、SpotLightHelper\n所谓光的辅助对象，就是在渲染后出现的一些白色细线，这些白色细线指示出光源的位置、大小、以及光发射的方向。\n光的辅助对象用法非常简单，3 步骤：\n先创建 光 的实例 将创建好的光实例作为 辅助对象构造函数的参数 场景中添加 辅助对象即可 例如：\n//创建并设置平行光 const directionalLight = new Three.DirectionalLight(0xFFFFFF, 1) directionalLight.position.set(0, 10, 0); directionalLight.target.position.set(-5, 0, 0) //将平行光添加到场景中 scene.add(directionalLight) scene.add(directionalLight.target) //根据平行光实例，创建对应的辅助对象，并将辅助对象添加到场景中 const directionalLightHelper = new Three.DirectionalLightHelper(directionalLight) scene.add(directionalLightHelper) 灯光作用与特点 AmbientLight(环境光、氛围光)：\n通常仅作为基础光线，一般需要与其他灯光配合使用。不能产生阴影、也无需指定坐标位置，仅需设置颜色和强度。\n注意：不支持阴影\nDirectionalLight(平行光)：\n最为经常使用的光源，光纤(光芒)都是平行向着一个方向发射。\n经常使用 DirectionalLight 来模拟太阳光照射到某个物体上的光照效果。\nHemisphereLight(半球光源)：\n相对 ambientLight，hemisphereLight 更加真实的模拟自然光源，提供 天空 和 地面 漫反射光线。\n一共接收 3 个参数：\n第 1 个参数：天空光线颜色 第 2 个参数：地面反射光颜色 第 3 个参数：光的反射强度 注意：不支持阴影\nPointLight(点光源)：\n类似生活中的灯泡，光纤(光芒)没有固定方向，朝着四周散射。\n注意：点光源对应的辅助对象 PointLightHelper 只有一个 菱形的光源形状，并没有 光 的发射线条。\nRectAreaLight(矩形面光源)：\n与 DirectionalLight 模拟太阳光不同，RectAreaLight 光源形状为一个矩形，可以模拟出明亮的窗口或矩形照明光源。\n注意：\n不支持阴影\n只有 MeshStandardMaterial 和 MeshPhysicalMaterial 材料才支持 RectAreaLight 光源\n按照官方文档描述，场景中必须加入 RectAreaLightUniformsLib.init()\n目前我比较疑惑的是，经过试验发现，即使不添加 RectAreaLightUniformsLib.init()，场景依然正常渲染，似乎看不出有任何差别\n特别说明：\nRectAreaLight 对应的 辅助对象 RectAreaLightArea 引入方式和其他 光辅助对象 引入方式不同。\n其他光辅助对象都是内置在 three 中的，使用之前无需引入，可以直接使用，例如：\nconst directionalLightHelper = new Three.DirectionalLightHelper(directionalLight) 但是 RectAreaLightHelper 在使用前需要引入才可以，引入代码：\nimport { RectAreaLightHelper } from 'three/examples/jsm/helpers/RectAreaLightHelper' SpotLight(聚光灯)：\n类似生活中的聚光灯效果。\n关于每个灯光的具体参数详情、属性用法，请参考官方文档：https://threejs.org/docs/index.html#api/zh/lights/Light\n接下来，我们将通过创建一个 HelloLight 的例子，直观的观察不同类型灯光的效果。\n这个示例中，会用到我们上节学习的 纹理 相关知识。\n前期准备：OrbitControls讲解、制作纹理图片 OrbitControls 的简介和用法 本示例中需要用到一个之前从未使用过的类：OrbitControls，先简单介绍一下这个类。\norbit 单词的翻译为：轨道 controls 单词的翻译为：控制权 OrbitControls 是鼠标镜头轨道控件，可以通过鼠标来配置镜头的运动轨道，例如 缩放、平移、旋转。也就是说在不修改场景的前提下，可以通过鼠标来改变镜头，以便查看不同角度下的场景。\n在手机端，不是鼠标，而是手指滑动\nOrbitControls的用法 const controls = new OrbitControls(camera, canvas) //创建一个实例 controls.target.set(0, 5, 0) //controls.target 为镜头的坐标系统 //controls.target.set(0, 5, 0) 的意思是：设置原点 Y 轴的坐标(以高出5米的轨道运行) controls.update() //使控件使用新目标 请注意，在上面代码中，OrbitControls 的构造函数中第 2 个参数为DOM 中的 canvas 节点，实际上当添加过 OrbitControls 之后，鼠标在 canvas 上的 拖拽、鼠标滚轴滚动 等操作都会被捕捉到，并且做出相对应的镜头画面切换。\n说直白点，我们终于可以通过鼠标对 3D 场景进行不同角度，距离的切换操作了。\nOrbitControls的change事件：\n无论是通过 鼠标或键盘 来修改镜头轨道 都会触发 OrbitControls 的 change 事件。\n我们可以通过添加 事件监听 来捕获该事件：\nconst handleChange = () =\u003e { ... } const controls = new OrbitControls(camera, canvasRef.current) controls.addEventListener('change',handleChange) 对于目前的我们来说，是没有必要使用该事件的，在后续的 Three.js 技巧篇 中，我们才会运用到 change 事件。\n除此之外，我们还可以设置 禁止缩放、禁止旋转、禁止右键拖拽、设置可旋转角度范围等等一系列配置，具体的可查阅官方文档：https://threejs.org/docs/#examples/zh/controls/OrbitControls\n特别注意：\nOrbitControls 并不是包含在 three 根目录下，而是位于 three/examples/jsm/controls/OrbitControls 中，因此引入代码为：\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' 提醒：在 OrbitControls.js 中，分别导出有 OrbitControls 和 MapControls，所以引入 OribitControls 是需要加 大括号 { }。\n补充说明：\n严格意义上讲，OrbitControls 并不是 Three.js 核心包含的代码内容，OrbitControls 是将最常见的鼠标与 Three.js 场景交互内容的一个额外封装。\n由于 OrbitControls 实在是过于频繁使用，最终 Three.js 将 OrbitControls 也包含到了 Three.js 代码包中，只不过不在默认的目录中，而是在 Three.js 示例目录中。\n在 Three.js 早期的版本中，代码包中并未包含 OrbitControls，若想使用还需要 yarn 安装 three-orbitcontrols 这个包。只不过当后来 Three.js 包含了 OrbitControls 之后，才再也无需额外安装了。\n补充说明2：\n原本 OrbitControl 除了鼠标拖拽可以改变场景视角，还支持键盘上的 4 个方向键来改变场景视角。\n只不过 React 对于原生 DOM 事件支持度并不高，React 更倾向于给组件添加 onKeydown 属性处理函数。\n本质上 组件的 onKeydown 相当于 React 的合成事件。\nThree.js 的官方示例使用的是原生 html + js，是完全支持原生键盘事件的。所以 官网的示例 使用键盘方向键控制场景没有问题，但是在 React 项目中却不太容易实现。\n在 React 中如果想让 canvas 拥有键盘事件监听，需要做以下 2 处设置：\n在 useEffect 中，当第一次挂载完成，添加 canvasRef.current.fouce()，让 canvas 自动获得焦点 在 中添加 tabindex 属性，属性值为 -1、0、1 都无所谓，例如： 只有满足以上 2 个条件后，canvas 才会监听到键盘事件，但是一旦 canvas 失去焦点，那么就又监听不到了。\n还是继续使用 鼠标拖拽 来修改查看场景视角吧\n补充说明3：\n事实上如果你真的需要监听 鼠标键盘方向键 ，其实最简单的办法就是把 OrbitControls 监听对象修改为 document.body 上。\n- const controls = new OrbitControls(camera, canvasRef.current) + const controls = new OrbitControls(camera, document.body) 纹理图片准备：制作纹理图片 checker.png 本示例中需要用到一个类似 3D 场景地面黑白网格的纹理，因此我们需要提前准备好这个纹理图片。\n在 PhotoShop 中新建一个 宽高都为 2 像素的画布，然后：\n左上角和右下角 的那 1 像素中填充一个较黑的颜色 右上角和左下角 的那 1 像素中填充一个较白的颜色 将图片导出为 checker.png，并保存到 src/assets/imgs/ 目录中 补充说明：\n虽然制作的纹理图片非常小，只有 2像素 * 2像素，但是我们可以通过设置纹理的重复，来实现渲染出比较大的 黑白网格底盘。\n设置纹理 magFilter 的属性值为 Three.NearestFilter 设置纹理 wrapS、wrapT 属性值为 Three.RepeatWrapping 根据 黑白网格的尺寸，计算并设置纹理 repeat 重复次数 以上 3 点刚好都是上一节我们讲解 纹理 时学习到的知识点。\n灯光示例：HelloLight 先回顾一下 Three.js 中 10 个 光 的类型：\n光的原型(Light) + 6种基础光(AmbientLight…) + 光探针原型(LightProbe) + 2种环境光探针(AmbientLightProbe、HemisphereLightProbe) = 1 + 6 + 1 + 2 = 10\n示例目标 使用并体验 Three.js 中除 Light 和 LightProbe 之外的其他 8 种光类型 使用并体验 光的辅助对象( XxxLightHelper) 补充说明：\n环境光 AmbientLight 是没有 辅助对象的、其他光都有辅助对象 矩形光 RectAreaLight 的辅助对象 RectAreaLightHelper 和其他光的辅助对象 引入方式不同 代码拆分与梳理 1、create-scene.ts：创建基础场景 创建 src/components/hello-light/create-scene.ts ，导出一个名为 createScene 的函数，用来专门负责创建基础的场景。\n具体代码梳理：\n该场景中包含 1个黑白网格的地面、1个立方体、1个球体，但是该场景不包含任何光。\ncreateScene 创建基础场景时接收一个参数 type，type 只能为以下 2 个值中的其中 1 种：MESH_PHONE_MATERIAL 或 MESH_STANDARD_MATERIAL\ntype 默认值为 MESH_PHONE_MATERIAL\n进一步解释：\n由于 RectAreaLight 只作用在 MeshStandardMaterial 和 MeshPhysicalMaterial 材料物体上，所以我们才设置 type 这个参数。\n当使用 RectAreaLight 时，我们告知 createScene，使用 MeshStandardMaterial 材质创建 地面、立方体、球体 当使用 其他 光时，我们告知 createScene，使用 MeshPhongMaterial 材质创建 地面、立方体、球体 2、index.tsx：创建渲染器、镜头、以及不同种类的光 具体代码梳理：\n当 canvas DOM 初始化后，创建 渲染器、镜头、镜头交互(OrbitControls) 创建 8 个按钮，每个按钮对应一种光 使用 useState 创建一个变量 type，用来记录当前演示 光的类型 点击不同按钮后，修改 当前光的类型 type 的值，从而引发 react 重新渲染 在新一轮的渲染中，通过判断 type 类型，使用 createScene 创建一个新的场景 和 对应的 光 3、index.scss：设置相关样式 具体样式梳理：\n设置 canvas 对应的样式 设置 8 个按钮对应的样式 具体的代码 create-scene.ts import * as Three from 'three' export enum MaterialType { MESH_PHONE_MATERIAL = 'MESH_PHONE_MATERIAL', MESH_STANDARD_MATERIAL = 'MESH_STANDARD_MATERIAL' } const createScene: (type?: keyof typeof MaterialType) =\u003e Three.Scene = (type = MaterialType.MESH_PHONE_MATERIAL) =\u003e { const scene = new Three.Scene() const planeSize = 40 const loader = new Three.TextureLoader() const texture = loader.load(require('@/assets/imgs/checker.png').default) texture.wrapS = Three.RepeatWrapping texture.wrapT = Three.RepeatWrapping texture.magFilter = Three.NearestFilter texture.repeat.set(planeSize / 2, planeSize / 2) let planeMat: Three.Material let cubeMat: Three.Material let sphereMat: Three.Material switch (type) { case MaterialType.MESH_STANDARD_MATERIAL: planeMat = new Three.MeshStandardMaterial({ map: texture, side: Three.DoubleSide }) cubeMat = new Three.MeshStandardMaterial({ color: '#8AC' }) sphereMat = new Three.MeshStandardMaterial({ color: '#CA8' }) break default: planeMat = new Three.MeshPhongMaterial({ map: texture, side: Three.DoubleSide }) cubeMat = new Three.MeshPhongMaterial({ color: '#8AC' }) sphereMat = new Three.MeshPhongMaterial({ color: '#8AC' }) } const planeGeo = new Three.PlaneBufferGeometry(planeSize, planeSize) const mesh = new Three.Mesh(planeGeo, planeMat) mesh.rotation.x = Math.PI * -0.5 scene.add(mesh) const cubeGeo = new Three.BoxBufferGeometry(4, 4, 4) const cubeMesh = new Three.Mesh(cubeGeo, cubeMat) cubeMesh.position.set(5, 2.5, 0) scene.add(cubeMesh) const sphereGeo = new Three.SphereBufferGeometry(3, 32, 16) const sphereMesh = new Three.Mesh(sphereGeo, sphereMat) sphereMesh.position.set(-4, 5, 0) scene.add(sphereMesh) return scene } export default createScene index.tsx import { useEffect, useRef, useState } from 'react' import * as Three from 'three' import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' //import { RectAreaLightUniformsLib } from 'three/examples/jsm/lights/RectAreaLightUniformsLib' import { RectAreaLightHelper } from 'three/examples/jsm/helpers/RectAreaLightHelper' import createScene, { MaterialType } from './create-scene' import './index.scss' enum LightType { AmbientLight = 'AmbientLight', AmbientLightProbe = 'AmbientLightProbe', DirectionalLight = 'DirectionalLight', HemisphereLight = 'HemisphereLight', HemisphereLightProbe = 'HemisphereLightProbe', PointLight = 'PointLight', RectAreaLight = 'RectAreaLight', SpotLight = 'SpotLight' } const buttonLables = [LightType.AmbientLight, LightType.AmbientLightProbe, LightType.DirectionalLight, LightType.HemisphereLight, LightType.HemisphereLightProbe, LightType.PointLight, LightType.RectAreaLight, LightType.SpotLight] const HelloLight = () =\u003e { const canvasRef = useRef(null) const sceneRef = useRef(null) const [type, setType] = useState(LightType.AmbientLight) useEffect(() =\u003e { if (canvasRef.current === null) { return } const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement }) const camera = new Three.PerspectiveCamera(45, 2, 0.1, 1000) camera.position.set(0, 10, 20) const controls = new OrbitControls(camera, canvasRef.current) controls.target.set(0, 5, 0) controls.update() const scene = createScene() sceneRef.current = scene const render = () =\u003e { if (sceneRef.current) { renderer.render(sceneRef.current, camera) } window.requestAnimationFrame(render) } window.requestAnimationFrame(render) const handleResize = () =\u003e { const canvas = canvasRef.current if (canvas === null) { return } camera.aspect = canvas.clientWidth / canvas.clientHeight camera.updateProjectionMatrix() renderer.setSize(canvas.clientWidth, canvas.clientHeight, false) } handleResize() window.addEventListener('resize', handleResize) return () =\u003e { window.removeEventListener('resize', handleResize) } }, [canvasRef]) useEffect(() =\u003e { if (sceneRef.current === null) { return } sceneRef.current = null let newScene: Three.Scene if (type === LightType.RectAreaLight) { newScene = createScene(MaterialType.MESH_STANDARD_MATERIAL) } else { newScene = createScene() } sceneRef.current = newScene switch (type) { case LightType.AmbientLight: const ambientLight = new Three.AmbientLight(0xFFFFFF, 1) newScene.add(ambientLight) break case LightType.AmbientLightProbe: const ambientLightProbe = new Three.AmbientLightProbe(0xFFFFFF, 1) newScene.add(ambientLightProbe) break case LightType.DirectionalLight: const directionalLight = new Three.DirectionalLight(0xFFFFFF, 1) directionalLight.position.set(0, 10, 0); directionalLight.target.position.set(-5, 0, 0) newScene.add(directionalLight) newScene.add(directionalLight.target) const directionalLightHelper = new Three.DirectionalLightHelper(directionalLight) newScene.add(directionalLightHelper) break case LightType.HemisphereLight: const hemisphereLight = new Three.HemisphereLight(0xB1E1FF, 0xB97A20, 1) newScene.add(hemisphereLight) const hemisphereLightHelper = new Three.HemisphereLightHelper(hemisphereLight,5) newScene.add(hemisphereLightHelper) break case LightType.HemisphereLightProbe: const hemisphereLightProbe = new Three.HemisphereLightProbe(0xB1E1FF, 0xB97A20, 1) newScene.add(hemisphereLightProbe) break case LightType.PointLight: const pointLight = new Three.PointLight(0xFFFFFF, 1) pointLight.position.set(0, 10, 0) newScene.add(pointLight) const pointLightHelper = new Three.PointLightHelper(pointLight) newScene.add(pointLightHelper) break; case LightType.RectAreaLight: //RectAreaLightUniformsLib.init() //实际测试时发现即使不添加这行代码，场景似乎也依然正常渲染，没有看出差异 const rectAreaLight = new Three.RectAreaLight(0xFFFFFF, 5, 12, 4) rectAreaLight.position.set(0, 10, 0) rectAreaLight.rotation.x = Three.MathUtils.degToRad(-90) newScene.add(rectAreaLight) const rectAreaLightHelper = new RectAreaLightHelper(rectAreaLight) newScene.add(rectAreaLightHelper) break case LightType.SpotLight: const spotLight = new Three.SpotLight(0xFFFFFF, 1) spotLight.position.set(0, 10, 0); spotLight.target.position.set(-5, 0, 0) newScene.add(spotLight) newScene.add(spotLight.target) const spotLightHelper = new Three.SpotLightHelper(spotLight) newScene.add(spotLightHelper) break default: console.log('???') break } }, [type]) return ( { buttonLables.map((label, index) =\u003e { return ","wordCount":"7080","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/11-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%81%AF%E5%85%89/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>11 Three.js基础之灯光</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>15 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e7%81%af%e5%85%89%e7%9a%84%e7%a7%8d%e7%b1%bb aria-label=灯光的种类>灯光的种类</a><ul><li><a href=#%e7%81%af%e5%85%89%e7%9a%84%e7%a7%8d%e7%b1%bb-1 aria-label=灯光的种类>灯光的种类</a></li><li><a href=#%e5%85%89%e7%9a%84%e8%be%85%e5%8a%a9%e5%af%b9%e8%b1%a1 aria-label=光的辅助对象>光的辅助对象</a></li><li><a href=#%e7%81%af%e5%85%89%e4%bd%9c%e7%94%a8%e4%b8%8e%e7%89%b9%e7%82%b9 aria-label=灯光作用与特点>灯光作用与特点</a></li></ul></li><li><a href=#%e5%89%8d%e6%9c%9f%e5%87%86%e5%a4%87orbitcontrols%e8%ae%b2%e8%a7%a3%e5%88%b6%e4%bd%9c%e7%ba%b9%e7%90%86%e5%9b%be%e7%89%87 aria-label=前期准备：OrbitControls讲解、制作纹理图片>前期准备：OrbitControls讲解、制作纹理图片</a><ul><li><a href=#orbitcontrols-%e7%9a%84%e7%ae%80%e4%bb%8b%e5%92%8c%e7%94%a8%e6%b3%95 aria-label="OrbitControls 的简介和用法">OrbitControls 的简介和用法</a><ul><li><a href=#orbitcontrols%e7%9a%84%e7%94%a8%e6%b3%95 aria-label=OrbitControls的用法>OrbitControls的用法</a></li><li><a href=#%e7%ba%b9%e7%90%86%e5%9b%be%e7%89%87%e5%87%86%e5%a4%87%e5%88%b6%e4%bd%9c%e7%ba%b9%e7%90%86%e5%9b%be%e7%89%87-checkerpng aria-label="纹理图片准备：制作纹理图片 checker.png">纹理图片准备：制作纹理图片 checker.png</a></li></ul></li></ul></li><li><a href=#%e7%81%af%e5%85%89%e7%a4%ba%e4%be%8bhellolight aria-label=灯光示例：HelloLight>灯光示例：HelloLight</a><ul><li><a href=#%e7%a4%ba%e4%be%8b%e7%9b%ae%e6%a0%87 aria-label=示例目标>示例目标</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e6%8b%86%e5%88%86%e4%b8%8e%e6%a2%b3%e7%90%86 aria-label=代码拆分与梳理>代码拆分与梳理</a><ul><li><a href=#1create-scenets%e5%88%9b%e5%bb%ba%e5%9f%ba%e7%a1%80%e5%9c%ba%e6%99%af aria-label=1、create-scene.ts：创建基础场景>1、create-scene.ts：创建基础场景</a></li><li><a href=#2indextsx%e5%88%9b%e5%bb%ba%e6%b8%b2%e6%9f%93%e5%99%a8%e9%95%9c%e5%a4%b4%e4%bb%a5%e5%8f%8a%e4%b8%8d%e5%90%8c%e7%a7%8d%e7%b1%bb%e7%9a%84%e5%85%89 aria-label=2、index.tsx：创建渲染器、镜头、以及不同种类的光>2、index.tsx：创建渲染器、镜头、以及不同种类的光</a></li><li><a href=#3indexscss%e8%ae%be%e7%bd%ae%e7%9b%b8%e5%85%b3%e6%a0%b7%e5%bc%8f aria-label=3、index.scss：设置相关样式>3、index.scss：设置相关样式</a></li></ul></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=具体的代码>具体的代码</a><ul><li><a href=#create-scenets aria-label=create-scene.ts>create-scene.ts</a></li><li><a href=#indextsx aria-label=index.tsx>index.tsx</a></li><li><a href=#indexscss aria-label=index.scss>index.scss</a></li></ul></li><li><a href=#%e9%81%97%e7%95%99%e7%9a%84%e7%96%91%e6%83%91 aria-label=遗留的疑惑>遗留的疑惑</a><ul><li><a href=#%e7%ac%ac1%e4%b8%aa%e7%96%91%e6%83%91rectarealightuniformslib aria-label=第1个疑惑：RectAreaLightUniformsLib>第1个疑惑：RectAreaLightUniformsLib</a></li><li><a href=#%e7%ac%ac2%e4%b8%aa%e7%96%91%e6%83%91rectarealighthelper aria-label=第2个疑惑：RectAreaLightHelper>第2个疑惑：RectAreaLightHelper</a></li></ul></li></ul></li><li><a href=#%e9%a2%9d%e5%a4%96%e7%9a%84%e4%b8%80%e4%ba%9b%e5%94%a0%e5%8f%a8%e8%af%9d aria-label=额外的一些唠叨话>额外的一些唠叨话</a></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=灯光的种类>灯光的种类<a hidden class=anchor aria-hidden=true href=#灯光的种类>#</a></h2><p>在场景中添加灯光后，灯光照射在物体上产生明暗、光亮和阴影，从而让物体显得更加立体有光泽。</p><blockquote><p>在有些文档或教程中，会把 灯光 称呼为 光源，这只是对 light 这个单词的不同翻译而已<br>如果我在本系列文章中，有时候使用 “灯光”，有时候使用 “光源”，请勿见怪。</p></blockquote><blockquote><p>向场景中添加灯光 这个行为，在传统 3D 软件制作中通常被称为 “打灯”</p></blockquote><p><strong>若场景中的物体由非反光材质构成，即使场景中没有任何光源，渲染后依然可以看见该物体。</strong></p><blockquote><p>非反光材质为 MeshBasicMaterial</p></blockquote><p><strong>若场景中的物体由反光材质构成，假设场景中没有任何光源，渲染出的结果将是一片漆黑，什么物体都看不见。</strong></p><blockquote><p>反光材质为 MeshPhongMaterial 等</p></blockquote><h3 id=灯光的种类-1>灯光的种类<a hidden class=anchor aria-hidden=true href=#灯光的种类-1>#</a></h3><p><strong>在 Three.js 中，有 6 种基础类型的灯光，他们都继承于 Three.Light 。</strong></p><table><thead><tr><th>灯光类型(都继承于Light)</th><th>灯光名称</th><th>是否支持阴影</th><th>是否作用于全局(无处不在)</th><th>是否有照射目标</th></tr></thead><tbody><tr><td>AmbientLight</td><td>环境光、氛围光</td><td>否</td><td>是</td><td>无</td></tr><tr><td>DirectionalLight</td><td>平行光</td><td>是</td><td>否</td><td>有</td></tr><tr><td>HemisphereLight</td><td>半球光源、户外光源</td><td>否</td><td>是</td><td>无</td></tr><tr><td>PointLight</td><td>点光源</td><td>是</td><td>否</td><td>有</td></tr><tr><td>RectAreaLight</td><td>矩形面光源</td><td>否</td><td>否</td><td>无</td></tr><tr><td>SpotLight</td><td>聚光灯光源</td><td>是</td><td>否</td><td>有</td></tr></tbody></table><p><strong>补充说明1：环境光</strong></p><p>有个别文档或教程中，会把 HemisphereLight 也称呼为 “环境光”。<br>事实上 AmbientLight 和 HemisphereLight 的作用都是提供环境光，只是 HemisphereLight 的环境光更加真实，当然渲染所需性能也更多。</p><p><strong>补充说明2：是否支持阴影</strong></p><p>**所有的光照射到物体上后，都会产生阴影。**但 这里说的不是 <strong>是否会产生阴影</strong>，而是说 <strong>“是否支持阴影”</strong>。</p><p>一共有 3 种光不支持阴影：AmbientLight、HemisphereLight、RectAreaLight</p><p>其他种类的光，都支持阴影：DirectionalLight、PointLight、SpotLight</p><p>关于 Three.js 中的 阴影 (LightShadown、DirectionalLightShadown、PointLightShadown、SpotLightShadown)，我们会在后面单独开辟一节来讲解。</p><p><strong>关于“阴影”的进一步补充：</strong></p><p>在之前所有的示例中，当场景上有反光物体且有灯光时，物体会产生明暗，但是请注意：</p><ol><li><p>这个“物体显示出的明暗”并不是真正的“阴影”。</p><blockquote><p>在 Three.js 中 有真正的阴影对象，这个会在后面的 “Three.js基础之阴影” 一文中有详细说明。</p></blockquote></li><li><p>这个“物体显示出的明暗”并不是完全符合我们日常的“光影明暗”。</p><blockquote><p>这是因为我们目前所有示例都使用的是“简单光照模型”，也就是说光照射在物体上后并不进行漫反射，所以渲染出的“明暗”并不完全自然合理。</p></blockquote></li><li><p>默认渲染器并不会渲染阴影、默认支持阴影的灯光也不会投射阴影，若想产生真正的阴影，还需开启阴影渲染和投射。</p><blockquote><p>具体如何开启，也会在后面的 “Three.js基础之阴影” 一文中有详细说明。</p></blockquote></li></ol><p><strong>补充说明3：是否作用域全局</strong></p><p>只有环境光(AmbientLight、HemisphereLight)作用于全局，其他光则照耀范围都是有限的。</p><p><strong>补充说明4：什么叫 “是否有照射目标？”</strong></p><p>答：就是这个光除了光源本身之外，还包含一个 target 属性，并且可以通过设置 target.position 的位置。对于有照射目标的灯光，在场景中不光要添加灯光本身，还可以添加 灯光照射目标。</p><blockquote><p>注意是 “可以添加” 灯光目标，而不是说 “必须也要添加” 灯光目标。</p></blockquote><p>请注意上面表格中，关于 “是否产生阴影” 和 “是否有照射目标”，这 2 项 是完全相同的，也就是说，只有包含照射目标的光，才会产生阴影。</p><p><strong>在 Three.js 中，有 3 种 光探针 类型的环境光。</strong></p><table><thead><tr><th>灯光类型</th><th>灯光名称</th></tr></thead><tbody><tr><td>LightProbe</td><td>光探针</td></tr><tr><td>AmbientLightProbe(继承于LightProbe)</td><td>环境光探针</td></tr><tr><td>HemisphereLightProbe(继承于LightProbe)</td><td>半球光探针</td></tr></tbody></table><p>关于 光探针，是另外一套比较复杂的光的算法方式。</p><p>根据我网上搜索到的一些信息，大概可以描述为：</p><p><strong>传统的 环境光(AmbientLight、HemisphereLight) 渲染时需要的计算量比较大，对于渲染静止物体来说还可以，但是渲染 运动类型 的物体时所消耗的性能过高，而 光探针类型的环境光(AmbientLightProbe、HemisphereLightProbe) 则更加适合 运动类型 的物体。</strong></p><h3 id=光的辅助对象>光的辅助对象<a hidden class=anchor aria-hidden=true href=#光的辅助对象>#</a></h3><p>场景中的光本身是不可见的，为了让我们方便观测光源，Three.js 提供了 光的辅助对象：DirectionalLightHelper、HemisphereLightHelper、PointLightHelper、RectAreaLightHelper、SpotLightHelper</p><p><strong>所谓光的辅助对象，就是在渲染后出现的一些白色细线，这些白色细线指示出光源的位置、大小、以及光发射的方向。</strong></p><p>光的辅助对象用法非常简单，3 步骤：</p><ol><li>先创建 光 的实例</li><li>将创建好的光实例作为 辅助对象构造函数的参数</li><li>场景中添加 辅助对象即可</li></ol><p>例如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>//创建并设置平行光
</span></span><span style=display:flex><span>const directionalLight = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>directionalLight.position.set(0, 10, 0);
</span></span><span style=display:flex><span>directionalLight.target.position.set(-5, 0, 0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//将平行光添加到场景中
</span></span><span style=display:flex><span>scene.add(directionalLight)
</span></span><span style=display:flex><span>scene.add(directionalLight.target)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//根据平行光实例，创建对应的辅助对象，并将辅助对象添加到场景中
</span></span><span style=display:flex><span>const directionalLightHelper = new Three.DirectionalLightHelper(directionalLight)
</span></span><span style=display:flex><span>scene.add(directionalLightHelper)
</span></span></code></pre></div><h3 id=灯光作用与特点>灯光作用与特点<a hidden class=anchor aria-hidden=true href=#灯光作用与特点>#</a></h3><p><strong>AmbientLight(环境光、氛围光)：</strong></p><p>通常仅作为基础光线，一般需要与其他灯光配合使用。不能产生阴影、也无需指定坐标位置，仅需设置颜色和强度。</p><p>注意：不支持阴影</p><p><strong>DirectionalLight(平行光)：</strong></p><p>最为经常使用的光源，光纤(光芒)都是平行向着一个方向发射。</p><p>经常使用 DirectionalLight 来模拟太阳光照射到某个物体上的光照效果。</p><p><strong>HemisphereLight(半球光源)：</strong></p><p>相对 ambientLight，hemisphereLight 更加真实的模拟自然光源，提供 天空 和 地面 漫反射光线。</p><p>一共接收 3 个参数：</p><ul><li>第 1 个参数：天空光线颜色</li><li>第 2 个参数：地面反射光颜色</li><li>第 3 个参数：光的反射强度</li></ul><p>注意：不支持阴影</p><p><strong>PointLight(点光源)：</strong></p><p>类似生活中的灯泡，光纤(光芒)没有固定方向，朝着四周散射。</p><p>注意：点光源对应的辅助对象 PointLightHelper 只有一个 菱形的光源形状，并没有 光 的发射线条。</p><p><strong>RectAreaLight(矩形面光源)：</strong></p><p>与 DirectionalLight 模拟太阳光不同，RectAreaLight 光源形状为一个矩形，可以模拟出明亮的窗口或矩形照明光源。</p><p>注意：</p><ol><li><p>不支持阴影</p></li><li><p>只有 MeshStandardMaterial 和 MeshPhysicalMaterial 材料才支持 RectAreaLight 光源</p></li><li><p>按照官方文档描述，场景中必须加入 RectAreaLightUniformsLib.init()</p><blockquote><p>目前我比较疑惑的是，经过试验发现，即使不添加 RectAreaLightUniformsLib.init()，场景依然正常渲染，似乎看不出有任何差别</p></blockquote></li></ol><p><strong>特别说明：</strong></p><p>RectAreaLight 对应的 辅助对象 RectAreaLightArea 引入方式和其他 光辅助对象 引入方式不同。</p><p>其他光辅助对象都是内置在 three 中的，使用之前无需引入，可以直接使用，例如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const directionalLightHelper = new Three.DirectionalLightHelper(directionalLight)
</span></span></code></pre></div><p>但是 RectAreaLightHelper 在使用前需要引入才可以，引入代码：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { RectAreaLightHelper } from &#39;three/examples/jsm/helpers/RectAreaLightHelper&#39;
</span></span></code></pre></div><p><strong>SpotLight(聚光灯)：</strong></p><p>类似生活中的聚光灯效果。</p><p>关于每个灯光的具体参数详情、属性用法，请参考官方文档：<a href=https://threejs.org/docs/index.html#api/zh/lights/Light>https://threejs.org/docs/index.html#api/zh/lights/Light</a></p><p>接下来，我们将通过创建一个 HelloLight 的例子，直观的观察不同类型灯光的效果。</p><blockquote><p>这个示例中，会用到我们上节学习的 纹理 相关知识。</p></blockquote><h2 id=前期准备orbitcontrols讲解制作纹理图片>前期准备：OrbitControls讲解、制作纹理图片<a hidden class=anchor aria-hidden=true href=#前期准备orbitcontrols讲解制作纹理图片>#</a></h2><h3 id=orbitcontrols-的简介和用法>OrbitControls 的简介和用法<a hidden class=anchor aria-hidden=true href=#orbitcontrols-的简介和用法>#</a></h3><p>本示例中需要用到一个之前从未使用过的类：OrbitControls，先简单介绍一下这个类。</p><ol><li>orbit 单词的翻译为：轨道</li><li>controls 单词的翻译为：控制权</li></ol><p>OrbitControls 是鼠标镜头轨道控件，可以通过鼠标来配置镜头的运动轨道，例如 缩放、平移、旋转。也就是说在不修改场景的前提下，可以通过鼠标来改变镜头，以便查看不同角度下的场景。</p><blockquote><p>在手机端，不是鼠标，而是手指滑动</p></blockquote><h4 id=orbitcontrols的用法>OrbitControls的用法<a hidden class=anchor aria-hidden=true href=#orbitcontrols的用法>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const controls = new OrbitControls(camera, canvas) //创建一个实例
</span></span><span style=display:flex><span>controls.target.set(0, 5, 0) //controls.target 为镜头的坐标系统
</span></span><span style=display:flex><span>//controls.target.set(0, 5, 0) 的意思是：设置原点 Y 轴的坐标(以高出5米的轨道运行)
</span></span><span style=display:flex><span>controls.update() //使控件使用新目标
</span></span></code></pre></div><p>请注意，在上面代码中，OrbitControls 的构造函数中第 2 个参数为DOM 中的 canvas 节点，实际上当添加过 OrbitControls 之后，鼠标在 canvas 上的 拖拽、鼠标滚轴滚动 等操作都会被捕捉到，并且做出相对应的镜头画面切换。</p><p>说直白点，我们终于可以通过鼠标对 3D 场景进行不同角度，距离的切换操作了。</p><p><strong>OrbitControls的change事件：</strong></p><p>无论是通过 鼠标或键盘 来修改镜头轨道 都会触发 OrbitControls 的 change 事件。</p><p>我们可以通过添加 事件监听 来捕获该事件：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const handleChange = () =&gt; { ... }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const controls = new OrbitControls(camera, canvasRef.current)
</span></span><span style=display:flex><span>controls.addEventListener(&#39;change&#39;,handleChange)
</span></span></code></pre></div><p>对于目前的我们来说，是没有必要使用该事件的，在后续的 Three.js 技巧篇 中，我们才会运用到 change 事件。</p><p>除此之外，我们还可以设置 禁止缩放、禁止旋转、禁止右键拖拽、设置可旋转角度范围等等一系列配置，具体的可查阅官方文档：<a href=https://threejs.org/docs/#examples/zh/controls/OrbitControls>https://threejs.org/docs/#examples/zh/controls/OrbitControls</a></p><p><strong>特别注意：</strong></p><p>OrbitControls 并不是包含在 three 根目录下，而是位于 three/examples/jsm/controls/OrbitControls 中，因此引入代码为：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;
</span></span></code></pre></div><blockquote><p>提醒：在 OrbitControls.js 中，分别导出有 OrbitControls 和 MapControls，所以引入 OribitControls 是需要加 大括号 { }。</p></blockquote><p><strong>补充说明：</strong></p><p>严格意义上讲，OrbitControls 并不是 Three.js 核心包含的代码内容，OrbitControls 是将最常见的鼠标与 Three.js 场景交互内容的一个额外封装。</p><p>由于 OrbitControls 实在是过于频繁使用，最终 Three.js 将 OrbitControls 也包含到了 Three.js 代码包中，只不过不在默认的目录中，而是在 Three.js 示例目录中。</p><blockquote><p>在 Three.js 早期的版本中，代码包中并未包含 OrbitControls，若想使用还需要 yarn 安装 three-orbitcontrols 这个包。只不过当后来 Three.js 包含了 OrbitControls 之后，才再也无需额外安装了。</p></blockquote><p><strong>补充说明2：</strong></p><p>原本 OrbitControl 除了鼠标拖拽可以改变场景视角，还支持键盘上的 4 个方向键来改变场景视角。</p><p>只不过 React 对于原生 DOM 事件支持度并不高，React 更倾向于给组件添加 onKeydown 属性处理函数。</p><blockquote><p>本质上 组件的 onKeydown 相当于 React 的合成事件。</p></blockquote><p>Three.js 的官方示例使用的是原生 html + js，是完全支持原生键盘事件的。所以 官网的示例 使用键盘方向键控制场景没有问题，但是在 React 项目中却不太容易实现。</p><p>在 React 中如果想让 canvas 拥有键盘事件监听，需要做以下 2 处设置：</p><ol><li>在 useEffect 中，当第一次挂载完成，添加 canvasRef.current.fouce()，让 canvas 自动获得焦点</li><li>在 &lt;canvas /> 中添加 tabindex 属性，属性值为 -1、0、1 都无所谓，例如：&lt;canvas tabindex={0} /></li></ol><p>只有满足以上 2 个条件后，canvas 才会监听到键盘事件，但是一旦 canvas 失去焦点，那么就又监听不到了。</p><blockquote><p>还是继续使用 鼠标拖拽 来修改查看场景视角吧</p></blockquote><p><strong>补充说明3：</strong></p><p>事实上如果你真的需要监听 鼠标键盘方向键 ，其实最简单的办法就是把 OrbitControls 监听对象修改为 document.body 上。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- const controls = new OrbitControls(camera, canvasRef.current)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006></span><span style=color:#282828;background-color:#79740e>+ const controls = new OrbitControls(camera, document.body)
</span></span></span></code></pre></div><h4 id=纹理图片准备制作纹理图片-checkerpng>纹理图片准备：制作纹理图片 checker.png<a hidden class=anchor aria-hidden=true href=#纹理图片准备制作纹理图片-checkerpng>#</a></h4><p>本示例中需要用到一个类似 3D 场景地面黑白网格的纹理，因此我们需要提前准备好这个纹理图片。</p><p>在 PhotoShop 中新建一个 宽高都为 2 像素的画布，然后：</p><ol><li>左上角和右下角 的那 1 像素中填充一个较黑的颜色</li><li>右上角和左下角 的那 1 像素中填充一个较白的颜色</li><li>将图片导出为 checker.png，并保存到 src/assets/imgs/ 目录中</li></ol><p><strong>补充说明：</strong></p><p>虽然制作的纹理图片非常小，只有 2像素 * 2像素，但是我们可以通过设置纹理的重复，来实现渲染出比较大的 黑白网格底盘。</p><ol><li>设置纹理 magFilter 的属性值为 Three.NearestFilter</li><li>设置纹理 wrapS、wrapT 属性值为 Three.RepeatWrapping</li><li>根据 黑白网格的尺寸，计算并设置纹理 repeat 重复次数</li></ol><p>以上 3 点刚好都是上一节我们讲解 纹理 时学习到的知识点。</p><h2 id=灯光示例hellolight>灯光示例：HelloLight<a hidden class=anchor aria-hidden=true href=#灯光示例hellolight>#</a></h2><p>先回顾一下 Three.js 中 10 个 光 的类型：</p><p>光的原型(Light) + 6种基础光(AmbientLight&mldr;) + 光探针原型(LightProbe) + 2种环境光探针(AmbientLightProbe、HemisphereLightProbe) = 1 + 6 + 1 + 2 = 10</p><h3 id=示例目标>示例目标<a hidden class=anchor aria-hidden=true href=#示例目标>#</a></h3><ol><li>使用并体验 Three.js 中除 Light 和 LightProbe 之外的其他 8 种光类型</li><li>使用并体验 光的辅助对象( XxxLightHelper)</li></ol><p><strong>补充说明：</strong></p><ol><li>环境光 AmbientLight 是没有 辅助对象的、其他光都有辅助对象</li><li>矩形光 RectAreaLight 的辅助对象 RectAreaLightHelper 和其他光的辅助对象 引入方式不同</li></ol><h3 id=代码拆分与梳理>代码拆分与梳理<a hidden class=anchor aria-hidden=true href=#代码拆分与梳理>#</a></h3><h4 id=1create-scenets创建基础场景>1、create-scene.ts：创建基础场景<a hidden class=anchor aria-hidden=true href=#1create-scenets创建基础场景>#</a></h4><p>创建 src/components/hello-light/create-scene.ts ，导出一个名为 createScene 的函数，用来专门负责创建基础的场景。</p><p><strong>具体代码梳理：</strong></p><ol><li><p>该场景中包含 1个黑白网格的地面、1个立方体、1个球体，但是该场景不包含任何光。</p></li><li><p>createScene 创建基础场景时接收一个参数 type，type 只能为以下 2 个值中的其中 1 种：MESH_PHONE_MATERIAL 或 MESH_STANDARD_MATERIAL</p></li><li><p>type 默认值为 MESH_PHONE_MATERIAL</p></li></ol><p><strong>进一步解释：</strong></p><p>由于 RectAreaLight 只作用在 MeshStandardMaterial 和 MeshPhysicalMaterial 材料物体上，所以我们才设置 type 这个参数。</p><ol><li>当使用 RectAreaLight 时，我们告知 createScene，使用 MeshStandardMaterial 材质创建 地面、立方体、球体</li><li>当使用 其他 光时，我们告知 createScene，使用 MeshPhongMaterial 材质创建 地面、立方体、球体</li></ol><h4 id=2indextsx创建渲染器镜头以及不同种类的光>2、index.tsx：创建渲染器、镜头、以及不同种类的光<a hidden class=anchor aria-hidden=true href=#2indextsx创建渲染器镜头以及不同种类的光>#</a></h4><p><strong>具体代码梳理：</strong></p><ol><li>当 canvas DOM 初始化后，创建 渲染器、镜头、镜头交互(OrbitControls)</li><li>创建 8 个按钮，每个按钮对应一种光</li><li>使用 useState 创建一个变量 type，用来记录当前演示 光的类型</li><li>点击不同按钮后，修改 当前光的类型 type 的值，从而引发 react 重新渲染</li><li>在新一轮的渲染中，通过判断 type 类型，使用 createScene 创建一个新的场景 和 对应的 光</li></ol><h4 id=3indexscss设置相关样式>3、index.scss：设置相关样式<a hidden class=anchor aria-hidden=true href=#3indexscss设置相关样式>#</a></h4><p><strong>具体样式梳理：</strong></p><ol><li>设置 canvas 对应的样式</li><li>设置 8 个按钮对应的样式</li></ol><h3 id=具体的代码>具体的代码<a hidden class=anchor aria-hidden=true href=#具体的代码>#</a></h3><h4 id=create-scenets>create-scene.ts<a hidden class=anchor aria-hidden=true href=#create-scenets>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export enum MaterialType {
</span></span><span style=display:flex><span>    MESH_PHONE_MATERIAL = &#39;MESH_PHONE_MATERIAL&#39;,
</span></span><span style=display:flex><span>    MESH_STANDARD_MATERIAL = &#39;MESH_STANDARD_MATERIAL&#39;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const createScene: (type?: keyof typeof MaterialType) =&gt; Three.Scene = (type = MaterialType.MESH_PHONE_MATERIAL) =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const scene = new Three.Scene()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const planeSize = 40
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const loader = new Three.TextureLoader()
</span></span><span style=display:flex><span>    const texture = loader.load(require(&#39;@/assets/imgs/checker.png&#39;).default)
</span></span><span style=display:flex><span>    texture.wrapS = Three.RepeatWrapping
</span></span><span style=display:flex><span>    texture.wrapT = Three.RepeatWrapping
</span></span><span style=display:flex><span>    texture.magFilter = Three.NearestFilter
</span></span><span style=display:flex><span>    texture.repeat.set(planeSize / 2, planeSize / 2)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    let planeMat: Three.Material
</span></span><span style=display:flex><span>    let cubeMat: Three.Material
</span></span><span style=display:flex><span>    let sphereMat: Three.Material
</span></span><span style=display:flex><span>    switch (type) {
</span></span><span style=display:flex><span>        case MaterialType.MESH_STANDARD_MATERIAL:
</span></span><span style=display:flex><span>            planeMat = new Three.MeshStandardMaterial({
</span></span><span style=display:flex><span>                map: texture,
</span></span><span style=display:flex><span>                side: Three.DoubleSide
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            cubeMat = new Three.MeshStandardMaterial({ color: &#39;#8AC&#39; })
</span></span><span style=display:flex><span>            sphereMat = new Three.MeshStandardMaterial({ color: &#39;#CA8&#39; })
</span></span><span style=display:flex><span>            break
</span></span><span style=display:flex><span>        default:
</span></span><span style=display:flex><span>            planeMat = new Three.MeshPhongMaterial({
</span></span><span style=display:flex><span>                map: texture,
</span></span><span style=display:flex><span>                side: Three.DoubleSide
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            cubeMat = new Three.MeshPhongMaterial({ color: &#39;#8AC&#39; })
</span></span><span style=display:flex><span>            sphereMat = new Three.MeshPhongMaterial({ color: &#39;#8AC&#39; })
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const planeGeo = new Three.PlaneBufferGeometry(planeSize, planeSize)
</span></span><span style=display:flex><span>    const mesh = new Three.Mesh(planeGeo, planeMat)
</span></span><span style=display:flex><span>    mesh.rotation.x = Math.PI * -0.5
</span></span><span style=display:flex><span>    scene.add(mesh)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const cubeGeo = new Three.BoxBufferGeometry(4, 4, 4)
</span></span><span style=display:flex><span>    const cubeMesh = new Three.Mesh(cubeGeo, cubeMat)
</span></span><span style=display:flex><span>    cubeMesh.position.set(5, 2.5, 0)
</span></span><span style=display:flex><span>    scene.add(cubeMesh)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const sphereGeo = new Three.SphereBufferGeometry(3, 32, 16)
</span></span><span style=display:flex><span>    const sphereMesh = new Three.Mesh(sphereGeo, sphereMat)
</span></span><span style=display:flex><span>    sphereMesh.position.set(-4, 5, 0)
</span></span><span style=display:flex><span>    scene.add(sphereMesh)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return scene
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default createScene
</span></span></code></pre></div><h4 id=indextsx>index.tsx<a hidden class=anchor aria-hidden=true href=#indextsx>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useEffect, useRef, useState } from &#39;react&#39;
</span></span><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;
</span></span><span style=display:flex><span>//import { RectAreaLightUniformsLib } from &#39;three/examples/jsm/lights/RectAreaLightUniformsLib&#39;
</span></span><span style=display:flex><span>import { RectAreaLightHelper } from &#39;three/examples/jsm/helpers/RectAreaLightHelper&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import createScene, { MaterialType } from &#39;./create-scene&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>enum LightType {
</span></span><span style=display:flex><span>    AmbientLight = &#39;AmbientLight&#39;,
</span></span><span style=display:flex><span>    AmbientLightProbe = &#39;AmbientLightProbe&#39;,
</span></span><span style=display:flex><span>    DirectionalLight = &#39;DirectionalLight&#39;,
</span></span><span style=display:flex><span>    HemisphereLight = &#39;HemisphereLight&#39;,
</span></span><span style=display:flex><span>    HemisphereLightProbe = &#39;HemisphereLightProbe&#39;,
</span></span><span style=display:flex><span>    PointLight = &#39;PointLight&#39;,
</span></span><span style=display:flex><span>    RectAreaLight = &#39;RectAreaLight&#39;,
</span></span><span style=display:flex><span>    SpotLight = &#39;SpotLight&#39;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const buttonLables = [LightType.AmbientLight, LightType.AmbientLightProbe, LightType.DirectionalLight,
</span></span><span style=display:flex><span>LightType.HemisphereLight, LightType.HemisphereLightProbe, LightType.PointLight,
</span></span><span style=display:flex><span>LightType.RectAreaLight, LightType.SpotLight]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloLight = () =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>    const sceneRef = useRef&lt;Three.Scene | null&gt;(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const [type, setType] = useState&lt;LightType&gt;(LightType.AmbientLight)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        if (canvasRef.current === null) {
</span></span><span style=display:flex><span>            return
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 1000)
</span></span><span style=display:flex><span>        camera.position.set(0, 10, 20)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const controls = new OrbitControls(camera, canvasRef.current)
</span></span><span style=display:flex><span>        controls.target.set(0, 5, 0)
</span></span><span style=display:flex><span>        controls.update()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const scene = createScene()
</span></span><span style=display:flex><span>        sceneRef.current = scene
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const render = () =&gt; {
</span></span><span style=display:flex><span>            if (sceneRef.current) {
</span></span><span style=display:flex><span>                renderer.render(sceneRef.current, camera)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const handleResize = () =&gt; {
</span></span><span style=display:flex><span>            const canvas = canvasRef.current
</span></span><span style=display:flex><span>            if (canvas === null) {
</span></span><span style=display:flex><span>                return
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            camera.aspect = canvas.clientWidth / canvas.clientHeight
</span></span><span style=display:flex><span>            camera.updateProjectionMatrix()
</span></span><span style=display:flex><span>            renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        handleResize()
</span></span><span style=display:flex><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        if (sceneRef.current === null) {
</span></span><span style=display:flex><span>            return
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        sceneRef.current = null
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        let newScene: Three.Scene
</span></span><span style=display:flex><span>        if (type === LightType.RectAreaLight) {
</span></span><span style=display:flex><span>            newScene = createScene(MaterialType.MESH_STANDARD_MATERIAL)
</span></span><span style=display:flex><span>        } else {
</span></span><span style=display:flex><span>            newScene = createScene()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        sceneRef.current = newScene
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        switch (type) {
</span></span><span style=display:flex><span>            case LightType.AmbientLight:
</span></span><span style=display:flex><span>                const ambientLight = new Three.AmbientLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>                newScene.add(ambientLight)
</span></span><span style=display:flex><span>                break
</span></span><span style=display:flex><span>            case LightType.AmbientLightProbe:
</span></span><span style=display:flex><span>                const ambientLightProbe = new Three.AmbientLightProbe(0xFFFFFF, 1)
</span></span><span style=display:flex><span>                newScene.add(ambientLightProbe)
</span></span><span style=display:flex><span>                break
</span></span><span style=display:flex><span>            case LightType.DirectionalLight:
</span></span><span style=display:flex><span>                const directionalLight = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>                directionalLight.position.set(0, 10, 0);
</span></span><span style=display:flex><span>                directionalLight.target.position.set(-5, 0, 0)
</span></span><span style=display:flex><span>                newScene.add(directionalLight)
</span></span><span style=display:flex><span>                newScene.add(directionalLight.target)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                const directionalLightHelper = new Three.DirectionalLightHelper(directionalLight)
</span></span><span style=display:flex><span>                newScene.add(directionalLightHelper)
</span></span><span style=display:flex><span>                break
</span></span><span style=display:flex><span>            case LightType.HemisphereLight:
</span></span><span style=display:flex><span>                const hemisphereLight = new Three.HemisphereLight(0xB1E1FF, 0xB97A20, 1)
</span></span><span style=display:flex><span>                newScene.add(hemisphereLight)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                const hemisphereLightHelper = new Three.HemisphereLightHelper(hemisphereLight,5)
</span></span><span style=display:flex><span>                newScene.add(hemisphereLightHelper)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                break
</span></span><span style=display:flex><span>            case LightType.HemisphereLightProbe:
</span></span><span style=display:flex><span>                const hemisphereLightProbe = new Three.HemisphereLightProbe(0xB1E1FF, 0xB97A20, 1)
</span></span><span style=display:flex><span>                newScene.add(hemisphereLightProbe)
</span></span><span style=display:flex><span>                break
</span></span><span style=display:flex><span>            case LightType.PointLight:
</span></span><span style=display:flex><span>                const pointLight = new Three.PointLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>                pointLight.position.set(0, 10, 0)
</span></span><span style=display:flex><span>                newScene.add(pointLight)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                const pointLightHelper = new Three.PointLightHelper(pointLight)
</span></span><span style=display:flex><span>                newScene.add(pointLightHelper)
</span></span><span style=display:flex><span>                break;
</span></span><span style=display:flex><span>            case LightType.RectAreaLight:
</span></span><span style=display:flex><span>                //RectAreaLightUniformsLib.init() //实际测试时发现即使不添加这行代码，场景似乎也依然正常渲染，没有看出差异
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                const rectAreaLight = new Three.RectAreaLight(0xFFFFFF, 5, 12, 4)
</span></span><span style=display:flex><span>                rectAreaLight.position.set(0, 10, 0)
</span></span><span style=display:flex><span>                rectAreaLight.rotation.x = Three.MathUtils.degToRad(-90)
</span></span><span style=display:flex><span>                newScene.add(rectAreaLight)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                const rectAreaLightHelper = new RectAreaLightHelper(rectAreaLight)
</span></span><span style=display:flex><span>                newScene.add(rectAreaLightHelper)
</span></span><span style=display:flex><span>                break
</span></span><span style=display:flex><span>            case LightType.SpotLight:
</span></span><span style=display:flex><span>                const spotLight = new Three.SpotLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>                spotLight.position.set(0, 10, 0);
</span></span><span style=display:flex><span>                spotLight.target.position.set(-5, 0, 0)
</span></span><span style=display:flex><span>                newScene.add(spotLight)
</span></span><span style=display:flex><span>                newScene.add(spotLight.target)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                const spotLightHelper = new Three.SpotLightHelper(spotLight)
</span></span><span style=display:flex><span>                newScene.add(spotLightHelper)
</span></span><span style=display:flex><span>                break
</span></span><span style=display:flex><span>            default:
</span></span><span style=display:flex><span>                console.log(&#39;???&#39;)
</span></span><span style=display:flex><span>                break
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [type])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;div className=&#39;full-screen&#39;&gt;
</span></span><span style=display:flex><span>            &lt;div className=&#39;buttons&#39;&gt;
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    buttonLables.map((label, index) =&gt; {
</span></span><span style=display:flex><span>                        return &lt;button
</span></span><span style=display:flex><span>                            className={label === type ? &#39;button-selected&#39; : &#39;&#39;}
</span></span><span style=display:flex><span>                            onClick={() =&gt; { setType(label) }}
</span></span><span style=display:flex><span>                            key={`button${index}`}
</span></span><span style=display:flex><span>                        &gt;{label}&lt;/button&gt;
</span></span><span style=display:flex><span>                    })
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            &lt;/div&gt;
</span></span><span style=display:flex><span>            &lt;canvas ref={canvasRef} /&gt;
</span></span><span style=display:flex><span>        &lt;/div&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloLight
</span></span></code></pre></div><blockquote><p>create-scene.ts 和 index.tsx 的代码非常多，并且我也没有写注释。<br>但是如果之前章节中的示例你也都跟着 敲一遍，应该很容易看懂 这两个文件里的代码。</p></blockquote><h4 id=indexscss>index.scss<a hidden class=anchor aria-hidden=true href=#indexscss>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.full-screen, canvas {
</span></span><span style=display:flex><span>    display: block;
</span></span><span style=display:flex><span>    height: inherit;
</span></span><span style=display:flex><span>    width: inherit;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.buttons {
</span></span><span style=display:flex><span>    display: flex;
</span></span><span style=display:flex><span>    justify-content: center;
</span></span><span style=display:flex><span>    width: 100%;
</span></span><span style=display:flex><span>    position: fixed;
</span></span><span style=display:flex><span>    top: 30px;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.buttons button {
</span></span><span style=display:flex><span>    width: 200px;
</span></span><span style=display:flex><span>    height: 30px;
</span></span><span style=display:flex><span>    margin-left: 20px;
</span></span><span style=display:flex><span>    font-size: 18px;
</span></span><span style=display:flex><span>    cursor: pointer;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.buttons button:first-child {
</span></span><span style=display:flex><span>    margin-left: 0;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.button-selected{
</span></span><span style=display:flex><span>    background-color:green;
</span></span><span style=display:flex><span>    color: white;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>若一切正常，实际运行后：</p><ol><li>点击网页中不同顶部的按钮，可以切换不同光对应的场景效果</li><li>点击并拖动鼠标 或 滚动鼠标滚轴，可以切换场景视角</li></ol><h3 id=遗留的疑惑>遗留的疑惑<a hidden class=anchor aria-hidden=true href=#遗留的疑惑>#</a></h3><h4 id=第1个疑惑rectarealightuniformslib>第1个疑惑：RectAreaLightUniformsLib<a hidden class=anchor aria-hidden=true href=#第1个疑惑rectarealightuniformslib>#</a></h4><p>按照官方文档的说法，在使用 RectAreaLight 时，必须要执行 RectAreaLightUniformsLib.init() 的，但实际试验发现不执行这行代码也没有任何问题。</p><p><strong>为什么会这样？</strong></p><h4 id=第2个疑惑rectarealighthelper>第2个疑惑：RectAreaLightHelper<a hidden class=anchor aria-hidden=true href=#第2个疑惑rectarealighthelper>#</a></h4><p>实际运行发现，RectAreaLightHelper 所展示的光源的位置和方向与实际不符。</p><p>矩形面灯光的代码为：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const rectAreaLight = new Three.RectAreaLight(0xFFFFFF, 5, 12, 4)
</span></span><span style=display:flex><span>rectAreaLight.position.set(0, 10, 0)
</span></span><span style=display:flex><span>rectAreaLight.rotation.x = Three.MathUtils.degToRad(-90)
</span></span><span style=display:flex><span>newScene.add(rectAreaLight)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const rectAreaLightHelper = new RectAreaLightHelper(rectAreaLight)
</span></span><span style=display:flex><span>newScene.add(rectAreaLightHelper)
</span></span></code></pre></div><p>我们对 rectAreaLight 进行了 position(位置)、rotation(旋转) 设置，<strong>难道 对应的辅助对象并不会跟随同步变化？</strong></p><h2 id=额外的一些唠叨话>额外的一些唠叨话<a hidden class=anchor aria-hidden=true href=#额外的一些唠叨话>#</a></h2><p>我是一边学习 Three.js 官方教程，一边写本系列文章。</p><p>本片文章的源头，对应的原始教程是：<a href=https://threejsfundamentals.org/threejs/lessons/threejs-lights.html>https://threejsfundamentals.org/threejs/lessons/threejs-lights.html</a></p><p>因为之前刚好学过 场景，按照当时编写的示例代码：</p><ol><li>月球围绕地球</li><li>地球围绕太阳</li><li>太阳自转</li></ol><p>我当时得出了一个结论：每一个 scene 实例都是一个相对独立的 场景空间，<strong>我想当然得认为这里面的独立也包含 场景中的 光</strong>。</p><p>所以最初我想实现 光 示例时这样的：</p><ol><li>一个主场景</li><li>主场景内，2 行 3 列 分布着 6 个子场景</li><li>这 6 个子场景里，分别包含这 6 中基础光源</li></ol><p>按照这个目标，我编写了代码，结果渲染后的场景画面，<strong>完全不是我预期的，实际结果是：6 个子场景上的灯光，完全混合在一起，并不是相互独立的</strong>。</p><p><strong>当时我完全懵的状态。</strong></p><p>经过 1 天的迷惑，查资料、QQ交流群里询问其他人，直至我最终查阅了 scene.add() 函数源码，才明白过来，我那个结论是错误的。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>sceneB.add(lightB)
</span></span><span style=display:flex><span>sceneA.add(sceneB)
</span></span></code></pre></div><p>以上代码最终真正的执行，会将 lightB 添加到 sceneA 中。</p><p>尤其假设 lightB 光的类型为 环境光，而环境光是无处不在的，那么 lightB 会影响到所有 sceneA 中的物体。</p><p>这也就解释了为什么 “6 个子场景上的灯光，完全混合在一起，并不是相互独立的”。</p><p>或许你会疑惑？你说的这些不都已经在 <a href=https://github.com/puxiao/threejs-tutorial/blob/main/08%20Three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF.md>Three.js基础之场景.md</a> 一节中讲过了，怎么又说了一遍？</p><p>事实是我在进一步理解 场景、光 之后，又重新修改编辑了 之前章节的错误观点，所以你看到的时候都才是正确的。</p><p>我是一边学习，一边有新的知识领悟，然后再不断回头修改、补充之前文章中的相关知识点。</p><p><strong>我唠叨的这些目的，其实想表达 2 个事情：</strong></p><ol><li>学习 Three.js 的 类、函数、方法、属性时候，最好去看一下 three.js 的源码，绝对会加深你的 Three.js 理解和功力。</li><li>学习 Three.js 真的挺难，需要不断打破已有认知，若有些地方暂时无法理解也没关系，只要继续加油，终会搞明白的。</li></ol><p>唠叨结束。</p><p>本文学习了 光(Light)，按道理接下来应该学习 阴影(LightShadown)，但是下节我们先学习 镜头(Camera)，学完之后再回过头学习 阴影。</p><blockquote><p>明天是2020年12月19日，阿里巴巴 前端 D2 技术分享大会开幕，19号、20号 为期 2 天的前端技术直播会议分享。</p></blockquote><blockquote><p>花 98 元买的直播观看门票，不能浪费了，所以，换换脑子，未来 2 天暂停 Three.js 的学习。</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/10-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%B9%E7%90%86/><span class=title>« Prev</span><br><span>10 Three.js基础之纹理</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/12-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%95%9C%E5%A4%B4/><span class=title>Next »</span><br><span>12 Three.js基础之镜头</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>