<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>24 Three.js解决方案之加载.gltf模型 | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="24 Three.js解决方案之加载.gltf模型 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/24-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="24 Three.js解决方案之加载.gltf模型"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/24-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="24 Three.js解决方案之加载.gltf模型"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"24 Three.js解决方案之加载.gltf模型","item":"https://bablvsj.github.io/posts/threejs/24-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"24 Three.js解决方案之加载.gltf模型","name":"24 Three.js解决方案之加载.gltf模型","description":"","keywords":["Three.js"],"articleBody":"上一章节，我们讲解了加载 .obj 模型，本文将讲解加载 .gltf 模型。\n注：虽然我们标题写的是 “加载.gltf模型”，但更加准确地说法应该是 “加载 gtTF 文件”\n首先我们先回顾一下 .obj 文件格式的模型一些特征：文件格式简单(纯文本)、除模型外无法提供其他场景元素(例如摄像机、灯光等)。\n本文要讲解的 .gltf 格式文件可以包含的数据内容和类型要比 .obj 多很多。\n常见 3D 文件格式 和 gltf 的区别 我们先将常见的 3D文件格式进行划分\n第1类(原始文件)：\n3D 建模软件本身特有的、原始的文件格式，例如：\nBlender 对应的是 .blend 3D Max 对应的是 .max Maya 对应的是 .ma C4D 对应的是 .c4d 第2类(中转文件)：\n多个 3D 建模软件彼此都可以打开，能够读取的文件格式，例如：\n.obj .dae .fbx 所谓“中转”，是指这些格式的作用实际上相当于将某个模型从 A 软件 导出 然后再 B 软件中可以打开并读取。\n第3类(特定格式)：\n某些 3D 应用独有的文件格式。\n例如王者荣耀这款游戏中 3D 模型就可能是自己独有的文件格式。\n第4类(传输格式)：\n这里的 “传输” 是英文单词 “Transmission” 的翻译\ngltf 就属于传输格式类型的文件。gltf格式可以做到其他格式都无法做到的事情。\nGLTF文件格式简介 GLTF是英文：Graphics Language Transmission Format 的缩写\nWebGL、OpenGL 中的 “GL” 和 GLTF 中的 “GL” 是相同的单词。\nGLTF中文全称为：图形语言传输格式\nGLTF 本身就是由 OpenGL 和 Vulkan 背后的 3D 图形标准组织 Khronos 定义的。\n所以你可以想象得到，gltf 本身就是为了网络传输、浏览器渲染 3D 而生的。\n关于更多 gltf 信息，可以查看其官网：https://www.khronos.org/gltf/\nGLTF的支持度：几乎所有的 Web 3D 图形框架都支持 GLTF\n除了 Three.js 框架外 ，其他 3D JS 引擎框架也都支持 GLTF\ngltf优点 1：体积小，便于传输\ngltf 文件中模型的数据都以二进制存储，当下载(使用) gltf 文件时可以将这些二进制数据直接在 GPU 中使用。\n反观 vrml、.obj 或 .dae 等格式，他们是将数据存储为文本(例如纯文本或JSON格式)，也就是说 GPU 在读取这些模型文件时还需要进行文本解析。\n在文件体积方面，通常相同的模型顶点数据如果用文本形式存储，要比二进制存储体积大 3 到 5 倍。\ngltf优点 2：直接渲染\ngltf 文件中模型的数据是直接要渲染的，而不是要再次编辑的。\n换句话说 gltf 文件中的模型是不可以再次编辑的\n而其他类型的文件，例如 .obj 中模型是可以在 Three.js 中加载完成后二次编辑的\n你可以简单的把 gltf 想象成 jpg 图片，而其他格式的 3D 文件是 PSD 文件，当我们仅仅是为了看到图片，无需编辑该图片时，肯定是 .jpg 图片体积小，打开速度快。\n正因为是不可编辑，所以一些对于渲染而言不重要的数据通常都已被删除，例如多边形都已转化为三角形。\ngltf优点 3：内嵌材质信息\ngltf 文件中模型的材质信息是被内嵌进去。\n请注意我们这里说的是 “材质信息”，也就是相当于 .obj 对应的 .mtl 中的数据，但是对于纹理图片资源(xxx.jpg)本身来说，并不会内嵌进去。\n所以，这里隐含的一个事情就是，我们依然需要将 .gltf 文件对应的纹理图片资源 .jpg 放在 pulic 目录中。\n结论：gltf 格式非常有针对性，是专门为渲染而设计的，文件体积小，且 GPU 读取快速。\n因此，推荐使用 gltf 格式。\n在Blender中导出gltf文件 讲了这么多 gltf 文件的优点，那么我们打开之前创建的 hello.blend 文件，导出一下 gltf 文件看看。\n导出步骤：\n打开 hello.blend\n文件 \u003e 导出 \u003e glTF 2.0(.glb/.gltf)\n在弹窗对话框中，使用默认导出项，我们直接点 导出\n尽管我们使用的是默认导出项，但是还请你留意一下这几项内容：\n包括：选定的物体(未勾选)、自定义属性(未勾选)、相机(未勾选)、精确灯光(未勾选)\n变换：Y 向上(已勾选)\n几何数据: 应用修改器(未勾选)、UV(已勾选)、法向(已勾选)、切向(未勾选)、顶点色(已勾选)、材质(导出)、图像(自动)、压缩(未勾选)\n动画：动画(已勾选)、形态键(已勾选)、蒙皮(已勾选)\n尽管我们创建的 hello.blend 中并未设置任何动画，你可以选择取消动画相关的勾选\n此时去导出目录里，我们会发现多出来了一个 hello.glb 的文件。\n特别强调：由于纹理图片资源 metal_texture.jpg 本身就在目录中，所以我们只是从直观上感觉多出了 1 个文件而已。\n.glb ？不是 .gltf ？\n额~，别着急，我们补充一下 GLTF 格式的知识。\nGLTF是一种3D文件格式规范，但是却有 3 种表现形式 3 种表现形式分别为：分离式、二进制、嵌入式\n第1种表现形式(分离式)：.gltf + .bin + 纹理贴图资源(.jpg、.png)\ngltf：3D 场景的所有概要信息，包括灯光、纹理贴图等信息\n该文件的内容具体形式为 JSON\n.bin：模型的二进制数据\n纹理贴图资源：这个就不多说了，就是纹理图片 xxx.jpg 或 .png\n第2种表现形式(二进制)：.glb\n.glb：包含场景所有的信息的二进制数据。\n.glb === .gltf + .bin + 纹理图片资源\n第3种表现形式(嵌入式)：.gltf\n.gltf：以 JSON 形式保存所有场景信息数据，包括材质和纹理信息。\n这种形式由于文件内容是 json，因此是可以通过文本再次编辑的\nBlender 默认导出 glTF 2.0 格式时，采用的是 .glb 后缀形式。\n想要更改成别的导出形式，我们可以在 Blender 导出项 格式下拉框中更改为 “.gltf 分离(.gltf + .bin + 纹理)” 或 “glTF嵌入式(.gltf)\"。\n那么此时导出的文件格式就是 .gltf 后缀形式。\n3种形式的对比：\n以下纯粹是我个人的观点，仅供参考\n比较常见的是前 2 种：分离式(.gltf + .bin + 纹理)、二进制形式(.glb)\n如果你的项目中，模型数据不会发生变化，但是纹理贴图可能容易发生变化，那么可以选择 分离式的。\n分离式的贴图资源本身就是单独存在的，因此方便替换修改。\n如果你是要发送给其他人使用、且不会发生材质变更的，则可以采用 .glb 形式的。\n由于所有数据都只在 .glb 文件中，就 1 个文件也利于文件发送。\n补充一点：有一个网站 https://gltf-viewer.donmccurdy.com/ ，他可以提供 .glb 文件在线预览。\n同时在 NPM 上面，有很多针对 .glb 和 .gltf 格式互转的工具包，例如：gltf-import-export\n对于 Three.js 来说，加载 glTF 格式的文件，无论哪种形式，均支持。\n使用GLTFLoader加载glTF文件的示例 在 Three.js 中负责加载 glTF 格式文件的加载器为 GLTFLoader。\n用法和之前 OBJLoader 用法完全相同，废话不多说，直接看代码。\n我们先加载 .glb 格式的文件，代码如下：\nsrc/components/hello-gltfloader\n由于 .glb 文件是单独 1 个存在，所以我们这次可以将 hello.glb 文件放在 src/assces/model/ 目录下了。\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\" ... const loader = new GLTFLoader() loader.load(require('@/assets/model/hello.glb').default, (gltf) =\u003e { scene.add(gltf.scene) }) 请注意当加载完成后，执行的是 scene.add(gltf.scene)\n加载完成得到的 gltf 中包含的数据有：\ngltf.animations; // Array gltf.scene; // THREE.Group gltf.scenes; // Array gltf.cameras; // Array gltf.asset; // Object 我们此刻只是将 gltf.scene 添加到了场景中而已，其他数据暂时并未使用到。\n和加载 .glb 类似，如果我们的 3D 数据文件为 分离式的 .gltf，则将上述代码修改为：\nloader.load('./model/hello.gltf', (gltf) =\u003e { scene.add(gltf.scene) }) 注意：我们只需将 hello.gltf 传递给 loader 即可，loader 会读取 .gltf 中的数据，自动去加载对应的 hello.bin 和 纹理图片 hello.jpg。\n由于牵扯到不同的文件 webpack 编译，所以我们选择将 .gltf、.bin、.jpg 文件放在 src/public/ 目录中。\n至此，加载 .gltf 文件讲解完成。\n就这？明明就几行代码的事情，为什么还要花这样大的篇幅来讲解 .obj 和 .glb、gltf ？\n答：要想学得深入，就一定要知道原理，知道 obj 和 gltf 的差异，知其然也要知其所以然。\n我这里提供几个上找到的 glTF 文件资源，方便自己练习使用。\n一个黄色的小鸭子：\nhttps://vr.josh.earth/assets/models/duck/duck.gltf https://vr.josh.earth/assets/models/duck/duck.bin https://vr.josh.earth/assets/models/duck/duck.png 一个简易3D社区\nhttps://threejsfundamentals.org/threejs/resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf\n这个小区模型比较大，你需要适当调整一下镜头参数，才可以看清楚全貌\n一个酷酷的头盔\nhttps://cdn.khronos.org/assets/api/gltf/DamagedHelmet.glb\n一个宇航员\nhttps://modelviewer.dev/shared-assets/models/Astronaut.glb\n真的好酷！\n谷歌开源的一个JS库：model-viewer 在搜索 glTF 相关文章时，我无意中发现另外谷歌公司开源的一个 JS 项目： model-viewer\n项目 Github 地址：https://github.com/google/model-viewer\n项目官网：https://modelviewer.dev/\n项目介绍：Easily display interactive 3D models on the web \u0026 in AR\n简单来说就是：在 Web 或 AR 中，一个简单的用来显示 3D 模型的 JS 库。\n具体用法：\n确实够简单了，就是引入 viewer ，然后可以使用 标签插入模型渲染显示标签。\n简直和插入图片标签 没啥区别。\n交互效果：除了可以渲染出 3D 模型文件，还默认配备有类似 OrbitControls 相同的交互效果。\n兼容性：目前 苹果浏览器 Safari、火狐 Firefox 并不支持。\n至此，关于如何加载 glTF 文件已讲解完毕。\n但是有一点我们没有提到，就是使用 glTF 中自带的灯光、镜头、动画等内容。\n由于目前我还不会在 Blender 创建动画，所以这一块我们暂且保留，等待以后有机会再继续学习。\n在 Three.js 中，还有很多其他文件格式的加载器，我们就不逐个讲解了，具体的可以查阅官方文档。\n你以为本文结束了？没有！\n在上面示例中，我们实际上漏掉了一个非常重要的知识点：加载被压缩过的 .glb 文件\nglTF文件压缩和加载(解压)——Draco 在本文的示例中，所演示加载的 .glb 文件是我自己在 Blender 中创建导出的。\n如同图片文件一样，也有专门针对 .glb 文件压缩的工具，最为著名的就是谷歌公司开源的：draco\nDraco简介 Draco 是一种库，用于压缩和解压缩 3D 几何网格(geometric mesh) 和 点云(point cloud)\ndraco官网：https://google.github.io/draco/\ndraco源码：https://github.com/google/draco\ndraco 底层是使用 c++ 编写的。\ndraco 可以在不牺牲模型效果的前提下，将 .glb 文件压缩体积减小很多。\n就好像将普通文件压缩成 .zip 一样\n至于文件减少多少，这个暂时没有查询到\nDraco使用流程是 使用 Draco 将模型压缩，最终压缩后的文件格式为 .drc 或 .glb\nDraco 可以压缩众多 3D 格式文件，.glb 仅仅是其中一种\n在 .glb 文件内部有一个特殊字段，用来表述本文件是否经过了 draco 压缩\n当客户端(JS) 使用 GLTFLoader 去加载某个 .glb 文件时会去读取该标识\n若判断该 .glb 文件未被压缩则直接进行加载和解析\n若判断该 .glb 文件是被 draco 压缩过的，则会尝试调用 draco 解压类，下载 .glb 文件的同时进行解压，最终将下载、解压后的 .glb 数据传递给 GLTFLoader 使用\n这就引申出来一个事情：我们需要提前将负责 draco 解压的类传递给 GLTFLoader，具体如何做请看后面的讲解。\n如何使用 Draco 压缩 .glb 文件？ 具体如何操作实现，暂时我也没有学习，先搁置一下。\n敬请期待以后的更新\n如何在Three.js 中加载压缩过的 .glb 文件？ 关于 Draco 的介绍，可以查看 Three.js 对于 Draco 的介绍描述：\nhttps://github.com/mrdoob/three.js/tree/dev/examples/js/libs/draco\nThree.js 源码包中 draco 针对 gltf 文件的解压文件库：\ndraco/ 目录下有 4 个文件：draco_decoder.js、draco_decoder.wasm、draco_encoder.js、draco_wasm_wrapper.js\ndraco/gltf/ 目录下面同样有 4 个文件\n请注意 draco/ 和 draco/gltf/ 目录下的 4 个文件虽然是名字一样，但是他们内容并不相同。\n分别解释一下这 4 个文件：\ndraco_decoder.js\ndraco 解压(解码) 相关 js\ndraco_decoder.wasm\n.wasm 文件是 WebAssembly 解码器\n关于 WebAssembly 更多知识，请执行查阅：https://www.wasm.com.cn/\ndraco_encoder.js\ndraco 压缩(编码) 相关 js\ndraco_wasm_wrapper.js\n用于封装 .wasm 解码器的 js\n重点来了…\n第1步：拷贝 draco 文件到项目 public 中 我们将 Three.js 中 examples/js/libs/draco 目录拷贝到 React 项目的 public 目录中。\ndraco 属于第 3 方库，我们目前暂时采用拷贝到 public 目录中这种形式\n请记得一定拷贝的是 draco/，其中包含 draco/gltf/ 目录\n第2步：实例化一个 DRACOLoader，并传递给 GLTFLoader 关于 DRACOLoader 的详细解释，请参考官方文档：\nhttps://threejs.org/docs/#examples/zh/loaders/DRACOLoader\n我们将之前 GLTFLoader 的代码修改如下：\n+ import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader' const gltfLoader = new GLTFLoader() + const dracoLoader = new DRACOLoader() + dracoLoader.setDecoderPath('./examples/js/libs/draco/') + dracoLoader.setDecoderConfig({ type: 'js' }) + gltfLoader.setDRACOLoader(dracoLoader) gltfLoader.load('./model/vivo.glb', (gltf) =\u003e { scene.add(gltf.scene) }) 下面就针对上面 4 行核心代码进行解释说明：\nconst dracoLoader = new DRACOLoader()\n实例化一个 DRACOLoader\ndracoLoader.setDecoderPath('./examples/js/libs/draco/')\n设置 dracoLoader 应该去哪个目录里查找 解压(解码) 文件\ndracoLoader.setDecoderConfig({ type: 'js' })\n设置 dracoLoader 的配置项\ngltfLoader.setDRACOLoader(dracoLoader)\n将 dracoLoader 传递给 gltfLoader，供 gltfLoader 使用\n至此，结束！\n虽然 draco 非常复杂，但是对于我们使用者而言却很简单，仅仅上面 4 行代码即可实现加载被 draco 压缩过的 .glb 文件。\n加载.drc模型文件 在上面示例中，我们加载的是被 draco 压缩过的 .glb 文件。\n那如果是被 draco 压缩过的 .drc 文件呢？\n答：更加简单，直接使用 DRACOLoader即可。\nDRACOLoader使用示例代码如下：\nconst loader = new DRACOLoader(); loader.setDecoderPath( '/examples/js/libs/draco/' ); loader.preload(); loader.load('./xxx/model.drc', function ( geometry ) { const material = new THREE.MeshStandardMaterial( { color: 0x606060 } ); const mesh = new THREE.Mesh( geometry, material ); scene.add( mesh ); } } 补充说明：修改模型位置偏差 无论加载 .obj 文件，还是本章讲解的加载 .gltf 文件，假设模型在建模软件中位置中心并不是原点，而是非常偏远的位置。\n那么文件加载完成后，将模型添加到场景中，模型的位置并不在场景视角的中心位置，如果位置过于偏远，甚至有可能根本看不见模型。\n我们可以通过以下方式，计算模型的位置偏差，并修正模型的位置，使其出现在视野中心位置。\nconst loader = new GLTFLoader() loader.load('./model/lddq.gltf', (gltf) =\u003e { const group = gltf.scene const box = new Three.Box3().setFromObject(group) const center = box.getCenter(new Three.Vector3()) group.position.x += (group.position.x - center.x) group.position.y += (group.position.y - center.y) group.position.z += (group.position.z - center.z) scene.add(group) }) Box3 的介绍请执行查阅官方文档。\n下一章节，我们要学习如何添加 场景背景，呵， VR 看房效果要来了！\n","wordCount":"4982","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/24-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>24 Three.js解决方案之加载.gltf模型</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>10 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e5%b8%b8%e8%a7%81-3d-%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f-%e5%92%8c-gltf-%e7%9a%84%e5%8c%ba%e5%88%ab aria-label="常见 3D 文件格式 和 gltf 的区别">常见 3D 文件格式 和 gltf 的区别</a><ul><li><a href=#gltf%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f%e7%ae%80%e4%bb%8b aria-label=GLTF文件格式简介>GLTF文件格式简介</a></li><li><a href=#%e5%9c%a8blender%e4%b8%ad%e5%af%bc%e5%87%bagltf%e6%96%87%e4%bb%b6 aria-label=在Blender中导出gltf文件>在Blender中导出gltf文件</a><ul><li><a href=#gltf%e6%98%af%e4%b8%80%e7%a7%8d3d%e6%96%87%e4%bb%b6%e6%a0%bc%e5%bc%8f%e8%a7%84%e8%8c%83%e4%bd%86%e6%98%af%e5%8d%b4%e6%9c%89-3-%e7%a7%8d%e8%a1%a8%e7%8e%b0%e5%bd%a2%e5%bc%8f aria-label="GLTF是一种3D文件格式规范，但是却有 3 种表现形式">GLTF是一种3D文件格式规范，但是却有 3 种表现形式</a></li></ul></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8gltfloader%e5%8a%a0%e8%bd%bdgltf%e6%96%87%e4%bb%b6%e7%9a%84%e7%a4%ba%e4%be%8b aria-label=使用GLTFLoader加载glTF文件的示例>使用GLTFLoader加载glTF文件的示例</a></li><li><a href=#%e8%b0%b7%e6%ad%8c%e5%bc%80%e6%ba%90%e7%9a%84%e4%b8%80%e4%b8%aajs%e5%ba%93model-viewer aria-label=谷歌开源的一个JS库：model-viewer>谷歌开源的一个JS库：model-viewer</a></li><li><a href=#gltf%e6%96%87%e4%bb%b6%e5%8e%8b%e7%bc%a9%e5%92%8c%e5%8a%a0%e8%bd%bd%e8%a7%a3%e5%8e%8bdraco aria-label=glTF文件压缩和加载(解压)——Draco>glTF文件压缩和加载(解压)——Draco</a><ul><li><a href=#draco%e7%ae%80%e4%bb%8b aria-label=Draco简介>Draco简介</a><ul><li><a href=#draco%e4%bd%bf%e7%94%a8%e6%b5%81%e7%a8%8b%e6%98%af aria-label=Draco使用流程是>Draco使用流程是</a></li><li><a href=#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-draco-%e5%8e%8b%e7%bc%a9-glb-%e6%96%87%e4%bb%b6 aria-label="如何使用 Draco 压缩 .glb 文件？">如何使用 Draco 压缩 .glb 文件？</a></li><li><a href=#%e5%a6%82%e4%bd%95%e5%9c%a8threejs-%e4%b8%ad%e5%8a%a0%e8%bd%bd%e5%8e%8b%e7%bc%a9%e8%bf%87%e7%9a%84-glb-%e6%96%87%e4%bb%b6 aria-label="如何在Three.js 中加载压缩过的 .glb 文件？">如何在Three.js 中加载压缩过的 .glb 文件？</a></li><li><a href=#%e7%ac%ac1%e6%ad%a5%e6%8b%b7%e8%b4%9d-draco-%e6%96%87%e4%bb%b6%e5%88%b0%e9%a1%b9%e7%9b%ae-public-%e4%b8%ad aria-label="第1步：拷贝 draco 文件到项目 public 中">第1步：拷贝 draco 文件到项目 public 中</a></li><li><a href=#%e7%ac%ac2%e6%ad%a5%e5%ae%9e%e4%be%8b%e5%8c%96%e4%b8%80%e4%b8%aa-dracoloader%e5%b9%b6%e4%bc%a0%e9%80%92%e7%bb%99-gltfloader aria-label="第2步：实例化一个 DRACOLoader，并传递给 GLTFLoader">第2步：实例化一个 DRACOLoader，并传递给 GLTFLoader</a></li></ul></li></ul></li><li><a href=#%e5%8a%a0%e8%bd%bddrc%e6%a8%a1%e5%9e%8b%e6%96%87%e4%bb%b6 aria-label=加载.drc模型文件>加载.drc模型文件</a></li><li><a href=#%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e%e4%bf%ae%e6%94%b9%e6%a8%a1%e5%9e%8b%e4%bd%8d%e7%bd%ae%e5%81%8f%e5%b7%ae aria-label=补充说明：修改模型位置偏差>补充说明：修改模型位置偏差</a></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>上一章节，我们讲解了加载 .obj 模型，本文将讲解加载 .gltf 模型。</p><blockquote><p>注：虽然我们标题写的是 “加载.gltf模型”，但更加准确地说法应该是 &ldquo;加载 gtTF 文件&rdquo;</p></blockquote><br><p>首先我们先回顾一下 .obj 文件格式的模型一些特征：文件格式简单(纯文本)、除模型外无法提供其他场景元素(例如摄像机、灯光等)。</p><p>本文要讲解的 .gltf 格式文件可以包含的数据内容和类型要比 .obj 多很多。</p><br><h2 id=常见-3d-文件格式-和-gltf-的区别>常见 3D 文件格式 和 gltf 的区别<a hidden class=anchor aria-hidden=true href=#常见-3d-文件格式-和-gltf-的区别>#</a></h2><p><strong>我们先将常见的 3D文件格式进行划分</strong></p><p><strong>第1类(原始文件)：</strong></p><p>3D 建模软件本身特有的、原始的文件格式，例如：</p><ol><li>Blender 对应的是 .blend</li><li>3D Max 对应的是 .max</li><li>Maya 对应的是 .ma</li><li>C4D 对应的是 .c4d</li></ol><br><p><strong>第2类(中转文件)：</strong></p><p>多个 3D 建模软件彼此都可以打开，能够读取的文件格式，例如：</p><ol><li>.obj</li><li>.dae</li><li>.fbx</li></ol><blockquote><p>所谓“中转”，是指这些格式的作用实际上相当于将某个模型从 A 软件 导出 然后再 B 软件中可以打开并读取。</p></blockquote><br><p><strong>第3类(特定格式)：</strong></p><p>某些 3D 应用独有的文件格式。</p><p>例如王者荣耀这款游戏中 3D 模型就可能是自己独有的文件格式。</p><br><p><strong>第4类(传输格式)：</strong></p><blockquote><p>这里的 “传输” 是英文单词 “Transmission” 的翻译</p></blockquote><p>gltf 就属于传输格式类型的文件。gltf格式可以做到其他格式都无法做到的事情。</p><br><h3 id=gltf文件格式简介>GLTF文件格式简介<a hidden class=anchor aria-hidden=true href=#gltf文件格式简介>#</a></h3><p><strong>GLTF是英文：Graphics Language Transmission Format 的缩写</strong></p><blockquote><p>WebGL、OpenGL 中的 “GL” 和 GLTF 中的 “GL” 是相同的单词。</p></blockquote><p><strong>GLTF中文全称为：图形语言传输格式</strong></p><blockquote><p>GLTF 本身就是由 OpenGL 和 Vulkan 背后的 3D 图形标准组织 Khronos 定义的。</p></blockquote><p>所以你可以想象得到，gltf 本身就是为了网络传输、浏览器渲染 3D 而生的。</p><p>关于更多 gltf 信息，可以查看其官网：<a href=https://www.khronos.org/gltf/>https://www.khronos.org/gltf/</a></p><br><p><strong>GLTF的支持度：几乎所有的 Web 3D 图形框架都支持 GLTF</strong></p><blockquote><p>除了 Three.js 框架外 ，其他 3D JS 引擎框架也都支持 GLTF</p></blockquote><br><p><strong>gltf优点 1：体积小，便于传输</strong></p><p>gltf 文件中模型的数据都以二进制存储，当下载(使用) gltf 文件时可以将这些二进制数据直接在 GPU 中使用。</p><p>反观 vrml、.obj 或 .dae 等格式，他们是将数据存储为文本(例如纯文本或JSON格式)，也就是说 GPU 在读取这些模型文件时还需要进行文本解析。</p><p>在文件体积方面，通常相同的模型顶点数据如果用文本形式存储，要比二进制存储体积大 3 到 5 倍。</p><br><p><strong>gltf优点 2：直接渲染</strong></p><p>gltf 文件中模型的数据是直接要渲染的，而不是要再次编辑的。</p><blockquote><p>换句话说 gltf 文件中的模型是不可以再次编辑的</p></blockquote><blockquote><p>而其他类型的文件，例如 .obj 中模型是可以在 Three.js 中加载完成后二次编辑的</p></blockquote><blockquote><p>你可以简单的把 gltf 想象成 jpg 图片，而其他格式的 3D 文件是 PSD 文件，当我们仅仅是为了看到图片，无需编辑该图片时，肯定是 .jpg 图片体积小，打开速度快。</p></blockquote><p>正因为是不可编辑，所以一些对于渲染而言不重要的数据通常都已被删除，例如多边形都已转化为三角形。</p><br><p><strong>gltf优点 3：内嵌材质信息</strong></p><p>gltf 文件中模型的材质信息是被内嵌进去。</p><p>请注意我们这里说的是 “材质信息”，也就是相当于 .obj 对应的 .mtl 中的数据，但是对于纹理图片资源(xxx.jpg)本身来说，并不会内嵌进去。</p><blockquote><p>所以，这里隐含的一个事情就是，我们依然需要将 .gltf 文件对应的纹理图片资源 .jpg 放在 pulic 目录中。</p></blockquote><br><p><strong>结论：gltf 格式非常有针对性，是专门为渲染而设计的，文件体积小，且 GPU 读取快速。</strong></p><p><strong>因此，推荐使用 gltf 格式。</strong></p><br><h3 id=在blender中导出gltf文件>在Blender中导出gltf文件<a hidden class=anchor aria-hidden=true href=#在blender中导出gltf文件>#</a></h3><p>讲了这么多 gltf 文件的优点，那么我们打开之前创建的 hello.blend 文件，导出一下 gltf 文件看看。</p><p><strong>导出步骤：</strong></p><ol><li><p>打开 hello.blend</p></li><li><p>文件 > 导出 > glTF 2.0(.glb/.gltf)</p></li><li><p>在弹窗对话框中，使用默认导出项，我们直接点 <code>导出</code></p><blockquote><p>尽管我们使用的是默认导出项，但是还请你留意一下这几项内容：</p><p><code>包括</code>：选定的物体(未勾选)、自定义属性(未勾选)、相机(未勾选)、精确灯光(未勾选)</p><p><code>变换</code>：Y 向上(已勾选)</p><p><code>几何数据</code>: 应用修改器(未勾选)、UV(已勾选)、法向(已勾选)、切向(未勾选)、顶点色(已勾选)、材质(导出)、图像(自动)、压缩(未勾选)</p><p><code>动画</code>：动画(已勾选)、形态键(已勾选)、蒙皮(已勾选)</p><blockquote><p>尽管我们创建的 hello.blend 中并未设置任何动画，你可以选择取消动画相关的勾选</p></blockquote></blockquote></li></ol><br><p>此时去导出目录里，我们会发现多出来了一个 <code>hello.glb</code> 的文件。</p><blockquote><p>特别强调：由于纹理图片资源 metal_texture.jpg 本身就在目录中，所以我们只是从直观上感觉多出了 1 个文件而已。</p></blockquote><br><p><strong>.glb ？不是 .gltf ？</strong></p><p>额~，别着急，我们补充一下 GLTF 格式的知识。</p><br><h4 id=gltf是一种3d文件格式规范但是却有-3-种表现形式>GLTF是一种3D文件格式规范，但是却有 3 种表现形式<a hidden class=anchor aria-hidden=true href=#gltf是一种3d文件格式规范但是却有-3-种表现形式>#</a></h4><p><strong>3 种表现形式分别为：分离式、二进制、嵌入式</strong></p><p><strong>第1种表现形式(分离式)：.gltf + .bin + 纹理贴图资源(.jpg、.png)</strong></p><ol><li><p>gltf：3D 场景的所有概要信息，包括灯光、纹理贴图等信息</p><blockquote><p>该文件的内容具体形式为 JSON</p></blockquote></li><li><p>.bin：模型的二进制数据</p></li><li><p>纹理贴图资源：这个就不多说了，就是纹理图片 xxx.jpg 或 .png</p></li></ol><br><p><strong>第2种表现形式(二进制)：.glb</strong></p><p>.glb：包含场景所有的信息的二进制数据。</p><blockquote><p>.glb === .gltf + .bin + 纹理图片资源</p></blockquote><br><p><strong>第3种表现形式(嵌入式)：.gltf</strong></p><p>.gltf：以 JSON 形式保存所有场景信息数据，包括材质和纹理信息。</p><blockquote><p>这种形式由于文件内容是 json，因此是可以通过文本再次编辑的</p></blockquote><br><p><strong>Blender 默认导出 glTF 2.0 格式时，采用的是 .glb 后缀形式。</strong></p><p>想要更改成别的导出形式，我们可以在 Blender 导出项 <code>格式</code>下拉框中更改为 “.gltf 分离(.gltf + .bin + 纹理)” 或 &ldquo;glTF嵌入式(.gltf)"。</p><p>那么此时<strong>导出的文件格式就是 .gltf 后缀形式。</strong></p><br><p><strong>3种形式的对比：</strong></p><blockquote><p>以下纯粹是我个人的观点，仅供参考</p></blockquote><p>比较常见的是前 2 种：分离式(.gltf + .bin + 纹理)、二进制形式(.glb)</p><p>如果你的项目中，模型数据不会发生变化，但是纹理贴图可能容易发生变化，那么可以选择 分离式的。</p><blockquote><p>分离式的贴图资源本身就是单独存在的，因此方便替换修改。</p></blockquote><p>如果你是要发送给其他人使用、且不会发生材质变更的，则可以采用 .glb 形式的。</p><blockquote><p>由于所有数据都只在 .glb 文件中，就 1 个文件也利于文件发送。</p></blockquote><br><p>补充一点：有一个网站 <a href=https://gltf-viewer.donmccurdy.com/>https://gltf-viewer.donmccurdy.com/</a> ，他可以提供 .glb 文件在线预览。</p><p>同时在 NPM 上面，有很多针对 .glb 和 .gltf 格式互转的工具包，例如：<a href=https://www.npmjs.com/package/gltf-import-export>gltf-import-export</a></p><br><p>对于 Three.js 来说，加载 glTF 格式的文件，无论哪种形式，均支持。</p><br><h2 id=使用gltfloader加载gltf文件的示例>使用GLTFLoader加载glTF文件的示例<a hidden class=anchor aria-hidden=true href=#使用gltfloader加载gltf文件的示例>#</a></h2><p>在 Three.js 中负责加载 glTF 格式文件的加载器为 GLTFLoader。</p><p>用法和之前 OBJLoader 用法完全相同，废话不多说，直接看代码。</p><br><p>我们先加载 .glb 格式的文件，代码如下：</p><p>src/components/hello-gltfloader</p><blockquote><p>由于 .glb 文件是单独 1 个存在，所以我们这次可以将 hello.glb 文件放在 src/assces/model/ 目录下了。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { GLTFLoader } from &#34;three/examples/jsm/loaders/GLTFLoader&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const loader = new GLTFLoader()
</span></span><span style=display:flex><span>loader.load(require(&#39;@/assets/model/hello.glb&#39;).default, (gltf) =&gt; {
</span></span><span style=display:flex><span>    scene.add(gltf.scene)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><blockquote><p>请注意当加载完成后，执行的是 scene.add(gltf.scene)</p><p>加载完成得到的 gltf 中包含的数据有：</p><ol><li>gltf.animations; // Array&lt;THREE.AnimationClip></li><li>gltf.scene; // THREE.Group</li><li>gltf.scenes; // Array&lt;THREE.Group></li><li>gltf.cameras; // Array&lt;THREE.Camera></li><li>gltf.asset; // Object</li></ol><p>我们此刻只是将 gltf.scene 添加到了场景中而已，其他数据暂时并未使用到。</p></blockquote><br><p>和加载 .glb 类似，如果我们的 3D 数据文件为 分离式的 .gltf，则将上述代码修改为：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>loader.load(&#39;./model/hello.gltf&#39;, (gltf) =&gt; {
</span></span><span style=display:flex><span>    scene.add(gltf.scene)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><blockquote><p>注意：我们只需将 hello.gltf 传递给 loader 即可，loader 会读取 .gltf 中的数据，自动去加载对应的 hello.bin 和 纹理图片 hello.jpg。</p></blockquote><blockquote><p>由于牵扯到不同的文件 webpack 编译，所以我们选择将 .gltf、.bin、.jpg 文件放在 src/public/ 目录中。</p></blockquote><br><p>至此，加载 .gltf 文件讲解完成。</p><p>就这？明明就几行代码的事情，为什么还要花这样大的篇幅来讲解 .obj 和 .glb、gltf ？</p><p>答：要想学得深入，就一定要知道原理，知道 obj 和 gltf 的差异，知其然也要知其所以然。</p><br><p>我这里提供几个上找到的 glTF 文件资源，方便自己练习使用。</p><p><strong>一个黄色的小鸭子：</strong></p><ol><li><a href=https://vr.josh.earth/assets/models/duck/duck.gltf>https://vr.josh.earth/assets/models/duck/duck.gltf</a></li><li><a href=https://vr.josh.earth/assets/models/duck/duck.bin>https://vr.josh.earth/assets/models/duck/duck.bin</a></li><li><a href=https://vr.josh.earth/assets/models/duck/duck.png>https://vr.josh.earth/assets/models/duck/duck.png</a></li></ol><br><p><strong>一个简易3D社区</strong></p><p><a href=https://threejsfundamentals.org/threejs/resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf>https://threejsfundamentals.org/threejs/resources/models/cartoon_lowpoly_small_city_free_pack/scene.gltf</a></p><blockquote><p>这个小区模型比较大，你需要适当调整一下镜头参数，才可以看清楚全貌</p></blockquote><br><p><strong>一个酷酷的头盔</strong></p><p><a href=https://cdn.khronos.org/assets/api/gltf/DamagedHelmet.glb>https://cdn.khronos.org/assets/api/gltf/DamagedHelmet.glb</a></p><br><p><strong>一个宇航员</strong></p><p><a href=https://modelviewer.dev/shared-assets/models/Astronaut.glb>https://modelviewer.dev/shared-assets/models/Astronaut.glb</a></p><blockquote><p>真的好酷！</p></blockquote><br><h2 id=谷歌开源的一个js库model-viewer>谷歌开源的一个JS库：model-viewer<a hidden class=anchor aria-hidden=true href=#谷歌开源的一个js库model-viewer>#</a></h2><p>在搜索 glTF 相关文章时，我无意中发现另外谷歌公司开源的一个 JS 项目： model-viewer</p><p>项目 Github 地址：<a href=https://github.com/google/model-viewer>https://github.com/google/model-viewer</a></p><p>项目官网：<a href=https://modelviewer.dev/>https://modelviewer.dev/</a></p><p>项目介绍：Easily display interactive 3D models on the web & in AR</p><blockquote><p>简单来说就是：在 Web 或 AR 中，一个简单的用来显示 3D 模型的 JS 库。</p></blockquote><br><p>具体用法：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&lt;script type=&#34;module&#34; src=&#34;https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js&#34;&gt;&lt;/script&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;model-viewer src=&#34;shared-assets/models/Astronaut.glb&#34; alt=&#34;A 3D model of an astronaut&#34; auto-rotate camera-controls&gt;&lt;/model-viewer&gt;
</span></span></code></pre></div><blockquote><p>确实够简单了，就是引入 viewer ，然后可以使用 <model-viewer>标签插入模型渲染显示标签。</p><p>简直和插入图片标签 <img> 没啥区别。</p></blockquote><br><p>交互效果：除了可以渲染出 3D 模型文件，还默认配备有类似 OrbitControls 相同的交互效果。</p><br><p>兼容性：目前 苹果浏览器 Safari、火狐 Firefox 并不支持。</p><br><p>至此，关于如何加载 glTF 文件已讲解完毕。</p><p><strong>但是有一点我们没有提到，就是使用 glTF 中自带的灯光、镜头、动画等内容。</strong></p><p>由于目前我还不会在 Blender 创建动画，所以这一块我们暂且保留，等待以后有机会再继续学习。</p><br><p>在 Three.js 中，还有很多其他文件格式的加载器，我们就不逐个讲解了，具体的可以查阅官方文档。</p><br><p>你以为本文结束了？没有！</p><p>在上面示例中，我们实际上漏掉了一个非常重要的知识点：加载被压缩过的 .glb 文件</p><br><h2 id=gltf文件压缩和加载解压draco>glTF文件压缩和加载(解压)——Draco<a hidden class=anchor aria-hidden=true href=#gltf文件压缩和加载解压draco>#</a></h2><p>在本文的示例中，所演示加载的 .glb 文件是我自己在 Blender 中创建导出的。</p><p>如同图片文件一样，也有专门针对 .glb 文件压缩的工具，最为著名的就是谷歌公司开源的：draco</p><h3 id=draco简介>Draco简介<a hidden class=anchor aria-hidden=true href=#draco简介>#</a></h3><p>Draco 是一种库，用于压缩和解压缩 3D 几何网格(geometric mesh) 和 点云(point cloud)</p><p>draco官网：<a href=https://google.github.io/draco/>https://google.github.io/draco/</a></p><p>draco源码：<a href=https://github.com/google/draco>https://github.com/google/draco</a></p><br><p>draco 底层是使用 c++ 编写的。</p><p>draco 可以在不牺牲模型效果的前提下，将 .glb 文件压缩体积减小很多。</p><blockquote><p>就好像将普通文件压缩成 .zip 一样</p></blockquote><blockquote><p>至于文件减少多少，这个暂时没有查询到</p></blockquote><br><h4 id=draco使用流程是>Draco使用流程是<a hidden class=anchor aria-hidden=true href=#draco使用流程是>#</a></h4><ol><li><p>使用 Draco 将模型压缩，最终压缩后的文件格式为 .drc 或 .glb</p><blockquote><p>Draco 可以压缩众多 3D 格式文件，.glb 仅仅是其中一种</p></blockquote></li><li><p>在 .glb 文件内部有一个特殊字段，用来表述本文件是否经过了 draco 压缩</p></li><li><p>当客户端(JS) 使用 GLTFLoader 去加载某个 .glb 文件时会去读取该标识</p></li><li><p>若判断该 .glb 文件未被压缩则直接进行加载和解析</p></li><li><p>若判断该 .glb 文件是被 draco 压缩过的，则会尝试调用 draco 解压类，下载 .glb 文件的同时进行解压，最终将下载、解压后的 .glb 数据传递给 GLTFLoader 使用</p><blockquote><p>这就引申出来一个事情：我们需要提前将负责 draco 解压的类传递给 GLTFLoader，具体如何做请看后面的讲解。</p></blockquote></li></ol><br><h4 id=如何使用-draco-压缩-glb-文件>如何使用 Draco 压缩 .glb 文件？<a hidden class=anchor aria-hidden=true href=#如何使用-draco-压缩-glb-文件>#</a></h4><p>具体如何操作实现，暂时我也没有学习，先搁置一下。</p><blockquote><p>敬请期待以后的更新</p></blockquote><br><h4 id=如何在threejs-中加载压缩过的-glb-文件>如何在Three.js 中加载压缩过的 .glb 文件？<a hidden class=anchor aria-hidden=true href=#如何在threejs-中加载压缩过的-glb-文件>#</a></h4><p>关于 Draco 的介绍，可以查看 Three.js 对于 Draco 的介绍描述：</p><p><a href=https://github.com/mrdoob/three.js/tree/dev/examples/js/libs/draco>https://github.com/mrdoob/three.js/tree/dev/examples/js/libs/draco</a></p><p>Three.js 源码包中 draco 针对 gltf 文件的解压文件库：</p><ol><li><p>draco/ 目录下有 4 个文件：draco_decoder.js、draco_decoder.wasm、draco_encoder.js、draco_wasm_wrapper.js</p></li><li><p>draco/gltf/ 目录下面同样有 4 个文件</p><blockquote><p>请注意 draco/ 和 draco/gltf/ 目录下的 4 个文件虽然是名字一样，但是他们内容并不相同。</p></blockquote></li></ol><p>分别解释一下这 4 个文件：</p><ol><li><p>draco_decoder.js</p><blockquote><p>draco 解压(解码) 相关 js</p></blockquote></li><li><p>draco_decoder.wasm</p><blockquote><p>.wasm 文件是 WebAssembly 解码器</p><p>关于 WebAssembly 更多知识，请执行查阅：<a href=https://www.wasm.com.cn/>https://www.wasm.com.cn/</a></p></blockquote></li><li><p>draco_encoder.js</p><blockquote><p>draco 压缩(编码) 相关 js</p></blockquote></li><li><p>draco_wasm_wrapper.js</p><blockquote><p>用于封装 .wasm 解码器的 js</p></blockquote></li></ol><p>重点来了&mldr;</p><br><h4 id=第1步拷贝-draco-文件到项目-public-中>第1步：拷贝 draco 文件到项目 public 中<a hidden class=anchor aria-hidden=true href=#第1步拷贝-draco-文件到项目-public-中>#</a></h4><p>我们将 Three.js 中 examples/js/libs/draco 目录拷贝到 React 项目的 public 目录中。</p><blockquote><p>draco 属于第 3 方库，我们目前暂时采用拷贝到 public 目录中这种形式</p><p>请记得一定拷贝的是 draco/，其中包含 draco/gltf/ 目录</p></blockquote><h4 id=第2步实例化一个-dracoloader并传递给-gltfloader>第2步：实例化一个 DRACOLoader，并传递给 GLTFLoader<a hidden class=anchor aria-hidden=true href=#第2步实例化一个-dracoloader并传递给-gltfloader>#</a></h4><blockquote><p>关于 DRACOLoader 的详细解释，请参考官方文档：</p><p><a href=https://threejs.org/docs/#examples/zh/loaders/DRACOLoader>https://threejs.org/docs/#examples/zh/loaders/DRACOLoader</a></p></blockquote><br><p>我们将之前 GLTFLoader 的代码修改如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ import { DRACOLoader } from &#39;three/examples/jsm/loaders/DRACOLoader&#39;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>
</span></span><span style=display:flex><span> const gltfLoader = new GLTFLoader()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ const dracoLoader = new DRACOLoader()
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ dracoLoader.setDecoderPath(&#39;./examples/js/libs/draco/&#39;)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ dracoLoader.setDecoderConfig({ type: &#39;js&#39; })
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ gltfLoader.setDRACOLoader(dracoLoader)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>
</span></span><span style=display:flex><span> gltfLoader.load(&#39;./model/vivo.glb&#39;, (gltf) =&gt; {
</span></span><span style=display:flex><span>     scene.add(gltf.scene)
</span></span><span style=display:flex><span> })
</span></span></code></pre></div><br><p>下面就针对上面 4 行核心代码进行解释说明：</p><ol><li><p><code>const dracoLoader = new DRACOLoader()</code></p><p>实例化一个 DRACOLoader</p></li><li><p><code>dracoLoader.setDecoderPath('./examples/js/libs/draco/')</code></p><p>设置 dracoLoader 应该去哪个目录里查找 解压(解码) 文件</p></li><li><p><code>dracoLoader.setDecoderConfig({ type: 'js' })</code></p><p>设置 dracoLoader 的配置项</p></li><li><p><code>gltfLoader.setDRACOLoader(dracoLoader)</code></p><p>将 dracoLoader 传递给 gltfLoader，供 gltfLoader 使用</p></li></ol><p>至此，结束！</p><br><p>虽然 draco 非常复杂，但是对于我们使用者而言却很简单，仅仅上面 4 行代码即可实现加载被 draco 压缩过的 .glb 文件。</p><br><h2 id=加载drc模型文件>加载.drc模型文件<a hidden class=anchor aria-hidden=true href=#加载drc模型文件>#</a></h2><p>在上面示例中，我们加载的是被 draco 压缩过的 .glb 文件。</p><p>那如果是被 draco 压缩过的 .drc 文件呢？</p><p>答：更加简单，直接使用 DRACOLoader即可。</p><br><p>DRACOLoader使用示例代码如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const loader = new DRACOLoader();
</span></span><span style=display:flex><span>loader.setDecoderPath( &#39;/examples/js/libs/draco/&#39; );
</span></span><span style=display:flex><span>loader.preload();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>loader.load(&#39;./xxx/model.drc&#39;,
</span></span><span style=display:flex><span> function ( geometry ) {
</span></span><span style=display:flex><span>  const material = new THREE.MeshStandardMaterial( { color: 0x606060 } );
</span></span><span style=display:flex><span>  const mesh = new THREE.Mesh( geometry, material );
</span></span><span style=display:flex><span>  scene.add( mesh );
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><br><h2 id=补充说明修改模型位置偏差>补充说明：修改模型位置偏差<a hidden class=anchor aria-hidden=true href=#补充说明修改模型位置偏差>#</a></h2><p>无论加载 .obj 文件，还是本章讲解的加载 .gltf 文件，假设模型在建模软件中位置中心并不是原点，而是非常偏远的位置。</p><p>那么文件加载完成后，将模型添加到场景中，模型的位置并不在场景视角的中心位置，如果位置过于偏远，甚至有可能根本看不见模型。</p><p>我们可以通过以下方式，计算模型的位置偏差，并修正模型的位置，使其出现在视野中心位置。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const loader = new GLTFLoader()
</span></span><span style=display:flex><span>loader.load(&#39;./model/lddq.gltf&#39;, (gltf) =&gt; {
</span></span><span style=display:flex><span>    const group = gltf.scene
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const box = new Three.Box3().setFromObject(group)
</span></span><span style=display:flex><span>    const center = box.getCenter(new Three.Vector3())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    group.position.x += (group.position.x - center.x)
</span></span><span style=display:flex><span>    group.position.y += (group.position.y - center.y)
</span></span><span style=display:flex><span>    group.position.z += (group.position.z - center.z)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    scene.add(group)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><blockquote><p>Box3 的介绍请执行查阅官方文档。</p></blockquote><br><p>下一章节，我们要学习如何添加 场景背景，呵， VR 看房效果要来了！</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/23-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/><span class=title>« Prev</span><br><span>23 Three.js解决方案之加载.obj模型</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/25-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E6%B7%BB%E5%8A%A0%E8%83%8C%E6%99%AF%E5%92%8C%E5%A4%A9%E7%A9%BA%E7%9B%92/><span class=title>Next »</span><br><span>25 Three.js解决方案之添加背景和天空盒</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>