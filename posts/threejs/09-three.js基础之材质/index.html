<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>09 Three.js基础之材质 | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="09 Three.js基础之材质 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/09-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/><link crossorigin=anonymous href=/assets/css/stylesheet.241265d51339977eb0f90d05780e286ec2789600ca4137f29552dec9dee06569.css integrity="sha256-JBJl1RM5l36w+Q0FeA4obsJ4lgDKQTfylVLeyd7gZWk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="09 Three.js基础之材质"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/09-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="09 Three.js基础之材质"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"09 Three.js基础之材质","item":"https://bablvsj.github.io/posts/threejs/09-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"09 Three.js基础之材质","name":"09 Three.js基础之材质","description":"","keywords":["Three.js"],"articleBody":"材质(material) 即 线段属性或物体表面的一些颜色、贴图、光亮程度、反光特性、粗糙度等属性。\n按照用途，所以材质大体上可以划分为：\n点材质(应用来点、粒子上) 线性材质(应用在线段或虚线上) 基础材质(应用在面上的各种材质) 特殊用途的材质(例如阴影) 自定义材质 上面的分类划分，仅仅是我个人观点，事实上并没有明确的种类划分规定。\n材质基础 材质名称 解释说明 Material 所有材质的父类 点材质 材质名称 解释说明 PointsMaterial 点材质(粒子材质) 线性材质 材质名称 解释说明 LineBasicMaterial 线段材质(颜色、宽度、断点、连接点等属性) LineDashedMaterial 虚线材质 基础材质(针对”面“) 材质名称 解释说明 MeshBasicMaterial 最基础的材质，不反射光，仅显示材质本身颜色 MeshLambertMaterial 仅顶点处反射光 MeshMatcapMaterial 自带光效(明暗)的材质 MeshPhongMaterial 任何点都反射光，拥有光泽度 MeshToonMaterial 卡通着色 MeshStandardMaterial 除光泽度外，还有粗糙度和金属度 MeshPhysicalMaterial 除光泽度、粗糙度、金属度外，还有清漆度和清漆粗糙度 特殊用途材质 材质名称 解释说明 ShadowMaterial 阴影材质 MeshDistanceMaterial 另外一种阴影投射材质 MeshDeptMaterial 远近距离深度着色材质 MeshNormalMaterial 网格法向量材质 SpriteMaterial 精灵材质/雪碧材质 自定义材质 材质名称 解释说明 ShaderMaterial 着色器材质 RawShaderMaterial 原始着色器材质 注意：本文只是大体上讲解一些 Three.js 中的各个材质特性，具体每个材质的详细参数和用法，需要自己查阅 Three.js 官方文档：https://threejs.org/docs/index.html#api/zh/materials/Material\n点材质：PointsMaterial PointsMaterial：点材质/粒子材质 用来创建 粒子 材质。\n线性材质：LineBasicMaterial、LineDashedMaterial LineBasicMaterial：基础的线段材质 用来创建 线段 的材质，属性包括：颜色、宽度、断点、连接点等。\nLineDashedMaterial：虚线材质 LineDashedMaterial 继承于 LineBasicMaterial，用来绘制虚线。\n基础材质讲解说明 Three.js 中基础材质类型，我们先从 MeshPhongMaterial 说起。\n为什么要先讲 MeshPhongMaterial？ 因为 MeshPhongMaterial 是使用最频繁，且处于特殊位置的材质。\nMeshPhongMaterial 可以作为其他材质的参考对象：\n比 MeshPhongMaterial 简单的有 MeshBasicMaterial、MeshLambertMaterial 和 MeshPhongMaterial 相似的有 MeshToonMaterial 比 MeshPhongMaterial 复杂的有 MeshStandardMaterial、MeshPhysicalMaterial MeshPhongMaterial Phong光照模型 Phong光照模型是最简单、最基础的光照模型，该模型只考虑物体对直线光的反射作用，不考虑物体之间的漫反射光(环境光)。\nPhong的假设前提 物体通常被设置为不透明 物体表面反射率相同 Phone的简单用法 新建一个 MeshPhongMaterial\nconst material = new Three.MeshPhongMaterial({ color:0xFF0000, flatShading:true }) 或者\nconst material = new Three.MeshPhoneMaterial() material.color.set(0xFF0000) material.flatShading = true 设置颜色的N种方式：\nnew Three.MeshPhoneMaterial({color:0xFF0000}) new Three.MeshPhoneMaterial({color:'red'}) new Three.MeshPhoneMaterial({color:'#F00'}) new Three.MeshPhoneMaterial({color:'rgb(255,0,0)'}) new Three.MeshPhoneMaterial({color:'hsl(0,100%,50%)'}) 修改颜色：\nmaterial.color.set(0xFF0000) material.color.set('red') material.color.set('#F00') material.color.set('rgb(255,0,0)') material.color.set('hsl(0,100%,50%)') material.color.setHSL(0,1,0.5) material.color.setRGB(1,0,0) Phong的属性：flatShading(平面着色) 特别强调：flatShading 属性并不是由 MeshPhongMaterial 定义的，而是有父类 Material 定义的。\n只不过由于 flatShading 比较重要，因此这里特别讲解一下该属性的作用。\nflatShading 的值为 布尔值，该值指 是否启用 平面着色 模式。\n默认值为 false，即不启用 平面着色 模式。\n补充说明 3 大着色模式 什么叫 着色？\n在三维图形学中，“着色” 的含义为：根据光照条件重建 物体各表面明暗效果的过程，就叫着色。\n这个 “着色” 过程中，就牵扯到不同的着色算法，也就是不同的着色模式。\n最常见的 3 种着色算法(模式) Flat Shading：平面着色\n根据每个三角形的法线计算着色效果，每个面只计算一次，也就是说相同的面采用同一个计算结果。\n这种模式对于 立方体 来说会减小计算量，因为立方体每个面都是平整且唯一的。\nGouraud Shading：逐顶着色\n针对每个顶点计算，而后对每个顶点的结果颜色进行线性插值得到片源的颜色。\nPhong Shading：补色渲染\n对每个三角形的每个片元进行着色计算。所以 Phong Shading 又被称为 逐片元着色\n由于颜色是按片元着色的，得到的结果比 逐顶着色(Gouraud Shading) 要更加细腻，尤其是用于光亮表面效果更加真实。\nPhong 并不是传统的英文单词，而是 生活在美国的越南籍科学家 Bui Tuong Phong (裴祥风) 的名字。\n所以 Phong Shading 又被称为 冯氏着色。\n以下内容更新于 2022.02.02\n在图形学中有一个被应用非常广泛的简单光照模型：冯氏光照模型\n注：这里的 简单 是指计算量非常小，但却可以模拟出简单的高光和漫反射。\n冯氏光照模型、冯氏着色法 简介：\n裴祥风 (1942-1975)，出生于越南，1973 年在美国 尤他大学 取得博士学位，并发明了冯氏光照模型和冯氏着色法，被广大 CG 界采用。\n冯氏光照模型主要有 3 个分量组成：\n环境光照(Ambient Lighting)：物体几乎永远不会是完全黑暗的，环境光照一般是一个常量。\n漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响，越是正对着光源的地方越亮。\n通过计算物体平面某个点的法向量与该点与光源的单位向量进行乘积，得到该点的亮度。\n当这两个向量相互重叠时该点最亮(亮度值为1)，当这两个向量成九十度则最暗(亮度值为0)\n向量、法线、乘积(也称内积) 这些都是 线性代数 中的词语，属于图形学中需要掌握的基础知识。如果学会了基础的 Three.js 后一定要去学习图形学，否则以后也做不出什么好的应用。\n镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。\n最终物体呈现的样子就是以上 3 种光照结果直接叠加后的样子。\n冯氏着色法(Phong Shading)：每个片元(fragment)或者每个点计算一次光照，点的法向量是通过顶点的法向量插值得到的。冯氏着色更加接近真实，当然计算开销也大。\n与冯氏着色法相对的有：平面着色法(Flat Shading)、高洛德着色法(Gouraud Shading)\n以上内容更新于 2022.02.02\nPhong 光照反射模型 也被称为 冯氏反射模型\n特别补充：\nMeshPhongMaterial 中的 Phong 是指 Phong 光照反射模型 Phong Shading 中的 Phong 只指 补色渲染 Phong光照反射模型、Phong补色渲染 这 2 个理论都是由 科学家 Bui Tuong Phong 提出的，所以也都以他的名字命名。 目前来说，补色渲染/逐片元着色，也就是 Phong Sharding 是最好、最复杂的着色方式。\nPhong的属性：emissive(发光颜色) color 指材质的基本颜色，而 emissive 指材质的发光色。\n注意：若将材质的 color 设置为黑色、emissive 设置为 某色 (例如 紫色)，那么此时材质呈现出的是 emissive 颜色。\nPhong的属性：shininess(光泽度) shininess 的值为数字。\n最小值可设置为 0，即无光泽度，此时呈现出的效果和 Lambert 相同 默认值为 30 该值越大，光泽度越高，呈现的效果越接近 高清玻璃或钢琴烤漆的那种光泽感 注意：若将材质的 color 设置为黑色、emissive 设置为 某色(例如 紫色)、光泽度 设置为 0，那么此时材质呈现出的是 emissive 颜色，且无光泽度。\nMeshBasicMaterial、MeshLambertMaterial 当我们对 MeshPhongMaterial 一些特性有所了解后，通过对 光感反射 特性的对比，可以学习了解到 MeshBasicMaterial 和 MeshLambertMaterial。\n几种材质的光感对比 MeshBasicMaterial：不反射任何光，仅显示材质本身颜色\nMeshLambertMaterial：仅顶点处反射光\nMeshPhongMaterial：任何地方都可反射光\nLambert 虽然顶点也可以反光，但是相对 Phong 而言，Lambert 整体反光度极其微小、不明显\n性能提示 关于颜色，以下 3 种情况所呈现出的最终效果完全相同：\n基于 MeshBasicMaterial，color 设置为紫色 基于 MeshLambertMaterial，color 设置为黑色，emissive 设置为 紫色 基于 MeshPhongMaterial，color 设置为黑色，emissive 设置为 紫色，shininess 设置为 0 以上 3 种设置下，最终所呈现出的颜色效果完全相同：都是紫色且无光泽。\n但是，从渲染性能上来讲，从上往下 所需要的性能越来越高，因此假设材质不需要 Phone 反光模式 或 镜面高光(光泽)的情况下，应优先选择 较低性能 的材质。\nMeshToonMaterial MeshToonMaterial 和 MeshPhongMaterial 类似但又不同。\nMeshToonMaterial 并不会像 MeshPhongMaterial 那样使用平滑着色，而是使用渐变贴图( X 乘 1 的纹理) 来决定如何着色。\n注意：“渐变贴图( X 乘 1 的纹理) \" 这句话我是从参考教程中看到的，我并没理解这句话的含义。\n并不是说必须要设置纹理图片，若不设置则会采用默认的渐变策略：\n前 70% 区域 亮度为 70% 后 30% 区域亮度为 100% 最终呈现出的效果，看起来特别像卡通动画的风格。所以 MeshToonMaterial 又被称为 卡通网格材质。\n卡通动画通常大面积为纯色，只在底部增加深色的颜色，以此来表现出立体效果。\n补充一点：\n网上很多教程在讲解 MeshToonMaterial 时会提到：\n“MeshToonMaterial 是 MeshPhongMaterial 的扩展”\n但是我自己通过 MeshToonMaterial.d.ts 源码查询，并未发现 MeshToonMaterial 是继承于 MeshPhongMaterial 的，所以我认为这句话并不正确。\nMeshMatcapMaterial 一种自带光效(明暗)的材质。\nMeshStandardMaterial、MeshPhysicalMaterial Phong 材质有一个属性 shininess(光泽度)，而 MeshStandardMaterial 有 2 个相对应的属性：\nroughness：粗糙度，取值范围为 0 - 1，即 0 为粗糙度最低，此时表现出的光泽度最高 metalness：金属度，取值范围为 0 - 1，即 0 为非金属、金属度最高为 1 在 粗糙度和金属度 共同的作用下，呈现出 更加细腻、可控 的光泽度。\nMeshPhysicalMaterial 继承于 MeshStandardMaterial ，新增加 2 个属性：\nclearcoat：添加(应用)透明涂层的程度，取值范围为 0 - 1 clearCoatRoughness：透明涂层的粗糙度，取值范围为 0 - 1 额外添加的透明涂层，在装修上有一个专业的名词：清漆(又名 凡立水)\n**清漆的含义为：**用透明涂料涂抹在物体表面，形成光滑薄膜，由于是透明的所以原有物体表面的纹理依然清晰可见不受影响。\n清漆 会让物体呈现出更加光泽的效果。\n因此：\nclearcoat 可以翻译成：添加 清漆 的程度 clearCoatRoughness 翻译成：清漆粗糙度 基础材质小总结 从各种材质渲染所需性能，也就是渲染所需时间的快慢排序，依次是：\nMeshBasicMaterial \u003e MeshLambertMaterial \u003e MeshPhongMaterial \u003e MeshStandardMaterial \u003e MeshPhysicalMaterial\n上面排序中，越靠后的材质所呈现出的 细节 越多、真实感越强。\n特殊材质：ShadowMaterial、MeshDistanceMaterial、MeshDepthMaterial、MeshNormalMaterial ShadowMaterial：阴影类型的材质 我们目前还从未在示例中使用过 ShadowMaterial 材质，ShadowMaterial 是用来创建 阴影 的。\nMeshDistanceMaterial：另外一种阴影投射材质 相对于 ShadowMaterial 的另外一种阴影投射材质，可以确保内部不透明部分不投射阴影。\nMeshDepthMaterial：以像素的深度来着色的材质 **所谓 “像素的深度” 是指物体距离 镜头(摄像机) 的远近距离。**不同的距离决定不同的着色效果。\n当物体距离镜头越近时会呈现白色、当距离越远时会呈现黑色。\n你可以想象成在黑夜中去看远方的发光物体，越近的物体所发出的光眼睛看到的越多(显得物体越亮)，越远的物体所发出的光越暗，直至完全消失在黑暗中。\n创建镜头的时候，会有 2 个 参数：near(最近距离)、far(最远距离)\nMeshNormalMaterial：网格法向量材质 该材质是根据 三角面 的 法向量 方向的不同，从而赋予不同的颜色。\n当物体旋转的时候由于各个面的法向量不断发生变化，物体的颜色也是不断发生变化。\nSpriteMaterial：精灵材质/雪碧材质 精灵材质，也叫 雪碧材质。\n大体来说，就是在场景中，可以加载图片，并且将图片当做纹理贴图，使用在材质上。\n自定义材质：ShaderMaterial、RawShaderMaterial ShaderMaterial：使用 Three.js 着色器制作自定义材质 RawShaderMaterial：完全自定义着色器所创建的自定义材质 特殊材质、自定义材质具体的用法，此刻都不必深究，道路漫漫，时间还长，以后再慢慢研究。\n材质通用、常用的2个属性：flatShading、side flatShading：是否平面着色 默认值为 false，即使用 渐变过渡着色。\n若设置值为 true，则使用平面着色。\n若启用平面着色，会让物体看起来更像是多面体，而不是光滑体。\n本文在讲解 MeshPhongMaterial 的时候已经提到过此属性。\nside：显示三角形的哪侧边(面) 默认值为 Three.FrontSide，即 只显示(渲染) 前面一侧的面。\n若设置值为 Three.BackSide，则 只显示(渲染) 里面一侧的面。\n对于绝大多数 图元 来说，通常 内部是不可见的，例如 球体或立方体的内部 你是看不见的，只能看见外面。side 通常是针对平面或非实体对象才有效果，例如 一个平面圆形，则背对 镜头的那一面即内面，在物体旋转过程中是可以看到内测那一面的。\n若设置值为 Three.DoubleSide，则 两侧(外面和里面) 都将被显示(渲染)。\n对于实体物体对象(非平面物体) 设置值为 Three.BackSide 或 Three.DoubleSide 都是无意义的。\n材质不常用的1个属性：needsUpdate 第1种情况：材质种类发生了重大变化 针对 面 的材质，之前已经提到过，大致分文 3 个类别：基础材质、特殊用途材质、自定义材质\n在实际项目中，通常情况下我们并不会将某个物体的材质进行 3 大类别之间的转换。\n例如我们不太会将某个 物体的材质 由某种基础材质突然变更为 阴影材质。\n尽管实际中发生几率非常小，但万一要发生了呢？\n第2种情况：材质种类没变，但设置发生了变化 若材质在被使用过后，发生了以下 2 种设置变化：\nflatShading 属性值的改变 添加或删除 纹理(texture) 从不使用纹理变为使用纹理 从使用纹理变为不使用纹理 纹理的变更是允许的，并不属于 “添加或删除纹理” 的范畴中 设置 needsUpdate 属性 当上述 2 种情况发生后，此时就需要设置 needsUpdate 属性：\nmaterial.needsUpdate = true 明确告知 Three.js 材质发生了重大变化，请使用新的材质重新渲染。\n更换新的材质并重新渲染，这个过程将消耗比较多的计算性能。\n补充说明：\n在官方教程中，讲解 needsUpdate 属性时还有一句话：\n在从纹理过渡到无纹理的情况下，通常最好使用1x1像素的白色纹理。\n由于目前还没有学习过纹理，所以我暂时没理解这句话具体的含义是什么。\n关于 材质 的一些基础知识，本文已经讲完。\n具体的每个材质都需要阅读官方文档，以及经过大量的练习才能掌握。\n同一个材质在不同光照、纹理的作用下，可能呈现出的效果相差很大。\n下一节，学习 纹理(Texture)。\n","wordCount":"5631","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/09-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>09 Three.js基础之材质</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>12 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><ul><ul><li><a href=#%e6%9d%90%e8%b4%a8%e5%9f%ba%e7%a1%80 aria-label=材质基础>材质基础</a></li><li><a href=#%e7%82%b9%e6%9d%90%e8%b4%a8 aria-label=点材质>点材质</a></li><li><a href=#%e7%ba%bf%e6%80%a7%e6%9d%90%e8%b4%a8 aria-label=线性材质>线性材质</a></li><li><a href=#%e5%9f%ba%e7%a1%80%e6%9d%90%e8%b4%a8%e9%92%88%e5%af%b9%e9%9d%a2 aria-label=基础材质(针对”面“)>基础材质(针对”面“)</a></li><li><a href=#%e7%89%b9%e6%ae%8a%e7%94%a8%e9%80%94%e6%9d%90%e8%b4%a8 aria-label=特殊用途材质>特殊用途材质</a></li><li><a href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%9d%90%e8%b4%a8 aria-label=自定义材质>自定义材质</a></li></ul></ul><li><a href=#%e7%82%b9%e6%9d%90%e8%b4%a8pointsmaterial aria-label=点材质：PointsMaterial>点材质：PointsMaterial</a><ul><ul><li><a href=#pointsmaterial%e7%82%b9%e6%9d%90%e8%b4%a8%e7%b2%92%e5%ad%90%e6%9d%90%e8%b4%a8 aria-label=PointsMaterial：点材质/粒子材质>PointsMaterial：点材质/粒子材质</a></li></ul></ul></li><li><a href=#%e7%ba%bf%e6%80%a7%e6%9d%90%e8%b4%a8linebasicmateriallinedashedmaterial aria-label=线性材质：LineBasicMaterial、LineDashedMaterial>线性材质：LineBasicMaterial、LineDashedMaterial</a><ul><ul><li><a href=#linebasicmaterial%e5%9f%ba%e7%a1%80%e7%9a%84%e7%ba%bf%e6%ae%b5%e6%9d%90%e8%b4%a8 aria-label=LineBasicMaterial：基础的线段材质>LineBasicMaterial：基础的线段材质</a></li><li><a href=#linedashedmaterial%e8%99%9a%e7%ba%bf%e6%9d%90%e8%b4%a8 aria-label=LineDashedMaterial：虚线材质>LineDashedMaterial：虚线材质</a></li></ul></ul></li><li><a href=#%e5%9f%ba%e7%a1%80%e6%9d%90%e8%b4%a8%e8%ae%b2%e8%a7%a3%e8%af%b4%e6%98%8e aria-label=基础材质讲解说明>基础材质讲解说明</a><ul><ul><li><a href=#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%85%88%e8%ae%b2-meshphongmaterial aria-label="为什么要先讲 MeshPhongMaterial？">为什么要先讲 MeshPhongMaterial？</a></li></ul></ul></li><li><a href=#meshphongmaterial aria-label=MeshPhongMaterial>MeshPhongMaterial</a><ul><li><a href=#phong%e5%85%89%e7%85%a7%e6%a8%a1%e5%9e%8b aria-label=Phong光照模型>Phong光照模型</a></li><li><a href=#phong%e7%9a%84%e5%81%87%e8%ae%be%e5%89%8d%e6%8f%90 aria-label=Phong的假设前提>Phong的假设前提</a></li><li><a href=#phone%e7%9a%84%e7%ae%80%e5%8d%95%e7%94%a8%e6%b3%95 aria-label=Phone的简单用法>Phone的简单用法</a></li><li><a href=#phong%e7%9a%84%e5%b1%9e%e6%80%a7flatshading%e5%b9%b3%e9%9d%a2%e7%9d%80%e8%89%b2 aria-label=Phong的属性：flatShading(平面着色)>Phong的属性：flatShading(平面着色)</a><ul><li><a href=#%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e-3-%e5%a4%a7%e7%9d%80%e8%89%b2%e6%a8%a1%e5%bc%8f aria-label="补充说明 3 大着色模式">补充说明 3 大着色模式</a></li><li><a href=#%e6%9c%80%e5%b8%b8%e8%a7%81%e7%9a%84-3-%e7%a7%8d%e7%9d%80%e8%89%b2%e7%ae%97%e6%b3%95%e6%a8%a1%e5%bc%8f aria-label="最常见的 3 种着色算法(模式)">最常见的 3 种着色算法(模式)</a></li></ul></li><li><a href=#phong%e7%9a%84%e5%b1%9e%e6%80%a7emissive%e5%8f%91%e5%85%89%e9%a2%9c%e8%89%b2 aria-label=Phong的属性：emissive(发光颜色)>Phong的属性：emissive(发光颜色)</a></li><li><a href=#phong%e7%9a%84%e5%b1%9e%e6%80%a7shininess%e5%85%89%e6%b3%bd%e5%ba%a6 aria-label=Phong的属性：shininess(光泽度)>Phong的属性：shininess(光泽度)</a></li></ul></li><li><a href=#meshbasicmaterialmeshlambertmaterial aria-label=MeshBasicMaterial、MeshLambertMaterial>MeshBasicMaterial、MeshLambertMaterial</a><ul><ul><li><a href=#%e5%87%a0%e7%a7%8d%e6%9d%90%e8%b4%a8%e7%9a%84%e5%85%89%e6%84%9f%e5%af%b9%e6%af%94 aria-label=几种材质的光感对比>几种材质的光感对比</a></li><li><a href=#%e6%80%a7%e8%83%bd%e6%8f%90%e7%a4%ba aria-label=性能提示>性能提示</a></li></ul></ul></li><li><a href=#meshtoonmaterial aria-label=MeshToonMaterial>MeshToonMaterial</a></li><li><a href=#meshmatcapmaterial aria-label=MeshMatcapMaterial>MeshMatcapMaterial</a></li><li><a href=#meshstandardmaterialmeshphysicalmaterial aria-label=MeshStandardMaterial、MeshPhysicalMaterial>MeshStandardMaterial、MeshPhysicalMaterial</a></li><li><a href=#%e5%9f%ba%e7%a1%80%e6%9d%90%e8%b4%a8%e5%b0%8f%e6%80%bb%e7%bb%93 aria-label=基础材质小总结>基础材质小总结</a></li><li><a href=#%e7%89%b9%e6%ae%8a%e6%9d%90%e8%b4%a8shadowmaterialmeshdistancematerialmeshdepthmaterialmeshnormalmaterial aria-label=特殊材质：ShadowMaterial、MeshDistanceMaterial、MeshDepthMaterial、MeshNormalMaterial>特殊材质：ShadowMaterial、MeshDistanceMaterial、MeshDepthMaterial、MeshNormalMaterial</a><ul><ul><li><a href=#shadowmaterial%e9%98%b4%e5%bd%b1%e7%b1%bb%e5%9e%8b%e7%9a%84%e6%9d%90%e8%b4%a8 aria-label=ShadowMaterial：阴影类型的材质>ShadowMaterial：阴影类型的材质</a></li><li><a href=#meshdistancematerial%e5%8f%a6%e5%a4%96%e4%b8%80%e7%a7%8d%e9%98%b4%e5%bd%b1%e6%8a%95%e5%b0%84%e6%9d%90%e8%b4%a8 aria-label=MeshDistanceMaterial：另外一种阴影投射材质>MeshDistanceMaterial：另外一种阴影投射材质</a></li><li><a href=#meshdepthmaterial%e4%bb%a5%e5%83%8f%e7%b4%a0%e7%9a%84%e6%b7%b1%e5%ba%a6%e6%9d%a5%e7%9d%80%e8%89%b2%e7%9a%84%e6%9d%90%e8%b4%a8 aria-label=MeshDepthMaterial：以像素的深度来着色的材质>MeshDepthMaterial：以像素的深度来着色的材质</a></li><li><a href=#meshnormalmaterial%e7%bd%91%e6%a0%bc%e6%b3%95%e5%90%91%e9%87%8f%e6%9d%90%e8%b4%a8 aria-label=MeshNormalMaterial：网格法向量材质>MeshNormalMaterial：网格法向量材质</a></li><li><a href=#spritematerial%e7%b2%be%e7%81%b5%e6%9d%90%e8%b4%a8%e9%9b%aa%e7%a2%a7%e6%9d%90%e8%b4%a8 aria-label=SpriteMaterial：精灵材质/雪碧材质>SpriteMaterial：精灵材质/雪碧材质</a></li></ul></ul></li><li><a href=#%e8%87%aa%e5%ae%9a%e4%b9%89%e6%9d%90%e8%b4%a8shadermaterialrawshadermaterial aria-label=自定义材质：ShaderMaterial、RawShaderMaterial>自定义材质：ShaderMaterial、RawShaderMaterial</a><ul><ul><li><a href=#shadermaterial%e4%bd%bf%e7%94%a8-threejs-%e7%9d%80%e8%89%b2%e5%99%a8%e5%88%b6%e4%bd%9c%e8%87%aa%e5%ae%9a%e4%b9%89%e6%9d%90%e8%b4%a8 aria-label="ShaderMaterial：使用 Three.js 着色器制作自定义材质">ShaderMaterial：使用 Three.js 着色器制作自定义材质</a></li><li><a href=#rawshadermaterial%e5%ae%8c%e5%85%a8%e8%87%aa%e5%ae%9a%e4%b9%89%e7%9d%80%e8%89%b2%e5%99%a8%e6%89%80%e5%88%9b%e5%bb%ba%e7%9a%84%e8%87%aa%e5%ae%9a%e4%b9%89%e6%9d%90%e8%b4%a8 aria-label=RawShaderMaterial：完全自定义着色器所创建的自定义材质>RawShaderMaterial：完全自定义着色器所创建的自定义材质</a></li></ul></ul></li><li><a href=#%e6%9d%90%e8%b4%a8%e9%80%9a%e7%94%a8%e5%b8%b8%e7%94%a8%e7%9a%842%e4%b8%aa%e5%b1%9e%e6%80%a7flatshadingside aria-label=材质通用、常用的2个属性：flatShading、side>材质通用、常用的2个属性：flatShading、side</a><ul><ul><li><a href=#flatshading%e6%98%af%e5%90%a6%e5%b9%b3%e9%9d%a2%e7%9d%80%e8%89%b2 aria-label=flatShading：是否平面着色>flatShading：是否平面着色</a></li><li><a href=#side%e6%98%be%e7%a4%ba%e4%b8%89%e8%a7%92%e5%bd%a2%e7%9a%84%e5%93%aa%e4%be%a7%e8%be%b9%e9%9d%a2 aria-label=side：显示三角形的哪侧边(面)>side：显示三角形的哪侧边(面)</a></li></ul></ul></li><li><a href=#%e6%9d%90%e8%b4%a8%e4%b8%8d%e5%b8%b8%e7%94%a8%e7%9a%841%e4%b8%aa%e5%b1%9e%e6%80%a7needsupdate aria-label=材质不常用的1个属性：needsUpdate>材质不常用的1个属性：needsUpdate</a><ul><ul><li><a href=#%e7%ac%ac1%e7%a7%8d%e6%83%85%e5%86%b5%e6%9d%90%e8%b4%a8%e7%a7%8d%e7%b1%bb%e5%8f%91%e7%94%9f%e4%ba%86%e9%87%8d%e5%a4%a7%e5%8f%98%e5%8c%96 aria-label=第1种情况：材质种类发生了重大变化>第1种情况：材质种类发生了重大变化</a></li><li><a href=#%e7%ac%ac2%e7%a7%8d%e6%83%85%e5%86%b5%e6%9d%90%e8%b4%a8%e7%a7%8d%e7%b1%bb%e6%b2%a1%e5%8f%98%e4%bd%86%e8%ae%be%e7%bd%ae%e5%8f%91%e7%94%9f%e4%ba%86%e5%8f%98%e5%8c%96 aria-label=第2种情况：材质种类没变，但设置发生了变化>第2种情况：材质种类没变，但设置发生了变化</a></li><li><a href=#%e8%ae%be%e7%bd%ae-needsupdate-%e5%b1%9e%e6%80%a7 aria-label="设置 needsUpdate 属性">设置 needsUpdate 属性</a></li></ul></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>材质(material) 即 线段属性或物体表面的一些颜色、贴图、光亮程度、反光特性、粗糙度等属性。</p><p>按照用途，所以材质大体上可以划分为：</p><ol><li>点材质(应用来点、粒子上)</li><li>线性材质(应用在线段或虚线上)</li><li>基础材质(应用在面上的各种材质)</li><li>特殊用途的材质(例如阴影)</li><li>自定义材质</li></ol><blockquote><p>上面的分类划分，仅仅是我个人观点，事实上并没有明确的种类划分规定。</p></blockquote><h4 id=材质基础>材质基础<a hidden class=anchor aria-hidden=true href=#材质基础>#</a></h4><table><thead><tr><th>材质名称</th><th>解释说明</th></tr></thead><tbody><tr><td>Material</td><td>所有材质的父类</td></tr></tbody></table><h4 id=点材质>点材质<a hidden class=anchor aria-hidden=true href=#点材质>#</a></h4><table><thead><tr><th>材质名称</th><th>解释说明</th></tr></thead><tbody><tr><td>PointsMaterial</td><td>点材质(粒子材质)</td></tr></tbody></table><h4 id=线性材质>线性材质<a hidden class=anchor aria-hidden=true href=#线性材质>#</a></h4><table><thead><tr><th>材质名称</th><th>解释说明</th></tr></thead><tbody><tr><td>LineBasicMaterial</td><td>线段材质(颜色、宽度、断点、连接点等属性)</td></tr><tr><td>LineDashedMaterial</td><td>虚线材质</td></tr></tbody></table><h4 id=基础材质针对面>基础材质(针对”面“)<a hidden class=anchor aria-hidden=true href=#基础材质针对面>#</a></h4><table><thead><tr><th>材质名称</th><th>解释说明</th></tr></thead><tbody><tr><td>MeshBasicMaterial</td><td>最基础的材质，不反射光，仅显示材质本身颜色</td></tr><tr><td>MeshLambertMaterial</td><td>仅顶点处反射光</td></tr><tr><td>MeshMatcapMaterial</td><td>自带光效(明暗)的材质</td></tr><tr><td>MeshPhongMaterial</td><td>任何点都反射光，拥有光泽度</td></tr><tr><td>MeshToonMaterial</td><td>卡通着色</td></tr><tr><td>MeshStandardMaterial</td><td>除光泽度外，还有粗糙度和金属度</td></tr><tr><td>MeshPhysicalMaterial</td><td>除光泽度、粗糙度、金属度外，还有清漆度和清漆粗糙度</td></tr></tbody></table><h4 id=特殊用途材质>特殊用途材质<a hidden class=anchor aria-hidden=true href=#特殊用途材质>#</a></h4><table><thead><tr><th>材质名称</th><th>解释说明</th></tr></thead><tbody><tr><td>ShadowMaterial</td><td>阴影材质</td></tr><tr><td>MeshDistanceMaterial</td><td>另外一种阴影投射材质</td></tr><tr><td>MeshDeptMaterial</td><td>远近距离深度着色材质</td></tr><tr><td>MeshNormalMaterial</td><td>网格法向量材质</td></tr><tr><td>SpriteMaterial</td><td>精灵材质/雪碧材质</td></tr></tbody></table><h4 id=自定义材质>自定义材质<a hidden class=anchor aria-hidden=true href=#自定义材质>#</a></h4><table><thead><tr><th>材质名称</th><th>解释说明</th></tr></thead><tbody><tr><td>ShaderMaterial</td><td>着色器材质</td></tr><tr><td>RawShaderMaterial</td><td>原始着色器材质</td></tr></tbody></table><p>注意：本文只是大体上讲解一些 Three.js 中的各个材质特性，具体每个材质的详细参数和用法，需要自己查阅 Three.js 官方文档：<a href=https://threejs.org/docs/index.html#api/zh/materials/Material>https://threejs.org/docs/index.html#api/zh/materials/Material</a></p><h2 id=点材质pointsmaterial>点材质：PointsMaterial<a hidden class=anchor aria-hidden=true href=#点材质pointsmaterial>#</a></h2><h4 id=pointsmaterial点材质粒子材质>PointsMaterial：点材质/粒子材质<a hidden class=anchor aria-hidden=true href=#pointsmaterial点材质粒子材质>#</a></h4><p>用来创建 粒子 材质。</p><h2 id=线性材质linebasicmateriallinedashedmaterial>线性材质：LineBasicMaterial、LineDashedMaterial<a hidden class=anchor aria-hidden=true href=#线性材质linebasicmateriallinedashedmaterial>#</a></h2><h4 id=linebasicmaterial基础的线段材质>LineBasicMaterial：基础的线段材质<a hidden class=anchor aria-hidden=true href=#linebasicmaterial基础的线段材质>#</a></h4><p>用来创建 线段 的材质，属性包括：颜色、宽度、断点、连接点等。</p><h4 id=linedashedmaterial虚线材质>LineDashedMaterial：虚线材质<a hidden class=anchor aria-hidden=true href=#linedashedmaterial虚线材质>#</a></h4><p>LineDashedMaterial 继承于 LineBasicMaterial，用来绘制虚线。</p><h2 id=基础材质讲解说明>基础材质讲解说明<a hidden class=anchor aria-hidden=true href=#基础材质讲解说明>#</a></h2><p>Three.js 中基础材质类型，我们先从 MeshPhongMaterial 说起。</p><h4 id=为什么要先讲-meshphongmaterial>为什么要先讲 MeshPhongMaterial？<a hidden class=anchor aria-hidden=true href=#为什么要先讲-meshphongmaterial>#</a></h4><p>因为 MeshPhongMaterial 是使用最频繁，且处于特殊位置的材质。</p><p>MeshPhongMaterial 可以作为其他材质的参考对象：</p><ol><li>比 MeshPhongMaterial 简单的有 MeshBasicMaterial、MeshLambertMaterial</li><li>和 MeshPhongMaterial 相似的有 MeshToonMaterial</li><li>比 MeshPhongMaterial 复杂的有 MeshStandardMaterial、MeshPhysicalMaterial</li></ol><h2 id=meshphongmaterial>MeshPhongMaterial<a hidden class=anchor aria-hidden=true href=#meshphongmaterial>#</a></h2><h3 id=phong光照模型>Phong光照模型<a hidden class=anchor aria-hidden=true href=#phong光照模型>#</a></h3><p>Phong光照模型是最简单、最基础的光照模型，该模型只考虑物体对直线光的反射作用，不考虑物体之间的漫反射光(环境光)。</p><h3 id=phong的假设前提>Phong的假设前提<a hidden class=anchor aria-hidden=true href=#phong的假设前提>#</a></h3><ol><li>物体通常被设置为不透明</li><li>物体表面反射率相同</li></ol><h3 id=phone的简单用法>Phone的简单用法<a hidden class=anchor aria-hidden=true href=#phone的简单用法>#</a></h3><p><strong>新建一个 MeshPhongMaterial</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const material = new Three.MeshPhongMaterial({
</span></span><span style=display:flex><span>  color:0xFF0000,
</span></span><span style=display:flex><span>  flatShading:true
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>或者</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const material = new Three.MeshPhoneMaterial()
</span></span><span style=display:flex><span>material.color.set(0xFF0000)
</span></span><span style=display:flex><span>material.flatShading = true
</span></span></code></pre></div><p><strong>设置颜色的N种方式：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>new Three.MeshPhoneMaterial({color:0xFF0000})
</span></span><span style=display:flex><span>new Three.MeshPhoneMaterial({color:&#39;red&#39;})
</span></span><span style=display:flex><span>new Three.MeshPhoneMaterial({color:&#39;#F00&#39;})
</span></span><span style=display:flex><span>new Three.MeshPhoneMaterial({color:&#39;rgb(255,0,0)&#39;})
</span></span><span style=display:flex><span>new Three.MeshPhoneMaterial({color:&#39;hsl(0,100%,50%)&#39;})
</span></span></code></pre></div><p>修改颜色：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>material.color.set(0xFF0000)
</span></span><span style=display:flex><span>material.color.set(&#39;red&#39;)
</span></span><span style=display:flex><span>material.color.set(&#39;#F00&#39;)
</span></span><span style=display:flex><span>material.color.set(&#39;rgb(255,0,0)&#39;)
</span></span><span style=display:flex><span>material.color.set(&#39;hsl(0,100%,50%)&#39;)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>material.color.setHSL(0,1,0.5)
</span></span><span style=display:flex><span>material.color.setRGB(1,0,0)
</span></span></code></pre></div><h3 id=phong的属性flatshading平面着色>Phong的属性：flatShading(平面着色)<a hidden class=anchor aria-hidden=true href=#phong的属性flatshading平面着色>#</a></h3><p><strong>特别强调：flatShading 属性并不是由 MeshPhongMaterial 定义的，而是有父类 Material 定义的。</strong></p><p>只不过由于 flatShading 比较重要，因此这里特别讲解一下该属性的作用。</p><p>flatShading 的值为 布尔值，该值指 是否启用 平面着色 模式。</p><blockquote><p>默认值为 false，即不启用 平面着色 模式。</p></blockquote><h4 id=补充说明-3-大着色模式>补充说明 3 大着色模式<a hidden class=anchor aria-hidden=true href=#补充说明-3-大着色模式>#</a></h4><p><strong>什么叫 着色？</strong></p><p>在三维图形学中，“着色” 的含义为：根据光照条件重建 物体各表面明暗效果的过程，就叫着色。</p><p>这个 &ldquo;着色&rdquo; 过程中，就牵扯到不同的着色算法，也就是不同的着色模式。</p><h4 id=最常见的-3-种着色算法模式>最常见的 3 种着色算法(模式)<a hidden class=anchor aria-hidden=true href=#最常见的-3-种着色算法模式>#</a></h4><p><strong>Flat Shading：平面着色</strong></p><p>根据每个三角形的法线计算着色效果，每个面只计算一次，也就是说相同的面采用同一个计算结果。</p><p>这种模式对于 立方体 来说会减小计算量，因为立方体每个面都是平整且唯一的。</p><p><strong>Gouraud Shading：逐顶着色</strong></p><p>针对每个顶点计算，而后对每个顶点的结果颜色进行线性插值得到片源的颜色。</p><p><strong>Phong Shading：补色渲染</strong></p><p>对每个三角形的每个片元进行着色计算。所以 Phong Shading 又被称为 <strong>逐片元着色</strong></p><p>由于颜色是按片元着色的，得到的结果比 逐顶着色(Gouraud Shading) 要更加细腻，尤其是用于光亮表面效果更加真实。</p><p>Phong 并不是传统的英文单词，而是 生活在美国的越南籍科学家 Bui Tuong Phong (裴祥风) 的名字。</p><p>所以 Phong Shading 又被称为 冯氏着色。</p><br><blockquote><p>以下内容更新于 2022.02.02</p></blockquote><p>在图形学中有一个被应用非常广泛的简单光照模型：冯氏光照模型</p><blockquote><p>注：这里的 简单 是指计算量非常小，但却可以模拟出简单的高光和漫反射。</p></blockquote><br><p><strong>冯氏光照模型、冯氏着色法 简介：</strong></p><p><strong>裴祥风</strong> (1942-1975)，出生于越南，1973 年在美国 尤他大学 取得博士学位，并发明了冯氏光照模型和冯氏着色法，被广大 CG 界采用。</p><p>冯氏光照模型主要有 3 个分量组成：</p><ol><li><p>环境光照(Ambient Lighting)：物体几乎永远不会是完全黑暗的，环境光照一般是一个常量。</p></li><li><p>漫反射光照(Diffuse Lighting)：模拟光源对物体的方向性影响，越是正对着光源的地方越亮。</p><blockquote><p>通过计算物体平面某个点的法向量与该点与光源的单位向量进行乘积，得到该点的亮度。</p><p>当这两个向量相互重叠时该点最亮(亮度值为1)，当这两个向量成九十度则最暗(亮度值为0)</p><p>向量、法线、乘积(也称内积) 这些都是 线性代数 中的词语，属于图形学中需要掌握的基础知识。如果学会了基础的 Three.js 后一定要去学习图形学，否则以后也做不出什么好的应用。</p></blockquote></li><li><p>镜面光照(Specular Lighting)：模拟有光泽物体上面出现的亮点。</p></li></ol><p>最终物体呈现的样子就是以上 3 种光照结果直接叠加后的样子。</p><br><p>冯氏着色法(Phong Shading)：每个片元(fragment)或者每个点计算一次光照，点的法向量是通过顶点的法向量插值得到的。冯氏着色更加接近真实，当然计算开销也大。</p><p>与冯氏着色法相对的有：平面着色法(Flat Shading)、高洛德着色法(Gouraud Shading)</p><blockquote><p>以上内容更新于 2022.02.02</p></blockquote><br><blockquote><p>Phong 光照反射模型 也被称为 冯氏反射模型</p></blockquote><p><strong>特别补充：</strong></p><ol><li>MeshPhongMaterial 中的 Phong 是指 Phong 光照反射模型</li><li>Phong Shading 中的 Phong 只指 补色渲染</li><li>Phong光照反射模型、Phong补色渲染 这 2 个理论都是由 科学家 Bui Tuong Phong 提出的，所以也都以他的名字命名。</li></ol><p><strong>目前来说，补色渲染/逐片元着色，也就是 Phong Sharding 是最好、最复杂的着色方式。</strong></p><h3 id=phong的属性emissive发光颜色>Phong的属性：emissive(发光颜色)<a hidden class=anchor aria-hidden=true href=#phong的属性emissive发光颜色>#</a></h3><p>color 指材质的基本颜色，而 emissive 指材质的发光色。</p><p>注意：若将材质的 color 设置为黑色、emissive 设置为 某色 (例如 紫色)，那么此时材质呈现出的是 emissive 颜色。</p><h3 id=phong的属性shininess光泽度>Phong的属性：shininess(光泽度)<a hidden class=anchor aria-hidden=true href=#phong的属性shininess光泽度>#</a></h3><p>shininess 的值为数字。</p><ol><li>最小值可设置为 0，即无光泽度，此时呈现出的效果和 Lambert 相同</li><li>默认值为 30</li><li>该值越大，光泽度越高，呈现的效果越接近 高清玻璃或钢琴烤漆的那种光泽感</li></ol><p>注意：若将材质的 color 设置为黑色、emissive 设置为 某色(例如 紫色)、光泽度 设置为 0，那么此时材质呈现出的是 emissive 颜色，且无光泽度。</p><h2 id=meshbasicmaterialmeshlambertmaterial>MeshBasicMaterial、MeshLambertMaterial<a hidden class=anchor aria-hidden=true href=#meshbasicmaterialmeshlambertmaterial>#</a></h2><p>当我们对 MeshPhongMaterial 一些特性有所了解后，通过对 光感反射 特性的对比，可以学习了解到 MeshBasicMaterial 和 MeshLambertMaterial。</p><h4 id=几种材质的光感对比>几种材质的光感对比<a hidden class=anchor aria-hidden=true href=#几种材质的光感对比>#</a></h4><ul><li><p><strong>MeshBasicMaterial：不反射任何光，仅显示材质本身颜色</strong></p></li><li><p><strong>MeshLambertMaterial：仅顶点处反射光</strong></p></li><li><p><strong>MeshPhongMaterial：任何地方都可反射光</strong></p><blockquote><p>Lambert 虽然顶点也可以反光，但是相对 Phong 而言，Lambert 整体反光度极其微小、不明显</p></blockquote></li></ul><h4 id=性能提示>性能提示<a hidden class=anchor aria-hidden=true href=#性能提示>#</a></h4><p>关于颜色，以下 3 种情况所呈现出的最终效果完全相同：</p><ol><li>基于 MeshBasicMaterial，color 设置为紫色</li><li>基于 MeshLambertMaterial，color 设置为黑色，emissive 设置为 紫色</li><li>基于 MeshPhongMaterial，color 设置为黑色，emissive 设置为 紫色，shininess 设置为 0</li></ol><p>以上 3 种设置下，最终所呈现出的颜色效果完全相同：都是紫色且无光泽。</p><p>但是，从渲染性能上来讲，从上往下 所需要的性能越来越高，因此假设材质不需要 Phone 反光模式 或 镜面高光(光泽)的情况下，应优先选择 较低性能 的材质。</p><h2 id=meshtoonmaterial>MeshToonMaterial<a hidden class=anchor aria-hidden=true href=#meshtoonmaterial>#</a></h2><p>MeshToonMaterial 和 MeshPhongMaterial 类似但又不同。</p><p>MeshToonMaterial 并不会像 MeshPhongMaterial 那样使用平滑着色，而是使用渐变贴图( X 乘 1 的纹理) 来决定如何着色。</p><blockquote><p>注意：&ldquo;渐变贴图( X 乘 1 的纹理) " 这句话我是从参考教程中看到的，我并没理解这句话的含义。</p></blockquote><p>并不是说必须要设置纹理图片，若不设置则会采用默认的渐变策略：</p><ol><li>前 70% 区域 亮度为 70%</li><li>后 30% 区域亮度为 100%</li></ol><p>最终呈现出的效果，看起来特别像卡通动画的风格。所以 <strong>MeshToonMaterial 又被称为 卡通网格材质</strong>。</p><blockquote><p>卡通动画通常大面积为纯色，只在底部增加深色的颜色，以此来表现出立体效果。</p></blockquote><p><strong>补充一点：</strong></p><p>网上很多教程在讲解 MeshToonMaterial 时会提到：</p><p><code>“MeshToonMaterial 是 MeshPhongMaterial 的扩展”</code></p><p>但是我自己通过 MeshToonMaterial.d.ts 源码查询，并未发现 MeshToonMaterial 是继承于 MeshPhongMaterial 的，所以我认为这句话并不正确。</p><h2 id=meshmatcapmaterial>MeshMatcapMaterial<a hidden class=anchor aria-hidden=true href=#meshmatcapmaterial>#</a></h2><p>一种自带光效(明暗)的材质。</p><h2 id=meshstandardmaterialmeshphysicalmaterial>MeshStandardMaterial、MeshPhysicalMaterial<a hidden class=anchor aria-hidden=true href=#meshstandardmaterialmeshphysicalmaterial>#</a></h2><p>Phong 材质有一个属性 shininess(光泽度)，而 <strong>MeshStandardMaterial</strong> 有 2 个相对应的属性：</p><ol><li>roughness：粗糙度，取值范围为 0 - 1，即 0 为粗糙度最低，此时表现出的光泽度最高</li><li>metalness：金属度，取值范围为 0 - 1，即 0 为非金属、金属度最高为 1</li></ol><p>在 粗糙度和金属度 共同的作用下，呈现出 更加细腻、可控 的光泽度。</p><p><strong>MeshPhysicalMaterial</strong> 继承于 MeshStandardMaterial ，新增加 2 个属性：</p><ol><li>clearcoat：添加(应用)透明涂层的程度，取值范围为 0 - 1</li><li>clearCoatRoughness：透明涂层的粗糙度，取值范围为 0 - 1</li></ol><p>额外添加的透明涂层，在装修上有一个专业的名词：<strong>清漆</strong>(又名 凡立水)</p><p>**清漆的含义为：**用透明涂料涂抹在物体表面，形成光滑薄膜，由于是透明的所以原有物体表面的纹理依然清晰可见不受影响。</p><blockquote><p>清漆 会让物体呈现出更加光泽的效果。</p></blockquote><p><strong>因此：</strong></p><ol><li>clearcoat 可以翻译成：添加 清漆 的程度</li><li>clearCoatRoughness 翻译成：清漆粗糙度</li></ol><h2 id=基础材质小总结>基础材质小总结<a hidden class=anchor aria-hidden=true href=#基础材质小总结>#</a></h2><p>从各种材质渲染所需性能，也就是渲染所需时间的快慢排序，依次是：</p><p><strong>MeshBasicMaterial > MeshLambertMaterial > MeshPhongMaterial > MeshStandardMaterial > MeshPhysicalMaterial</strong></p><p>上面排序中，越靠后的材质所呈现出的 细节 越多、真实感越强。</p><h2 id=特殊材质shadowmaterialmeshdistancematerialmeshdepthmaterialmeshnormalmaterial>特殊材质：ShadowMaterial、MeshDistanceMaterial、MeshDepthMaterial、MeshNormalMaterial<a hidden class=anchor aria-hidden=true href=#特殊材质shadowmaterialmeshdistancematerialmeshdepthmaterialmeshnormalmaterial>#</a></h2><h4 id=shadowmaterial阴影类型的材质>ShadowMaterial：阴影类型的材质<a hidden class=anchor aria-hidden=true href=#shadowmaterial阴影类型的材质>#</a></h4><p>我们目前还从未在示例中使用过 ShadowMaterial 材质，ShadowMaterial 是用来创建 阴影 的。</p><h4 id=meshdistancematerial另外一种阴影投射材质>MeshDistanceMaterial：另外一种阴影投射材质<a hidden class=anchor aria-hidden=true href=#meshdistancematerial另外一种阴影投射材质>#</a></h4><p>相对于 ShadowMaterial 的另外一种阴影投射材质，可以确保内部不透明部分不投射阴影。</p><h4 id=meshdepthmaterial以像素的深度来着色的材质>MeshDepthMaterial：以像素的深度来着色的材质<a hidden class=anchor aria-hidden=true href=#meshdepthmaterial以像素的深度来着色的材质>#</a></h4><p>**所谓 “像素的深度” 是指物体距离 镜头(摄像机) 的远近距离。**不同的距离决定不同的着色效果。</p><p>当物体距离镜头越近时会呈现白色、当距离越远时会呈现黑色。</p><blockquote><p>你可以想象成在黑夜中去看远方的发光物体，越近的物体所发出的光眼睛看到的越多(显得物体越亮)，越远的物体所发出的光越暗，直至完全消失在黑暗中。</p></blockquote><blockquote><p>创建镜头的时候，会有 2 个 参数：near(最近距离)、far(最远距离)</p></blockquote><h4 id=meshnormalmaterial网格法向量材质>MeshNormalMaterial：网格法向量材质<a hidden class=anchor aria-hidden=true href=#meshnormalmaterial网格法向量材质>#</a></h4><p>该材质是根据 三角面 的 法向量 方向的不同，从而赋予不同的颜色。</p><p>当物体旋转的时候由于各个面的法向量不断发生变化，物体的颜色也是不断发生变化。</p><h4 id=spritematerial精灵材质雪碧材质>SpriteMaterial：精灵材质/雪碧材质<a hidden class=anchor aria-hidden=true href=#spritematerial精灵材质雪碧材质>#</a></h4><p>精灵材质，也叫 雪碧材质。</p><p>大体来说，就是在场景中，可以加载图片，并且将图片当做纹理贴图，使用在材质上。</p><h2 id=自定义材质shadermaterialrawshadermaterial>自定义材质：ShaderMaterial、RawShaderMaterial<a hidden class=anchor aria-hidden=true href=#自定义材质shadermaterialrawshadermaterial>#</a></h2><h4 id=shadermaterial使用-threejs-着色器制作自定义材质>ShaderMaterial：使用 Three.js 着色器制作自定义材质<a hidden class=anchor aria-hidden=true href=#shadermaterial使用-threejs-着色器制作自定义材质>#</a></h4><h4 id=rawshadermaterial完全自定义着色器所创建的自定义材质>RawShaderMaterial：完全自定义着色器所创建的自定义材质<a hidden class=anchor aria-hidden=true href=#rawshadermaterial完全自定义着色器所创建的自定义材质>#</a></h4><p><strong>特殊材质、自定义材质具体的用法，此刻都不必深究，道路漫漫，时间还长，以后再慢慢研究。</strong></p><h2 id=材质通用常用的2个属性flatshadingside>材质通用、常用的2个属性：flatShading、side<a hidden class=anchor aria-hidden=true href=#材质通用常用的2个属性flatshadingside>#</a></h2><h4 id=flatshading是否平面着色>flatShading：是否平面着色<a hidden class=anchor aria-hidden=true href=#flatshading是否平面着色>#</a></h4><p>默认值为 false，即使用 渐变过渡着色。</p><p>若设置值为 true，则使用平面着色。</p><blockquote><p>若启用平面着色，会让物体看起来更像是多面体，而不是光滑体。</p></blockquote><blockquote><p>本文在讲解 MeshPhongMaterial 的时候已经提到过此属性。</p></blockquote><h4 id=side显示三角形的哪侧边面>side：显示三角形的哪侧边(面)<a hidden class=anchor aria-hidden=true href=#side显示三角形的哪侧边面>#</a></h4><p>默认值为 Three.FrontSide，即 只显示(渲染) 前面一侧的面。</p><p>若设置值为 Three.BackSide，则 只显示(渲染) 里面一侧的面。</p><blockquote><p>对于绝大多数 图元 来说，通常 内部是不可见的，例如 球体或立方体的内部 你是看不见的，只能看见外面。side 通常是针对平面或非实体对象才有效果，例如 一个平面圆形，则背对 镜头的那一面即内面，在物体旋转过程中是可以看到内测那一面的。</p></blockquote><p>若设置值为 Three.DoubleSide，则 两侧(外面和里面) 都将被显示(渲染)。</p><blockquote><p>对于实体物体对象(非平面物体) 设置值为 Three.BackSide 或 Three.DoubleSide 都是无意义的。</p></blockquote><h2 id=材质不常用的1个属性needsupdate>材质不常用的1个属性：needsUpdate<a hidden class=anchor aria-hidden=true href=#材质不常用的1个属性needsupdate>#</a></h2><h4 id=第1种情况材质种类发生了重大变化>第1种情况：材质种类发生了重大变化<a hidden class=anchor aria-hidden=true href=#第1种情况材质种类发生了重大变化>#</a></h4><p><strong>针对 面 的材质</strong>，之前已经提到过，大致分文 3 个类别：基础材质、特殊用途材质、自定义材质</p><p>在实际项目中，通常情况下我们并不会将某个物体的材质进行 3 大类别之间的转换。</p><p>例如我们不太会将某个 物体的材质 由某种基础材质突然变更为 阴影材质。</p><p>尽管实际中发生几率非常小，但万一要发生了呢？</p><h4 id=第2种情况材质种类没变但设置发生了变化>第2种情况：材质种类没变，但设置发生了变化<a hidden class=anchor aria-hidden=true href=#第2种情况材质种类没变但设置发生了变化>#</a></h4><p>若材质在被使用过后，发生了以下 2 种设置变化：</p><ol><li>flatShading 属性值的改变</li><li>添加或删除 纹理(texture)<ol><li>从不使用纹理变为使用纹理</li><li>从使用纹理变为不使用纹理</li><li>纹理的变更是允许的，并不属于 “添加或删除纹理” 的范畴中</li></ol></li></ol><h4 id=设置-needsupdate-属性>设置 needsUpdate 属性<a hidden class=anchor aria-hidden=true href=#设置-needsupdate-属性>#</a></h4><p><strong>当上述 2 种情况发生后，此时就需要设置 needsUpdate 属性：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>material.needsUpdate = true
</span></span></code></pre></div><p>明确告知 Three.js 材质发生了重大变化，请使用新的材质重新渲染。</p><blockquote><p>更换新的材质并重新渲染，这个过程将消耗比较多的计算性能。</p></blockquote><p><strong>补充说明：</strong></p><p>在官方教程中，讲解 needsUpdate 属性时还有一句话：</p><p><code>在从纹理过渡到无纹理的情况下，通常最好使用1x1像素的白色纹理。</code></p><p>由于目前还没有学习过纹理，所以我暂时没理解这句话具体的含义是什么。</p><p>关于 材质 的一些基础知识，本文已经讲完。</p><p><strong>具体的每个材质都需要阅读官方文档，以及经过大量的练习才能掌握。</strong></p><p>同一个材质在不同光照、纹理的作用下，可能呈现出的效果相差很大。</p><p>下一节，学习 纹理(Texture)。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/08-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/><span class=title>« Prev</span><br><span>08-Three.js基础之场景</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/10-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BA%B9%E7%90%86/><span class=title>Next »</span><br><span>10 Three.js基础之纹理</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>