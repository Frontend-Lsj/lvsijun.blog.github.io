<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>23 Three.js解决方案之加载.obj模型 | Bablvsj&#39;s Blog</title>
<meta name="keywords" content="Three.js">
<meta name="description" content="23 Three.js解决方案之加载.obj模型 - Bablvsj&#39;s Blog">
<meta name="author" content="">
<link rel="canonical" href="https://bablvsj.github.io/posts/threejs/23-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5525cc669fcb4f094a55bfc3ebfc5a6e73445e090010c66ab49c2cad14735f57.css" integrity="sha256-VSXMZp/LTwlKVb/D6/xabnNEXgkAEMZqtJwsrRRzX1c=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://bablvsj.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://bablvsj.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://bablvsj.github.io/img/Q.gif">
<link rel="apple-touch-icon" href="https://bablvsj.github.io/Q.gif">
<link rel="mask-icon" href="https://bablvsj.github.io/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="stylesheet" href="/css/syntax.css">


<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="23 Three.js解决方案之加载.obj模型" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bablvsj.github.io/posts/threejs/23-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T17:11:35+08:00" />
<meta property="article:modified_time" content="2023-12-19T17:11:35+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="23 Three.js解决方案之加载.obj模型"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "文章",
      "item": "https://bablvsj.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "23 Three.js解决方案之加载.obj模型",
      "item": "https://bablvsj.github.io/posts/threejs/23-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "23 Three.js解决方案之加载.obj模型",
  "name": "23 Three.js解决方案之加载.obj模型",
  "description": "",
  "keywords": [
    "Three.js"
  ],
  "articleBody": "本文将开始 Three.js 新的篇章—— Three.js 各种应用场景的解决方案。\n有 2 点会与之前的篇章不同：\n讲解内容时尽量简要，不再像前面 01-22 篇章那样啰嗦 和原版官方教程内容上略有不同，删除我认为没有必要的内容、增加上我自己补充的内容。 特别强调 1：从本文示例开始，我们将升级 React 和 Three.js 的版本\nreact 由原来的 17.0.2 升级为 17.0.3\n重点是 Three.js 由原来的 0.125.2 升级为 0.127.0\n由于 Three.js 版本迭代，对于某些类的引用路径、方法和属性的使用 难免会有一些变化。\n由于 Three.js 在 0.126.0 版本时已经默认不包含 .d.ts 文件，所以我们还需要额外单独安装 对应的 typescript 类型定义文件包\nyarn add @types/three //npm i @types/three 特别强调 2：尽管我们在前一章节花了非常多的时间研究出如果在 Web Worker 中渲染和控制 Threejs 3D 场景，但是本示例并不会选择使用 web worker，依然会选择直接在 JS 主场景中创建 3D 场景。\n正文开始…\n加载.obj(模型)文件 前言小絮\n在之前所有的示例中，场景中的 3D 物体元素都是直接在 Three.js 中创建的，但是 Three.js 毕竟不是专业的 3D 建模软件，所以实际工作中，我们更多的都是在传统 3D 建模软件中创建好模型，然后将模型导出成特定格式的文件，然后在 Three.js 中使用特定的加载器，将这些模型加载进来。\n让我们开始使用 Blender 尽管我更喜欢 C4D 这个软件，但是由于 C4D 为收费软件，所以在本教程中，我们将更多的使用 Blender 这个免费的 3D 建模软件。\n国外人很注意版权，所以很多教程中也都使用的是 Bleander。\n假设你希望自己创建的模型或者项目要跟别人交流，而你使用破解版的 C4D ，多少有一些隐患。\nBlender软件下载安装 Blender 不光免费，而且还支持简体中文。\n当前版本为 2.92.0\n下载地址：https://www.blender.org/download/\n软件安装好之后，第一次启动 Blender 时会有一个弹窗，在弹窗中将界面语言由 English 修改为 简体中文，这样软件界面就变成 简体中文了。\n关于Blender的基础用法，请参考我另外一篇学习笔记：Blender基础教程\n我也是刚开始学习 Blender，感兴趣一起学习吧。\n我本身就会一些基础的 C4D 软件操作，所以在学习 Blender 时并没有感觉特别吃力，只是觉得 Blender 各种操作的快捷键实在是太多了，有点难记。如果你是第一次接触 3D 建模软件，那…只能说，加油！\n使用Blender创建并导出3D模型——.obj文件 启动 Blender 之后，默认场景上有一个立方体，我们再添加几个其他元素，如 圆柱体、圆锥体、球体。\n关于Blender中“球体”的特别说明\n我们添加球体的操作是：物体模式下，点击 “添加 \u003e 表(曲)面 \u003e 球体”\n千万不要误操作成：“添加 \u003e 融球 \u003e 球”\n因为 Blender 中 融球 和 球体 虽然看上去都像球体，但是 2 者有很大的差别。\n这句话是废话，要是没差别也不会是不同操作了。\n所谓 融球 就是当 2 个融球彼此靠近一定程度后，2 个融球边缘会自动融合在一起，就是因为这个特性所以才被称为融球。融球本质上是 Blender 一种即时计算的数据公式。\n而 球体 就是属于普通的网格，2 个球体就算彼此靠得再近也不会发生相融的场景。\n我们只是简单将这几个元素修改一下位置，不做任何属性的调整，然后就直接导出模型。\n为什么不做复杂的调整？\n答：因为我也刚学 Blender，还不太会，就先这样吧。\n现在我们要导出刚才创建的 3D 场景元素，执行：\n文件 \u003e 导出 \u003e Wavefront(obj)\n在弹出的导出选项弹出中，我们什么也不修改，直接点击 导出OBJ，我们将文件名设置为 hello.obj。\n以下为默认的导出参数\n在 Objects as 选项中：\nOBJ 物体 (默认已勾选) OBJ组 (默认未被勾选) 材质组 (默认未被勾选) 动画 (默认未被勾选) 在 变换 选项中：\n缩放：1.00 (默认值) 路径模式：自动 (默认值) 前进：-Z 前进 (默认值) 向上：Y 向上 (默认值) 在 集合数据 选项中：\n应用修改器 (默认已勾选) 平滑组 (默认未被勾选) Bitflag平滑组 (默认未被勾选) 写入法线 (默认已勾选) 包括UV (默认已勾选) 写入材质 (默认已勾选) 三角面 (默认未被勾选) Curves as NURBS (默认未被勾选) 多边形组 (默认未被勾选) 保持顶点顺序 (默认未被勾选) 当导出完成后，我们会看到实际上产生了 2 个新文件：\nhello.obj hello.mtl 特别说明一下：\n.obj 这个文件是用来储存 3D模型 数据的\n请注意这里面只包含 3D模型 的数据和模型位置信息，并不包含 Blender 场景中的镜头和灯光\n.mtl 这个文件是用来储存 材质 数据的\n我们在 Blender 中创建的几个物体元素，实际上 Blender 已经给他们添加了默认的一个可反光材质。\n由于是可反光材质，所以请记得一定要在 Three.js 场景中添加灯光，否则这些物体都会看不见的。\n在 Blender 中材质包含有 纹理贴图，尽管此刻我们并未给材质设置任何纹理贴图。\n我们将得到的 hello.obj 文件拷贝到 React 项目中，路径为 src/assets/model/hello.obj\n接下来我们要开始编写 Three.js 相关代码了。\n加载 .obj 模型文件对应的类(加载器)为 OBJLoader OBJLoader 的用法也非常简单：\n最常用的方法为 .load()\nimport { OBJLoader } from \"three/examples/jsm/loaders/OBJLoader\" ... const loader = new OBJLoader() loader.load(require('@/assets/model/hello.obj').default, (group) =\u003e { console.log(group) scene.add(group) }, (event) =\u003e { console.log(Math.floor((event.loaded * 100) / event.total) + '% loaded') }, (error) =\u003e { console.log(error.type) }) 也可以使用异步的 loadAsync()，用法为：\nconst promise = loader.loadAsync(require('@/assets/model/hello.obj').default, (event) =\u003e { console.log(Math.floor((event.loaded * 100) / event.total) + '% loaded') }) promise.then((group) =\u003e { scene.add(group) }) 关于Three.js官方文档的一个小说明：\n如果你查看 OBJLoader 的官方文档，你会发现只介绍了 load() 方法，没有提及 loadAsync() ，这是为什么？\n即使你查看 OBJLoader 的源码，也会发现根本没有 loadAsync() 方法，那……\n这其实是因为 OBJLoader 继承于 Loader，而 loadAsync() 是由 Loader 定义的，所以才未出现在 OBJLoader 的文档中。\nThree.js 仓库管理员非常严谨，每次提交 PR 涉及修改一定要求你去修改对应的文档，所以如果以后发现某个方法并未出现在 要使用的类的介绍中，那么就去他的父类里查找即可。\n像别的编程语言文档，可能都会在某个类的介绍文章中，列出所继承父类的属性和方法，但是在 Three.js 中并未列出。\n我向官方提交了一个建议：https://github.com/mrdoob/three.js/issues/21640\n得到官方的回复内容为：\nIndeed. And that's the reasons why I not vote to do this. This approach would require a lot of manual effort and thus is error prone when things change. The documentation pages contain references like: See the base Material class for common properties. Same for methods. Considering that the documentation is not generated, I think it's better to stick with this approach. 官方回复的意思是：由于现在 Three.js 文档并不是自动生成的，如果那样做当发生变更时，每次都会产生大量的工作内容，所以…就先保持现状吧。\n完整的示例代码如下：\nsrc/components/hello-objloader/index.tsx\nimport { useRef, useEffect } from \"react\" import * as Three from 'three' import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\" import { OBJLoader } from \"three/examples/jsm/loaders/OBJLoader\" import './index.scss' const HelloOBJLoader = () =\u003e { const canvasRef = useRef(null) useEffect(() =\u003e { if (canvasRef.current === null) { return } const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current }) const scene = new Three.Scene() const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100) camera.position.set(10, 0, 10) const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1) scene.add(light) const control = new OrbitControls(camera, canvasRef.current) control.update() const loader = new OBJLoader() loader.load(require('@/assets/model/hello.obj').default, (group) =\u003e { console.log(group) scene.add(group) }, (event) =\u003e { console.log(Math.floor((event.loaded * 100) / event.total) + '% loaded') }, (error) =\u003e { console.log(error.type) }) const render = () =\u003e { renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) const handleResize = () =\u003e { if (canvasRef.current === null) { return } const width = canvasRef.current.clientWidth const height = canvasRef.current.clientHeight camera.aspect = width / height camera.updateProjectionMatrix() renderer.setSize(width, height, false) } handleResize() window.addEventListener('resize', handleResize) return () =\u003e { window.removeEventListener('resize', handleResize) } }, []) return ( ) } export default HelloOBJLoader 切记一定要给场景添加灯光，否则即使加载模型成功了，场景漆黑一片，也啥也看不见。\n此刻，我们在 Blender 中创建的 3D 模型已经加载并显示出来了，但是模型并没有任何材质，接下来我们要完善一下示例，给物体添加上材质。\n加载.mtl(材质和纹理)文件 首先，我们需要在 Blender 中给物体的材质添加纹理贴图。\n在Blender中给物体设置材质，添加纹理 具体步骤为：\n先准备一张 金属纹理贴图，将该图片文件命名为 metal_texture.jpg，暂且存放在 hello.blend 同级目录下。\n随着项目复杂，纹理图片资源变多，更加合理的是创建一个 texture 的目录，用来专门存放纹理图片资源\n在不选择任何物体的前提下，在 Blender 右侧选项面板中，找到 “材质属性” 面板，我们会看到 默认材质 Material，在 “表(曲)面 - 基础色” 设置中，找到 “基础色”，点击左侧的 小圆点，在弹出菜单中选择 “图像纹理”。\n如果你不小心点击的是 “基础色” 右侧的区域，则会出现 调色板\n此时 基础色 已修改为 图像纹理 状态，我们点击 “打开”，在弹窗中找到 metal_texture.jpg 并点击 “打开图片\"，这样该纹理图片已添加到 材质 Material 中了。\n接下来我们需要做的就是依次选中(或全选)立方体、圆柱体、椎体、球体，然后在材质属性面板中，找到 “材质图标”，鼠标放上去会显示提示文字：浏览要关联的材质，点击该图标，选择 Material\n请注意是一个图标，而不是什么按钮，更不要点击 “新建”\n至此，我们已经将所有物体均设置一个相同材质纹理图片。\n如果感兴趣，你完全可以自己给不同物体设置不同的材质纹理图片\n让我们先简单渲染一下，看看效果吧。\n首先我们调整好场景视角，然后执行 “视图 \u003e 对齐视图 \u003e 活动相机对齐当前视角”，这一步的快捷键为 Ctrl + Alt + Numpad0。\n然后我们点击 Blender 顶部菜单 “渲染 \u003e 渲染图像”，这一步的快捷键为 F12，接下来就渲染弹窗中就可以看到物体渲染后的样子。\n假设你不会 Blender，也没有关系，可以忽略我上面这段关于如何在 Blender 中创建模型和添加材质、纹理的操作。\n导出模型\n“文件 \u003e 导出 \u003e Wavefront(.obj)”\n我们看一下 Three.js 官方文档中对 .mtl 文件的描述：\n材质模版库（MTL）或 .MTL 文件格式是 .OBJ 的配套文件格式， 用于描述一个或多个 .OBJ 文件中物体表面着色（材质）属性。\n实际看看 hello.mtl 文件具体是什么内容\n我们可以使用 记事本 或 vscode 打开 hello.mtl 文件，内容如下：\n# Blender MTL File: 'hello.blend' # Material Count: 1 newmtl Material Ns 323.999994 Ka 1.000000 1.000000 1.000000 Kd 0.800000 0.800000 0.800000 Ks 0.500000 0.500000 0.500000 Ke 0.000000 0.000000 0.000000 Ni 1.450000 d 1.000000 illum 2 map_Kd metal_texture.jpg 我们可以看到最后一行 map_Kd metal_texture.jpg，大概也可以猜到这一行表明材质纹理图片的路径和文件名，并且路径是相对路径。\n由于我们将 metal_texture.jpg 存放在 hello.blend 同一目录下。\n关于.mtl文件内容的补充说明：\n下面我将针对上面的 .mtl 文件内容进行逐一解释\n#：注释内容 newtml：材质的名称 Ns：反射指数，即反射高光度，值越高则高光越密集，一般取值范围 0 - 1000 Ka：材质的环境光，一般取值范围 0 - 1 Kd：散射光 Ks：镜面光 Ni：折射光，一般取值范围 0.01 - 10 d：渐隐指数，取值范围为 0 - 1，当值为 1 时完全不透明，当值为 0 时完全透明 illum：材质的光照模型，值为整数，取值范围为 0 - 10 map_Kd：漫反射指定颜色纹理贴图文件路径 上面属性中 illum 实际上是 “illumination model”，即光照模型。\nillum 的取值分别对应的是：\n取值 光照模型 中文名 0 Color on and Ambient off 色彩开，阴影色关 1 Color on and Ambient on 色彩开，阴影色开 2 Highlight on 高光开 3 Reflection on and Ray trace on 反射开，光线追踪开 4 Transparency: Glass on / Reflection: Ray trace on 透明： 玻璃开 反射：光线追踪开 5 Reflection: Fresnel on and Ray trace on 反射：菲涅尔衍射开，光线追踪开 6 Transparency: Refraction on / Reflection: Fresnel off and Ray trace on 透明：折射开 反射：菲涅尔衍射关，光线追踪开 7 Transparency: Refraction on / Reflection: Fresnel on and Ray trace on 透明：折射开 反射：菲涅尔衍射开，光线追踪开 8 Reflection on and Ray trace off 反射开，光线追踪关 9 Transparency: Glass on / Reflection: Ray trace off 透明： 玻璃开 反射：光线追踪关 10 Casts shadows onto invisible surfaces 投射阴影于不可见表面 那么问题来了，由于 hello.mtl 中包含纹理图片的路径，如果我们将 图片资源(metal_texture.jpg) 拷贝到 src/assets/model 中，.jpg 图片会被 webpack 重新编译成别的文件名，这会造成我们加载不到 纹理图片 资源。\n最简单的解决办法，就是将 .obj/.mtl/.jpg 这 3 个文件资源存放在 public 目录中，而不是在 src 目录中。\npublic 目录里的文件是不会被 webpack 编译重命名的。\n拷贝文件到 Three.js 项目中\n我们在React 项目根目录的 public 目录下创建 model 目录，然后将新导出的 3 个文件：hello.obj、hello.mtl、metal_texture.jpg 拷贝到 public/model/ 中。\n至此，前期准备工作完毕，接下来转到 Three.js 项目代码中。\n加载 .mtl 表面着色器(材质)对应的类(加载器)为 MTLLoader 在 Three.js 中，各种加载器的用法几乎完全相同。\n我们需要做的事情就是：\n先使用 MTLLoader 实例 加载材质(纹理图片)资源\n特别强调一下，MTLLoader 实例 加载得到的对象类型并不是 Three.Metrial ，而是 MTLLoader.MaterialCreator\n加载完成后，将得到的 MaterialCreator 实例 赋予给 OBJLoader 实例\n这样 OBJLoader 以后加载的任意模型都会自动应用该 MaterialCreator 材质\n然后再让 OBJLoader 实例 去加载模型\n加载完成后，将模型添加到场景中\n实际代码：\nimport { MTLLoader } from \"three/examples/jsm/loaders/MTLLoader\" import { OBJLoader } from \"three/examples/jsm/loaders/OBJLoader\" ... const mtlLoader = new MTLLoader() const objLoader = new OBJLoader() mtlLoader.load('./model/hello.mtl', (materialCreator) =\u003e { objLoader.setMaterials(materialCreator) objLoader.load('./model/hello.obj', (group) =\u003e { scene.add(group) }) }) 请注意上述代码加载的资源地址为 “./model/hello.mtl” 和 “./model/hello.obj”，这里是相对路径，相对编译之后的 index.html 而言。\n完整的代码：\nimport { useRef, useEffect } from \"react\" import * as Three from 'three' import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\" import { MTLLoader } from \"three/examples/jsm/loaders/MTLLoader\" import { OBJLoader } from \"three/examples/jsm/loaders/OBJLoader\" import './index.scss' const HelloOBJLoader = () =\u003e { const canvasRef = useRef(null) useEffect(() =\u003e { if (canvasRef.current === null) { return } const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current }) const scene = new Three.Scene() const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100) camera.position.set(10, 0, 10) const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1) scene.add(light) const mtlLoader = new MTLLoader() const objLoader = new OBJLoader() mtlLoader.load('./model/hello.mtl', (materialCreator) =\u003e { objLoader.setMaterials(materialCreator) objLoader.load('./model/hello.obj', (group) =\u003e { scene.add(group) }) }) const control = new OrbitControls(camera, canvasRef.current) control.update() const render = () =\u003e { renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) const handleResize = () =\u003e { if (canvasRef.current === null) { return } const width = canvasRef.current.clientWidth const height = canvasRef.current.clientHeight camera.aspect = width / height camera.updateProjectionMatrix() renderer.setSize(width, height, false) } handleResize() window.addEventListener('resize', handleResize) return () =\u003e { window.removeEventListener('resize', handleResize) } }, []) return ( ) } export default HelloOBJLoader 至此，我们已经讲解完如何加载 .mtl 和 .obj 文件。\n.obj文件类型的一些特别之处 本文讲解的是在 Blender 中导出 wavefront(.obj) 文件格式。\n这里要针对性的进行补充：\nBlender 可以导出 N 多种文件格式\n.obj 仅仅是其中一种\nThree.js 支持多种 3D 文件模型格式\n本文讲解的是加载 .obj\n.obj格式的一些特点：\n行业内比较广泛使用\n.obj是一种纯文本格式\n本文中我们使用记事本打开了 .mtl 文件，并未打开 .obj 文件，感兴趣的可以自己尝试看看具体都是什么内容。\n.obj包含的内容有：Mesh(网格)、按组/物体分离、材质/纹理、NURBS曲线和曲面\n.obj不包含(不支持导出)的内容有：网格顶点颜色、骨架、动画、灯光、相机、空物体、父子关系或变换\n以上特性中不难看出 .obj 有优点，也有缺点。\n优点：只包含物体模型数据本身\n缺点：不包含其他复杂元素(动画、相机、灯光等)\n接下来，我们将在下一章节中，讲解另外一种 3D 模型格式文件：.gLTF\ngLTF 格式可以包含更多复杂的元素数据。\n为什么要自己学习Blender？ 我个人认为，如果你想深入学习 3D，学习 Three.js，那么你就需要掌握一门 3D 建模软件。\n你可以不精通，但是基础的操作你要掌握，这样非常利于你对于 Three.js 3D 概念的理解。\n如果你不会 3D 建模软件，那么你只能直接在 Three.js 中去创建模型，这将是一件非常费力的事情，并且也无法做到精准建模，对模型的细腻雕刻。\n你总不能完全依靠别人给你提供建好的模型，做到饭来张口的状态吧。\n自己能够掌握 3D 建模，越建越快乐。\n这也是为什么本文花了大量篇幅在一步一步讲解 Blender 中的各种操作的原因。\n我也是 Blender 新手小白，希望我们一起学习，一起加油。\n如果本文中讲解的 Blender 你根本不会操作，也不感兴趣安装学习，那么你可以直接在网上搜索一些 .obj 和 .mtl 文件进行代替学习。\n这里提供 2 个文件资源，你可以直接下载使用：\nhttps://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill-fixed.mtl\nhttps://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill.obj\n我们下一章节见。\n",
  "wordCount" : "5583",
  "inLanguage": "en",
  "datePublished": "2023-12-19T17:11:35+08:00",
  "dateModified": "2023-12-19T17:11:35+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://bablvsj.github.io/posts/threejs/23-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.obj%E6%A8%A1%E5%9E%8B/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Bablvsj's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://bablvsj.github.io/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://bablvsj.github.io" accesskey="h" title="Bablvsj&#39;s Blog (Alt + H)">Bablvsj&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://bablvsj.github.io/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/tags" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/about" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/search" title="🔍 (Alt &#43; /)" accesskey=/>
                    <span>🔍</span>
                </a>
            </li>
        </ul>
    </nav>
</header>


<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      23 Three.js解决方案之加载.obj模型
    </h1>
    <div class="post-meta">
      
<div class="post-tags-meta">
    <a href="https://bablvsj.github.io/tags/three.js/">Three.js</a>
</div>

12 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 CST'>2023/12/19</span>


      
    </div>
    
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        
        <div class="inner"><ul>
                <li>
                    <a href="#%e5%8a%a0%e8%bd%bdobj%e6%a8%a1%e5%9e%8b%e6%96%87%e4%bb%b6" aria-label="加载.obj(模型)文件">加载.obj(模型)文件</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e8%ae%a9%e6%88%91%e4%bb%ac%e5%bc%80%e5%a7%8b%e4%bd%bf%e7%94%a8-blender" aria-label="让我们开始使用 Blender">让我们开始使用 Blender</a></li>
                <li>
                    <a href="#blender%e8%bd%af%e4%bb%b6%e4%b8%8b%e8%bd%bd%e5%ae%89%e8%a3%85" aria-label="Blender软件下载安装">Blender软件下载安装</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8blender%e5%88%9b%e5%bb%ba%e5%b9%b6%e5%af%bc%e5%87%ba3d%e6%a8%a1%e5%9e%8bobj%e6%96%87%e4%bb%b6" aria-label="使用Blender创建并导出3D模型——.obj文件">使用Blender创建并导出3D模型——.obj文件</a></li>
                <li>
                    <a href="#%e5%8a%a0%e8%bd%bd-obj-%e6%a8%a1%e5%9e%8b%e6%96%87%e4%bb%b6%e5%af%b9%e5%ba%94%e7%9a%84%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e4%b8%ba-objloader" aria-label="加载 .obj 模型文件对应的类(加载器)为 OBJLoader">加载 .obj 模型文件对应的类(加载器)为 OBJLoader</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e5%8a%a0%e8%bd%bdmtl%e6%9d%90%e8%b4%a8%e5%92%8c%e7%ba%b9%e7%90%86%e6%96%87%e4%bb%b6" aria-label="加载.mtl(材质和纹理)文件">加载.mtl(材质和纹理)文件</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e5%9c%a8blender%e4%b8%ad%e7%bb%99%e7%89%a9%e4%bd%93%e8%ae%be%e7%bd%ae%e6%9d%90%e8%b4%a8%e6%b7%bb%e5%8a%a0%e7%ba%b9%e7%90%86" aria-label="在Blender中给物体设置材质，添加纹理">在Blender中给物体设置材质，添加纹理</a></li>
                <li>
                    <a href="#%e5%8a%a0%e8%bd%bd-mtl-%e8%a1%a8%e9%9d%a2%e7%9d%80%e8%89%b2%e5%99%a8%e6%9d%90%e8%b4%a8%e5%af%b9%e5%ba%94%e7%9a%84%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8%e4%b8%ba-mtlloader" aria-label="加载 .mtl 表面着色器(材质)对应的类(加载器)为 MTLLoader">加载 .mtl 表面着色器(材质)对应的类(加载器)为 MTLLoader</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#obj%e6%96%87%e4%bb%b6%e7%b1%bb%e5%9e%8b%e7%9a%84%e4%b8%80%e4%ba%9b%e7%89%b9%e5%88%ab%e4%b9%8b%e5%a4%84" aria-label=".obj文件类型的一些特别之处">.obj文件类型的一些特别之处</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e8%87%aa%e5%b7%b1%e5%ad%a6%e4%b9%a0blender" aria-label="为什么要自己学习Blender？">为什么要自己学习Blender？</a>
                </li>
            </ul>
        </div>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>本文将开始 Three.js 新的篇章—— Three.js 各种应用场景的解决方案。</p>
<p>有 2 点会与之前的篇章不同：</p>
<ol>
<li>讲解内容时尽量简要，不再像前面 01-22 篇章那样啰嗦</li>
<li>和原版官方教程内容上略有不同，删除我认为没有必要的内容、增加上我自己补充的内容。</li>
</ol>
<br>
<p><strong>特别强调 1：从本文示例开始，我们将升级 React 和 Three.js 的版本</strong></p>
<ol>
<li>
<p>react  由原来的 17.0.2 升级为 17.0.3</p>
</li>
<li>
<p>重点是 Three.js 由原来的 0.125.2 升级为 0.127.0</p>
<blockquote>
<p>由于 Three.js 版本迭代，对于某些类的引用路径、方法和属性的使用 难免会有一些变化。</p>
</blockquote>
</li>
<li>
<p>由于 Three.js 在 0.126.0 版本时已经默认不包含 .d.ts 文件，所以我们还需要额外单独安装 对应的 typescript 类型定义文件包</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>yarn add @types/three
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>//npm i @types/three
</span></span></code></pre></div></li>
</ol>
<br>
<p><strong>特别强调 2：尽管我们在前一章节花了非常多的时间研究出如果在 Web Worker 中渲染和控制 Threejs 3D 场景，但是本示例并不会选择使用 web worker，依然会选择直接在 JS 主场景中创建 3D 场景。</strong></p>
<br>
<p>正文开始&hellip;</p>
<h2 id="加载obj模型文件">加载.obj(模型)文件<a hidden class="anchor" aria-hidden="true" href="#加载obj模型文件">#</a></h2>
<br>
<p><strong>前言小絮</strong></p>
<p>在之前所有的示例中，场景中的 3D 物体元素都是直接在 Three.js 中创建的，但是 Three.js 毕竟不是专业的 3D 建模软件，所以实际工作中，我们更多的都是在传统 3D 建模软件中创建好模型，然后将模型导出成特定格式的文件，然后在 Three.js 中使用特定的加载器，将这些模型加载进来。</p>
<br>
<h4 id="让我们开始使用-blender">让我们开始使用 Blender<a hidden class="anchor" aria-hidden="true" href="#让我们开始使用-blender">#</a></h4>
<p>尽管我更喜欢 C4D 这个软件，但是由于 C4D 为收费软件，所以在本教程中，我们将更多的使用 Blender 这个免费的 3D 建模软件。</p>
<p>国外人很注意版权，所以很多教程中也都使用的是 Bleander。</p>
<p>假设你希望自己创建的模型或者项目要跟别人交流，而你使用破解版的 C4D ，多少有一些隐患。</p>
<br>
<h4 id="blender软件下载安装">Blender软件下载安装<a hidden class="anchor" aria-hidden="true" href="#blender软件下载安装">#</a></h4>
<p>Blender 不光免费，而且还支持简体中文。</p>
<blockquote>
<p>当前版本为 2.92.0</p>
</blockquote>
<p>下载地址：<a href="https://www.blender.org/download/">https://www.blender.org/download/</a></p>
<blockquote>
<p>软件安装好之后，第一次启动 Blender 时会有一个弹窗，在弹窗中将界面语言由 English 修改为 简体中文，这样软件界面就变成 简体中文了。</p>
</blockquote>
<br>
<p><strong>关于Blender的基础用法，请参考我另外一篇学习笔记：<a href="https://github.com/puxiao/notes/blob/master/Blender%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.md">Blender基础教程</a></strong></p>
<p>我也是刚开始学习 Blender，感兴趣一起学习吧。</p>
<blockquote>
<p>我本身就会一些基础的 C4D 软件操作，所以在学习 Blender 时并没有感觉特别吃力，只是觉得 Blender 各种操作的快捷键实在是太多了，有点难记。如果你是第一次接触 3D 建模软件，那&hellip;只能说，加油！</p>
</blockquote>
<br>
<h4 id="使用blender创建并导出3d模型obj文件">使用Blender创建并导出3D模型——.obj文件<a hidden class="anchor" aria-hidden="true" href="#使用blender创建并导出3d模型obj文件">#</a></h4>
<p>启动 Blender 之后，默认场景上有一个立方体，我们再添加几个其他元素，如 圆柱体、圆锥体、球体。</p>
<p><strong>关于Blender中“球体”的特别说明</strong></p>
<p>我们添加球体的操作是：物体模式下，点击 “添加 &gt; 表(曲)面 &gt; 球体”</p>
<p>千万不要误操作成：“添加 &gt; 融球 &gt; 球”</p>
<p>因为 Blender 中 融球 和 球体 虽然看上去都像球体，但是 2 者有很大的差别。</p>
<blockquote>
<p>这句话是废话，要是没差别也不会是不同操作了。</p>
<p>所谓 融球 就是当 2 个融球彼此靠近一定程度后，2 个融球边缘会自动融合在一起，就是因为这个特性所以才被称为融球。融球本质上是 Blender 一种即时计算的数据公式。</p>
<p>而 球体 就是属于普通的网格，2 个球体就算彼此靠得再近也不会发生相融的场景。</p>
</blockquote>
<br>
<p>我们只是简单将这几个元素修改一下位置，不做任何属性的调整，然后就直接导出模型。</p>
<blockquote>
<p>为什么不做复杂的调整？<br>
答：因为我也刚学 Blender，还不太会，就先这样吧。</p>
</blockquote>
<br>
<p>现在我们要导出刚才创建的 3D 场景元素，执行：</p>
<p><strong>文件 &gt; 导出 &gt; Wavefront(obj)</strong></p>
<p>在弹出的导出选项弹出中，我们什么也不修改，直接点击 导出OBJ，我们将文件名设置为 hello.obj。</p>
<blockquote>
<p>以下为默认的导出参数</p>
<p>在 Objects as 选项中：</p>
<ol>
<li>OBJ 物体 (默认已勾选)</li>
<li>OBJ组 (默认未被勾选)</li>
<li>材质组 (默认未被勾选)</li>
<li>动画 (默认未被勾选)</li>
</ol>
<p>在 变换 选项中：</p>
<ol>
<li>缩放：1.00 (默认值)</li>
<li>路径模式：自动  (默认值)</li>
<li>前进：-Z 前进  (默认值)</li>
<li>向上：Y 向上  (默认值)</li>
</ol>
<p>在 集合数据 选项中：</p>
<ol>
<li>应用修改器 (默认已勾选)</li>
<li>平滑组 (默认未被勾选)</li>
<li>Bitflag平滑组 (默认未被勾选)</li>
<li>写入法线 (默认已勾选)</li>
<li>包括UV (默认已勾选)</li>
<li>写入材质 (默认已勾选)</li>
<li>三角面 (默认未被勾选)</li>
<li>Curves as NURBS (默认未被勾选)</li>
<li>多边形组 (默认未被勾选)</li>
<li>保持顶点顺序 (默认未被勾选)</li>
</ol>
</blockquote>
<br>
<p>当导出完成后，我们会看到实际上产生了 2 个新文件：</p>
<ol>
<li>hello.obj</li>
<li>hello.mtl</li>
</ol>
<p>特别说明一下：</p>
<ol>
<li>
<p>.obj 这个文件是用来储存 3D模型 数据的</p>
<blockquote>
<p>请注意这里面只包含 3D模型 的数据和模型位置信息，并不包含 Blender 场景中的镜头和灯光</p>
</blockquote>
</li>
<li>
<p>.mtl 这个文件是用来储存 材质 数据的</p>
<blockquote>
<p>我们在 Blender 中创建的几个物体元素，<strong>实际上 Blender 已经给他们添加了默认的一个可反光材质</strong>。</p>
<p>由于是可反光材质，所以请记得一定要在 Three.js 场景中添加灯光，否则这些物体都会看不见的。</p>
</blockquote>
<blockquote>
<p>在 Blender 中材质包含有 纹理贴图，尽管此刻我们并未给材质设置任何纹理贴图。</p>
</blockquote>
</li>
</ol>
<br>
<p>我们将得到的 hello.obj 文件拷贝到 React 项目中，路径为 src/assets/model/hello.obj</p>
<p>接下来我们要开始编写 Three.js 相关代码了。</p>
<br>
<h4 id="加载-obj-模型文件对应的类加载器为-objloader">加载 .obj 模型文件对应的类(加载器)为 OBJLoader<a hidden class="anchor" aria-hidden="true" href="#加载-obj-模型文件对应的类加载器为-objloader">#</a></h4>
<p>OBJLoader 的用法也非常简单：</p>
<blockquote>
<p>最常用的方法为 .load()</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>import { OBJLoader } from &#34;three/examples/jsm/loaders/OBJLoader&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const loader = new OBJLoader()
</span></span><span style="display:flex;"><span>    loader.load(require(&#39;@/assets/model/hello.obj&#39;).default, (group) =&gt; {
</span></span><span style="display:flex;"><span>        console.log(group)
</span></span><span style="display:flex;"><span>        scene.add(group)
</span></span><span style="display:flex;"><span>    }, (event) =&gt; {
</span></span><span style="display:flex;"><span>        console.log(Math.floor((event.loaded * 100) / event.total) + &#39;% loaded&#39;)
</span></span><span style="display:flex;"><span>    }, (error) =&gt; {
</span></span><span style="display:flex;"><span>        console.log(error.type)
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><br>
<p>也可以使用异步的 loadAsync()，用法为：</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const promise = loader.loadAsync(require(&#39;@/assets/model/hello.obj&#39;).default, (event) =&gt; {
</span></span><span style="display:flex;"><span>            console.log(Math.floor((event.loaded * 100) / event.total) + &#39;% loaded&#39;)
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>promise.then((group) =&gt; {
</span></span><span style="display:flex;"><span>            scene.add(group)
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><br>
<p><strong>关于Three.js官方文档的一个小说明：</strong></p>
<p>如果你查看 OBJLoader 的官方文档，你会发现只介绍了 load() 方法，没有提及 loadAsync() ，这是为什么？</p>
<blockquote>
<p>即使你查看 OBJLoader 的源码，也会发现根本没有 loadAsync() 方法，那&hellip;&hellip;</p>
</blockquote>
<p>这其实是因为 OBJLoader 继承于 Loader，而 loadAsync() 是由 Loader 定义的，所以才未出现在 OBJLoader 的文档中。</p>
<p>Three.js 仓库管理员非常严谨，每次提交 PR 涉及修改一定要求你去修改对应的文档，所以如果以后发现某个方法并未出现在 要使用的类的介绍中，那么就去他的父类里查找即可。</p>
<br>
<blockquote>
<p>像别的编程语言文档，可能都会在某个类的介绍文章中，列出所继承父类的属性和方法，但是在 Three.js 中并未列出。</p>
</blockquote>
<blockquote>
<p>我向官方提交了一个建议：<a href="https://github.com/mrdoob/three.js/issues/21640">https://github.com/mrdoob/three.js/issues/21640</a></p>
<p>得到官方的回复内容为：</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Indeed. And that&#39;s the reasons why I not vote to do this. This approach would require a lot of manual effort and thus is error prone when things change.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>The documentation pages contain references like:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>See the base Material class for common properties.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Same for methods. Considering that the documentation is not generated, I think it&#39;s better to stick with this approach.
</span></span></code></pre></div><p>官方回复的意思是：由于现在 Three.js 文档并不是自动生成的，如果那样做当发生变更时，每次都会产生大量的工作内容，所以&hellip;就先保持现状吧。</p>
</blockquote>
<br>
<p>完整的示例代码如下：</p>
<p>src/components/hello-objloader/index.tsx</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>import { useRef, useEffect } from &#34;react&#34;
</span></span><span style="display:flex;"><span>import * as Three from &#39;three&#39;
</span></span><span style="display:flex;"><span>import { OrbitControls } from &#34;three/examples/jsm/controls/OrbitControls&#34;
</span></span><span style="display:flex;"><span>import { OBJLoader } from &#34;three/examples/jsm/loaders/OBJLoader&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import &#39;./index.scss&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const HelloOBJLoader = () =&gt; {
</span></span><span style="display:flex;"><span>    const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
</span></span><span style="display:flex;"><span>        const scene = new Three.Scene()
</span></span><span style="display:flex;"><span>        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
</span></span><span style="display:flex;"><span>        camera.position.set(10, 0, 10)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1)
</span></span><span style="display:flex;"><span>        scene.add(light)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const control = new OrbitControls(camera, canvasRef.current)
</span></span><span style="display:flex;"><span>        control.update()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const loader = new OBJLoader()
</span></span><span style="display:flex;"><span>        loader.load(require(&#39;@/assets/model/hello.obj&#39;).default, (group) =&gt; {
</span></span><span style="display:flex;"><span>            console.log(group)
</span></span><span style="display:flex;"><span>            scene.add(group)
</span></span><span style="display:flex;"><span>        }, (event) =&gt; {
</span></span><span style="display:flex;"><span>            console.log(Math.floor((event.loaded * 100) / event.total) + &#39;% loaded&#39;)
</span></span><span style="display:flex;"><span>        }, (error) =&gt; {
</span></span><span style="display:flex;"><span>            console.log(error.type)
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const render = () =&gt; {
</span></span><span style="display:flex;"><span>            renderer.render(scene, camera)
</span></span><span style="display:flex;"><span>            window.requestAnimationFrame(render)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        window.requestAnimationFrame(render)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const handleResize = () =&gt; {
</span></span><span style="display:flex;"><span>            if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            const width = canvasRef.current.clientWidth
</span></span><span style="display:flex;"><span>            const height = canvasRef.current.clientHeight
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            camera.aspect = width / height
</span></span><span style="display:flex;"><span>            camera.updateProjectionMatrix()
</span></span><span style="display:flex;"><span>            renderer.setSize(width, height, false)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        handleResize()
</span></span><span style="display:flex;"><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return () =&gt; {
</span></span><span style="display:flex;"><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }, [])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return (
</span></span><span style="display:flex;"><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export default HelloOBJLoader
</span></span></code></pre></div><blockquote>
<p>切记一定要给场景添加灯光，否则即使加载模型成功了，场景漆黑一片，也啥也看不见。</p>
</blockquote>
<br>
<p>此刻，我们在 Blender 中创建的 3D 模型已经加载并显示出来了，但是模型并没有任何材质，接下来我们要完善一下示例，给物体添加上材质。</p>
<br>
<h2 id="加载mtl材质和纹理文件">加载.mtl(材质和纹理)文件<a hidden class="anchor" aria-hidden="true" href="#加载mtl材质和纹理文件">#</a></h2>
<p>首先，我们需要在 Blender 中给物体的材质添加纹理贴图。</p>
<br>
<h4 id="在blender中给物体设置材质添加纹理">在Blender中给物体设置材质，添加纹理<a hidden class="anchor" aria-hidden="true" href="#在blender中给物体设置材质添加纹理">#</a></h4>
<p>具体步骤为：</p>
<ol>
<li>
<p>先准备一张 金属纹理贴图，将该图片文件命名为 metal_texture.jpg，暂且存放在 hello.blend 同级目录下。</p>
<blockquote>
<p>随着项目复杂，纹理图片资源变多，更加合理的是创建一个 texture 的目录，用来专门存放纹理图片资源</p>
</blockquote>
</li>
<li>
<p>在不选择任何物体的前提下，在 Blender 右侧选项面板中，找到 “材质属性” 面板，我们会看到 默认材质 Material，在 “表(曲)面 - 基础色” 设置中，找到 “基础色”，点击左侧的 小圆点，在弹出菜单中选择 “图像纹理”。</p>
<blockquote>
<p>如果你不小心点击的是 “基础色”  右侧的区域，则会出现 调色板</p>
</blockquote>
</li>
<li>
<p>此时 基础色 已修改为 图像纹理 状态，我们点击 “打开”，在弹窗中找到 metal_texture.jpg 并点击 “打开图片&quot;，这样该纹理图片已添加到 材质 Material 中了。</p>
</li>
<li>
<p>接下来我们需要做的就是依次选中(或全选)立方体、圆柱体、椎体、球体，然后在材质属性面板中，找到 “材质图标”，鼠标放上去会显示提示文字：浏览要关联的材质，点击该图标，选择 Material</p>
<blockquote>
<p>请注意是一个图标，而不是什么按钮，更不要点击 “新建”</p>
</blockquote>
</li>
<li>
<p>至此，我们已经将所有物体均设置一个相同材质纹理图片。</p>
<blockquote>
<p>如果感兴趣，你完全可以自己给不同物体设置不同的材质纹理图片</p>
</blockquote>
</li>
</ol>
<br>
<p>让我们先简单渲染一下，看看效果吧。</p>
<p>首先我们调整好场景视角，然后执行 “视图 &gt; 对齐视图 &gt; 活动相机对齐当前视角”，这一步的快捷键为 <code>Ctrl + Alt + Numpad0</code>。</p>
<p>然后我们点击 Blender 顶部菜单 “渲染 &gt; 渲染图像”，这一步的快捷键为 F12，接下来就渲染弹窗中就可以看到物体渲染后的样子。</p>
<br>
<blockquote>
<p>假设你不会 Blender，也没有关系，可以忽略我上面这段关于如何在 Blender 中创建模型和添加材质、纹理的操作。</p>
</blockquote>
<br>
<p><strong>导出模型</strong></p>
<p>&ldquo;文件 &gt; 导出 &gt; Wavefront(.obj)&rdquo;</p>
<br>
<p><strong>我们看一下 Three.js 官方文档中对 .mtl 文件的描述：</strong></p>
<p>材质模版库（MTL）或 .MTL 文件格式是 .OBJ 的配套文件格式， 用于描述一个或多个 .OBJ 文件中物体表面着色（材质）属性。</p>
<br>
<p><strong>实际看看 hello.mtl 文件具体是什么内容</strong></p>
<p>我们可以使用 记事本 或 vscode 打开 hello.mtl 文件，内容如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span># Blender MTL File: &#39;hello.blend&#39;
</span></span><span style="display:flex;"><span># Material Count: 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>newmtl Material
</span></span><span style="display:flex;"><span>Ns 323.999994
</span></span><span style="display:flex;"><span>Ka 1.000000 1.000000 1.000000
</span></span><span style="display:flex;"><span>Kd 0.800000 0.800000 0.800000
</span></span><span style="display:flex;"><span>Ks 0.500000 0.500000 0.500000
</span></span><span style="display:flex;"><span>Ke 0.000000 0.000000 0.000000
</span></span><span style="display:flex;"><span>Ni 1.450000
</span></span><span style="display:flex;"><span>d 1.000000
</span></span><span style="display:flex;"><span>illum 2
</span></span><span style="display:flex;"><span>map_Kd metal_texture.jpg
</span></span></code></pre></div><p>我们可以看到最后一行 <code>map_Kd metal_texture.jpg</code>，大概也可以猜到这一行表明材质纹理图片的路径和文件名，并且路径是相对路径。</p>
<blockquote>
<p>由于我们将 metal_texture.jpg 存放在 hello.blend 同一目录下。</p>
</blockquote>
<br>
<p><strong>关于.mtl文件内容的补充说明：</strong></p>
<blockquote>
<p>下面我将针对上面的 .mtl 文件内容进行逐一解释</p>
</blockquote>
<ol>
<li>#：注释内容</li>
<li>newtml：材质的名称</li>
<li>Ns：反射指数，即反射高光度，值越高则高光越密集，一般取值范围 0 - 1000</li>
<li>Ka：材质的环境光，一般取值范围 0 - 1</li>
<li>Kd：散射光</li>
<li>Ks：镜面光</li>
<li>Ni：折射光，一般取值范围 0.01 - 10</li>
<li>d：渐隐指数，取值范围为 0 - 1，当值为 1 时完全不透明，当值为 0 时完全透明</li>
<li>illum：材质的光照模型，值为整数，取值范围为 0 - 10</li>
<li>map_Kd：漫反射指定颜色纹理贴图文件路径</li>
</ol>
<br>
<p>上面属性中 illum 实际上是 “illumination model”，即光照模型。</p>
<p>illum 的取值分别对应的是：</p>
<table>
<thead>
<tr>
<th>取值</th>
<th>光照模型</th>
<th>中文名</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Color on and Ambient off</td>
<td>色彩开，阴影色关</td>
</tr>
<tr>
<td>1</td>
<td>Color on and Ambient on</td>
<td>色彩开，阴影色开</td>
</tr>
<tr>
<td>2</td>
<td>Highlight on</td>
<td>高光开</td>
</tr>
<tr>
<td>3</td>
<td>Reflection on and Ray trace on</td>
<td>反射开，光线追踪开</td>
</tr>
<tr>
<td>4</td>
<td>Transparency: Glass on / Reflection: Ray trace on</td>
<td>透明： 玻璃开 反射：光线追踪开</td>
</tr>
<tr>
<td>5</td>
<td>Reflection: Fresnel on and Ray trace on</td>
<td>反射：菲涅尔衍射开，光线追踪开</td>
</tr>
<tr>
<td>6</td>
<td>Transparency: Refraction on / Reflection: Fresnel off and Ray trace on</td>
<td>透明：折射开 反射：菲涅尔衍射关，光线追踪开</td>
</tr>
<tr>
<td>7</td>
<td>Transparency: Refraction on / Reflection: Fresnel on and Ray trace on</td>
<td>透明：折射开 反射：菲涅尔衍射开，光线追踪开</td>
</tr>
<tr>
<td>8</td>
<td>Reflection on and Ray trace off</td>
<td>反射开，光线追踪关</td>
</tr>
<tr>
<td>9</td>
<td>Transparency: Glass on / Reflection: Ray trace off</td>
<td>透明： 玻璃开 反射：光线追踪关</td>
</tr>
<tr>
<td>10</td>
<td>Casts shadows onto invisible surfaces</td>
<td>投射阴影于不可见表面</td>
</tr>
</tbody>
</table>
<br>
<p><strong>那么问题来了，由于 hello.mtl 中包含纹理图片的路径，如果我们将 图片资源(metal_texture.jpg) 拷贝到 src/assets/model 中，.jpg 图片会被 webpack 重新编译成别的文件名，这会造成我们加载不到 纹理图片 资源。</strong></p>
<br>
<p><strong>最简单的解决办法，就是将 .obj/.mtl/.jpg 这 3 个文件资源存放在 public 目录中，而不是在 src 目录中。</strong></p>
<blockquote>
<p>public 目录里的文件是不会被 webpack 编译重命名的。</p>
</blockquote>
<br>
<p><strong>拷贝文件到 Three.js 项目中</strong></p>
<p>我们在React 项目根目录的 public 目录下创建 model 目录，然后将新导出的 3 个文件：hello.obj、hello.mtl、metal_texture.jpg 拷贝到 public/model/ 中。</p>
<br>
<p>至此，前期准备工作完毕，接下来转到 Three.js 项目代码中。</p>
<br>
<h4 id="加载-mtl-表面着色器材质对应的类加载器为-mtlloader">加载 .mtl 表面着色器(材质)对应的类(加载器)为 MTLLoader<a hidden class="anchor" aria-hidden="true" href="#加载-mtl-表面着色器材质对应的类加载器为-mtlloader">#</a></h4>
<blockquote>
<p>在 Three.js 中，各种加载器的用法几乎完全相同。</p>
</blockquote>
<p>我们需要做的事情就是：</p>
<ol>
<li>
<p>先使用 MTLLoader 实例 加载材质(纹理图片)资源</p>
<blockquote>
<p>特别强调一下，MTLLoader 实例 加载得到的对象类型并不是 Three.Metrial ，而是 MTLLoader.MaterialCreator</p>
</blockquote>
</li>
<li>
<p>加载完成后，将得到的 MaterialCreator 实例 赋予给 OBJLoader 实例</p>
<blockquote>
<p>这样 OBJLoader 以后加载的任意模型都会自动应用该 MaterialCreator 材质</p>
</blockquote>
</li>
<li>
<p>然后再让 OBJLoader 实例 去加载模型</p>
<blockquote>
<p>加载完成后，将模型添加到场景中</p>
</blockquote>
</li>
</ol>
<br>
<p><strong>实际代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>import { MTLLoader } from &#34;three/examples/jsm/loaders/MTLLoader&#34;
</span></span><span style="display:flex;"><span>import { OBJLoader } from &#34;three/examples/jsm/loaders/OBJLoader&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const mtlLoader = new MTLLoader()
</span></span><span style="display:flex;"><span>const objLoader = new OBJLoader()
</span></span><span style="display:flex;"><span>mtlLoader.load(&#39;./model/hello.mtl&#39;, (materialCreator) =&gt; {
</span></span><span style="display:flex;"><span>    objLoader.setMaterials(materialCreator)
</span></span><span style="display:flex;"><span>    objLoader.load(&#39;./model/hello.obj&#39;, (group) =&gt; {
</span></span><span style="display:flex;"><span>        scene.add(group)
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>})
</span></span></code></pre></div><blockquote>
<p>请注意上述代码加载的资源地址为 “./model/hello.mtl” 和 “./model/hello.obj”，这里是相对路径，相对编译之后的 index.html 而言。</p>
</blockquote>
<br>
<p><strong>完整的代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>import { useRef, useEffect } from &#34;react&#34;
</span></span><span style="display:flex;"><span>import * as Three from &#39;three&#39;
</span></span><span style="display:flex;"><span>import { OrbitControls } from &#34;three/examples/jsm/controls/OrbitControls&#34;
</span></span><span style="display:flex;"><span>import { MTLLoader } from &#34;three/examples/jsm/loaders/MTLLoader&#34;
</span></span><span style="display:flex;"><span>import { OBJLoader } from &#34;three/examples/jsm/loaders/OBJLoader&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import &#39;./index.scss&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const HelloOBJLoader = () =&gt; {
</span></span><span style="display:flex;"><span>    const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
</span></span><span style="display:flex;"><span>        const scene = new Three.Scene()
</span></span><span style="display:flex;"><span>        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
</span></span><span style="display:flex;"><span>        camera.position.set(10, 0, 10)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const light = new Three.HemisphereLight(0xFFFFFF, 0x333333, 1)
</span></span><span style="display:flex;"><span>        scene.add(light)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const mtlLoader = new MTLLoader()
</span></span><span style="display:flex;"><span>        const objLoader = new OBJLoader()
</span></span><span style="display:flex;"><span>        mtlLoader.load(&#39;./model/hello.mtl&#39;, (materialCreator) =&gt; {
</span></span><span style="display:flex;"><span>            objLoader.setMaterials(materialCreator)
</span></span><span style="display:flex;"><span>            objLoader.load(&#39;./model/hello.obj&#39;, (group) =&gt; {
</span></span><span style="display:flex;"><span>                scene.add(group)
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const control = new OrbitControls(camera, canvasRef.current)
</span></span><span style="display:flex;"><span>        control.update()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const render = () =&gt; {
</span></span><span style="display:flex;"><span>            renderer.render(scene, camera)
</span></span><span style="display:flex;"><span>            window.requestAnimationFrame(render)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        window.requestAnimationFrame(render)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const handleResize = () =&gt; {
</span></span><span style="display:flex;"><span>            if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            const width = canvasRef.current.clientWidth
</span></span><span style="display:flex;"><span>            const height = canvasRef.current.clientHeight
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            camera.aspect = width / height
</span></span><span style="display:flex;"><span>            camera.updateProjectionMatrix()
</span></span><span style="display:flex;"><span>            renderer.setSize(width, height, false)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        handleResize()
</span></span><span style="display:flex;"><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return () =&gt; {
</span></span><span style="display:flex;"><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }, [])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return (
</span></span><span style="display:flex;"><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export default HelloOBJLoader
</span></span></code></pre></div><br>
<p>至此，我们已经讲解完如何加载 .mtl 和 .obj 文件。</p>
<br>
<h2 id="obj文件类型的一些特别之处">.obj文件类型的一些特别之处<a hidden class="anchor" aria-hidden="true" href="#obj文件类型的一些特别之处">#</a></h2>
<p>本文讲解的是在 Blender 中导出 wavefront(.obj) 文件格式。</p>
<p>这里要针对性的进行补充：</p>
<ol>
<li>
<p>Blender 可以导出 N 多种文件格式</p>
<blockquote>
<p>.obj 仅仅是其中一种</p>
</blockquote>
</li>
<li>
<p>Three.js 支持多种 3D 文件模型格式</p>
<blockquote>
<p>本文讲解的是加载 .obj</p>
</blockquote>
</li>
</ol>
<br>
<p><strong>.obj格式的一些特点：</strong></p>
<ol>
<li>
<p>行业内比较广泛使用</p>
</li>
<li>
<p>.obj是一种纯文本格式</p>
<blockquote>
<p>本文中我们使用记事本打开了 .mtl 文件，并未打开 .obj 文件，感兴趣的可以自己尝试看看具体都是什么内容。</p>
</blockquote>
</li>
<li>
<p>.obj包含的内容有：Mesh(网格)、按组/物体分离、材质/纹理、NURBS曲线和曲面</p>
</li>
<li>
<p>.obj不包含(不支持导出)的内容有：网格顶点颜色、骨架、动画、灯光、相机、空物体、父子关系或变换</p>
</li>
</ol>
<br>
<p>以上特性中不难看出 .obj 有优点，也有缺点。</p>
<p><strong>优点：只包含物体模型数据本身</strong></p>
<p><strong>缺点：不包含其他复杂元素(动画、相机、灯光等)</strong></p>
<br>
<p>接下来，我们将在下一章节中，讲解另外一种 3D 模型格式文件：.gLTF</p>
<p>gLTF 格式可以包含更多复杂的元素数据。</p>
<br>
<h2 id="为什么要自己学习blender">为什么要自己学习Blender？<a hidden class="anchor" aria-hidden="true" href="#为什么要自己学习blender">#</a></h2>
<p>我个人认为，如果你想深入学习 3D，学习 Three.js，那么你就需要掌握一门 3D 建模软件。</p>
<p>你可以不精通，但是基础的操作你要掌握，这样非常利于你对于 Three.js 3D 概念的理解。</p>
<br>
<p>如果你不会 3D 建模软件，那么你只能直接在 Three.js 中去创建模型，这将是一件非常费力的事情，并且也无法做到精准建模，对模型的细腻雕刻。</p>
<br>
<p>你总不能完全依靠别人给你提供建好的模型，做到饭来张口的状态吧。</p>
<p>自己能够掌握 3D 建模，越建越快乐。</p>
<br>
<p>这也是为什么本文花了大量篇幅在一步一步讲解 Blender 中的各种操作的原因。</p>
<blockquote>
<p>我也是 Blender 新手小白，希望我们一起学习，一起加油。</p>
</blockquote>
<br>
<p>如果本文中讲解的 Blender 你根本不会操作，也不感兴趣安装学习，那么你可以直接在网上搜索一些 .obj 和 .mtl 文件进行代替学习。</p>
<p>这里提供 2 个文件资源，你可以直接下载使用：</p>
<p><a href="https://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill-fixed.mtl">https://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill-fixed.mtl</a></p>
<p><a href="https://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill.obj">https://threejsfundamentals.org/threejs/resources/models/windmill_2/windmill.obj</a></p>
<br>
<p>我们下一章节见。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://bablvsj.github.io/tags/three.js/">Three.js</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://bablvsj.github.io/posts/threejs/22-three.js%E4%BC%98%E5%8C%96%E4%B9%8Boffscreencanvas%E4%B8%8Ewebworker/">
    <span class="title">« Prev</span>
    <br>
    <span>22 Three.js优化之OffscreenCanvas与WebWorker</span>
  </a>
  <a class="next" href="https://bablvsj.github.io/posts/threejs/24-three.js%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B9%8B%E5%8A%A0%E8%BD%BD.gltf%E6%A8%A1%E5%9E%8B/">
    <span class="title">Next »</span>
    <br>
    <span>24 Three.js解决方案之加载.gltf模型</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://bablvsj.github.io">Bablvsj&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <div class="flex-c-d">
        <a class="flex-d-c" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"
            target="_blank"> <span>本站由</span><img width="60" src="/images/upyun.png">提供CDN加速/云存储服务</a>
    </div>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
