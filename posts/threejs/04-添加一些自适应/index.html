<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>04 添加一些自适应 | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="04 添加一些自适应 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/04-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/><link crossorigin=anonymous href=/assets/css/stylesheet.241265d51339977eb0f90d05780e286ec2789600ca4137f29552dec9dee06569.css integrity="sha256-JBJl1RM5l36w+Q0FeA4obsJ4lgDKQTfylVLeyd7gZWk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="04 添加一些自适应"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/04-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="04 添加一些自适应"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"04 添加一些自适应","item":"https://bablvsj.github.io/posts/threejs/04-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"04 添加一些自适应","name":"04 添加一些自适应","description":"","keywords":["Three.js"],"articleBody":"在上一节中，已经实现了 HelloThree 最为基础的示例。本节将进一步优化那个示例。\n我们将给示例中的 canvas 添加宽高自适应，让它充满整个浏览器。\n优化第一项：修改 canvas 尺寸 默认 canvas 尺寸为 高150像素，宽300像素。我们现在把 canvas 修改为撑满屏幕。\n第1处修改 打开项目中 src/indes.scss ，修改 html、body、root 样式：\nbody{ - margin:0; } html,body { + margin: 0; + padding: 0; + height: 100%; + width: 100%; } #root { + height: inherit; + width: inherit; } 由于我们已经给 html, body 设置了 宽高 100%，所以 root 宽高 设置为 inherit 即可。\n第2处修改 新建文件 src/components/hello-threejs/index.scss，添加 canvas 样式：\n.full-screen { display: block; width: inherit; height: inherit; } canvas 宽高继承于 root，root 继承于 body，而 body 宽高均为 100%，所以最终 canvas 宽高也为 100%，撑满整个屏幕。\n特别提醒： 在上面样式中，我们设置了 display 为 block，让 canvas 由 内联元素 改为 块级元素。\n为什么要这么做？\n因为我们在后面代码中，需要获取 canvas 的 clientWidth(内部实际宽度) 和 clientHeight(内部实际高度)，而内联元素是无法获取到这 2 两个属性值的，因此我们要将画布修改为块级元素。\n内联元素和没有 CSS 样式的元素，获取到的 clientWidht 和 clientHeight 的值永远为 0\n第3处修改 在 src/components/hello-threejs/index.stx 中引入并添加样式\n+ import './index.scss' const HelloThreejs: React.FC = () =\u003e { ... return ( ) } 此时，再次执行预览 yarn start，就会发现 canvas 已全屏，充满整个浏览器可见区域。\n目前存在的问题 可以观察到 canvas 是被硬生生由原本的 高150、像素 宽 300 像素给硬生生拉伸成 100%。\n所以立方体出现了 扭曲、模糊、锯齿。\n那我们继续修改代码。\n第4处修改 修改 src/components/hello-threejs/index.stx 中 render 函数的代码，让镜头宽高比跟随着 canvas 宽高比，确保立方体不变形。\n... const render = (time: number) =\u003e { time = time * 0.001 + const canvas = renderer.domElement //获取 canvas + camera.aspect = canvas.clientWidth / canvas.clientHeight //设置镜头宽高比 + camera.updateProjectionMatrix() //通知镜头更新视椎(视野) cubes.map(cube =\u003e { ... } } ... 第5处修改 第4步立方体已经不再变形，但是依然模糊，锯齿感比较明显。原因是渲染器(renderer) 渲染出的画面尺寸小于实际网页 canvas 尺寸。\n继续修改 src/components/hello-threejs/index.tsx 中 render 函数的代码。\n... const render = (time: number) =\u003e { time = time * 0.001 const canvas = renderer.domElement //获取 canvas camera.aspect = canvas.clientWidth / canvas.clientHeight //设置镜头宽高比 camera.updateProjectionMatrix() //通知镜头更新视椎(视野) + renderer.setSize(canvas.clientWidth, canvas.clientHeight, false) + //第3个参数为可选参数，默认值为 true，false 意思是阻止因渲染内容尺寸发生变化而去修改 canvas 尺寸 cubes.map(cube =\u003e { ... } } ... 经过上面一番修改，浏览器中 canvas 里的立方体会变得不变形，且非常清晰。\n关于 renderer.setSize() 第 3 个参数的补充说明：\n在本示例中 renderer 是 WebGLRenderer 实例。\n我查看了一下 WebGLRenderer setSize() 源码：https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js\n发现了其中以下代码片段：\nthis.setSize = function ( width, height, updateStyle ) { ... if ( updateStyle !== false ) { _canvas.style.width = width + 'px'; _canvas.style.height = height + 'px'; } ... } 可以看出，假设第 3 个参数不传值，那么该参数值实际调用时为 undefined，undefined !==false 的值为 true 。\n因此我们可以得出结论：setSize() 第 3 个参数的默认值为 true，当我们希望控制尺寸的主动权完全由 canvas 决定时，那么一定要设置第 3 个参数为 false。\n如何应对高清屏？ 从上面示例可以看出，浏览器中渲染的画面尺寸，完全是按照 CSS 样式尺寸来显示的。\n对于高清屏(HD-DPI)来说，那 Three.js 渲染的画面又该有何应对呢？\n第1种策略(推荐)：不做任何策略 假设 HD-DP 比例为 3x，即原本 1 像素 则由 3 x 3 ，共 9 个像素来显示。\n也就是说原本只需渲染 1 像素，现在需要渲染 9 像素，所消耗的性能是原来的 9 倍。\n假设 3D 场景内容稍微复杂一些，那所带来的渲染性能要求会非常高，画面清晰的代价是更高性能的消耗，引起的卡顿 会带来不好的用户体验。\n事实上高清屏本身都会做显示优化，即使不做任何处理，画面清晰度并不会明显特别差。\n因此，什么都不做，其实是一个非常好的策略。\n假设就是想设置成高清屏，那又该如何操作呢？\n第2种策略(强烈不推荐)：通过 renderer.setPixelRatio 来配置渲染分辨率倍数 在浏览器中，通过 window.devicePixelRatio 可获得当前屏幕物理分辨率与 CSS 样式分辨率的比值。\n然后告知渲染器，以后任何 renderer.setSize 都按照此 比值(倍数) 进行渲染\nrenderer.setPixelRatio(window.devicePixelRatio) 强烈不推荐这种做法。\n第3种策略(勉强推荐)：按屏幕分辨率比值，计算出对应渲染尺寸 这种策略思路是：通过分辨率比值，计算出实际上应该渲染的最大尺寸，然后渲染出这个尺寸，再将画面内容渲染到 canvas 中。\n举例：假设 HD-DP 比例为 3x，即 普通宽 1 像素对应高清屏宽 3 像素。那么可以将 renderer 渲染出比 canvas 实际大 3 倍的画面，然后再将画面以 “压缩” 3 倍的形式填充到 canvas 中，从而实现所谓的 “高清屏渲染”。\n这样的操作，会使 渲染器 renderer 像正常渲染一样来执行各种渲染操作。\n对应的渲染代码为：\nconst canvas = renderer.domElement const ratio = window.devicePixelRatio const newWidth = Math.floor(canvas.clientWidth * ratio) const newHeight = Math.floor(canvas.clientHeight * ratio) renderer.setSize(newWidth,newHeight,false) //特别注意，第 3 个参数一定要为 false 尽管第 3 种策略相对第 2 种好一些，但是还是建议选择第 1 种策略，即什么也不做。\n你看在线视频时，关于清晰度会做哪种选择？\nA：蓝光 1080P，画面超级清晰，但播放时会有点卡顿\nB：高清 720 P，画面清晰度能够接受，播放时也非常流畅\n至此，关于 Three.js 的入门演示示例，已经结束。\n等一等，我们现在的代码正确吗？ 目前来说，虽然实际运行没有一点问题，但代码实际上并不是最优的。\n现在做给渲染器添加尺寸发生变化的代码是放在了 window.requestAnimationFrame() 中，每一次浏览器刷新都重新计算并设置一次，事实上在浪费着性能。\n我们需要改进的地方时：仅在浏览器窗口尺寸发生 resize 事件时去修改 渲染器 即可。\n需要说明的地方：\n监听浏览器窗口尺寸变化，对应的是 window.addEventListener(‘resize’, xxxx) 当 React 卸载后，一定记得移除监听 window.removeEventListener(‘resize’, xxxx) 为了在移除监听时可以找到 在 useEffect中定义的 resize 事件处理函数，我们会在示例代码中，再通过 useRef 创建一个变量指向 事件处理函数。 最终修改后的代码：\nimport React, { useRef, useEffect } from 'react' import { WebGLRenderer, PerspectiveCamera, Scene, BoxGeometry, Mesh, DirectionalLight, MeshPhongMaterial } from 'three' import './index.scss' const HelloThreejs: React.FC = () =\u003e { const canvasRef = useRef(null) const resizeHandleRef = useRef\u003c() =\u003e void\u003e() useEffect(() =\u003e { if (canvasRef.current) { //创建渲染器 const renderer = new WebGLRenderer({ canvas: canvasRef.current }) //创建镜头 //PerspectiveCamera() 中的 4 个参数分别为： //1、fov(field of view 的缩写)，可选参数，默认值为 50，指垂直方向上的角度，注意该值是度数而不是弧度 //2、aspect，可选参数，默认值为 1，画布的高宽比，例如画布高300像素，宽150像素，那么意味着高宽比为 2 //3、near，可选参数，默认值为 0.1，近平面，限制摄像机可绘制最近的距离，若小于该距离则不会绘制(相当于被裁切掉) //4、far，可选参数，默认值为 2000，远平面，限制摄像机可绘制最远的距离，若超出该距离则不会绘制(相当于被裁切掉) //以上 4 个参数在一起，构成了一个 “视椎”，关于视椎的概念理解，暂时先不作详细描述。 const camera = new PerspectiveCamera(75, 2, 0.1, 5) //创建场景 const scene = new Scene() //创建几何体 const geometry = new BoxGeometry(1, 1, 1) //创建材质 //我们需要让立方体能够反射光，所以不使用MeshBasicMaterial，而是改用MeshPhongMaterial //const material = new MeshBasicMaterial({ color: 0x44aa88 }) const material1 = new MeshPhongMaterial({ color: 0x44aa88 }) const material2 = new MeshPhongMaterial({ color: 0xc50d0d }) const material3 = new MeshPhongMaterial({ color: 0x39b20a }) //创建网格 const cube1 = new Mesh(geometry, material1) cube1.position.x = -2 scene.add(cube1)//将网格添加到场景中 const cube2 = new Mesh(geometry, material2) cube2.position.x = 0 scene.add(cube2)//将网格添加到场景中 const cube3 = new Mesh(geometry, material3) cube3.position.x = 2 scene.add(cube3)//将网格添加到场景中 const cubes = [cube1, cube2, cube3] //创建光源 const light = new DirectionalLight(0xFFFFFF, 1) light.position.set(-1, 2, 4) scene.add(light)//将光源添加到场景中 //设置透视镜头的Z轴距离，以便我们以某个距离来观察几何体 //之前初始化透视镜头时，设置的近平面为 0.1，远平面为 5 //因此 camera.position.z 的值一定要在 0.1 - 5 的范围内，超出这个范围则画面不会被渲染 camera.position.z = 2 //渲染器根据场景、透视镜头来渲染画面，并将该画面内容填充到 DOM 的 canvas 元素中 //renderer.render(scene, camera)//由于后面我们添加了自动渲染渲染动画，所以此处的渲染可以注释掉 //添加自动旋转渲染动画 const render = (time: number) =\u003e { time = time * 0.001 // cube.rotation.x = time // cube.rotation.y = time cubes.forEach(cube =\u003e { cube.rotation.x = time cube.rotation.y = time }) renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) const handleResize = () =\u003e { const canvas = renderer.domElement camera.aspect = canvas.clientWidth / canvas.clientHeight camera.updateProjectionMatrix() renderer.setSize(canvas.clientWidth, canvas.clientHeight, false) } handleResize() //默认打开时，即重新触发一次 resizeHandleRef.current = handleResize //将 resizeHandleRef.current 与 useEffect() 中声明的函数进行绑定 window.addEventListener('resize', handleResize) //添加窗口 resize 事件处理函数 } return () =\u003e { if (resizeHandleRef \u0026\u0026 resizeHandleRef.current) { window.removeEventListener('resize', resizeHandleRef.current) } } }, [canvasRef]) return ( ) } export default HelloThreejs 再次补充说明：\n尽管代码已经有所改进，但上述代码中，创建 3D 场景的代码都集中在 useEffect(() =\u003e { if (canvasRef.current) { … } }, [canvasRef] ) ，这很显然并不是合理的。\n合理的应该是通过 useState() 去将 renderer、camera、scene 等都独立出来定义。\n将原本集中的代码分散到更多小的 代码块 中。\n包括浏览器窗口 resize 事件处理，都应该添加 防抖 策略。\n这里就先暂时这样，不再做改进，等到将来再去做稍微复杂点的 场景应用 时，会再次优化代码结构。\n以下内容更新于 2021.05.11\n通过 ResizeObserver 来监听画布尺寸变化 在本文以及本教程的所有后面章节中，我们都是通过监听 window resize 事件，在 handleResize 处理函数中重新设置 相机和渲染器 的一些属性配置的。\n由于这些示例中实际上只存在一个 标签，画布(canvas) 的尺寸是充满整个浏览器窗口，画布尺寸发生变化的情况只有一种，即 浏览器窗口尺寸发生变化。\n但是在实际的项目中，有可能 标签仅仅只占 document.body 中的一部分而已，造成 画布(canvas) 尺寸发生变化，还有以下几种可能：\n通过 CSS 修改 标签的宽高 在 flex 布局下，当其他元素尺寸发生变化时，影响到 ，从而造成画布发生尺寸变化。 … 很明显，通过 CSS 的变化造成 画布尺寸变化，和 window resize 完全不相关联。\n因此我们要寻找其他监听 画布 标签尺寸发生变化的方式。\n我们可以通过浏览器最新的 ResizeObserver 来监听 尺寸变化。\nResizeObserver简介\nResizeObserver 是现代浏览器 API 中一个新的内置类，它可以监控某个 DOM 元素尺寸变化。\n在 ResizeObserver 出现之前，只能对 window 添加 resize 监听，无法对 DOM 元素添加尺寸变化监听。\nobserver 单词意思是 “观察”，也就是设计模式中的 “观察模式”，但是我个人习惯性有时候称呼为 “监控模式”\nResizeObserver 一共有 3 个方法：\nobserve()：开始监控(观察)某元素尺寸变化 unobserve()：停止监控(观察)某元素尺寸变化 disconnect()：取消和结束目标元素上所有的监控(观察) 更多详细介绍，请查阅：\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver\n实际示例代码：\nconst handleResize = () =\u003e { const canvas = renderer.domElement camera.aspect = canvas.clientWidth / canvas.clientHeight camera.updateProjectionMatrix() renderer.setSize(canvas.clientWidth, canvas.clientHeight, false) } handleResize() //我们不再添加 window resize 监控(观察) - window.addEventListener('resize', handleResize) //改为使用 ResizeObserver 来监控(观察)尺寸变化 + const resizeObserver = new ResizeObserver(() =\u003e { + handleResize() + }) + resizeObserver.observe(canvasRef.current) //当我们卸载组件前，一定要 清除掉 监控(观察) return () =\u003e{ - window.removeEventListener('resize', resizeHandleRef.current) + resizeObserver.disconnect() } 请注意，resizeObserver.observe() 方法中，可以有第 2 个可选参数。\n例如：resizeObserver.observe(canvasRef.current, { box: ‘border-box’ })\n如果第 2 个可选参数不填，那么默认值为 { box: ‘content-box’ }\n与本文无关的事情\n我在查阅 MDN 关于 ResizeObserver.observer() 介绍时，发现 简体中文(zh-cn) 介绍页中缺少对第 2 个参数，也就是可选参数的中文介绍，于是我就向 MDN 提交了 PR，添加上了该部分。\nhttps://github.com/mdn/translated-content/pull/817\n目前该 PR 已经被合并进 main 中，但是正常访问的 MDN 网页中还未更新过来，估计过一段时间就会看到。\n或许此刻已经更新了。\n以上内容更新于 2021.05.11\n那么接下来，会系统学习一下 Three.js 的一些基础理论。\n大楼究竟能改多高，取决于地基有多深，加油！\n","wordCount":"4373","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/04-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>04 添加一些自适应</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>9 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><ul><li><a href=#%e4%bc%98%e5%8c%96%e7%ac%ac%e4%b8%80%e9%a1%b9%e4%bf%ae%e6%94%b9-canvas-%e5%b0%ba%e5%af%b8 aria-label="优化第一项：修改 canvas 尺寸">优化第一项：修改 canvas 尺寸</a><ul><li><a href=#%e7%ac%ac1%e5%a4%84%e4%bf%ae%e6%94%b9 aria-label=第1处修改>第1处修改</a></li><li><a href=#%e7%ac%ac2%e5%a4%84%e4%bf%ae%e6%94%b9 aria-label=第2处修改>第2处修改</a></li><li><a href=#%e7%ac%ac3%e5%a4%84%e4%bf%ae%e6%94%b9 aria-label=第3处修改>第3处修改</a></li><li><a href=#%e7%9b%ae%e5%89%8d%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98 aria-label=目前存在的问题>目前存在的问题</a></li><li><a href=#%e7%ac%ac4%e5%a4%84%e4%bf%ae%e6%94%b9 aria-label=第4处修改>第4处修改</a></li><li><a href=#%e7%ac%ac5%e5%a4%84%e4%bf%ae%e6%94%b9 aria-label=第5处修改>第5处修改</a></li></ul></li></ul><li><a href=#%e5%a6%82%e4%bd%95%e5%ba%94%e5%af%b9%e9%ab%98%e6%b8%85%e5%b1%8f aria-label=如何应对高清屏？>如何应对高清屏？</a><ul><ul><li><a href=#%e7%ac%ac1%e7%a7%8d%e7%ad%96%e7%95%a5%e6%8e%a8%e8%8d%90%e4%b8%8d%e5%81%9a%e4%bb%bb%e4%bd%95%e7%ad%96%e7%95%a5 aria-label=第1种策略(推荐)：不做任何策略>第1种策略(推荐)：不做任何策略</a></li><li><a href=#%e7%ac%ac2%e7%a7%8d%e7%ad%96%e7%95%a5%e5%bc%ba%e7%83%88%e4%b8%8d%e6%8e%a8%e8%8d%90%e9%80%9a%e8%bf%87-renderersetpixelratio-%e6%9d%a5%e9%85%8d%e7%bd%ae%e6%b8%b2%e6%9f%93%e5%88%86%e8%be%a8%e7%8e%87%e5%80%8d%e6%95%b0 aria-label="第2种策略(强烈不推荐)：通过 renderer.setPixelRatio 来配置渲染分辨率倍数">第2种策略(强烈不推荐)：通过 renderer.setPixelRatio 来配置渲染分辨率倍数</a></li><li><a href=#%e7%ac%ac3%e7%a7%8d%e7%ad%96%e7%95%a5%e5%8b%89%e5%bc%ba%e6%8e%a8%e8%8d%90%e6%8c%89%e5%b1%8f%e5%b9%95%e5%88%86%e8%be%a8%e7%8e%87%e6%af%94%e5%80%bc%e8%ae%a1%e7%ae%97%e5%87%ba%e5%af%b9%e5%ba%94%e6%b8%b2%e6%9f%93%e5%b0%ba%e5%af%b8 aria-label=第3种策略(勉强推荐)：按屏幕分辨率比值，计算出对应渲染尺寸>第3种策略(勉强推荐)：按屏幕分辨率比值，计算出对应渲染尺寸</a></li></ul></ul></li><li><a href=#%e7%ad%89%e4%b8%80%e7%ad%89%e6%88%91%e4%bb%ac%e7%8e%b0%e5%9c%a8%e7%9a%84%e4%bb%a3%e7%a0%81%e6%ad%a3%e7%a1%ae%e5%90%97 aria-label=等一等，我们现在的代码正确吗？>等一等，我们现在的代码正确吗？</a><ul><ul><li><a href=#%e9%80%9a%e8%bf%87-resizeobserver-%e6%9d%a5%e7%9b%91%e5%90%ac%e7%94%bb%e5%b8%83%e5%b0%ba%e5%af%b8%e5%8f%98%e5%8c%96 aria-label="通过 ResizeObserver 来监听画布尺寸变化">通过 ResizeObserver 来监听画布尺寸变化</a></li></ul></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>在上一节中，已经实现了 HelloThree 最为基础的示例。本节将进一步优化那个示例。</p><p>我们将给示例中的 canvas 添加宽高自适应，让它充满整个浏览器。</p><br><h3 id=优化第一项修改-canvas-尺寸>优化第一项：修改 canvas 尺寸<a hidden class=anchor aria-hidden=true href=#优化第一项修改-canvas-尺寸>#</a></h3><p>默认 canvas 尺寸为 高150像素，宽300像素。我们现在把 canvas 修改为撑满屏幕。</p><br><h4 id=第1处修改>第1处修改<a hidden class=anchor aria-hidden=true href=#第1处修改>#</a></h4><p>打开项目中 src/indes.scss ，修改 html、body、root 样式：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>body{
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>-  margin:0;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>html,body {
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+   margin: 0;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+   padding: 0;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+   height: 100%;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+   width: 100%;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>#root {
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+   height: inherit;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+   width: inherit;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>}
</span></span></code></pre></div><blockquote><p>由于我们已经给 html, body 设置了 宽高 100%，所以 root 宽高 设置为 inherit 即可。</p></blockquote><br><h4 id=第2处修改>第2处修改<a hidden class=anchor aria-hidden=true href=#第2处修改>#</a></h4><p>新建文件 src/components/hello-threejs/index.scss，添加 canvas 样式：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.full-screen {
</span></span><span style=display:flex><span>    display: block;
</span></span><span style=display:flex><span>    width: inherit;
</span></span><span style=display:flex><span>    height: inherit;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>canvas 宽高继承于 root，root 继承于 body，而 body 宽高均为 100%，所以最终 canvas 宽高也为 100%，撑满整个屏幕。</p></blockquote><br><p><strong>特别提醒：</strong> 在上面样式中，我们设置了 display 为 block，让 canvas 由 内联元素 改为 块级元素。</p><p>为什么要这么做？</p><p>因为我们在后面代码中，需要获取 canvas 的 clientWidth(内部实际宽度) 和 clientHeight(内部实际高度)，而内联元素是无法获取到这 2 两个属性值的，因此我们要将画布修改为块级元素。</p><blockquote><p>内联元素和没有 CSS 样式的元素，获取到的 clientWidht 和 clientHeight 的值永远为 0</p></blockquote><br><h4 id=第3处修改>第3处修改<a hidden class=anchor aria-hidden=true href=#第3处修改>#</a></h4><p>在 src/components/hello-threejs/index.stx 中引入并添加样式</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ import &#39;./index.scss&#39;
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>
</span></span><span style=display:flex><span>const HelloThreejs: React.FC = () =&gt; {
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>  return (
</span></span><span style=display:flex><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>此时，再次执行预览 <code>yarn start</code>，就会发现 canvas 已全屏，充满整个浏览器可见区域。</p><br><h4 id=目前存在的问题>目前存在的问题<a hidden class=anchor aria-hidden=true href=#目前存在的问题>#</a></h4><p>可以观察到 canvas 是被硬生生由原本的 高150、像素 宽 300 像素给硬生生拉伸成 100%。</p><p>所以立方体出现了 扭曲、模糊、锯齿。</p><p>那我们继续修改代码。</p><br><h4 id=第4处修改>第4处修改<a hidden class=anchor aria-hidden=true href=#第4处修改>#</a></h4><p>修改 src/components/hello-threejs/index.stx 中 render 函数的代码，让镜头宽高比跟随着 canvas 宽高比，确保立方体不变形。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>...
</span></span><span style=display:flex><span>    const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>        time = time * 0.001
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+       const canvas = renderer.domElement //获取 canvas
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+       camera.aspect = canvas.clientWidth / canvas.clientHeight //设置镜头宽高比
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+       camera.updateProjectionMatrix() //通知镜头更新视椎(视野)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>
</span></span><span style=display:flex><span>        cubes.map(cube =&gt; { ... }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><br><h4 id=第5处修改>第5处修改<a hidden class=anchor aria-hidden=true href=#第5处修改>#</a></h4><p>第4步立方体已经不再变形，但是依然模糊，锯齿感比较明显。原因是渲染器(renderer) 渲染出的画面尺寸小于实际网页 canvas 尺寸。</p><p>继续修改 src/components/hello-threejs/index.tsx 中 render 函数的代码。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>...
</span></span><span style=display:flex><span>    const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>        time = time * 0.001
</span></span><span style=display:flex><span>       
</span></span><span style=display:flex><span>        const canvas = renderer.domElement //获取 canvas
</span></span><span style=display:flex><span>        camera.aspect = canvas.clientWidth / canvas.clientHeight //设置镜头宽高比
</span></span><span style=display:flex><span>        camera.updateProjectionMatrix() //通知镜头更新视椎(视野)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+       renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+       //第3个参数为可选参数，默认值为 true，false 意思是阻止因渲染内容尺寸发生变化而去修改 canvas 尺寸
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>
</span></span><span style=display:flex><span>        cubes.map(cube =&gt; { ... }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>经过上面一番修改，浏览器中 canvas 里的立方体会变得不变形，且非常清晰。</p><br><p><strong>关于 renderer.setSize() 第 3 个参数的补充说明：</strong></p><p>在本示例中 renderer 是 WebGLRenderer 实例。</p><p>我查看了一下 WebGLRenderer setSize() 源码：<a href=https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js>https://github.com/mrdoob/three.js/blob/master/src/renderers/WebGLRenderer.js</a></p><p>发现了其中以下代码片段：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>this.setSize = function ( width, height, updateStyle ) {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    if ( updateStyle !== false ) {
</span></span><span style=display:flex><span>        _canvas.style.width = width + &#39;px&#39;;
</span></span><span style=display:flex><span>        _canvas.style.height = height + &#39;px&#39;;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以看出，假设第 3 个参数不传值，那么该参数值实际调用时为 undefined，undefined !==false 的值为 true 。</p><p>因此我们可以得出结论：<strong>setSize() 第 3 个参数的默认值为 true</strong>，当我们希望控制尺寸的主动权完全由 canvas 决定时，那么一定要设置第 3 个参数为 false。</p><br><h2 id=如何应对高清屏>如何应对高清屏？<a hidden class=anchor aria-hidden=true href=#如何应对高清屏>#</a></h2><p>从上面示例可以看出，浏览器中渲染的画面尺寸，完全是按照 CSS 样式尺寸来显示的。</p><p>对于高清屏(HD-DPI)来说，那 Three.js 渲染的画面又该有何应对呢？</p><br><h4 id=第1种策略推荐不做任何策略>第1种策略(推荐)：不做任何策略<a hidden class=anchor aria-hidden=true href=#第1种策略推荐不做任何策略>#</a></h4><p>假设 HD-DP 比例为 3x，即原本 1 像素 则由 3 x 3 ，共 9 个像素来显示。</p><p>也就是说原本只需渲染 1 像素，现在需要渲染 9 像素，所消耗的性能是原来的 9 倍。</p><p>假设 3D 场景内容稍微复杂一些，那所带来的渲染性能要求会非常高，画面清晰的代价是更高性能的消耗，引起的卡顿 会带来不好的用户体验。</p><p>事实上高清屏本身都会做显示优化，即使不做任何处理，画面清晰度并不会明显特别差。</p><p>因此，什么都不做，其实是一个非常好的策略。</p><br><p>假设就是想设置成高清屏，那又该如何操作呢？</p><h4 id=第2种策略强烈不推荐通过-renderersetpixelratio-来配置渲染分辨率倍数>第2种策略(强烈不推荐)：通过 renderer.setPixelRatio 来配置渲染分辨率倍数<a hidden class=anchor aria-hidden=true href=#第2种策略强烈不推荐通过-renderersetpixelratio-来配置渲染分辨率倍数>#</a></h4><p>在浏览器中，通过 window.devicePixelRatio 可获得当前屏幕物理分辨率与 CSS 样式分辨率的比值。</p><p>然后告知渲染器，以后任何 renderer.setSize 都按照此 比值(倍数) 进行渲染</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>renderer.setPixelRatio(window.devicePixelRatio)
</span></span></code></pre></div><p><strong>强烈不推荐这种做法。</strong></p><br><h4 id=第3种策略勉强推荐按屏幕分辨率比值计算出对应渲染尺寸>第3种策略(勉强推荐)：按屏幕分辨率比值，计算出对应渲染尺寸<a hidden class=anchor aria-hidden=true href=#第3种策略勉强推荐按屏幕分辨率比值计算出对应渲染尺寸>#</a></h4><p>这种策略思路是：通过分辨率比值，计算出实际上应该渲染的最大尺寸，然后渲染出这个尺寸，再将画面内容渲染到 canvas 中。</p><p>举例：假设 HD-DP 比例为 3x，即 普通宽 1 像素对应高清屏宽 3 像素。那么可以将 renderer 渲染出比 canvas 实际大 3 倍的画面，然后再将画面以 “压缩” 3 倍的形式填充到 canvas 中，从而实现所谓的 “高清屏渲染”。</p><p>这样的操作，会使 渲染器 renderer 像正常渲染一样来执行各种渲染操作。</p><p><strong>对应的渲染代码为：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const canvas = renderer.domElement
</span></span><span style=display:flex><span>const ratio = window.devicePixelRatio
</span></span><span style=display:flex><span>const newWidth = Math.floor(canvas.clientWidth * ratio)
</span></span><span style=display:flex><span>const newHeight = Math.floor(canvas.clientHeight * ratio)
</span></span><span style=display:flex><span>renderer.setSize(newWidth,newHeight,false) //特别注意，第 3 个参数一定要为 false
</span></span></code></pre></div><br><p><strong>尽管第 3 种策略相对第 2 种好一些，但是还是建议选择第 1 种策略，即什么也不做。</strong></p><blockquote><p>你看在线视频时，关于清晰度会做哪种选择？<br>A：蓝光 1080P，画面超级清晰，但播放时会有点卡顿<br>B：高清 720 P，画面清晰度能够接受，播放时也非常流畅</p></blockquote><br><p>至此，关于 Three.js 的入门演示示例，已经结束。</p><br><h2 id=等一等我们现在的代码正确吗>等一等，我们现在的代码正确吗？<a hidden class=anchor aria-hidden=true href=#等一等我们现在的代码正确吗>#</a></h2><p>目前来说，虽然实际运行没有一点问题，但代码实际上并不是最优的。</p><p>现在做给渲染器添加尺寸发生变化的代码是放在了 window.requestAnimationFrame() 中，每一次浏览器刷新都重新计算并设置一次，事实上在浪费着性能。</p><p>我们需要改进的地方时：仅在浏览器窗口尺寸发生 resize 事件时去修改 渲染器 即可。</p><br><p><strong>需要说明的地方：</strong></p><ol><li>监听浏览器窗口尺寸变化，对应的是 window.addEventListener(&lsquo;resize&rsquo;, xxxx)</li><li>当 React 卸载后，一定记得移除监听 window.removeEventListener(&lsquo;resize&rsquo;, xxxx)</li><li>为了在移除监听时可以找到 在 useEffect中定义的 resize 事件处理函数，我们会在示例代码中，再通过 useRef 创建一个变量指向 事件处理函数。</li></ol><p><strong>最终修改后的代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import React, { useRef, useEffect } from &#39;react&#39;
</span></span><span style=display:flex><span>import { WebGLRenderer, PerspectiveCamera, Scene, BoxGeometry, Mesh, DirectionalLight, MeshPhongMaterial } from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloThreejs: React.FC = () =&gt; {
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>    const resizeHandleRef = useRef&lt;() =&gt; void&gt;()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current) {
</span></span><span style=display:flex><span>            //创建渲染器
</span></span><span style=display:flex><span>            const renderer = new WebGLRenderer({ canvas: canvasRef.current })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建镜头
</span></span><span style=display:flex><span>            //PerspectiveCamera() 中的 4 个参数分别为：
</span></span><span style=display:flex><span>            //1、fov(field of view 的缩写)，可选参数，默认值为 50，指垂直方向上的角度，注意该值是度数而不是弧度
</span></span><span style=display:flex><span>            //2、aspect，可选参数，默认值为 1，画布的高宽比，例如画布高300像素，宽150像素，那么意味着高宽比为 2
</span></span><span style=display:flex><span>            //3、near，可选参数，默认值为 0.1，近平面，限制摄像机可绘制最近的距离，若小于该距离则不会绘制(相当于被裁切掉)
</span></span><span style=display:flex><span>            //4、far，可选参数，默认值为 2000，远平面，限制摄像机可绘制最远的距离，若超出该距离则不会绘制(相当于被裁切掉)
</span></span><span style=display:flex><span>            //以上 4 个参数在一起，构成了一个 “视椎”，关于视椎的概念理解，暂时先不作详细描述。
</span></span><span style=display:flex><span>            const camera = new PerspectiveCamera(75, 2, 0.1, 5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建场景
</span></span><span style=display:flex><span>            const scene = new Scene()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建几何体
</span></span><span style=display:flex><span>            const geometry = new BoxGeometry(1, 1, 1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建材质
</span></span><span style=display:flex><span>            //我们需要让立方体能够反射光，所以不使用MeshBasicMaterial，而是改用MeshPhongMaterial
</span></span><span style=display:flex><span>            //const material = new MeshBasicMaterial({ color: 0x44aa88 })
</span></span><span style=display:flex><span>            const material1 = new MeshPhongMaterial({ color: 0x44aa88 })
</span></span><span style=display:flex><span>            const material2 = new MeshPhongMaterial({ color: 0xc50d0d })
</span></span><span style=display:flex><span>            const material3 = new MeshPhongMaterial({ color: 0x39b20a })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建网格
</span></span><span style=display:flex><span>            const cube1 = new Mesh(geometry, material1)
</span></span><span style=display:flex><span>            cube1.position.x = -2
</span></span><span style=display:flex><span>            scene.add(cube1)//将网格添加到场景中
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            const cube2 = new Mesh(geometry, material2)
</span></span><span style=display:flex><span>            cube2.position.x = 0
</span></span><span style=display:flex><span>            scene.add(cube2)//将网格添加到场景中
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            const cube3 = new Mesh(geometry, material3)
</span></span><span style=display:flex><span>            cube3.position.x = 2
</span></span><span style=display:flex><span>            scene.add(cube3)//将网格添加到场景中
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            const cubes = [cube1, cube2, cube3]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建光源
</span></span><span style=display:flex><span>            const light = new DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>            light.position.set(-1, 2, 4)
</span></span><span style=display:flex><span>            scene.add(light)//将光源添加到场景中
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //设置透视镜头的Z轴距离，以便我们以某个距离来观察几何体
</span></span><span style=display:flex><span>            //之前初始化透视镜头时，设置的近平面为 0.1，远平面为 5
</span></span><span style=display:flex><span>            //因此 camera.position.z 的值一定要在 0.1 - 5 的范围内，超出这个范围则画面不会被渲染
</span></span><span style=display:flex><span>            camera.position.z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //渲染器根据场景、透视镜头来渲染画面，并将该画面内容填充到 DOM 的 canvas 元素中
</span></span><span style=display:flex><span>            //renderer.render(scene, camera)//由于后面我们添加了自动渲染渲染动画，所以此处的渲染可以注释掉
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //添加自动旋转渲染动画
</span></span><span style=display:flex><span>            const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>                time = time * 0.001
</span></span><span style=display:flex><span>                // cube.rotation.x = time
</span></span><span style=display:flex><span>                // cube.rotation.y = time
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                cubes.forEach(cube =&gt; {
</span></span><span style=display:flex><span>                    cube.rotation.x = time
</span></span><span style=display:flex><span>                    cube.rotation.y = time
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                renderer.render(scene, camera)
</span></span><span style=display:flex><span>                window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            const handleResize = () =&gt; {
</span></span><span style=display:flex><span>                const canvas = renderer.domElement
</span></span><span style=display:flex><span>                camera.aspect = canvas.clientWidth / canvas.clientHeight
</span></span><span style=display:flex><span>                camera.updateProjectionMatrix()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            handleResize() //默认打开时，即重新触发一次
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            resizeHandleRef.current = handleResize //将 resizeHandleRef.current 与 useEffect() 中声明的函数进行绑定
</span></span><span style=display:flex><span>            window.addEventListener(&#39;resize&#39;, handleResize) //添加窗口 resize 事件处理函数
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            if (resizeHandleRef &amp;&amp; resizeHandleRef.current) {
</span></span><span style=display:flex><span>                window.removeEventListener(&#39;resize&#39;, resizeHandleRef.current)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloThreejs
</span></span></code></pre></div><br><p><strong>再次补充说明：</strong></p><p>尽管代码已经有所改进，但上述代码中，创建 3D 场景的代码都集中在 useEffect(() => { if (canvasRef.current) { &mldr; } }, [canvasRef] ) ，这很显然并不是合理的。</p><p>合理的应该是通过 useState() 去将 renderer、camera、scene 等都独立出来定义。</p><p>将原本集中的代码分散到更多小的 代码块 中。</p><p>包括浏览器窗口 resize 事件处理，都应该添加 防抖 策略。</p><p>这里就先暂时这样，不再做改进，等到将来再去做稍微复杂点的 场景应用 时，会再次优化代码结构。</p><br><blockquote><p>以下内容更新于 2021.05.11</p></blockquote><h4 id=通过-resizeobserver-来监听画布尺寸变化>通过 ResizeObserver 来监听画布尺寸变化<a hidden class=anchor aria-hidden=true href=#通过-resizeobserver-来监听画布尺寸变化>#</a></h4><p>在本文以及本教程的所有后面章节中，我们都是通过监听 window resize 事件，在 handleResize 处理函数中重新设置 相机和渲染器 的一些属性配置的。</p><p>由于这些示例中实际上只存在一个 &lt;canvas > 标签，画布(canvas) 的尺寸是充满整个浏览器窗口，画布尺寸发生变化的情况只有一种，即 浏览器窗口尺寸发生变化。</p><p>但是在实际的项目中，有可能 &lt;canvas > 标签仅仅只占 document.body 中的一部分而已，造成 画布(canvas) 尺寸发生变化，还有以下几种可能：</p><ol><li>通过 CSS 修改 &lt;canvas > 标签的宽高</li><li>在 flex 布局下，当其他元素尺寸发生变化时，影响到 &lt;canvas > ，从而造成画布发生尺寸变化。</li><li>&mldr;</li></ol><p>很明显，通过 CSS 的变化造成 画布尺寸变化，和 window resize 完全不相关联。</p><p>因此我们要寻找其他监听 画布 标签尺寸发生变化的方式。</p><br><p><strong>我们可以通过浏览器最新的 ResizeObserver 来监听 &lt;canvas > 尺寸变化。</strong></p><br><p><strong>ResizeObserver简介</strong></p><p>ResizeObserver 是现代浏览器 API 中一个新的内置类，它可以监控某个 DOM 元素尺寸变化。</p><blockquote><p>在 ResizeObserver 出现之前，只能对 window 添加 resize 监听，无法对 DOM 元素添加尺寸变化监听。</p></blockquote><br><blockquote><p>observer 单词意思是 “观察”，也就是设计模式中的 “观察模式”，但是我个人习惯性有时候称呼为 “监控模式”</p></blockquote><br><p>ResizeObserver 一共有 3 个方法：</p><ol><li>observe()：开始监控(观察)某元素尺寸变化</li><li>unobserve()：停止监控(观察)某元素尺寸变化</li><li>disconnect()：取消和结束目标元素上所有的监控(观察)</li></ol><br><p>更多详细介绍，请查阅：</p><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver>https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver</a></p><br><p><strong>实际示例代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>const handleResize = () =&gt; {
</span></span><span style=display:flex><span>    const canvas = renderer.domElement
</span></span><span style=display:flex><span>    camera.aspect = canvas.clientWidth / canvas.clientHeight
</span></span><span style=display:flex><span>    camera.updateProjectionMatrix()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>handleResize()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//我们不再添加 window resize 监控(观察)
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- window.addEventListener(&#39;resize&#39;, handleResize)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006></span>
</span></span><span style=display:flex><span>//改为使用 ResizeObserver 来监控(观察)尺寸变化
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ const resizeObserver = new ResizeObserver(() =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+     handleResize()
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ })
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ resizeObserver.observe(canvasRef.current)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>
</span></span><span style=display:flex><span>//当我们卸载组件前，一定要 清除掉 监控(观察)
</span></span><span style=display:flex><span>return () =&gt;{
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- window.removeEventListener(&#39;resize&#39;, resizeHandleRef.current)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006></span><span style=color:#282828;background-color:#79740e>+ resizeObserver.disconnect()
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>}
</span></span></code></pre></div><blockquote><p>请注意，resizeObserver.observe() 方法中，可以有第 2 个可选参数。</p><p>例如：resizeObserver.observe(canvasRef.current, { box: &lsquo;border-box&rsquo; })</p><p>如果第 2 个可选参数不填，那么默认值为 { box: &lsquo;content-box&rsquo; }</p></blockquote><br><p><strong>与本文无关的事情</strong></p><p>我在查阅 MDN 关于 <a href=https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver/observe>ResizeObserver.observer()</a> 介绍时，发现 简体中文(zh-cn) 介绍页中缺少对第 2 个参数，也就是可选参数的中文介绍，于是我就向 MDN 提交了 PR，添加上了该部分。</p><p><a href=https://github.com/mdn/translated-content/pull/817>https://github.com/mdn/translated-content/pull/817</a></p><p>目前该 PR 已经被合并进 main 中，但是正常访问的 MDN 网页中还未更新过来，估计过一段时间就会看到。</p><blockquote><p>或许此刻已经更新了。</p></blockquote><br><blockquote><p>以上内容更新于 2021.05.11</p></blockquote><br><p>那么接下来，会系统学习一下 Three.js 的一些基础理论。</p><p><strong>大楼究竟能改多高，取决于地基有多深，加油！</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/03-%E7%BC%96%E5%86%99hellothreejs/><span class=title>« Prev</span><br><span>03 编写HelloThreejs</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/05-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%85%83/><span class=title>Next »</span><br><span>05 Three.js基础之图元</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>