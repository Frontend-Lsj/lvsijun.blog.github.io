<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>20 Three.js优化之合并对象 | Bablvsj&#39;s Blog</title>
<meta name="keywords" content="Three.js">
<meta name="description" content="20 Three.js优化之合并对象 - Bablvsj&#39;s Blog">
<meta name="author" content="">
<link rel="canonical" href="https://bablvsj.github.io/posts/threejs/20-three.js%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5525cc669fcb4f094a55bfc3ebfc5a6e73445e090010c66ab49c2cad14735f57.css" integrity="sha256-VSXMZp/LTwlKVb/D6/xabnNEXgkAEMZqtJwsrRRzX1c=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.acb54fd32bbc1982428b8850317e45d076b95012730a5936667e6bc21777692a.js" integrity="sha256-rLVP0yu8GYJCi4hQMX5F0Ha5UBJzClk2Zn5rwhd3aSo="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://bablvsj.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="16x16" href="https://bablvsj.github.io/img/Q.gif">
<link rel="icon" type="image/png" sizes="32x32" href="https://bablvsj.github.io/img/Q.gif">
<link rel="apple-touch-icon" href="https://bablvsj.github.io/Q.gif">
<link rel="mask-icon" href="https://bablvsj.github.io/Q.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="stylesheet" href="/css/syntax.css">


<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="20 Three.js优化之合并对象" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://bablvsj.github.io/posts/threejs/20-three.js%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T17:11:35+08:00" />
<meta property="article:modified_time" content="2023-12-19T17:11:35+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="20 Three.js优化之合并对象"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "文章",
      "item": "https://bablvsj.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "20 Three.js优化之合并对象",
      "item": "https://bablvsj.github.io/posts/threejs/20-three.js%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "20 Three.js优化之合并对象",
  "name": "20 Three.js优化之合并对象",
  "description": "",
  "keywords": [
    "Three.js"
  ],
  "articleBody": "前面学习了 Three.js 入门、基础、技巧，今天开始学习 Three.js 的性能优化。\n关于性能优化有很多方式，最基础也是最常见的方式就是——合并几何对象。\n在 “Three.js 基础之图元” 那篇文章中，我们将几何体称呼为 图元，现在我们修改一下这个称呼，本文以后，绝大多数情况下我们都使用 “几何体” 来代替 “图元”。\n既然谈到性能优化，就不能使用简单的示例，要不然根本无法体现出 优化前和优化后 的区别。\n激动人心的时刻到了。\n本文我们的目标：制作并优化一个显示地球人口人数分布的可视化3D地球 你可以先访问以下网址，先感受一下我们本文要模仿的效果：\nhttps://globe.chromeexperiments.com/\n补充说明：这个网站，是谷歌浏览器为了向大众演示 WebGL 技术而制作的一个演示网页。\n我相信你第一次看到这种基于浏览器的 3D 地球数据展示，一定会被震撼到的。\n接下来我们就要逐步分析，找出实现方式。\n我们先考虑怎么把这个场景实现出来，然后再考虑优化的事。\n核心模块分析 我们要先搞明白这个 3D 数字地球的核心模块。\n3D 地球\n就是一个球体，添加一个地球纹理图片\n图片为一个矩形地球展开图，本示例使用的地球纹理图片资源：\nhttps://threejsfundamentals.org/threejs/resources/images/world.jpg\n表示人口多少的柱状物\n某个地区人口多则柱状物就比较高，反之人口少则柱状物比较低\n鼠标可交互\n这个直接使用 OrbitControls 就可以 只不过本示例只允许左右、上下拖拽查看，但不允许修改镜头轨道的远近距离\n上面的核心模块 1 、3 都很容易实现，重点我们进一步拆解一下 “表示人口多少的柱状物”。\n如何实现“表示人口多少的柱状物”？ 我们通过以下 3 个灵魂追问，来梳理思路。\n第1问：人口数据从哪里来？\n原网页提供 3 个年份的人口数量统计，分别是 1990、1995、2000年。\n美国国家航天局(NASA)提供的统计结果介绍页： https://sedac.ciesin.columbia.edu/data/set/gpw-v4-admin-unit-center-points-population-estimates-rev11/data-download\n请注意，该页面还提供最近年份的统计结果，但是下载时候提示需要注册。\n我们选择不使用最新的 2020 年数据，而是使用 2010 年的结果。\n为了方便你获得到 2010 年男性人口统计结果，你可以直接点击下面这个地址，直接下载：\nhttps://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc\n反正我们本文的重点是模仿效果，至于数据时效性不必纠结\n该人口统计数据文件格式为 .asc，至于如何解析该文件，我们会稍后讲解\n为啥是男性人口统计？女性人口呢？为什么不是全部人口统计呢？\n因为在下一篇文章中，就会有女性人口统计，然后做出同一个地区 男女人口数量比较 的动画\n为了简化，本文下面文字中，将忽略 “男性人口数量” 这个概念，统一称呼为 “人口数据”\n第2问：人口数据和地区的对应关系，如何表现在地球上？\n我们把刚才下载得到的人口统计数据文件，重命名为 gpw_v4_014mt_2010.asc，然后将该文件移动到：src/assets/data/ 目录中。\n点击该文件，用记事本查看该文件内容，你会发现里面大致为以下内容：\nncols 360 nrows 145 xllcorner -180 yllcorner -60 cellsize 0.99999999999994 NODATA_value -9999 -9999 -9999 -9999 -9999 -9999 -999... ... ... 这里面的数据内容为：矩形地球地图上，不同点(经纬度)对应的数值(人口数量)。\n补充：这里面的人口数量值并不是具体人口数量(比如 45932551 个人)，而是具有一定比例单位的值(例如 458.6)\n具体单位值对应的人口我还不清楚，或许是 万，也或许是百万，不过不影响我们本示例，你只需把他当成数字即可\n我们需要将数据与地图纹理图片进行点对点的位置匹配。\n.asc 后缀的文件有特别多种用途和场景，我们这里提到的 .asc 文件是指：以 PGP (Pretty Good Privacy) ASCII Armored File形式存在的栅格化结构的数据文件。\n.asc 栅格化结构的数据文件说明：\n关键字 对应含义 ncols(number colos) 表示该数据内容有多少列 nrows(number rows) 表示该数据内容有多少行 xllcorner(x-low-left-corner) 栅格的左下角坐标 x 的值 yllcorner(y-low-left-corner) 栅格的左下角坐标 y 的值 cellsize(cell size) 每个单元格元的尺寸 NODATA_value 单元格内没有值时对应的值 你可以把 .asc文件 想象成一个数据表格，每个单元格为一项，nrows 行 ncols 列 个单元格构建成了一个 数据网格。\n除了 .asc 开头的属性值键对外，后面的就是依次填入数据单元网格中的数据。\n第3问：根据人口多少，如何创建对应的柱状物？\n当得到地球某个经纬度(地球纹理图片上的某个坐标)上对应的人口数据后，就可以根据人口数量按照一定比例，创建柱状物。\n原理讲过后，那接下来就是实际操作了。\n基础示例：HelloEarth 接下来，将通过以下几个步骤，逐步实现我们的目标示例。\n特别说明：\n以下几个步骤中的代码，重点是向你讲解具体的功能和思路，并不是最终的代码。\n最终完整的示例代码中，会对这些每个步骤中的代码进行新的组织。\n第1步：加载人口数据文件(gpw_v4_014mt_2010.asc) 数据文件路径为 ./src/assets/data/gpw_v4_014mt_2010.asc\n由于我们使用 alias 来得到 .asc 文件编译后的路径，所以请记得：\ntsconfig.pahts.json 的 paths 中添加 \"@/assets/*\": [\"./src/assets/*\"]\nglobal.d.ts 中添加 declare module '*.asc';\n以上 2 处均配置正确后，才可以让我们在代码中方便使用 require('@/assets/xx/xx.asc').default 来获取 .asc 资源的路径\n假设你并不是使用 react + typescript + alias，那么你可以忽略我提到的配置，直接请求一个固定的网络资源(.asc文件)就好了。\n通过 window.fetch() 这个函数来获取 .asc 文件内容\n我们这里没有使用 xhr 或 axios 来请求获取文件资源，而是使用了 fetch 这个 Web API\n关于 fetch 的用法，请参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API\n具体的代码：\nconst loadDataFile = async (url: string) =\u003e { try { const res = await window.fetch(url) const text = await res.text() // text 就是 .asc 文件里的内容 } catch (error) { console.log('加载数据出错') } } const ascURL = require('@/assets/data/gpw_v4_014mt_2010.asc').default loadDataFile(ascURL) 额外说一个事情，本文对应的是 Three.js 官方教程 https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects.html\n我在阅读英文原文时，当时他代码中使用的是：\nasync function loadFile(url) { const req = await fetch(url); return req.text(); } 我认为不应该将返回值使用变量 req(request)，而应该是 res(response)，于是我就提交了一个合并请求(PR)，然后很快就得到 greggman 的回应，我的 PR 已被合并到 master 中。\n呵，我也顺带成为了这个项目中的一名 贡献者(contributor)。\n第2步：解析人口数据 为了方便我们以后代码提示，我们先使用 TypeScript 定义解析 .asc 数据后的格式\ntype DataType = (number | undefined)[][] type ASCData = { data: DataType, ncols: number, nrows: number, xllcorner: number, yllcorner: number, cellsize: number, NODATA_value: number, max: number, min: number, } data 为栅格化的世界人口数据，一共 nrows 条，每一条是由 ncols 个数字构成\n假设某个点对应有人口数据则值为具体的数字，若没有人口则值为 undefined。\n请记得没有人口数据的值为 undefined，而不是 0。\nmax、min 分别为我们添加的自定义属性，用来记录所有地区人口数据中最多和最少的人口数量，以此我们方便计算出 柱状高度比例\n开始解析 .asc 文件内容，大体步骤如下：\n首先我们知道 .asc 中每一行对应一条数据，那么就可以使用换行符 ‘\\n’ 来分隔出每一条数据，然后针对每一条数据进行解析\ntext.split('\\n').forEach((line) =\u003e { ... }) 被分隔出来的每一行数据，再进一步转化和分析：\n由于可能存在多个连续空格，因此我们对每一条数据，再通过正则表达式 /\\s+/ 进一步分隔\n// 在正则表达式 ‘/\\s+/’ 中 s 表示为空格，+ 表示 1个或多个 const parts = line.trim().split(/\\s+/) 位于 .asc 文件开头，描述栅格化数据的一些属性，例如 ncols、nrows…，这些数据的结构为：属性名 + 空格 + 值 构成的\nif (parts.length === 2) { ... } 位于 .asc 文件中间，一行行，一条条具体的数据值，这些数据的结构为：数字 + 空格 + 数字 + ...\nif (parts.length \u003e 2) { ... } 位于 .asc 文件尾部，可能存在的、无用的空白换行，这些空白换行是需要被我们通过条件判断来忽略掉的\n由于前面已经进行了 length === 2 或 \u003e 2 的判断，那么剩下的就肯定是空白无用的换行，我们什么也不做处理就好。 在解析所有人口数据的过程中，我们要不断记录、得出 人口最大数值和最小数值\n最终将解析好的数据结果对象，通过 TS 的 as 断言，对外返回出结果\n补充一点：由于我们从 text 中读取到的 “数字” 其实是 字符串，所以在解析过程中都需要使用 parseFloat() 这个函数将 string 转化为 number\n再补充一个细节，在初始化 max 和 min 时：\n让 max 初始化值为 0，因为我们知道有人口数据的值一定是大于 0 的 让 min 初始化值为 99999，因为我们知道一定有人口数据的值一定是小于 99999 的，且人口数量一定不会是负数 具体的代码：\nconst parseData = (text: string) =\u003e { const data: (number|undefined)[][] = [] const settings: { [key: string]: any } = { data } let max:number = 0 let min:number = 99999 text.split('\\n').forEach((line) =\u003e { const parts = line.trim().split(/\\s+/) if (parts.length === 2) { settings[parts[0]] = parseFloat(parts[1]) } else if(parts.length \u003e 2) { const values = parts.map((item) =\u003e { const value = parseFloat(item) if (value === settings['NODATA_value']) { return undefined } max = Math.max(max, value) min = Math.min(min, value) return value }) data.push(values) } }) return { ...settings, ...{ max, min } } as ASCData } 第3步：加载地球纹理图片 const loader = new Three.TextureLoader() const texture = loader.load(require('@/assets/imgs/world.jpg').default,render) const material = new Three.MeshPhongMaterial({ map: texture }) const geometry = new Three.SphereBufferGeometry(2, 32, 32) const earth = new Three.Mesh(geometry, material) scene.add(earth) 请注意上述代码中，loader.load(xxx, render)，我们希望当纹理图片加载完成后，才执行 render 渲染\n第4步：将人口数据与地球纹理图片进行位置上的匹配 先不考虑球体，假设我们仅仅想获得一张显示人口数量分布、平面的世界地图，该如何做呢？\n代码思路：\n我们通过 第 2 步骤已经拿到了栅格化后的世界人口分布数据 并且我们知道栅格化的数据是由 nrow(145) 行、ncols(360) 列组成 假设 1 个数据点 对应 1 像素，那么栅格化的数据实际上对应的是一个 高 145 像素、宽 360 像素的图形 假设 数据点最小(人口最少)的地方，我们用黑色来填充，而数据点最大(人口最多)的地方用红色填充，处于中间数量的点按照比例依次进行颜色变化，那么就可以得到我们想要的图形了。 关于某个点填充的颜色，我们使用 HSL(色相、饱和度、亮度)，其中当 人口少时 L 的值越接近于 0 (黑色)、人口多时 L 的值越接近 1 (红色) 向画布(canvas) 某个点填充颜色，需要用到 canvas 一些相关知识，请自行先学习了解一下 canvas 相关知识 对应的代码：\nconst hsl = (h: number, s: number, l: number) =\u003e { return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)` } const drawData = (ascData: ASCData) =\u003e { if (canvasRef.current === null) { return } const ctx = canvasRef.current.getContext('2d') if (ctx === null) { return } const range = ascData.max - ascData.min ctx.canvas.width = ascData.ncols ctx.canvas.height = ascData.nrows ctx.fillStyle = '#444' ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height) ascData.data.forEach((row, rowIndex) =\u003e { row.forEach((value, colIndex) =\u003e { if (value === undefined) { return } const amount = (value - ascData.min) / range const hue = 1 const saturation = 1 const lightness = amount ctx.fillStyle = hsl(hue, saturation, lightness) ctx.fillRect(colIndex,rowIndex,1,1) }) }) } 为了让你比较直观看清，这里贴出目前我们已经写出来的代码。\n请注意下面的代码并不是我们真正示例的代码，你可以实际运行以下，查看效果\nimport { useEffect, useRef } from 'react' const loadDataFile = async (url: string) =\u003e { const res = await window.fetch(url) const text = await res.text() return text } type DataType = (number | undefined)[][] type ASCData = { data: DataType, ncols: number, nrows: number, xllcorner: number, yllcorner: number, cellsize: number, NODATA_value: number, max: number, min: number, } const parseData = (text: string) =\u003e { const data: DataType = [] const settings: { [key: string]: any } = { data } let max: number = 0 let min: number = 99999 text.split('\\n').forEach((line) =\u003e { const parts = line.trim().split(/\\s+/) if (parts.length === 2) { settings[parts[0]] = parseFloat(parts[1]) } else if (parts.length \u003e 2) { const values = parts.map((item) =\u003e { const value = parseFloat(item) if (value === settings['NODATA_value']) { return undefined } max = Math.max(max, value) min = Math.min(min, value) return value }) data.push(values) } }) return { ...settings, ...{ max, min } } as ASCData } const hsl = (h: number, s: number, l: number) =\u003e { return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)` } const HelloEarth = () =\u003e { const canvasRef = useRef(null) const drawData = (ascData: ASCData) =\u003e { if (canvasRef.current === null) { return } const ctx = canvasRef.current.getContext('2d') if (ctx === null) { return } const range = ascData.max - ascData.min ctx.canvas.width = ascData.ncols ctx.canvas.height = ascData.nrows ctx.fillStyle = '#444' ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height) ascData.data.forEach((row, rowIndex) =\u003e { row.forEach((value, colIndex) =\u003e { if (value === undefined) { return } const amount = (value - ascData.min) / range const hue = 1 const saturation = 1 const lightness = amount ctx.fillStyle = hsl(hue, saturation, lightness) ctx.fillRect(colIndex,rowIndex,1,1) }) }) } useEffect(() =\u003e { if (canvasRef.current === null) { return } const ascURL = require('@/assets/data/gpw_v4_014mt_2010.asc').default const doSomthing = async () =\u003e { try { const text = await loadDataFile(ascURL) const ascData = parseData(text) drawData(ascData) } catch (error) { console.log(error) } } doSomthing() return () =\u003e { } }, [canvasRef]) return ( ) } export default HelloEarth 实际运行后，就会看到一张 世界人口分布的地图\n请注意这个 “看似是世界地图”的图片并不是真正的世界地理位置地图，而是人口数量分布图。\n如果你已经看懂了上面的代码，那么接下来就可以真正去制作 3D 立体地球示例了。\n本示例是我们做过的最复杂的例子，尽管我们已经进行了详细的思路解读，你一定要多看，多敲几遍，否则接下来的代码你可能更加难以理解。\n我们需要将之前的 drawData() 修改 为 addBoxes()，并且不再是在 canvas 中绘制点，而是在球体上添加柱状物：\nconst addBoxes = (ascData: ASCData, scene: Three.Scene) =\u003e { const geometry = new Three.BoxBufferGeometry(1, 1, 1) geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5)) const lonHelper = new Three.Object3D() scene.add(lonHelper) const latHelper = new Three.Object3D() lonHelper.add(latHelper) const positionHelper = new Three.Object3D() positionHelper.position.z = 1 latHelper.add(positionHelper) const range = ascData.max - ascData.min const lonFudge = Math.PI * 0.5 const latFudge = Math.PI * -0.135 ascData.data.forEach((row, latIndex) =\u003e { row.forEach((value, lonIndex) =\u003e { if (value === undefined) { return } const amount = (value - ascData.min) / range const material = new Three.MeshBasicMaterial() const hue = Three.MathUtils.lerp(0.7, 0.3, amount) const saturation = 1 const lightness = Three.MathUtils.lerp(0.1, 1, amount) material.color.setHSL(hue, saturation, lightness) const mesh = new Three.Mesh(geometry, material) scene.add(mesh) lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge positionHelper.updateWorldMatrix(true, false) mesh.applyMatrix4(positionHelper.matrixWorld) mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount)) }) }) } 上面代码中牵扯到了非常多新的、之前从未使用过的一些函数或属性。\n解释说明：\n栅格化数据 和 纹理图片 均可看作是 2D 矩形坐标，最终需要转化为 3D 球体坐标，转化过程中 lonFudge、latFudge 具体作用机理，暂时还没搞明白。\n先记住转化公式，以后再慢慢研究\n栅格化数据 为 360 145、纹理图片为 2048 1024\nThree.Matrix4：WebGL 中的矩阵库\nThree.MathUtils：Three.js 中内置的一些计算函数\n关于这些新的对象具体详细介绍，请查阅 Three.js 官方文档\nlonHelper用于赤道上的经度旋转、latHelper用于维度旋转、positionHelper用于 Z 轴(地球地面)上的偏移。\nlonFudge 的值为 Math.PI * 0.5，也就是相当于 1/4 个圆(地球 1/4 圈)\nlatFudge 的值为 Math.PI * -0.135，这里的 -0.135 不太清楚是怎么得出来的，但是大概率推测它是用来将柱状物与纹理图片对齐的\n示例所需其他代码块：\n创建 3D 地球、以及加载纹理图片 添加 OrbitControls 控制，并且开启 “弹性结束控制” 添加场景渲染函数 render，并且添加 “按需渲染” 相关代码 最终完整的示例代码：\nimport { useEffect, useRef } from 'react' import * as Three from 'three' import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' import './index.scss' const loadDataFile = async (url: string) =\u003e { const res = await window.fetch(url) const text = await res.text() return text } type DataType = (number | undefined)[][] type ASCData = { data: DataType, ncols: number, nrows: number, xllcorner: number, yllcorner: number, cellsize: number, NODATA_value: number, max: number, min: number, } const parseData = (text: string) =\u003e { const data: DataType = [] const settings: { [key: string]: any } = { data } let max: number = 0 let min: number = 99999 text.split('\\n').forEach((line) =\u003e { const parts = line.trim().split(/\\s+/) if (parts.length === 2) { settings[parts[0]] = parseFloat(parts[1]) } else if (parts.length \u003e 2) { const values = parts.map((item) =\u003e { const value = parseFloat(item) if (value === settings['NODATA_value']) { return undefined } max = Math.max(max, value) min = Math.min(min, value) return value }) data.push(values) } }) return { ...settings, ...{ max, min } } as ASCData } // const hsl = (h: number, s: number, l: number) =\u003e { // return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)` // } let renderRequested = false const HelloEarth = () =\u003e { const canvasRef = useRef(null) // const drawData = (ascData: ASCData) =\u003e { // if (canvasRef.current === null) { return } // const ctx = canvasRef.current.getContext('2d') // if (ctx === null) { return } // const range = ascData.max - ascData.min // ctx.canvas.width = ascData.ncols // ctx.canvas.height = ascData.nrows // ctx.fillStyle = '#444' // ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height) // ascData.data.forEach((row, rowIndex) =\u003e { // row.forEach((value, colIndex) =\u003e { // if (value === undefined) { return } // const amount = (value - ascData.min) / range // const hue = 1 // const saturation = 1 // const lightness = amount // ctx.fillStyle = hsl(hue, saturation, lightness) // ctx.fillRect(colIndex, rowIndex, 1, 1) // }) // }) // } const addBoxes = (ascData: ASCData, scene: Three.Scene) =\u003e { const geometry = new Three.BoxBufferGeometry(1, 1, 1) geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5)) const lonHelper = new Three.Object3D() scene.add(lonHelper) const latHelper = new Three.Object3D() lonHelper.add(latHelper) const positionHelper = new Three.Object3D() positionHelper.position.z = 1 latHelper.add(positionHelper) const range = ascData.max - ascData.min const lonFudge = Math.PI * 0.5 const latFudge = Math.PI * -0.135 ascData.data.forEach((row, latIndex) =\u003e { row.forEach((value, lonIndex) =\u003e { if (value === undefined) { return } const amount = (value - ascData.min) / range const material = new Three.MeshBasicMaterial() const hue = Three.MathUtils.lerp(0.7, 0.3, amount) const saturation = 1 const lightness = Three.MathUtils.lerp(0.1, 1, amount) material.color.setHSL(hue, saturation, lightness) const mesh = new Three.Mesh(geometry, material) scene.add(mesh) lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge positionHelper.updateWorldMatrix(true, false) mesh.applyMatrix4(positionHelper.matrixWorld) mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount)) }) }) } useEffect(() =\u003e { if (canvasRef.current === null) { return } const canvas = canvasRef.current const renderer = new Three.WebGLRenderer({ canvas }) const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100) camera.position.z = 4 const scene = new Three.Scene() scene.background= new Three.Color(0x000000) const controls = new OrbitControls(camera, canvas) controls.enableDamping = true controls.enablePan =false controls.update() const render = () =\u003e { renderRequested = false controls.update() renderer.render(scene, camera) } const handleChange =() =\u003e{ if(renderRequested === false){ renderRequested = true window.requestAnimationFrame(render) } } controls.addEventListener('change',handleChange) const loader = new Three.TextureLoader() const texture = loader.load(require('@/assets/imgs/world.jpg').default, render) const material = new Three.MeshBasicMaterial({ map: texture }) const geometry = new Three.SphereBufferGeometry(1, 64, 32) const earth = new Three.Mesh(geometry, material) scene.add(earth) const handleResize = () =\u003e { const width = canvas.clientWidth const height = canvas.clientHeight camera.aspect = width / height camera.updateProjectionMatrix() renderer.setSize(width, height, false) window.requestAnimationFrame(render) } handleResize() window.addEventListener('resize', handleResize) const ascURL = require('@/assets/data/gpw_v4_014mt_2010.asc').default const doSomthing = async () =\u003e { try { const text = await loadDataFile(ascURL) const ascData = parseData(text) //drawData(ascData) addBoxes(ascData, scene) render() } catch (error) { console.log(error) } } doSomthing() return () =\u003e { controls.removeEventListener('change',handleChange) window.removeEventListener('resize', handleResize) } }, [canvasRef]) return ( ) } export default HelloEarth 调试运行，首先就会看到一个 3D 立体地球，等待 1 秒左右，待 .asc 数据加载并解析、添加地球上的柱状物后，就会看到本示例所想演示的最终效果。\n终于终于到这一步了\n不过当你鼠标拖动地球时，会感受到略微卡顿，或者说不够流畅。\n那么接下来，就到了本文的核心内容：通过 合并对象 来达到优化场景的目的。\n补充：启用浏览器 调试工具 DevTool 的 Rendering 查看渲染性能 除了浏览器本身的 性能(Performance) 面板外，还有另外一个重要的、方便我们查看页面渲染性能的工具——Rendering。\n通过谷歌调试工具 Rendering，查看当前页面渲染性能情况：\n打开浏览器调试工具 DevTool\n点击右侧 3 个小圆点\n鼠标移动到 More tools\n点击 Rendering\n在新出现的 Rendering 面板中，勾选 Frame Rendering Stats\n备注：在旧的谷歌浏览器中，应该勾选的是 Show FPS meter\n这样就可以在网页左上角，实时看到当前渲染性能状况。\n性能数据解读：\n性能展示的数据，主要 2 个模块：Frames 和 GPU\nGPU 相关：\nGPU raster ：on 表示 GPU 光栅化已开启\nGPU memory：GPU 已用大小、GPU 最大可用大小\n在本示例中，通常是当修改浏览器尺寸时，此时需要大量计算，会显示出 GPU memory\n在普通的 鼠标拖拽 改变地球视角时，不会显示 GPU memory\nFrames相关：\n假设某一时刻，渲染性能结果为 Frames：63% 1082(0m) dropped of 2737\n对应的解读为：\n第1个数字 63% —— 63% 的帧按时渲染完成\n第2个数字 1082 —— 有 1082 个合成帧丢失(未渲染)\n第3个数字 0m —— 有 0 个帧丢失\n第4个数字 2737 —— 原本计划渲染 2737 个帧\n数字之间的计算关系为 63% ≈ 1 - (1082 + 0 )/ 2737\n也就是说 第2个数字(丢失的合成帧)越小，那么整体按时完成渲染帧的百分比(第1个数字)越大，意味着此刻网页越流畅。\n优化代码：合并对象 核心代码分析 在上面的示例代码中，lonHelper用于赤道上的经度旋转、latHelper用于维度旋转、positionHelper用于 Z 轴(地球地面)上的偏移。\n默认 Three.js 中物体是有 1/2 位于 Z 轴之下的，通过Z轴的偏移让柱状物可以完全出现在地面上\n每一个数据点(柱状物)都创建了一个 MeshBasicMaterial 和 Mesh。\n我们的数据点一共为 145行、360列，那么就意味着假设全部数据点都有数据，那么数据点总数量为：145 * 360 = 52200，但是考虑到有非常多的数据点的值为 -9999(NODATA_value)，也就是没有值，不需要绘制，那么减去这些没有数据点，最终需要绘制的数据点(柱状物)大约为 19000 个。\n柱状物19000个，再加上对应的 3 个辅助对象(lonHelper、latHelper、positionHelper)，相当于总绘制数量为 19000 * 4 = 76000。\n也就是说每一次场景更新，大约需要绘制 7.6 万个对象，所以这才造成了卡顿现象。\n如何解决卡顿？减少需要渲染对象的数量！\n还记得我们刚才统计的渲染对象数量吗？\n柱状体 约 19000个 每个柱状体对应 3 个辅助对象 19000 * 3 我们需要做的就是把所有的柱状体合并成一个物体，也就是说原本需要渲染 19000 个柱状体，合并之后只需渲染 1 个，让柱状体数量减少 18999 个。\n修改 addBoxes 函数代码：\nimport { BufferGeometryUtils } from 'three/examples/jsm/utils/BufferGeometryUtils' const addBoxes = (ascData: ASCData, scene: Three.Scene) =\u003e { //const geometry = new Three.BoxBufferGeometry(1, 1, 1) //geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5)) const lonHelper = new Three.Object3D() scene.add(lonHelper) const latHelper = new Three.Object3D() lonHelper.add(latHelper) const positionHelper = new Three.Object3D() positionHelper.position.z = 1 latHelper.add(positionHelper) const originHelper = new Three.Object3D() originHelper.position.z = 0.5 positionHelper.add(originHelper) const range = ascData.max - ascData.min const lonFudge = Math.PI * 0.5 const latFudge = Math.PI * -0.135 const geometries: Three.BoxBufferGeometry[] = [] const color = new Three.Color() ascData.data.forEach((row, latIndex) =\u003e { row.forEach((value, lonIndex) =\u003e { if (value === undefined) { return } const amount = (value - ascData.min) / range //const material = new Three.MeshBasicMaterial() //const hue = Three.MathUtils.lerp(0.7, 0.3, amount) //const saturation = 1 //const lightness = Three.MathUtils.lerp(0.1, 1, amount) //material.color.setHSL(hue, saturation, lightness) //const mesh = new Three.Mesh(geometry, material) //scene.add(mesh) const geometry = new Three.BoxBufferGeometry(1, 1, 1) lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge //positionHelper.updateWorldMatrix(true, false) //mesh.applyMatrix4(positionHelper.matrixWorld) //mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount)) positionHelper.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.01, 0.5, amount)) originHelper.updateWorldMatrix(true, false) geometry.applyMatrix4(originHelper.matrixWorld) const hue = Three.MathUtils.lerp(0.7, 0.3, amount) const saturation = 1 const lightness = Three.MathUtils.lerp(0.1, 1, amount) color.setHSL(hue, saturation, lightness) const rgb = color.toArray().map((value) =\u003e { return value * 255 }) const numVerts = geometry.getAttribute('position').count const itemSize = 3 const colors = new Uint8Array(itemSize * numVerts) //这里有一个稍微奇葩点的写法，就是使用下划线 _ 来起到参数占位的作用 colors.forEach((_, index) =\u003e { colors[index] = rgb[index % 3] }) const normalized = true const colorAttrib = new Three.BufferAttribute(colors, itemSize, normalized) geometry.setAttribute('color', colorAttrib) geometries.push(geometry) }) }) const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries) //const material = new Three.MeshBasicMaterial({ color: 'red' }) const material = new Three.MeshBasicMaterial({ vertexColors: true }) const mesh = new Three.Mesh(mergedGeometry, material) scene.add(mesh) } 上述代码中，注释部分为之前 addBoxes() 函数的代码，除了 //const material = new Three.MeshBasicMaterial({ color: ‘red’ }) 这一行\n代码解析：\n合并所有的柱状物，使用到了一个新的函数 BufferGeometryUtils.mergeBufferGeometries()\n注意：BufferGeometryUtils 并非来自 Three，而是来自 ’three/examples/jsm/utils/BufferGeometryUtils’\n柱状物的颜色，不再使用 color 设定，而是启用了 “顶点着色”。\n关于这 2 个大的知识点，可以去阅读 Three.js 官方文档\n需要恶补官方文档，如果只是看了本教程，那么还会有大量的知识点未曾接触。\n经过合并优化后的场景，在浏览器中运行，比之前的流畅非常多，没有卡顿的现象了。\n我本机电脑硬件配置比较高，我分别记录了 Rendering 面板中 优化前后的 Frames 值。\n优化前：顺利渲染帧的百分比约为 60%\n优化后：顺利渲染帧的百分比约为 90%\n可见网页流畅度确实提高了很多\n本文小结 在 Three.js 大型的场景中，绝大多数都需要采用合并对象的策略来优化渲染性能。\n合并对象可以减少需要渲染的对象数量，并且还可以将有一些根本不可见的面进行删除，减少渲染面，提高渲染性能。\n你以为就这样可以结束了？\n事实上还有优化空间，本文先到这里结束。\n下一篇将继续优化这个场景。\n",
  "wordCount" : "7517",
  "inLanguage": "en",
  "datePublished": "2023-12-19T17:11:35+08:00",
  "dateModified": "2023-12-19T17:11:35+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://bablvsj.github.io/posts/threejs/20-three.js%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Bablvsj's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://bablvsj.github.io/img/Q.gif"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://bablvsj.github.io" accesskey="h" title="Bablvsj&#39;s Blog (Alt + H)">Bablvsj&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://bablvsj.github.io/" title="主页">
                    <span>主页</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/archives/" title="时间轴">
                    <span>时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/tags" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/about" title="关于">
                    <span>关于</span>
                </a>
            </li>
            <li>
                <a href="https://bablvsj.github.io/search" title="🔍 (Alt &#43; /)" accesskey=/>
                    <span>🔍</span>
                </a>
            </li>
        </ul>
    </nav>
</header>


<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      20 Three.js优化之合并对象
    </h1>
    <div class="post-meta">
      
<div class="post-tags-meta">
    <a href="https://bablvsj.github.io/tags/three.js/">Three.js</a>
</div>

16 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 CST'>2023/12/19</span>


      
    </div>
    
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        
        <div class="inner"><ul><ul><ul>
                <li>
                    <a href="#%e6%9c%ac%e6%96%87%e6%88%91%e4%bb%ac%e7%9a%84%e7%9b%ae%e6%a0%87%e5%88%b6%e4%bd%9c%e5%b9%b6%e4%bc%98%e5%8c%96%e4%b8%80%e4%b8%aa%e6%98%be%e7%a4%ba%e5%9c%b0%e7%90%83%e4%ba%ba%e5%8f%a3%e4%ba%ba%e6%95%b0%e5%88%86%e5%b8%83%e7%9a%84%e5%8f%af%e8%a7%86%e5%8c%963d%e5%9c%b0%e7%90%83" aria-label="本文我们的目标：制作并优化一个显示地球人口人数分布的可视化3D地球">本文我们的目标：制作并优化一个显示地球人口人数分布的可视化3D地球</a></li>
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e6%a8%a1%e5%9d%97%e5%88%86%e6%9e%90" aria-label="核心模块分析">核心模块分析</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e8%a1%a8%e7%a4%ba%e4%ba%ba%e5%8f%a3%e5%a4%9a%e5%b0%91%e7%9a%84%e6%9f%b1%e7%8a%b6%e7%89%a9" aria-label="如何实现“表示人口多少的柱状物”？">如何实现“表示人口多少的柱状物”？</a></li></ul>
                    </ul>
                    
                <li>
                    <a href="#%e5%9f%ba%e7%a1%80%e7%a4%ba%e4%be%8bhelloearth" aria-label="基础示例：HelloEarth">基础示例：HelloEarth</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e7%ac%ac1%e6%ad%a5%e5%8a%a0%e8%bd%bd%e4%ba%ba%e5%8f%a3%e6%95%b0%e6%8d%ae%e6%96%87%e4%bb%b6gpw_v4_014mt_2010asc" aria-label="第1步：加载人口数据文件(gpw_v4_014mt_2010.asc)">第1步：加载人口数据文件(gpw_v4_014mt_2010.asc)</a></li>
                <li>
                    <a href="#%e7%ac%ac2%e6%ad%a5%e8%a7%a3%e6%9e%90%e4%ba%ba%e5%8f%a3%e6%95%b0%e6%8d%ae" aria-label="第2步：解析人口数据">第2步：解析人口数据</a></li>
                <li>
                    <a href="#%e7%ac%ac3%e6%ad%a5%e5%8a%a0%e8%bd%bd%e5%9c%b0%e7%90%83%e7%ba%b9%e7%90%86%e5%9b%be%e7%89%87" aria-label="第3步：加载地球纹理图片">第3步：加载地球纹理图片</a></li>
                <li>
                    <a href="#%e7%ac%ac4%e6%ad%a5%e5%b0%86%e4%ba%ba%e5%8f%a3%e6%95%b0%e6%8d%ae%e4%b8%8e%e5%9c%b0%e7%90%83%e7%ba%b9%e7%90%86%e5%9b%be%e7%89%87%e8%bf%9b%e8%a1%8c%e4%bd%8d%e7%bd%ae%e4%b8%8a%e7%9a%84%e5%8c%b9%e9%85%8d" aria-label="第4步：将人口数据与地球纹理图片进行位置上的匹配">第4步：将人口数据与地球纹理图片进行位置上的匹配</a></li>
                <li>
                    <a href="#%e8%a1%a5%e5%85%85%e5%90%af%e7%94%a8%e6%b5%8f%e8%a7%88%e5%99%a8-%e8%b0%83%e8%af%95%e5%b7%a5%e5%85%b7-devtool-%e7%9a%84-rendering-%e6%9f%a5%e7%9c%8b%e6%b8%b2%e6%9f%93%e6%80%a7%e8%83%bd" aria-label="补充：启用浏览器 调试工具 DevTool 的 Rendering 查看渲染性能">补充：启用浏览器 调试工具 DevTool 的 Rendering 查看渲染性能</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e4%bc%98%e5%8c%96%e4%bb%a3%e7%a0%81%e5%90%88%e5%b9%b6%e5%af%b9%e8%b1%a1" aria-label="优化代码：合并对象">优化代码：合并对象</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e6%a0%b8%e5%bf%83%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90" aria-label="核心代码分析">核心代码分析</a></li>
                <li>
                    <a href="#%e6%9c%ac%e6%96%87%e5%b0%8f%e7%bb%93" aria-label="本文小结">本文小结</a>
                </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>

  <div class="post-content"><p>前面学习了 Three.js 入门、基础、技巧，今天开始学习 Three.js 的性能优化。</p>
<p>关于性能优化有很多方式，最基础也是最常见的方式就是——合并几何对象。</p>
<blockquote>
<p>在 “Three.js 基础之图元” 那篇文章中，我们将几何体称呼为 图元，现在我们修改一下这个称呼，本文以后，绝大多数情况下我们都使用 “几何体” 来代替 “图元”。</p>
</blockquote>
<p>既然谈到性能优化，就不能使用简单的示例，要不然根本无法体现出 优化前和优化后 的区别。</p>
<p>激动人心的时刻到了。</p>
<h4 id="本文我们的目标制作并优化一个显示地球人口人数分布的可视化3d地球">本文我们的目标：制作并优化一个显示地球人口人数分布的可视化3D地球<a hidden class="anchor" aria-hidden="true" href="#本文我们的目标制作并优化一个显示地球人口人数分布的可视化3d地球">#</a></h4>
<p>你可以先访问以下网址，先感受一下我们本文要模仿的效果：</p>
<p><a href="https://globe.chromeexperiments.com/">https://globe.chromeexperiments.com/</a></p>
<blockquote>
<p>补充说明：这个网站，是谷歌浏览器为了向大众演示 WebGL 技术而制作的一个演示网页。</p>
</blockquote>
<p>我相信你第一次看到这种基于浏览器的 3D 地球数据展示，一定会被震撼到的。</p>
<p>接下来我们就要逐步分析，找出实现方式。</p>
<p><strong>我们先考虑怎么把这个场景实现出来，然后再考虑优化的事。</strong></p>
<h4 id="核心模块分析">核心模块分析<a hidden class="anchor" aria-hidden="true" href="#核心模块分析">#</a></h4>
<p>我们要先搞明白这个 3D 数字地球的核心模块。</p>
<ol>
<li>
<p>3D 地球</p>
<blockquote>
<p>就是一个球体，添加一个地球纹理图片</p>
<blockquote>
<p>图片为一个矩形地球展开图，本示例使用的地球纹理图片资源：<br>
<a href="https://threejsfundamentals.org/threejs/resources/images/world.jpg">https://threejsfundamentals.org/threejs/resources/images/world.jpg</a></p>
</blockquote>
</blockquote>
</li>
<li>
<p>表示人口多少的柱状物</p>
<blockquote>
<p>某个地区人口多则柱状物就比较高，反之人口少则柱状物比较低</p>
</blockquote>
</li>
<li>
<p>鼠标可交互</p>
<blockquote>
<p>这个直接使用 OrbitControls 就可以
只不过本示例只允许左右、上下拖拽查看，但不允许修改镜头轨道的远近距离</p>
</blockquote>
</li>
</ol>
<p>上面的核心模块 1 、3 都很容易实现，重点我们进一步拆解一下 “表示人口多少的柱状物”。</p>
<h4 id="如何实现表示人口多少的柱状物">如何实现“表示人口多少的柱状物”？<a hidden class="anchor" aria-hidden="true" href="#如何实现表示人口多少的柱状物">#</a></h4>
<p>我们通过以下 3 个灵魂追问，来梳理思路。</p>
<p><strong>第1问：人口数据从哪里来？</strong></p>
<p>原网页提供 3 个年份的人口数量统计，分别是 1990、1995、2000年。</p>
<p>美国国家航天局(NASA)提供的统计结果介绍页：
<a href="https://sedac.ciesin.columbia.edu/data/set/gpw-v4-admin-unit-center-points-population-estimates-rev11/data-download">https://sedac.ciesin.columbia.edu/data/set/gpw-v4-admin-unit-center-points-population-estimates-rev11/data-download</a></p>
<p>请注意，该页面还提供最近年份的统计结果，但是下载时候提示需要注册。</p>
<p>我们选择不使用最新的 2020 年数据，而是使用 2010 年的结果。</p>
<p>为了方便你获得到 2010 年男性人口统计结果，你可以直接点击下面这个地址，直接下载：</p>
<p><a href="https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc">https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc</a></p>
<blockquote>
<p>反正我们本文的重点是模仿效果，至于数据时效性不必纠结</p>
</blockquote>
<blockquote>
<p>该人口统计数据文件格式为 .asc，至于如何解析该文件，我们会稍后讲解</p>
</blockquote>
<blockquote>
<p>为啥是男性人口统计？女性人口呢？为什么不是全部人口统计呢？<br>
因为在下一篇文章中，就会有女性人口统计，然后做出同一个地区 男女人口数量比较 的动画<br>
为了简化，本文下面文字中，将忽略 “男性人口数量” 这个概念，统一称呼为 “人口数据”</p>
</blockquote>
<p><strong>第2问：人口数据和地区的对应关系，如何表现在地球上？</strong></p>
<p>我们把刚才下载得到的人口统计数据文件，重命名为 gpw_v4_014mt_2010.asc，然后将该文件移动到：src/assets/data/ 目录中。</p>
<p>点击该文件，用记事本查看该文件内容，你会发现里面大致为以下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>ncols         360
</span></span><span style="display:flex;"><span>nrows         145
</span></span><span style="display:flex;"><span>xllcorner     -180
</span></span><span style="display:flex;"><span>yllcorner     -60
</span></span><span style="display:flex;"><span>cellsize      0.99999999999994
</span></span><span style="display:flex;"><span>NODATA_value  -9999
</span></span><span style="display:flex;"><span>-9999 -9999 -9999 -9999 -9999 -999...
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>这里面的数据内容为：<strong>矩形地球地图上，不同点(经纬度)对应的数值(人口数量)</strong>。</p>
<blockquote>
<p>补充：这里面的人口数量值并不是具体人口数量(比如 45932551 个人)，而是具有一定比例单位的值(例如 458.6)</p>
<p>具体单位值对应的人口我还不清楚，或许是 万，也或许是百万，不过不影响我们本示例，你只需把他当成数字即可</p>
</blockquote>
<p>我们需要将数据与地图纹理图片进行点对点的位置匹配。</p>
<blockquote>
<p>.asc 后缀的文件有特别多种用途和场景，我们这里提到的 .asc 文件是指：以 <code>PGP (Pretty Good Privacy) ASCII Armored File</code>形式存在的栅格化结构的数据文件。</p>
</blockquote>
<blockquote>
<p><strong>.asc 栅格化结构的数据文件说明：</strong></p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>对应含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ncols(number colos)</td>
<td>表示该数据内容有多少列</td>
</tr>
<tr>
<td>nrows(number rows)</td>
<td>表示该数据内容有多少行</td>
</tr>
<tr>
<td>xllcorner(x-low-left-corner)</td>
<td>栅格的左下角坐标 x 的值</td>
</tr>
<tr>
<td>yllcorner(y-low-left-corner)</td>
<td>栅格的左下角坐标 y 的值</td>
</tr>
<tr>
<td>cellsize(cell size)</td>
<td>每个单元格元的尺寸</td>
</tr>
<tr>
<td>NODATA_value</td>
<td>单元格内没有值时对应的值</td>
</tr>
</tbody>
</table>
<blockquote>
<p>你可以把 .asc文件 想象成一个数据表格，每个单元格为一项，nrows 行 ncols 列 个单元格构建成了一个 数据网格。</p>
<p>除了 .asc 开头的属性值键对外，后面的就是依次填入数据单元网格中的数据。</p>
</blockquote>
</blockquote>
<p><strong>第3问：根据人口多少，如何创建对应的柱状物？</strong></p>
<p>当得到地球某个经纬度(地球纹理图片上的某个坐标)上对应的人口数据后，就可以根据人口数量按照一定比例，创建柱状物。</p>
<p>原理讲过后，那接下来就是实际操作了。</p>
<h2 id="基础示例helloearth">基础示例：HelloEarth<a hidden class="anchor" aria-hidden="true" href="#基础示例helloearth">#</a></h2>
<p>接下来，将通过以下几个步骤，逐步实现我们的目标示例。</p>
<p><strong>特别说明：</strong></p>
<p>以下几个步骤中的代码，重点是向你讲解具体的功能和思路，并不是最终的代码。</p>
<p>最终完整的示例代码中，会对这些每个步骤中的代码进行新的组织。</p>
<h4 id="第1步加载人口数据文件gpw_v4_014mt_2010asc">第1步：加载人口数据文件(gpw_v4_014mt_2010.asc)<a hidden class="anchor" aria-hidden="true" href="#第1步加载人口数据文件gpw_v4_014mt_2010asc">#</a></h4>
<ol>
<li>
<p><strong>数据文件路径为 ./src/assets/data/gpw_v4_014mt_2010.asc</strong></p>
</li>
<li>
<p><strong>由于我们使用 alias 来得到 .asc 文件编译后的路径，所以请记得：</strong></p>
<ol>
<li>
<p>tsconfig.pahts.json 的 paths 中添加 <code>&quot;@/assets/*&quot;: [&quot;./src/assets/*&quot;]</code></p>
</li>
<li>
<p>global.d.ts 中添加 <code>declare module '*.asc';</code></p>
</li>
<li>
<p>以上 2 处均配置正确后，才可以让我们在代码中方便使用 <code>require('@/assets/xx/xx.asc').default</code> 来获取 .asc 资源的路径</p>
<blockquote>
<p>假设你并不是使用 react + typescript + alias，那么你可以忽略我提到的配置，直接请求一个固定的网络资源(.asc文件)就好了。</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p><strong>通过 window.fetch() 这个函数来获取 .asc 文件内容</strong></p>
<blockquote>
<p>我们这里没有使用 xhr 或 axios 来请求获取文件资源，而是使用了 fetch 这个 Web API</p>
<p>关于 fetch 的用法，请参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API</a></p>
</blockquote>
</li>
</ol>
<p><strong>具体的代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const loadDataFile = async (url: string) =&gt; {
</span></span><span style="display:flex;"><span>    try {
</span></span><span style="display:flex;"><span>        const res = await window.fetch(url)
</span></span><span style="display:flex;"><span>        const text = await res.text() // text 就是 .asc 文件里的内容
</span></span><span style="display:flex;"><span>    } catch (error) {
</span></span><span style="display:flex;"><span>        console.log(&#39;加载数据出错&#39;)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const ascURL = require(&#39;@/assets/data/gpw_v4_014mt_2010.asc&#39;).default
</span></span><span style="display:flex;"><span>loadDataFile(ascURL)
</span></span></code></pre></div><blockquote>
<p>额外说一个事情，本文对应的是 Three.js 官方教程 <a href="https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects.html">https://threejsfundamentals.org/threejs/lessons/threejs-optimize-lots-of-objects.html</a></p>
<p>我在阅读英文原文时，当时他代码中使用的是：</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>async function loadFile(url) {
</span></span><span style="display:flex;"><span>  const req = await fetch(url);
</span></span><span style="display:flex;"><span>  return req.text();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>我认为不应该将返回值使用变量 req(request)，而应该是 res(response)，于是我就提交了一个合并请求(PR)，然后很快就得到 <a href="https://github.com/greggman">greggman</a> 的回应，我的 PR 已被合并到 master 中。</p>
<p>呵，我也顺带成为了这个项目中的一名 贡献者(contributor)。</p>
</blockquote>
<h4 id="第2步解析人口数据">第2步：解析人口数据<a hidden class="anchor" aria-hidden="true" href="#第2步解析人口数据">#</a></h4>
<ol>
<li>
<p><strong>为了方便我们以后代码提示，我们先使用 TypeScript 定义解析 .asc 数据后的格式</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>type DataType = (number | undefined)[][]
</span></span><span style="display:flex;"><span>type ASCData = {
</span></span><span style="display:flex;"><span>    data: DataType,
</span></span><span style="display:flex;"><span>    ncols: number,
</span></span><span style="display:flex;"><span>    nrows: number,
</span></span><span style="display:flex;"><span>    xllcorner: number,
</span></span><span style="display:flex;"><span>    yllcorner: number,
</span></span><span style="display:flex;"><span>    cellsize: number,
</span></span><span style="display:flex;"><span>    NODATA_value: number,
</span></span><span style="display:flex;"><span>    max: number,
</span></span><span style="display:flex;"><span>    min: number,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>data 为栅格化的世界人口数据，一共 nrows 条，每一条是由 ncols 个数字构成</p>
<p>假设某个点对应有人口数据则值为具体的数字，若没有人口则值为 undefined。</p>
<p>请记得没有人口数据的值为 undefined，而不是 0。</p>
<p>max、min 分别为我们添加的自定义属性，用来记录所有地区人口数据中最多和最少的人口数量，以此我们方便计算出 柱状高度比例</p>
</blockquote>
</li>
<li>
<p><strong>开始解析 .asc 文件内容，大体步骤如下：</strong></p>
<ol>
<li>
<p>首先我们知道 .asc 中每一行对应一条数据，那么就可以使用换行符 &lsquo;\n&rsquo; 来分隔出每一条数据，然后针对每一条数据进行解析</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>text.split(&#39;\n&#39;).forEach((line) =&gt; { ... })
</span></span></code></pre></div></li>
<li>
<p>被分隔出来的每一行数据，再进一步转化和分析：</p>
<ol>
<li>
<p>由于可能存在多个连续空格，因此我们对每一条数据，再通过正则表达式 <code>/\s+/</code> 进一步分隔</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// 在正则表达式 ‘/\s+/’ 中 s 表示为空格，+ 表示 1个或多个
</span></span><span style="display:flex;"><span>const parts = line.trim().split(/\s+/)
</span></span></code></pre></div></li>
<li>
<p>位于 .asc 文件开头，描述栅格化数据的一些属性，例如 ncols、nrows&hellip;，这些数据的结构为：<code>属性名 + 空格 + 值</code> 构成的</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>if (parts.length === 2) { ... }
</span></span></code></pre></div></li>
<li>
<p>位于 .asc 文件中间，一行行，一条条具体的数据值，这些数据的结构为：<code>数字 + 空格 + 数字 + ...</code></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>if (parts.length &gt; 2) { ... }
</span></span></code></pre></div></li>
<li>
<p>位于 .asc 文件尾部，可能存在的、无用的空白换行，这些空白换行是需要被我们通过条件判断来忽略掉的</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>由于前面已经进行了 length === 2 或 &gt; 2 的判断，那么剩下的就肯定是空白无用的换行，我们什么也不做处理就好。
</span></span></code></pre></div></li>
</ol>
</li>
<li>
<p>在解析所有人口数据的过程中，我们要不断记录、得出 人口最大数值和最小数值</p>
</li>
<li>
<p>最终将解析好的数据结果对象，通过 TS 的 as 断言，对外返回出结果</p>
</li>
<li>
<p>补充一点：由于我们从 text 中读取到的 “数字” 其实是 字符串，所以在解析过程中都需要使用 parseFloat() 这个函数将 string 转化为 number</p>
</li>
<li>
<p>再补充一个细节，在初始化 max 和 min 时：</p>
<ol>
<li>让 max 初始化值为 0，因为我们知道有人口数据的值一定是大于 0 的</li>
<li>让 min 初始化值为 99999，因为我们知道一定有人口数据的值一定是小于 99999 的，且人口数量一定不会是负数</li>
</ol>
</li>
</ol>
<p><strong>具体的代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const parseData = (text: string) =&gt; {
</span></span><span style="display:flex;"><span>    const data: (number|undefined)[][] = []
</span></span><span style="display:flex;"><span>    const settings: { [key: string]: any } = { data }
</span></span><span style="display:flex;"><span>    let max:number = 0
</span></span><span style="display:flex;"><span>    let min:number = 99999
</span></span><span style="display:flex;"><span>    text.split(&#39;\n&#39;).forEach((line) =&gt; {
</span></span><span style="display:flex;"><span>        const parts = line.trim().split(/\s+/)
</span></span><span style="display:flex;"><span>        if (parts.length === 2) {
</span></span><span style="display:flex;"><span>            settings[parts[0]] = parseFloat(parts[1])
</span></span><span style="display:flex;"><span>        } else if(parts.length &gt; 2) {
</span></span><span style="display:flex;"><span>            const values = parts.map((item) =&gt; {
</span></span><span style="display:flex;"><span>                const value = parseFloat(item)
</span></span><span style="display:flex;"><span>                if (value === settings[&#39;NODATA_value&#39;]) {
</span></span><span style="display:flex;"><span>                    return undefined
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                max = Math.max(max, value)
</span></span><span style="display:flex;"><span>                min = Math.min(min, value)
</span></span><span style="display:flex;"><span>                return value
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>            data.push(values)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    return { ...settings, ...{ max, min } } as ASCData
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<h4 id="第3步加载地球纹理图片">第3步：加载地球纹理图片<a hidden class="anchor" aria-hidden="true" href="#第3步加载地球纹理图片">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const loader = new Three.TextureLoader()
</span></span><span style="display:flex;"><span>const texture = loader.load(require(&#39;@/assets/imgs/world.jpg&#39;).default,render)
</span></span><span style="display:flex;"><span>const material = new Three.MeshPhongMaterial({
</span></span><span style="display:flex;"><span>    map: texture
</span></span><span style="display:flex;"><span>})
</span></span><span style="display:flex;"><span>const geometry = new Three.SphereBufferGeometry(2, 32, 32)
</span></span><span style="display:flex;"><span>const earth = new Three.Mesh(geometry, material)
</span></span><span style="display:flex;"><span>scene.add(earth)
</span></span></code></pre></div><blockquote>
<p>请注意上述代码中，loader.load(xxx, render)，我们希望当纹理图片加载完成后，才执行 render 渲染</p>
</blockquote>
<h4 id="第4步将人口数据与地球纹理图片进行位置上的匹配">第4步：将人口数据与地球纹理图片进行位置上的匹配<a hidden class="anchor" aria-hidden="true" href="#第4步将人口数据与地球纹理图片进行位置上的匹配">#</a></h4>
<p><strong>先不考虑球体，假设我们仅仅想获得一张显示人口数量分布、平面的世界地图，该如何做呢？</strong></p>
<p><strong>代码思路：</strong></p>
<ol>
<li>我们通过 第 2 步骤已经拿到了栅格化后的世界人口分布数据</li>
<li>并且我们知道栅格化的数据是由 nrow(145) 行、ncols(360) 列组成</li>
<li>假设 1 个数据点 对应 1 像素，那么栅格化的数据实际上对应的是一个 高 145 像素、宽 360 像素的图形</li>
<li>假设 数据点最小(人口最少)的地方，我们用黑色来填充，而数据点最大(人口最多)的地方用红色填充，处于中间数量的点按照比例依次进行颜色变化，那么就可以得到我们想要的图形了。
<ol>
<li>关于某个点填充的颜色，我们使用 HSL(色相、饱和度、亮度)，其中当 人口少时 L 的值越接近于 0 (黑色)、人口多时 L 的值越接近 1 (红色)</li>
<li>向画布(canvas) 某个点填充颜色，需要用到 canvas 一些相关知识，请自行先学习了解一下 canvas 相关知识</li>
</ol>
</li>
</ol>
<p><strong>对应的代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const hsl = (h: number, s: number, l: number) =&gt; {
</span></span><span style="display:flex;"><span>    return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const drawData = (ascData: ASCData) =&gt; {
</span></span><span style="display:flex;"><span>    if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>    const ctx = canvasRef.current.getContext(&#39;2d&#39;)
</span></span><span style="display:flex;"><span>    if (ctx === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const range = ascData.max - ascData.min
</span></span><span style="display:flex;"><span>    ctx.canvas.width = ascData.ncols
</span></span><span style="display:flex;"><span>    ctx.canvas.height = ascData.nrows
</span></span><span style="display:flex;"><span>    ctx.fillStyle = &#39;#444&#39;
</span></span><span style="display:flex;"><span>    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
</span></span><span style="display:flex;"><span>    ascData.data.forEach((row, rowIndex) =&gt; {
</span></span><span style="display:flex;"><span>        row.forEach((value, colIndex) =&gt; {
</span></span><span style="display:flex;"><span>            if (value === undefined) { return }
</span></span><span style="display:flex;"><span>            const amount = (value - ascData.min) / range
</span></span><span style="display:flex;"><span>            const hue = 1
</span></span><span style="display:flex;"><span>            const saturation = 1
</span></span><span style="display:flex;"><span>            const lightness = amount
</span></span><span style="display:flex;"><span>            ctx.fillStyle = hsl(hue, saturation, lightness)
</span></span><span style="display:flex;"><span>            ctx.fillRect(colIndex,rowIndex,1,1)
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为了让你比较直观看清，这里贴出目前我们已经写出来的代码。</p>
<blockquote>
<p>请注意下面的代码并不是我们真正示例的代码，你可以实际运行以下，查看效果</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>import { useEffect, useRef } from &#39;react&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const loadDataFile = async (url: string) =&gt; {
</span></span><span style="display:flex;"><span>    const res = await window.fetch(url)
</span></span><span style="display:flex;"><span>    const text = await res.text()
</span></span><span style="display:flex;"><span>    return text
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>type DataType = (number | undefined)[][]
</span></span><span style="display:flex;"><span>type ASCData = {
</span></span><span style="display:flex;"><span>    data: DataType,
</span></span><span style="display:flex;"><span>    ncols: number,
</span></span><span style="display:flex;"><span>    nrows: number,
</span></span><span style="display:flex;"><span>    xllcorner: number,
</span></span><span style="display:flex;"><span>    yllcorner: number,
</span></span><span style="display:flex;"><span>    cellsize: number,
</span></span><span style="display:flex;"><span>    NODATA_value: number,
</span></span><span style="display:flex;"><span>    max: number,
</span></span><span style="display:flex;"><span>    min: number,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const parseData = (text: string) =&gt; {
</span></span><span style="display:flex;"><span>    const data: DataType = []
</span></span><span style="display:flex;"><span>    const settings: { [key: string]: any } = { data }
</span></span><span style="display:flex;"><span>    let max: number = 0
</span></span><span style="display:flex;"><span>    let min: number = 99999
</span></span><span style="display:flex;"><span>    text.split(&#39;\n&#39;).forEach((line) =&gt; {
</span></span><span style="display:flex;"><span>        const parts = line.trim().split(/\s+/)
</span></span><span style="display:flex;"><span>        if (parts.length === 2) {
</span></span><span style="display:flex;"><span>            settings[parts[0]] = parseFloat(parts[1])
</span></span><span style="display:flex;"><span>        } else if (parts.length &gt; 2) {
</span></span><span style="display:flex;"><span>            const values = parts.map((item) =&gt; {
</span></span><span style="display:flex;"><span>                const value = parseFloat(item)
</span></span><span style="display:flex;"><span>                if (value === settings[&#39;NODATA_value&#39;]) {
</span></span><span style="display:flex;"><span>                    return undefined
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                max = Math.max(max, value)
</span></span><span style="display:flex;"><span>                min = Math.min(min, value)
</span></span><span style="display:flex;"><span>                return value
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>            data.push(values)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    return { ...settings, ...{ max, min } } as ASCData
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const hsl = (h: number, s: number, l: number) =&gt; {
</span></span><span style="display:flex;"><span>    return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const HelloEarth = () =&gt; {
</span></span><span style="display:flex;"><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const drawData = (ascData: ASCData) =&gt; {
</span></span><span style="display:flex;"><span>        if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>        const ctx = canvasRef.current.getContext(&#39;2d&#39;)
</span></span><span style="display:flex;"><span>        if (ctx === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const range = ascData.max - ascData.min
</span></span><span style="display:flex;"><span>        ctx.canvas.width = ascData.ncols
</span></span><span style="display:flex;"><span>        ctx.canvas.height = ascData.nrows
</span></span><span style="display:flex;"><span>        ctx.fillStyle = &#39;#444&#39;
</span></span><span style="display:flex;"><span>        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
</span></span><span style="display:flex;"><span>        ascData.data.forEach((row, rowIndex) =&gt; {
</span></span><span style="display:flex;"><span>            row.forEach((value, colIndex) =&gt; {
</span></span><span style="display:flex;"><span>                if (value === undefined) { return }
</span></span><span style="display:flex;"><span>                const amount = (value - ascData.min) / range
</span></span><span style="display:flex;"><span>                const hue = 1
</span></span><span style="display:flex;"><span>                const saturation = 1
</span></span><span style="display:flex;"><span>                const lightness = amount
</span></span><span style="display:flex;"><span>                ctx.fillStyle = hsl(hue, saturation, lightness)
</span></span><span style="display:flex;"><span>                ctx.fillRect(colIndex,rowIndex,1,1)
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>        if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>        const ascURL = require(&#39;@/assets/data/gpw_v4_014mt_2010.asc&#39;).default
</span></span><span style="display:flex;"><span>        const doSomthing = async () =&gt; {
</span></span><span style="display:flex;"><span>            try {
</span></span><span style="display:flex;"><span>                const text = await loadDataFile(ascURL)
</span></span><span style="display:flex;"><span>                const ascData = parseData(text)
</span></span><span style="display:flex;"><span>                drawData(ascData)
</span></span><span style="display:flex;"><span>            } catch (error) {
</span></span><span style="display:flex;"><span>                console.log(error)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        doSomthing()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return () =&gt; {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }, [canvasRef])
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>        return (
</span></span><span style="display:flex;"><span>        &lt;canvas ref={canvasRef} /&gt;
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export default HelloEarth
</span></span></code></pre></div><p>实际运行后，就会看到一张 世界人口分布的地图</p>
<blockquote>
<p>请注意这个 “看似是世界地图”的图片并不是真正的世界地理位置地图，而是人口数量分布图。</p>
</blockquote>
<p><strong>如果你已经看懂了上面的代码，那么接下来就可以真正去制作 3D 立体地球示例了。</strong></p>
<blockquote>
<p>本示例是我们做过的最复杂的例子，尽管我们已经进行了详细的思路解读，你一定要多看，多敲几遍，否则接下来的代码你可能更加难以理解。</p>
</blockquote>
<p><strong>我们需要将之前的 drawData() 修改 为 addBoxes()，并且不再是在 canvas 中绘制点，而是在球体上添加柱状物：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>const addBoxes = (ascData: ASCData, scene: Three.Scene) =&gt; {
</span></span><span style="display:flex;"><span>    const geometry = new Three.BoxBufferGeometry(1, 1, 1)
</span></span><span style="display:flex;"><span>    geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const lonHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>    scene.add(lonHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const latHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>    lonHelper.add(latHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const positionHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>    positionHelper.position.z = 1
</span></span><span style="display:flex;"><span>    latHelper.add(positionHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const range = ascData.max - ascData.min
</span></span><span style="display:flex;"><span>    const lonFudge = Math.PI * 0.5
</span></span><span style="display:flex;"><span>    const latFudge = Math.PI * -0.135
</span></span><span style="display:flex;"><span>    ascData.data.forEach((row, latIndex) =&gt; {
</span></span><span style="display:flex;"><span>        row.forEach((value, lonIndex) =&gt; {
</span></span><span style="display:flex;"><span>            if (value === undefined) { return }
</span></span><span style="display:flex;"><span>            const amount = (value - ascData.min) / range
</span></span><span style="display:flex;"><span>            const material = new Three.MeshBasicMaterial()
</span></span><span style="display:flex;"><span>            const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
</span></span><span style="display:flex;"><span>            const saturation = 1
</span></span><span style="display:flex;"><span>            const lightness = Three.MathUtils.lerp(0.1, 1, amount)
</span></span><span style="display:flex;"><span>            material.color.setHSL(hue, saturation, lightness)
</span></span><span style="display:flex;"><span>            const mesh = new Three.Mesh(geometry, material)
</span></span><span style="display:flex;"><span>            scene.add(mesh)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
</span></span><span style="display:flex;"><span>            latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            positionHelper.updateWorldMatrix(true, false)
</span></span><span style="display:flex;"><span>            mesh.applyMatrix4(positionHelper.matrixWorld)
</span></span><span style="display:flex;"><span>            mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>上面代码中牵扯到了非常多新的、之前从未使用过的一些函数或属性。</p>
</blockquote>
<p><strong>解释说明：</strong></p>
<ol>
<li>
<p>栅格化数据 和 纹理图片 均可看作是 2D 矩形坐标，最终需要转化为 3D 球体坐标，转化过程中 lonFudge、latFudge 具体作用机理，暂时还没搞明白。</p>
<blockquote>
<p>先记住转化公式，以后再慢慢研究</p>
</blockquote>
<blockquote>
<p>栅格化数据 为 360 <em>145、纹理图片为 2048</em> 1024</p>
</blockquote>
</li>
<li>
<p>Three.Matrix4：WebGL 中的矩阵库</p>
</li>
<li>
<p>Three.MathUtils：Three.js 中内置的一些计算函数</p>
<blockquote>
<p>关于这些新的对象具体详细介绍，请查阅 Three.js 官方文档</p>
</blockquote>
</li>
<li>
<p>lonHelper用于赤道上的经度旋转、latHelper用于维度旋转、positionHelper用于 Z 轴(地球地面)上的偏移。</p>
</li>
<li>
<p>lonFudge 的值为 Math.PI * 0.5，也就是相当于 1/4 个圆(地球 1/4 圈)</p>
</li>
<li>
<p>latFudge 的值为 Math.PI * -0.135，这里的 -0.135 不太清楚是怎么得出来的，但是大概率推测它是用来将柱状物与纹理图片对齐的</p>
</li>
</ol>
<p><strong>示例所需其他代码块：</strong></p>
<ol>
<li>创建 3D 地球、以及加载纹理图片</li>
<li>添加 OrbitControls 控制，并且开启 “弹性结束控制”</li>
<li>添加场景渲染函数 render，并且添加 “按需渲染” 相关代码</li>
</ol>
<p><strong>最终完整的示例代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>import { useEffect, useRef } from &#39;react&#39;
</span></span><span style="display:flex;"><span>import * as Three from &#39;three&#39;
</span></span><span style="display:flex;"><span>import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>import &#39;./index.scss&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const loadDataFile = async (url: string) =&gt; {
</span></span><span style="display:flex;"><span>    const res = await window.fetch(url)
</span></span><span style="display:flex;"><span>    const text = await res.text()
</span></span><span style="display:flex;"><span>    return text
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>type DataType = (number | undefined)[][]
</span></span><span style="display:flex;"><span>type ASCData = {
</span></span><span style="display:flex;"><span>    data: DataType,
</span></span><span style="display:flex;"><span>    ncols: number,
</span></span><span style="display:flex;"><span>    nrows: number,
</span></span><span style="display:flex;"><span>    xllcorner: number,
</span></span><span style="display:flex;"><span>    yllcorner: number,
</span></span><span style="display:flex;"><span>    cellsize: number,
</span></span><span style="display:flex;"><span>    NODATA_value: number,
</span></span><span style="display:flex;"><span>    max: number,
</span></span><span style="display:flex;"><span>    min: number,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const parseData = (text: string) =&gt; {
</span></span><span style="display:flex;"><span>    const data: DataType = []
</span></span><span style="display:flex;"><span>    const settings: { [key: string]: any } = { data }
</span></span><span style="display:flex;"><span>    let max: number = 0
</span></span><span style="display:flex;"><span>    let min: number = 99999
</span></span><span style="display:flex;"><span>    text.split(&#39;\n&#39;).forEach((line) =&gt; {
</span></span><span style="display:flex;"><span>        const parts = line.trim().split(/\s+/)
</span></span><span style="display:flex;"><span>        if (parts.length === 2) {
</span></span><span style="display:flex;"><span>            settings[parts[0]] = parseFloat(parts[1])
</span></span><span style="display:flex;"><span>        } else if (parts.length &gt; 2) {
</span></span><span style="display:flex;"><span>            const values = parts.map((item) =&gt; {
</span></span><span style="display:flex;"><span>                const value = parseFloat(item)
</span></span><span style="display:flex;"><span>                if (value === settings[&#39;NODATA_value&#39;]) {
</span></span><span style="display:flex;"><span>                    return undefined
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                max = Math.max(max, value)
</span></span><span style="display:flex;"><span>                min = Math.min(min, value)
</span></span><span style="display:flex;"><span>                return value
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>            data.push(values)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    return { ...settings, ...{ max, min } } as ASCData
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>// const hsl = (h: number, s: number, l: number) =&gt; {
</span></span><span style="display:flex;"><span>//     return `hsl(${h * 360 | 0},${s * 100 | 0}%,${l * 100 | 0}%)`
</span></span><span style="display:flex;"><span>// }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>let renderRequested = false
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const HelloEarth = () =&gt; {
</span></span><span style="display:flex;"><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // const drawData = (ascData: ASCData) =&gt; {
</span></span><span style="display:flex;"><span>    //     if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>    //     const ctx = canvasRef.current.getContext(&#39;2d&#39;)
</span></span><span style="display:flex;"><span>    //     if (ctx === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    //     const range = ascData.max - ascData.min
</span></span><span style="display:flex;"><span>    //     ctx.canvas.width = ascData.ncols
</span></span><span style="display:flex;"><span>    //     ctx.canvas.height = ascData.nrows
</span></span><span style="display:flex;"><span>    //     ctx.fillStyle = &#39;#444&#39;
</span></span><span style="display:flex;"><span>    //     ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height)
</span></span><span style="display:flex;"><span>    //     ascData.data.forEach((row, rowIndex) =&gt; {
</span></span><span style="display:flex;"><span>    //         row.forEach((value, colIndex) =&gt; {
</span></span><span style="display:flex;"><span>    //             if (value === undefined) { return }
</span></span><span style="display:flex;"><span>    //             const amount = (value - ascData.min) / range
</span></span><span style="display:flex;"><span>    //             const hue = 1
</span></span><span style="display:flex;"><span>    //             const saturation = 1
</span></span><span style="display:flex;"><span>    //             const lightness = amount
</span></span><span style="display:flex;"><span>    //             ctx.fillStyle = hsl(hue, saturation, lightness)
</span></span><span style="display:flex;"><span>    //             ctx.fillRect(colIndex, rowIndex, 1, 1)
</span></span><span style="display:flex;"><span>    //         })
</span></span><span style="display:flex;"><span>    //     })
</span></span><span style="display:flex;"><span>    // }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const addBoxes = (ascData: ASCData, scene: Three.Scene) =&gt; {
</span></span><span style="display:flex;"><span>        const geometry = new Three.BoxBufferGeometry(1, 1, 1)
</span></span><span style="display:flex;"><span>        geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const lonHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>        scene.add(lonHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const latHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>        lonHelper.add(latHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const positionHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>        positionHelper.position.z = 1
</span></span><span style="display:flex;"><span>        latHelper.add(positionHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const range = ascData.max - ascData.min
</span></span><span style="display:flex;"><span>        const lonFudge = Math.PI * 0.5
</span></span><span style="display:flex;"><span>        const latFudge = Math.PI * -0.135
</span></span><span style="display:flex;"><span>        ascData.data.forEach((row, latIndex) =&gt; {
</span></span><span style="display:flex;"><span>            row.forEach((value, lonIndex) =&gt; {
</span></span><span style="display:flex;"><span>                if (value === undefined) { return }
</span></span><span style="display:flex;"><span>                const amount = (value - ascData.min) / range
</span></span><span style="display:flex;"><span>                const material = new Three.MeshBasicMaterial()
</span></span><span style="display:flex;"><span>                const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
</span></span><span style="display:flex;"><span>                const saturation = 1
</span></span><span style="display:flex;"><span>                const lightness = Three.MathUtils.lerp(0.1, 1, amount)
</span></span><span style="display:flex;"><span>                material.color.setHSL(hue, saturation, lightness)
</span></span><span style="display:flex;"><span>                const mesh = new Three.Mesh(geometry, material)
</span></span><span style="display:flex;"><span>                scene.add(mesh)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
</span></span><span style="display:flex;"><span>                latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                positionHelper.updateWorldMatrix(true, false)
</span></span><span style="display:flex;"><span>                mesh.applyMatrix4(positionHelper.matrixWorld)
</span></span><span style="display:flex;"><span>                mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    useEffect(() =&gt; {
</span></span><span style="display:flex;"><span>        if (canvasRef.current === null) { return }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const canvas = canvasRef.current
</span></span><span style="display:flex;"><span>        const renderer = new Three.WebGLRenderer({ canvas })
</span></span><span style="display:flex;"><span>        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
</span></span><span style="display:flex;"><span>        camera.position.z = 4
</span></span><span style="display:flex;"><span>        const scene = new Three.Scene()
</span></span><span style="display:flex;"><span>        scene.background= new Three.Color(0x000000)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const controls = new OrbitControls(camera, canvas)
</span></span><span style="display:flex;"><span>        controls.enableDamping = true
</span></span><span style="display:flex;"><span>        controls.enablePan =false
</span></span><span style="display:flex;"><span>        controls.update()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const render = () =&gt; {
</span></span><span style="display:flex;"><span>            renderRequested = false
</span></span><span style="display:flex;"><span>            controls.update()
</span></span><span style="display:flex;"><span>            renderer.render(scene, camera)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const handleChange =() =&gt;{
</span></span><span style="display:flex;"><span>            if(renderRequested === false){
</span></span><span style="display:flex;"><span>                renderRequested = true
</span></span><span style="display:flex;"><span>                window.requestAnimationFrame(render)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        controls.addEventListener(&#39;change&#39;,handleChange)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const loader = new Three.TextureLoader()
</span></span><span style="display:flex;"><span>        const texture = loader.load(require(&#39;@/assets/imgs/world.jpg&#39;).default, render)
</span></span><span style="display:flex;"><span>        const material = new Three.MeshBasicMaterial({
</span></span><span style="display:flex;"><span>            map: texture
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>        const geometry = new Three.SphereBufferGeometry(1, 64, 32)
</span></span><span style="display:flex;"><span>        const earth = new Three.Mesh(geometry, material)
</span></span><span style="display:flex;"><span>        scene.add(earth)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const handleResize = () =&gt; {
</span></span><span style="display:flex;"><span>            const width = canvas.clientWidth
</span></span><span style="display:flex;"><span>            const height = canvas.clientHeight
</span></span><span style="display:flex;"><span>            camera.aspect = width / height
</span></span><span style="display:flex;"><span>            camera.updateProjectionMatrix()
</span></span><span style="display:flex;"><span>            renderer.setSize(width, height, false)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            window.requestAnimationFrame(render)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        handleResize()
</span></span><span style="display:flex;"><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        const ascURL = require(&#39;@/assets/data/gpw_v4_014mt_2010.asc&#39;).default
</span></span><span style="display:flex;"><span>        const doSomthing = async () =&gt; {
</span></span><span style="display:flex;"><span>            try {
</span></span><span style="display:flex;"><span>                const text = await loadDataFile(ascURL)
</span></span><span style="display:flex;"><span>                const ascData = parseData(text)
</span></span><span style="display:flex;"><span>                //drawData(ascData)
</span></span><span style="display:flex;"><span>                addBoxes(ascData, scene)
</span></span><span style="display:flex;"><span>                render()
</span></span><span style="display:flex;"><span>            } catch (error) {
</span></span><span style="display:flex;"><span>                console.log(error)
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        doSomthing()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return () =&gt; {
</span></span><span style="display:flex;"><span>            controls.removeEventListener(&#39;change&#39;,handleChange)
</span></span><span style="display:flex;"><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }, [canvasRef])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return (
</span></span><span style="display:flex;"><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style="display:flex;"><span>    )
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>export default HelloEarth
</span></span></code></pre></div><p>调试运行，首先就会看到一个 3D 立体地球，等待 1 秒左右，待 .asc 数据加载并解析、添加地球上的柱状物后，就会看到本示例所想演示的最终效果。</p>
<blockquote>
<p>终于终于到这一步了</p>
</blockquote>
<p>不过当你鼠标拖动地球时，会感受到略微卡顿，或者说不够流畅。</p>
<p>那么接下来，就到了本文的核心内容：通过 合并对象 来达到优化场景的目的。</p>
<h4 id="补充启用浏览器-调试工具-devtool-的-rendering-查看渲染性能">补充：启用浏览器 调试工具 DevTool 的 Rendering 查看渲染性能<a hidden class="anchor" aria-hidden="true" href="#补充启用浏览器-调试工具-devtool-的-rendering-查看渲染性能">#</a></h4>
<p>除了浏览器本身的 性能(Performance) 面板外，还有另外一个重要的、方便我们查看页面渲染性能的工具——Rendering。</p>
<p><strong>通过谷歌调试工具 Rendering，查看当前页面渲染性能情况：</strong></p>
<ol>
<li>
<p>打开浏览器调试工具 DevTool</p>
</li>
<li>
<p>点击右侧 3 个小圆点</p>
</li>
<li>
<p>鼠标移动到 More tools</p>
</li>
<li>
<p>点击 Rendering</p>
</li>
<li>
<p>在新出现的 Rendering 面板中，勾选 Frame Rendering Stats</p>
<blockquote>
<p>备注：在旧的谷歌浏览器中，应该勾选的是 Show FPS meter</p>
</blockquote>
</li>
</ol>
<p>这样就可以在网页左上角，实时看到当前渲染性能状况。</p>
<p><strong>性能数据解读：</strong></p>
<p>性能展示的数据，主要 2 个模块：Frames 和 GPU</p>
<p><strong>GPU 相关：</strong></p>
<ol>
<li>
<p>GPU raster ：on  表示 GPU 光栅化已开启</p>
</li>
<li>
<p>GPU memory：GPU 已用大小、GPU 最大可用大小</p>
<blockquote>
<p>在本示例中，通常是当修改浏览器尺寸时，此时需要大量计算，会显示出 GPU memory</p>
<p>在普通的 鼠标拖拽 改变地球视角时，不会显示 GPU memory</p>
</blockquote>
</li>
</ol>
<p><strong>Frames相关：</strong></p>
<p>假设某一时刻，渲染性能结果为 Frames：63% 1082(0m) dropped of 2737</p>
<p>对应的解读为：</p>
<p>第1个数字 63% —— 63% 的帧按时渲染完成</p>
<p>第2个数字 1082 —— 有 1082 个合成帧丢失(未渲染)</p>
<p>第3个数字 0m —— 有 0 个帧丢失</p>
<p>第4个数字 2737 —— 原本计划渲染 2737 个帧</p>
<p>数字之间的计算关系为 63% ≈ 1 - (1082 + 0 )/ 2737</p>
<p>也就是说 第2个数字(丢失的合成帧)越小，那么整体按时完成渲染帧的百分比(第1个数字)越大，意味着此刻网页越流畅。</p>
<h2 id="优化代码合并对象">优化代码：合并对象<a hidden class="anchor" aria-hidden="true" href="#优化代码合并对象">#</a></h2>
<h4 id="核心代码分析">核心代码分析<a hidden class="anchor" aria-hidden="true" href="#核心代码分析">#</a></h4>
<p>在上面的示例代码中，lonHelper用于赤道上的经度旋转、latHelper用于维度旋转、positionHelper用于 Z 轴(地球地面)上的偏移。</p>
<blockquote>
<p>默认 Three.js 中物体是有 1/2 位于 Z 轴之下的，通过Z轴的偏移让柱状物可以完全出现在地面上</p>
</blockquote>
<p>每一个数据点(柱状物)都创建了一个 MeshBasicMaterial 和 Mesh。</p>
<p>我们的数据点一共为 145行、360列，那么就意味着假设全部数据点都有数据，那么数据点总数量为：145 * 360 = 52200，但是考虑到有非常多的数据点的值为 -9999(NODATA_value)，也就是没有值，不需要绘制，那么减去这些没有数据点，<strong>最终需要绘制的数据点(柱状物)大约为 19000 个</strong>。</p>
<p><strong>柱状物19000个，再加上对应的 3 个辅助对象(lonHelper、latHelper、positionHelper)，相当于总绘制数量为 19000 * 4 = 76000。</strong></p>
<p>也就是说每一次场景更新，大约需要绘制 7.6 万个对象，所以这才造成了卡顿现象。</p>
<p><strong>如何解决卡顿？减少需要渲染对象的数量！</strong></p>
<p>还记得我们刚才统计的渲染对象数量吗？</p>
<ol>
<li>柱状体 约 19000个</li>
<li>每个柱状体对应 3 个辅助对象 19000 * 3</li>
</ol>
<p>我们需要做的就是把所有的柱状体合并成一个物体，也就是说原本需要渲染 19000 个柱状体，合并之后只需渲染 1 个，让柱状体数量减少 18999 个。</p>
<p><strong>修改 addBoxes 函数代码：</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>import { BufferGeometryUtils } from &#39;three/examples/jsm/utils/BufferGeometryUtils&#39;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>const addBoxes = (ascData: ASCData, scene: Three.Scene) =&gt; {
</span></span><span style="display:flex;"><span>    //const geometry = new Three.BoxBufferGeometry(1, 1, 1)
</span></span><span style="display:flex;"><span>    //geometry.applyMatrix4(new Three.Matrix4().makeTranslation(0, 0, 0.5))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const lonHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>    scene.add(lonHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const latHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>    lonHelper.add(latHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const positionHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>    positionHelper.position.z = 1
</span></span><span style="display:flex;"><span>    latHelper.add(positionHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const originHelper = new Three.Object3D()
</span></span><span style="display:flex;"><span>    originHelper.position.z = 0.5
</span></span><span style="display:flex;"><span>    positionHelper.add(originHelper)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    const range = ascData.max - ascData.min
</span></span><span style="display:flex;"><span>    const lonFudge = Math.PI * 0.5
</span></span><span style="display:flex;"><span>    const latFudge = Math.PI * -0.135
</span></span><span style="display:flex;"><span>    const geometries: Three.BoxBufferGeometry[] = []
</span></span><span style="display:flex;"><span>    const color = new Three.Color()
</span></span><span style="display:flex;"><span>    ascData.data.forEach((row, latIndex) =&gt; {
</span></span><span style="display:flex;"><span>        row.forEach((value, lonIndex) =&gt; {
</span></span><span style="display:flex;"><span>            if (value === undefined) { return }
</span></span><span style="display:flex;"><span>            const amount = (value - ascData.min) / range
</span></span><span style="display:flex;"><span>            //const material = new Three.MeshBasicMaterial()
</span></span><span style="display:flex;"><span>            //const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
</span></span><span style="display:flex;"><span>            //const saturation = 1
</span></span><span style="display:flex;"><span>            //const lightness = Three.MathUtils.lerp(0.1, 1, amount)
</span></span><span style="display:flex;"><span>            //material.color.setHSL(hue, saturation, lightness)
</span></span><span style="display:flex;"><span>            //const mesh = new Three.Mesh(geometry, material)
</span></span><span style="display:flex;"><span>            //scene.add(mesh)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            const geometry = new Three.BoxBufferGeometry(1, 1, 1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            lonHelper.rotation.y = Three.MathUtils.degToRad(lonIndex + ascData.xllcorner) + lonFudge
</span></span><span style="display:flex;"><span>            latHelper.rotation.x = Three.MathUtils.degToRad(latIndex + ascData.yllcorner) + latFudge
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //positionHelper.updateWorldMatrix(true, false)
</span></span><span style="display:flex;"><span>            //mesh.applyMatrix4(positionHelper.matrixWorld)
</span></span><span style="display:flex;"><span>            //mesh.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.001, 0.5, amount))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            positionHelper.scale.set(0.005, 0.005, Three.MathUtils.lerp(0.01, 0.5, amount))
</span></span><span style="display:flex;"><span>            originHelper.updateWorldMatrix(true, false)
</span></span><span style="display:flex;"><span>            geometry.applyMatrix4(originHelper.matrixWorld)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            const hue = Three.MathUtils.lerp(0.7, 0.3, amount)
</span></span><span style="display:flex;"><span>            const saturation = 1
</span></span><span style="display:flex;"><span>            const lightness = Three.MathUtils.lerp(0.1, 1, amount)
</span></span><span style="display:flex;"><span>            color.setHSL(hue, saturation, lightness)
</span></span><span style="display:flex;"><span>            const rgb = color.toArray().map((value) =&gt; {
</span></span><span style="display:flex;"><span>                return value * 255
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            const numVerts = geometry.getAttribute(&#39;position&#39;).count
</span></span><span style="display:flex;"><span>            const itemSize = 3
</span></span><span style="display:flex;"><span>            const colors = new Uint8Array(itemSize * numVerts)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            //这里有一个稍微奇葩点的写法，就是使用下划线 _ 来起到参数占位的作用
</span></span><span style="display:flex;"><span>            colors.forEach((_, index) =&gt; {
</span></span><span style="display:flex;"><span>                colors[index] = rgb[index % 3]
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            const normalized = true
</span></span><span style="display:flex;"><span>            const colorAttrib = new Three.BufferAttribute(colors, itemSize, normalized)
</span></span><span style="display:flex;"><span>            geometry.setAttribute(&#39;color&#39;, colorAttrib)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            geometries.push(geometry)
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    const mergedGeometry = BufferGeometryUtils.mergeBufferGeometries(geometries)
</span></span><span style="display:flex;"><span>    //const material = new Three.MeshBasicMaterial({ color: &#39;red&#39; })
</span></span><span style="display:flex;"><span>    const material = new Three.MeshBasicMaterial({
</span></span><span style="display:flex;"><span>        vertexColors: true
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>    const mesh = new Three.Mesh(mergedGeometry, material)
</span></span><span style="display:flex;"><span>    scene.add(mesh)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><blockquote>
<p>上述代码中，注释部分为之前 addBoxes() 函数的代码，除了 //const material = new Three.MeshBasicMaterial({ color: &lsquo;red&rsquo; }) 这一行</p>
</blockquote>
<p><strong>代码解析：</strong></p>
<ol>
<li>
<p>合并所有的柱状物，使用到了一个新的函数 BufferGeometryUtils.mergeBufferGeometries()</p>
<blockquote>
<p>注意：BufferGeometryUtils 并非来自 Three，而是来自 &rsquo;three/examples/jsm/utils/BufferGeometryUtils&rsquo;</p>
</blockquote>
</li>
<li>
<p>柱状物的颜色，不再使用 color 设定，而是启用了 “顶点着色”。</p>
</li>
</ol>
<blockquote>
<p>关于这 2 个大的知识点，可以去阅读 Three.js 官方文档</p>
</blockquote>
<blockquote>
<p>需要恶补官方文档，如果只是看了本教程，那么还会有大量的知识点未曾接触。</p>
</blockquote>
<p>经过合并优化后的场景，在浏览器中运行，比之前的流畅非常多，没有卡顿的现象了。</p>
<blockquote>
<p>我本机电脑硬件配置比较高，我分别记录了 Rendering 面板中 优化前后的 Frames 值。</p>
<p>优化前：顺利渲染帧的百分比约为 60%</p>
<p>优化后：顺利渲染帧的百分比约为 90%</p>
<p>可见网页流畅度确实提高了很多</p>
</blockquote>
<h4 id="本文小结">本文小结<a hidden class="anchor" aria-hidden="true" href="#本文小结">#</a></h4>
<p><strong>在 Three.js 大型的场景中，绝大多数都需要采用合并对象的策略来优化渲染性能。</strong></p>
<p>合并对象可以减少需要渲染的对象数量，并且还可以将有一些根本不可见的面进行删除，减少渲染面，提高渲染性能。</p>
<p>你以为就这样可以结束了？</p>
<p>事实上还有优化空间，本文先到这里结束。</p>
<p>下一篇将继续优化这个场景。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://bablvsj.github.io/tags/three.js/">Three.js</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://bablvsj.github.io/posts/threejs/19-three.js%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/">
    <span class="title">« Prev</span>
    <br>
    <span>19 Three.js技巧之画布</span>
  </a>
  <a class="next" href="https://bablvsj.github.io/posts/threejs/21-three.js%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%A8%E7%94%BB/">
    <span class="title">Next »</span>
    <br>
    <span>21 Three.js优化之合并对象的动画</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://bablvsj.github.io">Bablvsj&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <div class="flex-c-d">
        <a class="flex-d-c" href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral"
            target="_blank"> <span>本站由</span><img width="60" src="/images/upyun.png">提供CDN加速/云存储服务</a>
    </div>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script></body>

</html>
