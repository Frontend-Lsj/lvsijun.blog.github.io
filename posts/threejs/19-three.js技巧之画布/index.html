<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>19 Three.js技巧之画布 | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="19 Three.js技巧之画布 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/19-three.js%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/><link crossorigin=anonymous href=/assets/css/stylesheet.241265d51339977eb0f90d05780e286ec2789600ca4137f29552dec9dee06569.css integrity="sha256-JBJl1RM5l36w+Q0FeA4obsJ4lgDKQTfylVLeyd7gZWk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="19 Three.js技巧之画布"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/19-three.js%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="19 Three.js技巧之画布"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"19 Three.js技巧之画布","item":"https://bablvsj.github.io/posts/threejs/19-three.js%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"19 Three.js技巧之画布","name":"19 Three.js技巧之画布","description":"","keywords":["Three.js"],"articleBody":"本文讲解一下 画布 Canvas 的一些实用技巧。\n创建画布截屏(快照)，并保存图片到本地 设置不清除画布内容 获取键盘事件 设置画布透明度 设置画布为背景 示例基本代码：HelloCanvas 先制作一个简单的、带动画的Three.js场景 为了演示各个功能，我们先创建一个基础的 Three.js 动画场景：场景上有 3 个不同颜色、不停旋转的立方体。\n这个场景在之前多个示例中已经创建过多次，但是这次和之前的略微不同。\n**不同点1：**由于本文是讲解 canvas 的，本身和 Three.js 没太大的关联，所以这次我们会创建一个 useCreateScene 的自定义 hook，用来专门创建 3D 场景，这样我们的 index.tsx 代码可以更加简洁。\n所谓 自定义 react hook，本质上就是包含有 hook 的普通函数\n**不同点2：**由于讲解过程中需要用到一些按钮，所以我们这次将引入 react-dat-gui 这个组件，来添加一些示例相关按钮。\n关于如何使用 react-dat-gui 这个，请参考我写的 React中使用GUI.md 这篇教程。\n请务必学习一下 react-dat-gui 这个组件，在后续示例中我们会经常使用这个组件来作为调试面板。\n具体的代码 我们创建一个专门存放本示例的目录 src/components/hello-canvas/\nuse-create-scene.ts：\nimport { useEffect } from 'react' import * as Three from 'three' import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' const useCreateScene = (canvasRef: React.RefObject) =\u003e { useEffect(() =\u003e { if (canvasRef.current === null) { return } const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current }) const scene = new Three.Scene() scene.background = new Three.Color(0x222222) const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100) camera.position.set(0, 5, 10) const light = new Three.DirectionalLight(0xFFFFFF, 1) light.position.set(5, 10, 0) scene.add(light) const controls = new OrbitControls(camera, canvasRef.current) controls.update() const colors = ['blue', 'red', 'green'] const cubes: Three.Mesh[] = [] colors.forEach((color, index) =\u003e { const mat = new Three.MeshPhongMaterial({ color }) const geo = new Three.BoxBufferGeometry(2, 2, 2) const mesh = new Three.Mesh(geo, mat) mesh.position.x = (index - 1) * 4 scene.add(mesh) cubes.push(mesh) }) const render = (time: number) =\u003e { time *= 0.001 cubes.forEach((cube) =\u003e { cube.rotation.x = cube.rotation.y = time }) renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) const handleResize = () =\u003e { if (canvasRef.current === null) { return } const width = canvasRef.current.clientWidth const height = canvasRef.current.clientHeight camera.aspect = width / height camera.updateProjectionMatrix() renderer.setSize(width, height, false) } handleResize() window.addEventListener('resize', handleResize) return () =\u003e { window.removeEventListener('resize', handleResize) } }, [canvasRef]) } export default useCreateScene index.scss：\n.full-screen, canvas { display: block; height: inherit; width: inherit; } .dat-gui { top: 16px !important; font-size: 18px !important; } index.tsx：\nimport { useRef, useState } from 'react' import DatGUI, { DatButton } from 'react-dat-gui' import useCreateScene from './use-create-scene' import './index.scss' import 'react-dat-gui/dist/index.css' const HelloCanvas = () =\u003e { const canvasRef = useRef(null) const [date, setDate] = useState({}) useCreateScene(canvasRef) const handleGUIUpdate = (newDate: any) =\u003e { setDate(newDate) } const handleSaveClick = () =\u003e { //编写点击之后的代码 } return ( ) } export default HelloCanvas 补充说明：\n所有创建 3D 场景的代码都转移到了 use-create-scene.ts 中，index.tsx 的代码终于看上去非常简洁了。\n我们使用了 标签，但是由于我们本身只使用 按钮()，并未用到任何其他变量，所以\n这行属性配置只是为了不让 DatGUI 报缺省错误，并无其他作用。\nDatGUI 的 date、onUpdate 为必填属性\n至此，本示例所用到的基础场景代码已搭建好，接下来开始讲解 canvas 的使用技巧。\n创建画布截屏(快照)，并保存图片到本地 先说一下如何创建画布截屏(快照) 对于 HTML5 中的 canvas 来说，创建画布截屏(快照)有 2 种方式：canvas.toDataURL()、canvas.toBolb()\n所谓截屏和快照，更加准确的说法应该是：获取画布当前图片的内容\n第1种：canvas.toDataURL() canvas.toDataURL() 可以创建一个临时的图片地址，该图片地址可以作为当前页面中的 标签中的 src 属性值。或者可以创建一个下载链接，点击下载这个图片。\ntoDataURL()用法：\ncanvas.toDataURL(type?: string, quality?: any): string; type：图片格式类型，值只能是 “image/png” 或 “image/jpeg”\n除了上面 2 个固定值，若你填写其他值则不启作用也不报错，最终会使用 “image/png” 来作为默认值\n对于 谷歌浏览器 Chrome ，还额外支持一个类型 “image/webp”\nquality：jpeg 图片的压缩质量，取值范围 0 - 1，默认值为 0.92\nquality 的值越大，图片清晰度越高，文件体积越大\n如果 quality 的值不在 0-1 范围内，则会使用默认值 0.92\n创建 PNG 图片：\nconst imgurl = canvas.toDataURL('image/png') console.log(imgurl) //输出以下内容 data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAEUCAYAAADK... 创建 JPEG 图片：\nconst imgurl = canvas.toDataURL('image/jpeg',quality) console.log(imgurl) //输出以下内容 data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQY... 请注意上面输出内容中，均包含了 ”base64“，这种格式的图片，是可以自动下载的\n关于图片自动下载保存到本地我们会稍后讲解\n第2种：canvas.toBlob() canvas.toBlob() 可以创建 Blob 对象，该对象包含图片的数据内容。\n注意：canvas.toDataURL() 是获得一个临时的图片地址，而 canvas.toBlob() 是获得图片数据内容。\ncanvas.toBlob()用法：\ntoBlob(callback: BlobCallback, type?: string, quality?: any): void; callback：获得 Blob 对象的回调函数\n通常为：canvas.toBlob( (blob: Blob|null) =\u003e {} )\ntype：图片的格式类型，默认值为 “image/png”\nquality：若图片格式类型为 “image/jpeg”，quality 表示 JPEG 的压缩质量\ntype 的取值和默认值、quality 的取值范围和默认值 与 canvas.toDataURL() 完全相同\n使用示例：\ncanvas.toBlob((blob) =\u003e { console.log(blob) }) 或 canvas.toBlob((blob) =\u003e { console.log(blob) }, 'image/jpeg', 0.8) 注意：不同于 canvas.toDataURL()，canvas.toBlob() 这个函数是没有返回值的\n另外，假设使用 jpeg 压缩质量为 0.8，文件体积有可能只有 png 格式的 1/3 。\n补充说明 关于分辨率：\n按照 MDN 文档，无论哪种方式保存的图片分辨率都是 96，但是我在 PC 机上试验，将下载的图片保存到本地，并在 PhotoShop 软件中查看，发现图片分辨率依然是 72。\n我怀疑 保存图片的分辨率其实是和 当前系统一致的。假设在手机上，有可能图片分辨率就是 96 了。\n稍后我会在手机上验证一下 图片分辨率 这个问题。\n最后，建议你去 MDN 上看 canvas 保存图片 的相关讲解作为本小节的补充。\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas\n再说一下如何自动将图片下载到本地 图片自动下载到本地的思路：在JS中创建一个 a 链接，并且模拟出 a 点击事件\n使用toDataURL()函数：\nconst canvas = canvasRef.current const imgurl = canvas.toDataURL('image/jpeg', 0.8) const a = document.createElement('a') a.href = imgurl a.download = 'myimg.jpeg' a.click() 注意：我原本以为还需要将 a 标签插入到网页 body 中才可以实现自动下载，但是经过试验发现根本不需要这样，以下为我原本写的代码：\nconst a = document.createElement('a') document.body.appendChild(a) //根本无需此行代码 a.style.display = 'none' //由于不需要添加到 body 中，因此也无需此行代码 a.href = imgurl a.download = 'myimg.jpeg' a.click() document.body.removeChild(a) //根本无需此行代码 使用toBlob()函数：\nconst canvas = canvasRef.current canvas.toBlob((blob) =\u003e { const imgurl = window.URL.createObjectURL(blob) const a = document.createElement('a') a.href = imgurl a.download = 'myimg.jpeg' a.click() }, 'image/jpeg', 0.8) 小总结：\n若使用 canvas.toDataURL()，则可以直接将得到的图片临时地址 赋值给 a.href 若使用 canvas.toBlob()，则需要通过 window.URL.createObjectURL() 这个函数将 Blob 数据转化得到对应的地址，然后再赋值给 a.href 好了，关于如何获取画布图片数据、如何保持图片到本地讲解完毕，来实践吧。\n无论采用 canvas.toDataURL() 还是 canvas.toBlob() 都可以，本示例我们采用 toBlob() 。\n我们将 index.stx 的代码修改如下：\nimport { useRef, useState } from 'react' import DatGUI, { DatButton } from 'react-dat-gui' import useCreateScene from './use-create-scene' import './index.scss' import 'react-dat-gui/dist/index.css' const HelloCanvas = () =\u003e { const canvasRef = useRef(null) const [date, setDate] = useState({}) useCreateScene(canvasRef) const handleGUIUpdate = (newDate: any) =\u003e { setDate(newDate) } const handleSaveClick = () =\u003e { if (canvasRef.current === null) { return } const canvas = canvasRef.current //采用 toDataURL() 方式 // const imgurl = canvas.toDataURL('image/jpeg', 0.8) // const a = document.createElement('a') // a.href = imgurl // a.download = 'myimg.jpeg' //我们定义下载图片的文件名 // a.click() //采用 toBlob() 方式 canvas.toBlob((blob) =\u003e { const imgurl = window.URL.createObjectURL(blob) const a = document.createElement('a') a.href = imgurl a.download = 'myimg.jpeg' a.click() }, 'image/jpeg', 0.8) } return ( ) } export default HelloCanvas 实际运行，点击右上角的 按钮，就会给画布创建图片快照，并且自动下载到本地。\n然后你可以查看刚刚下载到本地的 myimg.jpeg 这个文件，打开它——你会发现？？？\n怎么图片啥内容都没有？纯色的？3 个立方体呢？\nwhat ？why ？\n呵，马上讲解为什么。\n问题出在了哪里？\n首先我们容易想到，在 use-create-scene.ts 的 render() 函数中，不停的运行着每一帧都进行画布重新渲染的代码，莫非是我们截图那一瞬间刚好画布还未渲染完成？\n好，我们先把那行代码删除掉，看是否就可以截图显示有内容了。\nconst render = (time: number) =\u003e { time *= 0.001 cubes.forEach((cube) =\u003e { cube.rotation.x = cube.rotation.y = time }) renderer.render(scene, camera) - window.requestAnimationFrame(render) } window.requestAnimationFrame(render) 再次运行，3 个立方体是静止状态，此时点击按钮保存截图。\n查看该图，竟然依然是空白，没有内容的。\n看来问题并不出在上面一行代码中，我们恢复刚才删除的 window.requestAnimationFrame(render)，再去想其他原因。\n真实的原因是：\n我们所谓的针对画布截屏 创建快照，实际上是获取 canvas 中的数据 但这个数据并不是针对 DOM 中已显示的 canvas，而是针对 canvas 对象中缓冲区的数据 关键在于当 canvas 渲染完成后(DOM中已显示出内容)，默认会清空 缓冲区中的数据 所以，这就是我们为什么去 “获取 canvas 图像数据时得到是空白内容” 的原因 canvas从计算到显示的过程：\ncanvas 根据相应的 JS 规则，开始创建、计算画布内容数据 canvas 将计算得到的画布内容数据填充到 canvas 缓冲区 当 canvas 画布内容计算完成，此时 canvas 缓冲区已有完整的画布内容数据后，将画布内容显示到 DOM 中 再说一遍：\n我们之前的示例中，渲染并显示 canvas 内容的函数 render 和 创建画布快照 的函数是相互独立的，这就造成了当我们去获取 canvas 缓冲区数据时，canvas 已经将画布内容显示到 DOM 中并且清空了缓冲区。\n解决办法：\n解决办法就是当我们要创建画布快照，获取 canvas 缓冲区内容之前，在同一个函数体内，额外调用一次 render 函数，确保此时 canvas 缓冲区内是有内容的。\n实际代码：\n第1：由于我们示例代码中，render 函数本身位于 useCreateScene 函数内部，因此我们需要创造一个 renderRef 的钩子(hook)，将 renderRef 对外 return 出去，以便 index.stx 中可以获取 render 函数的引用。\ntype RenderType = () =\u003e void ... const renderRef = useRef(null) ... renderRef.current = render ... return renderRef 第2：这样做引申出另外一个问题，就是我们的 render 函数其实是有参数 time 的：\nconst render = (time: number) =\u003e { time *= 0.001 cubes.forEach((cube) =\u003e { cube.rotation.x = cube.rotation.y = time }) renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) 而我们希望 index.tsx 中调用 render() 是不传参数 time 的。因为 index.tsx 中根本不存在 time 这个变量，所以我们需要对 渲染 进行适当的改造。\n我们将原本的 渲染函数 render() 拆分成 2 个函数：\n单纯负责渲染的 render 函数 负责修改物体属性从而产生动画的 animate 函数 const render = () =\u003e { renderer.render(scene, camera) } renderRef.current = render const animate = (time: number) =\u003e { time *= 0.001 cubes.forEach((cube) =\u003e { cube.rotation.x = cube.rotation.y = time }) render() //这样 render() 就是一个不需要参数的函数 window.requestAnimationFrame(animate) } window.requestAnimationFrame(animate) 经过这样改造后，完整的 use-create-screen.ts 代码如下：\nimport { useEffect, useRef } from 'react' import * as Three from 'three' import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' type RenderType = () =\u003e void const useCreateScene = (canvasRef: React.RefObject) =\u003e { const renderRef = useRef(null) useEffect(() =\u003e { if (canvasRef.current === null) { return } const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current }) const scene = new Three.Scene() scene.background = new Three.Color(0x222222) const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100) camera.position.set(0, 5, 10) const light = new Three.DirectionalLight(0xFFFFFF, 1) light.position.set(5, 10, 0) scene.add(light) const controls = new OrbitControls(camera, canvasRef.current) controls.update() const colors = ['blue', 'red', 'green'] const cubes: Three.Mesh[] = [] colors.forEach((color, index) =\u003e { const mat = new Three.MeshPhongMaterial({ color }) const geo = new Three.BoxBufferGeometry(2, 2, 2) const mesh = new Three.Mesh(geo, mat) mesh.position.x = (index - 1) * 4 scene.add(mesh) cubes.push(mesh) }) const render = () =\u003e { renderer.render(scene, camera) } renderRef.current = render const animate = (time: number) =\u003e { time *= 0.001 cubes.forEach((cube) =\u003e { cube.rotation.x = cube.rotation.y = time }) render() //这样 render() 就是一个不需要参数的函数 window.requestAnimationFrame(animate) } window.requestAnimationFrame(animate) const handleResize = () =\u003e { if (canvasRef.current === null) { return } const width = canvasRef.current.clientWidth const height = canvasRef.current.clientHeight camera.aspect = width / height camera.updateProjectionMatrix() renderer.setSize(width, height, false) } handleResize() window.addEventListener('resize', handleResize) return () =\u003e { window.removeEventListener('resize', handleResize) } }, [canvasRef]) return renderRef } export default useCreateScene index.tsx 完整代码如下：\nimport { useRef, useState } from 'react' import DatGUI, { DatButton } from 'react-dat-gui' import useCreateScene from './use-create-scene' import './index.scss' import 'react-dat-gui/dist/index.css' const HelloCanvas = () =\u003e { const canvasRef = useRef(null) const [date, setDate] = useState({}) const renderRef = useCreateScene(canvasRef) //获取自定义 hook 返回的 renderRef const handleGUIUpdate = (newDate: any) =\u003e { setDate(newDate) } const handleSaveClick = () =\u003e { if (canvasRef.current === null || renderRef.current === null) { return } const canvas = canvasRef.current renderRef.current() //此时调用 render()，进行一次渲染，确保 canvas 缓冲区有数据 //采用 toDataURL() 方式 // const imgurl = canvas.toDataURL('image/jpeg', 0.8) // const a = document.createElement('a') // a.href = imgurl // a.download = 'myimg.jpeg' //我们定义下载图片的文件名 // a.click() //采用 toBlob() 方式 canvas.toBlob((blob) =\u003e { const imgurl = window.URL.createObjectURL(blob) const a = document.createElement('a') a.href = imgurl a.download = 'myimg.jpeg' a.click() }, 'image/jpeg', 0.8) } return ( ) } export default HelloCanvas 调试运行，这次保存的画布快照图片，就不会再是空白，而是有具体内容了。\n设置不清除画布内容 上面刚讲到 HTML5 中的 Canvas 每次渲染都存在一个 数据缓冲区的概念，而 Three.js 的渲染器 WebGLRenderer 也同样存在 数据缓冲区 这个概念。\nWebGLRenderer 缓冲区内为每次渲染场景得到的画面数据，默认情况下每一次渲染都会清空(释放)上一次的渲染画面数据。\nCanvas 数据缓冲区每次清空 这个我们没有办法修改，只能调用渲染函数，重新渲染一次。\n但是 WebGLRenderer 的数据缓冲区却是可以通过设置让默认不清除的。\n所谓不清除上一次数据缓冲区的内容，本质上就是保留上一次渲染画面内容\n所谓不清除画布内容，本质上是让渲染器不清除之前的渲染内容\n设置 WebGLRenderer 保留数据缓冲区中的历史数据：\n我们只需要将 WebGLRender 的配置修改如下：\nconst renderer = new Three.WebGLRenderer({ canvas: canvasRef.current, preserveDrawingBuffer: true, alpha: true }) renderer.autoClearColor = false 经过以上的修改之后，每次渲染都会继续保留之前渲染历史画面。\n调试运行代码，你就能感受到和之前渲染的不一样效果了。\n但是，存在一个问题：当浏览器窗口尺寸改变后，由于执行了 renderer.setSize()，则此时 渲染器中过往的渲染内容将会被清空。\n渲染器中的渲染历史内容被清空后，画面就好像第一次刚开始那样，重新开始渲染。\n补充说明：当用户在手机上浏览时，手机从竖屏变为横屏时，也会触发重新绘制。\n真正的解决方案：离屏渲染\n例如使用 WebGLRenderTarget，具体请回顾我们之前讲解的内容：15 Three.js基础之离屏渲染.md\n补充一个示例：PreserveDrawingBuffer src/components/hello-canvas/preserve-drawing-buffer.tsx\n示例目标 创建一个由 6 个立方体，做相互缠绕运动的一个物体 创建一个正交镜头 OrthographicCamera 给 canvas 添加鼠标滑动监听、以及 手指滑动监听 当 鼠标或手指滑动画布时，更新 物体 在镜头中的位置 设置渲染器不清除历史画面 最终呈现出的效果：类似一个 画笔在画板上 画画 的效果。\nPreserveDrawingBuffer 代码：\nimport { useEffect, useRef } from 'react' import * as Three from 'three' import './index.scss' const state = { x: 0, y: 0, z: 0 } const PreserveDrawingBuffer = () =\u003e { const canvasRef = useRef(null) useEffect(() =\u003e { if (canvasRef.current === null) { return } const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current, preserveDrawingBuffer: true, alpha: true }) renderer.autoClearColor = false const camera = new Three.OrthographicCamera(-2, 2, 1, -1, -1, 1) const scene = new Three.Scene() scene.background = new Three.Color(0xFFFFFF) const light = new Three.DirectionalLight(0xFFFFFF, 1) light.position.set(-1, 2, 3) scene.add(light) const geometry = new Three.BoxBufferGeometry(1, 1, 1) const base = new Three.Object3D() scene.add(base) base.scale.set(0.1, 0.1, 0.1) const colors = ['#F00', '#FF0', '#0F0', '#0FF', '#00F', '#F0F'] const numArr = [-2, 2] //同一坐标轴上，对称 2 个立方体的坐标 colors.forEach((color, index) =\u003e { const material = new Three.MeshPhongMaterial({ color }) const cube = new Three.Mesh(geometry, material) const col = Math.floor(index / numArr.length) const row = index % numArr.length let result = [0, 0, 0] result[col] = numArr[row] cube.position.set(result[0], result[1], result[2]) base.add(cube) }) const temp = new Three.Vector3() const updatePosition = (x: number, y: number) =\u003e { if (canvasRef.current === null) { return } // const rect = canvasRef.current.getBoundingClientRect() // const newX = (x - rect.left) * canvasRef.current.width / rect.width // const newY = (y - rect.top) * canvasRef.current.height / rect.height // const resX = newX / canvasRef.current.width * 2 - 1 // const resY = newY / canvasRef.current.height * -2 + 1 const resX = x / canvasRef.current.width * 2 - 1 const resY = y / canvasRef.current.height * -2 + 1 temp.set(resX, resY, 0).unproject(camera) state.x = temp.x state.y = temp.y } const handleMouseMove = (eve: MouseEvent) =\u003e { updatePosition(eve.clientX, eve.clientY) } const handleTouchMove = (eve: TouchEvent) =\u003e { eve.preventDefault() const touche = eve.touches[0] updatePosition(touche.clientX, touche.clientY) } canvasRef.current.addEventListener('mousemove', handleMouseMove) canvasRef.current.addEventListener('touchmove', handleTouchMove, { passive: false }) const render = (time: number) =\u003e { time = time * 0.001 base.position.set(state.x, state.y, state.z) base.rotation.x = time base.rotation.y = time * 1.11 renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) const handleResize = () =\u003e { if (canvasRef.current === null) { return } const width = canvasRef.current.clientWidth const height = canvasRef.current.clientHeight camera.right = width / height camera.left = - camera.right camera.updateProjectionMatrix() renderer.setSize(width, height, false) } handleResize() window.addEventListener('resize', handleResize) return () =\u003e { window.removeEventListener('resize', handleResize) } }, [canvasRef]) return ( ) } export default PreserveDrawingBuffer 补充说明：\n上面这段代码略微复杂、陌生。因为这段代码中有几个地方是我们之前示例中从来未接触过的：\n使用的是正交镜头，而不是透视镜头\n当窗口尺寸发生变化时，更新正交镜头\n更新方式和我们之前习惯使用的 透视镜头(PerspectiveCamera) 大不同\n监听鼠标滑动、手指滑动事件\n更新 物体 在正交镜头中的 “投影位置”\n额外补充：\n上述代码中，6 个立方体 他们分别是：\n在 x 轴对称的 2 个立方体\n在示例中，对应的坐标分别为 (-2,0,0)、(2,0,0)\n在 y 轴对称的 2 个立方体\n在示例中，对应的坐标分别为 (0,-2,0)、(0,2,0)\n在 z 轴堆成的 2 个立方体\n在示例中，对应的坐标分别为 (0,0,-2)、(0,0,2)\n这 6 个立方体他们依次对应的坐标，没有提前写死，而是通过一段特殊的 forEach 循环来计算得出的。\n可以阅读下面这段通用的代码，帮助你理解 整个 forEach 循环是如何得到每个立方体坐标的。\n//遍历出 目标长度为N，特殊值为 [xx, xx, ...] 的 多维数组 const numArr = [-2, 2] //定义特殊位置上出现的数字 const arrLength = 3 //定义目标数组长度 const total = arrLength * numArr.length //根据目标数组长度以及特殊数字的个数，计算得出目标数组的总个数 for (let i = 0; i \u003c total; i++) { const col = Math.floor(i / numArr.length) //计算出特殊位置的索引 const row = i % numArr.length //计算出特殊位置上数字值对应的索引 let result = new Array(arrLength) //得到一个 长度为 arrLenght 的数组 result.fill(0) //将数组每一项填充为 0 result[col] = numArr[row] //修改特殊位置上的值 console.log(result) } 如果你对 useCreateScene 这个示例不太理解也没有关系，因为毕竟这个示例中出现了一些我们之前示例中从未用到的一些类，你可以先跳过这个示例，继续后面的学习。\n随着日后对于 正交镜头 的多次使用，终归会熟练并理解的。\n获取键盘事件 让 Canvas 获取键盘事件 必须同时满足以下 2 个条件后，canvas 才可以获得键盘事件。\ncanvas 当前获得焦点\n标签中必须添加 tabIndex属性，\n属性值是 -1、0、1 都无所谓，建议设置为 0\n补充说明：当 canvas 获得当前焦点后，会在四周出现一个蓝色边框，可以通过定义 css 样式来取消这个样式。\ncanvas:focus { outline: none; } 简单示例：\nimport { useEffect, useRef } from 'react' import './index.scss' const CanvasKeyboard = () =\u003e { const canvasRef = useRef(null) useEffect(() =\u003e { if (canvasRef.current === null) { return } canvasRef.current.focus() //自动获取焦点 const handleKeydown = (event: KeyboardEvent) =\u003e { console.log(event) } canvasRef.current.addEventListener('keydown', handleKeydown) return () =\u003e { if (canvasRef.current === null) { return } canvasRef.current.removeEventListener('keydown', handleKeydown) } }, [canvasRef]) return ( ) } export default CanvasKeyboard 让 OrbitControl 获取键盘事件 默认 OrbitControl 对象就包含键盘方向键侦听。\n键盘上的 上下左右 方向键 均可操控改变 镜头轨道视图。\n但是我们之前的代码中，经常是这样写的：\nconst controls = new OrbitControls(camera, canvasRef.current) 这样存在的问题是，当 canvas 失去焦点后，就无法再获得键盘事件。\n最简单的解决办法就是将代码修改为：\nconst controls = new OrbitControls(camera, document.body) 这样键盘事件就不容易丢失。\n设置画布透明度 设置画布透明度，你可能会疑惑，这有什么好讲的，直接通过 css 给 canvas 添加透明度样式即可：\ncanvas { opacity: 0.4; } 这样做肯定没有问题，但是这里说的 “设置画布透明度” 实际上是指 给不同物体设置透明度。\n例如我们之前示例中的立方体，那么所有的示例中立方体都不是半透明的。\n给材质设置透明度：\n需要给材质设置透明度\nconst mat = new Three.MeshPhongMaterial({ color, opacity: 0.4 }) 渲染器需要开启透明度渲染\nconst renderer = new Three.WebGLRenderer({ canvas: canvasRef.current, alpha:true, premultipliedAlpha:false }) alpha：canvas 是否包含透明度，默认为 false\npremultipliedAlpha：renderer 是否假设颜色有 premultiplied alpha (预乘alpha)，默认为 true\n针对 预乘Alpha 的补充说明：\npremultiplied alpha：颜色值 预乘 alpha\n这是传统 3D 绘制中的一个重要概念，你可以简单理解成如下：\n假设我们要表示一个 透明度为 60% 的纯红色，采用 RGBA 的方式为 (255,0,0,0.6)，通过 预乘 alpha，我们可以得到透明度为 60% 的纯红色如果放置在纯白色底上，实际上最终呈现出来的颜色和 RGB ( 255,102,102) 是完全相同的。\n假设一个颜色使用 RGBA 来表示，透明度为 A、rgb 颜色为 C、纯白色(255,255,255)为 F，那么把 RGBA 转化为 RGB 的公式为：\nCA + ( 1-A ) F\n也就是说 rgba(255,0,0,0.6) 转化为对应的 rgb 过程为：\n(255,0,0)0.6 + (1-0.6) (255,255,255) = (255, 255 x 0.4, 255 x 0.4) = (255,102,102)\n暂时看不懂没有关系，只需记住若想让渲染器将物体渲染出半透明，除了物体本身材质配置透明度以外，还需要将渲染器中的 alpha 设置为 true 、premultipliedAlpha 设置为 false\n设置画布为背景 将 canvas 设置为网页背景，事实上也很简单，对应的样式：\ncanvas { position: fixed; top: 0; left: 0; z-index: -1; } 上述 CSS 样式就让 canvas 位置固定，且层级最低，这样就成为当前网页背景了。\n但是实际项目中，更加建议将 canvas 包含在一个 iframe 中后，再作为 网页的背景。\n这样做有几个理由：\n使用 iframe 后，可以将 canvas、Three.js 的相关代码独立出来 可以多个页面都引用这个 iframe iframe的相关示例：\nHello Three.js #background { position: fixed; width:100%; height:100%; left:0; top:0; z-index:-1; border:none; pointer-events:none; } 上述 css 样式中：\nposition: fixed; 可以让 iframe 位置固定 z-index: -1; 可以让 iframe 层级最低 border: none; 可以让 iframe 不显示边框 pointer-events: none; 让 iframe 永远不会成为鼠标事件的 target，意味着让 iframe 不接受鼠标交互事件 关于更多 canvas 的相关用法，建议阅读 MDN 上关于 canvas 的相关文档：\nhttps://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API\n至此，关于 Three.js 的一些常用技巧讲解完毕。\n接下来开始讲解 Three.js 的一些性能优化。\n","wordCount":"7202","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/19-three.js%E6%8A%80%E5%B7%A7%E4%B9%8B%E7%94%BB%E5%B8%83/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>19 Three.js技巧之画布</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>15 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e7%a4%ba%e4%be%8b%e5%9f%ba%e6%9c%ac%e4%bb%a3%e7%a0%81hellocanvas aria-label=示例基本代码：HelloCanvas>示例基本代码：HelloCanvas</a><ul><ul><li><a href=#%e5%85%88%e5%88%b6%e4%bd%9c%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e5%b8%a6%e5%8a%a8%e7%94%bb%e7%9a%84threejs%e5%9c%ba%e6%99%af aria-label=先制作一个简单的、带动画的Three.js场景>先制作一个简单的、带动画的Three.js场景</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=具体的代码>具体的代码</a></li></ul></ul></li><li><a href=#%e5%88%9b%e5%bb%ba%e7%94%bb%e5%b8%83%e6%88%aa%e5%b1%8f%e5%bf%ab%e7%85%a7%e5%b9%b6%e4%bf%9d%e5%ad%98%e5%9b%be%e7%89%87%e5%88%b0%e6%9c%ac%e5%9c%b0 aria-label=创建画布截屏(快照)，并保存图片到本地>创建画布截屏(快照)，并保存图片到本地</a><ul><li><a href=#%e5%85%88%e8%af%b4%e4%b8%80%e4%b8%8b%e5%a6%82%e4%bd%95%e5%88%9b%e5%bb%ba%e7%94%bb%e5%b8%83%e6%88%aa%e5%b1%8f%e5%bf%ab%e7%85%a7 aria-label=先说一下如何创建画布截屏(快照)>先说一下如何创建画布截屏(快照)</a><ul><li><a href=#%e7%ac%ac1%e7%a7%8dcanvastodataurl aria-label=第1种：canvas.toDataURL()>第1种：canvas.toDataURL()</a></li><li><a href=#%e7%ac%ac2%e7%a7%8dcanvastoblob aria-label=第2种：canvas.toBlob()>第2种：canvas.toBlob()</a></li><li><a href=#%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e aria-label=补充说明>补充说明</a></li></ul></li><li><a href=#%e5%86%8d%e8%af%b4%e4%b8%80%e4%b8%8b%e5%a6%82%e4%bd%95%e8%87%aa%e5%8a%a8%e5%b0%86%e5%9b%be%e7%89%87%e4%b8%8b%e8%bd%bd%e5%88%b0%e6%9c%ac%e5%9c%b0 aria-label=再说一下如何自动将图片下载到本地>再说一下如何自动将图片下载到本地</a></li></ul></li><li><a href=#%e8%ae%be%e7%bd%ae%e4%b8%8d%e6%b8%85%e9%99%a4%e7%94%bb%e5%b8%83%e5%86%85%e5%ae%b9 aria-label=设置不清除画布内容>设置不清除画布内容</a><ul><li><a href=#%e8%a1%a5%e5%85%85%e4%b8%80%e4%b8%aa%e7%a4%ba%e4%be%8bpreservedrawingbuffer aria-label=补充一个示例：PreserveDrawingBuffer>补充一个示例：PreserveDrawingBuffer</a><ul><li><a href=#%e7%a4%ba%e4%be%8b%e7%9b%ae%e6%a0%87 aria-label=示例目标>示例目标</a></li></ul></li></ul></li><li><a href=#%e8%8e%b7%e5%8f%96%e9%94%ae%e7%9b%98%e4%ba%8b%e4%bb%b6 aria-label=获取键盘事件>获取键盘事件</a><ul><ul><li><a href=#%e8%ae%a9-canvas-%e8%8e%b7%e5%8f%96%e9%94%ae%e7%9b%98%e4%ba%8b%e4%bb%b6 aria-label="让 Canvas 获取键盘事件">让 Canvas 获取键盘事件</a></li><li><a href=#%e8%ae%a9-orbitcontrol-%e8%8e%b7%e5%8f%96%e9%94%ae%e7%9b%98%e4%ba%8b%e4%bb%b6 aria-label="让 OrbitControl 获取键盘事件">让 OrbitControl 获取键盘事件</a></li></ul></ul></li><li><a href=#%e8%ae%be%e7%bd%ae%e7%94%bb%e5%b8%83%e9%80%8f%e6%98%8e%e5%ba%a6 aria-label=设置画布透明度>设置画布透明度</a></li><li><a href=#%e8%ae%be%e7%bd%ae%e7%94%bb%e5%b8%83%e4%b8%ba%e8%83%8c%e6%99%af aria-label=设置画布为背景>设置画布为背景</a></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>本文讲解一下 画布 Canvas 的一些实用技巧。</p><ul><li>创建画布截屏(快照)，并保存图片到本地</li><li>设置不清除画布内容</li><li>获取键盘事件</li><li>设置画布透明度</li><li>设置画布为背景</li></ul><h2 id=示例基本代码hellocanvas>示例基本代码：HelloCanvas<a hidden class=anchor aria-hidden=true href=#示例基本代码hellocanvas>#</a></h2><h4 id=先制作一个简单的带动画的threejs场景>先制作一个简单的、带动画的Three.js场景<a hidden class=anchor aria-hidden=true href=#先制作一个简单的带动画的threejs场景>#</a></h4><p>为了演示各个功能，我们先创建一个基础的 Three.js 动画场景：场景上有 3 个不同颜色、不停旋转的立方体。</p><p>这个场景在之前多个示例中已经创建过多次，但是这次和之前的略微不同。</p><p>**不同点1：**由于本文是讲解 canvas 的，本身和 Three.js 没太大的关联，所以这次我们会创建一个 useCreateScene 的自定义 hook，用来专门创建 3D 场景，这样我们的 index.tsx 代码可以更加简洁。</p><blockquote><p>所谓 <code>自定义 react hook</code>，本质上就是包含有 hook 的普通函数</p></blockquote><p>**不同点2：**由于讲解过程中需要用到一些按钮，所以我们这次将引入 react-dat-gui 这个组件，来添加一些示例相关按钮。</p><p>关于如何使用 react-dat-gui 这个，请参考我写的 <a href=https://github.com/puxiao/notes/blob/master/React%E4%B8%AD%E4%BD%BF%E7%94%A8GUI.md>React中使用GUI.md</a> 这篇教程。</p><blockquote><p>请务必学习一下 react-dat-gui 这个组件，在后续示例中我们会经常使用这个组件来作为调试面板。</p></blockquote><h4 id=具体的代码>具体的代码<a hidden class=anchor aria-hidden=true href=#具体的代码>#</a></h4><p>我们创建一个专门存放本示例的目录 src/components/hello-canvas/</p><p><strong>use-create-scene.ts：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useEffect } from &#39;react&#39;
</span></span><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const useCreateScene = (canvasRef: React.RefObject&lt;HTMLCanvasElement&gt;) =&gt; {
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
</span></span><span style=display:flex><span>        const scene = new Three.Scene()
</span></span><span style=display:flex><span>        scene.background = new Three.Color(0x222222)
</span></span><span style=display:flex><span>        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
</span></span><span style=display:flex><span>        camera.position.set(0, 5, 10)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const light = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>        light.position.set(5, 10, 0)
</span></span><span style=display:flex><span>        scene.add(light)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const controls = new OrbitControls(camera, canvasRef.current)
</span></span><span style=display:flex><span>        controls.update()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const colors = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;]
</span></span><span style=display:flex><span>        const cubes: Three.Mesh[] = []
</span></span><span style=display:flex><span>        colors.forEach((color, index) =&gt; {
</span></span><span style=display:flex><span>            const mat = new Three.MeshPhongMaterial({ color })
</span></span><span style=display:flex><span>            const geo = new Three.BoxBufferGeometry(2, 2, 2)
</span></span><span style=display:flex><span>            const mesh = new Three.Mesh(geo, mat)
</span></span><span style=display:flex><span>            mesh.position.x = (index - 1) * 4
</span></span><span style=display:flex><span>            scene.add(mesh)
</span></span><span style=display:flex><span>            cubes.push(mesh)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>            time *= 0.001
</span></span><span style=display:flex><span>            cubes.forEach((cube) =&gt; {
</span></span><span style=display:flex><span>                cube.rotation.x = cube.rotation.y = time
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            renderer.render(scene, camera)
</span></span><span style=display:flex><span>            window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const handleResize = () =&gt; {
</span></span><span style=display:flex><span>            if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>            const width = canvasRef.current.clientWidth
</span></span><span style=display:flex><span>            const height = canvasRef.current.clientHeight
</span></span><span style=display:flex><span>            camera.aspect = width / height
</span></span><span style=display:flex><span>            camera.updateProjectionMatrix()
</span></span><span style=display:flex><span>            renderer.setSize(width, height, false)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        handleResize()
</span></span><span style=display:flex><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default useCreateScene
</span></span></code></pre></div><p><strong>index.scss：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>.full-screen,
</span></span><span style=display:flex><span>canvas {
</span></span><span style=display:flex><span>    display: block;
</span></span><span style=display:flex><span>    height: inherit;
</span></span><span style=display:flex><span>    width: inherit;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>.dat-gui {
</span></span><span style=display:flex><span>    top: 16px !important;
</span></span><span style=display:flex><span>    font-size: 18px !important;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>index.tsx：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useRef, useState } from &#39;react&#39;
</span></span><span style=display:flex><span>import DatGUI, { DatButton } from &#39;react-dat-gui&#39;
</span></span><span style=display:flex><span>import useCreateScene from &#39;./use-create-scene&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>import &#39;react-dat-gui/dist/index.css&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloCanvas = () =&gt; {
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>    const [date, setDate] = useState&lt;any&gt;({})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useCreateScene(canvasRef)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const handleGUIUpdate = (newDate: any) =&gt; {
</span></span><span style=display:flex><span>        setDate(newDate)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const handleSaveClick = () =&gt; {
</span></span><span style=display:flex><span>        //编写点击之后的代码
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;div className=&#39;full-screen&#39;&gt;
</span></span><span style=display:flex><span>            &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>            &lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&#39;dat-gui&#39; &gt;
</span></span><span style=display:flex><span>                &lt;DatButton label=&#39;点击保存画布快照&#39; onClick={handleSaveClick} /&gt;
</span></span><span style=display:flex><span>            &lt;/DatGUI&gt;
</span></span><span style=display:flex><span>        &lt;/div&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloCanvas
</span></span></code></pre></div><p><strong>补充说明：</strong></p><ol><li><p>所有创建 3D 场景的代码都转移到了 use-create-scene.ts 中，index.tsx 的代码终于看上去非常简洁了。</p></li><li><p>我们使用了 &lt;DatGUI > 标签，但是由于我们本身只使用 按钮(&lt;DatButton >)，并未用到任何其他变量，所以</p><p><code>&lt;DatGUI data={date} onUpdate={handleGUIUpdate} ></code>这行属性配置只是为了不让 DatGUI 报缺省错误，并无其他作用。</p><blockquote><p>DatGUI 的 date、onUpdate 为必填属性</p></blockquote></li></ol><p>至此，本示例所用到的基础场景代码已搭建好，接下来开始讲解 canvas 的使用技巧。</p><h2 id=创建画布截屏快照并保存图片到本地>创建画布截屏(快照)，并保存图片到本地<a hidden class=anchor aria-hidden=true href=#创建画布截屏快照并保存图片到本地>#</a></h2><h3 id=先说一下如何创建画布截屏快照>先说一下如何创建画布截屏(快照)<a hidden class=anchor aria-hidden=true href=#先说一下如何创建画布截屏快照>#</a></h3><p>对于 HTML5 中的 canvas 来说，创建画布截屏(快照)有 2 种方式：canvas.toDataURL()、canvas.toBolb()</p><blockquote><p>所谓截屏和快照，更加准确的说法应该是：获取画布当前图片的内容</p></blockquote><h4 id=第1种canvastodataurl>第1种：canvas.toDataURL()<a hidden class=anchor aria-hidden=true href=#第1种canvastodataurl>#</a></h4><p>canvas.toDataURL() 可以创建一个临时的图片地址，该图片地址可以作为当前页面中的 &lt;image >标签中的 src 属性值。或者可以创建一个下载链接，点击下载这个图片。</p><p><strong>toDataURL()用法：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>canvas.toDataURL(type?: string, quality?: any): string;
</span></span></code></pre></div><ol><li><p>type：图片格式类型，值只能是 &ldquo;image/png&rdquo; 或 &ldquo;image/jpeg&rdquo;</p><blockquote><p>除了上面 2 个固定值，若你填写其他值则不启作用也不报错，最终会使用 &ldquo;image/png&rdquo; 来作为默认值</p></blockquote><blockquote><p>对于 谷歌浏览器 Chrome ，还额外支持一个类型 “image/webp”</p></blockquote></li><li><p>quality：jpeg 图片的压缩质量，取值范围 0 - 1，默认值为 0.92</p><blockquote><p>quality 的值越大，图片清晰度越高，文件体积越大</p></blockquote><blockquote><p>如果 quality 的值不在 0-1 范围内，则会使用默认值 0.92</p></blockquote></li></ol><p><strong>创建 PNG 图片：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const imgurl = canvas.toDataURL(&#39;image/png&#39;)
</span></span><span style=display:flex><span>console.log(imgurl)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//输出以下内容
</span></span><span style=display:flex><span>data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAB4AAAAEUCAYAAADK...
</span></span></code></pre></div><p><strong>创建 JPEG 图片：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const imgurl = canvas.toDataURL(&#39;image/jpeg&#39;,quality)
</span></span><span style=display:flex><span>console.log(imgurl)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//输出以下内容
</span></span><span style=display:flex><span>data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAYEBQY...
</span></span></code></pre></div><blockquote><p>请注意上面输出内容中，均包含了 ”base64“，这种格式的图片，是可以自动下载的</p><p>关于图片自动下载保存到本地我们会稍后讲解</p></blockquote><h4 id=第2种canvastoblob>第2种：canvas.toBlob()<a hidden class=anchor aria-hidden=true href=#第2种canvastoblob>#</a></h4><p>canvas.toBlob() 可以创建 Blob 对象，该对象包含图片的数据内容。</p><blockquote><p>注意：canvas.toDataURL() 是获得一个临时的图片地址，而 canvas.toBlob() 是获得图片数据内容。</p></blockquote><p><strong>canvas.toBlob()用法：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>toBlob(callback: BlobCallback, type?: string, quality?: any): void;
</span></span></code></pre></div><ol><li><p>callback：获得 Blob 对象的回调函数</p><blockquote><p>通常为：canvas.toBlob( (blob: Blob|null) => {} )</p></blockquote></li><li><p>type：图片的格式类型，默认值为 &ldquo;image/png&rdquo;</p></li><li><p>quality：若图片格式类型为 &ldquo;image/jpeg&rdquo;，quality 表示 JPEG 的压缩质量</p><blockquote><p>type 的取值和默认值、quality 的取值范围和默认值 与 canvas.toDataURL() 完全相同</p></blockquote></li></ol><p><strong>使用示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>canvas.toBlob((blob) =&gt; {
</span></span><span style=display:flex><span>    console.log(blob)
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>或
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>canvas.toBlob((blob) =&gt; {
</span></span><span style=display:flex><span>    console.log(blob)
</span></span><span style=display:flex><span>}, &#39;image/jpeg&#39;, 0.8)
</span></span></code></pre></div><blockquote><p>注意：不同于 canvas.toDataURL()，canvas.toBlob() 这个函数是没有返回值的</p></blockquote><blockquote><p>另外，假设使用 jpeg 压缩质量为 0.8，文件体积有可能只有 png 格式的 1/3 。</p></blockquote><h4 id=补充说明>补充说明<a hidden class=anchor aria-hidden=true href=#补充说明>#</a></h4><p><strong>关于分辨率：</strong></p><p>按照 MDN 文档，无论哪种方式保存的图片分辨率都是 96，但是我在 PC 机上试验，将下载的图片保存到本地，并在 PhotoShop 软件中查看，发现图片分辨率依然是 72。</p><p>我怀疑 保存图片的分辨率其实是和 当前系统一致的。假设在手机上，有可能图片分辨率就是 96 了。</p><blockquote><p>稍后我会在手机上验证一下 图片分辨率 这个问题。</p></blockquote><p>最后，建议你去 MDN 上看 canvas 保存图片 的相关讲解作为本小节的补充。</p><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas>https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Pixel_manipulation_with_canvas</a></p><h3 id=再说一下如何自动将图片下载到本地>再说一下如何自动将图片下载到本地<a hidden class=anchor aria-hidden=true href=#再说一下如何自动将图片下载到本地>#</a></h3><p><strong>图片自动下载到本地的思路：在JS中创建一个 a 链接，并且模拟出 a 点击事件</strong></p><p><strong>使用toDataURL()函数：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const canvas = canvasRef.current
</span></span><span style=display:flex><span>const imgurl = canvas.toDataURL(&#39;image/jpeg&#39;, 0.8)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const a = document.createElement(&#39;a&#39;)
</span></span><span style=display:flex><span>a.href = imgurl
</span></span><span style=display:flex><span>a.download = &#39;myimg.jpeg&#39;
</span></span><span style=display:flex><span>a.click()
</span></span></code></pre></div><blockquote><p>注意：我原本以为还需要将 a 标签插入到网页 body 中才可以实现自动下载，但是经过试验发现根本不需要这样，以下为我原本写的代码：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const a = document.createElement(&#39;a&#39;)
</span></span><span style=display:flex><span>document.body.appendChild(a) //根本无需此行代码
</span></span><span style=display:flex><span>a.style.display = &#39;none&#39; //由于不需要添加到 body 中，因此也无需此行代码
</span></span><span style=display:flex><span>a.href = imgurl
</span></span><span style=display:flex><span>a.download = &#39;myimg.jpeg&#39;
</span></span><span style=display:flex><span>a.click()
</span></span><span style=display:flex><span>document.body.removeChild(a) //根本无需此行代码
</span></span></code></pre></div></blockquote><p><strong>使用toBlob()函数：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const canvas = canvasRef.current
</span></span><span style=display:flex><span>canvas.toBlob((blob) =&gt; {
</span></span><span style=display:flex><span>    const imgurl = window.URL.createObjectURL(blob)
</span></span><span style=display:flex><span>    const a = document.createElement(&#39;a&#39;)
</span></span><span style=display:flex><span>    a.href = imgurl
</span></span><span style=display:flex><span>    a.download = &#39;myimg.jpeg&#39;
</span></span><span style=display:flex><span>    a.click()
</span></span><span style=display:flex><span>}, &#39;image/jpeg&#39;, 0.8)
</span></span></code></pre></div><p><strong>小总结：</strong></p><ol><li>若使用 canvas.toDataURL()，则可以直接将得到的图片临时地址 赋值给 a.href</li><li>若使用 canvas.toBlob()，则需要通过 window.URL.createObjectURL() 这个函数将 Blob 数据转化得到对应的地址，然后再赋值给 a.href</li></ol><p>好了，关于如何获取画布图片数据、如何保持图片到本地讲解完毕，来实践吧。</p><p>无论采用 canvas.toDataURL() 还是 canvas.toBlob() 都可以，本示例我们采用 toBlob() 。</p><p>我们将 index.stx 的代码修改如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useRef, useState } from &#39;react&#39;
</span></span><span style=display:flex><span>import DatGUI, { DatButton } from &#39;react-dat-gui&#39;
</span></span><span style=display:flex><span>import useCreateScene from &#39;./use-create-scene&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>import &#39;react-dat-gui/dist/index.css&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloCanvas = () =&gt; {
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>    const [date, setDate] = useState&lt;any&gt;({})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useCreateScene(canvasRef)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const handleGUIUpdate = (newDate: any) =&gt; {
</span></span><span style=display:flex><span>        setDate(newDate)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const handleSaveClick = () =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>        const canvas = canvasRef.current
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //采用 toDataURL() 方式
</span></span><span style=display:flex><span>        // const imgurl = canvas.toDataURL(&#39;image/jpeg&#39;, 0.8)
</span></span><span style=display:flex><span>        // const a = document.createElement(&#39;a&#39;)
</span></span><span style=display:flex><span>        // a.href = imgurl
</span></span><span style=display:flex><span>        // a.download = &#39;myimg.jpeg&#39; //我们定义下载图片的文件名
</span></span><span style=display:flex><span>        // a.click()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //采用 toBlob() 方式
</span></span><span style=display:flex><span>        canvas.toBlob((blob) =&gt; {
</span></span><span style=display:flex><span>            const imgurl = window.URL.createObjectURL(blob)
</span></span><span style=display:flex><span>            const a = document.createElement(&#39;a&#39;)
</span></span><span style=display:flex><span>            a.href = imgurl
</span></span><span style=display:flex><span>            a.download = &#39;myimg.jpeg&#39;
</span></span><span style=display:flex><span>            a.click()
</span></span><span style=display:flex><span>        }, &#39;image/jpeg&#39;, 0.8)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;div className=&#39;full-screen&#39;&gt;
</span></span><span style=display:flex><span>            &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>            &lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&#39;dat-gui&#39; &gt;
</span></span><span style=display:flex><span>                &lt;DatButton label=&#39;点击保存画布快照&#39; onClick={handleSaveClick} /&gt;
</span></span><span style=display:flex><span>            &lt;/DatGUI&gt;
</span></span><span style=display:flex><span>        &lt;/div&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloCanvas
</span></span></code></pre></div><p>实际运行，点击右上角的 按钮，就会给画布创建图片快照，并且自动下载到本地。</p><p>然后你可以查看刚刚下载到本地的 myimg.jpeg 这个文件，打开它——你会发现？？？</p><p><strong>怎么图片啥内容都没有？纯色的？3 个立方体呢？</strong></p><p><strong>what ？why ？</strong></p><p>呵，马上讲解为什么。</p><p><strong>问题出在了哪里？</strong></p><p>首先我们容易想到，在 use-create-scene.ts 的 render() 函数中，不停的运行着每一帧都进行画布重新渲染的代码，莫非是我们截图那一瞬间刚好画布还未渲染完成？</p><p>好，我们先把那行代码删除掉，看是否就可以截图显示有内容了。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span>const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>    time *= 0.001
</span></span><span style=display:flex><span>    cubes.forEach((cube) =&gt; {
</span></span><span style=display:flex><span>        cube.rotation.x = cube.rotation.y = time
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    renderer.render(scene, camera)
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>-   window.requestAnimationFrame(render)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006></span>}
</span></span><span style=display:flex><span>window.requestAnimationFrame(render)
</span></span></code></pre></div><p>再次运行，3 个立方体是静止状态，此时点击按钮保存截图。</p><p>查看该图，竟然依然是空白，没有内容的。</p><p>看来问题并不出在上面一行代码中，我们恢复刚才删除的 <code>window.requestAnimationFrame(render)</code>，再去想其他原因。</p><p><strong>真实的原因是：</strong></p><ol><li>我们所谓的针对画布截屏 创建快照，实际上是获取 canvas 中的数据</li><li>但这个数据并不是针对 DOM 中已显示的 canvas，而是针对 canvas 对象中缓冲区的数据</li><li>关键在于当 canvas 渲染完成后(DOM中已显示出内容)，默认会清空 缓冲区中的数据</li><li>所以，这就是我们为什么去 “获取 canvas 图像数据时得到是空白内容” 的原因</li></ol><p><strong>canvas从计算到显示的过程：</strong></p><ol><li>canvas 根据相应的 JS 规则，开始创建、计算画布内容数据</li><li>canvas 将计算得到的画布内容数据填充到 canvas 缓冲区</li><li>当 canvas 画布内容计算完成，此时 canvas 缓冲区已有完整的画布内容数据后，将画布内容显示到 DOM 中</li></ol><p><strong>再说一遍：</strong></p><p>我们之前的示例中，渲染并显示 canvas 内容的函数 render 和 创建画布快照 的函数是相互独立的，这就造成了当我们去获取 canvas 缓冲区数据时，canvas 已经将画布内容显示到 DOM 中并且清空了缓冲区。</p><p><strong>解决办法：</strong></p><p>解决办法就是当我们要创建画布快照，获取 canvas 缓冲区内容之前，在同一个函数体内，额外调用一次 render 函数，确保此时 canvas 缓冲区内是有内容的。</p><p><strong>实际代码：</strong></p><p>第1：由于我们示例代码中，render 函数本身位于 useCreateScene 函数内部，因此我们需要创造一个 renderRef 的钩子(hook)，将 renderRef 对外 return 出去，以便 index.stx 中可以获取 render 函数的引用。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>type RenderType = () =&gt; void
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const renderRef = useRef&lt;RenderType | null&gt;(null)
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>renderRef.current = render
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>return renderRef
</span></span></code></pre></div><p>第2：这样做引申出另外一个问题，就是我们的 render 函数其实是有参数 time 的：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>    time *= 0.001
</span></span><span style=display:flex><span>    cubes.forEach((cube) =&gt; {
</span></span><span style=display:flex><span>        cube.rotation.x = cube.rotation.y = time
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    renderer.render(scene, camera)
</span></span><span style=display:flex><span>    window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>window.requestAnimationFrame(render)
</span></span></code></pre></div><p>而我们希望 index.tsx 中调用 render() 是不传参数 time 的。因为 index.tsx 中根本不存在 time 这个变量，所以我们需要对 渲染 进行适当的改造。</p><p>我们将原本的 渲染函数 render() 拆分成 2 个函数：</p><ol><li>单纯负责渲染的 render 函数</li><li>负责修改物体属性从而产生动画的 animate 函数</li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const render = () =&gt; {
</span></span><span style=display:flex><span>    renderer.render(scene, camera)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>renderRef.current = render
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const animate = (time: number) =&gt; {
</span></span><span style=display:flex><span>    time *= 0.001
</span></span><span style=display:flex><span>    cubes.forEach((cube) =&gt; {
</span></span><span style=display:flex><span>        cube.rotation.x = cube.rotation.y = time
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>    render() //这样 render() 就是一个不需要参数的函数
</span></span><span style=display:flex><span>    window.requestAnimationFrame(animate)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>window.requestAnimationFrame(animate)
</span></span></code></pre></div><p>经过这样改造后，完整的 use-create-screen.ts 代码如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useEffect, useRef } from &#39;react&#39;
</span></span><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>type RenderType = () =&gt; void
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const useCreateScene = (canvasRef: React.RefObject&lt;HTMLCanvasElement&gt;) =&gt; {
</span></span><span style=display:flex><span>    const renderRef = useRef&lt;RenderType | null&gt;(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
</span></span><span style=display:flex><span>        const scene = new Three.Scene()
</span></span><span style=display:flex><span>        scene.background = new Three.Color(0x222222)
</span></span><span style=display:flex><span>        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
</span></span><span style=display:flex><span>        camera.position.set(0, 5, 10)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const light = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>        light.position.set(5, 10, 0)
</span></span><span style=display:flex><span>        scene.add(light)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const controls = new OrbitControls(camera, canvasRef.current)
</span></span><span style=display:flex><span>        controls.update()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const colors = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;]
</span></span><span style=display:flex><span>        const cubes: Three.Mesh[] = []
</span></span><span style=display:flex><span>        colors.forEach((color, index) =&gt; {
</span></span><span style=display:flex><span>            const mat = new Three.MeshPhongMaterial({ color })
</span></span><span style=display:flex><span>            const geo = new Three.BoxBufferGeometry(2, 2, 2)
</span></span><span style=display:flex><span>            const mesh = new Three.Mesh(geo, mat)
</span></span><span style=display:flex><span>            mesh.position.x = (index - 1) * 4
</span></span><span style=display:flex><span>            scene.add(mesh)
</span></span><span style=display:flex><span>            cubes.push(mesh)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const render = () =&gt; {
</span></span><span style=display:flex><span>            renderer.render(scene, camera)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        renderRef.current = render
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const animate = (time: number) =&gt; {
</span></span><span style=display:flex><span>            time *= 0.001
</span></span><span style=display:flex><span>            cubes.forEach((cube) =&gt; {
</span></span><span style=display:flex><span>                cube.rotation.x = cube.rotation.y = time
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            render() //这样 render() 就是一个不需要参数的函数
</span></span><span style=display:flex><span>            window.requestAnimationFrame(animate)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        window.requestAnimationFrame(animate)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const handleResize = () =&gt; {
</span></span><span style=display:flex><span>            if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>            const width = canvasRef.current.clientWidth
</span></span><span style=display:flex><span>            const height = canvasRef.current.clientHeight
</span></span><span style=display:flex><span>            camera.aspect = width / height
</span></span><span style=display:flex><span>            camera.updateProjectionMatrix()
</span></span><span style=display:flex><span>            renderer.setSize(width, height, false)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        handleResize()
</span></span><span style=display:flex><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return renderRef
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default useCreateScene
</span></span></code></pre></div><p>index.tsx 完整代码如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useRef, useState } from &#39;react&#39;
</span></span><span style=display:flex><span>import DatGUI, { DatButton } from &#39;react-dat-gui&#39;
</span></span><span style=display:flex><span>import useCreateScene from &#39;./use-create-scene&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>import &#39;react-dat-gui/dist/index.css&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloCanvas = () =&gt; {
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>    const [date, setDate] = useState&lt;any&gt;({})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const renderRef =  useCreateScene(canvasRef) //获取自定义 hook 返回的 renderRef
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const handleGUIUpdate = (newDate: any) =&gt; {
</span></span><span style=display:flex><span>        setDate(newDate)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const handleSaveClick = () =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current === null || renderRef.current === null) { return }
</span></span><span style=display:flex><span>        const canvas = canvasRef.current
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        renderRef.current() //此时调用 render()，进行一次渲染，确保 canvas 缓冲区有数据
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //采用 toDataURL() 方式
</span></span><span style=display:flex><span>        // const imgurl = canvas.toDataURL(&#39;image/jpeg&#39;, 0.8)
</span></span><span style=display:flex><span>        // const a = document.createElement(&#39;a&#39;)
</span></span><span style=display:flex><span>        // a.href = imgurl
</span></span><span style=display:flex><span>        // a.download = &#39;myimg.jpeg&#39; //我们定义下载图片的文件名
</span></span><span style=display:flex><span>        // a.click()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //采用 toBlob() 方式
</span></span><span style=display:flex><span>        canvas.toBlob((blob) =&gt; {
</span></span><span style=display:flex><span>            const imgurl = window.URL.createObjectURL(blob)
</span></span><span style=display:flex><span>            const a = document.createElement(&#39;a&#39;)
</span></span><span style=display:flex><span>            a.href = imgurl
</span></span><span style=display:flex><span>            a.download = &#39;myimg.jpeg&#39;
</span></span><span style=display:flex><span>            a.click()
</span></span><span style=display:flex><span>        }, &#39;image/jpeg&#39;, 0.8)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;div className=&#39;full-screen&#39;&gt;
</span></span><span style=display:flex><span>            &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>            &lt;DatGUI data={date} onUpdate={handleGUIUpdate} className=&#39;dat-gui&#39; &gt;
</span></span><span style=display:flex><span>                &lt;DatButton label=&#39;点击保存画布快照&#39; onClick={handleSaveClick} /&gt;
</span></span><span style=display:flex><span>            &lt;/DatGUI&gt;
</span></span><span style=display:flex><span>        &lt;/div&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloCanvas
</span></span></code></pre></div><p>调试运行，这次保存的画布快照图片，就不会再是空白，而是有具体内容了。</p><h2 id=设置不清除画布内容>设置不清除画布内容<a hidden class=anchor aria-hidden=true href=#设置不清除画布内容>#</a></h2><p>上面刚讲到 HTML5 中的 Canvas 每次渲染都存在一个 数据缓冲区的概念，而 Three.js 的渲染器 WebGLRenderer 也同样存在 数据缓冲区 这个概念。</p><p>WebGLRenderer 缓冲区内为每次渲染场景得到的画面数据，默认情况下每一次渲染都会清空(释放)上一次的渲染画面数据。</p><p>Canvas 数据缓冲区每次清空 这个我们没有办法修改，只能调用渲染函数，重新渲染一次。</p><p>但是 WebGLRenderer 的数据缓冲区却是可以通过设置让默认不清除的。</p><blockquote><p>所谓不清除上一次数据缓冲区的内容，本质上就是保留上一次渲染画面内容</p></blockquote><blockquote><p>所谓不清除画布内容，本质上是让渲染器不清除之前的渲染内容</p></blockquote><p><strong>设置 WebGLRenderer 保留数据缓冲区中的历史数据：</strong></p><p>我们只需要将 WebGLRender 的配置修改如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const renderer = new Three.WebGLRenderer({
</span></span><span style=display:flex><span>    canvas: canvasRef.current,
</span></span><span style=display:flex><span>    preserveDrawingBuffer: true,
</span></span><span style=display:flex><span>    alpha: true
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>renderer.autoClearColor = false
</span></span></code></pre></div><p>经过以上的修改之后，每次渲染都会继续保留之前渲染历史画面。</p><p>调试运行代码，你就能感受到和之前渲染的不一样效果了。</p><p><strong>但是，存在一个问题：当浏览器窗口尺寸改变后，由于执行了 renderer.setSize()，则此时 渲染器中过往的渲染内容将会被清空。</strong></p><blockquote><p>渲染器中的渲染历史内容被清空后，画面就好像第一次刚开始那样，重新开始渲染。</p></blockquote><blockquote><p>补充说明：当用户在手机上浏览时，手机从竖屏变为横屏时，也会触发重新绘制。</p></blockquote><p><strong>真正的解决方案：离屏渲染</strong></p><p>例如使用 WebGLRenderTarget，具体请回顾我们之前讲解的内容：<a href=https://github.com/puxiao/threejs-tutorial/blob/main/15%20Three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93.md>15 Three.js基础之离屏渲染.md</a></p><h3 id=补充一个示例preservedrawingbuffer>补充一个示例：PreserveDrawingBuffer<a hidden class=anchor aria-hidden=true href=#补充一个示例preservedrawingbuffer>#</a></h3><p>src/components/hello-canvas/preserve-drawing-buffer.tsx</p><h4 id=示例目标>示例目标<a hidden class=anchor aria-hidden=true href=#示例目标>#</a></h4><ol><li>创建一个由 6 个立方体，做相互缠绕运动的一个物体</li><li>创建一个正交镜头 OrthographicCamera</li><li>给 canvas 添加鼠标滑动监听、以及 手指滑动监听</li><li>当 鼠标或手指滑动画布时，更新 物体 在镜头中的位置</li><li>设置渲染器不清除历史画面</li></ol><p>最终呈现出的效果：类似一个 画笔在画板上 画画 的效果。</p><p><strong>PreserveDrawingBuffer 代码：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useEffect, useRef } from &#39;react&#39;
</span></span><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const state = { x: 0, y: 0, z: 0 }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const PreserveDrawingBuffer = () =&gt; {
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const renderer = new Three.WebGLRenderer({
</span></span><span style=display:flex><span>            canvas: canvasRef.current,
</span></span><span style=display:flex><span>            preserveDrawingBuffer: true,
</span></span><span style=display:flex><span>            alpha: true
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        renderer.autoClearColor = false
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const camera = new Three.OrthographicCamera(-2, 2, 1, -1, -1, 1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const scene = new Three.Scene()
</span></span><span style=display:flex><span>        scene.background = new Three.Color(0xFFFFFF)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const light = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>        light.position.set(-1, 2, 3)
</span></span><span style=display:flex><span>        scene.add(light)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const geometry = new Three.BoxBufferGeometry(1, 1, 1)
</span></span><span style=display:flex><span>        const base = new Three.Object3D()
</span></span><span style=display:flex><span>        scene.add(base)
</span></span><span style=display:flex><span>        base.scale.set(0.1, 0.1, 0.1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const colors = [&#39;#F00&#39;, &#39;#FF0&#39;, &#39;#0F0&#39;, &#39;#0FF&#39;, &#39;#00F&#39;, &#39;#F0F&#39;]
</span></span><span style=display:flex><span>        const numArr = [-2, 2] //同一坐标轴上，对称 2 个立方体的坐标
</span></span><span style=display:flex><span>        colors.forEach((color, index) =&gt; {
</span></span><span style=display:flex><span>            const material = new Three.MeshPhongMaterial({ color })
</span></span><span style=display:flex><span>            const cube = new Three.Mesh(geometry, material)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            const col = Math.floor(index / numArr.length)
</span></span><span style=display:flex><span>            const row = index % numArr.length
</span></span><span style=display:flex><span>            let result = [0, 0, 0]
</span></span><span style=display:flex><span>            result[col] = numArr[row]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cube.position.set(result[0], result[1], result[2])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            base.add(cube)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const temp = new Three.Vector3()
</span></span><span style=display:flex><span>        const updatePosition = (x: number, y: number) =&gt; {
</span></span><span style=display:flex><span>            if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            // const rect = canvasRef.current.getBoundingClientRect()
</span></span><span style=display:flex><span>            // const newX = (x - rect.left) * canvasRef.current.width / rect.width
</span></span><span style=display:flex><span>            // const newY = (y - rect.top) * canvasRef.current.height / rect.height
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            // const resX = newX / canvasRef.current.width * 2 - 1
</span></span><span style=display:flex><span>            // const resY = newY / canvasRef.current.height * -2 + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            const resX = x / canvasRef.current.width * 2 - 1
</span></span><span style=display:flex><span>            const resY = y / canvasRef.current.height * -2 + 1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            temp.set(resX, resY, 0).unproject(camera)
</span></span><span style=display:flex><span>            state.x = temp.x
</span></span><span style=display:flex><span>            state.y = temp.y
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const handleMouseMove = (eve: MouseEvent) =&gt; {
</span></span><span style=display:flex><span>            updatePosition(eve.clientX, eve.clientY)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        const handleTouchMove = (eve: TouchEvent) =&gt; {
</span></span><span style=display:flex><span>            eve.preventDefault()
</span></span><span style=display:flex><span>            const touche = eve.touches[0]
</span></span><span style=display:flex><span>            updatePosition(touche.clientX, touche.clientY)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        canvasRef.current.addEventListener(&#39;mousemove&#39;, handleMouseMove)
</span></span><span style=display:flex><span>        canvasRef.current.addEventListener(&#39;touchmove&#39;, handleTouchMove, { passive: false })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>            time = time * 0.001
</span></span><span style=display:flex><span>            base.position.set(state.x, state.y, state.z)
</span></span><span style=display:flex><span>            base.rotation.x = time
</span></span><span style=display:flex><span>            base.rotation.y = time * 1.11
</span></span><span style=display:flex><span>            renderer.render(scene, camera)
</span></span><span style=display:flex><span>            window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const handleResize = () =&gt; {
</span></span><span style=display:flex><span>            if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>            const width = canvasRef.current.clientWidth
</span></span><span style=display:flex><span>            const height = canvasRef.current.clientHeight
</span></span><span style=display:flex><span>            camera.right = width / height
</span></span><span style=display:flex><span>            camera.left = - camera.right
</span></span><span style=display:flex><span>            camera.updateProjectionMatrix()
</span></span><span style=display:flex><span>            renderer.setSize(width, height, false)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        handleResize()
</span></span><span style=display:flex><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default PreserveDrawingBuffer
</span></span></code></pre></div><p><strong>补充说明：</strong></p><p>上面这段代码略微复杂、陌生。因为这段代码中有几个地方是我们之前示例中从来未接触过的：</p><ol><li><p>使用的是正交镜头，而不是透视镜头</p></li><li><p>当窗口尺寸发生变化时，更新正交镜头</p><blockquote><p>更新方式和我们之前习惯使用的 透视镜头(PerspectiveCamera) 大不同</p></blockquote></li><li><p>监听鼠标滑动、手指滑动事件</p></li><li><p>更新 物体 在正交镜头中的 “投影位置”</p></li></ol><p><strong>额外补充：</strong></p><p>上述代码中，6 个立方体 他们分别是：</p><ol><li><p>在 x 轴对称的 2 个立方体</p><blockquote><p>在示例中，对应的坐标分别为 (-2,0,0)、(2,0,0)</p></blockquote></li><li><p>在 y 轴对称的 2 个立方体</p><blockquote><p>在示例中，对应的坐标分别为 (0,-2,0)、(0,2,0)</p></blockquote></li><li><p>在 z 轴堆成的 2 个立方体</p><blockquote><p>在示例中，对应的坐标分别为 (0,0,-2)、(0,0,2)</p></blockquote></li></ol><p>这 6 个立方体他们依次对应的坐标，没有提前写死，而是通过一段特殊的 forEach 循环来计算得出的。</p><p>可以阅读下面这段通用的代码，帮助你理解 整个 forEach 循环是如何得到每个立方体坐标的。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>//遍历出 目标长度为N，特殊值为 [xx, xx, ...] 的 多维数组
</span></span><span style=display:flex><span>const numArr = [-2, 2] //定义特殊位置上出现的数字
</span></span><span style=display:flex><span>const arrLength = 3 //定义目标数组长度
</span></span><span style=display:flex><span>const total = arrLength * numArr.length //根据目标数组长度以及特殊数字的个数，计算得出目标数组的总个数
</span></span><span style=display:flex><span>for (let i = 0; i &lt; total; i++) {
</span></span><span style=display:flex><span>    const col = Math.floor(i / numArr.length) //计算出特殊位置的索引
</span></span><span style=display:flex><span>    const row = i % numArr.length //计算出特殊位置上数字值对应的索引
</span></span><span style=display:flex><span>    let result = new Array(arrLength) //得到一个 长度为 arrLenght 的数组
</span></span><span style=display:flex><span>    result.fill(0) //将数组每一项填充为 0
</span></span><span style=display:flex><span>    result[col] = numArr[row] //修改特殊位置上的值
</span></span><span style=display:flex><span>    console.log(result)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果你对 useCreateScene 这个示例不太理解也没有关系，因为毕竟这个示例中出现了一些我们之前示例中从未用到的一些类，你可以先跳过这个示例，继续后面的学习。</p><blockquote><p>随着日后对于 正交镜头 的多次使用，终归会熟练并理解的。</p></blockquote><h2 id=获取键盘事件>获取键盘事件<a hidden class=anchor aria-hidden=true href=#获取键盘事件>#</a></h2><h4 id=让-canvas-获取键盘事件>让 Canvas 获取键盘事件<a hidden class=anchor aria-hidden=true href=#让-canvas-获取键盘事件>#</a></h4><p>必须同时满足以下 2 个条件后，canvas 才可以获得键盘事件。</p><ol><li><p>canvas 当前获得焦点</p></li><li><p><code>&lt;canvas \></code> 标签中必须添加 tabIndex属性，</p><blockquote><p>属性值是 -1、0、1 都无所谓，建议设置为 0</p></blockquote></li></ol><p>补充说明：当 canvas 获得当前焦点后，会在四周出现一个蓝色边框，可以通过定义 css 样式来取消这个样式。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>canvas:focus {
</span></span><span style=display:flex><span>    outline: none;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>简单示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useEffect, useRef } from &#39;react&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const CanvasKeyboard = () =&gt; {
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement | null&gt;(null)
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        canvasRef.current.focus() //自动获取焦点
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const handleKeydown = (event: KeyboardEvent) =&gt; {
</span></span><span style=display:flex><span>            console.log(event)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        canvasRef.current.addEventListener(&#39;keydown&#39;, handleKeydown)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            if (canvasRef.current === null) { return }
</span></span><span style=display:flex><span>            canvasRef.current.removeEventListener(&#39;keydown&#39;, handleKeydown)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; tabIndex={0} /&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default CanvasKeyboard
</span></span></code></pre></div><h4 id=让-orbitcontrol-获取键盘事件>让 OrbitControl 获取键盘事件<a hidden class=anchor aria-hidden=true href=#让-orbitcontrol-获取键盘事件>#</a></h4><p>默认 OrbitControl 对象就包含键盘方向键侦听。</p><p>键盘上的 上下左右 方向键 均可操控改变 镜头轨道视图。</p><p>但是我们之前的代码中，经常是这样写的：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const controls = new OrbitControls(camera, canvasRef.current)
</span></span></code></pre></div><p>这样存在的问题是，当 canvas 失去焦点后，就无法再获得键盘事件。</p><p>最简单的解决办法就是将代码修改为：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const controls = new OrbitControls(camera, document.body)
</span></span></code></pre></div><p>这样键盘事件就不容易丢失。</p><h2 id=设置画布透明度>设置画布透明度<a hidden class=anchor aria-hidden=true href=#设置画布透明度>#</a></h2><p>设置画布透明度，你可能会疑惑，这有什么好讲的，直接通过 css 给 canvas 添加透明度样式即可：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>canvas {
</span></span><span style=display:flex><span>    opacity: 0.4;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样做肯定没有问题，但是这里说的 “设置画布透明度” 实际上是指 给不同物体设置透明度。</p><p>例如我们之前示例中的立方体，那么所有的示例中立方体都不是半透明的。</p><p><strong>给材质设置透明度：</strong></p><ol><li><p>需要给材质设置透明度</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const mat = new Three.MeshPhongMaterial({
</span></span><span style=display:flex><span>    color,
</span></span><span style=display:flex><span>    opacity: 0.4
</span></span><span style=display:flex><span>})
</span></span></code></pre></div></li><li><p>渲染器需要开启透明度渲染</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const renderer = new Three.WebGLRenderer({ 
</span></span><span style=display:flex><span>    canvas: canvasRef.current,
</span></span><span style=display:flex><span>    alpha:true,
</span></span><span style=display:flex><span>    premultipliedAlpha:false
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><blockquote><p>alpha：canvas 是否包含透明度，默认为 false</p><p>premultipliedAlpha：renderer 是否假设颜色有 premultiplied alpha (预乘alpha)，默认为 true</p></blockquote></li></ol><p><strong>针对 预乘Alpha 的补充说明：</strong></p><p>premultiplied alpha：颜色值 预乘 alpha</p><p>这是传统 3D 绘制中的一个重要概念，你可以简单理解成如下：</p><p>假设我们要表示一个 透明度为 60% 的纯红色，采用 RGBA 的方式为 (255,0,0,0.6)，通过 预乘 alpha，我们可以得到透明度为 60% 的纯红色如果放置在纯白色底上，实际上最终呈现出来的颜色和 RGB ( 255,102,102) 是完全相同的。</p><p>假设一个颜色使用 RGBA 来表示，透明度为 A、rgb 颜色为 C、纯白色(255,255,255)为 F，那么把 RGBA 转化为 RGB 的公式为：</p><p>C<em>A + ( 1-A )</em> F</p><p>也就是说 rgba(255,0,0,0.6) 转化为对应的 rgb 过程为：</p><p>(255,0,0)<em>0.6 + (1-0.6)</em> (255,255,255) = (255, 255 x 0.4, 255 x 0.4) = (255,102,102)</p><p><strong>暂时看不懂没有关系，只需记住若想让渲染器将物体渲染出半透明，除了物体本身材质配置透明度以外，还需要将渲染器中的 alpha 设置为 true 、premultipliedAlpha 设置为 false</strong></p><h2 id=设置画布为背景>设置画布为背景<a hidden class=anchor aria-hidden=true href=#设置画布为背景>#</a></h2><p>将 canvas 设置为网页背景，事实上也很简单，对应的样式：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>canvas {
</span></span><span style=display:flex><span>  position: fixed;
</span></span><span style=display:flex><span>  top: 0;
</span></span><span style=display:flex><span>  left: 0;
</span></span><span style=display:flex><span>  z-index: -1;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述 CSS 样式就让 canvas 位置固定，且层级最低，这样就成为当前网页背景了。</p><p>但是实际项目中，更加建议将 canvas 包含在一个 iframe 中后，再作为 网页的背景。</p><p>这样做有几个理由：</p><ol><li>使用 iframe 后，可以将 canvas、Three.js 的相关代码独立出来</li><li>可以多个页面都引用这个 iframe</li></ol><p><strong>iframe的相关示例：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>&lt;iframe id=&#39;background&#39; src=&#39;xxx.html&#39; &gt;
</span></span><span style=display:flex><span>&lt;div&gt;
</span></span><span style=display:flex><span>    Hello Three.js
</span></span><span style=display:flex><span>&lt;/div&gt;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>#background {
</span></span><span style=display:flex><span>    position: fixed;
</span></span><span style=display:flex><span>    width:100%;
</span></span><span style=display:flex><span>    height:100%;
</span></span><span style=display:flex><span>    left:0;
</span></span><span style=display:flex><span>    top:0;
</span></span><span style=display:flex><span>    z-index:-1;
</span></span><span style=display:flex><span>    border:none;
</span></span><span style=display:flex><span>    pointer-events:none;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上述 css 样式中：</p><ol><li>position: fixed; 可以让 iframe 位置固定</li><li>z-index: -1; 可以让 iframe 层级最低</li><li>border: none; 可以让 iframe 不显示边框</li><li>pointer-events: none; 让 iframe 永远不会成为鼠标事件的 target，意味着让 iframe 不接受鼠标交互事件</li></ol><p>关于更多 canvas 的相关用法，建议阅读 MDN 上关于 canvas 的相关文档：</p><p><a href=https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API>https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p><p>至此，关于 Three.js 的一些常用技巧讲解完毕。</p><p>接下来开始讲解 Three.js 的一些性能优化。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/18-three.js%E6%8A%80%E5%B7%A7%E4%B9%8B%E8%B0%83%E8%AF%95/><span class=title>« Prev</span><br><span>18 Three.js技巧之调试</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/20-three.js%E4%BC%98%E5%8C%96%E4%B9%8B%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1/><span class=title>Next »</span><br><span>20 Three.js优化之合并对象</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>