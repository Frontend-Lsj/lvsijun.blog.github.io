<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>15 Three.js基础之离屏渲染 | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="15 Three.js基础之离屏渲染 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/15-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/><link crossorigin=anonymous href=/assets/css/stylesheet.241265d51339977eb0f90d05780e286ec2789600ca4137f29552dec9dee06569.css integrity="sha256-JBJl1RM5l36w+Q0FeA4obsJ4lgDKQTfylVLeyd7gZWk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="15 Three.js基础之离屏渲染"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/15-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="15 Three.js基础之离屏渲染"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"15 Three.js基础之离屏渲染","item":"https://bablvsj.github.io/posts/threejs/15-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"15 Three.js基础之离屏渲染","name":"15 Three.js基础之离屏渲染","description":"","keywords":["Three.js"],"articleBody":"Render Targets(离屏渲染)简介 名词解释：Render Targets 从字面上直接翻译，“Render Targets” 应该翻译为 “渲染目标”。\n从实际作用上翻译，”Render Targets“ 应该翻译为 ”离屏渲染目标 或 离屏渲染对象“。\n国内绝大多数 Three.js 教程都把 Render Targets 翻译为 离屏渲染。\n我个人认为翻译成：离屏渲染目标 更为合适，但有时我会不自觉使用 离线渲染对象 这个词，所以你只需要明白 虽然称呼不同，但指向的都是同一个东西。\n离屏渲染概念解释 首先，我们先说一下 普通的“渲染”。\n之前示例中我们使用的渲染器都是 WebGLRenderer。我们创建的渲染器实例 renderer 会根据 场景(含场景中的物体)、灯光 来将视觉结果渲染到网页中。\n此时的 渲染 就是普通的渲染，渲染结果直接出现在网页中。\n那什么又是离屏渲染？\n答：渲染器会渲染场景，但是不会吧渲染结果直接呈现在网页中，而是把渲染结果保存到 GPU 内部中。\n此时 暂存到 GPU 中的渲染结果(图片)，可以被当做一种纹理(texture)，使用到其他物体中。\n离屏渲染 和 正常渲染 整个计算过程完全相同，不同的地方在于 离屏渲染 的结果是保存在 GPU 内存中，而非直接显示在网页中。\n离屏渲染的种类 在 Three.js 中，一共有 3 种离屏渲染类型。\n离屏渲染类型 名称及解释 WebGLMultisampleRenderTarget WebGL 2 对应的离屏渲染 WebGLRenderTarget WebGLRender 对应的离屏渲染 WebGLCubeRenderTarget CubeCamera 对应的离屏渲染 离屏渲染的用途 假设有这样一个场景：场景中有 3 个不同颜色、不停转动的立方体。\n我们之前示例中会使用 WebGLRenderer ，把这个场景画面内容渲染到网页中，这属于正常的渲染。\n若我们现在改变需求，我们希望修改成：\n场景中有一面镜子 在镜子中显示出 3 个不同颜色、不同旋转的立方体 场景本身当中，是看不见这 3 个立方体的 为了实现这个需求，我们此时就需要用到 离屏渲染。\n具体做法是：\n创建一个子场景，该子场景中 有 3 个不同颜色、不停旋转的立方体\n创建一个总场景、一个渲染器，一面镜子\n使用总场景的渲染器，对子场景进行渲染，得到一个离屏渲染结果(图像纹理)\n注意：由于是离屏渲染，只是将 3 个立方体渲染出的视觉效果保存到 GPU 内存中，网页中并不会显示出离屏渲染结果\n将离屏渲染结果作为一个纹理，作用在镜子面上\n使用总场景的渲染器，将镜子渲染到网页中\n至此，完成我们的目标。\n再试想另外一个应用场景：\n一辆汽车，汽车的倒车镜中可以显示出汽车后面的场景，这也需要用到 离线渲染。\n离屏渲染示例：HelloRenderTarget 示例目标 创建一个 “子场景”，子场景中有 光、镜头、3 个不同颜色的立方体 创建一个 “总场景”，总场景中有 光、镜头、1 个平面圆(镜子)、1个立方体 在 总场景中，控制子场景中的 3 个立方体，让他们不停旋转 通过离屏渲染，将子场景中的 “景象” 作为图片纹理，作用在镜子和立方体的6个面上 代码思路 场景搭建：\n子场景和总场景的创建过程，比较简单，不再过多讲述。\n由于子场景和总场景中都有 镜头、光、立方体这些，为了方便我们区分，也为了让我们代码更加简单清晰，所以我们会单独创建一个 scr/components/hello-render-target/render-target-scene.ts 的文件，用来创建子场景。\n注意：子场景中不需要创建渲染器\n我们说的 总场景，其实就是 HelloRenderTarget 组件本身\n子场景需要对外暴露出 场景、立方体、镜头：\nexport default { scene, boxs, camera } 总场景获取子场景中的关键元素：\nimport * as RTScene from './render-target-scene' ... const rtScene = RTScene.default.scene const rtBoxs = RTScene.default.boxs const rtCamera = RTScene.default.camera 创建离屏渲染对象\nconst rendererTarget = new Three.WebGLRenderTarget(512, 512) 请注意，上面代码中设置 离屏渲染对象的尺寸为 宽 512 像素、高 512 像素\n创建材质，并将材质纹理与离屏渲染对象的渲染结果纹理进行绑定\nconst material = new Three.MeshPhongMaterial({ map: rendererTarget.texture }) 由于离屏渲染对象的渲染出的纹理尺寸为 512 X 512，这样意味着我们应该将子场景中的镜头宽高比(aspect) 设置为 1\n同样，也意味着我们将来 总场景中的 物体(镜子和立方体) 渲染的面 宽高比 也应该是 1:1。\n若物体渲染的面 宽高比不是 1:1，那么最终渲染出的面上的图片会变形。\n修改渲染器的渲染目标，让渲染器去渲染离屏渲染对象，当渲染完成后再清除(恢复)渲染器的渲染目标\nrenderer.setRenderTarget(rendererTarget) renderer.render(rtScene, rtCamera) renderer.setRenderTarget(null) 虽然渲染器的渲染目标最终又被设置为 null，但是 离屏渲染的画面我们已经获得并保存在 rendererTarget 中。\n最终，在使用渲染器把镜子和立方体进行渲染输出\nrenderer.render(scene, camera) 至此，整个代码完成\n示例代码 子场景：\n文件位于 scr/components/hello-render-target/render-target-scene.ts\nimport * as Three from 'three' const scene = new Three.Scene() scene.background = new Three.Color(0x00FFFF) const camera = new Three.PerspectiveCamera(45, 1, 0.1, 10) camera.position.z = 10 const light = new Three.DirectionalLight(0xFFFFFF, 1) light.position.set(0, 10, 10) scene.add(light) const colors = ['blue', 'red', 'green'] const boxs: Three.Mesh[] = [] colors.forEach((color, index) =\u003e { const mat = new Three.MeshPhongMaterial({ color }) const geo = new Three.BoxBufferGeometry(2, 2, 2) const mesh = new Three.Mesh(geo, mat) mesh.position.x = (index - 1) * 3 scene.add(mesh) boxs.push(mesh) }) export default { scene, boxs, camera } 总场景(HelloRenderTarget)：\n文件位于 scr/components/hello-render-target/index.tsx\nimport { useEffect, useRef } from 'react' import * as Three from 'three' import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls' import * as RTScene from './render-target-scene' import './index.scss' const HelloRenderTarget = () =\u003e { const canvasRef = useRef(null) useEffect(() =\u003e { if (canvasRef.current === null) { return } const rtScene = RTScene.default.scene const rtBoxs = RTScene.default.boxs const rtCamera = RTScene.default.camera const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current }) const rendererTarget = new Three.WebGLRenderTarget(512, 512) const scene = new Three.Scene() scene.background = new Three.Color(0x333333) const light = new Three.DirectionalLight(0xFFFFFF, 1) light.position.set(0, 10, 10) light.target.position.set(-2, 2, 2) scene.add(light) scene.add(light.target) const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100) camera.position.z = 15 const controls = new OrbitControls(camera, canvasRef.current) controls.update() const material = new Three.MeshPhongMaterial({ map: rendererTarget.texture }) const cubeGeo = new Three.BoxBufferGeometry(4, 4, 4) const cubeMesh = new Three.Mesh(cubeGeo, material) cubeMesh.position.x = 4 scene.add(cubeMesh) const circleGeo = new Three.CircleBufferGeometry(2.8, 36) const circleMesh = new Three.Mesh(circleGeo, material) circleMesh.position.x = -4 scene.add(circleMesh) const render = (time: number) =\u003e { time *= 0.001 rtBoxs.forEach((item) =\u003e { item.rotation.set(time, time, 0) }) renderer.setRenderTarget(rendererTarget) renderer.render(rtScene, rtCamera) renderer.setRenderTarget(null) cubeMesh.rotation.set(time, time, 0) renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) const handleResize = () =\u003e { if (canvasRef.current === null) { return } const width = canvasRef.current.clientWidth const height = canvasRef.current.clientHeight camera.aspect = width / height camera.updateProjectionMatrix() renderer.setSize(width, height, false) } handleResize() window.addEventListener('resize', handleResize) return () =\u003e { window.removeEventListener('resize', handleResize) } }, [canvasRef]) return ( ) } export default HelloRenderTarget 补充一下：上面代码中关于灯光的位置、灯光目标的位置、镜头的位置、立方体的位置 都是我随手 填上的，并没有特别的含义，你完全可以适当修改一下。\n发布运行，就会在网页中看到 镜子的 1 个面、立方体的 6 个面 上 显示着 3 个不停旋转的立方体。\n补充说明1 在上述示例代码中，离线渲染目标的尺寸我设置的宽高均为 512，你完全可以设置成其他比例的值。\n但是为了画面不出现变形内容，所以要遵循以下原则：\n离线渲染目标的宽高比、子场景中镜头的宽高比、总场景中物体被渲染的面的宽高比，这 3 者要保持一致，这样就不会变形。\n假设你想在运行的过程中，修改 离线渲染目标的宽高、以及子场景中镜头的宽高比，其操作方式和修改普通的渲染器或镜头没有什么区别。例如：\nrenderTarget.setSize(newWidth,newHeight) rtCamera.aspect = newWidth/newHeight rtCamera.updateProjectionMatrix() 补充说明2：3D绘制中的 4 大数据缓冲 颜色缓冲： 像素缓冲： 深度缓冲：depth buffer 模板缓冲：stencil buffer stencilBuffer 又被称为 印模缓冲\n模板(stencil)与模板(template)的差异之处：\n单词 stencil 和 template 都可以被翻译为 模板，但是他们 2 者含义是有区别的。\n首先这 2 个单词都是来源以 印刷。\n模板(template)：形模，例如通过修剪 木板或钢板 的外形，以此外形来进行印刷\n模板(stencil)：印模，另外一种印刷技术，例如通过蜡纸来印刷\n你把 印模 与 形模 理解成 2 种 不同的印刷方式即可\n保存 渲染目标对应的 图片纹理之外，还会额外创建 颜色纹理 和 深度模板纹理 离屏渲染目标 除了得到并保存 渲染目标对应的 图片纹理之外，还会额外创建 颜色纹理 和 深度模板纹理。\n图片纹理中，就使用到了 像素缓冲\n像我们上面示例中根本就用不到 深度缓冲，那么我们可以在 离屏渲染目标初始化的时候，直接设置 不需要创建 深度缓冲 和 模板缓冲，以节省性能。\nconst rendererTarget = new Three.WebGLRenderTarget(512, 512,{ depthBuffer:false, stencilBuffer:false }) 补充说明：\ndepthBuffer：深度缓存、默认值为 true stencilBuffer：模板缓冲，默认值为 false 关于上述 补充说明2 、补充说明3 中的几个缓冲，我个人理解也不够深，不够透彻，观点仅供参考。\n至此，离线渲染 讲解完毕。\n今天是 2020年最后一天，大家元旦快乐。\n元旦过后，我们将开始学习 Three.js 基础中最后 2 个知识：自定义几何体(current Geometry)、自定义缓冲几何体(current buffer geometry)\n","wordCount":"2888","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/15-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>15 Three.js基础之离屏渲染</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>6 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#render-targets%e7%a6%bb%e5%b1%8f%e6%b8%b2%e6%9f%93%e7%ae%80%e4%bb%8b aria-label="Render Targets(离屏渲染)简介">Render Targets(离屏渲染)简介</a><ul><ul><li><a href=#%e5%90%8d%e8%af%8d%e8%a7%a3%e9%87%8arender-targets aria-label="名词解释：Render Targets">名词解释：Render Targets</a></li><li><a href=#%e7%a6%bb%e5%b1%8f%e6%b8%b2%e6%9f%93%e6%a6%82%e5%bf%b5%e8%a7%a3%e9%87%8a aria-label=离屏渲染概念解释>离屏渲染概念解释</a></li><li><a href=#%e7%a6%bb%e5%b1%8f%e6%b8%b2%e6%9f%93%e7%9a%84%e7%a7%8d%e7%b1%bb aria-label=离屏渲染的种类>离屏渲染的种类</a></li><li><a href=#%e7%a6%bb%e5%b1%8f%e6%b8%b2%e6%9f%93%e7%9a%84%e7%94%a8%e9%80%94 aria-label=离屏渲染的用途>离屏渲染的用途</a></li></ul></ul></li><li><a href=#%e7%a6%bb%e5%b1%8f%e6%b8%b2%e6%9f%93%e7%a4%ba%e4%be%8bhellorendertarget aria-label=离屏渲染示例：HelloRenderTarget>离屏渲染示例：HelloRenderTarget</a><ul><ul><li><a href=#%e7%a4%ba%e4%be%8b%e7%9b%ae%e6%a0%87 aria-label=示例目标>示例目标</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e6%80%9d%e8%b7%af aria-label=代码思路>代码思路</a></li><li><a href=#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81 aria-label=示例代码>示例代码</a></li><li><a href=#%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e1 aria-label=补充说明1>补充说明1</a></li><li><a href=#%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e23d%e7%bb%98%e5%88%b6%e4%b8%ad%e7%9a%84-4-%e5%a4%a7%e6%95%b0%e6%8d%ae%e7%bc%93%e5%86%b2 aria-label="补充说明2：3D绘制中的 4 大数据缓冲">补充说明2：3D绘制中的 4 大数据缓冲</a></li><li><a href=#%e4%bf%9d%e5%ad%98-%e6%b8%b2%e6%9f%93%e7%9b%ae%e6%a0%87%e5%af%b9%e5%ba%94%e7%9a%84-%e5%9b%be%e7%89%87%e7%ba%b9%e7%90%86%e4%b9%8b%e5%a4%96%e8%bf%98%e4%bc%9a%e9%a2%9d%e5%a4%96%e5%88%9b%e5%bb%ba-%e9%a2%9c%e8%89%b2%e7%ba%b9%e7%90%86-%e5%92%8c-%e6%b7%b1%e5%ba%a6%e6%a8%a1%e6%9d%bf%e7%ba%b9%e7%90%86 aria-label="保存 渲染目标对应的 图片纹理之外，还会额外创建 颜色纹理 和 深度模板纹理">保存 渲染目标对应的 图片纹理之外，还会额外创建 颜色纹理 和 深度模板纹理</a></li></ul></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=render-targets离屏渲染简介>Render Targets(离屏渲染)简介<a hidden class=anchor aria-hidden=true href=#render-targets离屏渲染简介>#</a></h2><h4 id=名词解释render-targets>名词解释：Render Targets<a hidden class=anchor aria-hidden=true href=#名词解释render-targets>#</a></h4><p><strong>从字面上直接翻译，“Render Targets” 应该翻译为 “渲染目标”。</strong></p><p><strong>从实际作用上翻译，”Render Targets“ 应该翻译为 ”离屏渲染目标 或 离屏渲染对象“。</strong></p><blockquote><p>国内绝大多数 Three.js 教程都把 Render Targets 翻译为 离屏渲染。</p><p>我个人认为翻译成：离屏渲染目标 更为合适，但有时我会不自觉使用 离线渲染对象 这个词，所以你只需要明白 虽然称呼不同，但指向的都是同一个东西。</p></blockquote><h4 id=离屏渲染概念解释>离屏渲染概念解释<a hidden class=anchor aria-hidden=true href=#离屏渲染概念解释>#</a></h4><p>首先，我们先说一下 普通的“渲染”。</p><p>之前示例中我们使用的渲染器都是 WebGLRenderer。我们创建的渲染器实例 renderer 会根据 场景(含场景中的物体)、灯光 来将视觉结果渲染到网页中。</p><p>此时的 渲染 就是普通的渲染，渲染结果直接出现在网页中。</p><p><strong>那什么又是离屏渲染？</strong></p><p>答：渲染器会渲染场景，但是不会吧渲染结果直接呈现在网页中，而是把渲染结果保存到 GPU 内部中。</p><p>此时 暂存到 GPU 中的渲染结果(图片)，可以被当做一种纹理(texture)，使用到其他物体中。</p><p>离屏渲染 和 正常渲染 整个计算过程完全相同，不同的地方在于 离屏渲染 的结果是保存在 GPU 内存中，而非直接显示在网页中。</p><h4 id=离屏渲染的种类>离屏渲染的种类<a hidden class=anchor aria-hidden=true href=#离屏渲染的种类>#</a></h4><p>在 Three.js 中，一共有 3 种离屏渲染类型。</p><table><thead><tr><th>离屏渲染类型</th><th>名称及解释</th></tr></thead><tbody><tr><td>WebGLMultisampleRenderTarget</td><td>WebGL 2 对应的离屏渲染</td></tr><tr><td>WebGLRenderTarget</td><td>WebGLRender 对应的离屏渲染</td></tr><tr><td>WebGLCubeRenderTarget</td><td>CubeCamera 对应的离屏渲染</td></tr></tbody></table><h4 id=离屏渲染的用途>离屏渲染的用途<a hidden class=anchor aria-hidden=true href=#离屏渲染的用途>#</a></h4><p>假设有这样一个场景：场景中有 3 个不同颜色、不停转动的立方体。</p><p>我们之前示例中会使用 WebGLRenderer ，把这个场景画面内容渲染到网页中，这属于正常的渲染。</p><p>若我们现在改变需求，我们希望修改成：</p><ol><li>场景中有一面镜子</li><li>在镜子中显示出 3 个不同颜色、不同旋转的立方体</li><li>场景本身当中，是看不见这 3 个立方体的</li></ol><p>为了实现这个需求，我们此时就需要用到 离屏渲染。</p><p>具体做法是：</p><ol><li><p>创建一个子场景，该子场景中 有 3 个不同颜色、不停旋转的立方体</p></li><li><p>创建一个总场景、一个渲染器，一面镜子</p></li><li><p>使用总场景的渲染器，对子场景进行渲染，得到一个离屏渲染结果(图像纹理)</p><blockquote><p>注意：由于是离屏渲染，只是将 3 个立方体渲染出的视觉效果保存到 GPU 内存中，网页中并不会显示出离屏渲染结果</p></blockquote></li><li><p>将离屏渲染结果作为一个纹理，作用在镜子面上</p></li><li><p>使用总场景的渲染器，将镜子渲染到网页中</p><blockquote><p>至此，完成我们的目标。</p></blockquote></li></ol><p><strong>再试想另外一个应用场景：</strong></p><p>一辆汽车，汽车的倒车镜中可以显示出汽车后面的场景，这也需要用到 离线渲染。</p><h2 id=离屏渲染示例hellorendertarget>离屏渲染示例：HelloRenderTarget<a hidden class=anchor aria-hidden=true href=#离屏渲染示例hellorendertarget>#</a></h2><h4 id=示例目标>示例目标<a hidden class=anchor aria-hidden=true href=#示例目标>#</a></h4><ol><li>创建一个 “子场景”，子场景中有 光、镜头、3 个不同颜色的立方体</li><li>创建一个 “总场景”，总场景中有 光、镜头、1 个平面圆(镜子)、1个立方体</li><li>在 总场景中，控制子场景中的 3 个立方体，让他们不停旋转</li><li>通过离屏渲染，将子场景中的 “景象” 作为图片纹理，作用在镜子和立方体的6个面上</li></ol><h4 id=代码思路>代码思路<a hidden class=anchor aria-hidden=true href=#代码思路>#</a></h4><p><strong>场景搭建：</strong></p><p>子场景和总场景的创建过程，比较简单，不再过多讲述。</p><p>由于子场景和总场景中都有 镜头、光、立方体这些，为了方便我们区分，也为了让我们代码更加简单清晰，所以我们会单独创建一个 scr/components/hello-render-target/render-target-scene.ts 的文件，用来创建子场景。</p><blockquote><p>注意：子场景中不需要创建渲染器</p></blockquote><blockquote><p>我们说的 总场景，其实就是 HelloRenderTarget 组件本身</p></blockquote><p>子场景需要对外暴露出 场景、立方体、镜头：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>export default {
</span></span><span style=display:flex><span>    scene,
</span></span><span style=display:flex><span>    boxs,
</span></span><span style=display:flex><span>    camera
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>总场景获取子场景中的关键元素：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import * as RTScene from &#39;./render-target-scene&#39;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>const rtScene = RTScene.default.scene
</span></span><span style=display:flex><span>const rtBoxs = RTScene.default.boxs
</span></span><span style=display:flex><span>const rtCamera = RTScene.default.camera
</span></span></code></pre></div><p><strong>创建离屏渲染对象</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const rendererTarget = new Three.WebGLRenderTarget(512, 512)
</span></span></code></pre></div><blockquote><p>请注意，上面代码中设置 离屏渲染对象的尺寸为 宽 512 像素、高 512 像素</p></blockquote><p><strong>创建材质，并将材质纹理与离屏渲染对象的渲染结果纹理进行绑定</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const material = new Three.MeshPhongMaterial({
</span></span><span style=display:flex><span>    map: rendererTarget.texture
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><blockquote><p>由于离屏渲染对象的渲染出的纹理尺寸为 512 X 512，这样意味着我们应该将子场景中的镜头宽高比(aspect) 设置为 1</p></blockquote><blockquote><p>同样，也意味着我们将来 总场景中的 物体(镜子和立方体) 渲染的面 宽高比 也应该是 1:1。</p><p>若物体渲染的面 宽高比不是 1:1，那么最终渲染出的面上的图片会变形。</p></blockquote><p><strong>修改渲染器的渲染目标，让渲染器去渲染离屏渲染对象，当渲染完成后再清除(恢复)渲染器的渲染目标</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>renderer.setRenderTarget(rendererTarget)
</span></span><span style=display:flex><span>renderer.render(rtScene, rtCamera)
</span></span><span style=display:flex><span>renderer.setRenderTarget(null)
</span></span></code></pre></div><blockquote><p>虽然渲染器的渲染目标最终又被设置为 null，但是 离屏渲染的画面我们已经获得并保存在 rendererTarget 中。</p></blockquote><p><strong>最终，在使用渲染器把镜子和立方体进行渲染输出</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>renderer.render(scene, camera)
</span></span></code></pre></div><blockquote><p>至此，整个代码完成</p></blockquote><h4 id=示例代码>示例代码<a hidden class=anchor aria-hidden=true href=#示例代码>#</a></h4><p><strong>子场景：</strong></p><p>文件位于 scr/components/hello-render-target/render-target-scene.ts</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const scene = new Three.Scene()
</span></span><span style=display:flex><span>scene.background = new Three.Color(0x00FFFF)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const camera = new Three.PerspectiveCamera(45, 1, 0.1, 10)
</span></span><span style=display:flex><span>camera.position.z = 10
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const light = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>light.position.set(0, 10, 10)
</span></span><span style=display:flex><span>scene.add(light)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const colors = [&#39;blue&#39;, &#39;red&#39;, &#39;green&#39;]
</span></span><span style=display:flex><span>const boxs: Three.Mesh[] = []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>colors.forEach((color, index) =&gt; {
</span></span><span style=display:flex><span>    const mat = new Three.MeshPhongMaterial({ color })
</span></span><span style=display:flex><span>    const geo = new Three.BoxBufferGeometry(2, 2, 2)
</span></span><span style=display:flex><span>    const mesh = new Three.Mesh(geo, mat)
</span></span><span style=display:flex><span>    mesh.position.x = (index - 1) * 3
</span></span><span style=display:flex><span>    scene.add(mesh)
</span></span><span style=display:flex><span>    boxs.push(mesh)
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default {
</span></span><span style=display:flex><span>    scene,
</span></span><span style=display:flex><span>    boxs,
</span></span><span style=display:flex><span>    camera
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>总场景(HelloRenderTarget)：</strong></p><p>文件位于 scr/components/hello-render-target/index.tsx</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useEffect, useRef } from &#39;react&#39;
</span></span><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>import { OrbitControls } from &#39;three/examples/jsm/controls/OrbitControls&#39;
</span></span><span style=display:flex><span>import * as RTScene from &#39;./render-target-scene&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloRenderTarget = () =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current === null) {
</span></span><span style=display:flex><span>            return
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const rtScene = RTScene.default.scene
</span></span><span style=display:flex><span>        const rtBoxs = RTScene.default.boxs
</span></span><span style=display:flex><span>        const rtCamera = RTScene.default.camera
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current })
</span></span><span style=display:flex><span>        const rendererTarget = new Three.WebGLRenderTarget(512, 512)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const scene = new Three.Scene()
</span></span><span style=display:flex><span>        scene.background = new Three.Color(0x333333)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const light = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>        light.position.set(0, 10, 10)
</span></span><span style=display:flex><span>        light.target.position.set(-2, 2, 2)
</span></span><span style=display:flex><span>        scene.add(light)
</span></span><span style=display:flex><span>        scene.add(light.target)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const camera = new Three.PerspectiveCamera(45, 2, 0.1, 100)
</span></span><span style=display:flex><span>        camera.position.z = 15
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const controls = new OrbitControls(camera, canvasRef.current)
</span></span><span style=display:flex><span>        controls.update()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const material = new Three.MeshPhongMaterial({
</span></span><span style=display:flex><span>            map: rendererTarget.texture
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const cubeGeo = new Three.BoxBufferGeometry(4, 4, 4)
</span></span><span style=display:flex><span>        const cubeMesh = new Three.Mesh(cubeGeo, material)
</span></span><span style=display:flex><span>        cubeMesh.position.x = 4
</span></span><span style=display:flex><span>        scene.add(cubeMesh)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const circleGeo = new Three.CircleBufferGeometry(2.8, 36)
</span></span><span style=display:flex><span>        const circleMesh = new Three.Mesh(circleGeo, material)
</span></span><span style=display:flex><span>        circleMesh.position.x = -4
</span></span><span style=display:flex><span>        scene.add(circleMesh)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>            time *= 0.001
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            rtBoxs.forEach((item) =&gt; {
</span></span><span style=display:flex><span>                item.rotation.set(time, time, 0)
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            renderer.setRenderTarget(rendererTarget)
</span></span><span style=display:flex><span>            renderer.render(rtScene, rtCamera)
</span></span><span style=display:flex><span>            renderer.setRenderTarget(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cubeMesh.rotation.set(time, time, 0)
</span></span><span style=display:flex><span>            renderer.render(scene, camera)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const handleResize = () =&gt; {
</span></span><span style=display:flex><span>            if (canvasRef.current === null) {
</span></span><span style=display:flex><span>                return
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            const width = canvasRef.current.clientWidth
</span></span><span style=display:flex><span>            const height = canvasRef.current.clientHeight
</span></span><span style=display:flex><span>            camera.aspect = width / height
</span></span><span style=display:flex><span>            camera.updateProjectionMatrix()
</span></span><span style=display:flex><span>            renderer.setSize(width, height, false)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        handleResize()
</span></span><span style=display:flex><span>        window.addEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            window.removeEventListener(&#39;resize&#39;, handleResize)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloRenderTarget
</span></span></code></pre></div><blockquote><p>补充一下：上面代码中关于灯光的位置、灯光目标的位置、镜头的位置、立方体的位置 都是我随手 填上的，并没有特别的含义，你完全可以适当修改一下。</p></blockquote><p>发布运行，就会在网页中看到 镜子的 1 个面、立方体的 6 个面 上 显示着 3 个不停旋转的立方体。</p><h4 id=补充说明1>补充说明1<a hidden class=anchor aria-hidden=true href=#补充说明1>#</a></h4><p>在上述示例代码中，离线渲染目标的尺寸我设置的宽高均为 512，你完全可以设置成其他比例的值。</p><p>但是为了画面不出现变形内容，所以要遵循以下原则：</p><p><strong>离线渲染目标的宽高比、子场景中镜头的宽高比、总场景中物体被渲染的面的宽高比，这 3 者要保持一致，这样就不会变形。</strong></p><p>假设你想在运行的过程中，修改 离线渲染目标的宽高、以及子场景中镜头的宽高比，其操作方式和修改普通的渲染器或镜头没有什么区别。例如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>renderTarget.setSize(newWidth,newHeight)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rtCamera.aspect = newWidth/newHeight
</span></span><span style=display:flex><span>rtCamera.updateProjectionMatrix()
</span></span></code></pre></div><h4 id=补充说明23d绘制中的-4-大数据缓冲>补充说明2：3D绘制中的 4 大数据缓冲<a hidden class=anchor aria-hidden=true href=#补充说明23d绘制中的-4-大数据缓冲>#</a></h4><ol><li>颜色缓冲：</li><li>像素缓冲：</li><li>深度缓冲：depth buffer</li><li>模板缓冲：stencil buffer</li></ol><blockquote><p>stencilBuffer 又被称为 印模缓冲</p></blockquote><p><strong>模板(stencil)与模板(template)的差异之处：</strong></p><p>单词 stencil 和 template 都可以被翻译为 模板，但是他们 2 者含义是有区别的。</p><p>首先这 2 个单词都是来源以 印刷。</p><ol><li><p>模板(template)：形模，例如通过修剪 木板或钢板 的外形，以此外形来进行印刷</p></li><li><p>模板(stencil)：印模，另外一种印刷技术，例如通过蜡纸来印刷</p><blockquote><p>你把 印模 与 形模 理解成 2 种 不同的印刷方式即可</p></blockquote></li></ol><h4 id=保存-渲染目标对应的-图片纹理之外还会额外创建-颜色纹理-和-深度模板纹理>保存 渲染目标对应的 图片纹理之外，还会额外创建 颜色纹理 和 深度模板纹理<a hidden class=anchor aria-hidden=true href=#保存-渲染目标对应的-图片纹理之外还会额外创建-颜色纹理-和-深度模板纹理>#</a></h4><p>离屏渲染目标 除了得到并保存 渲染目标对应的 图片纹理之外，还会额外创建 颜色纹理 和 深度模板纹理。</p><blockquote><p>图片纹理中，就使用到了 像素缓冲</p></blockquote><p>像我们上面示例中根本就用不到 深度缓冲，那么我们可以在 离屏渲染目标初始化的时候，直接设置 不需要创建 深度缓冲 和 模板缓冲，以节省性能。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const rendererTarget = new Three.WebGLRenderTarget(512, 512,{
</span></span><span style=display:flex><span>    depthBuffer:false,
</span></span><span style=display:flex><span>    stencilBuffer:false
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p><strong>补充说明：</strong></p><ol><li>depthBuffer：深度缓存、默认值为 true</li><li>stencilBuffer：模板缓冲，默认值为 false</li></ol><blockquote><p>关于上述 补充说明2 、补充说明3 中的几个缓冲，我个人理解也不够深，不够透彻，观点仅供参考。</p></blockquote><p>至此，离线渲染 讲解完毕。</p><p>今天是 2020年最后一天，大家元旦快乐。</p><p>元旦过后，我们将开始学习 Three.js 基础中最后 2 个知识：自定义几何体(current Geometry)、自定义缓冲几何体(current buffer geometry)</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/14-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%9B%BE/><span class=title>« Prev</span><br><span>14 Three.js基础之雾</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/16-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E5%87%A0%E4%BD%95%E4%BD%93/><span class=title>Next »</span><br><span>16 Three.js基础之自定义几何体</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>