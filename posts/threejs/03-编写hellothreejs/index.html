<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>03 编写HelloThreejs | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="03 编写HelloThreejs - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/03-%E7%BC%96%E5%86%99hellothreejs/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="03 编写HelloThreejs"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/03-%E7%BC%96%E5%86%99hellothreejs/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="03 编写HelloThreejs"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"03 编写HelloThreejs","item":"https://bablvsj.github.io/posts/threejs/03-%E7%BC%96%E5%86%99hellothreejs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"03 编写HelloThreejs","name":"03 编写HelloThreejs","description":"","keywords":["Three.js"],"articleBody":"终于要真正第一次亲密接触 Three.js 了。\n我们先梳理一下创建一个 Three.js 示例所需要的过程，认真阅读并理解整个过程，会更加容易让你读懂我后面的示例代码。\n从引入Three到创建示例的过程 第1环节：引入Three.js 引入方式1：将 THREE 一次全部引入\nimport THREE from 'three' //当需要使用某个具体的模块时，例如创建场景，则代码如下 const scene = new THREE.Scene() 这种方式会将所有 Three.js 相关模块都引入进来，虽然引入代码简介，但是会造成项目打包输出时文件过大，因此并不建议这样引入。\n请注意：默认 three 模块导出的名字就是全部大写的 “THREE”。我个人非常不习惯 模块名称 全部大写，我的代码习惯是使用 “Three”。\nimport * as Three from 'three' const scene = new Three.Scene() 本系列文章中使用的示例，代码绝大多数都采用这种引入形式，使用 Three 而 不使用 THREE。\n所以网上一些教程中可能描述某个类时使用的是 THREE.Xxxx，而我在本系列文章中都会使用 Three.Xxxx 这种方式。\n引入方式2：按需引入模块\n例如我们需要使用 Scene 模块，则仅引入该模块即可\nimport { Scene } from 'three' //当需要使用某个具体的模块时，例如创建场景，则代码如下 const scene = new Scene() 本文示例代码，都将采用按需引入的方式。\n第2环节：将DOM中的canvas与Threejs中的渲染器进行挂钩 采用 React 的 useEffect + useRef 来实现所谓 “挂钩” 。\n具体参见示例代码\n第3环节：创建Three.js基础3大元素、场景可见元素 基础3大元素：\n渲染器 \u003e 本文示例采用的渲染器是 WebGLRenderer 透视镜头 \u003e 本文示例采用的是 PerspectiveCamera 场景 \u003e Scen 场景可见元素：\n几何体 \u003e 本文示例采用的是 BoxGeometry(立方体) 几何体的材质(颜色、光亮程度) \u003e 本文示例采用的是 MeshBasicMaterial 或 MeshPhongMaterial 网格 \u003e Mesh 光源 \u003e 本文示例采用的是 DirectionalLight(平行光源) 补充说明：\n你应该发现，除了 场景(Scen)、网格(Mesh) 之外，其他的元素我都注明 “本文示例采用的是…”。\n因为无论渲染器，还是几何体，以及其他元素，Three.js 都内置了非常多不同种类的元素构造函数，这个会在以后学习中逐渐详细说明举例。\n第4环节：使用渲染器渲染出画面 渲染画面\n就是根据第3环节中所创建出的 3D 场景，渲染出画面，并将画面内容填充到 canvas 中。\n本文示例中，为了呈现 3D 动画，使用到了浏览器中 window.requestAnimationFrame() 这个函数。\n关于 window.requestAnimationFrame() 的用法请参考：https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame\n补充说明：3D动画是怎么动起来的？ 默认情况下，渲染出的 3D 场景都是静止的，所谓 3D 动画，本质上是因为 “场景” 上发生了 “变化” 被渲染器不断重新渲染。\n引起这些所谓 “变化”，简单可归纳为以下几种原因：\n镜头不变，但可见场景元素发生了变化，例如几何体发生了变化、网格角度发生了变化等 可见场景元素不变，但是镜头发生了变化，例如镜头的推近、拉远等 镜头变化了，同时场景元素也变化了…… 示例代码 第1步：创建并编写index.tsx代码内容 在 src/components/hello-threejs 目录下，创建 index.tsx 作为我们自定义的组件。\n编写该组件对应的代码内容：\nimport React, { useRef, useEffect } from 'react' import { WebGLRenderer, PerspectiveCamera, Scene, BoxGeometry, Mesh, DirectionalLight, MeshPhongMaterial } from 'three' const HelloThreejs: React.FC = () =\u003e { const canvasRef = useRef(null) useEffect(() =\u003e { if (canvasRef.current) { //创建渲染器 const renderer = new WebGLRenderer({ canvas: canvasRef.current }) //创建镜头 //PerspectiveCamera() 中的 4 个参数分别为： //1、fov(field of view 的缩写)，可选参数，默认值为 50，指垂直方向上的角度，注意该值是度数而不是弧度 //2、aspect，可选参数，默认值为 1，画布的宽高比(宽/高)，例如画布宽300像素，高150像素，那么意味着宽高比为 2 //3、near，可选参数，默认值为 0.1，近平面，限制摄像机可绘制最近的距离，若小于该距离则不会绘制(相当于被裁切掉) //4、far，可选参数，默认值为 2000，远平面，限制摄像机可绘制最远的距离，若超出该距离则不会绘制(相当于被裁切掉) //以上 4 个参数在一起，构成了一个 “视椎”，关于视椎的概念理解，暂时先不作详细描述。 const camera = new PerspectiveCamera(75, 2, 0.1, 5) //创建场景 const scene = new Scene() //创建几何体 const geometry = new BoxGeometry(1, 1, 1) //创建材质 //我们需要让立方体能够反射光，所以不使用MeshBasicMaterial，而是改用MeshPhongMaterial //const material = new MeshBasicMaterial({ color: 0x44aa88 }) const material = new MeshPhongMaterial({ color: 0x44aa88 }) //创建网格 const cube = new Mesh(geometry, material) scene.add(cube)//将网格添加到场景中 //创建光源 const light = new DirectionalLight(0xFFFFFF, 1) light.position.set(-1, 2, 4) scene.add(light)//将光源添加到场景中，若场景中没有任何光源，则可反光材质的物体渲染出的结果是一片漆黑，什么也看不见 //设置透视镜头的Z轴距离，以便我们以某个距离来观察几何体 //之前初始化透视镜头时，设置的近平面为 0.1，远平面为 5 //因此 camera.position.z 的值一定要在 0.1 - 5 的范围内，超出这个范围则画面不会被渲染 camera.position.z = 2 //渲染器根据场景、透视镜头来渲染画面，并将该画面内容填充到 DOM 的 canvas 元素中 //renderer.render(scene, camera)//由于后面我们添加了自动渲染渲染动画，所以此处的渲染可以注释掉 //添加自动旋转渲染动画 const render = (time: number) =\u003e { time = time * 0.001 //原本 time 为毫秒，我们这里对 time 进行转化，修改成 秒，以便于我们动画旋转角度的递增 cube.rotation.x = time cube.rotation.y = time renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) } }, [canvasRef]) return ( ) } export default HelloThreejs 第2步：添加对HelloThreejs组件的使用 修改 src/app.tsx 对应的代码：\nimport './App.scss' import HelloThreejs from '@/components/hello-threejs'; const App = () =\u003e { return ( ) } export default App; 第3步：查看运行效果 yarn start 若无意外，你会在浏览器中看到一个 高150像素，宽300像素的 黑色场景，该场景上一直有一个 3D 立方体在旋转。\n至此，我们的第一个 Three.js 示例完成。\n如何让场景有多个立方体？ 首先回忆一下 “01 Three.js简介.md” 中 “Three.js中的技术名词” 中关于 网格的介绍。\n网格：一种特定的 几何体和材质 绘制出的一个特定的几何体系。\n网格包含的内容为：几何体、几何体的材质、几何体的自身网格坐标体系\n在 Three.js 中，要牢记以下几个概念：\n一个几何体或材质，可以同时被多个网格使用(引用) 一个场景内，可以添加多个网格 那和让场景中有多个立方体？\n答：使用相同或不同的几何体(立方体)，以及相同或不同的材质，去创建多个网格(特定的几何体)，然后将多个网格添加到同一个场景中。\n注意：为了不同的立方体在场景中不叠加在一起，所以我们还要将网格(特定的几何体)的位置设置成不同的值。\n具体代码的修改 1、我们假定继续使用原有示例中的立方体，因此创建几何体的代码不变。\n2、为了凸显立方体的区别，我们将创建 3 个不同颜色的材质。\n- //创建纹理 - const material = new MeshBasicMaterial({ color: 0x44aa88 }) + //创建 3 个纹理 + const material1 = new MeshPhongMaterial({ color: 0x44aa88 }) + const material2 = new MeshPhongMaterial({ color: 0xc50d0d }) + const material3 = new MeshPhongMaterial({ color: 0x39b20a }) 3、创建 3 个网格，每个网格的水平位置不同\n- //创建网格 - const cube = new Mesh(geometry, material)~~ - scene.add(cube) + //创建 3 个网格 + const cube1 = new Mesh(geometry, material1) + cube1.position.x = -2 + scene.add(cube1)//将网格添加到场景中 + const cube2 = new Mesh(geometry, material2) + cube2.position.x = 0 + scene.add(cube2)//将网格添加到场景中 + const cube3 = new Mesh(geometry, material3) + cube3.position.x = 2 + scene.add(cube3)//将网格添加到场景中 4、为了便于后面对于不同网格的循环修改，我们将创建包含 3 个网格的一个数组\nconst cubes = [cube1, cube2, cube3] 5、修改自动旋转渲染动画的相关代码\n- cube.rotation.x = time - cube.rotation.y = time + //通过 cube.map 循环遍历修改网格相关属性 + cubes.map(cube =\u003e { + cube.rotation.x = time + cube.rotation.y = time + }) 6、保存并重新执行 yarn start，若一切正常此时就会看到 画面中有 3 个不同颜色的立方体同时在做旋转动画。\n目前 3 个立方体仅仅是颜色和位置不同，你可以尝试将立方体设置为不同的尺寸，不同的旋转频率等等，自己发挥吧。\n是不是感觉自己对 Three.js 场景有进一步有所掌握 ^_^。\n下一节，我们将进一步改进这个示例代码。\n","wordCount":"3039","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/03-%E7%BC%96%E5%86%99hellothreejs/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>03 编写HelloThreejs</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>7 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e4%bb%8e%e5%bc%95%e5%85%a5three%e5%88%b0%e5%88%9b%e5%bb%ba%e7%a4%ba%e4%be%8b%e7%9a%84%e8%bf%87%e7%a8%8b aria-label=从引入Three到创建示例的过程>从引入Three到创建示例的过程</a><ul><li><a href=#%e7%ac%ac1%e7%8e%af%e8%8a%82%e5%bc%95%e5%85%a5threejs aria-label=第1环节：引入Three.js>第1环节：引入Three.js</a></li><li><a href=#%e7%ac%ac2%e7%8e%af%e8%8a%82%e5%b0%86dom%e4%b8%ad%e7%9a%84canvas%e4%b8%8ethreejs%e4%b8%ad%e7%9a%84%e6%b8%b2%e6%9f%93%e5%99%a8%e8%bf%9b%e8%a1%8c%e6%8c%82%e9%92%a9 aria-label=第2环节：将DOM中的canvas与Threejs中的渲染器进行挂钩>第2环节：将DOM中的canvas与Threejs中的渲染器进行挂钩</a></li><li><a href=#%e7%ac%ac3%e7%8e%af%e8%8a%82%e5%88%9b%e5%bb%bathreejs%e5%9f%ba%e7%a1%803%e5%a4%a7%e5%85%83%e7%b4%a0%e5%9c%ba%e6%99%af%e5%8f%af%e8%a7%81%e5%85%83%e7%b4%a0 aria-label=第3环节：创建Three.js基础3大元素、场景可见元素>第3环节：创建Three.js基础3大元素、场景可见元素</a></li><li><a href=#%e7%ac%ac4%e7%8e%af%e8%8a%82%e4%bd%bf%e7%94%a8%e6%b8%b2%e6%9f%93%e5%99%a8%e6%b8%b2%e6%9f%93%e5%87%ba%e7%94%bb%e9%9d%a2 aria-label=第4环节：使用渲染器渲染出画面>第4环节：使用渲染器渲染出画面</a></li><li><a href=#%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e3d%e5%8a%a8%e7%94%bb%e6%98%af%e6%80%8e%e4%b9%88%e5%8a%a8%e8%b5%b7%e6%9d%a5%e7%9a%84 aria-label=补充说明：3D动画是怎么动起来的？>补充说明：3D动画是怎么动起来的？</a></li></ul></li><li><a href=#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81 aria-label=示例代码>示例代码</a><ul><ul><li><a href=#%e7%ac%ac1%e6%ad%a5%e5%88%9b%e5%bb%ba%e5%b9%b6%e7%bc%96%e5%86%99indextsx%e4%bb%a3%e7%a0%81%e5%86%85%e5%ae%b9 aria-label=第1步：创建并编写index.tsx代码内容>第1步：创建并编写index.tsx代码内容</a></li><li><a href=#%e7%ac%ac2%e6%ad%a5%e6%b7%bb%e5%8a%a0%e5%af%b9hellothreejs%e7%bb%84%e4%bb%b6%e7%9a%84%e4%bd%bf%e7%94%a8 aria-label=第2步：添加对HelloThreejs组件的使用>第2步：添加对HelloThreejs组件的使用</a></li><li><a href=#%e7%ac%ac3%e6%ad%a5%e6%9f%a5%e7%9c%8b%e8%bf%90%e8%a1%8c%e6%95%88%e6%9e%9c aria-label=第3步：查看运行效果>第3步：查看运行效果</a></li></ul></ul></li><li><a href=#%e5%a6%82%e4%bd%95%e8%ae%a9%e5%9c%ba%e6%99%af%e6%9c%89%e5%a4%9a%e4%b8%aa%e7%ab%8b%e6%96%b9%e4%bd%93 aria-label=如何让场景有多个立方体？>如何让场景有多个立方体？</a><ul><ul><li><a href=#%e5%85%b7%e4%bd%93%e4%bb%a3%e7%a0%81%e7%9a%84%e4%bf%ae%e6%94%b9 aria-label=具体代码的修改>具体代码的修改</a></li></ul></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>终于要真正第一次亲密接触 Three.js 了。</p><p>我们先梳理一下创建一个 Three.js 示例所需要的过程，认真阅读并理解整个过程，会更加容易让你读懂我后面的示例代码。</p><h2 id=从引入three到创建示例的过程>从引入Three到创建示例的过程<a hidden class=anchor aria-hidden=true href=#从引入three到创建示例的过程>#</a></h2><h3 id=第1环节引入threejs>第1环节：引入Three.js<a hidden class=anchor aria-hidden=true href=#第1环节引入threejs>#</a></h3><p><strong>引入方式1：将 THREE 一次全部引入</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import THREE from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//当需要使用某个具体的模块时，例如创建场景，则代码如下
</span></span><span style=display:flex><span>const scene = new THREE.Scene()
</span></span></code></pre></div><blockquote><p>这种方式会将所有 Three.js 相关模块都引入进来，虽然引入代码简介，但是会造成项目打包输出时文件过大，因此并不建议这样引入。</p></blockquote><p><strong>请注意：默认 three 模块导出的名字就是全部大写的 “THREE”。我个人非常不习惯 模块名称 全部大写，我的代码习惯是使用 “Three”。</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const scene = new Three.Scene()
</span></span></code></pre></div><blockquote><p><strong>本系列文章中使用的示例，代码绝大多数都采用这种引入形式，使用 Three 而 不使用 THREE。<br>所以网上一些教程中可能描述某个类时使用的是 THREE.Xxxx，而我在本系列文章中都会使用 Three.Xxxx 这种方式。</strong></p></blockquote><p><strong>引入方式2：按需引入模块</strong></p><p>例如我们需要使用 Scene 模块，则仅引入该模块即可</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { Scene } from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//当需要使用某个具体的模块时，例如创建场景，则代码如下
</span></span><span style=display:flex><span>const scene = new Scene()
</span></span></code></pre></div><blockquote><p>本文示例代码，都将采用按需引入的方式。</p></blockquote><h3 id=第2环节将dom中的canvas与threejs中的渲染器进行挂钩>第2环节：将DOM中的canvas与Threejs中的渲染器进行挂钩<a hidden class=anchor aria-hidden=true href=#第2环节将dom中的canvas与threejs中的渲染器进行挂钩>#</a></h3><p><strong>采用 React 的 useEffect + useRef 来实现所谓 “挂钩” 。</strong></p><blockquote><p>具体参见示例代码</p></blockquote><h3 id=第3环节创建threejs基础3大元素场景可见元素>第3环节：创建Three.js基础3大元素、场景可见元素<a hidden class=anchor aria-hidden=true href=#第3环节创建threejs基础3大元素场景可见元素>#</a></h3><p><strong>基础3大元素：</strong></p><ol><li>渲染器 > 本文示例采用的渲染器是 WebGLRenderer</li><li>透视镜头 > 本文示例采用的是 PerspectiveCamera</li><li>场景 > Scen</li></ol><p><strong>场景可见元素：</strong></p><ol><li>几何体 > 本文示例采用的是 BoxGeometry(立方体)</li><li>几何体的材质(颜色、光亮程度) > 本文示例采用的是 MeshBasicMaterial 或 MeshPhongMaterial</li><li>网格 > Mesh</li><li>光源 > 本文示例采用的是 DirectionalLight(平行光源)</li></ol><p><strong>补充说明：</strong></p><p>你应该发现，除了 场景(Scen)、网格(Mesh) 之外，其他的元素我都注明 “本文示例采用的是&mldr;”。</p><p>因为无论渲染器，还是几何体，以及其他元素，Three.js 都内置了非常多不同种类的元素构造函数，这个会在以后学习中逐渐详细说明举例。</p><h3 id=第4环节使用渲染器渲染出画面>第4环节：使用渲染器渲染出画面<a hidden class=anchor aria-hidden=true href=#第4环节使用渲染器渲染出画面>#</a></h3><p><strong>渲染画面</strong></p><p>就是根据第3环节中所创建出的 3D 场景，渲染出画面，并将画面内容填充到 canvas 中。</p><p>本文示例中，为了呈现 3D 动画，使用到了浏览器中 window.requestAnimationFrame() 这个函数。</p><blockquote><p>关于 window.requestAnimationFrame() 的用法请参考：<a href=https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame>https://developer.mozilla.org/zh-CN/docs/Web/API/window/requestAnimationFrame</a></p></blockquote><h3 id=补充说明3d动画是怎么动起来的>补充说明：3D动画是怎么动起来的？<a hidden class=anchor aria-hidden=true href=#补充说明3d动画是怎么动起来的>#</a></h3><p>默认情况下，渲染出的 3D 场景都是静止的，所谓 3D 动画，本质上是因为 “场景” 上发生了 “变化” 被渲染器不断重新渲染。</p><p>引起这些所谓 “变化”，简单可归纳为以下几种原因：</p><ol><li>镜头不变，但可见场景元素发生了变化，例如几何体发生了变化、网格角度发生了变化等</li><li>可见场景元素不变，但是镜头发生了变化，例如镜头的推近、拉远等</li><li>镜头变化了，同时场景元素也变化了&mldr;&mldr;</li></ol><h2 id=示例代码>示例代码<a hidden class=anchor aria-hidden=true href=#示例代码>#</a></h2><h4 id=第1步创建并编写indextsx代码内容>第1步：创建并编写index.tsx代码内容<a hidden class=anchor aria-hidden=true href=#第1步创建并编写indextsx代码内容>#</a></h4><p>在 src/components/hello-threejs 目录下，创建 index.tsx 作为我们自定义的组件。</p><p>编写该组件对应的代码内容：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import React, { useRef, useEffect } from &#39;react&#39;
</span></span><span style=display:flex><span>import { WebGLRenderer, PerspectiveCamera, Scene, BoxGeometry, Mesh, DirectionalLight, MeshPhongMaterial } from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloThreejs: React.FC = () =&gt; {
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        if (canvasRef.current) {
</span></span><span style=display:flex><span>            //创建渲染器
</span></span><span style=display:flex><span>            const renderer = new WebGLRenderer({ canvas: canvasRef.current })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建镜头
</span></span><span style=display:flex><span>            //PerspectiveCamera() 中的 4 个参数分别为：
</span></span><span style=display:flex><span>            //1、fov(field of view 的缩写)，可选参数，默认值为 50，指垂直方向上的角度，注意该值是度数而不是弧度
</span></span><span style=display:flex><span>            //2、aspect，可选参数，默认值为 1，画布的宽高比(宽/高)，例如画布宽300像素，高150像素，那么意味着宽高比为 2
</span></span><span style=display:flex><span>            //3、near，可选参数，默认值为 0.1，近平面，限制摄像机可绘制最近的距离，若小于该距离则不会绘制(相当于被裁切掉)
</span></span><span style=display:flex><span>            //4、far，可选参数，默认值为 2000，远平面，限制摄像机可绘制最远的距离，若超出该距离则不会绘制(相当于被裁切掉)
</span></span><span style=display:flex><span>            //以上 4 个参数在一起，构成了一个 “视椎”，关于视椎的概念理解，暂时先不作详细描述。
</span></span><span style=display:flex><span>            const camera = new PerspectiveCamera(75, 2, 0.1, 5)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建场景
</span></span><span style=display:flex><span>            const scene = new Scene()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建几何体
</span></span><span style=display:flex><span>            const geometry = new BoxGeometry(1, 1, 1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建材质
</span></span><span style=display:flex><span>            //我们需要让立方体能够反射光，所以不使用MeshBasicMaterial，而是改用MeshPhongMaterial
</span></span><span style=display:flex><span>            //const material = new MeshBasicMaterial({ color: 0x44aa88 })
</span></span><span style=display:flex><span>            const material = new MeshPhongMaterial({ color: 0x44aa88 })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建网格
</span></span><span style=display:flex><span>            const cube = new Mesh(geometry, material)
</span></span><span style=display:flex><span>            scene.add(cube)//将网格添加到场景中
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建光源
</span></span><span style=display:flex><span>            const light = new DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>            light.position.set(-1, 2, 4)
</span></span><span style=display:flex><span>            scene.add(light)//将光源添加到场景中，若场景中没有任何光源，则可反光材质的物体渲染出的结果是一片漆黑，什么也看不见
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //设置透视镜头的Z轴距离，以便我们以某个距离来观察几何体
</span></span><span style=display:flex><span>            //之前初始化透视镜头时，设置的近平面为 0.1，远平面为 5
</span></span><span style=display:flex><span>            //因此 camera.position.z 的值一定要在 0.1 - 5 的范围内，超出这个范围则画面不会被渲染
</span></span><span style=display:flex><span>            camera.position.z = 2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //渲染器根据场景、透视镜头来渲染画面，并将该画面内容填充到 DOM 的 canvas 元素中
</span></span><span style=display:flex><span>            //renderer.render(scene, camera)//由于后面我们添加了自动渲染渲染动画，所以此处的渲染可以注释掉
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //添加自动旋转渲染动画
</span></span><span style=display:flex><span>            const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>                time = time * 0.001 //原本 time 为毫秒，我们这里对 time 进行转化，修改成 秒，以便于我们动画旋转角度的递增
</span></span><span style=display:flex><span>                cube.rotation.x = time
</span></span><span style=display:flex><span>                cube.rotation.y = time
</span></span><span style=display:flex><span>                renderer.render(scene, camera)
</span></span><span style=display:flex><span>                window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;canvas ref={canvasRef} /&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloThreejs
</span></span></code></pre></div><h4 id=第2步添加对hellothreejs组件的使用>第2步：添加对HelloThreejs组件的使用<a hidden class=anchor aria-hidden=true href=#第2步添加对hellothreejs组件的使用>#</a></h4><p>修改 src/app.tsx 对应的代码：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import &#39;./App.scss&#39;
</span></span><span style=display:flex><span>import HelloThreejs from &#39;@/components/hello-threejs&#39;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const App = () =&gt; {
</span></span><span style=display:flex><span>  return (
</span></span><span style=display:flex><span>    &lt;HelloThreejs /&gt;
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default App;
</span></span></code></pre></div><h4 id=第3步查看运行效果>第3步：查看运行效果<a hidden class=anchor aria-hidden=true href=#第3步查看运行效果>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>yarn start
</span></span></code></pre></div><p>若无意外，你会在浏览器中看到一个 高150像素，宽300像素的 黑色场景，该场景上一直有一个 3D 立方体在旋转。</p><p>至此，我们的第一个 Three.js 示例完成。</p><h2 id=如何让场景有多个立方体>如何让场景有多个立方体？<a hidden class=anchor aria-hidden=true href=#如何让场景有多个立方体>#</a></h2><p>首先回忆一下 &ldquo;01 Three.js简介.md&rdquo; 中 “Three.js中的技术名词” 中关于 网格的介绍。</p><p><strong>网格：一种特定的 几何体和材质 绘制出的一个特定的几何体系。</strong></p><p><strong>网格包含的内容为：几何体、几何体的材质、几何体的自身网格坐标体系</strong></p><p><strong>在 Three.js 中，要牢记以下几个概念：</strong></p><ul><li>一个几何体或材质，可以同时被多个网格使用(引用)</li><li>一个场景内，可以添加多个网格</li></ul><p><strong>那和让场景中有多个立方体？</strong></p><p>答：使用相同或不同的几何体(立方体)，以及相同或不同的材质，去创建多个网格(特定的几何体)，然后将多个网格添加到同一个场景中。</p><blockquote><p>注意：为了不同的立方体在场景中不叠加在一起，所以我们还要将网格(特定的几何体)的位置设置成不同的值。</p></blockquote><h4 id=具体代码的修改>具体代码的修改<a hidden class=anchor aria-hidden=true href=#具体代码的修改>#</a></h4><p>1、我们假定继续使用原有示例中的立方体，因此创建几何体的代码不变。</p><p>2、为了凸显立方体的区别，我们将创建 3 个不同颜色的材质。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- //创建纹理
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- const material = new MeshBasicMaterial({ color: 0x44aa88 })
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006></span>
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ //创建 3 个纹理
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ const material1 = new MeshPhongMaterial({ color: 0x44aa88 })
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ const material2 = new MeshPhongMaterial({ color: 0xc50d0d })
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ const material3 = new MeshPhongMaterial({ color: 0x39b20a })
</span></span></span></code></pre></div><p>3、创建 3 个网格，每个网格的水平位置不同</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- //创建网格
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- const cube = new Mesh(geometry, material)~~
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- scene.add(cube)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006></span>
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ //创建 3 个网格
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ const cube1 = new Mesh(geometry, material1)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ cube1.position.x = -2
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ scene.add(cube1)//将网格添加到场景中
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ const cube2 = new Mesh(geometry, material2)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ cube2.position.x = 0
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ scene.add(cube2)//将网格添加到场景中
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e></span>
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ const cube3 = new Mesh(geometry, material3)
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ cube3.position.x = 2
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ scene.add(cube3)//将网格添加到场景中
</span></span></span></code></pre></div><p>4、为了便于后面对于不同网格的循环修改，我们将创建包含 3 个网格的一个数组</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const cubes = [cube1, cube2, cube3]
</span></span></code></pre></div><p>5、修改自动旋转渲染动画的相关代码</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- cube.rotation.x = time
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006>- cube.rotation.y = time
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#9d0006></span>    
</span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ //通过 cube.map 循环遍历修改网格相关属性
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ cubes.map(cube =&gt; {
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+     cube.rotation.x = time
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+     cube.rotation.y = time
</span></span></span><span style=display:flex><span><span style=color:#282828;background-color:#79740e>+ })
</span></span></span></code></pre></div><p>6、保存并重新执行 yarn start，若一切正常此时就会看到 画面中有 3 个不同颜色的立方体同时在做旋转动画。</p><blockquote><p>目前 3 个立方体仅仅是颜色和位置不同，你可以尝试将立方体设置为不同的尺寸，不同的旋转频率等等，自己发挥吧。</p></blockquote><p>是不是感觉自己对 Three.js 场景有进一步有所掌握 ^_^。</p><p><strong>下一节，我们将进一步改进这个示例代码。</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/02-%E5%88%9D%E5%A7%8B%E5%8C%96three.js%E9%A1%B9%E7%9B%AE/><span class=title>« Prev</span><br><span>02 初始化Three.js项目</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/04-%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%BA%9B%E8%87%AA%E9%80%82%E5%BA%94/><span class=title>Next »</span><br><span>04 添加一些自适应</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>