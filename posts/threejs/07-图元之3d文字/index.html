<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>07 图元之3D文字 | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="07 图元之3D文字 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/07-%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="07 图元之3D文字"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/07-%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="07 图元之3D文字"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"07 图元之3D文字","item":"https://bablvsj.github.io/posts/threejs/07-%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"07 图元之3D文字","name":"07 图元之3D文字","description":"","keywords":["Three.js"],"articleBody":"在 Three.js 所有内置的图元中，TextBufferGeometry 是最为特殊的一个。\n特殊之处在于：在使用 TextBufferGeometry 创建 文字几何对象之前，需要先加载 3D 字体数据。\n字体数据文件通常为 .json 文件，Three.js 提供了一个专门负责加载字体数据的类：FontLoader\n由于需要加载外部字体数据文件，所以创建 3D 文字这个过程是异步的。\n字体数据的补充说明：\n字体数据 准确来说是描述字体轮廓的 字体数据 究竟包含哪些字符由 制作 3D 软件决定的，例如有些字体数据只针对字母，并不支持汉字。 若某个字符并不包含在 字体数据中，那么 Three.js 会将该字符替换为 问号(?) 我们暂且先不考虑 字体数据文件 是如何在第 3 方 3D 软件中创建、导出的，先看一下如何加载字体数据文件。\nFontLoader用法分析 FontLoader 我先看一下 FontLoader.d.ts 的内容：\n这是本系列文章 第一次 从 .d.ts 文件角度来分析、推理 某个类的用法。\n这也体现了使用 TypeScript 的好处，你可以随时去查看对应的 .d.ts 文件，去查看各种类的具体的使用方法\nimport { Loader } from './Loader'; import { LoadingManager } from './LoadingManager'; import { Font } from './../extras/core/Font'; export class FontLoader extends Loader { constructor( manager?: LoadingManager ); load( url: string, onLoad?: ( responseFont: Font ) =\u003e void, onProgress?: ( event: ProgressEvent ) =\u003e void, onError?: ( event: ErrorEvent ) =\u003e void ): void; parse( json: any ): Font; } 从上面可以看出：\nFontLoader 继承于 Loader\n不难想象，在 Three.js 中一定还有负责加载其他资源类型的 Loader\n构造函数接收一个 LoadingManager 实例\n方法 load( url, onLoad, onProgress, onError )，从字面上就能推测出：\nurl：资源加载地址 onLoad：加载完成后，触发的事件回调函数 onProgress：加载过程中，触发的事件回调函数 onError：加载失败，触发的事件回调函数 方法 parse( json ) ，用来解析 JSON 数据，并返回 Font 实例\n延展说明：\nFontLoader 中牵扯到了另外 3 个类：Loader、LoadingManager、Font。\nLoader 和 LoadingManager 内部封装了加载和解析数据的过程，我们暂时不用深究他们的源码和用法，接下来重点看一下 Font。\nFont import { Shape } from './Shape'; export class Font { constructor( jsondata: any ); /** * @default 'Font' */ type: string; data: string; generateShapes( text: string, size: number ): Shape[]; } 从上面可以看出：\nFont 类是将 原始的字体数据 从 JSON 转化为 Three.js 内部可识别的 字体数据。\nFont 构造函数接收的参数就是 JSON 数据\n属性 type 默认值为 ‘Font’\n属性 data 数据类型为字符串，我猜出 data 就是用来保存构造函数中 jsondata 数据的\n方法 generateShapes( text, size ): Shape[]，根据参数来生成所有的 形状(shape)\nShape 这个类在前面示例中使用过多次，shape 单词的本意就是 形状\nShape[] 表示这是一个 元祖数组，数组的每一个元素都必须是 Shape 实例\n至此，对于 FontLoader、Font 已有大致了解，接下来该去尝试如何使用他们了。\n使用 FontLoader 加载字体数据 **我们使用 FontLoader 加载线上的一个字体数据：https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json**\n示例1：使用基础的方式进行加载 const loader = new FontLoader() const url = 'https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json' const onLoadHandle = (responseFont: Font) =\u003e { console.log(responseFont) } const onProgressHandle = (event: ProgressEvent) =\u003e { console.log(event) } const onErrorHandle = (error: ErrorEvent) =\u003e { console.log(error) } loader.load(url, onLoadHandle, onProgressHandle, onErrorHandle) 以上代码中，采用最原始，基础的方式来加载 字体数据。\n字体数据加载完成对应的 onLoadHandle 处理函数中，可以放置后续的操作。\n示例2：使用 async/await 封装加载过程 我们封装的目标：将异步加载过程封装好，然后就可以像写同步代码一样去获取异步结果。\n首先分析一下 示例1 中几个关键点：\nnew FontLoader() 实例化一个 加载器 url：加载地址 onLoadHandle、onProgressHandle、onErrorHandle 3 个加载事件处理函数 封装思路分析：\n实现方式肯定使用 promise + async/awiat\npromise 中的 resolve 刚好对应 onLoadHandle\npromise 中的 reject 刚好对应 onErrorHandle\n至于加载过程 onProgressHandle，我们基本用不到他，所以直接选择忽略该回到函数\n届时我们会传递一个 undefined 来替代 onProgressHandle\n封装加载过程：\nconst loadFont: (url: string) =\u003e Promise = (url) =\u003e { const loader = new FontLoader() return new Promise((resolve, reject: (error: ErrorEvent) =\u003e void) =\u003e { loader.load(url, resolve, undefined, reject) }) } 只有在 async 函数中才可以使用到 Promise，所以我们还需要定义以下函数：\nconst createText = async () =\u003e { const url = 'https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json' const font = await loadFont(url) //请注意这行代码，我们可以想使用同步编写的方式，获取到 字体数据 //开始创建 3D 字体 几何对象 ... } createText() 改造我们之前写的HelloPrimitives 改造原因 由于 TextBufferGeometry 创建过程为异步，async/await 具有函数异步传染性，因此我们需要将 index.tsx 中的代码也修改成异步 之前 index.tsx 中 useEffect( … ) 内容稍显复杂，我们特意将其中 随机生成材质、获得摆放位置 的响应代码从 useEffect 中提取出来，放到外部。 my-text.ts import { Font, FontLoader, Mesh, Object3D, TextBufferGeometry } from \"three\"; import { createMaterial } from './index' const loadFont: (url: string) =\u003e Promise = (url) =\u003e { const loader = new FontLoader() return new Promise((resolve, reject: (error: ErrorEvent) =\u003e void) =\u003e { loader.load(url, resolve, undefined, reject) }) } const createText = async () =\u003e { const url = 'https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json' const font = await loadFont(url) //异步加载 字体数据 //第一个参数 'puxiao' 可以替换成任何其他的英文字母 //特别注意：由于目前我们加载的 字体数据 只是针对英文字母的字体轮廓描述，并没有包含中文字体轮廓 //所以如果设置成 汉字，则场景无法正常渲染出文字 //对于无法渲染的字符，会被渲染成 问号(?) 作为替代 //第二个参数对应的是文字外观配置 const geometry = new TextBufferGeometry('puxiao', { font: font, size: 3.0, height: .2, curveSegments: 12, bevelEnabled: true, bevelThickness: 0.15, bevelSize: .3, bevelSegments: 5, }) const mesh = new Mesh(geometry, createMaterial()) //Three.js默认是以文字左侧为中心旋转点，下面的代码是将文字旋转点位置改为文字中心 //实现的思路是：用文字的网格去套进另外一个网格，通过 2 个网格之间的落差来实现将旋转中心点转移到文字中心位置 //具体代码细节，会在以后 场景 中详细学习，此刻你只需要照着以下代码敲就可以 geometry.computeBoundingBox() geometry.boundingBox?.getCenter(mesh.position).multiplyScalar(-1) const text = new Object3D() text.add(mesh) return text } export default createText index.tsx import { useRef, useEffect, useCallback } from 'react' import * as Three from 'three' import './index.scss' import myBox from './my-box' import myCircle from './my-circle' import myCone from './my-cone' import myCylinder from './my-cylinder' import myDodecahedron from './my-dodecahedron' import myEdges from './my-edges' import myExtrude from './my-extrude' import myIcosahedron from './my-icosahedron' import myLathe from './my-lathe' import myOctahedron from './my-octahedron' import myParametric from './my-parametric' import myPlane from './my-plane' import myPolyhedron from './my-polyhedron' import myRing from './my-ring' import myShape from './my-shape' import mySphere from './my-sphere' import myTetrahedron from './my-tetrahedron' import myTorus from './my-torus' import myTorusKnot from './my-torus-knot' import myTube from './my-tube' import myWireframe from './my-wireframe' import createText from './my-text' const meshArr: (Three.Mesh | Three.LineSegments | Three.Object3D)[] = [] //保存所有图形的元数组 export const createMaterial = () =\u003e { const material = new Three.MeshPhongMaterial({ side: Three.DoubleSide }) const hue = Math.floor(Math.random() * 100) / 100 //随机获得一个色相 const saturation = 1 //饱和度 const luminance = 0.5 //亮度 material.color.setHSL(hue, saturation, luminance) return material } //定义物体在画面中显示的网格布局 const eachRow = 5 //每一行显示 5 个 const spread = 15 //行高 和 列宽 const getPositionByIndex = (index: number) =\u003e { //我们设定的排列是每行显示 eachRow，即 5 个物体、行高 和 列宽 均为 spread 即 15 //因此每个物体根据顺序，计算出自己所在的位置 const row = Math.floor(index / eachRow) //计算出所在行 const column = index % eachRow //计算出所在列 const x = (column - 2) * spread //为什么要 -2 ？ //因为我们希望将每一行物体摆放的单元格，依次是：-2、-1、0、1、2，这样可以使每一整行物体处于居中显示 const y = (2 - row) * spread return { x, y } } const HelloPrimitives = () =\u003e { const canvasRef = useRef(null) const rendererRef = useRef(null) const cameraRef = useRef(null) const createInit = useCallback( async () =\u003e { if (canvasRef.current === null) { return } meshArr.length = 0 //以防万一，先清空原有数组 //初始化场景 const scene = new Three.Scene() scene.background = new Three.Color(0xAAAAAA) //初始化镜头 const camera = new Three.PerspectiveCamera(40, 2, 0.1, 1000) camera.position.z = 120 cameraRef.current = camera //初始化渲染器 const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement }) rendererRef.current = renderer //添加 2 盏灯光 const light0 = new Three.DirectionalLight(0xFFFFFF, 1) light0.position.set(-1, 2, 4) scene.add(light0) const light1 = new Three.DirectionalLight(0xFFFFFF, 1) light0.position.set(1, -2, -4) scene.add(light1) //获得各个 solid 类型的图元实例，并添加到 solidPrimitivesArr 中 const solidPrimitivesArr: Three.BufferGeometry[] = [] solidPrimitivesArr.push(myBox, myCircle, myCone, myCylinder, myDodecahedron) solidPrimitivesArr.push(myExtrude, myIcosahedron, myLathe, myOctahedron, myParametric) solidPrimitivesArr.push(myPlane, myPolyhedron, myRing, myShape, mySphere) solidPrimitivesArr.push(myTetrahedron, myTorus, myTorusKnot, myTube) //将各个 solid 类型的图元实例转化为网格，并添加到 primitivesArr 中 solidPrimitivesArr.forEach((item) =\u003e { const material = createMaterial() //随机获得一种颜色材质 const mesh = new Three.Mesh(item, material) meshArr.push(mesh) //将网格添加到网格数组中 }) //创建 3D 文字，并添加到 mesArr 中，请注意此函数为异步函数 meshArr.push(await createText()) //获得各个 line 类型的图元实例，并添加到 meshArr 中 const linePrimitivesArr: Three.BufferGeometry[] = [] linePrimitivesArr.push(myEdges, myWireframe) //将各个 line 类型的图元实例转化为网格，并添加到 meshArr 中 linePrimitivesArr.forEach((item) =\u003e { const material = new Three.LineBasicMaterial({ color: 0x000000 }) const mesh = new Three.LineSegments(item, material) meshArr.push(mesh) }) //配置每一个图元实例，转化为网格，并位置和材质后，将其添加到场景中 meshArr.forEach((mesh, index) =\u003e { const { x, y } = getPositionByIndex(index) mesh.position.x = x mesh.position.y = y scene.add(mesh) //将网格添加到场景中 }) //添加自动旋转渲染动画 const render = (time: number) =\u003e { time = time * 0.001 meshArr.forEach(item =\u003e { item.rotation.x = time item.rotation.y = time }) renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) }, [canvasRef], ) const resizeHandle = () =\u003e { //根据窗口大小变化，重新修改渲染器的视椎 if (rendererRef.current === null || cameraRef.current === null) { return } const canvas = rendererRef.current.domElement cameraRef.current.aspect = canvas.clientWidth / canvas.clientHeight cameraRef.current.updateProjectionMatrix() rendererRef.current.setSize(canvas.clientWidth, canvas.clientHeight, false) } //组件首次装载到网页后触发，开始创建并初始化 3D 场景 useEffect(() =\u003e { createInit() resizeHandle() window.addEventListener('resize', resizeHandle) return () =\u003e { window.removeEventListener('resize', resizeHandle) } }, [canvasRef, createInit]) return ( ) } export default HelloPrimitives 特别提醒：虽然针对 index.tsx 进行了修改，但是并不影响之前创建的其他图元，其他图元并不需要修改任何代码。\n你是否想也赶紧自己去创建一份可以显示中文的 3D 字体数据？\n这需要你会一些 3D 软件，例如 C4D(收费软件)、blender(免费开源软件) 在后续的学习中，一定会涉及到自定义字体样式、自定义几何图形，自己建模的，目前主要任务还是先系统学习 Three.js。\n至此，Three.js 中内置的 22 种图元，均逐一尝试完毕。\n同时也意味着，我们 Three.js 的 hello world 之旅完成，通过 HelloThreejs、HelloPrimitives，我们该体验的代码也都体验过了。\n接下来就要逐个开始深入、详细学习 具体的各个模块的用法。\n加油！\n","wordCount":"3349","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/07-%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>07 图元之3D文字</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>7 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#fontloader%e7%94%a8%e6%b3%95%e5%88%86%e6%9e%90 aria-label=FontLoader用法分析>FontLoader用法分析</a><ul><li><a href=#fontloader aria-label=FontLoader>FontLoader</a></li><li><a href=#font aria-label=Font>Font</a></li></ul></li><li><a href=#%e4%bd%bf%e7%94%a8-fontloader-%e5%8a%a0%e8%bd%bd%e5%ad%97%e4%bd%93%e6%95%b0%e6%8d%ae aria-label="使用 FontLoader 加载字体数据">使用 FontLoader 加载字体数据</a><ul><li><a href=#%e7%a4%ba%e4%be%8b1%e4%bd%bf%e7%94%a8%e5%9f%ba%e7%a1%80%e7%9a%84%e6%96%b9%e5%bc%8f%e8%bf%9b%e8%a1%8c%e5%8a%a0%e8%bd%bd aria-label=示例1：使用基础的方式进行加载>示例1：使用基础的方式进行加载</a></li><li><a href=#%e7%a4%ba%e4%be%8b2%e4%bd%bf%e7%94%a8-asyncawait-%e5%b0%81%e8%a3%85%e5%8a%a0%e8%bd%bd%e8%bf%87%e7%a8%8b aria-label="示例2：使用 async/await 封装加载过程">示例2：使用 async/await 封装加载过程</a></li></ul></li><li><a href=#%e6%94%b9%e9%80%a0%e6%88%91%e4%bb%ac%e4%b9%8b%e5%89%8d%e5%86%99%e7%9a%84helloprimitives aria-label=改造我们之前写的HelloPrimitives>改造我们之前写的HelloPrimitives</a><ul><li><a href=#%e6%94%b9%e9%80%a0%e5%8e%9f%e5%9b%a0 aria-label=改造原因>改造原因</a></li><li><a href=#my-textts aria-label=my-text.ts>my-text.ts</a></li><li><a href=#indextsx aria-label=index.tsx>index.tsx</a></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>在 Three.js 所有内置的图元中，TextBufferGeometry 是最为特殊的一个。</p><p><strong>特殊之处在于：在使用 TextBufferGeometry 创建 文字几何对象之前，需要先加载 3D 字体数据。</strong></p><p><strong>字体数据文件通常为 .json 文件，Three.js 提供了一个专门负责加载字体数据的类：FontLoader</strong></p><p><strong>由于需要加载外部字体数据文件，所以创建 3D 文字这个过程是异步的。</strong></p><p><strong>字体数据的补充说明：</strong></p><ol><li>字体数据 准确来说是描述字体轮廓的</li><li>字体数据 究竟包含哪些字符由 制作 3D 软件决定的，例如有些字体数据只针对字母，并不支持汉字。</li><li>若某个字符并不包含在 字体数据中，那么 Three.js 会将该字符替换为 问号(?)</li></ol><p>我们暂且先不考虑 字体数据文件 是如何在第 3 方 3D 软件中创建、导出的，先看一下如何加载字体数据文件。</p><h2 id=fontloader用法分析>FontLoader用法分析<a hidden class=anchor aria-hidden=true href=#fontloader用法分析>#</a></h2><h3 id=fontloader>FontLoader<a hidden class=anchor aria-hidden=true href=#fontloader>#</a></h3><p>我先看一下 FontLoader.d.ts 的内容：</p><blockquote><p>这是本系列文章 第一次 从 .d.ts 文件角度来分析、推理 某个类的用法。</p><p>这也体现了使用 TypeScript 的好处，你可以随时去查看对应的 .d.ts 文件，去查看各种类的具体的使用方法</p></blockquote><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { Loader } from &#39;./Loader&#39;;
</span></span><span style=display:flex><span>import { LoadingManager } from &#39;./LoadingManager&#39;;
</span></span><span style=display:flex><span>import { Font } from &#39;./../extras/core/Font&#39;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export class FontLoader extends Loader {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> constructor( manager?: LoadingManager );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> load(
</span></span><span style=display:flex><span>  url: string,
</span></span><span style=display:flex><span>  onLoad?: ( responseFont: Font ) =&gt; void,
</span></span><span style=display:flex><span>  onProgress?: ( event: ProgressEvent ) =&gt; void,
</span></span><span style=display:flex><span>  onError?: ( event: ErrorEvent ) =&gt; void
</span></span><span style=display:flex><span> ): void;
</span></span><span style=display:flex><span> parse( json: any ): Font;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>从上面可以看出：</strong></p><ol><li><p>FontLoader 继承于 Loader</p><blockquote><p>不难想象，在 Three.js 中一定还有负责加载其他资源类型的 Loader</p></blockquote></li><li><p>构造函数接收一个 LoadingManager 实例</p></li><li><p>方法 load( url, onLoad, onProgress, onError )，从字面上就能推测出：</p><ol><li>url：资源加载地址</li><li>onLoad：加载完成后，触发的事件回调函数</li><li>onProgress：加载过程中，触发的事件回调函数</li><li>onError：加载失败，触发的事件回调函数</li></ol></li><li><p>方法 parse( json ) ，用来解析 JSON 数据，并返回 Font 实例</p></li></ol><p><strong>延展说明：</strong></p><p>FontLoader 中牵扯到了另外 3 个类：Loader、LoadingManager、Font。</p><p>Loader 和 LoadingManager 内部封装了加载和解析数据的过程，我们暂时不用深究他们的源码和用法，接下来重点看一下 Font。</p><h3 id=font>Font<a hidden class=anchor aria-hidden=true href=#font>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { Shape } from &#39;./Shape&#39;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export class Font {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> constructor( jsondata: any );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> /**
</span></span><span style=display:flex><span>  * @default &#39;Font&#39;
</span></span><span style=display:flex><span>  */
</span></span><span style=display:flex><span> type: string;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> data: string;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> generateShapes( text: string, size: number ): Shape[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>从上面可以看出：</strong></p><ol><li><p>Font 类是将 原始的字体数据 从 JSON 转化为 Three.js 内部可识别的 字体数据。</p></li><li><p>Font 构造函数接收的参数就是 JSON 数据</p></li><li><p>属性 type 默认值为 &lsquo;Font&rsquo;</p></li><li><p>属性 data 数据类型为字符串，我猜出 data 就是用来保存构造函数中 jsondata 数据的</p></li><li><p>方法 generateShapes( text, size ): Shape[]，根据参数来生成所有的 形状(shape)</p><blockquote><p>Shape 这个类在前面示例中使用过多次，shape 单词的本意就是 形状</p><p>Shape[] 表示这是一个 元祖数组，数组的每一个元素都必须是 Shape 实例</p></blockquote></li></ol><p>至此，对于 FontLoader、Font 已有大致了解，接下来该去尝试如何使用他们了。</p><h2 id=使用-fontloader-加载字体数据>使用 FontLoader 加载字体数据<a hidden class=anchor aria-hidden=true href=#使用-fontloader-加载字体数据>#</a></h2><p>**我们使用 FontLoader 加载线上的一个字体数据：<a href=https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json**>https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json**</a></p><h3 id=示例1使用基础的方式进行加载>示例1：使用基础的方式进行加载<a hidden class=anchor aria-hidden=true href=#示例1使用基础的方式进行加载>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const loader = new FontLoader()
</span></span><span style=display:flex><span>const url = &#39;https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const onLoadHandle = (responseFont: Font) =&gt; {
</span></span><span style=display:flex><span>    console.log(responseFont)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>const onProgressHandle = (event: ProgressEvent&lt;EventTarget&gt;) =&gt; {
</span></span><span style=display:flex><span>    console.log(event)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>const onErrorHandle = (error: ErrorEvent) =&gt; {
</span></span><span style=display:flex><span>    console.log(error)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>loader.load(url, onLoadHandle, onProgressHandle, onErrorHandle)
</span></span></code></pre></div><p>以上代码中，采用最原始，基础的方式来加载 字体数据。</p><p>字体数据加载完成对应的 onLoadHandle 处理函数中，可以放置后续的操作。</p><h3 id=示例2使用-asyncawait-封装加载过程>示例2：使用 async/await 封装加载过程<a hidden class=anchor aria-hidden=true href=#示例2使用-asyncawait-封装加载过程>#</a></h3><p><strong>我们封装的目标：将异步加载过程封装好，然后就可以像写同步代码一样去获取异步结果。</strong></p><p><strong>首先分析一下 示例1 中几个关键点：</strong></p><ol><li>new FontLoader() 实例化一个 加载器</li><li>url：加载地址</li><li>onLoadHandle、onProgressHandle、onErrorHandle 3 个加载事件处理函数</li></ol><p><strong>封装思路分析：</strong></p><ol><li><p>实现方式肯定使用 promise + async/awiat</p></li><li><p>promise 中的 resolve 刚好对应 onLoadHandle</p></li><li><p>promise 中的 reject 刚好对应 onErrorHandle</p></li><li><p>至于加载过程 onProgressHandle，我们基本用不到他，所以直接选择忽略该回到函数</p><blockquote><p>届时我们会传递一个 undefined 来替代 onProgressHandle</p></blockquote></li></ol><p><strong>封装加载过程：</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const loadFont: (url: string) =&gt; Promise&lt;Font&gt; = (url) =&gt; {
</span></span><span style=display:flex><span>    const loader = new FontLoader()
</span></span><span style=display:flex><span>    return new Promise((resolve, reject: (error: ErrorEvent) =&gt; void) =&gt; {
</span></span><span style=display:flex><span>        loader.load(url, resolve, undefined, reject)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>只有在 async 函数中才可以使用到 Promise，所以我们还需要定义以下函数：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>const createText = async () =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const url = &#39;https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const font = await loadFont(url) //请注意这行代码，我们可以想使用同步编写的方式，获取到 字体数据
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    //开始创建 3D 字体 几何对象
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>createText()
</span></span></code></pre></div><h2 id=改造我们之前写的helloprimitives>改造我们之前写的HelloPrimitives<a hidden class=anchor aria-hidden=true href=#改造我们之前写的helloprimitives>#</a></h2><h3 id=改造原因>改造原因<a hidden class=anchor aria-hidden=true href=#改造原因>#</a></h3><ol><li>由于 TextBufferGeometry 创建过程为异步，async/await 具有函数异步传染性，因此我们需要将 index.tsx 中的代码也修改成异步</li><li>之前 index.tsx 中 useEffect( &mldr; ) 内容稍显复杂，我们特意将其中 随机生成材质、获得摆放位置 的响应代码从 useEffect 中提取出来，放到外部。</li></ol><h3 id=my-textts>my-text.ts<a hidden class=anchor aria-hidden=true href=#my-textts>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { Font, FontLoader, Mesh, Object3D, TextBufferGeometry } from &#34;three&#34;;
</span></span><span style=display:flex><span>import { createMaterial } from &#39;./index&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const loadFont: (url: string) =&gt; Promise&lt;Font&gt; = (url) =&gt; {
</span></span><span style=display:flex><span>    const loader = new FontLoader()
</span></span><span style=display:flex><span>    return new Promise((resolve, reject: (error: ErrorEvent) =&gt; void) =&gt; {
</span></span><span style=display:flex><span>        loader.load(url, resolve, undefined, reject)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const createText = async () =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const url = &#39;https://threejsfundamentals.org/threejs/resources/threejs/fonts/helvetiker_regular.typeface.json&#39;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    const font = await loadFont(url) //异步加载 字体数据
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    //第一个参数 &#39;puxiao&#39; 可以替换成任何其他的英文字母
</span></span><span style=display:flex><span>    //特别注意：由于目前我们加载的 字体数据 只是针对英文字母的字体轮廓描述，并没有包含中文字体轮廓
</span></span><span style=display:flex><span>    //所以如果设置成 汉字，则场景无法正常渲染出文字
</span></span><span style=display:flex><span>    //对于无法渲染的字符，会被渲染成 问号(?) 作为替代
</span></span><span style=display:flex><span>    //第二个参数对应的是文字外观配置
</span></span><span style=display:flex><span>    const geometry = new TextBufferGeometry(&#39;puxiao&#39;, {
</span></span><span style=display:flex><span>        font: font,
</span></span><span style=display:flex><span>        size: 3.0,
</span></span><span style=display:flex><span>        height: .2,
</span></span><span style=display:flex><span>        curveSegments: 12,
</span></span><span style=display:flex><span>        bevelEnabled: true,
</span></span><span style=display:flex><span>        bevelThickness: 0.15,
</span></span><span style=display:flex><span>        bevelSize: .3,
</span></span><span style=display:flex><span>        bevelSegments: 5,
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const mesh = new Mesh(geometry, createMaterial())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //Three.js默认是以文字左侧为中心旋转点，下面的代码是将文字旋转点位置改为文字中心
</span></span><span style=display:flex><span>    //实现的思路是：用文字的网格去套进另外一个网格，通过 2 个网格之间的落差来实现将旋转中心点转移到文字中心位置
</span></span><span style=display:flex><span>    //具体代码细节，会在以后 场景 中详细学习，此刻你只需要照着以下代码敲就可以
</span></span><span style=display:flex><span>    geometry.computeBoundingBox()
</span></span><span style=display:flex><span>    geometry.boundingBox?.getCenter(mesh.position).multiplyScalar(-1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const text = new Object3D()
</span></span><span style=display:flex><span>    text.add(mesh)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return text
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default createText
</span></span></code></pre></div><h3 id=indextsx>index.tsx<a hidden class=anchor aria-hidden=true href=#indextsx>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useRef, useEffect, useCallback } from &#39;react&#39;
</span></span><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import myBox from &#39;./my-box&#39;
</span></span><span style=display:flex><span>import myCircle from &#39;./my-circle&#39;
</span></span><span style=display:flex><span>import myCone from &#39;./my-cone&#39;
</span></span><span style=display:flex><span>import myCylinder from &#39;./my-cylinder&#39;
</span></span><span style=display:flex><span>import myDodecahedron from &#39;./my-dodecahedron&#39;
</span></span><span style=display:flex><span>import myEdges from &#39;./my-edges&#39;
</span></span><span style=display:flex><span>import myExtrude from &#39;./my-extrude&#39;
</span></span><span style=display:flex><span>import myIcosahedron from &#39;./my-icosahedron&#39;
</span></span><span style=display:flex><span>import myLathe from &#39;./my-lathe&#39;
</span></span><span style=display:flex><span>import myOctahedron from &#39;./my-octahedron&#39;
</span></span><span style=display:flex><span>import myParametric from &#39;./my-parametric&#39;
</span></span><span style=display:flex><span>import myPlane from &#39;./my-plane&#39;
</span></span><span style=display:flex><span>import myPolyhedron from &#39;./my-polyhedron&#39;
</span></span><span style=display:flex><span>import myRing from &#39;./my-ring&#39;
</span></span><span style=display:flex><span>import myShape from &#39;./my-shape&#39;
</span></span><span style=display:flex><span>import mySphere from &#39;./my-sphere&#39;
</span></span><span style=display:flex><span>import myTetrahedron from &#39;./my-tetrahedron&#39;
</span></span><span style=display:flex><span>import myTorus from &#39;./my-torus&#39;
</span></span><span style=display:flex><span>import myTorusKnot from &#39;./my-torus-knot&#39;
</span></span><span style=display:flex><span>import myTube from &#39;./my-tube&#39;
</span></span><span style=display:flex><span>import myWireframe from &#39;./my-wireframe&#39;
</span></span><span style=display:flex><span>import createText from &#39;./my-text&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const meshArr: (Three.Mesh | Three.LineSegments | Three.Object3D)[] = [] //保存所有图形的元数组
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export const createMaterial = () =&gt; {
</span></span><span style=display:flex><span>    const material = new Three.MeshPhongMaterial({ side: Three.DoubleSide })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const hue = Math.floor(Math.random() * 100) / 100 //随机获得一个色相
</span></span><span style=display:flex><span>    const saturation = 1 //饱和度
</span></span><span style=display:flex><span>    const luminance = 0.5 //亮度
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    material.color.setHSL(hue, saturation, luminance)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return material
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//定义物体在画面中显示的网格布局
</span></span><span style=display:flex><span>const eachRow = 5 //每一行显示 5 个
</span></span><span style=display:flex><span>const spread = 15 //行高 和 列宽
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const getPositionByIndex = (index: number) =&gt; {
</span></span><span style=display:flex><span>    //我们设定的排列是每行显示 eachRow，即 5 个物体、行高 和 列宽 均为 spread 即 15
</span></span><span style=display:flex><span>    //因此每个物体根据顺序，计算出自己所在的位置
</span></span><span style=display:flex><span>    const row = Math.floor(index / eachRow) //计算出所在行
</span></span><span style=display:flex><span>    const column = index % eachRow //计算出所在列
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const x = (column - 2) * spread //为什么要 -2 ？
</span></span><span style=display:flex><span>    //因为我们希望将每一行物体摆放的单元格，依次是：-2、-1、0、1、2，这样可以使每一整行物体处于居中显示
</span></span><span style=display:flex><span>    const y = (2 - row) * spread
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return { x, y }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloPrimitives = () =&gt; {
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>    const rendererRef = useRef&lt;Three.WebGLRenderer | null&gt;(null)
</span></span><span style=display:flex><span>    const cameraRef = useRef&lt;Three.PerspectiveCamera | null&gt;(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const createInit = useCallback(
</span></span><span style=display:flex><span>        async () =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            if (canvasRef.current === null) {
</span></span><span style=display:flex><span>                return
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            meshArr.length = 0 //以防万一，先清空原有数组
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //初始化场景
</span></span><span style=display:flex><span>            const scene = new Three.Scene()
</span></span><span style=display:flex><span>            scene.background = new Three.Color(0xAAAAAA)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //初始化镜头
</span></span><span style=display:flex><span>            const camera = new Three.PerspectiveCamera(40, 2, 0.1, 1000)
</span></span><span style=display:flex><span>            camera.position.z = 120
</span></span><span style=display:flex><span>            cameraRef.current = camera
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //初始化渲染器
</span></span><span style=display:flex><span>            const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement })
</span></span><span style=display:flex><span>            rendererRef.current = renderer
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //添加 2 盏灯光
</span></span><span style=display:flex><span>            const light0 = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>            light0.position.set(-1, 2, 4)
</span></span><span style=display:flex><span>            scene.add(light0)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            const light1 = new Three.DirectionalLight(0xFFFFFF, 1)
</span></span><span style=display:flex><span>            light0.position.set(1, -2, -4)
</span></span><span style=display:flex><span>            scene.add(light1)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //获得各个 solid 类型的图元实例，并添加到 solidPrimitivesArr 中
</span></span><span style=display:flex><span>            const solidPrimitivesArr: Three.BufferGeometry[] = []
</span></span><span style=display:flex><span>            solidPrimitivesArr.push(myBox, myCircle, myCone, myCylinder, myDodecahedron)
</span></span><span style=display:flex><span>            solidPrimitivesArr.push(myExtrude, myIcosahedron, myLathe, myOctahedron, myParametric)
</span></span><span style=display:flex><span>            solidPrimitivesArr.push(myPlane, myPolyhedron, myRing, myShape, mySphere)
</span></span><span style=display:flex><span>            solidPrimitivesArr.push(myTetrahedron, myTorus, myTorusKnot, myTube)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //将各个 solid 类型的图元实例转化为网格，并添加到 primitivesArr 中
</span></span><span style=display:flex><span>            solidPrimitivesArr.forEach((item) =&gt; {
</span></span><span style=display:flex><span>                const material = createMaterial() //随机获得一种颜色材质
</span></span><span style=display:flex><span>                const mesh = new Three.Mesh(item, material)
</span></span><span style=display:flex><span>                meshArr.push(mesh) //将网格添加到网格数组中
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //创建 3D 文字，并添加到 mesArr 中，请注意此函数为异步函数
</span></span><span style=display:flex><span>            meshArr.push(await createText())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //获得各个 line 类型的图元实例，并添加到 meshArr 中
</span></span><span style=display:flex><span>            const linePrimitivesArr: Three.BufferGeometry[] = []
</span></span><span style=display:flex><span>            linePrimitivesArr.push(myEdges, myWireframe)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //将各个 line 类型的图元实例转化为网格，并添加到 meshArr 中
</span></span><span style=display:flex><span>            linePrimitivesArr.forEach((item) =&gt; {
</span></span><span style=display:flex><span>                const material = new Three.LineBasicMaterial({ color: 0x000000 })
</span></span><span style=display:flex><span>                const mesh = new Three.LineSegments(item, material)
</span></span><span style=display:flex><span>                meshArr.push(mesh)
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //配置每一个图元实例，转化为网格，并位置和材质后，将其添加到场景中
</span></span><span style=display:flex><span>            meshArr.forEach((mesh, index) =&gt; {
</span></span><span style=display:flex><span>                const { x, y } = getPositionByIndex(index)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                mesh.position.x = x
</span></span><span style=display:flex><span>                mesh.position.y = y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                scene.add(mesh) //将网格添加到场景中
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            //添加自动旋转渲染动画
</span></span><span style=display:flex><span>            const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>                time = time * 0.001
</span></span><span style=display:flex><span>                meshArr.forEach(item =&gt; {
</span></span><span style=display:flex><span>                    item.rotation.x = time
</span></span><span style=display:flex><span>                    item.rotation.y = time
</span></span><span style=display:flex><span>                })
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                renderer.render(scene, camera)
</span></span><span style=display:flex><span>                window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        [canvasRef],
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const resizeHandle = () =&gt; {
</span></span><span style=display:flex><span>        //根据窗口大小变化，重新修改渲染器的视椎
</span></span><span style=display:flex><span>        if (rendererRef.current === null || cameraRef.current === null) {
</span></span><span style=display:flex><span>            return
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        const canvas = rendererRef.current.domElement
</span></span><span style=display:flex><span>        cameraRef.current.aspect = canvas.clientWidth / canvas.clientHeight
</span></span><span style=display:flex><span>        cameraRef.current.updateProjectionMatrix()
</span></span><span style=display:flex><span>        rendererRef.current.setSize(canvas.clientWidth, canvas.clientHeight, false)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    //组件首次装载到网页后触发，开始创建并初始化 3D 场景
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>        createInit()
</span></span><span style=display:flex><span>        resizeHandle()
</span></span><span style=display:flex><span>        window.addEventListener(&#39;resize&#39;, resizeHandle)
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            window.removeEventListener(&#39;resize&#39;, resizeHandle)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef, createInit])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloPrimitives
</span></span></code></pre></div><p>特别提醒：虽然针对 index.tsx 进行了修改，但是并不影响之前创建的其他图元，其他图元并不需要修改任何代码。</p><blockquote><p>你是否想也赶紧自己去创建一份可以显示中文的 3D 字体数据？<br>这需要你会一些 3D 软件，例如 C4D(收费软件)、blender(免费开源软件)
在后续的学习中，一定会涉及到自定义字体样式、自定义几何图形，自己建模的，目前主要任务还是先系统学习 Three.js。</p></blockquote><p>至此，Three.js 中内置的 22 种图元，均逐一尝试完毕。</p><p>同时也意味着，我们 Three.js 的 hello world 之旅完成，通过 HelloThreejs、HelloPrimitives，我们该体验的代码也都体验过了。</p><p><strong>接下来就要逐个开始深入、详细学习 具体的各个模块的用法。</strong></p><p><strong>加油！</strong></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/06-%E5%9B%BE%E5%85%83%E7%BB%83%E4%B9%A0%E7%A4%BA%E4%BE%8B/><span class=title>« Prev</span><br><span>06 图元练习示例</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/08-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/><span class=title>Next »</span><br><span>08-Three.js基础之场景</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>