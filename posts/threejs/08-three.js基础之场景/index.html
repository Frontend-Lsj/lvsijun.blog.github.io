<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>08-Three.js基础之场景 | Bablvsj's Blog</title><meta name=keywords content="Three.js"><meta name=description content="08-Three.js基础之场景 - Bablvsj's Blog"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/threejs/08-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/><link crossorigin=anonymous href=/assets/css/stylesheet.241265d51339977eb0f90d05780e286ec2789600ca4137f29552dec9dee06569.css integrity="sha256-JBJl1RM5l36w+Q0FeA4obsJ4lgDKQTfylVLeyd7gZWk=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="08-Three.js基础之场景"><meta property="og:description" content><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/threejs/08-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-19T17:11:35+08:00"><meta property="article:modified_time" content="2023-12-19T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="08-Three.js基础之场景"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"08-Three.js基础之场景","item":"https://bablvsj.github.io/posts/threejs/08-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"08-Three.js基础之场景","name":"08-Three.js基础之场景","description":"","keywords":["Three.js"],"articleBody":"再次回顾一下 Three.js 3 大 核心要素：场景、镜头、渲染器\n本文主要将 Three.js 中的 场景，但是请注意，本文讲的场景实际上是指 场景图(scene graph)，而不是单指 我们之前示例代码中用到过的 场景 Three.Scene。\n但是请注意，本文讲的场景实际上是指 场景图(scene graph)，而不是单指 我们之前示例代码中用到过的 场景 Three.Scene。\n场景图(scene graph)的概念解释 场景与场景图的关系 SceneGraph 准确的翻译应该是叫：场景图，但是本文中，我有时依然倔强得把他叫做 “场景”。\n但无论我怎么称呼它，请你记得：场景(Three.Scene) 只是 场景图 中的一种。\n场景图的数据结构 抛开 Three.js 不谈，我们先看一下在数据结构中，树与图 的概念区分。\n树：一种 分层 数据的抽象模型\n呈现出的是像大树枝一样的结构，根据结构特征还可以划分为 二叉树、红黑树、大顶树、小顶树等等\n图：网络结构的抽象模型，是一组由边连接的节点\n呈现出的是像蜘蛛网、道路网、航班线路一样的结构\n回到 Three.js 中。\n请务必记得：\n场景图 中的 图，并非数据结构中的图 场景图的数据结构并非 图，而是 树 补充一下：\n在有一些教程示例代码中，当循环遍历 场景 中物体对象时，你或许会看到这样的代码：\n他使用的是：xxx.forEach((node) =\u003e { node ....}) 而不是：xxx.forEach((itme) =\u003e { item ...}) 尽管无论数组元素变量名是叫 node 还是 item，实际上效果是相同的，但是他为什么会用 node 这个单词呢？\n答：因为场景图的数据结构是树，而场景上的物体对象实际就是树结构中的一个节点，节点对应的单词就是 node。\n场景图(空间)的含义 在 Three.js 中，场景即空间，而 空间 包含以下几种情况：\n由 Scene 创建的普通场景、普通场景中还可以添加雾(Fog、FogExp2)从而变成具有雾化效果的场景\n无论哪种场景下，都可以添加 Object3D、Mesh\nScene 场景下，距离镜头越远的物体看上去越小，但清晰度不变\n包含 雾(Fog、FogExp2) 场景下，距离镜头越远的物体不光看上去越小，同时被雾气环绕\n对于现阶段的我们来说，目前主要以使用 Scene 场景为主，Fog、FogExp2 会在以后学习和使用\n由 Object3D 创建的 空白空间\n可以添加 Mesh\n由 Mesh 创建的 具体的物体所在的网格空间\n可以添加其他的 Mesh\n理论上，Object3D 和 Mesh 是可以互相添加，互相嵌套的，最终会构成一个复杂的空间体系\n请注意，为了避免 “场景图” 这 3 个字过于绕口，以及为了方便理解，在下面文字中，我会将 场景图 称呼为 场景或空间\n场景的几个概念 概念1：一个局部的相对空间，即为一个场景 例如太阳系就是一个空间(场景)\n概念2：一个空间(场景) 又可能是由 几个子空间(场景) 组合而成 太阳系由 8 大行星构成\n行星除了本身之外还包卫星，例如地球和月球\n地球上又包含陆地和海洋\n陆地上又包含中国，中国包含你此刻所处的空间\n概念3：表面上添加某场景，但实际上执行的是合并场景 例如 sceneA.add(sceneB)，表面上看 sceneA 添加了 sceneB，sceneB 称为了 sceneA 的子场景，但事实上根本并不是这样！\n什么？这岂不是和 概念 2 完全相悖？\n没错！确实是即合并又互相独立。\n所谓独立：sceneB 中的元素(物体、灯光)的坐标位置继续保持独立\n所谓合并：sceneB中的元素(物体、灯光)被复制添加到其他场景中，例如 场景B 中的灯光会影响 场景C\n举一个很容易犯错的例子：\n假设有 环境灯光 lightB、lightC，和 场景 sceneA、sceneB、sceneC\nsceneB.add(lightB) //场景B 中添加 灯光B sceneC.add(lightC) //场景C 中添加 灯光C sceneA.add(sceneB) //场景A 中添加 场景B sceneA.add(sceneC) //场景A 中添加 场景C renderer.render(sceneA,camera) //使用场景渲染器，将 场景A 渲染出来 你可能以为 灯光B 只在 场景B 中起作用、灯光C 只在 场景C 中起作用。\n但事实根本不是这样，上面代码渲染过后，你会发现：场景B 和 场景C 中，分别都受到 环境灯光B 和 环境灯光C。\n因为环境灯光是全局的、环境灯光在场景中无处不在、会影响场景中全部的物体。\n假设不是环境灯光，而是普通的平行灯光，事实上依然会影响(照耀)到其他 “子场景”上的物体，只不过可能因为距离设定原因，不会像全局环境光那样影响明显。\n为什么会这样？\n我们查看一下 scene.add() 函数源码：\n注意：Scene 继承于 Object3D，所以 scene.add() 方法实际上是由 Object3D 定义的。\nadd: function (object) { if (arguments.length \u003e 1) { for (let i = 0; i \u003c arguments.length; i++) { this.add(arguments[i]); } return this; } if (object === this) { console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object); return this; } if ((object \u0026\u0026 object.isObject3D)) { if (object.parent !== null) { object.parent.remove(object); } object.parent = this; this.children.push(object); object.dispatchEvent(_addedEvent); } else { console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object); } return this; } 源码分析：\nif (object.parent !== null) { object.parent.remove(object); } //如果元素(物体、灯光)拥有父级，则将该元素从父级中删除 object.parent = this; //将元素(物体、灯光)的父级指向 this(自己) this.children.push(object); //将元素(物体、灯光)添加到自己场景中的 children 中 经过以上 3 步操作，add() 函数实现了 将 子场景元素拆散、合并到自己(最外层场景、顶场景)中。\n假设我就希望有若干个“子场景”，子场景中的灯光(哪怕是环境光)是独立，不会影响其他 子场景的，怎么实现？\n答：只能声明多个 渲染器(WebGLRenderer)，每个渲染器渲染一个场景(Scene)、每个场景内添加一种光源。\n提前预告：在后续讲解 灯光 那一章节中，就会运用到这个知识点。\n概念4：一个子空间(场景)只需要关注和他最紧密相关的空间即可 假设你此刻在家里，那么你的相对空间就只针对家里即可，尽管你此刻所处的地球正在自转，你无需关心这个事情。\n月球也可能只关心它是否围着地球转，而不需要关心他在太阳系中的运动轨迹\n概念4引申出来的另外一个概念：通过空间嵌套来改变原有的相对状态 一个 空间A 嵌套进入另外一个 空间B，此时 空间A 将会拥有 空间B 的一些属性，例如 空间A 会随着 空间B 一起缩放 两个子空间 A和B 都嵌套进另外一个空间 C，此时 空间A、空间B 相对独立且共存 举例说明1：修改文字对象的旋转中心点 默认情况下，Three.js 中创建的 TextBufferGeometry 对象旋转点位于左侧。\n为了让 文字对象 看上去以 中心位置 为中心点旋转，那么可以这样操作：\n通过 new Object3D() 创建 空间A\n通过 new Mesh( new TextBufferGeometry({ … } ), createMaterial() ) 创建文字对象\n修改文字的中心点\ngeometry.computeBoundingBox() geometry.boundingBox?.getCenter(mesh.position).multiplyScalar(-1) 将 文字对象(网格) 添加到 空间A 中，同时将 空间A 添加到场景中\n经过这样操作过后，即可将 文字对象 文字对象的中心点改为中间。\n举例说明2：创建月球与地球的相对空间 太阳和地球构成一个相对空间、地球与月亮也构成一个相对空间。\n假设我们现在的目标是创建 月球与地球的相对空间，那么可以这样操作：\n创建地球对象 A、月球对象 B\n“地球对象”，更加精准的描述应该是：地球对应的网格，也就是 “地球本身的空间”\n为了不让月球和地球重叠在一起，通常情况下会给 月球对象 B 设置 .position.x = xx，好让地球和月球之间存在一定的距离\n通过 new Object3D() 创建空间 C\n将 A、B 都添加到 C 中\n将 C 添加到主场景中\n经过这样操作后，主场景中包含 C，而 C 包含 A、B，至此形成了一个 地球和月球 共同存在的空间。\n场景(空间)的最常见操作 将 空间A 加入到 空间B：B.add(A) 设置空间 A 在空间B 中的位置：A.position.x = xxx 场景的示例：太阳、地球、月亮 我们模拟出以下场景 月球自转的同时，围绕地球旋转 地球自转的同时，围绕太阳旋转 太阳仅自转，位置不变 本文的重点在于讲解 场景 的概念，若对代码中某些 方法或属性的使用 不太能够理解也没有关系，将来会慢慢学习到。\n代码文件说明 我们将在 src/components/hello-scene/ 目录下创建 index.stx 作为本次演示主文件。\n与以往代码不同，这次我们将创建 太阳、地球、月亮、以及 光源 的过程迁移到另外一个单独的文件中 ，好让我们在 useEffect 中的代码更加清爽一些。\n对应的文件为 src/components/hello-scene/create-something.ts\n代码核心说明 我们将创建一个球体，让太阳、地球、月亮都由这个球体创建而来，只不过每个球体网格在材质(颜色)、大小方面不同。\n我们将创建 3 个相对空间：\n月球相对地球的轨道空间\n这个空间中只有月球，因为设置了偏差(poisition.x = 2)，所以月球会做圆形轨道运动\n地球(含月球)相对太阳的轨道空间\n这个空间中有地球(含月球)，同样因为设置了偏差(position.x = 10)，所以会整体做圆形轨道运动\n太阳与地球轨道构成的相对空间\n这个空间包含太阳、地球(含月球)\n补充说明 为了让我们更加容易看到 球体 的自转，所以无论是太阳还是地球或月亮，外形都设置成一个 六边形的球体。\n我们只是为了演示 相对空间 的使用，所以 太阳、月亮、地球 的尺寸、自转频率、位置关系等是随意设置的值，并不是真实中的大小比例。\n科普一下：实际中，太阳直径是地球直径的 109 倍、地球直径是月球直径的 4 倍\n具体的代码 create-something.js import { Mesh, MeshPhongMaterial, Object3D, PointLight, SphereBufferGeometry } from \"three\" //创建一个球体 const sphere = new SphereBufferGeometry(1, 6, 6) //球体为6边形，目的是为了方便我们观察到他在自转 //创建太阳 const sunMaterial = new MeshPhongMaterial({ emissive: 0xFFFF00 }) const sunMesh = new Mesh(sphere, sunMaterial) sunMesh.scale.set(4, 4, 4) //将球体尺寸放大 4 倍 //创建地球 const earthMaterial = new MeshPhongMaterial({ color: 0x2233FF, emissive: 0x112244 }) const earthMesh = new Mesh(sphere, earthMaterial) //创建月球 const moonMaterial = new MeshPhongMaterial({ color: 0x888888, emissive: 0x222222 }) const moonMesh = new Mesh(sphere, moonMaterial) moonMesh.scale.set(0.5, 0.5, 0.5) //将球体尺寸缩小 0.5 倍 //创建一个 3D 空间，用来容纳月球，相当于月球轨迹空间 export const moonOribit = new Object3D() moonOribit.position.x = 2 moonOribit.add(moonMesh) //创建一个 3D 空间，用来容纳地球，相当于地球轨迹空间 export const earthOrbit = new Object3D() earthOrbit.position.x = 10 earthOrbit.add(earthMesh) earthOrbit.add(moonOribit) //创建一个 3D 空间，用来容纳太阳和地球(含月球) export const solarSystem = new Object3D() solarSystem.add(sunMesh) solarSystem.add(earthOrbit) //创建点光源 export const pointLight = new PointLight(0xFFFFFF, 3) export default {} index.tsx import { useRef, useEffect } from 'react' import * as Three from 'three' import { solarSystem, earthOrbit, moonOribit, pointLight } from '@/components/hello-scene/create-something' import './index.scss' const nodeArr = [solarSystem, earthOrbit, moonOribit] //太阳、地球、月亮对应的网格 const HelloScene = () =\u003e { const canvasRef = useRef(null) const rendererRef = useRef(null) const cameraRef = useRef(null) const sceneRef = useRef(null) useEffect(() =\u003e { //创建渲染器 const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement }) rendererRef.current = renderer //创建镜头 const camera = new Three.PerspectiveCamera(40, 2, 0.1, 1000) camera.position.set(0, 50, 0) camera.up.set(0, 0, 1) camera.lookAt(0, 0, 0) cameraRef.current = camera //创建场景 const scene = new Three.Scene() scene.background = new Three.Color(0x111111) sceneRef.current = scene //将太阳系、灯光添加到场景中 scene.add(solarSystem) scene.add(pointLight) //创建循环渲染的动画 const render = (time: number) =\u003e { time = time * 0.001 nodeArr.forEach((item) =\u003e { item.rotation.y = time }) renderer.render(scene, camera) window.requestAnimationFrame(render) } window.requestAnimationFrame(render) //添加窗口尺寸变化的监听 const resizeHandle = () =\u003e { const canvas = renderer.domElement camera.aspect = canvas.clientWidth / canvas.clientHeight camera.updateProjectionMatrix() renderer.setSize(canvas.clientWidth, canvas.clientHeight, false) } resizeHandle() window.addEventListener('resize', resizeHandle) return () =\u003e { window.removeEventListener('resize', resizeHandle) } }, [canvasRef]) return ( ) } export default HelloScene 上述代码共同构建出的空间体系 主场景 Scene 包含 太阳系 太阳系：太阳系本身 + 太阳 + 地球系(含月球系) 地球系：地球系本身 + 地球 + 月球系 月球系：月球系本身 + 月球 每一个空间体系都是相互独立运作，但在他们共同作用下，构成了一个复杂的空间体系。\n思考题：如何实现一辆简单的，有 4 个滚动轮子的汽车？\n补充一个类：AxesHelper 在传统的 3D 制作软件中，都会直观的显示出 X、Y、Z 网格线，帮助我们比较直观的查看 物体所在网格的位置。\n在 Three.js 中，可以通过给空间网格添加 AxesHeler 实例来让渲染的时候，显示出 XYZ 网格。\n具体用法：请将以下代码，添加到本文的示例代码中\nuseEffect(() =\u003e { ... //显示轴线 nodeArr.forEach((item) =\u003e { const axes = new Three.AxesHelper() const material = axes.material as Three.Material material.depthTest = false axes.renderOrder = 1 // renderOrder 的该值默认为 0，这里设置为 1 ，目的是为了提高优先级，避免被物体本身给遮盖住 item.add(axes) }) ... }, [canvasRef]) 关于 Three.js 中 场景、空间 的概念和基本用法，先讲解到这里。在后续稍微复杂点的项目中，都会有大量 空间 相互嵌套 的使用需求。\n空间的相互嵌套才构建出了复杂的 3D 场景。\n学习到本篇，是否有些心累的？感觉贴出来的示例代码越来越长，越来越复杂了？ 打起精神，继续加油吧。\n下一节，开始讲一下 决定物体外观被渲染成什么样子的 “材质” 。\n","wordCount":"4358","inLanguage":"en","datePublished":"2023-12-19T17:11:35+08:00","dateModified":"2023-12-19T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/threejs/08-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9C%BA%E6%99%AF/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>08-Three.js基础之场景</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></div>9 min&nbsp;·&nbsp;<span title='2023-12-19 17:11:35 +0800 +0800'>2023/12/19</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e5%9c%ba%e6%99%af%e5%9b%bescene-graph%e7%9a%84%e6%a6%82%e5%bf%b5%e8%a7%a3%e9%87%8a aria-label="场景图(scene graph)的概念解释">场景图(scene graph)的概念解释</a><ul><li><a href=#%e5%9c%ba%e6%99%af%e4%b8%8e%e5%9c%ba%e6%99%af%e5%9b%be%e7%9a%84%e5%85%b3%e7%b3%bb aria-label=场景与场景图的关系>场景与场景图的关系</a></li><li><a href=#%e5%9c%ba%e6%99%af%e5%9b%be%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84 aria-label=场景图的数据结构>场景图的数据结构</a></li><li><a href=#%e5%9c%ba%e6%99%af%e5%9b%be%e7%a9%ba%e9%97%b4%e7%9a%84%e5%90%ab%e4%b9%89 aria-label=场景图(空间)的含义>场景图(空间)的含义</a></li><li><a href=#%e5%9c%ba%e6%99%af%e7%9a%84%e5%87%a0%e4%b8%aa%e6%a6%82%e5%bf%b5 aria-label=场景的几个概念>场景的几个概念</a></li><li><a href=#%e6%a6%82%e5%bf%b51%e4%b8%80%e4%b8%aa%e5%b1%80%e9%83%a8%e7%9a%84%e7%9b%b8%e5%af%b9%e7%a9%ba%e9%97%b4%e5%8d%b3%e4%b8%ba%e4%b8%80%e4%b8%aa%e5%9c%ba%e6%99%af aria-label=概念1：一个局部的相对空间，即为一个场景>概念1：一个局部的相对空间，即为一个场景</a></li><li><a href=#%e6%a6%82%e5%bf%b52%e4%b8%80%e4%b8%aa%e7%a9%ba%e9%97%b4%e5%9c%ba%e6%99%af-%e5%8f%88%e5%8f%af%e8%83%bd%e6%98%af%e7%94%b1-%e5%87%a0%e4%b8%aa%e5%ad%90%e7%a9%ba%e9%97%b4%e5%9c%ba%e6%99%af-%e7%bb%84%e5%90%88%e8%80%8c%e6%88%90 aria-label="概念2：一个空间(场景) 又可能是由 几个子空间(场景) 组合而成">概念2：一个空间(场景) 又可能是由 几个子空间(场景) 组合而成</a></li><li><a href=#%e6%a6%82%e5%bf%b53%e8%a1%a8%e9%9d%a2%e4%b8%8a%e6%b7%bb%e5%8a%a0%e6%9f%90%e5%9c%ba%e6%99%af%e4%bd%86%e5%ae%9e%e9%99%85%e4%b8%8a%e6%89%a7%e8%a1%8c%e7%9a%84%e6%98%af%e5%90%88%e5%b9%b6%e5%9c%ba%e6%99%af aria-label=概念3：表面上添加某场景，但实际上执行的是合并场景>概念3：表面上添加某场景，但实际上执行的是合并场景</a></li><li><a href=#%e6%a6%82%e5%bf%b54%e4%b8%80%e4%b8%aa%e5%ad%90%e7%a9%ba%e9%97%b4%e5%9c%ba%e6%99%af%e5%8f%aa%e9%9c%80%e8%a6%81%e5%85%b3%e6%b3%a8%e5%92%8c%e4%bb%96%e6%9c%80%e7%b4%a7%e5%af%86%e7%9b%b8%e5%85%b3%e7%9a%84%e7%a9%ba%e9%97%b4%e5%8d%b3%e5%8f%af aria-label=概念4：一个子空间(场景)只需要关注和他最紧密相关的空间即可>概念4：一个子空间(场景)只需要关注和他最紧密相关的空间即可</a><ul><li><a href=#%e6%a6%82%e5%bf%b54%e5%bc%95%e7%94%b3%e5%87%ba%e6%9d%a5%e7%9a%84%e5%8f%a6%e5%a4%96%e4%b8%80%e4%b8%aa%e6%a6%82%e5%bf%b5%e9%80%9a%e8%bf%87%e7%a9%ba%e9%97%b4%e5%b5%8c%e5%a5%97%e6%9d%a5%e6%94%b9%e5%8f%98%e5%8e%9f%e6%9c%89%e7%9a%84%e7%9b%b8%e5%af%b9%e7%8a%b6%e6%80%81 aria-label=概念4引申出来的另外一个概念：通过空间嵌套来改变原有的相对状态>概念4引申出来的另外一个概念：通过空间嵌套来改变原有的相对状态</a></li><li><a href=#%e4%b8%be%e4%be%8b%e8%af%b4%e6%98%8e1%e4%bf%ae%e6%94%b9%e6%96%87%e5%ad%97%e5%af%b9%e8%b1%a1%e7%9a%84%e6%97%8b%e8%bd%ac%e4%b8%ad%e5%bf%83%e7%82%b9 aria-label=举例说明1：修改文字对象的旋转中心点>举例说明1：修改文字对象的旋转中心点</a></li><li><a href=#%e4%b8%be%e4%be%8b%e8%af%b4%e6%98%8e2%e5%88%9b%e5%bb%ba%e6%9c%88%e7%90%83%e4%b8%8e%e5%9c%b0%e7%90%83%e7%9a%84%e7%9b%b8%e5%af%b9%e7%a9%ba%e9%97%b4 aria-label=举例说明2：创建月球与地球的相对空间>举例说明2：创建月球与地球的相对空间</a></li></ul></li><li><a href=#%e5%9c%ba%e6%99%af%e7%a9%ba%e9%97%b4%e7%9a%84%e6%9c%80%e5%b8%b8%e8%a7%81%e6%93%8d%e4%bd%9c aria-label=场景(空间)的最常见操作>场景(空间)的最常见操作</a></li></ul></li><li><a href=#%e5%9c%ba%e6%99%af%e7%9a%84%e7%a4%ba%e4%be%8b%e5%a4%aa%e9%98%b3%e5%9c%b0%e7%90%83%e6%9c%88%e4%ba%ae aria-label=场景的示例：太阳、地球、月亮>场景的示例：太阳、地球、月亮</a><ul><ul><li><a href=#%e6%88%91%e4%bb%ac%e6%a8%a1%e6%8b%9f%e5%87%ba%e4%bb%a5%e4%b8%8b%e5%9c%ba%e6%99%af aria-label=我们模拟出以下场景>我们模拟出以下场景</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e6%96%87%e4%bb%b6%e8%af%b4%e6%98%8e aria-label=代码文件说明>代码文件说明</a></li><li><a href=#%e4%bb%a3%e7%a0%81%e6%a0%b8%e5%bf%83%e8%af%b4%e6%98%8e aria-label=代码核心说明>代码核心说明</a></li><li><a href=#%e8%a1%a5%e5%85%85%e8%af%b4%e6%98%8e aria-label=补充说明>补充说明</a></li><li><a href=#%e5%85%b7%e4%bd%93%e7%9a%84%e4%bb%a3%e7%a0%81 aria-label=具体的代码>具体的代码</a></li><li><a href=#create-somethingjs aria-label=create-something.js>create-something.js</a></li><li><a href=#indextsx aria-label=index.tsx>index.tsx</a></li><li><a href=#%e4%b8%8a%e8%bf%b0%e4%bb%a3%e7%a0%81%e5%85%b1%e5%90%8c%e6%9e%84%e5%bb%ba%e5%87%ba%e7%9a%84%e7%a9%ba%e9%97%b4%e4%bd%93%e7%b3%bb aria-label=上述代码共同构建出的空间体系>上述代码共同构建出的空间体系</a></li></ul></ul></li><li><a href=#%e8%a1%a5%e5%85%85%e4%b8%80%e4%b8%aa%e7%b1%bbaxeshelper aria-label=补充一个类：AxesHelper>补充一个类：AxesHelper</a></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p>再次回顾一下 Three.js 3 大 核心要素：场景、镜头、渲染器</p><p><strong>本文主要将 Three.js 中的 场景，但是请注意，本文讲的场景实际上是指 场景图(scene graph)，而不是单指 我们之前示例代码中用到过的 场景 Three.Scene。</strong></p><p>但是请注意，本文讲的场景实际上是指 场景图(scene graph)，而不是单指 我们之前示例代码中用到过的 场景 Three.Scene。</p><h2 id=场景图scene-graph的概念解释>场景图(scene graph)的概念解释<a hidden class=anchor aria-hidden=true href=#场景图scene-graph的概念解释>#</a></h2><h3 id=场景与场景图的关系>场景与场景图的关系<a hidden class=anchor aria-hidden=true href=#场景与场景图的关系>#</a></h3><p><strong>SceneGraph 准确的翻译应该是叫：场景图，但是本文中，我有时依然倔强得把他叫做 &ldquo;场景&rdquo;。</strong></p><p><strong>但无论我怎么称呼它，请你记得：场景(Three.Scene) 只是 场景图 中的一种。</strong></p><h3 id=场景图的数据结构>场景图的数据结构<a hidden class=anchor aria-hidden=true href=#场景图的数据结构>#</a></h3><p>抛开 Three.js 不谈，我们先看一下在数据结构中，树与图 的概念区分。</p><p><strong>树：一种 分层 数据的抽象模型</strong></p><blockquote><p>呈现出的是像大树枝一样的结构，根据结构特征还可以划分为 二叉树、红黑树、大顶树、小顶树等等</p></blockquote><p><strong>图：网络结构的抽象模型，是一组由边连接的节点</strong></p><blockquote><p>呈现出的是像蜘蛛网、道路网、航班线路一样的结构</p></blockquote><p>回到 Three.js 中。</p><p><strong>请务必记得：</strong></p><ol><li>场景图 中的 图，并非数据结构中的图</li><li><strong>场景图的数据结构并非 图，而是 树</strong></li></ol><p><strong>补充一下：</strong></p><p>在有一些教程示例代码中，当循环遍历 场景 中物体对象时，你或许会看到这样的代码：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>他使用的是：xxx.forEach((node) =&gt; { node ....}) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>而不是：xxx.forEach((itme) =&gt; { item ...})
</span></span></code></pre></div><p>尽管无论数组元素变量名是叫 node 还是 item，实际上效果是相同的，但是<strong>他为什么会用 node 这个单词呢？</strong></p><p>答：因为<strong>场景图的数据结构是树，而场景上的物体对象实际就是树结构中的一个节点</strong>，节点对应的单词就是 node。</p><h3 id=场景图空间的含义>场景图(空间)的含义<a hidden class=anchor aria-hidden=true href=#场景图空间的含义>#</a></h3><p><strong>在 Three.js 中，场景即空间，而 空间 包含以下几种情况</strong>：</p><ol><li><p>由 Scene 创建的普通场景、普通场景中还可以添加雾(Fog、FogExp2)从而变成具有雾化效果的场景</p><blockquote><p>无论哪种场景下，都可以添加 Object3D、Mesh</p></blockquote><blockquote><p>Scene 场景下，距离镜头越远的物体看上去越小，但清晰度不变<br>包含 雾(Fog、FogExp2) 场景下，距离镜头越远的物体不光看上去越小，同时被雾气环绕</p></blockquote><blockquote><p>对于现阶段的我们来说，目前主要以使用 Scene 场景为主，Fog、FogExp2 会在以后学习和使用</p></blockquote></li><li><p>由 Object3D 创建的 空白空间</p><blockquote><p>可以添加 Mesh</p></blockquote></li><li><p>由 Mesh 创建的 具体的物体所在的网格空间</p><blockquote><p>可以添加其他的 Mesh</p></blockquote></li></ol><blockquote><p>理论上，Object3D 和 Mesh 是可以互相添加，互相嵌套的，最终会构成一个复杂的空间体系</p></blockquote><blockquote><p>请注意，为了避免 “场景图” 这 3 个字过于绕口，以及为了方便理解，在下面文字中，我会将 场景图 称呼为 场景或空间</p></blockquote><h3 id=场景的几个概念>场景的几个概念<a hidden class=anchor aria-hidden=true href=#场景的几个概念>#</a></h3><h3 id=概念1一个局部的相对空间即为一个场景>概念1：一个局部的相对空间，即为一个场景<a hidden class=anchor aria-hidden=true href=#概念1一个局部的相对空间即为一个场景>#</a></h3><p>例如太阳系就是一个空间(场景)</p><h3 id=概念2一个空间场景-又可能是由-几个子空间场景-组合而成>概念2：一个空间(场景) 又可能是由 几个子空间(场景) 组合而成<a hidden class=anchor aria-hidden=true href=#概念2一个空间场景-又可能是由-几个子空间场景-组合而成>#</a></h3><p>太阳系由 8 大行星构成</p><p>行星除了本身之外还包卫星，例如地球和月球</p><p>地球上又包含陆地和海洋</p><p>陆地上又包含中国，中国包含你此刻所处的空间</p><h3 id=概念3表面上添加某场景但实际上执行的是合并场景>概念3：表面上添加某场景，但实际上执行的是合并场景<a hidden class=anchor aria-hidden=true href=#概念3表面上添加某场景但实际上执行的是合并场景>#</a></h3><p>例如 sceneA.add(sceneB)，表面上看 sceneA 添加了 sceneB，sceneB 称为了 sceneA 的子场景，但事实上根本并不是这样！</p><p><strong>什么？这岂不是和 概念 2 完全相悖？</strong></p><p><strong>没错！确实是即合并又互相独立。</strong></p><p><strong>所谓独立：sceneB 中的元素(物体、灯光)的坐标位置继续保持独立</strong></p><p><strong>所谓合并：sceneB中的元素(物体、灯光)被复制添加到其他场景中，例如 场景B 中的灯光会影响 场景C</strong></p><p><strong>举一个很容易犯错的例子：</strong></p><p>假设有 环境灯光 lightB、lightC，和 场景 sceneA、sceneB、sceneC</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>sceneB.add(lightB) //场景B 中添加 灯光B
</span></span><span style=display:flex><span>sceneC.add(lightC) //场景C 中添加 灯光C
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>sceneA.add(sceneB) //场景A 中添加 场景B
</span></span><span style=display:flex><span>sceneA.add(sceneC) //场景A 中添加 场景C
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>renderer.render(sceneA,camera) //使用场景渲染器，将 场景A 渲染出来
</span></span></code></pre></div><p><strong>你可能以为 灯光B 只在 场景B 中起作用、灯光C 只在 场景C 中起作用。</strong></p><p><strong>但事实根本不是这样，上面代码渲染过后，你会发现：场景B 和 场景C 中，分别都受到 环境灯光B 和 环境灯光C。</strong></p><p><strong>因为环境灯光是全局的、环境灯光在场景中无处不在、会影响场景中全部的物体。</strong></p><p><strong>假设不是环境灯光，而是普通的平行灯光，事实上依然会影响(照耀)到其他 “子场景”上的物体，只不过可能因为距离设定原因，不会像全局环境光那样影响明显。</strong></p><p><strong>为什么会这样？</strong></p><p>我们查看一下 scene.add() 函数源码：</p><blockquote><p>注意：Scene 继承于 Object3D，所以 scene.add() 方法实际上是由 Object3D 定义的。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>add: function (object) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (arguments.length &gt; 1) {
</span></span><span style=display:flex><span>        for (let i = 0; i &lt; arguments.length; i++) {
</span></span><span style=display:flex><span>            this.add(arguments[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        return this;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if (object === this) {
</span></span><span style=display:flex><span>        console.error(&#34;THREE.Object3D.add: object can&#39;t be added as a child of itself.&#34;, object);
</span></span><span style=display:flex><span>        return this;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    if ((object &amp;&amp; object.isObject3D)) {
</span></span><span style=display:flex><span>        if (object.parent !== null) {
</span></span><span style=display:flex><span>            object.parent.remove(object);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        object.parent = this;
</span></span><span style=display:flex><span>        this.children.push(object);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        object.dispatchEvent(_addedEvent);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    } else {
</span></span><span style=display:flex><span>        console.error(&#34;THREE.Object3D.add: object not an instance of THREE.Object3D.&#34;, object);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    return this;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>源码分析：</strong></p><ol><li>if (object.parent !== null) { object.parent.remove(object); } //如果元素(物体、灯光)拥有父级，则将该元素从父级中删除</li><li>object.parent = this; //将元素(物体、灯光)的父级指向 this(自己)</li><li>this.children.push(object); //将元素(物体、灯光)添加到自己场景中的 children 中</li></ol><p>经过以上 3 步操作，<strong>add() 函数实现了 将 子场景元素拆散、合并到自己(最外层场景、顶场景)中</strong>。</p><p><strong>假设我就希望有若干个“子场景”，子场景中的灯光(哪怕是环境光)是独立，不会影响其他 子场景的，怎么实现？</strong></p><p>答：只能声明多个 渲染器(WebGLRenderer)，每个渲染器渲染一个场景(Scene)、每个场景内添加一种光源。</p><blockquote><p>提前预告：在后续讲解 灯光 那一章节中，就会运用到这个知识点。</p></blockquote><h3 id=概念4一个子空间场景只需要关注和他最紧密相关的空间即可>概念4：一个子空间(场景)只需要关注和他最紧密相关的空间即可<a hidden class=anchor aria-hidden=true href=#概念4一个子空间场景只需要关注和他最紧密相关的空间即可>#</a></h3><p>假设你此刻在家里，那么你的相对空间就只针对家里即可，尽管你此刻所处的地球正在自转，你无需关心这个事情。</p><p>月球也可能只关心它是否围着地球转，而不需要关心他在太阳系中的运动轨迹</p><h4 id=概念4引申出来的另外一个概念通过空间嵌套来改变原有的相对状态>概念4引申出来的另外一个概念：通过空间嵌套来改变原有的相对状态<a hidden class=anchor aria-hidden=true href=#概念4引申出来的另外一个概念通过空间嵌套来改变原有的相对状态>#</a></h4><ul><li><strong>一个 空间A 嵌套进入另外一个 空间B，此时 空间A 将会拥有 空间B 的一些属性，例如 空间A 会随着 空间B 一起缩放</strong></li><li><strong>两个子空间 A和B 都嵌套进另外一个空间 C，此时 空间A、空间B 相对独立且共存</strong></li></ul><h4 id=举例说明1修改文字对象的旋转中心点>举例说明1：修改文字对象的旋转中心点<a hidden class=anchor aria-hidden=true href=#举例说明1修改文字对象的旋转中心点>#</a></h4><p>默认情况下，Three.js 中创建的 TextBufferGeometry 对象旋转点位于左侧。</p><p>为了让 文字对象 看上去以 中心位置 为中心点旋转，那么可以这样操作：</p><ol><li><p>通过 new Object3D() 创建 空间A</p></li><li><p>通过 new Mesh( new TextBufferGeometry({ &mldr; } ), createMaterial() ) 创建文字对象</p></li><li><p>修改文字的中心点</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>geometry.computeBoundingBox()
</span></span><span style=display:flex><span>geometry.boundingBox?.getCenter(mesh.position).multiplyScalar(-1)
</span></span></code></pre></div></li><li><p>将 文字对象(网格) 添加到 空间A 中，同时将 空间A 添加到场景中</p></li></ol><p>经过这样操作过后，即可将 文字对象 文字对象的中心点改为中间。</p><h4 id=举例说明2创建月球与地球的相对空间>举例说明2：创建月球与地球的相对空间<a hidden class=anchor aria-hidden=true href=#举例说明2创建月球与地球的相对空间>#</a></h4><p>太阳和地球构成一个相对空间、地球与月亮也构成一个相对空间。</p><p>假设我们现在的目标是创建 月球与地球的相对空间，那么可以这样操作：</p><ol><li><p>创建地球对象 A、月球对象 B</p><blockquote><p>“地球对象”，更加精准的描述应该是：地球对应的网格，也就是 “地球本身的空间”</p><p>为了不让月球和地球重叠在一起，通常情况下会给 月球对象 B 设置 .position.x = xx，好让地球和月球之间存在一定的距离</p></blockquote></li><li><p>通过 new Object3D() 创建空间 C</p></li><li><p>将 A、B 都添加到 C 中</p></li><li><p>将 C 添加到主场景中</p></li></ol><p>经过这样操作后，主场景中包含 C，而 C 包含 A、B，至此形成了一个 地球和月球 共同存在的空间。</p><h3 id=场景空间的最常见操作>场景(空间)的最常见操作<a hidden class=anchor aria-hidden=true href=#场景空间的最常见操作>#</a></h3><ol><li>将 空间A 加入到 空间B：B.add(A)</li><li>设置空间 A 在空间B 中的位置：A.position.x = xxx</li></ol><h2 id=场景的示例太阳地球月亮>场景的示例：太阳、地球、月亮<a hidden class=anchor aria-hidden=true href=#场景的示例太阳地球月亮>#</a></h2><h4 id=我们模拟出以下场景>我们模拟出以下场景<a hidden class=anchor aria-hidden=true href=#我们模拟出以下场景>#</a></h4><ol><li>月球自转的同时，围绕地球旋转</li><li>地球自转的同时，围绕太阳旋转</li><li>太阳仅自转，位置不变</li></ol><blockquote><p>本文的重点在于讲解 场景 的概念，若对代码中某些 方法或属性的使用 不太能够理解也没有关系，将来会慢慢学习到。</p></blockquote><h4 id=代码文件说明>代码文件说明<a hidden class=anchor aria-hidden=true href=#代码文件说明>#</a></h4><ol><li><p>我们将在 src/components/hello-scene/ 目录下创建 index.stx 作为本次演示主文件。</p></li><li><p>与以往代码不同，这次我们将创建 太阳、地球、月亮、以及 光源 的过程迁移到另外一个单独的文件中 ，好让我们在 useEffect 中的代码更加清爽一些。</p><p>对应的文件为 src/components/hello-scene/create-something.ts</p></li></ol><h4 id=代码核心说明>代码核心说明<a hidden class=anchor aria-hidden=true href=#代码核心说明>#</a></h4><ol><li><p>我们将创建一个球体，让太阳、地球、月亮都由这个球体创建而来，只不过每个球体网格在材质(颜色)、大小方面不同。</p></li><li><p>我们将创建 3 个相对空间：</p><ol><li><p>月球相对地球的轨道空间</p><blockquote><p>这个空间中只有月球，因为设置了偏差(poisition.x = 2)，所以月球会做圆形轨道运动</p></blockquote></li><li><p>地球(含月球)相对太阳的轨道空间</p><blockquote><p>这个空间中有地球(含月球)，同样因为设置了偏差(position.x = 10)，所以会整体做圆形轨道运动</p></blockquote></li><li><p>太阳与地球轨道构成的相对空间</p><blockquote><p>这个空间包含太阳、地球(含月球)</p></blockquote></li></ol></li></ol><h4 id=补充说明>补充说明<a hidden class=anchor aria-hidden=true href=#补充说明>#</a></h4><ol><li><p>为了让我们更加容易看到 球体 的自转，所以无论是太阳还是地球或月亮，外形都设置成一个 六边形的球体。</p></li><li><p>我们只是为了演示 相对空间 的使用，所以 太阳、月亮、地球 的尺寸、自转频率、位置关系等是随意设置的值，并不是真实中的大小比例。</p><blockquote><p>科普一下：实际中，太阳直径是地球直径的 109 倍、地球直径是月球直径的 4 倍</p></blockquote></li></ol><h4 id=具体的代码>具体的代码<a hidden class=anchor aria-hidden=true href=#具体的代码>#</a></h4><h4 id=create-somethingjs>create-something.js<a hidden class=anchor aria-hidden=true href=#create-somethingjs>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { Mesh, MeshPhongMaterial, Object3D, PointLight, SphereBufferGeometry } from &#34;three&#34;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//创建一个球体
</span></span><span style=display:flex><span>const sphere = new SphereBufferGeometry(1, 6, 6) //球体为6边形，目的是为了方便我们观察到他在自转
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//创建太阳
</span></span><span style=display:flex><span>const sunMaterial = new MeshPhongMaterial({ emissive: 0xFFFF00 })
</span></span><span style=display:flex><span>const sunMesh = new Mesh(sphere, sunMaterial)
</span></span><span style=display:flex><span>sunMesh.scale.set(4, 4, 4) //将球体尺寸放大 4 倍
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//创建地球
</span></span><span style=display:flex><span>const earthMaterial = new MeshPhongMaterial({ color: 0x2233FF, emissive: 0x112244 })
</span></span><span style=display:flex><span>const earthMesh = new Mesh(sphere, earthMaterial)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//创建月球
</span></span><span style=display:flex><span>const moonMaterial = new MeshPhongMaterial({ color: 0x888888, emissive: 0x222222 })
</span></span><span style=display:flex><span>const moonMesh = new Mesh(sphere, moonMaterial)
</span></span><span style=display:flex><span>moonMesh.scale.set(0.5, 0.5, 0.5) //将球体尺寸缩小 0.5 倍
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//创建一个 3D 空间，用来容纳月球，相当于月球轨迹空间
</span></span><span style=display:flex><span>export const moonOribit = new Object3D()
</span></span><span style=display:flex><span>moonOribit.position.x = 2
</span></span><span style=display:flex><span>moonOribit.add(moonMesh)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//创建一个 3D 空间，用来容纳地球，相当于地球轨迹空间
</span></span><span style=display:flex><span>export const earthOrbit = new Object3D()
</span></span><span style=display:flex><span>earthOrbit.position.x = 10
</span></span><span style=display:flex><span>earthOrbit.add(earthMesh)
</span></span><span style=display:flex><span>earthOrbit.add(moonOribit)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//创建一个 3D 空间，用来容纳太阳和地球(含月球)
</span></span><span style=display:flex><span>export const solarSystem = new Object3D()
</span></span><span style=display:flex><span>solarSystem.add(sunMesh)
</span></span><span style=display:flex><span>solarSystem.add(earthOrbit)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//创建点光源
</span></span><span style=display:flex><span>export const pointLight = new PointLight(0xFFFFFF, 3)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default {}
</span></span></code></pre></div><h4 id=indextsx>index.tsx<a hidden class=anchor aria-hidden=true href=#indextsx>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>import { useRef, useEffect } from &#39;react&#39;
</span></span><span style=display:flex><span>import * as Three from &#39;three&#39;
</span></span><span style=display:flex><span>import { solarSystem, earthOrbit, moonOribit, pointLight } from &#39;@/components/hello-scene/create-something&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>import &#39;./index.scss&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const nodeArr = [solarSystem, earthOrbit, moonOribit] //太阳、地球、月亮对应的网格
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>const HelloScene = () =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    const canvasRef = useRef&lt;HTMLCanvasElement&gt;(null)
</span></span><span style=display:flex><span>    const rendererRef = useRef&lt;Three.WebGLRenderer | null&gt;(null)
</span></span><span style=display:flex><span>    const cameraRef = useRef&lt;Three.PerspectiveCamera | null&gt;(null)
</span></span><span style=display:flex><span>    const sceneRef = useRef&lt;Three.Scene | null&gt;(null)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    useEffect(() =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //创建渲染器
</span></span><span style=display:flex><span>        const renderer = new Three.WebGLRenderer({ canvas: canvasRef.current as HTMLCanvasElement })
</span></span><span style=display:flex><span>        rendererRef.current = renderer
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //创建镜头
</span></span><span style=display:flex><span>        const camera = new Three.PerspectiveCamera(40, 2, 0.1, 1000)
</span></span><span style=display:flex><span>        camera.position.set(0, 50, 0)
</span></span><span style=display:flex><span>        camera.up.set(0, 0, 1)
</span></span><span style=display:flex><span>        camera.lookAt(0, 0, 0)
</span></span><span style=display:flex><span>        cameraRef.current = camera
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //创建场景
</span></span><span style=display:flex><span>        const scene = new Three.Scene()
</span></span><span style=display:flex><span>        scene.background = new Three.Color(0x111111)
</span></span><span style=display:flex><span>        sceneRef.current = scene
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //将太阳系、灯光添加到场景中
</span></span><span style=display:flex><span>        scene.add(solarSystem)
</span></span><span style=display:flex><span>        scene.add(pointLight)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //创建循环渲染的动画
</span></span><span style=display:flex><span>        const render = (time: number) =&gt; {
</span></span><span style=display:flex><span>            time = time * 0.001
</span></span><span style=display:flex><span>            nodeArr.forEach((item) =&gt; {
</span></span><span style=display:flex><span>                item.rotation.y = time
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            renderer.render(scene, camera)
</span></span><span style=display:flex><span>            window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        window.requestAnimationFrame(render)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //添加窗口尺寸变化的监听
</span></span><span style=display:flex><span>        const resizeHandle = () =&gt; {
</span></span><span style=display:flex><span>            const canvas = renderer.domElement
</span></span><span style=display:flex><span>            camera.aspect = canvas.clientWidth / canvas.clientHeight
</span></span><span style=display:flex><span>            camera.updateProjectionMatrix()
</span></span><span style=display:flex><span>            renderer.setSize(canvas.clientWidth, canvas.clientHeight, false)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        resizeHandle()
</span></span><span style=display:flex><span>        window.addEventListener(&#39;resize&#39;, resizeHandle)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        return () =&gt; {
</span></span><span style=display:flex><span>            window.removeEventListener(&#39;resize&#39;, resizeHandle)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }, [canvasRef])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    return (
</span></span><span style=display:flex><span>        &lt;canvas ref={canvasRef} className=&#39;full-screen&#39; /&gt;
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>export default HelloScene
</span></span></code></pre></div><h4 id=上述代码共同构建出的空间体系>上述代码共同构建出的空间体系<a hidden class=anchor aria-hidden=true href=#上述代码共同构建出的空间体系>#</a></h4><ol><li>主场景 Scene 包含 太阳系</li><li>太阳系：太阳系本身 + 太阳 + 地球系(含月球系)</li><li>地球系：地球系本身 + 地球 + 月球系</li><li>月球系：月球系本身 + 月球</li></ol><p><strong>每一个空间体系都是相互独立运作，但在他们共同作用下，构成了一个复杂的空间体系。</strong></p><blockquote><p>思考题：如何实现一辆简单的，有 4 个滚动轮子的汽车？</p></blockquote><h2 id=补充一个类axeshelper>补充一个类：AxesHelper<a hidden class=anchor aria-hidden=true href=#补充一个类axeshelper>#</a></h2><p>在传统的 3D 制作软件中，都会直观的显示出 X、Y、Z 网格线，帮助我们比较直观的查看 物体所在网格的位置。</p><p>在 Three.js 中，可以通过给空间网格添加 AxesHeler 实例来让渲染的时候，显示出 XYZ 网格。</p><p><strong>具体用法：请将以下代码，添加到本文的示例代码中</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>useEffect(() =&gt; {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        //显示轴线
</span></span><span style=display:flex><span>        nodeArr.forEach((item) =&gt; {
</span></span><span style=display:flex><span>            const axes = new Three.AxesHelper()
</span></span><span style=display:flex><span>            const material = axes.material as Three.Material
</span></span><span style=display:flex><span>            material.depthTest = false
</span></span><span style=display:flex><span>            axes.renderOrder = 1 // renderOrder 的该值默认为 0，这里设置为 1 ，目的是为了提高优先级，避免被物体本身给遮盖住
</span></span><span style=display:flex><span>            item.add(axes)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>}, [canvasRef])
</span></span></code></pre></div><p>关于 Three.js 中 场景、空间 的概念和基本用法，先讲解到这里。在后续稍微复杂点的项目中，都会有大量 空间 相互嵌套 的使用需求。</p><p><strong>空间的相互嵌套才构建出了复杂的 3D 场景。</strong></p><p>学习到本篇，是否有些心累的？感觉贴出来的示例代码越来越长，越来越复杂了？ 打起精神，继续加油吧。</p><p>下一节，开始讲一下 决定物体外观被渲染成什么样子的 “材质” 。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/three.js/>Three.js</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/threejs/07-%E5%9B%BE%E5%85%83%E4%B9%8B3d%E6%96%87%E5%AD%97/><span class=title>« Prev</span><br><span>07 图元之3D文字</span></a>
<a class=next href=https://bablvsj.github.io/posts/threejs/09-three.js%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9D%90%E8%B4%A8/><span class=title>Next »</span><br><span>09 Three.js基础之材质</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>