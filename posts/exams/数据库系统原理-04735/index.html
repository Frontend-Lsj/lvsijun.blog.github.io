<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>数据库系统原理 | Bablvsj's Blog</title><meta name=keywords content="exams"><meta name=description content="最新自考笔记 : https://github.com/Eished/self-study-exam_notes https://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx 大纲 2018 版 题型 题数 * 得分 合计 单项选择题 15 题 x 2 分 30 分 填空题 10 题 x 1 分 10 分 设计题 5 题 x 4 分 20 分 简答题 5 题 x 6 分 30 分 综合题 1 题 x"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/exams/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-04735/><link crossorigin=anonymous href=/assets/css/stylesheet.b33b75c69bb2ec0d4accfeaad1d3ba05b272f180583f687c640a522d6492076f.css integrity="sha256-szt1xpuy7A1KzP6q0dO6BbJy8YBYP2h8ZApSLWSSB28=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="数据库系统原理"><meta property="og:description" content="最新自考笔记 : https://github.com/Eished/self-study-exam_notes https://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx 大纲 2018 版 题型 题数 * 得分 合计 单项选择题 15 题 x 2 分 30 分 填空题 10 题 x 1 分 10 分 设计题 5 题 x 4 分 20 分 简答题 5 题 x 6 分 30 分 综合题 1 题 x"><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/exams/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-04735/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-29T13:46:19+08:00"><meta property="article:modified_time" content="2022-10-29T13:46:19+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="数据库系统原理"><meta name=twitter:description content="最新自考笔记 : https://github.com/Eished/self-study-exam_notes https://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx 大纲 2018 版 题型 题数 * 得分 合计 单项选择题 15 题 x 2 分 30 分 填空题 10 题 x 1 分 10 分 设计题 5 题 x 4 分 20 分 简答题 5 题 x 6 分 30 分 综合题 1 题 x"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"数据库系统原理","item":"https://bablvsj.github.io/posts/exams/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-04735/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"数据库系统原理","name":"数据库系统原理","description":"最新自考笔记 : https://github.com/Eished/self-study-exam_notes https://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx 大纲 2018 版 题型 题数 * 得分 合计 单项选择题 15 题 x 2 分 30 分 填空题 10 题 x 1 分 10 分 设计题 5 题 x 4 分 20 分 简答题 5 题 x 6 分 30 分 综合题 1 题 x","keywords":["exams"],"articleBody":"最新自考笔记 : https://github.com/Eished/self-study-exam_notes\nhttps://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx\n大纲 2018 版 题型 题数 * 得分 合计 单项选择题 15 题 x 2 分 30 分 填空题 10 题 x 1 分 10 分 设计题 5 题 x 4 分 20 分 简答题 5 题 x 6 分 30 分 综合题 1 题 x 10 分 10 分 数据库系统原理试卷分析 选择题 30 分（重要） 1 数据库概念发展 2 数据库系统结构 3 关系数据结构 4 关系数据结构 5 关系数据结构 6 数据库设计 7 数据库设计 8 MySQL 操作 9 MYSQL 操作 10 数据库编程 存储过程 11 数据库完整性约束 12 触发器 13 用户权限 14 数据仓库 15 数据仓库 大数据\n填空题 10 分 16DBMS 概念 17 表的态 18 数据库设计 19 数据库设计安全 20 数据库操作语句 21 数据库安全 完整性约束 触发器 22 数据库安全 权限 23 数据库安全 事务 24 数据 25 大数据\n设计题 20 分 (重要) 27 关系代数查询 28SQL 语句查询 29SQL 语句查询 30SQL 语句建立视图\n简答题 30 分 (重要) 31 数据库系统的结构 32 数据库安全完整 33 数据库编程存储 34 数据库编程存储过程体 35 数据库安全事务-封锁\n综合题 10 分\n36 数据库设计 （1）E-R 图 （2）关系模式 （3）SQL 语句建立表\n使用软件 MySQL Workbench 第一章 数据库系统概论 第一节 数据库基本概念 数据(Data)：描述事物的符号记录，是指利用物理符号记录下来的、可以鉴别的信息。\n数据库（DataBase, DB）：指长期存储在计算机内、有组织的、可共享的大量数据的集合。 数据库中存储的数据的三个基本特点：永久存储、有组织、可共享\n数据库管理系统(DataBase Management System, DBMS)：专门用于建立和管理数据库的一套软件，介于应用程序和操作系统之间的。\nDBMS 的主要功能：\n数据库的定义功能（提供数据定义语言（DDL）、定义数据库中的数据对象） 数据组织、存储和管理功能 数据库的操纵功能（提供数据操纵语言（DML）、 基本的数据操作有检索和更新两类） 数据库的事务管理和运行管理 数据库的建立和维护功能（提供实用程序/工具， 完成数据库数据批量装载， 数据库转储， 介质故障恢复， 数据库的重组织和性能监视等） 其它功能 数据库系统(DataBase System,DBS)：指在计算机系统中引入数据库后的系统构成。一般由数据库、数据库管理系统、应用程序、数据库管理员（Database Administrator，DBA）和用户构成。\n1．DBS 的组成：是数据库、硬件、软件和数据库管理员的集合体。 2．软件包括 DBMS、OS、各种主语言和应用开发支撑软件等程序。其中，DBMS 是 DBS 的核心软件，要在 OS 支持下才能工作。 3．数据库管理员（DBA）：是控制数据整体结构的一组人员，负责 DBS 的正常运行，承担创建、监控和维护数据库结构的责任。\n第二节 数据管理技术的发展 数据管理是指对数据进行分类、组织、编码、存储、检索和维护的工作，是数据处理和数据分析的中心问题\n人工管理 （20世纪50年代中之前）\n数据不保存 应用程序管理数据（没有专门的数据库管理系统） 数据面向应用程序（数据不能共享、一组数据只能对应一个程序） 文件系统 （20世纪50年代末–60年代中）\n长期保存 文件系统提供了数据的物理独立性 实现数据的文件级共享, 不能实现数据普通共享, 存在大量数据冗余 数据库系统 （20世纪60年代末–至今）\n数据集成（主要目的） 数据共享性高 数据冗余小 数据一致性 数据独立性高 实施统一管理与控制 减少应用程序开发与维护的工作量 数据库引起不一致的根源是数据冗余，通过消除或控制数据冗余\n数据库系统具有对数据的统一管理和控制功能包括4个方面：\n数据安全性（Security）保护：保护数据，以防止不合法的使用，而造成数据的泄密和破坏 数据的完整性（Integrity）检查：保证数据的正确性、 有效性和相容性 并发控制（Concurrency Control）：对多用户的并发操作加以控制和协调， 防止相互干扰导致的错误 故障恢复（Recovery）：将数据库从错误状态恢复到某一已知的正确状态的功能 第三节 数据库系统的结构 1.3.1 数据库系统的三级模式结构 DBA视角 内部系统结构： 采用三级模式：外模式、模式、内模式 外部系统结构： 集中式结构、分布式结构、并行结构\n数据库应用的用户角度： CS(客户/服务器 )结构、BS(浏览器/服务器)结构\n名称 别称 视图类型 模式 概念模式、逻辑模式 概念视图 外模式 子模式、用户模式 数据视图，即用户视图 内模式 存储模式 内部视图、存储视图 模式（Schema）: 逻辑模式 / 概念模式\n是数据库全体数据的逻辑结构和特征的描述, 是所有用户的公共数据视图。 外模式（External Schema）:子模式 / 用户模式\n数据库用户使用的局部数据的逻辑结构和特征的描述。 一个外模式可以为 多个应用系统所使用，一个应用程序只能使用一个外模式 内模式（Internal Schema）: 存储模式\n是数据物理结构和存储方式的描述。 一个数据库只有一个内模式 三级模式结构的两层映像与数据独立性\n映像，是一种对应规则，它指出映像双方是如何进行转换的。\n逻辑数据独立性：外模式 / 模式 当模式改变时，DBA对 外模式／模式 映像作相应改变， 使外模式保持不变，则应用程序不必修改， 保证了数据与程序的逻辑独立性。\n物理数据独立性：模式 / 内模式 当数据库的存储结构改变了（例如选用了另一种存储结构） ， DBA修改模式／内模式映象， 使模式保持不变。模式不变， 则应用程序不变。 保证了数据与程序的物理独立性。\n应用A/B/C \u003c—\u003e 外模式1/2/3 \u003c– 外模式/模式映像 –\u003e 模式 \u003c– 模式/内模式映像 –\u003e 内模式 \u003c—\u003e 数据库\n外模式/模式映像，存在于外模式和逻辑模式之间，用于定义外模式和逻辑模式之间的对应性。 逻辑模式/内模式映像，存在于逻辑模式和内模式之间，用于定义逻辑模式和内模式之间的对应性。 模式（Schema）：是对数据库逻辑结构和特征的描述，是型的描述， 不涉及具体值，模式是相对稳定的\n实例（Instance）：数据库某一时刻的状态——模式的一个具体值，同一个模式可以有很多实例，实例随数据库中的数据的更新而变动\n例题 “学生选课数据库” 模式：学生、课程和学生选课3个关系模式： 学生表： Student(Sno， Sname， Ssex， Sage， Sdept) 课程表： Course(Cno， Cname， Cpno， Ccredit) 学生选课表： SC(Sno， Cno， Grade) 2014年的学生选课数据库实例： 2014年学校中所有学生的记录 2014年学校开设的所有课程的记录 2014年所有学生选课的记录 2013年的学生选课数据库实例： 2013年学校中所有学生的记录 2013年学校开设的所有课程的记录 2013年所有学生选课的记录 2014年度和2013年度对应“学生选课数据库”模式的2个数据库实例是不同的 1.3.2 数据库系统的运行与应用结构 客户/服务器 (Client/Server, CS) 结构 客户端、前台、表示层主要完成与数据库使用者的交互任务。 服务器、后台、数据层主要负责数据管理\n浏览器/服务器 (Browser/Server, B/S) 结构 三层客户/服务器结构，表示层、处理层（中间层）、数据层\n第四节 数据模型 数据模型是对现实世界数据特征的抽象，通俗地讲数据模型就是现实世界的模拟。\n1.4.1 数据特征与数据模型组成要素 数据模型组成 数据结构–描述系统的静态特征，即数据对象的数据类型、内容、属性以及数据对象之间的练习。 数据操作–描述系统的动态特征，对象的实例允许执行的操作的集合，主要有更新和检索两大类。 数据约束：描述数据结构中数据间的语法和语义关联 1.4.2 数据模型的分类 现实世界 ==\u003e 概念模型 ： 数据库设计人员完成 概念模型 ==\u003e 逻辑模型 ：数据库设计人员完成、数据库设计工具辅助完成 逻辑模型 ==\u003e 物理模型 ：由DBMS完成 graph TD c1((现实世界)) ---- c2((认识抽象)) c2((认识抽象)) --- 信息世界-概念模型 信息世界-概念模型 --- 机器世界-数据库管理系统支持的数据模型 概念模型的表示方法\n实体型: 用矩形表示, 内写实体名 属性: 椭圆表示, 内写名称, 无向边连接相应实体 联系: 菱形表示, 内写名称, 无向边连接实体 概念模型的一种表示方法：实体-联系图（Entity-Relationship，E-R图）\ngraph TD c1((开始)) --- 供应商 c2((账号)) --- 供应商 c3((地址)) --- 供应商 c4((电话号码1)) --- 供应商 供应商 --- b1{供应} b1{供应} --- 零件 零件 --- c5((零件号)) 零件 --- c6((规格)) 零件 --- c7((名称)) 零件 --- b2{库存} b2{库存} --- c16((库存量)) b2{库存} --- 仓库 仓库 --- c13((仓库号)) 仓库 --- c14((面积)) 仓库 --- c15((电话号码2)) 仓库 --- b3{工作} b3{工作} --- 职工 c12((职工号)) --- 职工 c11((姓名1)) --- 职工 概念层数据模型 概念模型的用途\n概念模型用于信息世界的建模\n是现实世界到机器世界的一个中间层次\n是数据库设计的有力工具\n数据库设计人员和用户之间进行交流的语言\n信息世界中的基本概念\n实体(Entity)：客观存在并可相互区别的事物称为实体。可以是具体的人、 事、 物或抽象的概念 属性(Attribute)：实体所具有的某一特性称为属性。 一个实体可以由若干个属性来刻画 码或键(Key)：唯一标识实体的属性集称为码。 域(Domain) 实体型(Entity Type)：用实体名及其属性名集合来抽象和刻画同类实体 实体集(Entity Set)：同一类型实体的集合称为实体集 联系(Relationship)：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型） 内部的联系和实体（型） 之间的联系。 实体内部的联系: 是指组成实体的各属性之间的联系\n实体之间的联系: 通常是指不同实体集之间的联系。实体之间的联系有一对一（1:1)、一对多（1:n）和多对多（m:n）\n逻辑层数据模型，是按照计算机系统的观点对数据建模， 用于DBMS实现。\n网状模型 层次模型 关系模型 二维表 面向对象数据模型 对象关系数据模型 半结构化数据模型 物理层数据模型，是对数据最底层的抽象，用于描述数据在系统内（磁盘上） 的表示方式和存取方法。\n第二章 关系型数据库（重点） 第一节 关系型数据库概述 商用数据库管理系统中，关系模型逐渐取代早起的网状模型和层次模型，成为主流数据模型。\n关系型数据库的基本特征是使用关系数据模型组织数据。 关系型数据库的优点：高级的分过程语言接口、较好的数据独立性、为商品化的关系数据库管理系统的研制做好了技术上的准备。\n关系数据库系统是支持关系模型的数据库系统\n关系模型由关系数据结构、关系操作集合和完整性约束三部分构成\n关系数据结构\n一张扁平的二维表 可以描述现实世界中的实体以及实体间的各种关系 关系操作集合\n集合操作方式（操作对象和结果都是集合） 操作包括：选择、投影、连接、除、并、交、差等查询操作和增、删、改操作两部分构成 结构化查询语言（SQL, Structured Query Language）是关系数据库操作的标准语言 完整性约束\n实体完整性 参照完整性 用户定义的完整性 第二节 关系型数据模型 2.2.1 关系数据结构(字典) 表(Table)\n也称关系, 二维的数据结构; 由唯一表名、若干列、若干行数据组成 关系(Relation)：一个关系对应通常说的一张表，现实世界的实体以及实体间的各种联系均用关系来表示。\n基本关系: 实际存在的表，是实际存储数据的逻辑表示 查询表: 查询结果对应的表 视图表: 由基本表或其它试图表导出的表，是虚表，不对应实际存储的数据 列(Column)：字段或属性，属性的个数成为关系的元或度\n也称字段(Field)或属性; 有唯一列名, 表示一种属性 域(Domain)：属性的取值范围来自某个域。 例：学生年龄属性的域（15～45岁），性别的域是（男， 女）\n行(Row)：称元组(Tuple)或记录(Record)，表中的一行即为一个元组\n分量(Component)：元组中的一个属性值\n码或键(Key)：称码键，唯一标识元组关系的属性。\n超码或超键(Super Key)\n在关系中的一个码移去某个属性, 它任然是这个关系的码, 称为该关系的超码或超键 一般每个关系至少有一个默认的超码, 即该关系的所有属性的集合 候选码或候选键(Candidate Key)：能够唯一标识一条记录的最小属性集\n候选键是没有多余属性的超键 例如， 学号唯一，而且没有多余属性，所以是一个候选键 姓名唯一，而且没有多余属性，所以是一个候选键 （姓名，性别）唯一，但是单独姓名一个属性就能确定这个人是谁，所以性别这个属性就是多余属性，所以（姓名，性别）不是候选键 主属性(Primary Attribute)和非主属性(Nonprimary Attribute)\n关系中包含在任何一个候选码中的属性称为主属性 不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute） 主码或主键(Primary Key)：若干候选码中指定一个用来唯一标识关系的元组\n全码或全键(All-Key)：一个关系模式的所有属性集合是这个关系的主码或主键\n外码或外键(Foreign Key)：关系中的某个属性(或属性组)不是这个关系的主码或候选码, 而是另一关系的主码\n参照关系(Referencing Relation)和被参照关系(Referenced Relation)\n参照关系（从关系）: 外码所在的关系 被参照关系（主关系）: 以外码作为主码的关系 例如，选课表中，学号和课程号是主码，但在课程表中作为外码。 数据类型(Data Type)\n限制该列中存储的数据 关系模式(Relation Schema)：对关系的描述。如关系名（属性1，属性2， …，属性n）、学生（学号， 姓名，年龄，性别，系名，年级）\n数据库有型(type)和 值(value) 之分，关系模式是型, 关系是值; 关系模式是静态的, 关系是动态的、随时间不断变化的。 关系数据库(Relation Database)：所有关系的集合构成一个关系数据库 关系数据库对关系的限定/要求：\n每一个属性都是不可分解的（不允许表中有表，如工资表）\n每一个关系仅仅有一种关系模式\n每一个关系模式中的属性必须命名，属性名不同\n同一个关系中不允许出现候选码或候选键值完全相同的元组\n在关系中元组的顺序（即行序）是无关紧要的，可以任意交换。\n在关系中属性的顺序（即列序）是无关紧要的，可以任意交换。\n数据库表名字段等, 一般不使用中文, 用英文 关系数据库的型: 关系数据库模式, 对关系数据库的描述 关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库 关系必须是规范化的， 满足一定的规范条件 最基本的规范条件：关系的每一个分量必须是一个不可分的数据项， 不允许表中还有表。 下图中工资和扣除是可分的数据项 ,不符合关系模型要求\n域的笛卡尔积空间 给定一组域D_1, D_2, …, D_n，允许其中某些域是相同的。D_1, D_2, …, D_n的笛卡尔积空间为：D_1×D_2×…×D_n={(d_1,d_2,…,d_n)|d_i∈D_i,i=1,2,…,n} 所有域取值的任意组合 笛卡尔积可以看作为关系的“域” 基数（Cardinal number） 若D_i(i=1,2,…,n)为有限集，其基数为m_i，则D_1×D_2×…×D_n的基数M为：M=∏_i^n▒m_i\n笛卡尔积的表示方法 笛卡尔积可以表示为一张二维表 表中的每行对应一个元组，表中的每一列对应一个域\n例题： 给出3个域： D1=导师集合SUPERVISOR=｛张清玫， 刘逸｝ D2=专业集合SPECIALITY=｛计算机专业， 信息专业｝ D3=研究生集合POSTGRADUATE=｛李勇， 刘晨， 王敏｝ D1， D2， D3的笛卡尔积为\n答：D1×D2×D3＝｛ (张清玫，计算机专业，李勇)， (张清玫，计算机专业，刘晨)， (张清玫，计算机专业，王敏)， (张清玫，信息专业，李勇)， (张清玫，信息专业，刘晨)， (张清玫，信息专业，王敏)， (刘逸，计算机专业，李勇)， (刘逸，计算机专业，刘晨)， (刘逸，计算机专业，王敏)， (刘逸，信息专业，李勇)， (刘逸，信息专业，刘晨)， (刘逸，信息专业，王敏) ｝ 笛卡尔积的二维表表示：\nSUPERVISOR SPECIALITY POSTGRADUATE 张清玫 计算机专业 李勇 张清玫 计算机专业 刘晨 张清玫 计算机专业 王敏 张清玫 信息专业 李勇 张清玫 信息专业 刘晨 张清玫 信息专业 王敏 刘逸 计算机专业 李勇 刘逸 计算机专业 刘晨 刘逸 计算机专业 王敏 刘逸 信息专业 李勇 刘逸 信息专业 刘晨 刘逸 信息专业 王敏 2.2.2 关系操作集合 基本的关系操作 查询(Query) 选择\\投影\\连接\\除\\并\\差\\交\\笛卡尔积等 插入(Insert) 删除(Delete) 修改(Update) 关系数据语言的分类 特点: 高度非过程化\n关系代数语言 关系演算语言 两者兼备的语言(SQL) 关系代数σ 关系代数运算符 关系到数操作经过有限次复合的式子称为关系代数操作表达式, 简称为关系代数表达式; 可以使用关系代数表达式表示所需要执行的各种数据库查询和修改处理; 因而, 关系代数也是一种抽象的查询语言, 它通过对关系的操作来表达查询 传统的集合运算：并、差、交、笛卡尔积 4 种运算 学生住宿登记关系 S1\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901001 钟义 男 N201 901002 海燕 女 N302 901003 肖沙 男 N201 学生住宿登记关系 S2\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901004 秦学 男 C101 901005 赵月 女 D303 901003 肖沙 男 N201 并( UNION)： R3=R1UR2，合并元组 S1 U S2\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901001 钟义 男 N201 901002 海燕 女 N302 901003 肖沙 男 N201 901004 秦学 男 C101 901005 赵月 女 D303 差( DIFFERENCE)：R3 = R1 - R2 属于R1但不属于R2 S1 - S2\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901001 钟义 男 N201 901002 海燕 女 N302 交( INTERSECTION)：R3=R1∩R2，找共同元组 S1 ∩ S2\n学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901003 肖沙 男 N201 笛卡尔积( CARTESIAN PRODUCT)：R3=R1×R2 新关系 R3 中元组的前 m 个分量是 R1 的一个元组，后 n 个分量为 R2 的一个元组。 笛卡尔积示例— “学生”关系\n学号（SNO） 姓名(SNAME) 89199 陈星 89200 易南 89201 林俊 笛卡尔积示例— “课程”关系\n课程号（CNO） 课程名(CNAME) 教室（CROOM） 1 操作系统 C5-201 2 数据库 C5 - 307 笛卡尔积示例— “学生选课”关系\n学号（SNO） 姓名(SNAME) 课程号（CNO） 课程名(CNAME) 教室（CROOM） 89199 陈星 1 操作系统 C5-201 89199 陈星 2 数据库 C5 - 307 89200 易南 1 操作系统 C5-201 89199 易南 2 数据库 C5 - 307 89201 林俊 1 操作系统 C5-201 89201 林俊 2 数据库 C5 - 307 专门的关系运算（重点） σ π ÷\n一元专门关系操作包括对单个关系进行垂直分解的投影运算和进行水平分解选择运算； 二元专门关系操作则是对两个关系进行操作，包括连接运算和除 选择(select) σ F(R) : F 为条件表达式, R 为指定的被运算关系名。选择满足条件的记录。 select 关系名 where 条件; 条件是由常数、属性名或列名、比较操作符（\u003e、≥、\u003c、≤、≠）及逻辑操作符（-、∧、V）组成的条件表达式。 例如，查找性别为男性的，select S1 where 性别 = “男” σ 性别 = \"男性\"（S1） 学号（SNO） 姓名(SNAME) 性别（SSEX） 宿舍（SROOM） 901001 钟义 男 N201 901003 肖沙 男 N201 进行逻辑运算（∧与、∨或、¬非） 查询一个宿舍为N201的男生 σ 宿舍 = N201(S1) ∧性别 = 男（S1） 投影 π_A(R) ：选择若干列组成新的关系，新关系中不含重复舒服，R 为被运算关系名, A 为属性序列。 projection 关系名(属性名1, 属性名2, ..., 属性名n); 例如，选择学号、姓名这两列, 。 projection S1 (学号，姓名) π 学号,姓名（S1） 学号（SNO） 姓名(SNAME) 901001 钟义 901002 海燕 901003 肖沙 例如，假设想要找出年龄大于19岁的学生的名字和年龄，则可以将前面的两个查询组合起来，表达式如下：\nπ_Sname,Sage(σ_Sage\u003e19(S)) 连接(join) ⨝，从两个关系的笛卡尔积中选取属性间满足一定条件的元组。R3=R1⨝R2 join 关系名1 AND 关系名2 where 条件; 笛卡尔积 只保留属性值相等 去除重复列 R\nA B C a1 b1 5 a1 b2 6 a2 b3 8 a2 b4 12 S\nB E b1 3 b2 7 b3 10 b3 2 b5 2 一般连接：在一般连接上，A和B分别为R和S上列数相等且可比的属性组，θ为比较运算符\n举个例子：输出 R⋈S 且C","wordCount":"73576","inLanguage":"en","datePublished":"2022-10-29T13:46:19+08:00","dateModified":"2022-10-29T13:46:19+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/exams/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-04735/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>数据库系统原理</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/exams/>exams</a></div>147 min&nbsp;·&nbsp;<span title='2022-10-29 13:46:19 +0800 +0800'>2022/10/29</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e5%a4%a7%e7%ba%b2-2018-%e7%89%88 aria-label="大纲 2018 版">大纲 2018 版</a><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86%e8%af%95%e5%8d%b7%e5%88%86%e6%9e%90 aria-label=数据库系统原理试卷分析>数据库系统原理试卷分析</a></li><li><a href=#%e4%bd%bf%e7%94%a8%e8%bd%af%e4%bb%b6 aria-label=使用软件>使用软件</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%80%e7%ab%a0-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e6%a6%82%e8%ae%ba aria-label="第一章 数据库系统概论">第一章 数据库系统概论</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%8a%82-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="第一节 数据库基本概念">第一节 数据库基本概念</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%8a%82-%e6%95%b0%e6%8d%ae%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e7%9a%84%e5%8f%91%e5%b1%95 aria-label="第二节 数据管理技术的发展">第二节 数据管理技术的发展</a></li><li><a href=#%e7%ac%ac%e4%b8%89%e8%8a%82-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e7%9a%84%e7%bb%93%e6%9e%84 aria-label="第三节 数据库系统的结构">第三节 数据库系统的结构</a><ul><li><a href=#131-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e7%9a%84%e4%b8%89%e7%ba%a7%e6%a8%a1%e5%bc%8f%e7%bb%93%e6%9e%84 aria-label="1.3.1 数据库系统的三级模式结构">1.3.1 数据库系统的三级模式结构</a><ul><ul><ul><li><a href=#%e4%be%8b%e9%a2%98 aria-label=例题>例题</a></li></ul></ul></ul></li><li><a href=#132-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e7%9a%84%e8%bf%90%e8%a1%8c%e4%b8%8e%e5%ba%94%e7%94%a8%e7%bb%93%e6%9e%84 aria-label="1.3.2 数据库系统的运行与应用结构">1.3.2 数据库系统的运行与应用结构</a></li></ul></li><li><a href=#%e7%ac%ac%e5%9b%9b%e8%8a%82-%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b aria-label="第四节 数据模型">第四节 数据模型</a><ul><li><a href=#141-%e6%95%b0%e6%8d%ae%e7%89%b9%e5%be%81%e4%b8%8e%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e7%bb%84%e6%88%90%e8%a6%81%e7%b4%a0 aria-label="1.4.1 数据特征与数据模型组成要素">1.4.1 数据特征与数据模型组成要素</a></li><li><a href=#142-%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%88%86%e7%b1%bb aria-label="1.4.2 数据模型的分类">1.4.2 数据模型的分类</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e7%ab%a0-%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e9%87%8d%e7%82%b9 aria-label="第二章 关系型数据库（重点）">第二章 关系型数据库（重点）</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%8a%82-%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e6%a6%82%e8%bf%b0 aria-label="第一节 关系型数据库概述">第一节 关系型数据库概述</a></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%8a%82-%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b aria-label="第二节 关系型数据模型">第二节 关系型数据模型</a><ul><li><a href=#221-%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%ad%97%e5%85%b8 aria-label="2.2.1 关系数据结构(字典)">2.2.1 关系数据结构(字典)</a></li><li><a href=#222-%e5%85%b3%e7%b3%bb%e6%93%8d%e4%bd%9c%e9%9b%86%e5%90%88 aria-label="2.2.2 关系操作集合">2.2.2 关系操作集合</a><ul><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e7%9a%84%e5%85%b3%e7%b3%bb%e6%93%8d%e4%bd%9c aria-label=基本的关系操作>基本的关系操作</a></li><li><a href=#%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e8%af%ad%e8%a8%80%e7%9a%84%e5%88%86%e7%b1%bb aria-label=关系数据语言的分类>关系数据语言的分类</a></li><li><a href=#%e5%85%b3%e7%b3%bb%e4%bb%a3%e6%95%b0%cf%83 aria-label=关系代数σ>关系代数σ</a><ul><li><a href=#%e4%bc%a0%e7%bb%9f%e7%9a%84%e9%9b%86%e5%90%88%e8%bf%90%e7%ae%97%e5%b9%b6%e5%b7%ae%e4%ba%a4%e7%ac%9b%e5%8d%a1%e5%b0%94%e7%a7%af-4-%e7%a7%8d%e8%bf%90%e7%ae%97 aria-label="传统的集合运算：并、差、交、笛卡尔积 4 种运算">传统的集合运算：并、差、交、笛卡尔积 4 种运算</a></li><li><a href=#%e4%b8%93%e9%97%a8%e7%9a%84%e5%85%b3%e7%b3%bb%e8%bf%90%e7%ae%97%e9%87%8d%e7%82%b9 aria-label=专门的关系运算（重点）>专门的关系运算（重点）</a></li></ul></li></ul></ul></li><li><a href=#223-%e5%85%b3%e7%b3%bb%e7%9a%84%e5%ae%8c%e6%95%b4%e6%80%a7%e7%ba%a6%e6%9d%9f aria-label="2.2.3 关系的完整性约束">2.2.3 关系的完整性约束</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e8%8a%82-%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%a7%84%e8%8c%83%e5%8c%96%e7%90%86%e8%ae%ba-%e9%87%8d%e7%82%b9 aria-label="第三节 关系数据库的规范化理论 （重点）">第三节 关系数据库的规范化理论 （重点）</a><ul><li><a href=#231-%e5%85%b3%e7%b3%bb%e6%a8%a1%e5%bc%8f%e4%b8%ad%e5%8f%af%e8%83%bd%e5%ad%98%e5%9c%a8%e7%9a%84%e5%86%97%e4%bd%99%e5%92%8c%e5%bc%82%e5%b8%b8%e9%97%ae%e9%a2%98 aria-label="2.3.1 关系模式中可能存在的冗余和异常问题">2.3.1 关系模式中可能存在的冗余和异常问题</a></li><li><a href=#232-%e5%87%bd%e6%95%b0%e4%be%9d%e8%b5%96%e4%b8%8e%e5%85%b3%e9%94%ae%e5%ad%97%e9%87%8d%e7%82%b9 aria-label="2.3.2 函数依赖与关键字(重点)">2.3.2 函数依赖与关键字(重点)</a><ul><ul><ul><li><a href=#%e4%be%8b%e9%a2%98-1 aria-label=例题>例题</a></li><li><a href=#%e4%be%8b%e9%a2%98-%e5%80%99%e9%80%89%e5%85%b3%e9%94%ae%e5%ad%97 aria-label=例题-候选关键字>例题-候选关键字</a></li></ul></ul></ul></li><li><a href=#233-%e8%8c%83%e5%bc%8f%e4%b8%8e%e8%a7%84%e8%8c%83%e5%8c%96%e8%bf%87%e7%a8%8b aria-label="2.3.3 范式与规范化过程">2.3.3 范式与规范化过程</a><ul><ul><ul><li><a href=#%e4%be%8b%e9%a2%981nf-4nf aria-label="例题：1NF ~4NF">例题：1NF ~4NF</a></li><li><a href=#%e4%be%8b%e9%a2%98%e8%ae%be%e8%ae%a1%e9%a2%98 aria-label=例题：设计题>例题：设计题</a></li><li><a href=#%e4%be%8b%e9%a2%98%e8%ae%be%e8%ae%a1%e9%a2%98%e7%bb%bc%e5%90%88%e9%a2%98 aria-label=例题：设计题【综合题】>例题：设计题【综合题】</a></li><li><a href=#%e4%be%8b%e9%a2%98bc%e8%8c%83%e5%bc%8f aria-label=例题：BC范式>例题：BC范式</a></li></ul></ul></ul></li><li><a href=#234-%e5%85%b3%e7%b3%bb%e8%a7%84%e8%8c%83%e5%8c%96%e7%90%86%e8%ae%ba%e7%9a%84%e5%ba%94%e7%94%a8 aria-label="2.3.4 关系规范化理论的应用">2.3.4 关系规范化理论的应用</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e7%ab%a0-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1 aria-label="第三章 数据库设计">第三章 数据库设计</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%8a%82-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e6%a6%82%e8%bf%b0 aria-label="第一节 数据库设计概述">第一节 数据库设计概述</a><ul><li><a href=#311-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f aria-label="3.1.1 数据库的生命周期">3.1.1 数据库的生命周期</a></li><li><a href=#312-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e7%9a%84%e7%9b%ae%e6%a0%87 aria-label="3.1.2 数据库设计的目标">3.1.2 数据库设计的目标</a></li><li><a href=#313-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e7%9a%84%e5%86%85%e5%ae%b9 aria-label="3.1.3 数据库设计的内容">3.1.3 数据库设计的内容</a></li><li><a href=#314-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e7%9a%84%e6%96%b9%e6%b3%95 aria-label="3.1.4 数据库设计的方法">3.1.4 数据库设计的方法</a></li><li><a href=#315-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e7%9a%84%e8%bf%87%e7%a8%8b aria-label="3.1.5 数据库设计的过程">3.1.5 数据库设计的过程</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%8a%82-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%ad%a5%e9%aa%a4 aria-label="第二节 数据库设计的基本步骤">第二节 数据库设计的基本步骤</a><ul><li><a href=#321-%e9%9c%80%e6%b1%82%e5%88%86%e6%9e%90%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e7%9a%84%e8%b5%b7%e7%82%b9 aria-label="3.2.1 需求分析(数据库设计的起点)">3.2.1 需求分析(数据库设计的起点)</a></li><li><a href=#322-%e6%a6%82%e5%bf%b5%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1%e6%a6%82%e5%bf%b5%e6%a8%a1%e5%9e%8b aria-label="3.2.2 概念结构设计(概念模型)">3.2.2 概念结构设计(概念模型)</a></li><li><a href=#323-%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1 aria-label="3.2.3 逻辑结构设计">3.2.3 逻辑结构设计</a></li><li><a href=#324-%e7%89%a9%e7%90%86%e8%ae%be%e8%ae%a1 aria-label="3.2.4 物理设计">3.2.4 物理设计</a></li><li><a href=#325-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ae%9e%e6%96%bd aria-label="3.2.5 数据库实施">3.2.5 数据库实施</a></li><li><a href=#326-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%90%e8%a1%8c%e5%92%8c%e7%bb%b4%e6%8a%a4 aria-label="3.2.6 数据库运行和维护">3.2.6 数据库运行和维护</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e8%8a%82-%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e6%96%b9%e6%b3%95%e9%87%8d%e7%82%b9 aria-label="第三节 关系数据库设计方法(重点)">第三节 关系数据库设计方法(重点)</a><ul><li><a href=#331-%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1%e8%bf%87%e7%a8%8b%e4%b8%8e%e5%90%84%e7%ba%a7%e6%a8%a1%e5%bc%8f aria-label="3.3.1 关系数据库设计过程与各级模式">3.3.1 关系数据库设计过程与各级模式</a></li><li><a href=#332-%e6%a6%82%e5%bf%b5%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1%e6%96%b9%e6%b3%95 aria-label="3.3.2 概念结构设计方法">3.3.2 概念结构设计方法</a></li><li><a href=#333-%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1%e6%96%b9%e6%b3%95 aria-label="3.3.3 逻辑结构设计方法">3.3.3 逻辑结构设计方法</a></li><li><a href=#334-%e7%89%a9%e7%90%86%e7%bb%93%e6%9e%84%e8%ae%be%e8%ae%a1%e6%96%b9%e6%b3%95 aria-label="3.3.4 物理结构设计方法">3.3.4 物理结构设计方法</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac%e5%9b%9b%e7%ab%a0-sql-%e4%b8%8e%e5%85%b3%e7%b3%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ba%93%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c aria-label="第四章 SQL 与关系型数据库基本操作">第四章 SQL 与关系型数据库基本操作</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%8a%82-sql-%e6%a6%82%e8%bf%b0 aria-label="第一节 SQL 概述">第一节 SQL 概述</a><ul><li><a href=#411-sql-%e7%9a%84%e5%8f%91%e5%b1%95 aria-label="4.1.1 SQL 的发展">4.1.1 SQL 的发展</a></li><li><a href=#412-sql-%e7%9a%84%e7%89%b9%e7%82%b9 aria-label="4.1.2 SQL 的特点">4.1.2 SQL 的特点</a></li><li><a href=#413-sql-%e7%9a%84%e7%bb%84%e6%88%90 aria-label="4.1.3 SQL 的组成">4.1.3 SQL 的组成</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%8a%82-mysql-%e9%a2%84%e5%a4%87%e7%9f%a5%e8%af%86 aria-label="第二节 MySQL 预备知识">第二节 MySQL 预备知识</a><ul><li><a href=#421-mysql-%e4%bd%bf%e7%94%a8%e5%9f%ba%e7%a1%80 aria-label="4.2.1 MySQL 使用基础">4.2.1 MySQL 使用基础</a></li><li><a href=#422-mysql-%e4%b8%ad%e7%9a%84-sql aria-label="4.2.2 MySQL 中的 SQL">4.2.2 MySQL 中的 SQL</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e8%8a%82-%e6%95%b0%e6%8d%ae%e5%ae%9a%e4%b9%89 aria-label="第三节 数据定义">第三节 数据定义</a><ul><li><a href=#431-%e6%95%b0%e6%8d%ae%e5%ba%93%e6%a8%a1%e5%bc%8f%e5%ae%9a%e4%b9%89 aria-label="4.3.1 数据库模式定义">4.3.1 数据库模式定义</a></li><li><a href=#432-%e8%a1%a8%e5%ae%9a%e4%b9%89%e4%b8%8e%e6%93%8d%e4%bd%9c aria-label="4.3.2 表定义与操作">4.3.2 表定义与操作</a></li><li><a href=#433-%e7%b4%a2%e5%bc%95%e5%ae%9a%e4%b9%89 aria-label="4.3.3 索引定义">4.3.3 索引定义</a></li></ul></li><li><a href=#%e7%ac%ac%e5%9b%9b%e8%8a%82-%e6%95%b0%e6%8d%ae%e6%9b%b4%e6%96%b0 aria-label="第四节 数据更新">第四节 数据更新</a><ul><li><a href=#441-%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae aria-label="4.4.1 插入数据">4.4.1 插入数据</a></li><li><a href=#442-%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae aria-label="4.4.2 删除数据">4.4.2 删除数据</a></li><li><a href=#443-%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae aria-label="4.4.3 修改数据">4.4.3 修改数据</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%94%e8%8a%82-%e6%95%b0%e6%8d%ae%e6%9f%a5%e8%af%a2%e9%9a%be%e7%82%b9 aria-label="第五节 数据查询(难点)">第五节 数据查询(难点)</a><ul><li><a href=#451-select-%e8%af%ad%e5%8f%a5 aria-label="4.5.1 select 语句">4.5.1 select 语句</a></li><li><a href=#452-%e5%88%97%e7%9a%84%e9%80%89%e6%8b%a9%e4%b8%8e%e6%8c%87%e5%ae%9a aria-label="4.5.2 列的选择与指定">4.5.2 列的选择与指定</a></li><li><a href=#453-from-%e5%ad%90%e5%8f%a5%e4%b8%8e%e5%a4%9a%e8%a1%a8%e8%bf%9e%e6%8e%a5%e6%9f%a5%e8%af%a2 aria-label="4.5.3 from 子句与多表连接查询">4.5.3 from 子句与多表连接查询</a></li><li><a href=#454-where-%e5%ad%90%e5%8f%a5%e4%b8%8e%e6%9d%a1%e4%bb%b6%e6%9f%a5%e8%af%a2 aria-label="4.5.4 where 子句与条件查询">4.5.4 where 子句与条件查询</a></li><li><a href=#455-group-by-%e5%ad%90%e5%8f%a5%e4%b8%8e%e5%88%86%e7%bb%84%e6%9f%a5%e8%af%a2 aria-label="4.5.5 group by 子句与分组查询">4.5.5 group by 子句与分组查询</a></li><li><a href=#456-having-%e5%ad%90%e5%8f%a5 aria-label="4.5.6 having 子句">4.5.6 having 子句</a></li><li><a href=#457-order-by-%e5%ad%90%e5%8f%a5 aria-label="4.5.7 order by 子句">4.5.7 order by 子句</a></li><li><a href=#458-limit-%e5%ad%90%e5%8f%a5 aria-label="4.5.8 limit 子句">4.5.8 limit 子句</a></li></ul></li><li><a href=#%e7%ac%ac%e5%85%ad%e8%8a%82-%e8%a7%86%e5%9b%be aria-label="第六节 视图">第六节 视图</a><ul><li><a href=#461-%e5%88%9b%e5%bb%ba%e8%a7%86%e5%9b%be aria-label="4.6.1 创建视图">4.6.1 创建视图</a></li><li><a href=#462-%e5%88%a0%e9%99%a4%e8%a7%86%e5%9b%be aria-label="4.6.2 删除视图">4.6.2 删除视图</a></li><li><a href=#463-%e4%bf%ae%e6%94%b9%e8%a7%86%e5%9b%be%e5%ae%9a%e4%b9%89 aria-label="4.6.3 修改视图定义">4.6.3 修改视图定义</a></li><li><a href=#464-%e6%9f%a5%e7%9c%8b%e8%a7%86%e5%9b%be%e5%ae%9a%e4%b9%89 aria-label="4.6.4 查看视图定义">4.6.4 查看视图定义</a></li><li><a href=#465-%e6%9b%b4%e6%96%b0%e8%a7%86%e5%9b%be%e6%95%b0%e6%8d%ae aria-label="4.6.5 更新视图数据">4.6.5 更新视图数据</a></li><li><a href=#466-%e6%9f%a5%e8%af%a2%e8%a7%86%e5%9b%be%e6%95%b0%e6%8d%ae aria-label="4.6.6 查询视图数据">4.6.6 查询视图数据</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%94%e7%ab%a0-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%bc%96%e7%a8%8b aria-label="第五章 数据库编程">第五章 数据库编程</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%8a%82-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%bc%96%e7%a8%8b aria-label="第一节 数据库编程">第一节 数据库编程</a><ul><li><a href=#511-%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label="5.1.1 存储过程的基本概念">5.1.1 存储过程的基本概念</a></li><li><a href=#512-%e5%88%9b%e5%bb%ba%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b aria-label="5.1.2 创建存储过程">5.1.2 创建存储过程</a></li><li><a href=#513-%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e4%bd%93 aria-label="5.1.3 存储过程体">5.1.3 存储过程体</a><ul><ul><ul><li><a href=#%e8%af%95%e9%a2%98%e5%9c%a8%e4%bd%bf%e7%94%a8%e6%b8%b8%e6%a0%87%e7%9a%84%e8%bf%87%e7%a8%8b%e4%b8%ad%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e4%bb%a5%e4%b8%8b%e5%87%a0%e7%82%b9 aria-label=试题：在使用游标的过程中，需要注意以下几点>试题：在使用游标的过程中，需要注意以下几点</a></li></ul></ul></ul></li><li><a href=#514-%e8%b0%83%e7%94%a8%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e4%bd%93 aria-label="5.1.4 调用存储过程体">5.1.4 调用存储过程体</a></li><li><a href=#515-%e5%88%a0%e9%99%a4%e5%ad%98%e5%82%a8%e8%bf%87%e7%a8%8b%e4%bd%93 aria-label="5.1.5 删除存储过程体">5.1.5 删除存储过程体</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%8a%82-%e5%ad%98%e5%82%a8%e5%87%bd%e6%95%b0 aria-label="第二节 存储函数">第二节 存储函数</a><ul><li><a href=#521-%e5%88%9b%e5%bb%ba%e5%ad%98%e5%82%a8%e5%87%bd%e6%95%b0 aria-label="5.2.1 创建存储函数">5.2.1 创建存储函数</a></li><li><a href=#522-%e8%b0%83%e7%94%a8%e5%ad%98%e5%82%a8%e5%87%bd%e6%95%b0 aria-label="5.2.2 调用存储函数">5.2.2 调用存储函数</a></li><li><a href=#523-%e5%88%a0%e9%99%a4%e5%ad%98%e5%82%a8%e5%87%bd%e6%95%b0 aria-label="5.2.3 删除存储函数">5.2.3 删除存储函数</a></li></ul></li></ul></li><li><a href=#%e7%ac%ac%e5%85%ad%e7%ab%a0-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ae%89%e5%85%a8%e4%b8%8e%e9%98%b2%e6%8a%a4 aria-label="第六章 数据库安全与防护">第六章 数据库安全与防护</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%8a%82-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ae%8c%e6%95%b4%e6%80%a7 aria-label="第一节 数据库完整性">第一节 数据库完整性</a><ul><li><a href=#611-%e5%ae%8c%e6%95%b4%e6%80%a7%e7%ba%a6%e6%9d%9f%e6%9d%a1%e4%bb%b6%e7%9a%84%e4%bd%9c%e7%94%a8%e5%af%b9%e8%b1%a1 aria-label="6.1.1 完整性约束条件的作用对象">6.1.1 完整性约束条件的作用对象</a></li><li><a href=#612-%e5%ae%9a%e4%b9%89%e4%b8%8e%e5%ae%9e%e7%8e%b0%e5%ae%8c%e6%95%b4%e6%80%a7%e7%ba%a6%e6%9d%9f aria-label="6.1.2 定义与实现完整性约束">6.1.2 定义与实现完整性约束</a></li><li><a href=#613-%e5%91%bd%e5%90%8d%e5%ae%8c%e6%95%b4%e6%80%a7%e7%ba%a6%e6%9d%9f aria-label="6.1.3 命名完整性约束">6.1.3 命名完整性约束</a></li><li><a href=#614-%e6%9b%b4%e6%96%b0%e5%ae%8c%e6%95%b4%e6%80%a7%e7%ba%a6%e6%9d%9f aria-label="6.1.4 更新完整性约束">6.1.4 更新完整性约束</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%8a%82-%e8%a7%a6%e5%8f%91%e5%99%a8%e9%9a%be%e7%82%b9 aria-label="第二节 触发器(难点)">第二节 触发器(难点)</a><ul><li><a href=#621-%e5%88%9b%e5%bb%ba%e8%a7%a6%e5%8f%91%e5%99%a8 aria-label="6.2.1 创建触发器">6.2.1 创建触发器</a></li><li><a href=#622-%e5%88%a0%e9%99%a4%e8%a7%a6%e5%8f%91%e5%99%a8 aria-label="6.2.2 删除触发器">6.2.2 删除触发器</a></li><li><a href=#623-%e4%bd%bf%e7%94%a8%e8%a7%a6%e5%8f%91%e5%99%a8 aria-label="6.2.3 使用触发器">6.2.3 使用触发器</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e8%8a%82-%e5%ae%89%e5%85%a8%e6%80%a7%e4%b8%8e%e8%ae%bf%e9%97%ae%e6%8e%a7%e5%88%b6 aria-label="第三节 安全性与访问控制">第三节 安全性与访问控制</a><ul><li><a href=#631-%e7%94%a8%e6%88%b7%e8%b4%a6%e5%8f%b7%e7%ae%a1%e7%90%86 aria-label="6.3.1 用户账号管理">6.3.1 用户账号管理</a></li><li><a href=#632-%e7%94%a8%e6%88%b7%e6%9d%83%e9%99%90%e7%ae%a1%e7%90%86 aria-label="6.3.2 用户权限管理">6.3.2 用户权限管理</a></li></ul></li><li><a href=#%e7%ac%ac%e5%9b%9b%e8%8a%82-%e4%ba%8b%e5%8a%a1%e4%b8%8e%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6-%e9%87%8d%e7%82%b9 aria-label="第四节 事务与并发控制 （重点）">第四节 事务与并发控制 （重点）</a><ul><li><a href=#641-%e4%ba%8b%e5%8a%a1%e7%9a%84%e6%a6%82%e5%bf%b5201810 aria-label="6.4.1 事务的概念(201810)">6.4.1 事务的概念(201810)</a></li><li><a href=#642-%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%89%b9%e5%be%81acid aria-label="6.4.2 事务的特征(ACID)">6.4.2 事务的特征(ACID)</a></li><li><a href=#643-%e5%b9%b6%e5%8f%91%e6%93%8d%e4%bd%9c%e9%97%ae%e9%a2%98 aria-label="6.4.3 并发操作问题">6.4.3 并发操作问题</a></li><li><a href=#644-%e5%b0%81%e9%94%81-%e6%98%af%e6%9c%80%e5%b8%b8%e7%94%a8%e7%9a%84%e5%b9%b6%e5%8f%91%e6%8e%a7%e5%88%b6%e6%8a%80%e6%9c%af aria-label="6.4.4 封锁 是最常用的并发控制技术">6.4.4 封锁 是最常用的并发控制技术</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%94%e7%ab%a0-%e5%a4%87%e4%bb%bd%e4%b8%8e%e6%81%a2%e5%a4%8d aria-label="第五章 备份与恢复">第五章 备份与恢复</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%83%e7%ab%a0-%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ba%94%e7%94%a8%e8%ae%be%e8%ae%a1%e4%b8%8e%e5%bc%80%e5%8f%91%e5%ae%9e%e4%be%8b aria-label="第七章 数据库应用设计与开发实例">第七章 数据库应用设计与开发实例</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%8a%82-%e9%9c%80%e6%b1%82%e6%8f%8f%e8%bf%b0%e4%b8%8e%e5%88%86%e6%9e%90 aria-label="第一节 需求描述与分析">第一节 需求描述与分析</a><ul><li><a href=#711-%e5%8a%9f%e8%83%bd%e6%80%a7%e9%9c%80%e6%b1%82 aria-label="7.1.1 功能性需求">7.1.1 功能性需求</a></li><li><a href=#712-%e9%9d%9e%e5%8a%9f%e8%83%bd%e6%80%a7%e9%9c%80%e6%b1%82 aria-label="7.1.2 非功能性需求">7.1.2 非功能性需求</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%8a%82-%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1 aria-label="第二节 系统设计">第二节 系统设计</a><ul><li><a href=#721-%e5%8a%9f%e8%83%bd%e6%a8%a1%e5%9d%97%e8%ae%be%e8%ae%a1 aria-label="7.2.1 功能模块设计">7.2.1 功能模块设计</a></li><li><a href=#722-%e6%95%b0%e6%8d%ae%e5%ba%93%e8%ae%be%e8%ae%a1 aria-label="7.2.2 数据库设计">7.2.2 数据库设计</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e8%8a%82-%e7%b3%bb%e7%bb%9f%e5%ae%9e%e7%8e%b0 aria-label="第三节 系统实现">第三节 系统实现</a></li><li><a href=#%e7%ac%ac%e5%9b%9b%e8%8a%82-%e7%b3%bb%e7%bb%9f%e6%b5%8b%e8%af%95%e4%b8%8e%e7%bb%b4%e6%8a%a4 aria-label="第四节 系统测试与维护">第四节 系统测试与维护</a></li><li><a href=#%e6%9c%ac%e7%ab%a0%e5%b0%8f%e7%bb%93 aria-label=本章小结>本章小结</a></li></ul></li><li><a href=#%e7%ac%ac%e5%85%ab%e7%ab%a0-%e6%95%b0%e6%8d%ae%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e7%9a%84%e5%8f%91%e5%b1%95 aria-label="第八章 数据管理技术的发展">第八章 数据管理技术的发展</a><ul><li><a href=#%e7%ac%ac%e4%b8%80%e8%8a%82-%e6%95%b0%e6%8d%ae%e5%ba%93%e6%8a%80%e6%9c%af%e5%8f%91%e5%b1%95%e6%a6%82%e8%bf%b0 aria-label="第一节 数据库技术发展概述">第一节 数据库技术发展概述</a><ul><li><a href=#811-%e7%ac%ac%e4%b8%80%e4%bb%a3%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f aria-label="8.1.1 第一代数据库系统">8.1.1 第一代数据库系统</a></li><li><a href=#812-%e7%ac%ac%e4%ba%8c%e4%bb%a3%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f-20%e4%b8%96%e7%ba%aa70%e5%b9%b4%e4%bb%a3%e7%a7%b0%e4%b8%ba%e6%95%b0%e6%8d%ae%e5%ba%93%e6%97%b6%e4%bb%a3 aria-label="8.1.2 第二代数据库系统 （20世纪70年代，称为数据库时代）">8.1.2 第二代数据库系统 （20世纪70年代，称为数据库时代）</a></li><li><a href=#813-%e7%ac%ac%e4%b8%89%e4%bb%a3%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f aria-label="8.1.3 第三代数据库系统">8.1.3 第三代数据库系统</a></li></ul></li><li><a href=#%e7%ac%ac%e4%ba%8c%e8%8a%82-%e6%95%b0%e6%8d%ae%e4%bb%93%e5%ba%93%e4%b8%8e%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98 aria-label="第二节 数据仓库与数据挖掘">第二节 数据仓库与数据挖掘</a><ul><li><a href=#821-%e4%bb%8e%e6%95%b0%e6%8d%ae%e5%ba%93%e5%88%b0%e6%95%b0%e6%8d%ae%e4%bb%93%e5%ba%93 aria-label="8.2.1 从数据库到数据仓库">8.2.1 从数据库到数据仓库</a></li><li><a href=#822-%e6%95%b0%e6%8d%ae%e6%8c%96%e6%8e%98%e6%8a%80%e6%9c%af aria-label="8.2.2 数据挖掘技术">8.2.2 数据挖掘技术</a></li></ul></li><li><a href=#%e7%ac%ac%e4%b8%89%e8%8a%82-%e5%a4%a7%e6%95%b0%e6%8d%ae%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af aria-label="第三节 大数据管理技术">第三节 大数据管理技术</a><ul><li><a href=#831-%e5%a4%a7%e6%95%b0%e6%8d%ae%e5%ae%9a%e4%b9%89 aria-label="8.3.1 大数据定义">8.3.1 大数据定义</a></li><li><a href=#832-%e5%a4%a7%e6%95%b0%e6%8d%ae%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af%e5%85%b8%e5%9e%8b%e4%bb%a3%e8%a1%a8 aria-label="8.3.2 大数据管理技术典型代表">8.3.2 大数据管理技术典型代表</a></li></ul></li></ul></li><li><a href=#last aria-label=Last>Last</a><ul><ul><ul><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%93%8d%e4%bd%9c aria-label=数据库操作>数据库操作</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e8%a1%a8%e6%93%8d%e4%bd%9c aria-label=数据库表操作>数据库表操作</a><ul><ul><li><a href=#%e5%88%9b%e5%bb%ba%e5%ba%93%e8%a1%a8 aria-label=创建库表>创建库表</a></li><li><a href=#%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae aria-label=插入数据>插入数据</a></li><li><a href=#%e4%bd%bf%e7%94%a8-insert-int-set%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae aria-label="使用 insert int ..set插入数据">使用 insert int ..set插入数据</a></li><li><a href=#%e6%8f%92%e5%85%a5%e6%96%b0%e5%88%97--alter----add-column aria-label="插入新列：  alter  &amp;hellip;  add column">插入新列： alter &mldr; add column</a></li><li><a href=#%e5%88%a0%e9%99%a4%e6%95%b0%e6%8d%ae aria-label=删除数据>删除数据</a></li><li><a href=#%e6%9b%b4%e6%96%b0%e6%95%b0%e6%8d%ae-update---set aria-label="更新数据 update  &amp;hellip; set">更新数据 update &mldr; set</a></li><li><a href=#%e6%9f%a5%e7%9c%8b%e6%8c%87%e5%ae%9a%e6%95%b0%e6%8d%ae%e5%ba%93%e8%a1%a8%e4%bd%bf%e7%94%a8%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86 aria-label=查看指定数据库表使用的字符集>查看指定数据库表使用的字符集</a></li><li><a href=#%e4%bf%ae%e6%94%b9%e6%95%b0%e6%8d%ae%e5%ba%93%e8%a1%a8%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86%e4%b8%ba-utf8-%e8%a7%a3%e5%86%b3%e6%8f%92%e5%85%a5%e4%b8%ad%e6%96%87%e6%95%b0%e6%8d%ae%e6%8a%a5%e9%94%99%e7%9a%84%e9%97%ae%e9%a2%98 aria-label="修改数据库表的字符集为 utf8 (解决插入中文数据报错的问题)">修改数据库表的字符集为 utf8 (解决插入中文数据报错的问题)</a></li></ul></ul></li><li><a href=#%e6%95%b0%e6%8d%ae%e6%9f%a5%e8%af%a2 aria-label=数据查询>数据查询</a><ul><ul><li><a href=#case-when-else-end aria-label="case when else end">case when else end</a></li><li><a href=#case-when-then-else-end-%e6%9d%a1%e4%bb%b6 aria-label="case when then else end 条件">case when then else end 条件</a></li><li><a href=#inner-join--%e5%86%85%e8%bf%9e%e6%8e%a5 aria-label="inner join  内连接">inner join 内连接</a></li><li><a href=#%e6%95%b0%e6%8d%ae%e8%8c%83%e5%9b%b4--between-and------in aria-label="数据范围  between and   /   in">数据范围 between and / in</a></li></ul><li><a href=#group-by-%e5%ad%90%e5%8f%a5%e4%b8%8e%e5%88%86%e7%bb%84%e6%9f%a5%e8%af%a2 aria-label="group by 子句与分组查询">group by 子句与分组查询</a></li><li><a href=#having-%e7%94%a8%e4%ba%8e%e8%bf%87%e6%bb%a4%e5%88%86%e7%bb%84 aria-label="having 用于过滤分组">having 用于过滤分组</a></li></ul></li></ul><li><a href=#%e8%a7%86%e5%9b%be aria-label=视图>视图</a><ul><ul><ul><li><a href=#%e5%88%9b%e5%bb%ba%e8%a7%86%e5%9b%be aria-label=创建视图>创建视图</a></li><li><a href=#%e5%88%9b%e5%bb%ba%e8%a7%86%e5%9b%be-%e5%8f%aa%e5%8f%96%e9%83%a8%e5%88%86%e5%8f%82%e6%95%b0 aria-label="创建视图 只取部分参数">创建视图 只取部分参数</a></li><li><a href=#%e6%9f%a5%e8%af%a2%e8%a7%86%e5%9b%be aria-label=查询视图>查询视图</a></li><li><a href=#%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae-1 aria-label=插入数据>插入数据</a></li></ul></ul></li></ul></ul></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><p><strong>最新自考笔记</strong> : <a href=https://github.com/Eished/self-study-exam_notes>https://github.com/Eished/self-study-exam_notes</a></p><p><a href=https://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx>https://github.com/yangyiRunning/DB_course_ware/blob/master/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%8A%80%E6%9C%AF4-%E7%AC%AC%E5%9B%9B%E7%AB%A0.pptx</a></p><h1 id=大纲-2018-版>大纲 2018 版<a hidden class=anchor aria-hidden=true href=#大纲-2018-版>#</a></h1><table><thead><tr><th style=text-align:left>题型</th><th style=text-align:left>题数 * 得分</th><th style=text-align:left>合计</th></tr></thead><tbody><tr><td style=text-align:left>单项选择题</td><td style=text-align:left>15 题 x 2 分</td><td style=text-align:left>30 分</td></tr><tr><td style=text-align:left>填空题</td><td style=text-align:left>10 题 x 1 分</td><td style=text-align:left>10 分</td></tr><tr><td style=text-align:left>设计题</td><td style=text-align:left>5 题 x 4 分</td><td style=text-align:left>20 分</td></tr><tr><td style=text-align:left>简答题</td><td style=text-align:left>5 题 x 6 分</td><td style=text-align:left>30 分</td></tr><tr><td style=text-align:left>综合题</td><td style=text-align:left>1 题 x 10 分</td><td style=text-align:left>10 分</td></tr></tbody></table><h2 id=数据库系统原理试卷分析>数据库系统原理试卷分析<a hidden class=anchor aria-hidden=true href=#数据库系统原理试卷分析>#</a></h2><p><strong>选择题 30 分（重要）</strong>
1 数据库概念发展
2 数据库系统结构
3 关系数据结构
4 关系数据结构
5 关系数据结构
6 数据库设计
7 数据库设计
8 MySQL 操作
9 MYSQL 操作
10 数据库编程 存储过程
11 数据库完整性约束
12 触发器
13 用户权限
14 数据仓库
15 数据仓库 大数据</p><p><strong>填空题 10 分</strong>
16DBMS 概念
17 表的态
18 数据库设计
19 数据库设计安全
20 数据库操作语句
21 数据库安全 完整性约束 触发器
22 数据库安全 权限
23 数据库安全 事务
24 数据
25 大数据</p><p><strong>设计题 20 分 (重要)</strong>
27 关系代数查询
28SQL 语句查询
29SQL 语句查询
30SQL 语句建立视图</p><p><strong>简答题 30 分 (重要)</strong>
31 数据库系统的结构
32 数据库安全完整
33 数据库编程存储
34 数据库编程存储过程体
35 数据库安全事务-封锁</p><p><strong>综合题 10 分</strong></p><p>36 数据库设计
（1）E-R 图
（2）关系模式
（3）SQL 语句建立表</p><h2 id=使用软件>使用软件<a hidden class=anchor aria-hidden=true href=#使用软件>#</a></h2><ul><li><a href=https://dev.mysql.com/downloads/workbench/>MySQL Workbench</a></li></ul><h1 id=第一章-数据库系统概论>第一章 数据库系统概论<a hidden class=anchor aria-hidden=true href=#第一章-数据库系统概论>#</a></h1><h2 id=第一节-数据库基本概念>第一节 数据库基本概念<a hidden class=anchor aria-hidden=true href=#第一节-数据库基本概念>#</a></h2><ul><li><p><strong>数据(Data)</strong>：描述事物的符号记录，是指利用物理符号记录下来的、可以鉴别的信息。</p></li><li><p><strong>数据库（DataBase, DB）</strong>：指长期存储在计算机内、有组织的、可共享的大量数据的集合。
数据库中存储的数据的三个基本特点：永久存储、有组织、可共享</p></li><li><p><strong>数据库管理系统(DataBase Management System, DBMS)</strong>：专门用于建立和管理数据库的一套软件，介于应用程序和操作系统之间的。</p><blockquote><p>DBMS 的主要功能：</p><ol><li>数据库的定义功能（提供数据定义语言（DDL）、定义数据库中的数据对象）</li><li>数据组织、存储和管理功能</li><li>数据库的操纵功能（提供数据操纵语言（DML）、 基本的数据操作有检索和更新两类）</li><li>数据库的事务管理和运行管理</li><li>数据库的建立和维护功能（提供实用程序/工具， 完成数据库数据批量装载， 数据库转储， 介质故障恢复， 数据库的重组织和性能监视等）</li><li>其它功能</li></ol></blockquote></li><li><p><strong>数据库系统(DataBase System,DBS)</strong>：指在计算机系统中引入数据库后的系统构成。一般由数据库、数据库管理系统、应用程序、数据库管理员（Database Administrator，DBA）和用户构成。</p><blockquote><p>1．DBS 的组成：是数据库、硬件、软件和数据库管理员的集合体。
2．软件包括 DBMS、OS、各种主语言和应用开发支撑软件等程序。其中，DBMS 是 DBS 的核心软件，要在 OS 支持下才能工作。
3．数据库管理员（DBA）：是控制数据整体结构的一组人员，负责 DBS 的正常运行，承担创建、监控和维护数据库结构的责任。</p></blockquote></li></ul><h2 id=第二节-数据管理技术的发展>第二节 数据管理技术的发展<a hidden class=anchor aria-hidden=true href=#第二节-数据管理技术的发展>#</a></h2><p>数据管理是指对数据进行<strong>分类、组织、编码、存储、检索和维护</strong>的工作，是数据处理和数据分析的中心问题</p><ol><li><p><strong>人工管理</strong> （20世纪50年代中之前）</p><ol><li><strong>数据不保存</strong></li><li>应用程序管理数据（没有专门的数据库管理系统）</li><li>数据面向应用程序（数据不能共享、一组数据只能对应一个程序）</li></ol></li><li><p><strong>文件系统</strong> （20世纪50年代末&ndash;60年代中）</p><ol><li>长期保存</li><li>文件系统提供了数据的物理独立性</li><li>实现数据的<strong>文件级共享</strong>, 不能实现数据普通共享,</li><li><strong>存在大量数据冗余</strong></li></ol></li><li><p><strong>数据库系统</strong> （20世纪60年代末&ndash;至今）</p><ol><li>数据集成（主要目的）</li><li><strong>数据共享性高</strong></li><li><strong>数据冗余小</strong></li><li>数据一致性</li><li>数据独立性高</li><li>实施统一管理与控制</li><li>减少应用程序开发与维护的工作量</li></ol></li></ol><p>数据库引起不一致的根源是<strong>数据冗余</strong>，通过消除或控制数据冗余</p><p>数据库系统具有对数据的统一管理和控制功能包括4个方面：</p><ol><li>数据安全性（Security）保护：保护数据，以防止不合法的使用，而造成数据的泄密和破坏</li><li>数据的完整性（Integrity）检查：保证数据的正确性、 有效性和相容性</li><li>并发控制（Concurrency Control）：对多用户的并发操作加以控制和协调， 防止相互干扰导致的错误</li><li>故障恢复（Recovery）：将数据库从错误状态恢复到某一已知的正确状态的功能</li></ol><h2 id=第三节-数据库系统的结构>第三节 数据库系统的结构<a hidden class=anchor aria-hidden=true href=#第三节-数据库系统的结构>#</a></h2><h3 id=131-数据库系统的三级模式结构>1.3.1 数据库系统的三级模式结构<a hidden class=anchor aria-hidden=true href=#131-数据库系统的三级模式结构>#</a></h3><p>DBA视角
内部系统结构： 采用三级模式：外模式、模式、内模式
外部系统结构： 集中式结构、分布式结构、并行结构</p><p>数据库应用的用户角度： CS(客户/服务器 )结构、BS(浏览器/服务器)结构</p><table><thead><tr><th style=text-align:left>名称</th><th style=text-align:left>别称</th><th style=text-align:left>视图类型</th></tr></thead><tbody><tr><td style=text-align:left>模式</td><td style=text-align:left>概念模式、逻辑模式</td><td style=text-align:left>概念视图</td></tr><tr><td style=text-align:left>外模式</td><td style=text-align:left>子模式、用户模式</td><td style=text-align:left>数据视图，即用户视图</td></tr><tr><td style=text-align:left>内模式</td><td style=text-align:left>存储模式</td><td style=text-align:left>内部视图、存储视图</td></tr></tbody></table><ul><li><p><strong>模式（Schema）</strong>: 逻辑模式 / 概念模式</p><ul><li>是数据库全体数据的逻辑结构和特征的描述, 是所有用户的公共数据视图。</li></ul></li><li><p><strong>外模式（External Schema）</strong>:子模式 / 用户模式</p><ul><li>数据库用户使用的局部数据的逻辑结构和特征的描述。</li><li>一个外模式可以为 多个应用系统所使用，一个应用程序只能使用一个外模式</li></ul></li><li><p><strong>内模式（Internal Schema）</strong>: 存储模式</p><ul><li>是数据物理结构和存储方式的描述。</li><li>一个数据库只有一个内模式</li></ul></li><li><p><strong>三级模式结构的两层映像与数据独立性</strong></p></li></ul><p><strong>映像</strong>，是一种对应规则，它指出映像双方是如何进行转换的。</p><p><strong>逻辑数据独立性</strong>：外模式 / 模式
当模式改变时，DBA对 外模式／模式 映像作相应改变， 使外模式保持不变，则应用程序不必修改， 保证了数据与程序的逻辑独立性。</p><p><strong>物理数据独立性</strong>：模式 / 内模式
当数据库的存储结构改变了（例如选用了另一种存储结构） ， DBA修改模式／内模式映象， 使模式保持不变。模式不变， 则应用程序不变。 保证了数据与程序的物理独立性。</p><p>应用A/B/C &lt;&mdash;> 外模式1/2/3 &lt;&ndash; 外模式/模式映像 &ndash;> 模式 &lt;&ndash; 模式/内模式映像 &ndash;> 内模式 &lt;&mdash;> 数据库</p><ol><li>外模式/模式映像，存在于外模式和逻辑模式之间，用于定义外模式和逻辑模式之间的对应性。</li><li>逻辑模式/内模式映像，存在于逻辑模式和内模式之间，用于定义逻辑模式和内模式之间的对应性。</li></ol><p>模式（Schema）：是对数据库逻辑结构和特征的描述，是型的描述， 不涉及具体值，模式是相对稳定的</p><p>实例（Instance）：数据库某一时刻的状态——模式的一个具体值，同一个模式可以有很多实例，实例随数据库中的数据的更新而变动</p><h6 id=例题>例题<a hidden class=anchor aria-hidden=true href=#例题>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>“学生选课数据库” 模式：学生、课程和学生选课3个关系模式：
</span></span><span style=display:flex><span> 学生表： Student(Sno， Sname， Ssex， Sage， Sdept)
</span></span><span style=display:flex><span> 课程表： Course(Cno， Cname， Cpno， Ccredit)
</span></span><span style=display:flex><span> 学生选课表： SC(Sno， Cno， Grade)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2014年的学生选课数据库实例：
</span></span><span style=display:flex><span> 2014年学校中所有学生的记录
</span></span><span style=display:flex><span> 2014年学校开设的所有课程的记录
</span></span><span style=display:flex><span> 2014年所有学生选课的记录
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>2013年的学生选课数据库实例：
</span></span><span style=display:flex><span> 2013年学校中所有学生的记录
</span></span><span style=display:flex><span> 2013年学校开设的所有课程的记录
</span></span><span style=display:flex><span> 2013年所有学生选课的记录
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>2014年度和2013年度对应“学生选课数据库”模式的2个数据库实例是不同的
</span></span></code></pre></div><h3 id=132-数据库系统的运行与应用结构>1.3.2 数据库系统的运行与应用结构<a hidden class=anchor aria-hidden=true href=#132-数据库系统的运行与应用结构>#</a></h3><ol><li><p><strong>客户/服务器 (Client/Server, CS) 结构</strong>
客户端、前台、表示层主要完成与数据库使用者的交互任务。
服务器、后台、数据层主要负责数据管理</p></li><li><p><strong>浏览器/服务器 (Browser/Server, B/S) 结构</strong>
三层客户/服务器结构，表示层、处理层（中间层）、数据层</p></li></ol><h2 id=第四节-数据模型>第四节 数据模型<a hidden class=anchor aria-hidden=true href=#第四节-数据模型>#</a></h2><p>数据模型是对现实世界数据特征的抽象，通俗地讲数据模型就是现实世界的模拟。</p><h3 id=141-数据特征与数据模型组成要素>1.4.1 数据特征与数据模型组成要素<a hidden class=anchor aria-hidden=true href=#141-数据特征与数据模型组成要素>#</a></h3><ul><li>数据模型组成<ol><li>数据结构&ndash;描述系统的静态特征，即数据对象的数据类型、内容、属性以及数据对象之间的练习。</li><li>数据操作&ndash;描述系统的动态特征，对象的实例允许执行的操作的集合，主要有更新和检索两大类。</li><li>数据约束：描述数据结构中数据间的语法和语义关联</li></ol></li></ul><h3 id=142-数据模型的分类>1.4.2 数据模型的分类<a hidden class=anchor aria-hidden=true href=#142-数据模型的分类>#</a></h3><ul><li>现实世界 ==> 概念模型 ： 数据库设计人员完成</li><li>概念模型 ==> 逻辑模型 ：数据库设计人员完成、数据库设计工具辅助完成</li><li>逻辑模型 ==> 物理模型 ：由DBMS完成</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>graph TD
</span></span><span style=display:flex><span> c1((现实世界)) ---- c2((认识抽象)) 
</span></span><span style=display:flex><span> c2((认识抽象)) --- 信息世界-概念模型
</span></span><span style=display:flex><span>  信息世界-概念模型 --- 机器世界-数据库管理系统支持的数据模型
</span></span></code></pre></div><p>概念模型的表示方法</p><ol><li>实体型: 用矩形表示, 内写实体名</li><li>属性: 椭圆表示, 内写名称, 无向边连接相应实体</li><li>联系: 菱形表示, 内写名称, 无向边连接实体</li></ol><p>概念模型的一种表示方法：<strong>实体-联系图（Entity-Relationship，E-R图）</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>graph TD
</span></span><span style=display:flex><span> c1((开始)) --- 供应商
</span></span><span style=display:flex><span> c2((账号)) --- 供应商
</span></span><span style=display:flex><span> c3((地址)) --- 供应商
</span></span><span style=display:flex><span> c4((电话号码1)) --- 供应商
</span></span><span style=display:flex><span> 供应商 --- b1{供应}
</span></span><span style=display:flex><span> b1{供应} --- 零件
</span></span><span style=display:flex><span> 零件 --- c5((零件号))
</span></span><span style=display:flex><span> 零件 --- c6((规格))
</span></span><span style=display:flex><span> 零件 --- c7((名称))
</span></span><span style=display:flex><span> 零件 --- b2{库存}
</span></span><span style=display:flex><span> b2{库存} --- c16((库存量))
</span></span><span style=display:flex><span> b2{库存} --- 仓库
</span></span><span style=display:flex><span> 仓库 --- c13((仓库号))
</span></span><span style=display:flex><span> 仓库 --- c14((面积))
</span></span><span style=display:flex><span> 仓库 --- c15((电话号码2))
</span></span><span style=display:flex><span> 仓库 --- b3{工作}
</span></span><span style=display:flex><span> b3{工作} --- 职工
</span></span><span style=display:flex><span> c12((职工号)) --- 职工
</span></span><span style=display:flex><span> c11((姓名1)) --- 职工
</span></span><span style=display:flex><span> 
</span></span></code></pre></div><ol><li><strong>概念层数据模型</strong></li></ol><ul><li><p>概念模型的用途</p><ol><li><p>概念模型用于信息世界的建模</p></li><li><p>是现实世界到机器世界的一个中间层次</p></li><li><p>是数据库设计的有力工具</p></li><li><p>数据库设计人员和用户之间进行交流的语言</p></li><li><p>信息世界中的基本概念</p><ol><li>实体(Entity)：客观存在并可相互区别的事物称为实体。可以是具体的人、 事、 物或抽象的概念</li><li>属性(Attribute)：实体所具有的某一特性称为属性。 一个实体可以由若干个属性来刻画</li><li>码或键(Key)：唯一标识实体的属性集称为码。</li><li>域(Domain)</li><li>实体型(Entity Type)：用实体名及其属性名集合来抽象和刻画同类实体</li><li>实体集(Entity Set)：同一类型实体的集合称为实体集</li><li>联系(Relationship)：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体（型） 内部的联系和实体（型） 之间的联系。</li></ol></li></ol></li><li><p>实体内部的联系: 是指组成实体的各属性之间的联系</p></li><li><p>实体之间的联系: 通常是指不同实体集之间的联系。实体之间的联系有一对一（1:1)、一对多（1:n）和多对多（m:n）</p></li></ul><ol start=2><li><p><strong>逻辑层数据模型</strong>，是按照计算机系统的观点对数据建模， 用于DBMS实现。</p><ol><li>网状模型</li><li>层次模型</li><li>关系模型<ul><li>二维表</li></ul></li><li>面向对象数据模型</li><li>对象关系数据模型</li><li>半结构化数据模型</li></ol></li><li><p><strong>物理层数据模型</strong>，是对数据最底层的抽象，用于描述数据在系统内（磁盘上） 的表示方式和存取方法。</p></li></ol><h1 id=第二章-关系型数据库重点>第二章 关系型数据库（重点）<a hidden class=anchor aria-hidden=true href=#第二章-关系型数据库重点>#</a></h1><h2 id=第一节-关系型数据库概述>第一节 关系型数据库概述<a hidden class=anchor aria-hidden=true href=#第一节-关系型数据库概述>#</a></h2><p>商用数据库管理系统中，关系模型逐渐取代早起的网状模型和层次模型，成为主流数据模型。</p><p>关系型数据库的基本特征是使用关系数据模型组织数据。
关系型数据库的优点：高级的分过程语言接口、较好的数据独立性、为商品化的关系数据库管理系统的研制做好了技术上的准备。</p><p>关系数据库系统是支持关系模型的数据库系统</p><p>关系模型由关系数据结构、关系操作集合和完整性约束三部分构成</p><p><strong>关系数据结构</strong></p><ol><li>一张扁平的二维表</li><li>可以描述现实世界中的实体以及实体间的各种关系</li></ol><p><strong>关系操作集合</strong></p><ol><li>集合操作方式（操作对象和结果都是集合）</li><li>操作包括：选择、投影、连接、除、并、交、差等查询操作和增、删、改操作两部分构成</li><li>结构化查询语言（SQL, Structured Query Language）是关系数据库操作的标准语言</li></ol><p><strong>完整性约束</strong></p><ol><li>实体完整性</li><li>参照完整性</li><li>用户定义的完整性</li></ol><h2 id=第二节-关系型数据模型>第二节 关系型数据模型<a hidden class=anchor aria-hidden=true href=#第二节-关系型数据模型>#</a></h2><h3 id=221-关系数据结构字典>2.2.1 关系数据结构(字典)<a hidden class=anchor aria-hidden=true href=#221-关系数据结构字典>#</a></h3><ol><li><p>表(Table)</p><ul><li>也称关系, 二维的数据结构; 由唯一表名、若干列、若干行数据组成</li></ul></li><li><p>关系(Relation)：一个关系对应通常说的一张表，现实世界的实体以及实体间的各种联系均用关系来表示。</p><ul><li>基本关系: 实际存在的表，是实际存储数据的逻辑表示</li><li>查询表: 查询结果对应的表</li><li>视图表: 由基本表或其它试图表导出的表，是虚表，不对应实际存储的数据</li></ul></li><li><p><strong>列(Column)：字段或属性</strong>，属性的个数成为关系的<strong>元或度</strong></p><ul><li>也称字段(Field)或属性;</li><li>有唯一列名, 表示一种属性</li></ul></li><li><p><strong>域(Domain)：属性的取值范围来自某个域。</strong>
例：学生年龄属性的域（15～45岁），性别的域是（男， 女）</p></li><li><p><strong>行(Row)：称元组(Tuple)或记录(Record)</strong>，表中的一行即为一个元组</p></li><li><p>分量(Component)：元组中的一个属性值</p></li><li><p><strong>码或键(Key)</strong>：称码键，唯一标识元组关系的属性。</p></li><li><p>超码或超键(Super Key)</p><ul><li>在关系中的一个码移去某个属性, 它任然是这个关系的码, 称为该关系的超码或超键</li><li>一般每个关系至少有一个默认的超码, 即该关系的所有属性的集合</li></ul></li><li><p><strong>候选码或候选键(Candidate Key)</strong>：能够唯一标识一条记录的最小属性集</p><ul><li>候选键是没有多余属性的超键
例如，
学号唯一，而且没有多余属性，所以是一个候选键
姓名唯一，而且没有多余属性，所以是一个候选键
（姓名，性别）唯一，但是单独姓名一个属性就能确定这个人是谁，所以性别这个属性就是多余属性，所以（姓名，性别）不是候选键</li></ul></li><li><p>主属性(Primary Attribute)和非主属性(Nonprimary Attribute)</p><ul><li>关系中<strong>包含在任何一个候选码中的属性称为主属性</strong></li><li>不包含在任何侯选码中的属性称为非主属性（Non-Prime attribute）或非码属性（Non-key attribute）</li></ul></li><li><p><strong>主码或主键(Primary Key)</strong>：若干候选码中<strong>指定一个用来唯一</strong>标识关系的元组</p></li><li><p>全码或全键(All-Key)：一个关系模式的所有属性集合是这个关系的主码或主键</p></li><li><p><strong>外码或外键(Foreign Key)</strong>：关系中的某个属性(或属性组)不是这个关系的主码或候选码, 而是另一关系的主码</p></li><li><p>参照关系(Referencing Relation)和被参照关系(Referenced Relation)</p><ul><li><strong>参照关系</strong>（从关系）: 外码所在的关系</li><li><strong>被参照关系</strong>（主关系）: 以外码作为主码的关系
例如，选课表中，学号和课程号是主码，但在课程表中作为外码。</li></ul></li><li><p>数据类型(Data Type)</p><ul><li>限制该列中存储的数据</li></ul></li><li><p>关系模式(Relation Schema)：对关系的描述。如关系名（属性1，属性2， …，属性n）、学生（学号， 姓名，年龄，性别，系名，年级）</p><ul><li><strong>数据库有型(type)和 值(value) 之分，关系模式是型, 关系是值;</strong></li><li>关系模式是静态的, 关系是动态的、随时间不断变化的。</li></ul></li><li><p><strong>关系数据库(Relation Database)</strong>：所有关系的集合构成一个关系数据库
关系数据库对关系的限定/要求：</p></li></ol><ul><li><p>每一个属性都是不可分解的（不允许表中有表，如工资表）</p></li><li><p>每一个关系仅仅有一种关系模式</p></li><li><p>每一个关系模式中的属性必须命名，属性名不同</p></li><li><p>同一个关系中不允许出现候选码或候选键值完全相同的元组</p></li><li><p>在关系中元组的顺序（即行序）是无关紧要的，可以任意交换。</p></li><li><p>在关系中属性的顺序（即列序）是无关紧要的，可以任意交换。</p><ul><li>数据库表名字段等, 一般不使用中文, 用英文
关系数据库的型: 关系数据库模式, 对关系数据库的描述
关系数据库的值: 关系模式在某一时刻对应的关系的集合，通常称为关系数据库</li></ul></li></ul><ol start=21><li><p>关系必须是规范化的， 满足一定的规范条件
最基本的规范条件：关系的每一个分量必须是一个不可分的数据项， 不允许表中还有表。 下图中工资和扣除是可分的数据项 ,不符合关系模型要求</p></li><li><p>域的笛卡尔积空间
给定一组域D_1, D_2, …, D_n，允许其中某些域是相同的。D_1, D_2, …, D_n的笛卡尔积空间为：D_1×D_2×…×D_n={(d_1,d_2,…,d_n)|d_i∈D_i,i=1,2,…,n}
所有域取值的任意组合
笛卡尔积可以看作为关系的“域”
基数（Cardinal number）
若D_i(i=1,2,…,n)为有限集，其基数为m_i，则D_1×D_2×…×D_n的基数M为：M=∏_i^n▒m_i</p></li></ol><p>笛卡尔积的表示方法
笛卡尔积可以表示为一张二维表
表中的每行对应一个元组，表中的每一列对应一个域</p><p>例题：
给出3个域：
D1=导师集合SUPERVISOR=｛张清玫， 刘逸｝
D2=专业集合SPECIALITY=｛计算机专业， 信息专业｝
D3=研究生集合POSTGRADUATE=｛李勇， 刘晨， 王敏｝
D1， D2， D3的笛卡尔积为</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>答：D1×D2×D3＝｛
</span></span><span style=display:flex><span>(张清玫，计算机专业，李勇)， (张清玫，计算机专业，刘晨)，
</span></span><span style=display:flex><span>(张清玫，计算机专业，王敏)， (张清玫，信息专业，李勇)，
</span></span><span style=display:flex><span>(张清玫，信息专业，刘晨)， (张清玫，信息专业，王敏)，
</span></span><span style=display:flex><span>(刘逸，计算机专业，李勇)， (刘逸，计算机专业，刘晨)，
</span></span><span style=display:flex><span>(刘逸，计算机专业，王敏)， (刘逸，信息专业，李勇)，
</span></span><span style=display:flex><span>(刘逸，信息专业，刘晨)， (刘逸，信息专业，王敏) ｝
</span></span></code></pre></div><p>笛卡尔积的二维表表示：</p><table><thead><tr><th>SUPERVISOR</th><th>SPECIALITY</th><th>POSTGRADUATE</th></tr></thead><tbody><tr><td>张清玫</td><td>计算机专业</td><td>李勇</td></tr><tr><td>张清玫</td><td>计算机专业</td><td>刘晨</td></tr><tr><td>张清玫</td><td>计算机专业</td><td>王敏</td></tr><tr><td>张清玫</td><td>信息专业</td><td>李勇</td></tr><tr><td>张清玫</td><td>信息专业</td><td>刘晨</td></tr><tr><td>张清玫</td><td>信息专业</td><td>王敏</td></tr><tr><td>刘逸</td><td>计算机专业</td><td>李勇</td></tr><tr><td>刘逸</td><td>计算机专业</td><td>刘晨</td></tr><tr><td>刘逸</td><td>计算机专业</td><td>王敏</td></tr><tr><td>刘逸</td><td>信息专业</td><td>李勇</td></tr><tr><td>刘逸</td><td>信息专业</td><td>刘晨</td></tr><tr><td>刘逸</td><td>信息专业</td><td>王敏</td></tr></tbody></table><h3 id=222-关系操作集合>2.2.2 关系操作集合<a hidden class=anchor aria-hidden=true href=#222-关系操作集合>#</a></h3><h5 id=基本的关系操作>基本的关系操作<a hidden class=anchor aria-hidden=true href=#基本的关系操作>#</a></h5><ul><li>查询(Query)<ul><li>选择\投影\连接\除\并\差\交\笛卡尔积等</li></ul></li><li>插入(Insert)</li><li>删除(Delete)</li><li>修改(Update)</li></ul><h5 id=关系数据语言的分类>关系数据语言的分类<a hidden class=anchor aria-hidden=true href=#关系数据语言的分类>#</a></h5><ul><li><p>特点: 高度非过程化</p><ol><li>关系代数语言</li><li>关系演算语言</li><li>两者兼备的语言(SQL)</li></ol></li></ul><h5 id=关系代数σ>关系代数σ<a hidden class=anchor aria-hidden=true href=#关系代数σ>#</a></h5><ul><li>关系代数运算符</li><li>关系到数操作经过有限次复合的式子称为关系代数操作表达式, 简称为关系代数表达式;<ul><li>可以使用关系代数表达式表示所需要执行的各种数据库查询和修改处理;</li><li>因而, 关系代数也是一种抽象的查询语言, 它通过对关系的操作来表达查询</li></ul></li></ul><h6 id=传统的集合运算并差交笛卡尔积-4-种运算>传统的集合运算：并、差、交、笛卡尔积 4 种运算<a hidden class=anchor aria-hidden=true href=#传统的集合运算并差交笛卡尔积-4-种运算>#</a></h6><p>学生住宿登记关系 S1</p><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th><th>性别（SSEX）</th><th>宿舍（SROOM）</th></tr></thead><tbody><tr><td>901001</td><td>钟义</td><td>男</td><td>N201</td></tr><tr><td>901002</td><td>海燕</td><td>女</td><td>N302</td></tr><tr><td>901003</td><td>肖沙</td><td>男</td><td>N201</td></tr></tbody></table><p>学生住宿登记关系 S2</p><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th><th>性别（SSEX）</th><th>宿舍（SROOM）</th></tr></thead><tbody><tr><td>901004</td><td>秦学</td><td>男</td><td>C101</td></tr><tr><td>901005</td><td>赵月</td><td>女</td><td>D303</td></tr><tr><td>901003</td><td>肖沙</td><td>男</td><td>N201</td></tr></tbody></table><ol><li><strong>并( UNION)： R3=R1UR2</strong>，合并元组</li></ol><p>S1 U S2</p><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th><th>性别（SSEX）</th><th>宿舍（SROOM）</th></tr></thead><tbody><tr><td>901001</td><td>钟义</td><td>男</td><td>N201</td></tr><tr><td>901002</td><td>海燕</td><td>女</td><td>N302</td></tr><tr><td>901003</td><td>肖沙</td><td>男</td><td>N201</td></tr><tr><td>901004</td><td>秦学</td><td>男</td><td>C101</td></tr><tr><td>901005</td><td>赵月</td><td>女</td><td>D303</td></tr></tbody></table><ol start=2><li><strong>差( DIFFERENCE)</strong>：R3 = R1 - R2</li></ol><ul><li>属于R1但不属于R2</li></ul><p>S1 - S2</p><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th><th>性别（SSEX）</th><th>宿舍（SROOM）</th></tr></thead><tbody><tr><td>901001</td><td>钟义</td><td>男</td><td>N201</td></tr><tr><td>901002</td><td>海燕</td><td>女</td><td>N302</td></tr></tbody></table><ol start=3><li><strong>交( INTERSECTION)：R3=R1∩R2</strong>，找共同元组</li></ol><p>S1 ∩ S2</p><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th><th>性别（SSEX）</th><th>宿舍（SROOM）</th></tr></thead><tbody><tr><td>901003</td><td>肖沙</td><td>男</td><td>N201</td></tr></tbody></table><ol start=4><li><strong>笛卡尔积( CARTESIAN PRODUCT)：R3=R1×R2</strong>
<strong>新关系 R3 中元组的前 m 个分量是 R1 的一个元组，后 n 个分量为 R2 的一个元组</strong>。</li></ol><p>笛卡尔积示例— “学生”关系</p><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th></tr></thead><tbody><tr><td>89199</td><td>陈星</td></tr><tr><td>89200</td><td>易南</td></tr><tr><td>89201</td><td>林俊</td></tr></tbody></table><p>笛卡尔积示例— “课程”关系</p><table><thead><tr><th>课程号（CNO）</th><th>课程名(CNAME)</th><th>教室（CROOM）</th></tr></thead><tbody><tr><td>1</td><td>操作系统</td><td>C5-201</td></tr><tr><td>2</td><td>数据库</td><td>C5 - 307</td></tr></tbody></table><p>笛卡尔积示例— “学生选课”关系</p><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th><th>课程号（CNO）</th><th>课程名(CNAME)</th><th>教室（CROOM）</th></tr></thead><tbody><tr><td>89199</td><td>陈星</td><td>1</td><td>操作系统</td><td>C5-201</td></tr><tr><td>89199</td><td>陈星</td><td>2</td><td>数据库</td><td>C5 - 307</td></tr><tr><td>89200</td><td>易南</td><td>1</td><td>操作系统</td><td>C5-201</td></tr><tr><td>89199</td><td>易南</td><td>2</td><td>数据库</td><td>C5 - 307</td></tr><tr><td>89201</td><td>林俊</td><td>1</td><td>操作系统</td><td>C5-201</td></tr><tr><td>89201</td><td>林俊</td><td>2</td><td>数据库</td><td>C5 - 307</td></tr></tbody></table><h6 id=专门的关系运算重点>专门的关系运算（重点）<a hidden class=anchor aria-hidden=true href=#专门的关系运算重点>#</a></h6><p>σ π ÷</p><ul><li>一元专门关系操作包括对单个关系进行垂直分解的投影运算和进行水平分解选择运算；</li><li>二元专门关系操作则是对两个关系进行操作，包括连接运算和除</li></ul><ol><li>选择(select) <strong>σ F(R)</strong> : F 为条件表达式, R 为指定的被运算关系名。选择满足条件的记录。</li></ol><ul><li><code>select 关系名 where 条件;</code></li><li>条件是由常数、属性名或列名、比较操作符<code>（>、≥、&lt;、≤、≠）</code>及逻辑操作符<code>（-、∧、V）</code>组成的条件表达式。</li><li>例如，查找性别为男性的，select S1 where 性别 = “男”</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>σ 性别 <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;男性&#34;</span>（S1）
</span></span></code></pre></div><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th><th>性别（SSEX）</th><th>宿舍（SROOM）</th></tr></thead><tbody><tr><td>901001</td><td>钟义</td><td>男</td><td>N201</td></tr><tr><td>901003</td><td>肖沙</td><td>男</td><td>N201</td></tr></tbody></table><ul><li><strong>进行逻辑运算</strong>（∧与、∨或、¬非）</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>查询一个宿舍为N201的男生
</span></span><span style=display:flex><span>σ 宿舍 <span style=color:#af3a03>=</span> N201<span style=color:#af3a03>(</span>S1<span style=color:#af3a03>)</span> ∧性别 <span style=color:#af3a03>=</span> 男（S1）
</span></span></code></pre></div><ol start=2><li>投影 <strong>π_A(R)</strong> ：选择若干列组成新的关系，新关系中不含重复舒服，R 为被运算关系名, A 为属性序列。</li></ol><ul><li><code>projection 关系名(属性名1, 属性名2, ..., 属性名n);</code></li><li>例如，选择学号、姓名这两列, 。 projection S1 (学号，姓名)</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>π 学号,姓名（S1）
</span></span></code></pre></div><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th></tr></thead><tbody><tr><td>901001</td><td>钟义</td></tr><tr><td>901002</td><td>海燕</td></tr><tr><td>901003</td><td>肖沙</td></tr></tbody></table><p>例如，假设想要找出年龄大于19岁的学生的名字和年龄，则可以将前面的两个查询组合起来，表达式如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>π_Sname,<span style=color:#b57614>Sage</span>(σ_Sage<span style=color:#af3a03>&gt;</span><span style=color:#8f3f71>19</span>(S))
</span></span></code></pre></div><ol start=3><li>连接(join) ⨝，从两个关系的笛卡尔积中选取属性间满足一定条件的元组。R3=R1⨝R2</li></ol><ul><li><code>join 关系名1 AND 关系名2 where 条件;</code>
笛卡尔积
只保留属性值相等
去除重复列</li></ul><p>R</p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>5</td></tr><tr><td>a1</td><td>b2</td><td>6</td></tr><tr><td>a2</td><td>b3</td><td>8</td></tr><tr><td>a2</td><td>b4</td><td>12</td></tr></tbody></table><p>S</p><table><thead><tr><th>B</th><th>E</th></tr></thead><tbody><tr><td>b1</td><td>3</td></tr><tr><td>b2</td><td>7</td></tr><tr><td>b3</td><td>10</td></tr><tr><td>b3</td><td>2</td></tr><tr><td>b5</td><td>2</td></tr></tbody></table><p><strong>一般连接</strong>：在一般连接上，A和B分别为R和S上列数相等且可比的属性组，θ为比较运算符</p><p>举个例子：输出 R⋈S 且C&lt;E的元组，结果为</p><table><thead><tr><th>A</th><th>R .B</th><th>C</th><th>S.B</th><th>E</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>5</td><td>b2</td><td>7</td></tr><tr><td>a1</td><td>b1</td><td>5</td><td>b3</td><td>10</td></tr><tr><td>a1</td><td>b2</td><td>6</td><td>b2</td><td>7</td></tr><tr><td>a1</td><td>b2</td><td>6</td><td>b3</td><td>10</td></tr><tr><td>a2</td><td>b3</td><td>8</td><td>b3</td><td>10</td></tr></tbody></table><p><strong>等值连接</strong> （equijoin）
θ为“=”的连接运算称为等值连接。它是从关系R与S的广义笛卡尔积中选取A、B属性组值相等的那些元组</p><p>举个例子：R⋈S,且R.B=S.B，结果为</p><table><thead><tr><th>A</th><th>R .B</th><th>C</th><th>S.B</th><th>E</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>5</td><td>b1</td><td>3</td></tr><tr><td>a1</td><td>b2</td><td>6</td><td>b2</td><td>7</td></tr><tr><td>a2</td><td>b3</td><td>8</td><td>b3</td><td>10</td></tr><tr><td>a2</td><td>b3</td><td>8</td><td>b3</td><td>2</td></tr></tbody></table><p>等值连接会去除属性列不相等的元组</p><table><thead><tr><th>A</th><th>R .B</th><th>C</th><th>S.B</th><th>E</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>5</td><td>b1</td><td>3</td></tr><tr><td>a1</td><td>b2</td><td>6</td><td>b2</td><td>7</td></tr><tr><td>a2</td><td>b3</td><td>8</td><td>b3</td><td>10</td></tr><tr><td>a2</td><td>b3</td><td>8</td><td>b3</td><td>2</td></tr></tbody></table><ol start=4><li>除(division)：÷</li></ol><ul><li>若除关系为 m 元关系，除关系为 n 元关系，则运算结果为一个 m-n 元关系</li></ul><h3 id=223-关系的完整性约束>2.2.3 关系的完整性约束<a hidden class=anchor aria-hidden=true href=#223-关系的完整性约束>#</a></h3><p>数据库的数据完整性是指数据库中数据的<strong>正确性、相容性、一致性</strong>。</p><p>关系的完整性约束分类：</p><ol><li><p><strong>实体完整性约束(Entity Integrity Constraint)：是指关系的主属性，即</strong>主码的组成不能为NULL。关系对应于现实世界中的实体集，而现实世界的实体是可区分的，即说明每个实体具有唯一性标识。</p></li><li><p><strong>参照完整性约束(Referential Integrity Constraint)：是定义</strong>外码<strong>和</strong>主码<strong>之间的</strong>引用规则，要么外码等于主码中某个元组的主码值，要么为空值。例如，
教师（职工号、姓名、性别、职称、<strong>系编号</strong>）系编号属于外码
系（系编号、系名、办公地点、办公电话）</p></li><li><p><strong>用户自定义完整性约束</strong>：是<strong>针对某一应用环境</strong>的完整性约束条件，它反映了<strong>某一具体应用</strong>所涉及的数据应满足的要求。</p><ul><li>关系模型<strong>提供</strong>定义和检验这类完整性规则的<strong>机制</strong>，其目的是用<strong>统一的方式由系统来处理</strong>它们，不再由应用程序来完成这项工作。</li><li>在实际系统中，这类完整性规则一般在<strong>建立数据库表</strong>的<strong>同时进行定义</strong>，但如果某些约束条件没有建立在库表级，则<strong>应用编程人员</strong>应在各模块的具体编程中通过程序进行<strong>检查和控制</strong></li></ul></li><li><p>关系模型完整性约束的检验</p><ol><li>执行插入操作<ul><li>首先，检查<strong>实体完整性约束</strong>，检查插入行在主码属性上的值是否已经存在，若不存在，可以执行插入操作；否则不可以执行插入操作。或者，检查插入行在主码的各个属性上的值是否为空（NULL），若都不为空，可以执行插入操作；否则不可以执行插入操作。</li><li>然后，再检查<strong>参照完整性约束</strong>，如果是向被参照关系插入，不需要考虑参照完整性约束；如果是向参照关系插入，检查插入行在外码属性上的值是否已经在相应被参照关系的主码属性值中存在，若存在，可以执行插入操作；否则不可以执行插入操作，或将插入行在外码属性上的值改为空值后再执行插入操作（假定该外码允许取空值）。</li><li>最后，检查<strong>用户定义完整性约束</strong>，检查要被插入的元组中各属性值是否满足域完整性约束和其他特殊定义的完整性规则，包括数据类型、精度、取值范围、是否允许空值、是否有默认值等，以及检查插入行在相应属性上的值是否遵守具体应用的业务规则，若满足，可以执行插入操作；否则不可以执行插入操作，并给出错误信息。</li></ul></li><li>执行删除操作</li><li>执行更新操作</li></ol></li></ol><h2 id=第三节-关系数据库的规范化理论-重点>第三节 关系数据库的规范化理论 （重点）<a hidden class=anchor aria-hidden=true href=#第三节-关系数据库的规范化理论-重点>#</a></h2><h3 id=231-关系模式中可能存在的冗余和异常问题>2.3.1 关系模式中可能存在的冗余和异常问题<a hidden class=anchor aria-hidden=true href=#231-关系模式中可能存在的冗余和异常问题>#</a></h3><ol><li><strong>数据冗余</strong>：是指同一数据被反复存储的情况。</li><li><strong>更新异常</strong>：数据冗余，更新数据时，维护数据完整性代价太大。</li><li><strong>插入异常</strong>：是指该插入的数据不能执行插入操作的情形。</li><li><strong>删除异常</strong>：是指不应该删去的数据被删去的情形。</li></ol><p>关系模式中产生上述问题的原因，及消除的方法，都与<strong>数据依赖</strong>的概念有密切关系。</p><h3 id=232-函数依赖与关键字重点>2.3.2 函数依赖与关键字(重点)<a hidden class=anchor aria-hidden=true href=#232-函数依赖与关键字重点>#</a></h3><p>关系：一张二维表
关系模式：用来定义关系，如 Student(Sno、Sname、Ssex、Sage、Sdept)，Student用来描述关系。
关系数据库：基于关系模型的数据库，利用关系来描述现实世界</p><p><strong>函数依赖</strong>：关系中属性的对应关系</p><blockquote><p>双箭头是“等价于”,就是充要条件</p><p>A←B, A 是 B 的必要非充分条件 (如果有事物情况 B，则必然有事物情况 A；如果有事物情况 A 不一定有事物情况 B)</p><p>A→B, A 是 B 的充分非必要条件 (如果有事物情况 A，则必然有事物情况 B；如果有事物情况 B 不一定有事物情况 A，A 就是 B 的充分而不必要的条件)</p></blockquote><p>只有一对多和一对一的情况会存在函数依赖，多对多无法形成函数依赖。</p><p>SC(Sno，Cno，Grade) 学号、课程、成绩
非平凡函数依赖（如果 X → Y，但Y 不属于 X，则称 X → Y 是非平凡函数依赖 ）： (Sno,Cno) &ndash;> Grade
平凡函数依赖（如果 X → Y，但Y 属于 X，则称 X → Y 是平凡函数依赖 ）： （Sno,Cno）&ndash;> Sno / (Sno,Cno) &ndash;> Cno</p><p><strong>候选码：能够决定其他所有属性的属性或者属性集。
组成候选码的属性叫做主属性。</strong></p><h6 id=例题-1>例题<a hidden class=anchor aria-hidden=true href=#例题-1>#</a></h6><p>R(职工名、项目名、工资、部门名、部门经理) 如果规定每个职工可参加多个项目，各领一份工资；每个项目只属于一个部门；每个部门只有一个经理。试写出关系模式R的基本函数依赖和码。
基本函数依赖： （职工名，项目名）-> 工资、项目名 -> 部门名、部门名 -> 部门经理
候选码： （职工名，项目名）</p><ol><li><strong>完全函数依赖</strong><ul><li>X → Y : <strong>X的每一个值，属性Y只有唯一值与之对应，则称 X能决定Y（Y函数依赖X</strong>）</li></ul></li></ol><table><thead><tr><th>学号（SNO）</th><th>姓名(SNAME)</th><th>性别（SSEX）</th></tr></thead><tbody><tr><td>901001</td><td>钟义</td><td>男</td></tr><tr><td>901002</td><td>海燕</td><td>女</td></tr><tr><td>901003</td><td>肖沙</td><td>男</td></tr></tbody></table><p><strong>SNO → SNAME
SNO → SSEX</strong></p><ul><li>设 R 为任一给定关系，X、Y 为其属性集， <strong>若 X→Y，且对 X 中的任何真子集 X 都有 X→Y，则称Y 完全函数依赖于 X</strong> 。</li><li>例如，一个有关学生选课信息的关系模式 <code>SC(SNO, CNO, CTITLE, INAME, IPLACE, GRADE)</code>，<ul><li>其各属性的含义分别是：<code>学号、课程编号、课程名、授课老师、老师办公地址、成绩</code>，</li><li>在该关系中，函数依赖 <code>(SNO,CNO) → GRADE</code> 为完全函数依赖。</li><li>显然，其中的单个属性 <code>SNO 或 CNO</code> 都不能单独函数决定 <code>GRADE</code>，即 SNO ↛ GRADE，CNO ↛ GRADE</li></ul></li></ul><ol start=2><li><strong>部分函数依赖</strong><ul><li>设 R 为任一给定关系，X、Y 为其属性集，<strong>若 X→Y，且 X 中存在一个真子集 X 满足 X→Y，则称 Y 部分函数依赖于 X</strong></li><li>Y 集合或者单独都可以确定 X</li></ul></li></ol><p>例如，在表有关学生住宿登记的关系 S1 中，有<strong>函数依赖 <code>(SNO,SNAME)→SSEX</code>，但其中<code>SNO→SSEX</code>，所以<code>(SNO, SNAME)→SSEX</code>为部分函数依赖。</strong></p><ol start=3><li><p><strong>传递函数依赖</strong></p><ul><li>设 R 为任一给定关系，X、Y、Z 为其不同属性子集，<strong>若 X→Y, Y ↛ X, Y→Z，则有 X→Z，称为 Z 传递函数依赖于 X</strong></li><li>例如，假设有一个关系模式 <code>BOOKS（BNO, PNAME, PADDRESS）</code>，
其各属性的含义分别是 <code>书号 出版社名称 出版社地址</code>。<ul><li>一种书对应一个唯一书号，并只能在某一个出版社出版；</li><li>一个出版社一般只有一个唯一名称和唯一地址，但一个出版社可出版多种书。</li><li>此时，该关系中存在函数依赖：
<strong>Sno → Sdept , Sdept → Mname；所以Mname 传递函数依赖于Sno。</strong></li></ul></li></ul></li><li><p>严格的<strong>关键字的定义</strong>:</p><ul><li>设 R 为任一给定关系，U 为其所含的全部属性<strong>集合</strong>，X 为 U 的<strong>子集</strong>，<strong>若有完全函数依赖X→U，则 X 为 R 的一个候选关键字。</strong></li><li>X 可以唯一确定 R</li></ul></li></ol><h6 id=例题-候选关键字>例题-候选关键字<a hidden class=anchor aria-hidden=true href=#例题-候选关键字>#</a></h6><pre><code> 例如，在上述有关学生选课信息的关系模式 SC 中，
 SC（SNO，CNO，CTITLE，INAME，IPLACE，GRADE）
 (SNO，CNO) → CTITLE， (SNO，CNO) → INAME，
 (SNO，CNO) → IPLACE， (SNO，CNO) → GRADE，
 则属性集`（SNO,CNO）`为候选关键字，于是`SNO和CNO`为主属性，除此之外的其他属性均为非主属性
</code></pre><h3 id=233-范式与规范化过程>2.3.3 范式与规范化过程<a hidden class=anchor aria-hidden=true href=#233-范式与规范化过程>#</a></h3><p><strong>关系数据库的规范化理论是数据库逻辑设计的工具。</strong></p><p>关系数据库中的关系需要满足一定的要求，<strong>不同程度的要求称为不同的范式</strong>（Normal Form, NF）。</p><ul><li>满足最低要求的称为第一范式，称简 1NF，这是最基本的范式；</li><li>在第一范式的基础上进一步满足一些新要求的称为<strong>第二范式（2NF）</strong>；</li><li>以此类推，再进一步的范式是<strong>第三范式（3NF）及其改进形式 BCNF（ Boyce-Codd Normal Form）</strong>；</li></ul><p><strong>关系模式的规范化（ Normalization）</strong>：一个低一级范式的关系模式通过模式分解（Schema Decomposition）可以转换为若干个高一级范式的关系模式的集合的过程。</p><ol><li><strong>第一范式 1NF（存在非主属性对候选码的部分函数依赖）</strong><ul><li>设 R 为任一给定关系，如果 R 中的所有属性<strong>都是不可再分的基本数据项</strong>，则 R 为第一范式</li></ul></li></ol><table><thead><tr><th>ID</th><th>cusLinkInfo</th></tr></thead><tbody><tr><td>1</td><td>北京市海淀区成府路 010-62283393</td></tr><tr><td>2</td><td>北京市海淀区成府路 010-62283393</td></tr><tr><td>3</td><td>北京市海淀区成府路 010-62283393</td></tr></tbody></table><table><thead><tr><th>ID</th><th>cusLinkInfo</th><th>casTel</th></tr></thead><tbody><tr><td>1</td><td>北京市海淀区成府路</td><td>010-62283393</td></tr><tr><td>2</td><td>北京市海淀区成府路</td><td>010-62283393</td></tr><tr><td>3</td><td>北京市海淀区成府路</td><td>010-62283393</td></tr></tbody></table><p>第一范式的缺点：冗余高、插入操作异常、删除操作异常</p><ol start=5><li><p><strong>第二范式（2NF）</strong></p><ul><li>设 R 为任一给定关系，若 R 为 1NF，且其所有<strong>非主属性都完全函数依赖于候选关键字</strong>，则 R 为第二范式</li><li>完全函数依赖的意思，就是所有的非主属性都依赖于所有的主属性。</li><li>不符合2NF举例：</li><li>非主键列全部依赖于部分主键</li><li>非主键列部分依赖于全部主键</li><li>非主键列部分依赖于部分主键</li></ul></li><li><p><strong>第三范式（3NF）</strong></p><ul><li>设 R 为任一给定关系，若 R 为 2NF，且其每一个<strong>不存在非主属性对候选关键字的传递函数依赖</strong>，则 R 为第三范式。</li><li>若R属于3NF，则R的每一个非主属性既<strong>不部分函数依赖</strong>于候选码，也<strong>不传递函数依赖</strong>于候选码。</li></ul></li><li><p><strong>第三范式的改进形式 BCNF</strong></p><ul><li>若 R 为 1NF，如果对于R的每个<strong>函数依赖 X→Y，若Y 不属于 X，则 X 必包含候选关键字</strong>，则 R 为 BCNF。</li><li>如果R属于3NF，且R只有一个候选码，则R必属于BCNF</li></ul></li></ol><p>1NF -> 2NF：<strong>消除非主属性对候选码的部分函数依赖</strong>
找到候选关键字，看其余的属性是否完全函数依赖候选关键字，如果是，与候选关键字一同抄下来形成一个表格，如果不是，抄下来形成第二个表格，并将候选关键字里能够唯一决定表格2的属性组抄在第一列。</p><p>2NF -> 3NF：<strong>消除非主属性对码的传递函数依赖</strong>
找到表格中传递函数依赖关系的三个属性组，设为x、y、z，将这三个属性组拆成两个表格，第一个表格为 x、y，第二个表格为y、z。</p><p>3NF -> BCNF：<strong>消除主属性对码的部分和传递函数依赖</strong>。
列出表格中的所有函数依赖关系，每个关系拆出一个表格</p><h6 id=例题1nf-4nf>例题：1NF ~4NF<a hidden class=anchor aria-hidden=true href=#例题1nf-4nf>#</a></h6><ul><li><p>1NF：SLC(Sno，Sdept(所在系)，Sloc(宿舍楼)，Cno，Grade)</p></li><li><p>2NF：SC(Sno，Cno，Grade)、SL(Sno，Sdept，Sloc)
SL(Sno，Sdept，Sloc) 的函数依赖
Sno -> Sdept
Sno -> Sloc
Sdept -> Sloc
SL的候选码为 Sno，Sloc传递函数依赖于Sno。</p></li><li><p>3NF 将传递函数依赖分解
SL(Sno，Sdept，Sloc) 分解
SD(Sno，Sdept)
DL(Sdept，Sloc)</p></li><li><p>BCNF ： 主属性部分依赖于候选码</p></li></ul><h6 id=例题设计题>例题：设计题<a hidden class=anchor aria-hidden=true href=#例题设计题>#</a></h6><p>某超市商品采购数据库包含三个关系：
商品（商品编号、商品名、价格、生产日期）
采购员（编号、姓名、性别、联系电话）
采购（商品编号、编号、采购日期、采购数量）
实现以下操作：
1.使用关系代数查询“女”采购员的所有信息
2.使用关系代数查询所有商品的商品名和生产日期</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#8f3f71>1</span>. <span style=color:#af3a03>select</span> 采购员 <span style=color:#af3a03>where</span> 性别 <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;女&#34;</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>2</span>. projection 商品（商品名，生产日期） 
</span></span><span style=display:flex><span>错误
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>正确答案： 
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span>. 选择运算 σ 性别 <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;女&#39;</span>(采购员)
</span></span><span style=display:flex><span><span style=color:#8f3f71>2</span>. π 商品名，生产日期（商品）
</span></span></code></pre></div><h6 id=例题设计题综合题>例题：设计题【综合题】<a hidden class=anchor aria-hidden=true href=#例题设计题综合题>#</a></h6><p>设有关系模式R（读者号，姓名，单位号，单位名，图书号，书名 借阅日期，还书日期）存储读者借阅图书等信息。 如果规定：每个读者只属于一个单位；每个读者可以借阅多本图书，每本图书也可以被多名读者借阅，每个读者也可以对某本围 书多次借阅，但每个读者每本图书每天最多借一次。
（1）根据上述条件，写出模式R的关键字。
（2）R最高属于第几范式，为什么？
（3）举例说明R在何种情况下会发生删除异常。
（4）将R规范到3NF</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>正确答案
</span></span><span style=display:flex><span><span style=color:#8f3f71>1.</span>读者号、图书号、借阅日期
</span></span><span style=display:flex><span><span style=color:#8f3f71>2.</span> R ⊆ <span style=color:#8f3f71>1</span>NF，因为存在非主属性对码的部分函数依赖
</span></span><span style=display:flex><span><span style=color:#8f3f71>3.</span> 删除读者借阅图书信息时，有可能把读者的基本信息也删除了。
</span></span><span style=display:flex><span><span style=color:#8f3f71>4.</span>  R1(读者号、姓名、单位号)
</span></span><span style=display:flex><span> R2(单位号、单位名)
</span></span><span style=display:flex><span> R3(图书号、书名)
</span></span><span style=display:flex><span> R4(读者号、图书号、借阅日期、还书日期)
</span></span></code></pre></div><h6 id=例题bc范式>例题：BC范式<a hidden class=anchor aria-hidden=true href=#例题bc范式>#</a></h6><p>在关系模式STC(S,T,C)中，S表示学生，T表示教师，C表示课程。</p><ol><li>假设每一位教师只教一门课，每门课由若干教师教。</li><li>某一学生选定某门课，就确定一个固定的教师。</li><li>某个学生选修某个教师的课就确定了所选课的名称。</li></ol><p>函数依赖： T->C、(S,C)-> T、(S,T)->C</p><p>候选码：(S,C)、(S,T)
STC属于3NF
主属性：S、T、C</p><p>解决办法：采用投影分解法，将STC分解为两个关系模式，SC(S,C)、TC(T,C)</p><h3 id=234-关系规范化理论的应用>2.3.4 关系规范化理论的应用<a hidden class=anchor aria-hidden=true href=#234-关系规范化理论的应用>#</a></h3><ul><li>关系规范化理论主要应用于数据库设计中的概念设计阶段，对所产生的概念设计，可用它来分析其实体划分是否适合，判断属性分配到哪个实体中更为合理。在实现设计中当将 E-R 图向关系模型转换时，还可以用它来分析并发现概念设计中可能存在的遗漏或不当之处，特别是联系实体是否不单独转换为一独立关系而集成到与之相联的基本实体中去处理时，规范化理论是最有效的评价准则</li></ul><h1 id=第三章-数据库设计>第三章 数据库设计<a hidden class=anchor aria-hidden=true href=#第三章-数据库设计>#</a></h1><h2 id=第一节-数据库设计概述>第一节 数据库设计概述<a hidden class=anchor aria-hidden=true href=#第一节-数据库设计概述>#</a></h2><h3 id=311-数据库的生命周期>3.1.1 数据库的生命周期<a hidden class=anchor aria-hidden=true href=#311-数据库的生命周期>#</a></h3><ul><li>通常，从数据库演变过程的角度来看，数据库的生命周期可分为两个阶段，<ul><li>分别是<strong>数据库分析与设计</strong>阶段、<strong>数据库实现与操作</strong>阶段。</li><li>其中，数据库分析与设计阶段包括<strong>需求分析、概念设计、逻辑设计和物理设计</strong>四个环节；</li><li>数据库实现与操作阶段包含<strong>数据库的实现、操作与监督、修改与调整</strong>三个子阶段。</li></ul></li></ul><h3 id=312-数据库设计的目标>3.1.2 数据库设计的目标<a hidden class=anchor aria-hidden=true href=#312-数据库设计的目标>#</a></h3><ul><li>事实上，数据库设计具有两个十分重要的目标，即<strong>满足应用功能需求</strong>和<strong>良好的数据库性能</strong>。<ul><li>满足应用功能需求，主要是指用户当前与可预知的将来应用所需要的数据及其联系，应全部准确地存储在数据库之中，从而可满足用户应用中所需要的<strong>对数据进行的存、取、删、改等操作</strong>；</li><li>良好的数据库性能，主要是指对<strong>数据的高效率存取和空间的节省</strong>，并具有<strong>良好的数据共享性、完整性、一致性及安全保密性。</strong></li></ul></li></ul><h3 id=313-数据库设计的内容>3.1.3 数据库设计的内容<a hidden class=anchor aria-hidden=true href=#313-数据库设计的内容>#</a></h3><p>数据库设计是<strong>从用户对数据的需求出发</strong>，研究并构造数据库的过程。主要包括：</p><ol><li><p><strong>数据库结构设计</strong>（静态的）</p><ul><li><p>数据库结构设计是针对给定的应用环境进行数据库的模式或子模式的设计，包括数据库的</p><ul><li>概念结构设计</li><li>逻辑结构设计</li><li>物理结构设计</li></ul><p>模式定义并给出各应用程序共享的结构，是静态的，一经形成通常不会改变。</p></li></ul></li><li><p><strong>数据库行为设计</strong>（动态的）</p><ul><li>数据库行为设计是确定数据库用户的行为和动作，而用户的行为和动作是对数据库的操作</li></ul></li></ol><h3 id=314-数据库设计的方法>3.1.4 数据库设计的方法<a hidden class=anchor aria-hidden=true href=#314-数据库设计的方法>#</a></h3><ol><li><p><strong>直观设计法</strong></p><ul><li>直观设计法是一类最原始的数据库设计方法，它利用设计者的经验和技巧来设计数据库模式。不适应如今信息系统的开发。</li></ul></li><li><p><strong>规范设计法</strong></p><ul><li>规范设计法是一类较为普遍、常用的数据库设计方法。<ol><li><strong>新奥尔良（ New Orleans）设计方法</strong><ul><li>将数据库设计分为四个阶段，分别是需求分析、概念结构设计、逻辑结构设计和物理结构设计，它<strong>注重数据库的结构设计</strong>，而不太考虑数据库的行为设计</li></ul></li><li><strong>基于 ER 模型的数据库设计方法</strong><ul><li>基本思想是在需求分析的基础上用 E-R 图构造一个反映现实世界实体之间联系的企业模式，然后将此模式转换成某一特定 DBMS 下的概念模式。</li></ul></li><li><strong>基于第三范式的设计方法</strong><ul><li><strong>是一类结构化设计方法</strong>，其思想是在需求分析的基础上首先确定数据库的模式、属性及属性间的依赖关系，然后将它们组织在一个单一的关系模式中，再分析模式中不符合第三范式的约束条件，进行模式分解，规范成若干个第三范式关系模式的集合。</li></ul></li></ol></li></ul></li><li><p><strong>计算机辅助设计法 — 计算机辅助软件工程工具（俗称 case 工具）</strong></p><ul><li>以领域专家的知识或经验为主导，模拟某规范化设计的方法，通常通过人机交互的方式来完成设计的某些过程。目前，许多计算机辅助软件工程工具（俗称 case 工具），可以用来帮助数据库设计人员完成数据库设计的些工作，如此可减轻数据库设计人员的工作量，加快数据库设计的进度，例如 Rational 公司的 Rational rose 等。</li></ul></li></ol><h3 id=315-数据库设计的过程>3.1.5 数据库设计的过程<a hidden class=anchor aria-hidden=true href=#315-数据库设计的过程>#</a></h3><ol><li><strong>需求分析阶段</strong>；</li><li><strong>结构设计阶段</strong>，其包括概念结构设计、逻辑结构设计和物理结构设计；</li><li><strong>行为设计阶段</strong>，其包括功能设计、事务设计和程序设计；</li><li><strong>数据库实施阶段</strong>，其包括加载数据库数据和调试运行应用程序；</li><li><strong>数据库运行和维护阶段</strong>。</li></ol><h2 id=第二节-数据库设计的基本步骤>第二节 数据库设计的基本步骤<a hidden class=anchor aria-hidden=true href=#第二节-数据库设计的基本步骤>#</a></h2><p>数据库设计过程中涉及的5个基本步骤：
<strong>需求分析、概念结构设计、逻辑结构设计、数据库实施、数据库运行与维护。</strong></p><h3 id=321-需求分析数据库设计的起点>3.2.1 需求分析(数据库设计的起点)<a hidden class=anchor aria-hidden=true href=#321-需求分析数据库设计的起点>#</a></h3><p>目标：是了解与分析用户的信息及应用处理的要求，并将结果按一定格式整理而形成需求分析报告。
**需求分析报告的作用：是后续概念设计、逻辑设计、物理设计、数据库建立与维护的依据。</p><ol><li><p>确定数据库范围：确定数据库应支持哪些应用功能。</p></li><li><p>应用过程分析：了解并分析数据与数据处理间的关系。</p></li><li><p>收集与分析数据：数据收集与分析的任务是了解并分析数据的组成格式及操作特征，每个数据元素的语义及关系等，并将它们收集起来整理归档。</p></li><li><p>编写需求分析报告</p></li></ol><h3 id=322-概念结构设计概念模型>3.2.2 概念结构设计(概念模型)<a hidden class=anchor aria-hidden=true href=#322-概念结构设计概念模型>#</a></h3><ul><li><strong>概念结构设计</strong>的任务是在需求分析中产生的需求分析报告的基础上，按照特定的方法设计满足应用需求的用户信息结构，该信息结构通常称为概念模型。</li><li>概念模型独立于任何软件与硬件，其设计的<strong>主要目标是最大限度地满足应用需求</strong></li><li><strong>关系的规范化理论主要用于概念设计阶段。</strong></li><li>概念结构设计的常用方法有<strong>实体分析法（自顶向下法）和属性综合法（自底向上法）</strong> 两种</li></ul><h3 id=323-逻辑结构设计>3.2.3 逻辑结构设计<a hidden class=anchor aria-hidden=true href=#323-逻辑结构设计>#</a></h3><p>目标将概念模型转换为等价的、并为特定DBMS所支持数据模型的结构；在基本表的基础上再建立必要的视图，形成数据的外模式。</p><p><strong>三种逻辑模型：层次模型、网状模型、关系数据模型</strong></p><ol><li><p>逻辑结构设计的输入与输出信息</p><ol><li>独立于特定 DBMS 的概念模型。</li><li>有关响应时间、安全保密性、数据完整性及恢复方面的要求说明，包括保持数据致性的规则说明。</li><li>数据量及使用频率</li><li>特定 DBMS 特性，包括 DBMS 支持的数据模型及数据定义语言的说明</li></ol><p>在完成逻辑结构设计之后，应该形成如下输出信息。</p><ol><li>一个特定 DBMS 支持的概念模式，或称之为模式。</li><li>一个或多个外部视图，或称之为子模式。</li><li>物理设计说明，其主要包括存入数据库中的数据量、使用频率及响应时间要求。</li><li>程序设计说明，其是在需求分析的基础上，根据已完成的逻辑模型，编制各程序名、执行逻辑步、存取数据的名、顺序及操作特征（读、写、删、改）的说明。</li></ol></li><li><p>逻辑结构设计的步骤</p></li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>graph TD
</span></span><span style=display:flex><span> c1((概念设计)) --- 模型转换
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 模型转换 --- 子模式设计
</span></span><span style=display:flex><span> 模型转换 --- 应用程序设计说明
</span></span><span style=display:flex><span> 子模式设计 --- 设计评价
</span></span><span style=display:flex><span> 应用程序设计说明 --- 设计评价
</span></span><span style=display:flex><span> 设计评价 --- 物理设计
</span></span><span style=display:flex><span> 
</span></span></code></pre></div><ol><li><strong>模型转换</strong><ul><li>将概念模型等价地转换为特定 DBMS 支持的关系模型、网状模型或层次模型表示。对于一个特定的应用环境，通常只转换为用户要求的某个特定 DBMS 所支持的一种模型表示。</li></ul></li><li><strong>子模式设计</strong><ul><li>抽取或导出模式的子集，以构造不同用户使用的局部数据逻辑结构。具体的规则在 DBMS 的使用指南中通常会有明确的说明。</li></ul></li><li><strong>编制应用程序设计说明</strong><ul><li>为可实际运行的应用程序设计提供依据与指导，并作为设计评价的基础。</li></ul></li><li><strong>设计评价</strong><ul><li>分析并检验模式及子模式的正确性与合理性，其方法是通过程序设计指南中提交的程序执行逻辑步骤在子模式上的模拟执行来考核模式及子模式是否满足应用需求，有无遗漏，并进一步估计数据容量及存取效率，为物理设计提供参考信息。评价分析中，如若发现不合理之处，则返回到模型转换处重新执行，如此反复，直至满足要求为止</li></ul></li></ol><h3 id=324-物理设计>3.2.4 物理设计<a hidden class=anchor aria-hidden=true href=#324-物理设计>#</a></h3><ul><li>物理设计是指对于一个给定的数据库逻辑结构，研究并构造物理结构的过程<ul><li>其具体任务主要是确定数据库在存储设备上的<strong>存储结构及存取方法</strong>，</li><li>因 DBMS 的不同还可能包括<strong>建立索引和聚集，以及物理块大小、缓冲区个数和大小、数据压缩的选择</strong>等</li></ul></li></ul><h3 id=325-数据库实施>3.2.5 数据库实施<a hidden class=anchor aria-hidden=true href=#325-数据库实施>#</a></h3><ol><li>加载数据</li><li>应用程序设计</li><li>数据库试运行</li></ol><h3 id=326-数据库运行和维护>3.2.6 数据库运行和维护<a hidden class=anchor aria-hidden=true href=#326-数据库运行和维护>#</a></h3><ul><li>只有经过试运行之后，确认系统无故障或暂未发现故障时，系统才能投入到生产实际中运行。数据库系统投入实际运行标志着数据库设计和应用开发的基本完成，但绝不意味着设计和应用开发工作的终止。随着应用的深入和拓展，有可能暴露原未发现的问题；也有可能因对数据的不断增、删、改而使得系统的物理存储结构变坏或存取效率下降；另外，应用需求也有可能发生改变或扩展。所有这些，都需要工作人员在系统运行中做好维护工作，监督、发现和分析问题，提出改进或扩展方案并付诸实施。此外，还应定期或不定期地进行数据转储，当系统出现故障吋进行恢复处理，并实施安全与完整性控制。</li><li>系统维护中最困难的工作是数据库重组与重构。重组是当空间利用率和存取效率下降时进行的，它并不改变数据库的逻辑结构和物理结构，只是利用 DBMS 提供的设施调整数据库中数据的存储位置，从而回收“碎片”，使有关联的数据尽可能靠近存放，达到提高空间利用率和数据存取效率的目的。重构是指部分修改数据库的逻辑结构或物理结构，这往往因应用需求的改变与拓展或发现当初的设计欠妥而引起的，例如增、删、改数据类型，增、删、改索引与聚集等。</li></ul><h2 id=第三节-关系数据库设计方法重点>第三节 关系数据库设计方法(重点)<a hidden class=anchor aria-hidden=true href=#第三节-关系数据库设计方法重点>#</a></h2><h3 id=331-关系数据库设计过程与各级模式>3.3.1 关系数据库设计过程与各级模式<a hidden class=anchor aria-hidden=true href=#331-关系数据库设计过程与各级模式>#</a></h3><ul><li>如图 3 所示，按照数据库设计的基本步骤，在关系数据库设计的不同阶段，会形成<strong>数据库的各级模式</strong>:</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>graph LR
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>应用要求-应用1 --综合--&gt; 概念模式
</span></span><span style=display:flex><span>应用要求..2 --综合--&gt; 概念模式
</span></span><span style=display:flex><span>应用要求..3 --综合--&gt; 概念模式
</span></span><span style=display:flex><span>应用要求..4 --综合--&gt; 概念模式
</span></span><span style=display:flex><span>概念模式 --转换--&gt; 逻辑模式
</span></span><span style=display:flex><span>逻辑模式 --映像--&gt; 外模式-应用1
</span></span><span style=display:flex><span>逻辑模式 --映像--&gt; 外模式..2
</span></span><span style=display:flex><span>逻辑模式 --映像--&gt; 外模式..3
</span></span><span style=display:flex><span>逻辑模式 --映像--&gt; 外模式..4
</span></span><span style=display:flex><span>逻辑模式 --映像--&gt; c1((内模式))
</span></span><span style=display:flex><span> 
</span></span></code></pre></div><ul><li><p>在需求分析阶段，综合各个用户的应用需求；</p></li><li><p>在概念结构设计阶段形成独立于机器特点、独立于各个关系数据库管理系统产品（如 MySQL、 Oracle、SQL Server 等）的概念模式，</p></li><li><p>例如本书使用的 E-R 图；</p><ul><li>在逻辑结构设计阶段，将 E-R 图转换成具体的数据库产品支持的关系数据模型，形成<strong>数据库逻辑模式</strong>，</li><li>然后根据用户处理的要求、安全性的考虑，在基本表的基础上再建立必要的视图，形成<strong>数据的外模式</strong>；</li><li>在物理结构的设计阶段，根据关系数据库管理系统的特点和处理的需要，进行物理存储安排，建立索引，形成<strong>数据库内模式</strong>。</li></ul></li></ul><h3 id=332-概念结构设计方法>3.3.2 概念结构设计方法<a hidden class=anchor aria-hidden=true href=#332-概念结构设计方法>#</a></h3><ol><li><p>E-R 图的表示方法</p></li><li><p><strong>实体型，其用矩形表示，矩形框内写明实体的名称</strong></p></li><li><p><strong>属性，其用椭圆形表示，并用无向边将其与相应的实体连接起来</strong></p></li><li><p><strong>联系，其用菱形表示，菱形框内写明联系的名称，并用无向边分别与有关实体连接起来，同时在无向边旁标上联系的类型（1:1、1:N 或 M:N），如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来。</strong></p></li></ol><p>两个实体型之间的三类联系的E-R图示例</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>graph TD
</span></span><span style=display:flex><span>系 --1--&gt; C1{隶属}  
</span></span><span style=display:flex><span>C1{隶属}  --1--&gt;系主任
</span></span><span style=display:flex><span>班级 --1--&gt; C2{包含}  
</span></span><span style=display:flex><span>C2{包含}  --N--&gt;学生1
</span></span><span style=display:flex><span>学生2 --M--&gt; C3{选课}  
</span></span><span style=display:flex><span>C3{选课}  --N--&gt;课程
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback><span style=display:flex><span>graph LR
</span></span><span style=display:flex><span>用户与部门之间
</span></span><span style=display:flex><span>c1((用户名)) --- 用户
</span></span><span style=display:flex><span>c2((用户ID)) --- 用户
</span></span><span style=display:flex><span>c3((年龄)) --- 用户
</span></span><span style=display:flex><span>c4((口令)) --- 用户
</span></span><span style=display:flex><span>用户 --N--&gt; C1{包含}  
</span></span><span style=display:flex><span>C1{包含}  --1--&gt; 部门
</span></span><span style=display:flex><span>部门 --- c5((部门ID)) 
</span></span><span style=display:flex><span>部门 --- c6((部门名)) 
</span></span><span style=display:flex><span>部门 --- c7((部门地址)) 
</span></span><span style=display:flex><span>部门 --- c8((部门领导)) 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>用户与用户组之间
</span></span><span style=display:flex><span>用户1 --N--&gt; C11{属于}  
</span></span><span style=display:flex><span>C11{属于}  --1--&gt; 用户组
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>用户组与权限之间
</span></span><span style=display:flex><span>用户组1 --M--&gt; C21{拥有}  
</span></span><span style=display:flex><span>C21{属于}  --N--&gt; 权限
</span></span></code></pre></div><h3 id=333-逻辑结构设计方法>3.3.3 逻辑结构设计方法<a hidden class=anchor aria-hidden=true href=#333-逻辑结构设计方法>#</a></h3><ol><li>E-R 图向关系模型的转换<ol><li>一个实体型转换为一个关系模式。<ul><li>实体的属性作为关系的属性，实体的码作为关系的码。</li></ul></li><li><strong>一对一（1:1）联系</strong>可以转换为一个独立的关系模式，也可以与<strong>任意一端</strong>对应的关系模式合并。<ul><li>如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，每个实体的码均是该关系的候选码；</li><li>如果与某一端实体对应的关系模式合并，则需要在该关系模式的属性中加入另一个关系模式的码和联系本身的属性。</li></ul></li><li><strong>一对多（1:N）联系</strong>可以转换为一个独立的关系模式，也可以与<strong>N 端对应的关系模式合并。</strong><ul><li>如果转换为一个独立的关系模式，则与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为 N 端实体的码。</li></ul></li><li><strong>多对多（M:N）联系</strong>转换为一个关系模式。<ul><li>与该联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合。</li></ul></li><li>三个或三个以上实体间的一个多元联系可以转换为一个关系模式。<ul><li>与该多元联系相连的各实体的码以及联系本身的属性均转换为关系的属性，而关系的码为各实体码的组合</li></ul></li><li>具有相同码的关系模式可合并。</li></ol></li></ol><h3 id=334-物理结构设计方法>3.3.4 物理结构设计方法<a hidden class=anchor aria-hidden=true href=#334-物理结构设计方法>#</a></h3><ol><li>建立索引<ul><li>建立索引的方式通常有静态和动态两种。<ul><li><strong>静态建立索引</strong>是指应用人员预先建立索引，旦建立，后续的应用程序均可直接使用该索引存取数据，它多适合于用户较多且使用周期相对较长的数据；</li><li><strong>动态建立索引</strong>是指应用人员在程序内外临时建立索引，它多适合于单独用户或临时性使用要求情况。</li></ul></li></ul></li><li>建立聚集<ul><li><strong>聚集是将相关数据集中存放的物理存储技术</strong>，借以提高 IO 的数据命中率而改善存取速度，其功能由具体的 DBMS 所提供，如 MySQL。<ul><li>所谓集中存放是指将相关数据尽可能地存放于一个物理块中，或一个磁道中，或一个柱面中，或相邻区域（块、磁道、柱面）中。</li><li>例如，一个教师关系中含姓名、出生时间、性别、职称等属性，若 1975 年出生的教师有 100 个，则该关系中含有 100 个 1975 年出生教师数据的元组，最坏情况下，100 个元组分布在 100 个不同物理块中，当按出生时间访问 1975 年出生的教师信息时，则可能需要 100 次 IO（假定一次 IO 读入一个物理块）。若按出生时间集中存放数据，则一次能读入多个 1975 年出生的教师数据。</li></ul></li><li>数据聚集结构的一种有效方式是块结构方式，块与块之间由指针连接，一个块对应于一个物理分区。数据聚集可在一个或多个关系上建立。若在一个关系上建立聚集，则可按垂直或水平方向对关系分组。可将常用或经常一起使用的属性值或元组值集中存放，其他的则另外存放。若在多个关系上建立聚集，则将多个不同关系中常在一起使用的数据集中存放。无论采用何种方式，数据使用频率较高的数据才有必要建立聚集，数据量通常也较大，且更新操作应较少。</li><li>对关系数据库系统来说，就市场上流行的主要 DBMS 而言，建立了索引和聚集之后，其物理设计就基本完成，而逻辑模型本身通常并不需要进行改变。此时的物理模型实际上就是关于在逻辑模型上建立了哪些索引与聚集，以及如何建立的说明。显然，程序编制说明中应加入如何利用索引和聚集来加快数据访问的速度，从而提高应用程序执行效率的相关说明。</li></ul></li></ol><h1 id=第四章-sql-与关系型数据库基本操作>第四章 SQL 与关系型数据库基本操作<a hidden class=anchor aria-hidden=true href=#第四章-sql-与关系型数据库基本操作>#</a></h1><h2 id=第一节-sql-概述>第一节 SQL 概述<a hidden class=anchor aria-hidden=true href=#第一节-sql-概述>#</a></h2><h3 id=411-sql-的发展>4.1.1 SQL 的发展<a hidden class=anchor aria-hidden=true href=#411-sql-的发展>#</a></h3><ul><li>SQL 标准是 1986 年 10 月由美国国家标准局颁布</li><li><strong>SQL3/SQL-99：1999年颁布的SQL标准</strong></li></ul><h3 id=412-sql-的特点>4.1.2 SQL 的特点<a hidden class=anchor aria-hidden=true href=#412-sql-的特点>#</a></h3><ol><li>SQL 不是某个特定数据库供应商专有的语言。几乎所有重要的关系数据库管理系统都支持 SQL，所以掌握 SQL 可以帮助用户与几乎所有的关系数据库进行交互。</li><li>SQL 简单易学。它的语句全都是由具有很强<strong>描述性的英语单词所组成</strong>，而且这些单词的数目不多。</li><li>SQL 尽管看上去很简单，但它实际上是一种强有力的语言，灵活使用其语言元素可以进行非常复杂和高级的数据库操作。</li><li>需要注意的是：SQL 语句<strong>不区分大小写</strong>。许多 SQL 开发人员习惯于对所有 SQL<strong>关键字使用大写</strong>，而对所有<strong>列和表的名称使用小写</strong>，这样的书写方式可使代码更易于阅读和调试，本书列举的实例也将遵照这个方式。</li></ol><h3 id=413-sql-的组成>4.1.3 SQL 的组成<a hidden class=anchor aria-hidden=true href=#413-sql-的组成>#</a></h3><ol><li>数据定义语言(Data Definition Language,DDL)：<strong>定义结构</strong><ul><li><code>create</code>：用于创建数据库或数据库对象。</li><li><code>alter</code>：用于对数据库或数据库对象进行修改。</li><li><code>drop</code>：用于删除数据库或数据库对象。</li></ul></li><li>数据操纵语言(Data Manipulation Language, DML)：<strong>定义数据</strong><ol><li><code>select</code>：用于从表或视图中检索数据，其是数据库中使用最为频繁的 SQL 语句</li><li><code>insert</code>：用于将数据插入到表或视图中。</li><li><code>update</code>：用于修改表或视图中的数据，其既可修改表或视图中一行数据，也可同时修改多行或全部数据</li><li><code>delete</code>：用于从表或视图中删除数据，其中可根据条件删除指定的数据。</li></ol></li><li>数据控制语言(Data Control Language, DCL)：<strong>授权和回收权限</strong><ol><li><code>grant</code>：用于授予权限，可把语句许可或对象许可的权限授予其他用户和角色。</li><li><code>revoke</code>：用于收回权限，其功能与 grant 相反，但不影响该用户或角色从其他作为成员继承许可权限。</li></ol></li><li>嵌入式和动态 SQL 规则</li><li>SQL 调用和会话规则</li></ol><h2 id=第二节-mysql-预备知识>第二节 MySQL 预备知识<a hidden class=anchor aria-hidden=true href=#第二节-mysql-预备知识>#</a></h2><h3 id=421-mysql-使用基础>4.2.1 MySQL 使用基础<a hidden class=anchor aria-hidden=true href=#421-mysql-使用基础>#</a></h3><p>MySQL是一个关系型数据库管理系统。</p><ol><li>LAMP（ Linux+ Apache+MySQL+ PHP/Perl/Python），即使用 Linx 作为操作系统， Apache 作为 Wb 服务器， MySQL 作为数据库管理系统，PHP、Perl 或 Python 语言作为服务器端脚本解释器</li><li>WAMP（ Windows+ Apache+ MySQL+ PHP/Perl/Python），即使用 Windows 作为操作系统， Apache 作为 Web 服务器， MySQL 作为数据库管理系统，PHP、Perl 或 Python 语言作为服务器端脚本解释器</li></ol><h3 id=422-mysql-中的-sql>4.2.2 MySQL 中的 SQL<a hidden class=anchor aria-hidden=true href=#422-mysql-中的-sql>#</a></h3><ol><li><p>常量</p><p>常量是指在程序运行过程中值不变的量，也称为字面值或标量值。常量的使用格式取决于值的数据类型，可分为字符串常量、数值常量、十六进制常量、时间日期常量、位字段值、布尔值和 null 值。</p></li></ol><ul><li>字符串常量是指用单引号或双引号括起来的字符序列，分为 ASCⅡ 字符串常量和 Unicode 字符串常量。</li><li>数值常量可以分为整数常量和浮点数常量。其中，整数常量是不带小数点的十进制数；浮点数常量则是使用小数点的数值常量。</li><li>一个十六进制值通常指定为一个字符串常量，每对十六进制数字被转换为一个字符，其最前面有一个大写字母“X”或小写字“x”</li><li>日期时间常量是用单引号将表示日期时间的字符串括起来而构成的。</li><li>可以使用<code>b'value'</code>格式符号书写位字段值。其中， value 是一个用 0 或 1 书写的二进制值。位字段符号可以方便地指定分配给 BIT 列的值。</li><li>布尔值只包含两个可能的值，分别是 TRUE 和 FALSE。其中， FALSE 的数字值是
“0”，TRUE 的数字值是“1”。</li><li>NUL 值通常用于表示“没有值”“无数据”等意义，它与数字类型的“0”或字符串类型的空字符串是完全不同的。</li></ul><ol start=2><li><p>变量</p><ul><li>变量用于临时存储数据，变量中的数据可以随着程序的运行而变化。变量有名字和数据类型两个属性。其中，变量的名字用于标识变量，变量的数据类型用于确定变量中存储数值的格式和可执行的运算。</li><li>在 MySQL 中，变量分为用户变量和系统变量。在使用时，<strong>用户变量前常添加一个符号“@”</strong>，用于将其与列名区分开；而大多数系统变量应用于其他 SQL 语句中时，必须在<strong>系统变量名称前添加两个“@”符号</strong>。</li></ul></li><li><p>运算符</p><ul><li>常用的运算符算术运算符有：<ul><li><code>+（加）、-（减）、*（乘）、/（除）和%（求模）</code> 5 种运算。</li></ul></li><li>位运算符有：<ul><li><code>&（位与）、|（位或）、^（位异或）、~（位取反）、>（位右移）、&lt;（位左移）</code>。</li></ul></li><li>比较运算符有：<ul><li><code>=（等于）、>（大于）、&lt;（小于）、>（大于等于）、&lt;=（小于等于）、∞（不等于）、！=（不等于）、&lt;→（相等或都等于空）</code></li></ul></li><li>逻辑运算符有：<ul><li><code>NOT或！（逻辑非）、AND或&&（逻辑与）、OR或‖（逻辑或）XOR（逻辑异或)</code></li></ul></li></ul></li><li><p>表达式</p><ul><li>表达式是常量、变量、列名、复杂计算、运算符和函数的组合。</li><li>一个表达式通常可以得到一个值。与常量、变量一样，表达式的值也具有某种数据类型，可能的数据类型有字符类型、数值类型、日期时间类型。因而，根据表达式的值的数据类型，表达式可分为字符型表达式、数值型表达式和日期表达式。</li></ul></li><li><p>内置函数</p><ul><li>数学函数，例如<code>abs()</code>函数、<code>sort()</code>函数；</li><li>聚合函数，例如 <code>count()</code>函数；count 计数，sum求和</li><li>字符串函数，例如 <code>asc()</code>函数、 <code>char()</code>函数</li><li>日期和时间函数，例如<code>now()</code>函数、 <code>year()</code>函数；</li><li>加密函数，例如 <code>encode()</code>函数、 <code>encrypt()</code>函数</li><li>控制流程函数，例如<code>if()</code>函数、 <code>ifnull()</code>函数；</li><li>格式化函数，例如 <code>format()</code>函数</li><li>类型转换函数，例如<code>cast()</code>函数；</li><li>系统信息函数，例如 <code>user()</code>函数、<code>version()</code>函数。</li></ul></li></ol><h2 id=第三节-数据定义>第三节 数据定义<a hidden class=anchor aria-hidden=true href=#第三节-数据定义>#</a></h2><h3 id=431-数据库模式定义>4.3.1 数据库模式定义<a hidden class=anchor aria-hidden=true href=#431-数据库模式定义>#</a></h3><ol><li><p>创建数据库</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> {<span style=color:#af3a03>database</span><span style=color:#af3a03>|</span><span style=color:#af3a03>schema</span>}[<span style=color:#af3a03>if</span> <span style=color:#af3a03>not</span> <span style=color:#af3a03>exists</span>] db_name
</span></span><span style=display:flex><span>[<span style=color:#af3a03>default</span>] <span style=color:#af3a03>character</span> <span style=color:#b57614>set</span>[<span style=color:#af3a03>=</span>]charset_name
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>[<span style=color:#af3a03>default</span>] <span style=color:#af3a03>collate</span>[<span style=color:#af3a03>=</span>]collation_name
</span></span></code></pre></div><ul><li><code>[]</code>标示其内容为可选项;</li><li><code>|</code> 用于分隔花括号中的选择项,表示可任选其中一项来与花括号外的语法成分共同组成 SQL 语句命令, 即选项彼此间是"或"的关系</li><li><code>db_name</code> 用于标示具体的数据库命名,且该数据库名必须符合操作系统文件夹命名规则, 而在 MySQL 中则不区分大小写;</li><li>关键字 <code>default</code> 用于指定默认值;</li><li>关键字 <code>character set</code> 用于<strong>指定数据库字符集</strong> <code>Charset</code>;</li><li>关键字 <code>collate</code> 用于<strong>指定字符集的校对规则</strong>;</li><li>关键字 <code>if not exists</code> 用于在创建数据库前进行判断,只有该数据库目前尚不存在时才执行 <code>create database</code> 操作,即此选项可以避免出现数据库已经存在而再新建的错误</li></ul><p>例 4.1</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>database</span> test_db;
</span></span></code></pre></div></li><li><p>选择数据库</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>use</span> db_name;
</span></span></code></pre></div></li><li><p>修改数据库</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>alter</span> {<span style=color:#af3a03>database</span><span style=color:#af3a03>|</span><span style=color:#af3a03>schema</span>} [db_name]
</span></span><span style=display:flex><span>alter_specification...
</span></span></code></pre></div><p>例 4.2 修改已有数据库 test_db 的默认字符集和校对规则</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>alter</span> <span style=color:#af3a03>database</span> test_db
</span></span><span style=display:flex><span><span style=color:#af3a03>default</span> <span style=color:#af3a03>character</span> <span style=color:#b57614>set</span> gb2312  <span style=color:#928374;font-style:italic># 修改字符集
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>default</span> <span style=color:#af3a03>collate</span> gb2312_chinese_ci;   <span style=color:#928374;font-style:italic># 用于指定字符集的校对规则
</span></span></span></code></pre></div></li><li><p>删除数据库</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> {<span style=color:#af3a03>database</span><span style=color:#af3a03>|</span><span style=color:#af3a03>schema</span>}{<span style=color:#af3a03>if</span> <span style=color:#af3a03>exists</span>} db_name;
</span></span></code></pre></div><p>例 4.3</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> <span style=color:#af3a03>database</span> <span style=color:#af3a03>if</span> <span style=color:#af3a03>exists</span> mytest;
</span></span></code></pre></div></li><li><p>查找数据库</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>show</span>{<span style=color:#af3a03>database</span><span style=color:#af3a03>|</span><span style=color:#af3a03>schemas</span>}
</span></span><span style=display:flex><span>[<span style=color:#af3a03>like</span> <span style=color:#79740e>&#39;pattern&#39;</span><span style=color:#af3a03>|</span><span style=color:#af3a03>where</span> expr]
</span></span><span style=display:flex><span><span style=color:#af3a03>like</span> 关键字用于匹配指定的数据库名称
</span></span></code></pre></div><p>例 4.4</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>show</span> <span style=color:#af3a03>databases</span>;
</span></span></code></pre></div></li></ol><h3 id=432-表定义与操作>4.3.2 表定义与操作<a hidden class=anchor aria-hidden=true href=#432-表定义与操作>#</a></h3><ol><li><p>创建表</p><p><code>create table</code>语句的语法内容较多,主要由表创建定义( create definition)、表选项( table options)和分区选项( partition options)等内容所构成。</p></li></ol><p>MySQL主要数据类型：
数值型： 包括 int、double、float(n)
字符串型： char(n)、varchar(n)；前者是定长(固定长度n)，后者为变长串
位串型：bit(n)、bit varying(n) ；同上
时间型：date、time</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> [TEMPORARY] <span style=color:#af3a03>table</span> <span style=color:#b57614>tbl_name</span>
</span></span><span style=display:flex><span>(
</span></span><span style=display:flex><span>字段名<span style=color:#8f3f71>1</span> 数据类型 [列级完整性约束条件][默认值]
</span></span><span style=display:flex><span>  [,字段名<span style=color:#8f3f71>2</span> 数据类型[列级完整性约束条件][默认值]]
</span></span><span style=display:flex><span>  [,...]
</span></span><span style=display:flex><span>  [,表级完整性约束条件]
</span></span><span style=display:flex><span>)[<span style=color:#af3a03>ENGINE</span><span style=color:#af3a03>=</span>引擎类型];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>PRIMARY</span> <span style=color:#af3a03>KEY</span>(id) 指定主键
</span></span><span style=display:flex><span><span style=color:#af3a03>AUTO_INCREMENT</span> 设置自增属性,自动编号
</span></span><span style=display:flex><span><span style=color:#af3a03>DEFAULT</span> 指定默认值
</span></span></code></pre></div><p>例 4.5 在一个已有数据库<code>mysql_list</code>中新建一个包含客户姓名、性别、地址、联系方式等内容的客户基本信息表, 要求将客户的 id 号指定为该表的主键.</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>use</span> test_db;
</span></span><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>table</span> customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> (
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> cust_id <span style=color:#b57614>INT</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> cust_name <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> cust_sex <span style=color:#b57614>char</span>(<span style=color:#8f3f71>1</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>default</span> <span style=color:#8f3f71>0</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> cust_address <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> cust_contact <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>primary</span> <span style=color:#af3a03>key</span>(cust_id)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> );
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>17</span> sec)
</span></span></code></pre></div><ol><li><p>临时表与持久表</p><ul><li><code>TEMPORARY</code> 为临时表, 不加为持久表</li><li>临时表只有创建者可见, 断开连接会自动删除</li></ul></li><li><p>数据类型</p></li><li><p>关键字 <code>AUTO_INCREMENT</code></p><ul><li>为表中数据类型为整型的列设置自增属性</li><li>每个表只能有一个自增列, 并且它必须被索引</li></ul></li><li><p>指定默认值 <code>default</code></p><ul><li>而如若该列被定义为 <code>not null</code>,则默认值取决于该列的类型</li><li>对于一个<code>AUTO INCREMENT</code>列,默认值是在顺序中的下一个值;</li><li>对于除 <code>timestamp</code>以外的日期和时间类型,默认值是该类型适当的"零"值;</li><li>对于表中第一个 <code>timestamp</code>列,默认值是当前的日期和时间</li></ul></li><li><p><code>null</code> 值</p></li><li><p>主键 <code>primary key()</code></p></li><li><p>更新表</p></li><li><p><code>add[column]</code> 子句</p><ul><li><p>例 4.6 向数据库 <code>test_db</code>的表 <code>customers</code>中添加一列,并命名为 <code>cust_city</code>, 用于描述用户所在的城市, 要求其不能为<code>null</code>, 默认值为字符串<code>Wuhan</code>, 且该列位于原表 <code>cust_sex</code>列之后</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>add</span> <span style=color:#af3a03>column</span> cust_city <span style=color:#b57614>char</span>(<span style=color:#8f3f71>10</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>default</span> <span style=color:#79740e>&#39;Wuhan&#39;</span> after cust_sex;
</span></span></code></pre></div></li><li><p>通过关键字" <code>after</code>&ldquo;在原表 <code>cust_sex</code>列之后添加了一个新列 <code>cust_city</code>,也可通过关键字&rdquo; FIRST"将新列 <code>cust_city</code>作为原表的第一列,若不指定这两个关键字,则新列会添加到原表的最后.另外,此例中对表名的指定采用的是完全限定的表名方式, 即" <code>db_name.tbl_name</code>&ldquo;的表名格式</p></li><li><p>类似地,可以在 <code>alter table</code>语句中通过使用 <code>ADDPRIMARY key</code>子句、<code>add foreign key</code>子句、 <code>add index</code>子句为原表添加一个主键、外键和索引等.</p></li></ul></li><li><p><code>change[column]</code> 子句，修改表中列的名称或数据类型</p><ul><li><p>例 4.7 将数据库 <code>test_db</code>中表 <code>customers</code>的 <code>cust sex</code>列重命名为<code>sex</code>,且将其数据类型更改为字符长度为 1 的字符数据类型<code>char(1)</code>,允许其为<code>null</code>,默认值为字符常量<code>M</code>.</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>change</span> <span style=color:#af3a03>column</span> cust_sex sex <span style=color:#b57614>char</span>(<span style=color:#8f3f71>1</span>) <span style=color:#d3869b>null</span> <span style=color:#af3a03>default</span> <span style=color:#79740e>&#39;M&#39;</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>04</span> sec)
</span></span></code></pre></div></li><li><p>如果试图改变的数据类型与原有数据类型不兼容，SQL 命令则不会被执行，且系统会提示错误；而在类型兼容的情况下，该列的数据可能会被截断</p></li></ul></li><li><p><code>alter[column] 子句</code>，修改或删除表中指定列的默认值</p><ul><li><p>例 4.8 将数据库 <code>test_db</code>中表 <code>customers</code>的 <code>cust city</code>列的默认值修改为字符常量 ‘Beijing’</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>column</span> cust_city <span style=color:#b57614>set</span> <span style=color:#af3a03>default</span> <span style=color:#79740e>&#39;Beijing&#39;</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>04</span> sec)
</span></span></code></pre></div></li></ul></li><li><p><code>modify[column] 子句</code>，只修改指定列的数据类型，不会干涉它的类名</p><ul><li><p>例 4.9 将数据库 <code>test_db</code>中表 <code>customers</code>的 <code>cust name</code>列的数据类型由之前的字符长度为 50 的定长字符数据类型 <code>char（50）</code>更改为字符长度为 20 的定长字符数据类型 <code>char（20）</code>，并将此列设置成表的第一列。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> modify <span style=color:#af3a03>column</span> cust_name <span style=color:#b57614>char</span>(<span style=color:#8f3f71>20</span>) FIRST;
</span></span></code></pre></div></li></ul></li><li><p><code>drop[column] 子句</code>，删除表中指定列</p><ul><li><p>例 4.10 删除数据库 <code>test_db</code>中表 <code>customers</code>的 <code>cust contact</code>列。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span>  <span style=color:#af3a03>drop</span> <span style=color:#af3a03>column</span> cust_contact;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>05</span> sec)
</span></span></code></pre></div></li><li><p>类似地,也可分别通过在 <code>alter table</code> 语句中添加 <code>drop primary key</code>子句、 <code>drop foreign key</code>子句、<code>drop index</code>子句卸除原表的主键、外键和索引等</p></li></ul></li><li><p><code>rename[TO]</code> 子句，给表重新命名</p><ul><li><p>例 4.11 使用 <code>rename [TO]</code>子句,<strong>重命名数据库</strong> <code>test_db</code>中表 <code>customers</code>的表名为<code>backup customers</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>rename</span> <span style=color:#af3a03>TO</span> test_db.backup_customers;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>03</span> sec)
</span></span></code></pre></div></li></ul></li><li><p>重命名表</p></li></ol><pre><code>```mysql
 rename table tbl_name TO new_tbl_name
 [,tbl_name2 to new_tbl_name2] ...
 ```
</code></pre><ul><li><p>例 4.12 使用 <code>rename table</code>语句,将例 4.1 中的表 <code>backup customers</code>再重新命名为<code>customer</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>rename</span> <span style=color:#af3a03>table</span> test_db.backup_customers <span style=color:#af3a03>TO</span> test_db.customers;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>05</span> sec)
</span></span></code></pre></div><ol start=4><li>删除表</li></ol></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> [TEMPORARAY] <span style=color:#af3a03>table</span> [<span style=color:#af3a03>if</span> <span style=color:#af3a03>exists</span>] tbl_name[,tbl_name]... [<span style=color:#af3a03>restrict</span><span style=color:#af3a03>|</span>CASXADE]
</span></span></code></pre></div><ul><li><p>需要注意的是: <code>drop table</code>语句可以同时删除多个表(包括临时表), 但操作者必须拥有该命令的权限;</p><ul><li>当表被删除时, 其中存储的数据和分区信息均会被删除, 所以使用该语句须格外小心, 但操作者在该表上的权限并不会自动被删除</li></ul></li></ul><ol start=5><li><p>查看表</p><ol><li><p>显示表的名称</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>show</span> [full] <span style=color:#af3a03>tables</span> {<span style=color:#af3a03>from</span><span style=color:#af3a03>|</span><span style=color:#af3a03>in</span>} db_name]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>like</span><span style=color:#79740e>&#39;pattern&#39;</span><span style=color:#af3a03>|</span><span style=color:#af3a03>where</span> expr]
</span></span></code></pre></div><ul><li>例 4.13 显示数据库 <code>test_db</code>中所有的表名</li></ul></li></ol></li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>show</span> <span style=color:#af3a03>tables</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> Tables_in_mysql_test <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> customers            <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><ol start=2><li><p>显示表的结构</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>show</span> [full] columns {<span style=color:#af3a03>from</span><span style=color:#af3a03>|</span><span style=color:#af3a03>in</span>} tbl_name [{<span style=color:#af3a03>from</span><span style=color:#af3a03>|</span><span style=color:#af3a03>in</span>} db_name]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>like</span><span style=color:#79740e>&#39;pattern&#39;</span><span style=color:#af3a03>|</span><span style=color:#af3a03>where</span> expr]
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>{<span style=color:#af3a03>describe</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>} tbl_name[col_name<span style=color:#af3a03>|</span>wild]
</span></span></code></pre></div><p>MySQL 支持用 <code>describe</code>作为 <code>show columns from</code>的一种快捷方式</p><ul><li><p>例 4.14 显示数据库 <code>test_db</code>中表 <code>customers</code>的结构</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>desc</span> test_db.customers;
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+------+-----+---------+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> Field        <span style=color:#af3a03>|</span> Type     <span style=color:#af3a03>|</span> <span style=color:#d3869b>Null</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>Key</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>Default</span> <span style=color:#af3a03>|</span> Extra          <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+------+-----+---------+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_name    <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>20</span>) <span style=color:#af3a03>|</span> YES  <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>    <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_id      <span style=color:#af3a03>|</span> <span style=color:#b57614>int</span>(<span style=color:#8f3f71>11</span>)  <span style=color:#af3a03>|</span> NO   <span style=color:#af3a03>|</span> PRI <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>    <span style=color:#af3a03>|</span> <span style=color:#af3a03>auto_increment</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> sex          <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>1</span>)  <span style=color:#af3a03>|</span> YES  <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> M       <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_city    <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>10</span>) <span style=color:#af3a03>|</span> NO   <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> Beijing <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_address <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#af3a03>|</span> YES  <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>    <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+------+-----+---------+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>5</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div></li></ul></li></ol><h3 id=433-索引定义>4.3.3 索引定义<a hidden class=anchor aria-hidden=true href=#433-索引定义>#</a></h3><p>索引是提高数据文件访问效率的有效方法</p><ul><li>DBMS 根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表,因而索引实质上是一张描述索引列的列值与原表中记录行之间一一对应关系的有序表</li><li>在列上创建了索引之后,查找数据时可以直接根据该列上的索引找到对应记录行的位置, 从而快速地查找到数据<ol><li>**索引是以文件的形式存储的，如果有大量的索引，索引文件可能会比数据文件更快地达到最大的文件尺寸。**特别是如果在一个大表上创建了多种组合索引，索引文件会膨胀得非常快。</li><li><strong>索引在提高查询速度的同时，却会降低更新表的速度</strong>。在更新表中索引列上的数据时，索引会被自动更新，以确保索引树与表中的内容保持一致，这可能需要重新组织一个索引。如果表中的索引很多，这会非常浪费时间，由此会降低 INSERT、 UPDATE、 delete 和其他写入操作的效率。表中的索引越多，则更新表的时间就会越长。</li></ol></li><li>根据具体用途，索引在逻辑上通常包含有如下几类<ol><li>普通索引（ <code>index</code>）是最基本的索引类型，它没有任何限制。创建普通索引时，通常使用关键字<code>index</code>或<code>key</code></li><li>唯一性索引（ <code>unique</code>）：区别普通索引，即索引列中的所有值都只能出现一次，必须是唯一的。创建唯一性索引时，通常使用的关键字 <code>unique</code>。</li><li>主键（ <code>primary key</code>）
主键是一种唯一性索引。创建主键时，必须指定关键字 <code>primary key</code>，且不能有空值。主键一般是在创建表的时候指定，也可以通过修改表的方式添加主键，并且每个表只能有一个主键。</li></ol></li></ul><ol><li><p>索引的创建</p><ol><li><p>使用 <code>create index</code>语句创建索引</p><p>可以使用专门用于创建索引的 <code>create index</code>语句在一个已有的表上创建索引，但该语句不能创建主键。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> [<span style=color:#af3a03>unique</span>] <span style=color:#af3a03>index</span> index_name
</span></span><span style=display:flex><span><span style=color:#af3a03>on</span> <span style=color:#b57614>tbl_name</span>(index_col_name,...)
</span></span></code></pre></div><p><code>index_col_name</code>的格式为：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>col_name[(length)][<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>]
</span></span></code></pre></div><ul><li><p>可选项“ <code>unique</code>”关键字用于指定创建唯一性索引；“ <code>index_name</code>”用于指定索引名，一个表可以创建多个索引，但每个索引在该表中的名称必须是唯一的；“ <code>tbl_name</code>”用于指定要建立索引的表名；“ <code>index_col_name</code>”是关于索引列的描述。</p></li><li><p>关于索引列的描述可包含这样三个语法要素：“ <code>col_name</code>”用于指定要创建索引的列名，通常可考虑将查询语句中在 <code>where</code>子句和<code>JOIN</code>子句里出现的列来作为索引列可选项“ <code>length</code>”，用于指定使用列的前 <code>length</code>个字符来创建索引，使用列的一部分创建索引有利于减小索引文件的大小，节省磁盘空间；关键字“<code>asc</code>”或“<code>desc</code>”是可选项，用于指定索引按升序（ASC）还是降序（<code>desc</code>）来排列，默认时为<code>asc</code></p></li><li><p>例 4.5 在数据库 <code>test_db</code>的表 <code>customers</code>上，根据客户姓名列的前三个字符创建个升序索引 <code>index_customers</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>index</span> index_customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>on</span> test_db.<span style=color:#b57614>customers</span>(<span style=color:#b57614>cust_name</span>(<span style=color:#8f3f71>3</span>) <span style=color:#af3a03>asc</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>05</span> sec)
</span></span></code></pre></div><p>该语句成功执行后，接着输入语句 <code>show index from test_db.customers</code>即可查看到已建立的索引</p></li><li><p>例 4.16 在数据库 <code>test_db</code>的表 <code>customers</code>上，根据客户姓名列和客户 id 号创建一个组合索引 <code>index_cust</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>index</span> index_cust
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>on</span> test_db.<span style=color:#b57614>customers</span>(cust_name,cust_id);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>02</span> sec)
</span></span></code></pre></div></li></ul></li><li><p>使用 <code>create table</code>语句创建索引</p><ol><li><p>语法项 <code>(constraint [symbol]] primary key(index_col_name;…)</code>, 用于表示在创建新表的同时创建该表的主键</p></li><li><p>语法项 <code>{index|key}[index_name](index_col_name,…)</code>, 用于表示在创建新表的同时创建该表的索引</p></li><li><p>语法项 <code>[constraint[symbol]] unique [index|key][index_name](inde_name,…)</code>,用于表示在创建新表的同时创建该表的唯一性索引;</p></li><li><p>语法项<code>[constraint[symbo]foreign key[lindex name](Gindex_col_name,…)</code>,用于表示在创建新表的同时创建该表的外键</p><ul><li><p>其中,关键字&rdquo;<code>key</code>&ldquo;是关键字 <code>index</code>的同义词;</p></li><li><p><strong>关键字&rdquo; <code>constraint</code>&ldquo;用于为主键、 <code>unique</code>键、外键定义一个名字</strong>;</p></li><li><p>在使用 <code>create table</code>语句定义列选项的时候,可以通过直接在某个列定义后面添加关键字&rdquo; <code>primary key</code>&ldquo;的方式来创建主键,而当主键是由多个列组成的多列索引时,则不能使用这种方法,只能通过在语句最后加上一个 <code>primary key( col name,…)</code>子句的方式来实现</p></li><li><p>例 4.17 在已有数据库 <code>test_db</code>上新建一个包含产品卖家 id 号、姓名、地址、联系方式、售卖产品类型、当月销量等内容的产品卖家信息表 seller ,要求在创建表的同时, 为该表添加由卖家 id 号和售卖产品类型组成的联合主键, 并在当月销量上创建索引</p></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>table</span> seller
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> (
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> seller_id <span style=color:#b57614>int</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> seller_name <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> seller_adderss <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> seller_contact <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> product_type <span style=color:#b57614>int</span>(<span style=color:#8f3f71>5</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> sales <span style=color:#b57614>int</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>primary</span> <span style=color:#af3a03>key</span>(seller_id,product_type),
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>index</span> <span style=color:#b57614>index_seller</span>(sales)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> );
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows affected, <span style=color:#8f3f71>1</span> <span style=color:#b57614>warning</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>03</span> sec)
</span></span></code></pre></div><p>主键都不能为空</p></li></ol></li><li><p>使用 <code>alter table</code>语句创建索引</p><ol><li>语法项 <code>add{ index key} index name](index col name,…)</code>,用于表示在修改表的同时为该表添加索引</li><li>语法项 <code>add[ constraint[ symbol]] primary key( Gindex col name;…)</code>,用于表示在修改表的同时为该表添加主键;</li><li>语法项 <code>add[ constraint[ symbol]unique[ idex key][ index name]( index col name,…)</code>,用于表示在修改表的同时为该表添加唯一性索引;</li><li>语法项 <code>add[ constraint[ symbol]foreign key[ lindex name]( index col name;…)</code>,用于表示在修改表的同时为该表添加外键.</li></ol><ul><li><p>例 4.8 使用 <code>alter table</code>语句在数据库 <code>test_db</code>中表 <code>seller</code>的姓名列上添加一个非唯一的索引,取名为 <code>index_seller_name</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.seller
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>add</span> <span style=color:#af3a03>index</span> <span style=color:#b57614>index_seller_name</span>(seller_name);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>02</span> sec)
</span></span></code></pre></div></li></ul></li></ol></li><li><p>索引的查看</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>show</span> {<span style=color:#af3a03>index</span><span style=color:#af3a03>|</span>INDEXES<span style=color:#af3a03>|</span><span style=color:#af3a03>keys</span>}
</span></span><span style=display:flex><span>{<span style=color:#af3a03>from</span><span style=color:#af3a03>|</span><span style=color:#af3a03>in</span>} tbl_name
</span></span><span style=display:flex><span>[{<span style=color:#af3a03>from</span><span style=color:#af3a03>|</span><span style=color:#af3a03>in</span>} db_name]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>where</span> expr]
</span></span></code></pre></div></li><li><p>索引的删除</p><ol><li><p>使用 <code>drop index</code>语句删除索引</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> <span style=color:#af3a03>index</span> index_name <span style=color:#af3a03>on</span> tbl_name
</span></span></code></pre></div><p>其中,&rdquo; <code>index_name</code>&ldquo;用于指定要删除的索引名,&rdquo; <code>tbl_name</code>&ldquo;用于指定该索引所在的表</p><ul><li><p>例 4.19 删除 例 4.16 中所创建的索引 <code>index_cust</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>drop</span> <span style=color:#af3a03>index</span> index_cust <span style=color:#af3a03>on</span> test_db.customers;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>02</span> sec)
</span></span></code></pre></div></li></ul></li><li><p>使用 <code>alter table</code>语句删除索引</p><ol><li><p>选用 <code>drop primary key</code>子句用于删除表中的主键, 由于一个表中只有一个主键, 其也是一个索引;</p></li><li><p>选用 <code>drop index</code>子句用于删除各种类型的索引</p></li><li><p>选用 <code>drop foreign key</code>子句用于删除外键</p><ul><li><p>例 4.20 使用 <code>alter table</code>语句删除数据库 <code>test_db</code>中表 <code>customers</code>的主键和索引<code>index_customers</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#928374;font-style:italic>#drop primary key,
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>drop</span> <span style=color:#af3a03>index</span> index_customers;
</span></span></code></pre></div><p>主键有 auto_increment，先清除自增才能删 <code>modify column cust_id INT not null;</code>
删除后设置回 key</p></li></ul></li></ol></li></ol></li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> modify <span style=color:#af3a03>column</span> cust_id <span style=color:#b57614>INT</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>key</span> <span style=color:#af3a03>AUTO_INCREMENT</span> FIRST
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>add</span> <span style=color:#af3a03>column</span> cust_contact <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#d3869b>null</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>change</span> <span style=color:#af3a03>column</span> sex cust_sex <span style=color:#b57614>char</span>(<span style=color:#8f3f71>1</span>) <span style=color:#d3869b>null</span> <span style=color:#af3a03>default</span> <span style=color:#79740e>&#39;M&#39;</span>;
</span></span></code></pre></div><p>Query OK, 0 rows affected (0.04 sec)</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>desc</span> test_db.customers;
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+------+-----+---------+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> Field        <span style=color:#af3a03>|</span> Type     <span style=color:#af3a03>|</span> <span style=color:#d3869b>Null</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>Key</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>Default</span> <span style=color:#af3a03>|</span> Extra          <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+------+-----+---------+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_id      <span style=color:#af3a03>|</span> <span style=color:#b57614>int</span>(<span style=color:#8f3f71>11</span>)  <span style=color:#af3a03>|</span> NO   <span style=color:#af3a03>|</span> PRI <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>    <span style=color:#af3a03>|</span> <span style=color:#af3a03>auto_increment</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_name    <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>20</span>) <span style=color:#af3a03>|</span> YES  <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>    <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_sex     <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>1</span>)  <span style=color:#af3a03>|</span> YES  <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> M       <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_city    <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>10</span>) <span style=color:#af3a03>|</span> NO   <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> Beijing <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_address <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#af3a03>|</span> YES  <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>    <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_contact <span style=color:#af3a03>|</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#af3a03>|</span> YES  <span style=color:#af3a03>|</span>     <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>    <span style=color:#af3a03>|</span>                <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+------+-----+---------+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>6</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><h2 id=第四节-数据更新>第四节 数据更新<a hidden class=anchor aria-hidden=true href=#第四节-数据更新>#</a></h2><h3 id=441-插入数据>4.4.1 插入数据<a hidden class=anchor aria-hidden=true href=#441-插入数据>#</a></h3><ol><li><p>使用 <code>insert...values</code> 语句插入单行或多行元组数基</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>insert</span> [<span style=color:#af3a03>into</span>] tbl_name[(col_name,...)]
</span></span><span style=display:flex><span>{<span style=color:#af3a03>values</span><span style=color:#af3a03>|</span>value}({expr<span style=color:#af3a03>|</span><span style=color:#af3a03>default</span>},...),(...),...
</span></span></code></pre></div><ol><li><p>" <code>tbl_name</code>&ldquo;指定欲被插入数据的表名.</p></li><li><p>" <code>col_name</code>&ldquo;指定需要插入数据的列名列表;</p><ol><li>如果要向表中所有列插入数据, 则全部列名均可省略;</li><li>如果只是向表的部分列插入数据, 则需要明确指定这些列的列名;</li><li>而对于那些没有被指定的列, 它们的值可根据列的<strong>默认值或相关属性</strong>来确定, 通常 MySQL 是按照下列原则进行处理的:<ol><li>对于具有标志( <code>IDENTITY</code>)属性的列, 系统会自动生成序号值来唯一标志该列;</li><li>具有默认值的列, 其值可通过在 <code>insert</code> 语句中指定关键字&rdquo; <code>default</code>&ldquo;将其设为默认值;</li><li>没有默认值的列, 若允许为空值, 则其值可通过在 <code>insert</code> 语句中指定关键字
&ldquo;<code>null</code>&rdquo; 将其设为空值, 若不允许为空值, 则 <code>insert</code> 语句执行出错;</li><li>对于类型为 <code>timestamp</code>的列,系统会为其自动赋值</li><li>由于 <code>AUTO INCREMENT</code>属性列的值是在表中其他列被赋值之后生成的,所以在对表中其他列做任何赋值操作(如 <code>insert</code>语句)时,对该 <code>AUTO INCREMENT</code>属性列的引用只会返回数字 0</li></ol></li></ol></li><li><p>通过关键字&rdquo; <code>values</code>&ldquo;或&rdquo;<code>value</code>&ldquo;引导的子句,其包含各列需要插入的数据清单; 数据清单中数据的顺序必须与列的顺序相对应,同时该子句中的值可以是:</p><ol><li>&ldquo;<code>expr</code>",表示一个常量、变量或一个表达式,也可以是空值<code>null</code>,其值的数据类型要与列的数据类型一致,如果表达式的类型与列值不匹配,这样做会造成类型转化或插入语句出错,另外当列值为字符型时,需要用单引号括起</li><li>关键字&rdquo; <code>default</code>",即用于指定此列值为该列的默认值,前提是该列之前已经明确指定了默认值,否则插入语句会出错.</li></ol></li></ol></li></ol><ul><li><strong>例 4.21</strong> 使用 <code>insert… values</code>语句向数据库 <code>test_db</code>的表 <code>customers</code>中插入这样行完整数据:<code>(901,张三,F,北京市,朝阳区)</code></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>901</span>,<span style=color:#79740e>&#39;张三&#39;</span>,<span style=color:#79740e>&#39;F&#39;</span>,<span style=color:#79740e>&#39;北京市&#39;</span>,<span style=color:#79740e>&#39;朝阳区&#39;</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>07</span> sec)
</span></span></code></pre></div><ul><li><strong>例 4.22</strong> 使用 <code>insert… values</code> 语句向数据库 <code>test_db</code>的表 <code>customers</code>中插入一行数据,要求该数据目前只用明确给出 <code>cust name</code>列和 <code>cust address</code>列的信息,即分别为"李四"和"武汉市&rdquo;,而 <code>cust id</code>列的值由系统自动生成, <code>cust sex</code>列选用表中默认值,另外<code>cust contact</code>列的值暂不确定,可不用指定</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>0</span>,<span style=color:#79740e>&#39;李四&#39;</span>,<span style=color:#af3a03>default</span>,<span style=color:#79740e>&#39;武汉市&#39;</span>,<span style=color:#d3869b>null</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><p>values 语句的使用中没有给出待插入表的列表清单 , 最好将其改为这样的 SQL 语句形式</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> test_db.<span style=color:#b57614>customers</span>(cust_id,cust_name,cust_sex,cust_address,cust_contact)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>0</span>,<span style=color:#79740e>&#39;王五&#39;</span>,<span style=color:#af3a03>default</span>,<span style=color:#79740e>&#39;上海市&#39;</span>,<span style=color:#d3869b>null</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><p>其中,第一个列 <code>cust id</code>指定为数字 0,也可设置为<code>null</code>,这是因为每次插入一个新行时,该列会由 MySQL 在前一行该列值的基础上自动增量;</p><ol start=2><li>使用 <code>insert...set</code> 语句插入部分列值数据</li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>insert</span> [<span style=color:#af3a03>into</span>] tbl_name
</span></span><span style=display:flex><span><span style=color:#b57614>set</span> col_name<span style=color:#af3a03>=</span>{expr<span style=color:#af3a03>|</span><span style=color:#af3a03>default</span>},...
</span></span></code></pre></div><ul><li><p>例 4.23 使用 <code>insert...set</code>语句来实现 例 4.22 的数据插入需求</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#b57614>set</span> cust_name<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;李四&#39;</span>,cust_address<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;武汉市&#39;</span>,cust_sex<span style=color:#af3a03>=</span><span style=color:#af3a03>default</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><ol start=3><li>使用 <code>insert...select</code> 语句插入子查询数据</li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>insert</span> [<span style=color:#af3a03>into</span>] tbl_name[(col_name,...)]
</span></span><span style=display:flex><span><span style=color:#af3a03>select</span>...
</span></span></code></pre></div></li><li><p>在此语法中: <code>select</code>子句用于快速地从一个或多个表中取出数据,并将这些数据作为行数据插入到另一个表中, <code>select</code>子句返回的是一个查询到的结果集, <code>insert</code>语句将这个结果集插入到指定表中,其中结果集中每行数据的字段数、字段的数据类型必须与被操作的表完全一致</p></li></ul><h3 id=442-删除数据>4.4.2 删除数据<a hidden class=anchor aria-hidden=true href=#442-删除数据>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span> <span style=color:#af3a03>delete</span> <span style=color:#af3a03>from</span> tbl_name
</span></span><span style=display:flex><span> [<span style=color:#af3a03>where</span> where_condition]
</span></span><span style=display:flex><span> [<span style=color:#af3a03>order</span> <span style=color:#af3a03>by</span> ...]
</span></span><span style=display:flex><span> [<span style=color:#af3a03>limit</span> row_count]
</span></span></code></pre></div><ul><li><p>" <code>tbl name</code>&ldquo;指定要删除数据的表名;</p></li><li><p>可选项 <code>where</code>子句表示为删除操作限定删除条件,从而删除特定的行,</p><ul><li>若省略 <code>where</code>子句,则表示删除该表中的所有行,但表的定义仍在数据字典中,即 <code>delete</code>语句删除的是表中的数据,而不是关于表的定义;</li></ul></li><li><p>可选项 <code>order by</code>子句表示各行将按照子句中指定的顺序进行删除;</p></li><li><p>可选项<code>LIMT</code>子句用于告知服务器在控制命令被返回到客户端前被删除的行的最大值</p></li><li><p>例 4.24 使用 <code>delete</code>语句删除数据库 <code>test_db</code>的表 <code>customers</code>中客户名为"王五&rdquo;
的客户信息</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>delete</span> <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_name<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;王五&#39;</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>03</span> sec)
</span></span></code></pre></div></li></ul><h3 id=443-修改数据>4.4.3 修改数据<a hidden class=anchor aria-hidden=true href=#443-修改数据>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>  <span style=color:#af3a03>update</span> tbl_name
</span></span><span style=display:flex><span>  <span style=color:#b57614>set</span> col_name<span style=color:#af3a03>=</span>{expr1<span style=color:#af3a03>|</span><span style=color:#af3a03>default</span>}[,col_name2<span style=color:#af3a03>=</span>{expr2<span style=color:#af3a03>|</span><span style=color:#af3a03>default</span>}]...
</span></span><span style=display:flex><span>  [<span style=color:#af3a03>where</span> where_condition]
</span></span><span style=display:flex><span>  [<span style=color:#af3a03>order</span> <span style=color:#af3a03>by</span> ...]
</span></span><span style=display:flex><span>  [<span style=color:#af3a03>limit</span> row_count]
</span></span></code></pre></div><ul><li><p><code>tbl name</code>指定要修改的表的名称;</p></li><li><p><code>set</code>子句用于指定表中要修改的列名及其列值, 其中每个指定的列值可以是表达式, 也可以是该列所对应的默认值, 如果指定的是默认值,则用关键字&rdquo; <code>default</code>&ldquo;表示列值;</p></li><li><p>可选项 <code>where</code>子句用于限定表中要修改的行,若不指定此子句,则 <code>update</code>语句会修改表中所有的行;</p></li><li><p>可选项 <code>order by</code>子句用于限定表中的行被修改的次序;</p></li><li><p>可选项<code>limit</code>子句用于限定被修改的行数</p></li><li><p>例 4.25 使用 <code>update</code>语句将数据库 <code>test_db</code>的表 <code>customers</code>中姓名为"张三"的客户的地址更新为"武汉市&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>update</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#b57614>set</span> cust_address<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;南京市&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_name<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;张三&#39;</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><p>更新多个值用 <code>,</code> 分隔; 删除即设置为空;</p></li></ul><h2 id=第五节-数据查询难点>第五节 数据查询(难点)<a hidden class=anchor aria-hidden=true href=#第五节-数据查询难点>#</a></h2><h3 id=451-select-语句>4.5.1 select 语句<a hidden class=anchor aria-hidden=true href=#451-select-语句>#</a></h3><ul><li><p>语法格式</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>select</span>
</span></span><span style=display:flex><span>[<span style=color:#af3a03>ALL</span><span style=color:#af3a03>|</span><span style=color:#af3a03>DISTINCT</span><span style=color:#af3a03>|</span><span style=color:#af3a03>DISTINCTROW</span>]
</span></span><span style=display:flex><span>select_expr[,select_expr ...]
</span></span><span style=display:flex><span><span style=color:#af3a03>from</span> table_refrences
</span></span><span style=display:flex><span>[<span style=color:#af3a03>where</span> where_condition]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span>{col_name<span style=color:#af3a03>|</span>expr<span style=color:#af3a03>|</span>position}
</span></span><span style=display:flex><span> [<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>],... [<span style=color:#af3a03>WITH</span> ROLLUP]]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>having</span> where_condition]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>order</span> <span style=color:#af3a03>by</span> {col_name<span style=color:#af3a03>|</span>expr<span style=color:#af3a03>|</span>position}
</span></span><span style=display:flex><span> [<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>], ...]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>limit</span> {[offset,] row_count<span style=color:#af3a03>|</span>row_count offset offset}]
</span></span></code></pre></div><ul><li><p><code>select</code>子句用于指定输出的字段;</p><ul><li><code>from</code>子句用于指定数据的来源;</li><li><code>where</code>子句用于指定数据的选择条件;</li><li><code>group by</code>子句用于对检索到的记录进行分组;(仅在按组计算聚合时使用)</li><li><code>having</code>子句用于指定组的选择条件;</li><li><code>order by</code>子句用于对查询的结果进行排序</li></ul></li><li><p><code>select</code>子句和<code>from</code>子句是必需的,其他子句都是可选的,并且在<code>select</code>语句的使用中, <strong>所有被添加选用的子句必须依照 <code>select</code> 语句的语法格式所罗列的顺序来使用</strong>,</p><ul><li>例如,一个 <code>having</code>子句必须位于 <code>group by</code>子句之后,并位于 <code>order by</code>子句之前,</li></ul></li><li><p>在 <code>select</code>语句的语法结构中, 三个关键字&rdquo;<code>ALL</code>"" <code>DISTINCT</code>"" <code>DISTINC TROW</code>&ldquo;为可选项,用于指定是否应返回结果集中的重复行;</p></li><li><p>默认为<code>ALL</code>,即 <code>select</code>操作中所有匹配的行,包括可能存在的重复行,都将被返回;</p></li></ul></li></ul><h3 id=452-列的选择与指定>4.5.2 列的选择与指定<a hidden class=anchor aria-hidden=true href=#452-列的选择与指定>#</a></h3><ol><li>选择指定的列<ul><li>若查询列有多个,则列名之间用逗号分隔, 且查询结果次序是依照<code>select</code>语句中指定列的次序给出的;</li><li>若查询所有列, 则可 <code>select *</code></li></ul></li></ol><p>例 4.26 查询数据库 <code>test_db</code>的表 <code>customers</code>中各个客户的姓名、性别和地址信息</p><pre><code> ```mysql
 mysql&gt; select cust_name,cust_sex,cust_address
     -&gt; from test_db.customers;
 ```
</code></pre><p>例 4.27 查询数据库 <code>test_db</code>的表 <code>customers</code>中各个客户的所有信息</p><pre><code> ```mysql
 mysql&gt; select * from test_db.customers;
 ```
</code></pre><ol start=2><li><p>定义并使用列的别名</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>column_name[<span style=color:#af3a03>as</span>]column_alias
</span></span></code></pre></div></li></ol><p>例 4.28 查询数据库 <code>test_db</code>的表 <code>customers</code>中客户的 <code>cust_name</code>、 <code>cust_address</code>和 <code>cust_contact</code>,要求将结果集中 <code>cust_address</code>列的名称使用别名"地址"替代.</p><pre><code> ```mysql
 mysql&gt; select cust_name,cust_address as 地址,cust_contact
     -&gt; from test_db.customers;
 ```
</code></pre><ol start=3><li><p>替换查询结果集中的数据</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>case</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>when</span> 条件<span style=color:#8f3f71>1</span> <span style=color:#af3a03>then</span> 表达式<span style=color:#8f3f71>2</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>when</span> 条件<span style=color:#8f3f71>2</span> <span style=color:#af3a03>then</span> 表达式<span style=color:#8f3f71>2</span>
</span></span><span style=display:flex><span> ...
</span></span><span style=display:flex><span><span style=color:#af3a03>else</span> 表达式
</span></span><span style=display:flex><span>end [<span style=color:#af3a03>as</span>] column_alias
</span></span></code></pre></div></li></ol><p>例 4.29 查询表 <code>customers</code>中客户的 <code>cust_name、cust_sex</code>, 要求判断结果集中 <code>cust_ sex</code>列的值, 如果该列的值为 M, 则显示输出"男&rdquo;, 否则为"女", 同时在结果集的显示中将 <code>cust_sex</code>列用别名"性别"标注</p><pre><code> ```mysql
 mysql&gt; select cust_name,
     -&gt; case
     -&gt; when cust_sex='M' then'男'
     -&gt; else '女'
     -&gt; end as 性别
     -&gt; from test_db.customers;
 ```
</code></pre><ol start=4><li>计算列的值</li></ol><p><strong>例 4.30</strong> 查询数据库 <code>test_db</code>的表 <code>customers</code>中每个客户的 <code>cust_name</code>列、 <code>cust_sex</code>列,以及对 <code>cust_id</code>列加上数字 100 后的值</p><pre><code> ```mysql
 mysql&gt; select cust_name,cust_sex,cust_id+100
     -&gt; from test_db.customers;
 ```
</code></pre><ol start=5><li><p>聚合函数</p><ul><li>select 语句的语法项" <code>select expr</code>&ldquo;也可以指定为聚合函数;</li><li>聚合函数通常是数据库系统中一类系统内置函数,常用于对一组值进行计算,然后返回单个值;</li><li>它通常与 <code>group by</code>子句一起使用,如果 <code>select</code>语句中有一个 <code>group by</code>子句,则这个聚合函数对所有列起作用,如果没有,则 <code>select</code>语句只产生一行作为结果</li><li>除 count 函数外,聚合函数忽略空值</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span>count 求中项数
</span></span><span style=display:flex><span>max 最大值
</span></span><span style=display:flex><span>min 最小值
</span></span><span style=display:flex><span>sum 求和
</span></span><span style=display:flex><span>avg  平均值
</span></span><span style=display:flex><span>std <span style=color:#af3a03>/</span> stddev  返回给定表达式中所有值的标准值
</span></span><span style=display:flex><span>variance 所有值的方差
</span></span><span style=display:flex><span>group_concat  值连接组合而成的结果
</span></span><span style=display:flex><span>bit_and 逻辑或
</span></span><span style=display:flex><span>bir_or 逻辑与
</span></span><span style=display:flex><span>bit_xor 逻辑异或
</span></span></code></pre></div><h3 id=453-from-子句与多表连接查询>4.5.3 from 子句与多表连接查询<a hidden class=anchor aria-hidden=true href=#453-from-子句与多表连接查询>#</a></h3><ol><li><p>交叉连接 cross join</p><ul><li>交叉连接,又称笛卡尔积; 在 MySQL 中,它是通过在<code>from</code>子句中使用关键字&rdquo; <code>CROSS JOIN</code>&ldquo;来连接两张表, 从而实现一张表的每一行与另一张表的每一行的笛卡尔乘积, 并返回两张表的每一行相乘的所有可能的搭配结果, 供 <code>select</code>语句中其他语法元素( 如 <code>where</code>子句、 <code>group by</code>子句等)进行过滤和筛选操作</li></ul></li></ol><p><strong>例 4.31</strong> 假设数据库中有两张表,分别是<code>tbl1</code>和<code>tbl2</code>, 现要求输出这两张表执行交叉联接后的所有数据集</p><pre><code> ```mysql
 mysql&gt; select * from tbl cross join tbl2;
 ```
</code></pre><p>在<code>from</code>子句中也<strong>可以省略关键字 <code>cross join</code></strong>, 而使用逗号分隔交叉联接的两张表</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span> <span style=color:#af3a03>from</span> tbl,tbl2;
</span></span></code></pre></div><ol start=2><li><p>内连接</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>select</span> some_columns <span style=color:#af3a03>from</span> table1 <span style=color:#af3a03>inner</span> GION table2 <span style=color:#af3a03>on</span> some_conditions;
</span></span></code></pre></div><ul><li><p>" <code>some columns</code>&ldquo;用于指定需要检索的列的名称或列别名;</p></li><li><p>" <code>tablel</code>&ldquo;和&rdquo;<code>table2</code>&ldquo;用于指定进行内连接的两张表的表名或表别名;</p></li><li><p><code>on</code>子句通过事先设定的连接条件<code>some conditions</code>&rdquo;, 来指定两张表按什么条件进行连接, 且连接条件中可采用任何一种比较运算符;</p></li><li><p>接条件&rdquo; <code>some conditions</code>&ldquo;一般使用的语法格式是:</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>  [<span style=color:#af3a03>&lt;</span><span style=color:#af3a03>table</span><span style=color:#af3a03>&gt;</span>.]<span style=color:#af3a03>&lt;</span>列名或列别名<span style=color:#af3a03>&gt;&lt;</span>比较运算符<span style=color:#af3a03>&gt;</span>[<span style=color:#af3a03>&lt;</span>table2<span style=color:#af3a03>&gt;</span>.]<span style=color:#af3a03>&lt;</span>列名或列别名<span style=color:#af3a03>&gt;</span>
</span></span></code></pre></div></li><li><p><strong>例 4.32</strong> 根据第二章描述的学生基本信息登记表 <code>tb student</code>和学生成绩表 <code>tb score</code>, 使用内连接查询每个学生及其选课成绩的详细信息;</p><p>由于学生基本信息存储在 <code>tb student</code>表中, 学生选课成绩信息存储在 <code>tb score</code>表中, 所以这个查询涉及两张表, 这两张表之间进行连接的连接条件是两个表中的 <code>studentNo</code>相等</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span><span style=color:#af3a03>*</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> tb_student <span style=color:#af3a03>INNER</span> <span style=color:#af3a03>JOIN</span> tb_score
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>on</span> tb_student.studentNo<span style=color:#af3a03>=</span>tb_score.studentNo;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+--------+-----------+---------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> studentNo <span style=color:#af3a03>|</span> stName <span style=color:#af3a03>|</span> studentNo <span style=color:#af3a03>|</span> stScore <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+--------+-----------+---------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>         <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span> <span style=color:#8f3f71>32</span>     <span style=color:#af3a03>|</span>         <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>99</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+--------+-----------+---------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><ul><li>由于内连接是系统默认的表连接, 因而在<code>from</code>子句中可以省略关键字&rdquo; <code>INNER</code>",而只用关键字&rdquo;<code>JOIN</code>&ldquo;连接表;</li><li>在<code>from</code>子句中,也可以在多个表之间连续使用关键字<code>INNER JOIN</code>&ldquo;或关键字&rdquo;<code>JOIN</code>",如此可以同时实现多个表的内连接;</li></ul></li><li><p>此外,关于内连接的使用,通常有如下三种情形</p><ol><li>等值连接<ul><li>在<code>from</code>子句中使用关键字&rdquo; <code>INNER JOIN</code>&ldquo;或&rdquo;<code>JOIN</code>&ldquo;连接两张表时, 如若<strong>在<code>on</code>子句</strong>的连接条件中使用运算符&rdquo;<code>=</code>"(即等号), 即进行相等性测试, 则此连接方式称为等值连</li></ul></li><li>非等值连接<ul><li>在<code>from</code>子句中使用关键字" <code>INNER JOIN</code>&ldquo;或&rdquo;<code>JOIN</code>&ldquo;连接两张表时, 如若<strong>在<code>on</code>子句</strong>的连接条件中使用除运算符&rdquo;<code>=</code>&ldquo;之外的运算符, 即进行不相等性测试, 则此连接方式称为非等值连接,也称为不等连接</li></ul></li><li>自连接<ul><li>在<code>from</code>子句中使用关键字&rdquo; <code>INNER JOIN</code>&ldquo;或&rdquo;<code>JOIN</code>&ldquo;连接表时, 可以将一个表与它自身进行连接, 这种连接方式称为自连接;</li><li>自连接是一种特殊的内连接, 若需要在一个表中查找具有相同列值的行, 则可以考虑使用自连;</li><li>使用自连接时, 需要为表指定两个不同的别名, 且对所有查询列的引用均必须使用表别名限定, 否则 <code>select</code>操作会失败</li></ul></li></ol></li></ul></li><li><p>外连接</p><ol><li>左外连接<ul><li>左外连接，也称左连接，它的使用语法格式与内连接大致相同，区别仅在于它在<code>from</code>子句中使用关键字&rdquo; <code>LEFT OUTER JOIN</code>&ldquo;或关键字&rdquo; <code>LEFT JOIN</code>&ldquo;来连接两张表，而不是使用关键字&rdquo; <code>INNER JOIN</code>&ldquo;或&rdquo;<code>JOIN</code>"，如此可用于接收关键字" <code>LEFT OUTER JOIN</code>&ldquo;或&rdquo; <code>LEFT JOIN</code>"<strong>左边表（也称为基表）的所有行，并用这些行与该关键字右边表（也称为参考表）</strong> 中的行进行匹配，即匹配左表中的每一行及右表中符合条件的行。</li><li>这种连接方式特别适合当左表与右表具有一对多关系的情形。在左外连接的结果集中除了匹配的行之外，还包括左表中有的，但在右表中不匹配的行，对于这样的行，从右表中被选择的列的值被设置为<code>null</code>; 也就是说，左外连接的结果集中的<code>null</code>值表示右表中没有找到与左表相符的记录</li></ul></li><li>右外连接<ul><li>右外连接，也称右连接，它的使用语法格式与内连接大致相同，区别仅在于它在<code>from</code>子句中使用关键字“ <code>RIGHT OUTER JOIN</code>”或关键字“ <code>RIGHT JOIN</code>”来连接两张表，而不是使用关键字“ <code>INNER JOIN</code>”或“<code>JOIN</code>”</li><li><strong>右外连接是以右表为基表</strong>，其连接方法与左外连接完全一样。在右外连接的结果集中除了匹配的行之外，还包括右表中有的，但在左表中不匹配的行，对于这样的行，从左表中被选择的列的值被设置为<code>null</code></li></ul></li></ol><ul><li><p>例 4.33 根据第二章描述的学生基本信息登记表 <code>tb student</code>和学生成绩表 <code>tb score</code>，使用左外连接查询每个学生及其选课成绩的详细信息</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span><span style=color:#af3a03>*</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> tb_student <span style=color:#af3a03>LEFT</span> <span style=color:#af3a03>JOIN</span> tb_score
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>on</span> tb_student.studentNo<span style=color:#af3a03>=</span>tb_score.studentNo;
</span></span></code></pre></div></li><li><p>在实际使用中，例 4.32 和 例 4.33 的执行结果可能会存在如下两种情形</p><ul><li>返回结果完全一样，这说明 <code>tb student</code>表中不存在未选修任何课程的学生。</li><li>返回结果不一样，即使用内连接只能查询到部分学生的基本登记信息，以及他们所选课程号和对应的成绩，而使用左外连接可以查询到全部学生的基本登记信息，以及部分学生的选课课程号和对应的成绩，且剩余学生的选课课程号和对应的成绩则为<code>null</code>，这说明在 <code>tb student</code>表中存在有学生未选修任何课程。</li><li>因此，尽管有可能对两张表分别使用内连接和外连接之后，所返回的结果相同，但实质上这两类连接的操作语义是不同的，它们的差别在于外连接一定会在结果集中提供数据行，无论该行数据能否在另外一张表中找出相匹配的数据行</li></ul></li></ul></li></ol><h3 id=454-where-子句与条件查询>4.5.4 where 子句与条件查询<a hidden class=anchor aria-hidden=true href=#454-where-子句与条件查询>#</a></h3><ol><li><p>比较运算</p><ul><li><p>比较运算用于比较两个表达式的值。</p><ul><li>其中， MySQL 支持表 44 列出的所有比较运算符。</li><li>当两个表达式的值均不为<code>null</code>时，除了“<code>&lt;=></code>”运算符，其他比较运算返回逻辑值<code>TRUE</code>（真）或 <code>FALSE</code>（假）; 而当两个表达式值中有一个为空值或都为空值时，则将返回 <code>UNKNOWN</code>。</li><li>运算符“<code>&lt;=></code>” 不会出现值为<code>UNKNOWN</code>的情况。</li></ul></li><li><p>例 4.34 在数据库 <code>test_db</code>的表 <code>customers</code>中查找所有男性客户的信息。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span><span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_sex<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;M&#39;</span>;
</span></span></code></pre></div></li></ul></li><li><p>判定范围</p><ol><li><p><code>BETWEEN...AND</code></p><ul><li>查询的过滤条件被限定在值的某个范围, 表达式 <code>expression</code> 的值不能大于表达式 <code>expression2</code>的值, 否则返回 <code>FALSE</code>；如果使用关键字<code>not</code>时，其返回值正好相反</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>  expression [<span style=color:#af3a03>not</span>] <span style=color:#af3a03>BETWEEN</span> expression1 <span style=color:#af3a03>AND</span> expression2
</span></span></code></pre></div><ul><li>例 4.35 在数据库 <code>test_db</code> 的表 <code>customers</code>中，查询客户 id 号在 903 至 912 之间的十个客户的信息。</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span><span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_id <span style=color:#af3a03>BETWEEN</span> <span style=color:#8f3f71>903</span> <span style=color:#af3a03>AND</span> <span style=color:#8f3f71>912</span>;
</span></span></code></pre></div><ol start=2><li><p><code>in</code></p><ul><li>使用关键字“<code>in</code>”可以指定一个值的枚举表，该表中会列出所有可能的值，当要判定的值能与该表中任意一个值匹配时，会返回结果<code>TRUE</code>，否则返回 <code>FALSE</code>, 其使用语法格式是：</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>  expression <span style=color:#af3a03>in</span>(expression[,...])
</span></span></code></pre></div><ul><li><p>例 4.36 在数据库 <code>test_db</code>的表 <code>customers</code>中，查询客户 id 号分别为 903、906 和 908 个客户的信息。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span><span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_id <span style=color:#af3a03>in</span>(<span style=color:#8f3f71>903</span>,<span style=color:#8f3f71>906</span>,<span style=color:#8f3f71>908</span>);
</span></span></code></pre></div></li></ul></li></ol></li><li><p>判定空值</p><ul><li><p>使用关键字“ <code>IS null</code>”</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>expression <span style=color:#af3a03>IS</span>[<span style=color:#af3a03>not</span>]<span style=color:#d3869b>null</span>
</span></span></code></pre></div></li><li><p>例 4.37 在数据库 <code>test_db</code>的表 <code>customers</code>中，查询是否存在没有填写客户联系方式的客户。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> cust_name <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_contact <span style=color:#af3a03>IS</span> <span style=color:#d3869b>null</span>;
</span></span></code></pre></div></li></ul></li><li><p>子查询</p><ul><li>使用 <code>select</code>语句创建子查询<ol><li>表子查询，即子查询返回的结果集是一个表。</li><li>行子查询，即子查询返回的结果集是带有一个或多个值的一行数据。</li><li>列子査询，即子査询返回的结果集是一列数据，该列可以有一行或多行，但每行只有一个值</li><li>标量子查询，即子查询返回的结果集仅仅是一个值。</li></ol></li></ul><ol><li><p>结合关键字使用的子查询</p><ul><li><p>结合关键字“<code>in</code>”所使用的子查询主要用于判定一个给定值是否存在于在子查询的结果集中，其使用语法格式是</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>expression[<span style=color:#af3a03>not</span>]<span style=color:#af3a03>in</span> (subquery)
</span></span></code></pre></div></li><li><p>例 4.38 根据第 2 章描述的学生基本信息登记表 <code>tb student</code>和学生成绩表 <code>tb score</code>，使用子査询的方式查询任意所选课程成绩高于 80 分的学生的学号和姓名信息。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> studentNo,studentName
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> tb_student
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> studentNo <span style=color:#af3a03>in</span> (<span style=color:#af3a03>select</span> studentNo <span style=color:#af3a03>from</span> tb_score <span style=color:#af3a03>where</span> stScore<span style=color:#af3a03>&gt;</span><span style=color:#8f3f71>80</span>);
</span></span></code></pre></div></li></ul></li><li><p>结合比较运算符使用的子查询</p><ul><li><p>结合比较运算符所使用的子査询主要用于将表达式的值与子査询的结果进行比较运算，其使用语法格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>expression{<span style=color:#af3a03>=|&lt;|&lt;=|&gt;|&gt;=|&lt;&gt;|!=</span>}{<span style=color:#af3a03>ALL</span><span style=color:#af3a03>|</span>SOME<span style=color:#af3a03>|</span>ANY}{subquery}
</span></span></code></pre></div></li><li><p>在此语法中：三个关键字“<code>ALL</code>”“<code>SOME</code>”或“<code>ANY</code>”为选择项，用于指定对比较运算的限制。</p><ul><li>其中，关键字“ALL”用于指定表达式需要与子查询结果集中的每个值都进行比较，当表达式与每个值都满足比较关系时，会返回 TRUE，否则返回 FALSE；</li><li>关键字“SOME”和“ANY”是同义词，表示表达式只要与子查询结果集中的某个值满足比较关系时，就返回 TRUE，否则返回 FALSE。</li></ul></li></ul></li><li><p>结合关键字“ <code>EXIST</code>”使用的子查询</p><ul><li><p>结合关键字“ <code>EXIST</code>”所使用的子查询主要用于判定子查询的结果集是否为空, 否则返回 FALSE。它的使用语法格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#b57614>EXIST</span>(subquery)
</span></span></code></pre></div></li></ul></li></ol></li></ol><h3 id=455-group-by-子句与分组查询>4.5.5 group by 子句与分组查询<a hidden class=anchor aria-hidden=true href=#455-group-by-子句与分组查询>#</a></h3><ul><li><p>在 <code>select</code>语句中，允许使用 <code>group by</code>子句，<strong>将结果集中的数据行根据选择列的值逻辑分组，以便能汇总表内容的子集，即实现对每个组的聚集计算。</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span>{col_name<span style=color:#af3a03>|</span>expr<span style=color:#af3a03>|</span>position}{<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>},...[<span style=color:#af3a03>WITH</span> ROLLUP]
</span></span></code></pre></div><ol><li><code>col name</code>：指定用于分组的选择列。<ul><li>可以指定多个列，彼此间用逗号分隔。注意， <code>group by</code>子句中的各选择列必须也是 <code>select</code>语句的选择列表清单中的一项。</li></ul></li><li><code>expr</code>：指定用于分组的表达式。<ul><li>该表达式通常与聚合函数一块使用，例如可将表达式“ <code>COUNT（*）AS '人数'</code>”作为 <code>select</code>语句的选择列表清单中的一项</li></ul></li><li><code>position</code>：指定用于分组的选择列在 <code>select</code>语句结果集中的位置，通常是一个正整数。<ul><li>例如，使用 <code>group by 3</code>表示根据 <code>select</code>语句中列清单上的第 3 列的值进行逻辑分组。</li></ul></li><li><code>asc|desc</code>：关键字“<code>asc</code>”表示按升序分组；关键字“<code>desc</code>”表示按降序分组。<ul><li>其中，默认值为 ASC。这两个关键字必须位于对应的列名、表达式、列的位置之后。</li></ul></li><li><strong><code>WITH ROLLUP</code>：此关键字为可选项，用于指定在结果集中不仅包含由 <code>group by</code>子句分组后的数据行，还包含各分组的汇总行，以及所有分组的整体汇总行。</strong><ul><li>因此，使用该关键字，可以得到每个分组以及每个分组汇总级别的值。</li><li>其汇总规则是：按列的排列的逆序依次进行汇总，并且在生成的同一逻辑组的汇总行中，对于具有不同列值的字段值将被设置为 NULL。</li></ul></li></ol></li><li><p>例 4.39 在数据库 <code>test_db</code>的表 <code>customers</code>中获取一个数据结果集，要求该结果集中分别包含每个相同地址的男性客户人数和女性客户人数。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> cust_address,cust_sex,<span style=color:#b57614>count</span>(<span style=color:#af3a03>*</span>) <span style=color:#af3a03>as</span> <span style=color:#79740e>&#39;人数&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span> cust_address,cust_sex;
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_address <span style=color:#af3a03>|</span> cust_sex <span style=color:#af3a03>|</span>  人数   <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 南京市        <span style=color:#af3a03>|</span> F        <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>         <span style=color:#af3a03>|</span> M        <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 武汉市        <span style=color:#af3a03>|</span> M        <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>3</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>05</span> sec)
</span></span></code></pre></div></li><li><p>例 4.40 在数据库 <code>test_db</code>的表 <code>customers</code>中获取一个数据结果集，要求该结果集中包含每个相同地址的男性客户人数、女性客户人数、总人数以及客户的总人数</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> cust_address,cust_sex,<span style=color:#b57614>count</span>(<span style=color:#af3a03>*</span>)<span style=color:#af3a03>as</span><span style=color:#79740e>&#39;人数&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span> cust_address,cust_sex
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>WITH</span> ROLLUP;
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_address <span style=color:#af3a03>|</span> cust_sex <span style=color:#af3a03>|</span> 人数   <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>         <span style=color:#af3a03>|</span> M        <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>         <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>     <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 南京市        <span style=color:#af3a03>|</span> F        <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>3</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 南京市        <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>     <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>3</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 武汉市        <span style=color:#af3a03>|</span> M        <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>2</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 武汉市        <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>     <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>2</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>         <span style=color:#af3a03>|</span> <span style=color:#d3869b>null</span>     <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>6</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>7</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>03</span> sec)
</span></span></code></pre></div></li><li><p>此外，对于 <code>group by</code>子句的使用，需要注意以下几点。</p><ol><li><code>group by</code>子句可以包含任意数目的列，使得其可对分组进行嵌套，为数据分组提供更加细致的控制。</li><li>如果在 <code>group by</code>子句中嵌套了分组，那么将按 <code>group by</code>子句中列的排列顺序的逆序方式依次进行汇总，并将在最后规定的分组上进行一个完全汇总。</li><li><code>group by</code>子句中列出的每个列都必须是检索列或有效的表达式，但不能是聚合函数。如果在 <code>select</code>语句中使用表达式，则必须在 <code>group by</code>子句中指定相同的表达式。注意，不能使用别名</li><li>除聚合函数之外， <code>select</code>语句中的每个列都必须在 <code>group by</code>子句中给出。</li><li>如果用于分组的列中含有<code>null</code>值，则<code>null</code>将作为一个单独的分组返回；如果该列中存在多个<code>null</code>值，则将这些<code>null</code>值所在的行分为一组。</li></ol></li></ul><h3 id=456-having-子句>4.5.6 having 子句<a hidden class=anchor aria-hidden=true href=#456-having-子句>#</a></h3><ul><li><p>在结果集中规定包含哪些分组和排除哪些分组。</p></li><li><p><code>having</code>子句的使用语法格式是</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>having</span> where_condition
</span></span></code></pre></div></li><li><p><code>having</code>子句与 <code>where</code>子句非常相似， <code>having</code>子句支持 <code>where</code>子句中所有的操作符和句法，但两者之间仍存在以下几点差异</p><ol><li><strong><code>where</code>子句主要用于过滤数据行，而 <code>having</code>子句主要用于过滤分组</strong>，即<code>having</code>子句可基于分组的聚合值而不是特定行的值来过滤数据。</li><li><strong><code>having</code>子句中的条件可以包含聚合函数，而 <code>where</code>子句中则不可以</strong>。</li><li><strong><code>where</code>子句会在数据分组前进行过滤， <code>having</code>子句则会在数据分组后进行过滤</strong>。因而， <code>where</code>子句排除的行不包含在分组中，这就会可能改变计算值，从而影<code>having</code>子句基于这些值过滤掉的分组。</li></ol></li><li><p>例 4.41 在数据库 <code>test_db</code>的表 <code>customers</code>中查找这样一类客户信息：要求在返回的果集中，列出相同客户地址中满足客户人数少于 3 的所有客户姓名及其对应地址。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> cust_name,cust_address
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span> cust_address,cust_name
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>having</span> <span style=color:#b57614>count</span>(<span style=color:#af3a03>*</span>)<span style=color:#af3a03>&lt;=</span><span style=color:#8f3f71>3</span>;
</span></span></code></pre></div></li></ul><h3 id=457-order-by-子句>4.5.7 order by 子句<a hidden class=anchor aria-hidden=true href=#457-order-by-子句>#</a></h3><ul><li><p>可以使用 order BY 子句将结果集中的数据行按一定的顺序进行排列</p></li><li><p>order BY 子句的使用语法格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>order</span> <span style=color:#af3a03>by</span> {col_name<span style=color:#af3a03>|</span>expr<span style=color:#af3a03>|</span>position}[<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>],...
</span></span><span style=display:flex><span><span style=color:#af3a03>order</span> <span style=color:#af3a03>by</span> cust_name <span style=color:#af3a03>desc</span>,cust_address <span style=color:#af3a03>desc</span>;
</span></span></code></pre></div><ul><li><code>col name</code>：指定用于排序的列。可以同时指定多个列，列名彼此间用逗号分隔。</li><li><code>expr</code>：指定用于排序的表达式。</li><li><code>position</code>：指定用于排序的列在 <code>select</code>语句结果集中的位置，通常是一个正整数例如，使用 <code>order by 2</code>表示对 <code>select</code>语句中列清单上的第 2 列进行排序。</li><li><code>asc|desc</code>：关键字“<code>asc</code>”表示按升序排列；关键字“<code>desc</code>”表示按降序排列。其中，默认值为<code>asc</code>。这两个关键字必须位于对应的列名、表达式、列的位置之后。</li></ul></li><li><p>例 4.42 在数据库 <code>test_db</code>的表 <code>customers</code>中依次按照客户姓名和地址的降序方式输出客户的姓名和性别。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> cust_name,cust_sex <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>order</span> <span style=color:#af3a03>by</span> cust_name <span style=color:#af3a03>desc</span>,cust_address <span style=color:#af3a03>desc</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_name <span style=color:#af3a03>|</span> cust_sex <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 张三      <span style=color:#af3a03>|</span> F        <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 王五      <span style=color:#af3a03>|</span> F        <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 王五      <span style=color:#af3a03>|</span> F        <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 王六      <span style=color:#af3a03>|</span> M        <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 李四      <span style=color:#af3a03>|</span> M        <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 李四      <span style=color:#af3a03>|</span> M        <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>6</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div></li><li><p>此外，关于 <code>order by</code>子句的使用，需要注意以下几点。</p><ol><li><code>order by</code>子句中可以包含子查询。</li><li>当对空值进行排序时， <code>order by</code>子句会将该空值作为最小值来对待。即，若按升序排列结果集，则 <code>order by</code>子句会将该空值所在的数据行置于结果集的最上方；若是使用降序排序，则会将其置于结果集的最下方</li><li>若在 <code>order by</code>子句中指定多个列进行排序，则在 MySQL 中会按照这些列从左至右所罗列的次序依次进行排序。</li><li>在使用 <code>group by</code>子句时，通常也会同时使用 <code>order by</code>子句。</li></ol></li></ul><h3 id=458-limit-子句>4.5.8 limit 子句<a hidden class=anchor aria-hidden=true href=#458-limit-子句>#</a></h3><ul><li><p>可以使用 LIMIT 子句来限制被 <code>select</code>语句返回的行数。</p></li><li><p><code>LIMIT</code>子句的使用语法格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>limit</span> {[offset,] row_count<span style=color:#af3a03>|</span>row_count offset offset}
</span></span></code></pre></div><ol><li><code>offset</code>：为可选项，默认为数字 0，用于指定返回数据的第一行在 <code>select</code>语句结果集中的偏移量，其必须是非负的整数常量。注意， <code>select</code>语句结果集中第一行（初始行）的偏移量为 0 而不是 1。</li><li><code>row count</code>：用于指定返回数据的行数，其也必须是非负的整数常量。若这个指定行数大于实际能返回的行数时，在 MySQL 中将只返回它能返回的数据行。</li><li><code>row count offset offset</code>：从第 <code>offset+1</code>行开始，取 <code>row count</code>行。</li></ol></li><li><p>例 443 在数据库 <code>test_db</code>的表 <code>customers</code>中查找从第 5 位客户开始的 3 位客户的 id 号 和姓名信息。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> cust_id,cust_name <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>order</span> <span style=color:#af3a03>by</span> cust_id
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>limit</span> <span style=color:#8f3f71>4</span>,<span style=color:#8f3f71>3</span>; <span style=color:#928374;font-style:italic>#也可以写成 limit 3 offset 4;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>+---------+-----------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_id <span style=color:#af3a03>|</span> cust_name <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+---------+-----------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>     <span style=color:#8f3f71>906</span> <span style=color:#af3a03>|</span> 王五      <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>     <span style=color:#8f3f71>907</span> <span style=color:#af3a03>|</span> 王六      <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+---------+-----------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>2</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div></li></ul><h2 id=第六节-视图>第六节 视图<a hidden class=anchor aria-hidden=true href=#第六节-视图>#</a></h2><ul><li>视图是数据库中的一个对象，它是数据库管理系统提供给用户的以多种角度观察数据库中数据的一种重要机制。视图是从一个或多个表或者其他视图中通过查询语句导出的表，它也包含一系列带有名称的数据列和若干条数据行，并有自己的视图名，由此可见视图与基本表十分类似。然而，视图仍不同于数据库中真实存在的基本表，它们存在以下区别。<ol><li><strong>视图不是数据库中真实的表，而是一张虚拟表</strong>，其结构和数据是建立在对数据库中真实表的查询基础上的。</li><li>视图的内容是由存储在数据库中进行查询操作的 SQL 语句来定义的，它的列数据与行数据均来自于定义视图的查询所引用的真实表，并且这些数据是在引用视图时动态生成的</li><li>视图不是以数据集的形式存储在数据库中，它所对应的数据实际上是存储在视图所引用的真实表（基本表）中。</li><li><strong>视图是用来查看存储在别处的数据的一种虚拟表，而其自身并不存储数据</strong>。
尽管视图与数据库中的基本表存在着本质上的不同，但视图一经定义后，可以如同使用基本表一样，对视图进行查询、修改、删除和更新等操作，并且使用视图还具有如下一些优点。</li><li>集中分散数据。当用户所需的数据分散在数据库多个表中时，通过定义视图可以将这些数据集中在一起，以方使用户对分散数据的集中查询与处理。</li><li>简化查询语句。通过定义视图可为用户屏蔽数据库的复杂性，使其不必详细了解数据库中复杂的表结构和表连接，因而能简化用户对数据库的查询语句。例如，即便是底层数据库表发生了更改，也不会影响到上层用户对数据库的正常使用，只需数据库编程人员重新定义视图的内容即可。</li><li>重用 SQL 语句。视图提供的是一种对查询操作的封装，它本身不包含数据，其所呈现的数据是根据视图的定义从基本表中检索出来的，如若基本表中的数据被新增或更改，视图所呈现的则是更新后的数据。因此，通过定义视图，编写完所需查询后，可以方便地重用该视图，而不必了解它的具体查询细节。</li><li>保护数据安全。通过只授予用户使用视图的权限，而不具体指定使用表的权限，来保护基础数据的安全性。</li><li>共享所需数据。通过使用视图，每个用户不必都定义和存储自己所需的数据，可以共享数据库中的数据，从而同样的数据只需存储一次。
更改数据格式。通过使用视图，可以重新格式化检索出的数据，并组织输出到其他应用程序中去</li></ol></li></ul><h3 id=461-创建视图>4.6.1 创建视图<a hidden class=anchor aria-hidden=true href=#461-创建视图>#</a></h3><ul><li><p>使用 <code>CREATE VIEW</code>语句来创建视图</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>CREATE</span> VIEW view_name[(column_list)]
</span></span><span style=display:flex><span> <span style=color:#af3a03>as</span> select_statement
</span></span><span style=display:flex><span> [<span style=color:#af3a03>WITH</span>[CASCADED<span style=color:#af3a03>|</span>LOCAL]<span style=color:#af3a03>CHECK</span> <span style=color:#af3a03>OPTION</span>]
</span></span></code></pre></div><ol><li><code>view name</code>用于指定视图的名称，且该名称在数据库中必须是唯一的，<strong>不能与其他表或视图同名</strong>。</li><li><code>column list</code>是可选项，用于为视图中的每个列指定明确的名称，且列名的数目必须等于 <code>select</code>语句检索出的结果数据集的列数，同时每个列名间用逗号分隔。如若省略<code>column list</code>，则新建视图使用与基本表或源视图中相同的列名</li><li><code>select statement</code>用于指定创建视图的 <code>select</code>语句。这个 <code>select</code>语句给出了视图的定义，它可用于查询多个基本表或源视图</li><li><code>WITH CHECK OPTION</code>是可选项，用于指定在可更新视图上所进行的修改都需要符合 <code>select statement</code>中所指定的限制条件，这样可以确保数据修改后，仍可以通过视图看到修改后的数据。当视图是根据另一个视图定义时，关键字“ <code>WITH CHECK OPTION</code>”给出两个参数，即 <code>CASCADED</code>和 <code>LOCAL</code>，它们决定检查测试的范围。其中，关键字“ <code>CASCADED</code>”为选项默认值，它会对所有视图进行检查，而关键字“ <code>LOCAL</code>”则使 <code>CHECK OPTION</code>只对定义的视图进行检查。</li></ol></li><li><p>例 4.44 在数据库 <code>mysql test中</code>创建视图 <code>customers view</code>，要求该视图包含客户信息表<code>customers</code>中所有男客户的信息，并且要求保证今后对该视图数据的修改都必须符合客户性别为男性这个条件。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> VIEW customers_view
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>as</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span><span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_sex<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;M&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>WITH</span> <span style=color:#af3a03>CHECK</span> <span style=color:#af3a03>OPTION</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>03</span> sec)
</span></span></code></pre></div></li></ul><h3 id=462-删除视图>4.6.2 删除视图<a hidden class=anchor aria-hidden=true href=#462-删除视图>#</a></h3><ul><li><p>使用 <code>drop VIEW</code>语句来删除视图</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>DROPVIEW view_name[(cloumn_list)]
</span></span><span style=display:flex><span> <span style=color:#af3a03>as</span> select_statement
</span></span><span style=display:flex><span> [<span style=color:#af3a03>WITH</span>[CASCADED<span style=color:#af3a03>|</span>LOCAL]<span style=color:#af3a03>CHECK</span> <span style=color:#af3a03>OPTION</span>]
</span></span></code></pre></div></li></ul><h3 id=463-修改视图定义>4.6.3 修改视图定义<a hidden class=anchor aria-hidden=true href=#463-修改视图定义>#</a></h3><ul><li><p>使用 <code>alter VIEW</code>语句来对已有视图的定义（结构）进行修改</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>ALTERVIEW view_name[(column_list)]
</span></span><span style=display:flex><span> <span style=color:#af3a03>as</span> select_statement
</span></span><span style=display:flex><span> [<span style=color:#af3a03>WITH</span>[CASCADED<span style=color:#af3a03>|</span>LOCAL]<span style=color:#af3a03>CHECK</span> <span style=color:#af3a03>OPTION</span>]
</span></span></code></pre></div></li></ul><h3 id=464-查看视图定义>4.6.4 查看视图定义<a hidden class=anchor aria-hidden=true href=#464-查看视图定义>#</a></h3><ul><li><p>使用 <code>show create VIEW</code>语句来查看已有视图的定义（结构）</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>show</span> <span style=color:#af3a03>create</span> VIEW view_name
</span></span></code></pre></div></li></ul><h3 id=465-更新视图数据>4.6.5 更新视图数据<a hidden class=anchor aria-hidden=true href=#465-更新视图数据>#</a></h3><ol><li><p>使用 <code>insert</code>语句通过视图向基本表插入数据</p><ul><li><p>例 4.45 在数据库 <code>test_db</code>中，向视图 <code>customers view</code>插入下面一条记录</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> test_db.customers_view
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>0</span>,<span style=color:#79740e>&#39;周敏&#39;</span>,<span style=color:#79740e>&#39;M&#39;</span>,<span style=color:#79740e>&#39;武汉市&#39;</span>,<span style=color:#79740e>&#39;洪山区&#39;</span>,<span style=color:#d3869b>null</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div></li></ul></li><li><p>使用 <code>update</code>语句通过视图修改基本表的数据</p><ul><li><p>例 4.46 将视图 <code>customers vicw</code>中所有客户的 <code>cust address</code>列到更新为“上海市”。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>update</span> test_db.customers_view
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#b57614>set</span> cust_address<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;上海市&#39;</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>4</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div></li></ul></li><li><p>使用 <code>delete</code>语句通过视图删除基本表的数据</p><ul><li><p>例 4.47 删除视图 <code>customers view</code>中姓名为“周明”的客户信息。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>delete</span> <span style=color:#af3a03>from</span> test_db.customers_view
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_name<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;周敏&#39;</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div></li></ul></li></ol><h3 id=466-查询视图数据>4.6.6 查询视图数据<a hidden class=anchor aria-hidden=true href=#466-查询视图数据>#</a></h3><ul><li><p>例 4.48 在视图 <code>customers view</code>中查找客户 id 号为 905 的客户姓名及其地址信息</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> cust_name,cust_address
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> test_db.customers_view
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_id<span style=color:#af3a03>=</span><span style=color:#8f3f71>904</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+--------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> cust_name <span style=color:#af3a03>|</span> cust_address <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+--------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 李四      <span style=color:#af3a03>|</span> 上海市       <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+--------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div></li></ul><p>由于视图是一个虚拟表，所以通过插入、修改和删除等操作方法来更新视图中的数据，实质上是在更新视图所引用的基本表中的数据。</p><h1 id=第五章-数据库编程>第五章 数据库编程<a hidden class=anchor aria-hidden=true href=#第五章-数据库编程>#</a></h1><h2 id=第一节-数据库编程>第一节 数据库编程<a hidden class=anchor aria-hidden=true href=#第一节-数据库编程>#</a></h2><h3 id=511-存储过程的基本概念>5.1.1 存储过程的基本概念<a hidden class=anchor aria-hidden=true href=#511-存储过程的基本概念>#</a></h3><ul><li>存储过程是一组为了完成某项特定功能的SQL语句集，其本质是一段存储在数据库中的代码。</li><li>存储过程可由<strong>声明式sql语句</strong>和<strong>过程式sql语句</strong>组成。</li><li>使用存储过程通常具有以下一些好处：<ol><li><strong>可增强 SQL 语言的功能和灵活性</strong>，存储过程可以用流控制语句编写，有很强的<strong>灵活性</strong>，可以完成复杂的判断和较复杂的运算。</li><li><strong>良好的封装性</strong>，存储**过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码</li><li><strong>高性能</strong>，存储过程执行一次后，其执行规划就驻留在高速缓冲存储器中，在以后的操作中，只需从高速缓冲存储器中调用已编译好的二进制代码执行即可，从而<strong>提高了系统性能</strong>。</li><li><strong>可减少网络流量</strong>，由于存储过程是在服务器端运行，且执行速度快，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载</li><li><strong>存储过程可作为一种安全机制来确保数据库的安全性和数据的完整性</strong>，使用存储过程可以完成所有数据库操作，并可通过编程方式控制这些数据库操作对数据库信息访问的权限。</li></ol></li></ul><h3 id=512-创建存储过程>5.1.2 创建存储过程<a hidden class=anchor aria-hidden=true href=#512-创建存储过程>#</a></h3><ul><li><p><code>delimiter</code>命令的使用语法格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>delimiter $$
</span></span></code></pre></div><ul><li>其中，<code>$$</code>是用户定义的结束符，通常这个符号可以是一些特殊的符号，例如两个“<code>#</code>”或两个“<code>￥</code>”等；</li><li>另外，当使用 <code>delimiter</code>命令时，应该避免使用反斜杠（“<code>/</code>”）字符，因为它是 <code>MySQL</code>的转义字符。</li></ul></li><li><p>例 5.1 将 <code>MySQL</code>结束符修改为两个感叹号“<code>!!</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>delimiter <span style=color:#af3a03>!!</span>
</span></span></code></pre></div><p>换回默认的分号“<code>；</code>”作为结束标志</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>delimiter ;
</span></span></code></pre></div></li><li><p>使用 <code>create procedure</code>语句来创建存储过程</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>procedure</span> <span style=color:#b57614>sp_name</span>([proc_apramenter[,...]])
</span></span><span style=display:flex><span> routine_body
</span></span></code></pre></div><p>语法项“ <code>proc parameter</code>”的语法格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>[<span style=color:#af3a03>in</span><span style=color:#af3a03>|</span><span style=color:#af3a03>OUT</span><span style=color:#af3a03>|</span><span style=color:#af3a03>INOUT</span>] param_name type
</span></span></code></pre></div><ol><li>语法项“ <code>sp name</code>”用于指定存储过程的名称，且默认在当前数据库中创建。</li><li>语法项“ <code>proc parameter</code>”用于指定存储过程的参数列表。<ol><li>其中，语法项“ <code>param name</code>”为参数名，语法项“<code>type</code>”为参数的类型（其可以是任何有效的 MySQL 数据类型）。</li><li>当有多个参数时，参数列表中彼此间用逗号分隔。存储过程可以没有参数（此时存储过程的名称后仍须加上一对括号），也可以有一个或多个参数。</li><li>MySQL 存储过程支持三种类型的参数，即<strong>输入参数、输出参数和输入/输出参数，分用“<code>in</code>”“<code>OUT</code>”和“ <code>INOUT</code>”三个关键字标识</strong>。其中，输入参数是使数据可以传递给一个存储过程；输出参数用于存储过程需要返回一个操作结果的情形；而输入输出参数既可以充当输入参数也可以充当输出参数。</li><li>需要注意的是，参数的取名不要与数据表的列名相同，否则尽管不会返回出错消息，但是存储过程中的 SQL 语句会将参数名看作是列名，从而引发不可预知的结果。</li></ol></li><li><strong>语法项“ <code>routine body</code>”表示存储过程的主体部分，也称为存储过程体</strong>，其包含了在过程调用的时候必须执行的 SQL 语句。<ol><li>这个部分是以关键字“ <code>BEGIN</code>”开始，以关键字“<code>END</code>”结束。</li><li>如若存储过程体中只有一条 SQL 语句时，可以省略 <code>BEGIN…END</code>标志。</li><li>另外，在存储过程体中，<code>BEGN…END</code>复合语句还可以嵌套使用。</li></ol></li></ol></li><li><p>例 5.2 在数据库 <code>test_db</code>中创建一个存储过程，用于实现给定表 <code>customers</code>中一个客户 id 号即可修改表 <code>customers</code>中该客户的性别为一个指定的性别。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> delimiter $$
</span></span><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>procedure</span> <span style=color:#b57614>sp_update_sex</span>(<span style=color:#af3a03>in</span> cid <span style=color:#b57614>INT</span>,<span style=color:#af3a03>in</span> csex <span style=color:#b57614>char</span>(<span style=color:#8f3f71>1</span>))
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> BEGIN
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span>  <span style=color:#af3a03>update</span> customers <span style=color:#b57614>set</span> cust_sex<span style=color:#af3a03>=</span>csex <span style=color:#af3a03>where</span> cust_id<span style=color:#af3a03>=</span>cid;
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> END $$
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>09</span> sec)
</span></span></code></pre></div></li></ul><h3 id=513-存储过程体>5.1.3 存储过程体<a hidden class=anchor aria-hidden=true href=#513-存储过程体>#</a></h3><ol><li><p>局部变量</p><ul><li><p><strong>使用 <code>declare</code>语句来声明局部变量</strong>，并且同时还可以对该局部变量赋予一个初始值</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>declare</span> var_name[,...]type[<span style=color:#af3a03>default</span> value]
</span></span></code></pre></div><ul><li>语法项“ <code>var name</code>”用于指定局部变量的名称；语法项“<code>type</code>”用于声明局部变量的数据类型； <code>default</code>子句用于为局部变量指定一个默认值，若没有指定，则默认为<code>null</code></li></ul></li><li><p>例 5.3 声明一个整型局部变量<code>cid</code>。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>declare</span> cid <span style=color:#b57614>INT</span>(<span style=color:#8f3f71>10</span>)
</span></span></code></pre></div><ol><li>局部变量<strong>只能在存储过程体的 <code>BEGIN…END</code>语句块中声明</strong>。</li><li>局部变量<strong>必须在存储过程体的开头处声明</strong>。</li><li>局部变量的<strong>作用范围仅限于声明它的<code>BEGN…END</code>语句块</strong>，其他语句块中的语句不可以使用它。</li><li>局部变量不同于用户变量，两者间的区别是：<strong>局部变量声明时，在其前面没有使用<code>@</code>符号</strong>，并且它只能被声明它的 <code>BEGIN…END</code>语句块中的语句所使用；而<strong>用户变量在声明时，会在其名称前面使用<code>@</code>符号，同时已声明的用户变量存在于整个会话之中。</strong></li></ol></li></ul></li><li><p><code>set</code> 语句</p><ul><li><p><strong>使用 set 语句为局部变量赋值</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#b57614>set</span> var_name<span style=color:#af3a03>=</span>expr[,var_name<span style=color:#af3a03>=</span>expr]...
</span></span></code></pre></div></li><li><p>例 5.4 为 例 5.3 中声明的局部变量<code>cid</code>赋予一个整数值 910</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#b57614>set</span> cid<span style=color:#af3a03>=</span><span style=color:#8f3f71>910</span>;
</span></span></code></pre></div></li></ul></li><li><p><code>SELECT…INTO</code> 语句</p><ul><li><p><strong>使用 <code>SELECT…INTO</code>语句把选定列的值直接存储到局部变量中</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>select</span> col_name[,...]<span style=color:#af3a03>into</span> var_name[,...] table_expr
</span></span></code></pre></div><ul><li>语法项“ <code>col name</code>”用于指定列名；语法项“ <code>var name</code>”用于指定要赋值的变量名；</li><li>语法项“ &lsquo;<code>table expr</code>”表示 <code>select</code>语句中的<code>from</code>子句及后面的语法部分。</li><li>此外，需要注意的是：存储过程体中的 <code>SELECT…INTO</code>语句返回的结果集只能有一行数据</li></ul></li></ul></li><li><p>流程控制语句</p><ol><li>条件判断语句<ul><li>常用的条件判断语句有<code>IF…THEN…ELSE</code>语句和<code>case</code>语句。它们的使用语法及方式类似于高级程序设计语言</li></ul></li></ol></li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>if</span> 条件 <span style=color:#af3a03>then</span> 表达式<span style=color:#8f3f71>1</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>else</span> 表达式<span style=color:#8f3f71>2</span>
</span></span><span style=display:flex><span>end <span style=color:#af3a03>if</span>;
</span></span></code></pre></div><ol start=2><li><p>循环语句</p><ul><li>常用的循环语句有<code>WHLE</code>语句、 <code>REPEAT</code>语句和<code>LOOP</code>语句。</li><li>while 条件表达式 END while</li><li>repeat 表达式 END repeat</li><li>loop 表达式 END loop</li></ul></li><li><p>游标</p></li></ol><p><strong>游标是一个被 <code>select</code>语句检索出来的结果集</strong>。在存储游标后，游标相当于一个指针，它指向当前的一行数据。游标只能用于存储过程或存储函数，不能单独在查询操作中使用。</p><ol><li><p>声明游标, 使用 <code>declare CURSOR</code>语句创建游标</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>declare</span> cursor_name <span style=color:#af3a03>CURSOR</span> <span style=color:#af3a03>FOR</span> select_statement
</span></span></code></pre></div><ul><li>“ <code>cursor name</code>”用于指定要创建的游标的名称，其命名规则与表名相同</li><li>“ <code>select statement</code>”用于指定一个 <code>select</code>语句，其会返回一行或多行的数据，且需注意此处的 <code>select</code>语句不能有<code>into</code>子句。</li></ul></li><li><p>打开游标</p><p>在定义游标之后，必须打开该游标，才能使用。这个过程实际上是将游标连接到由<code>select</code>语句返回的结果集中。在 MSQL 中，可以使用 <code>open</code> 语句打开游标</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>open cursor_name
</span></span></code></pre></div><ul><li>“ <code>cursor name</code>”用于指定要打开的游标在实际应用中，</li><li>一个游标可以被多次打开，由于其他用户或应用程序可能随时更新了数据表，因此每次打开游标的结果集可能会不同。</li></ul></li><li><p>读取数据</p><p>对于填有数据的游标，可根据需要取出数据。在 MySQL 中，可以使用 <code>FETCH…INTO</code>语句从中读取数据</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>FETCH</span> cursor_name <span style=color:#af3a03>into</span> var_name[,var_name]...
</span></span></code></pre></div><ul><li>“ <code>cursor name</code>”用于指定已打开的游标；语法项“ <code>var name</code>”用于指定存放数据的变量名。</li><li><code>FETCH…NTO</code>语句与 <code>SELECT…INTO</code>语句具有相同的意义， <code>FETCH</code>语句是将游标指向的一行数据赋给一些变量，这些变量的数目必须等于声明游标时 <code>select</code>子句中选择列的数目。</li><li>游标相当于一个指针，它指向当前的一行数据。</li></ul></li><li><p>关闭游标</p><p>在结束游标使用时，必须关闭游标。在 MySQL 中，可以使用 close 语句关闭游标</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>close cursor_name
</span></span></code></pre></div><ul><li>“<code>cursor name</code>”用于要关闭的游标。</li><li>每个游标不再需要时都应该被关闭，使用 <code>close</code>语句将会释放游标所使用的全部资源。</li><li>在一个游标被关闭后，如果没有重新被打开，则不能被使用。</li><li>对于声明过的游标，则不需要再次声明，可直接使用<code>open</code>语句打开。</li><li>另外，如果没有明确关闭游标， <code>MySQL</code>将会在到达<code>END</code>语句时自动关闭它</li></ul></li></ol><ul><li><p>例 5.5 在数据库 <code>test_db</code>中创建一个存储过程，用于计算表 <code>customers</code>中数据行的行数</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>use</span> test_db;
</span></span><span style=display:flex><span>delimiter $$
</span></span><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>procedure</span> <span style=color:#b57614>sp_sumofrow</span>(<span style=color:#af3a03>OUT</span> ROWS2 <span style=color:#b57614>INT</span>)
</span></span><span style=display:flex><span>BEGIN
</span></span><span style=display:flex><span>  <span style=color:#af3a03>declare</span> cid <span style=color:#b57614>INT</span>;
</span></span><span style=display:flex><span>  <span style=color:#af3a03>declare</span> FOUND BOOLEAN <span style=color:#af3a03>default</span> <span style=color:#d3869b>TRUE</span>;
</span></span><span style=display:flex><span>  <span style=color:#af3a03>declare</span> cur_cid <span style=color:#af3a03>CURSOR</span> <span style=color:#af3a03>FOR</span>
</span></span><span style=display:flex><span>   <span style=color:#af3a03>select</span> cust_id <span style=color:#af3a03>from</span> customers;
</span></span><span style=display:flex><span>  <span style=color:#af3a03>declare</span> <span style=color:#af3a03>CONTINUE</span> HANDLER <span style=color:#af3a03>FOR</span> <span style=color:#af3a03>not</span> FOUND
</span></span><span style=display:flex><span>   <span style=color:#b57614>set</span> FOUND<span style=color:#af3a03>=</span><span style=color:#d3869b>FALSE</span>;
</span></span><span style=display:flex><span>   <span style=color:#b57614>set</span> ROWS2<span style=color:#af3a03>=</span><span style=color:#8f3f71>0</span>;
</span></span><span style=display:flex><span>  open cur_cid;
</span></span><span style=display:flex><span>  <span style=color:#af3a03>FETCH</span> cur_cid <span style=color:#af3a03>into</span> cid;
</span></span><span style=display:flex><span>  <span style=color:#af3a03>WHILE</span> FOUND DO
</span></span><span style=display:flex><span>   <span style=color:#b57614>set</span> ROWS2<span style=color:#af3a03>=</span>ROWS2<span style=color:#af3a03>+</span><span style=color:#8f3f71>1</span>;
</span></span><span style=display:flex><span>   <span style=color:#af3a03>FETCH</span> cur_cid <span style=color:#af3a03>into</span> cid;
</span></span><span style=display:flex><span>  END <span style=color:#af3a03>WHILE</span>;
</span></span><span style=display:flex><span>  close cur_cid;
</span></span><span style=display:flex><span>END$$
</span></span></code></pre></div><p><code>ROW</code> 是关键字, 用 <code>ROW2</code>;</p><p>对存储过程 <code>sp sumofrow</code>进行调用</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> delimiter ;
</span></span><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>call</span> <span style=color:#b57614>sp_sumofrow</span>(<span style=color:#af3a03>@</span>rows2);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>@</span>rows2;
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#af3a03>@</span>rows2 <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>      <span style=color:#8f3f71>6</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+--------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>03</span> sec)
</span></span></code></pre></div><ul><li>由此例可以看出：定义了一个 <code>CONTINUE HANDLER</code>句柄，它是在条件出现时被执行的代码，用于控制循环语句，以实现游标的下移；</li><li><code>declare</code>语句的使用存在特定的次序，即用 <code>declare</code>语句定义的局部变量必须在定义任意游标或句柄之前定义，而句柄必须在游标之后定义，否则系统会出现错误消息。</li></ul></li></ul><h6 id=试题在使用游标的过程中需要注意以下几点>试题：在使用游标的过程中，需要注意以下几点<a hidden class=anchor aria-hidden=true href=#试题在使用游标的过程中需要注意以下几点>#</a></h6><ol><li>游标只能用于<strong>存储过程</strong>或<strong>存储函数</strong>中，不能单独在<strong>查询操作</strong>中使用。</li><li>在存储过程或存储函数中可以定义<strong>多个游标</strong>，但是在一个<code>BEGIN…END</code>语句块中每个游标的名字必须是<strong>唯一</strong>的。</li><li>游标不是一条 <code>select</code>语句，是<strong>被 <code>select</code>语句检索出来的结果集</strong>。</li></ol><h3 id=514-调用存储过程体>5.1.4 调用存储过程体<a hidden class=anchor aria-hidden=true href=#514-调用存储过程体>#</a></h3><ul><li><p>创建好存储过程后，可以使用<code>call</code>语句在程序或者其他存储过程中调用它</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>call</span> <span style=color:#b57614>sp_name</span>([parameter[,...]])
</span></span><span style=display:flex><span><span style=color:#af3a03>call</span> sp_name[()]
</span></span></code></pre></div><ul><li>语法项“ <code>sp name</code>”用于指定被调用的存储过程的名称。如果要调用某个特定数据库的存储过程，则需要在前面加上该数据库的名称</li><li>语法项“ <code>parameter</code>”用于指定调用存储过程所要使用的参数。调用语句中参数的个数必须等于存储过程的参数个数。</li><li>当调用没有参数的存储过程时，使用 <code>call sp_name()</code>语句与使用 <code>call sp_name</code>语句是相同的</li></ul></li><li><p>例 5.6 调用数据库 <code>test_db</code>中的存储过程 <code>sp update sex</code>，将客户 id 号 为 909 的客户性别修改为男性“M”</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>call</span> <span style=color:#b57614>sp_update_sex</span>(<span style=color:#8f3f71>906</span>,<span style=color:#79740e>&#39;M&#39;</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div></li></ul><h3 id=515-删除存储过程体>5.1.5 删除存储过程体<a hidden class=anchor aria-hidden=true href=#515-删除存储过程体>#</a></h3><ul><li><p>存储过程在被创建后，会被保存在服务器上以供使用，直至被删除。在 MySQL 中，可以使用 <code>drop procedure</code>语句删除数据库中已创建的存储过程</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> <span style=color:#af3a03>procedure</span>[<span style=color:#af3a03>if</span> <span style=color:#af3a03>exists</span>]sp_name
</span></span></code></pre></div><ul><li>“ <code>sp name</code>”用于指定要删除的存储过程的名称。需注意，它后面没有参数列表，也没有括号。在删除之前，必须确认该存储过程没有任何依赖关系，否则会导致其他与之关联的存储过程无法运行。</li><li>此外，为防止因删除不存在的存储过程而引发的错误，在 <code>drop procedure</code>语句中添加关键字“ <code>if exists</code>”。</li></ul></li><li><p>例 5.7 删除数据库 <code>test_db</code>中的存储过程 <code>sp update sex</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>drop</span> <span style=color:#af3a03>procedure</span> sp_update_sex;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>04</span> sec)
</span></span></code></pre></div></li></ul><h2 id=第二节-存储函数>第二节 存储函数<a hidden class=anchor aria-hidden=true href=#第二节-存储函数>#</a></h2><p><strong>存储函数与存储过程的区别</strong></p><ol><li><strong>存储函数不能拥有输出参数</strong>，这是因为存储函数自身就是输出参数；而存储过程可以拥有输出参数。</li><li><strong>可以直接对存储函数进行调用</strong>，且不需要使用 <code>call</code> 语句；而对存储过程的调用，需要使用 <code>call</code> 语句。</li><li><strong>存储函数中必须包含一条 <code>RETURN</code>语句</strong>，而这条特殊的 SQL 语句<strong>不允许包含于存储过程中</strong>。</li></ol><h3 id=521-创建存储函数>5.2.1 创建存储函数<a hidden class=anchor aria-hidden=true href=#521-创建存储函数>#</a></h3><ul><li><p>使用 <code>create function</code>语句创建存储函数</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> function <span style=color:#b57614>sp_name</span>([func_parameter[,..]])
</span></span><span style=display:flex><span> RETURNS type
</span></span><span style=display:flex><span> routine_body
</span></span></code></pre></div><p>语法项 “ <code>func parameter</code>”的语法格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>param_name type
</span></span></code></pre></div><ul><li>语法项“<code>sp_name</code>”用于指定存储函数的名称，需注意，存储函数不能与存储过程具有相同的名字。</li><li>语法项“ <code>func parameter</code>”用于指定存储函数的参数，这里的参数只有名称和类型，不能指定关键字“<code>in</code>”“<code>OUT</code>”和“ <code>INOUT</code></li><li><strong><code>RETURNS</code>子句用于声明存储函数返回值的数据类型，其中<code>type</code>用于指定返回值的数据类型。</strong></li><li>语法项“ <code>routine body</code>”用于指定存储函数的主体部分，也称为存储函数体。所有在存储过程中使用的 SQL 语句在存储函数中同样也适用，包括前面所介绍的局部变量、<code>set</code>语句、流程控制语句、游标等。但是，存储函数体中还必须包含一个 <code>return value</code>语句, 其中<code>value</code>用于指定存储函数的返回值</li></ul></li><li><p>例 5.8 在数据库 <code>test_db</code>中创建一个存储函数，要求该函数能根据给定的客户 id 号返回客户的性别，如果数据库中没有给定的客户 id 号，则返回“没有该客户”。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>use</span> test_db;
</span></span><span style=display:flex><span>delimiter $$
</span></span><span style=display:flex><span><span style=color:#af3a03>create</span> function <span style=color:#b57614>fn_search</span>(cid <span style=color:#b57614>INT</span>)
</span></span><span style=display:flex><span> RETURNS <span style=color:#b57614>char</span>(<span style=color:#8f3f71>2</span>)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>DETERMINISTIC</span>
</span></span><span style=display:flex><span>BEGIN
</span></span><span style=display:flex><span> <span style=color:#af3a03>declare</span> SEX <span style=color:#b57614>char</span>(<span style=color:#8f3f71>2</span>);
</span></span><span style=display:flex><span> <span style=color:#af3a03>select</span> cust_sex <span style=color:#af3a03>into</span> SEX <span style=color:#af3a03>from</span> customers
</span></span><span style=display:flex><span>  <span style=color:#af3a03>where</span> cust_id<span style=color:#af3a03>=</span>cid;
</span></span><span style=display:flex><span> <span style=color:#af3a03>if</span> SEX <span style=color:#af3a03>IS</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>then</span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>RETURN</span>(<span style=color:#af3a03>select</span><span style=color:#79740e>&#39;没有该客户&#39;</span>);
</span></span><span style=display:flex><span> <span style=color:#af3a03>ELSE</span> <span style=color:#af3a03>if</span> SEX<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;F&#39;</span> <span style=color:#af3a03>then</span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>RETURN</span>(<span style=color:#af3a03>select</span><span style=color:#79740e>&#39;女&#39;</span>);
</span></span><span style=display:flex><span>  <span style=color:#af3a03>ELSE</span> <span style=color:#af3a03>RETURN</span>(<span style=color:#af3a03>select</span><span style=color:#79740e>&#39;男&#39;</span>);
</span></span><span style=display:flex><span>        END <span style=color:#af3a03>if</span>;
</span></span><span style=display:flex><span> END <span style=color:#af3a03>if</span>;
</span></span><span style=display:flex><span>END$$
</span></span><span style=display:flex><span>delimiter ;
</span></span></code></pre></div></li></ul><h3 id=522-调用存储函数>5.2.2 调用存储函数<a hidden class=anchor aria-hidden=true href=#522-调用存储函数>#</a></h3><ul><li><p>可以如同调用系统内置函数一样，使用<strong>关键字 SELECT 对其进行调用</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>select</span> <span style=color:#b57614>sp_name</span>([func_parameter[,...]])
</span></span></code></pre></div></li><li><p>例 5.9 调用数据库 <code>test_db</code>中的存储函数 <code>fn search</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#b57614>fn_search</span>(<span style=color:#8f3f71>904</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#b57614>fn_search</span>(<span style=color:#8f3f71>904</span>) <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 男             <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div></li></ul><h3 id=523-删除存储函数>5.2.3 删除存储函数<a hidden class=anchor aria-hidden=true href=#523-删除存储函数>#</a></h3><ul><li><p>存储函数在被创建后，会被保存在服务器上以供使用，直至被删除。删除存储函数的方法与删除存储过程的方法基本一样。在 MySQL 中，可以使用 <code>drop function</code>语句来实现</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> function [<span style=color:#af3a03>if</span> <span style=color:#af3a03>exists</span>] sp_name
</span></span></code></pre></div><ul><li>“ <code>sp name</code>”指定要删除的存储函数的名称。</li><li>注意，它后面没有参数列表，也没有括号。</li><li>在删除之前，必须确认该存储函数没有任何依赖关系，否则会导致其他与之关联的存储函数无法运行。</li><li>同样，为防止因删除不存在的存储函数而引发的错误，可在 <code>drop function</code> 语句中添加关键字“ <code>if exists</code>”。</li></ul></li><li><p>例 5.10 删除数据库 <code>test_db</code>中的存储函数 <code>fn search</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>drop</span> function <span style=color:#af3a03>if</span> <span style=color:#af3a03>exists</span> fn_search;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div></li></ul><h1 id=第六章-数据库安全与防护>第六章 数据库安全与防护<a hidden class=anchor aria-hidden=true href=#第六章-数据库安全与防护>#</a></h1><h2 id=第一节-数据库完整性>第一节 数据库完整性<a hidden class=anchor aria-hidden=true href=#第一节-数据库完整性>#</a></h2><p>数据库完整性是指 数据库中<strong>数据的正确性和相容性</strong>。</p><h3 id=611-完整性约束条件的作用对象>6.1.1 完整性约束条件的作用对象<a hidden class=anchor aria-hidden=true href=#611-完整性约束条件的作用对象>#</a></h3><ul><li>完整性检查是围绕完整性约束条件进行的，因而<strong>完整性约束条件</strong>是完整性控制机制的核心。完整性约束条件的作用对象可以是<strong>列、元组和表</strong>。<ol><li><strong>列级约束</strong>主要指对列的类型、取值范围、精度等的约束<ol><li>对<strong>数据类型</strong>的约束，其包括数据类型、长度、精度等。<ul><li>例如，在 <code>customers</code>表中将客户地址的数据类型设定为定长字符型，且长度为 50。</li></ul></li><li>对<strong>数据格式</strong>的约束。<ul><li>例如，在学生信息表 <code>tb student</code>表中可将学号 <code>studentNo</code>字段的前四位规定为学生的入学年份，第 5 位规定为院系的编号等。</li></ul></li><li>对<strong>取值范围</strong>或<strong>取值集合</strong>的约束。<ul><li>例如，在学生成绩表 tb score 表中规定成绩 score 字段的取值范围为 0 到 100。</li></ul></li><li>对<strong>空值</strong>的约束。<ul><li>例如，在定义列时规定该列是否允许取空值。</li></ul></li></ol></li><li><strong>元组约束</strong>指元组中各个字段之间的相互约束<ul><li>例如某个活动的开始日期小于结束日期</li></ul></li><li><strong>表级约束</strong>指若干元组之间、关系之间的联系的约束。<ul><li>例如，在学生成绩表 <code>tb score</code> 表中学号 <code>studentNo</code>字段的取值受学生信息表 <code>tb student</code> 表中学号 studentNo 字段取值的约束。</li></ul></li></ol></li></ul><h3 id=612-定义与实现完整性约束>6.1.2 定义与实现完整性约束<a hidden class=anchor aria-hidden=true href=#612-定义与实现完整性约束>#</a></h3><ol><li><p><strong>实体完整性</strong></p><p>在 MSQL 中，实体完整性是通过<strong>主键约束</strong>和<strong>候选键约束</strong>来实现的</p><ol><li><p><strong>主键约束</strong></p><p>主键可以是表中的某一列，也可以是表中多个列所构成的一个组合。其中，由多个列组合而成的主键也称为复合主键。</p><ol><li><strong>每一个表只能定义一个主键</strong>。</li><li><strong>主键的值必须能够唯一标志表中的每一行记录，且不能为<code>null</code></strong>，即表中不同行在主键上不能具有相同的值。这是唯一性原则</li><li><strong>复合主键不能包含不必要的多余列</strong>。即当从一个复合主键中删除一列后，如果剩下的列构成主键仍能满足唯一性原则，那么这个复合主键是不正确的。这是<strong>最小化规则</strong>。</li><li><strong>一个列名在复合主键的列表中只能出现一次</strong>。</li></ol><p><strong>主键约束</strong>可以在 <code>create table</code> 或 <code>alter table</code> 语句中<strong>使用关键字“ <code>primary key</code>”来实现</strong>，其方式有两种。</p><ol><li>一种是作为<strong>列的完整性约束</strong>，此时只需在表中某个列的属性定义后加上关键字<code>primary key</code>”即可。</li><li>一种是作为<strong>表的完整性约束</strong>，需要在表中所有列的属性定义后添加一条 <code>primary key(index col_name,...)</code>格式的子句</li></ol></li><li><p><strong>候选键约束</strong></p><ul><li>候选键可以是表可以是表中多个列所构成的一个组合，候选键的值必须是唯一的，且不能为<code>null</code>。候选键可以在 <code>create table</code> 或 <code>alter table</code> 语句中使用<strong>关键字“ <code>unique</code>”来定义</strong><ol><li>一个表中只能创建一个主键，但可以定义<strong>若干个候选键</strong></li><li>定义主键约束时，系统会自动产生 <code>primary key</code>索引，而定义候选键约束时，系统自动产生 <code>unique</code>索引</li></ol></li></ul></li></ol></li><li><p><strong>参照完整性</strong></p><p>参照完整性是通过在创建表（ <code>create table</code>）或更新表（ <code>alter table</code>）的同时定义一个<strong>外键声明</strong>来实现的。</p><ol><li><p>在表中某个列的属性定义后直接加上“ <code>reference_definition</code>”语法项。</p></li><li><p>在表中所有列的属性定义后添加“ <code>foreign key(index_col_name,...) reference_definition</code>”子句的语法项。</p><ul><li>这里列出 <code>create table</code>语句和 <code>alter table</code> 语句中“ <code>reference definition</code>”语法项的定义：</li></ul></li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>REFERENCES</span> <span style=color:#b57614>tbs_name</span>(index_col_name,...)
</span></span><span style=display:flex><span> [<span style=color:#af3a03>on</span> <span style=color:#af3a03>delete</span> reference_option]
</span></span><span style=display:flex><span> [<span style=color:#af3a03>on</span> <span style=color:#af3a03>update</span> reference_option]
</span></span></code></pre></div><ul><li><p><code>index_col_name</code> 语法格式</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>col_name[(length)][<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>]
</span></span></code></pre></div></li><li><p><code>reference_option</code> 的语法格式</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>restrict</span><span style=color:#af3a03>|</span>CASXADE<span style=color:#af3a03>|</span><span style=color:#b57614>set</span> <span style=color:#d3869b>null</span><span style=color:#af3a03>|</span>NO ACTION
</span></span></code></pre></div></li><li><p>由此可见，语法项“ <code>reference definition</code>”的语法定义主要包含外键所参照的表和列，以及参照动作的声明和实施策略等四部分内容。其中，相关语法说明如下</p><ol><li>“ <code>tbl_name</code>”指定外键所参照的表名。<ul><li>这个表称为被参照表（或父表），而外键所在的表称作参照表（或子表）。</li></ul></li><li>“ <code>col_name</code>”指定被参照的列名。<ul><li>外键可以引用被参照表中的主键或候选键，也可以引用被参照表中某些列的一个组合，但这个组合不能是被参照表中随机的一组列，必须保证该组合的取值在被参照表中是唯一的。</li><li>外键中的所有列值在被参照表的列中必须全部存在，也就是通过外键来对参照表中某些列（外键）的取值进行限定与约束。</li></ul></li><li>关键字“ <code>on delete</code>”或“ <code>on update</code>”指定参照动作相关的 <code>SOL</code> 语句。<ul><li>这里可为每个外键指定的参照动作分别对应于 delete 语句和 UPDATE 语句。</li></ul></li><li>语法项“ <code>reference option</code>”指定参照完整性约束的实现策略。<ul><li>其中，当没有明确指定参照完整性的实现策略时，两个参照动作会默认使用 <code>restrict</code>。</li><li>关键字“ <code>restrict</code>”表示限制策略，即当要删除或更新被参照表中被参照列上，并在外键中出现的值时，系统拒绝对被参照表的删除或更新操作：关键字“ <code>CASCADE</code>”表示级联策略，即从被参照表中删除或更新记录行时，自动删除或更新参照表中匹配的记录行；</li><li>关键字“<code>set null</code>”表示置空策略，即当从被参照表中删除或更新记录行时，设置参照表中与之对应的外键列的值为<code>null</code>，这个策略需要被参照表中的外键列没有声明限定词 <code>not null</code>；</li><li>关键字“ <code>NO ACTION</code>”表示不采取实施策略，即当一个相关的外键值在被参照表中时，删除或更新被参照表中键值的动作不被允许，该策略的动作语义与 <code>restrict</code>相同。</li></ul></li></ol></li></ul><ol start=3><li><p>例 6.1 在数据库 <code>test_db</code>中创建一个商品订单表<code>oder</code>，该表包含的订单信息有：订单号 <code>oder id</code>、订购商品名 <code>order product</code>、订购商品类型 <code>order product type</code>、订购客户 id 号 <code>cust id</code>、订购时间 <code>order date</code>、订购价格 <code>order price</code>、订购数量 <code>order amount</code>。要求商品订单表 <code>orders</code>中的所有订购客户信息均已在表 <code>customers</code> 中记录在册。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>use</span> test_db;
</span></span><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>table</span> <span style=color:#b57614>orders</span>
</span></span><span style=display:flex><span>(
</span></span><span style=display:flex><span> order_id <span style=color:#b57614>INT</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>    order_product <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    order_product_type <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    cust_id <span style=color:#b57614>INT</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    order_date <span style=color:#b57614>DATETIME</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    order_price <span style=color:#b57614>DOUBLE</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    order_amount <span style=color:#b57614>INT</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>primary</span> <span style=color:#af3a03>key</span>(order_id),
</span></span><span style=display:flex><span>    <span style=color:#af3a03>foreign</span> <span style=color:#af3a03>key</span>(cust_id)
</span></span><span style=display:flex><span>  <span style=color:#af3a03>REFERENCES</span> <span style=color:#b57614>customers</span>(cust_id)
</span></span><span style=display:flex><span>        <span style=color:#af3a03>on</span> <span style=color:#af3a03>delete</span> <span style=color:#af3a03>restrict</span>
</span></span><span style=display:flex><span>        <span style=color:#af3a03>on</span> <span style=color:#af3a03>update</span> <span style=color:#af3a03>restrict</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><ul><li>从 例 6.1 可以看到，其通过使用关键字“ <code>primary key</code>”定义了一个主键约束，与此同时，它还通过定义外键创建了一个参照完整性约束，其作用是确保 MySQL 随时检测插入到外键中的每一个非空值是否都已经在被参照表中作为主键出现了，具体而言就是，对于插入表 <code>orders</code>中的每一个订购客户 id 号都执行一次检测，查看这个订购客户 id 号是否已经出现在表 <code>customers</code> 的客户 id 号列（主键）中。</li><li>如若没有，数据将无法正常插入，且系统会返回如下错误提示：<code>ERROR1452（23000：Cannot add or update a child row:a foreign key constraint fails</code>。</li><li>这个过程也适用于使用 <code>update</code>语句更新表 <code>orders</code>中的 <code>cust id</code>列，即由 MySQL 确保表 <code>orders</code>中 <code>cust_id</code>列的内容总是表 <code>customers</code>中 <code>cust id</code>列的内容的个子集</li><li>指定一个外键的规则<ol><li>被参照表必须已经用一条 <code>create table</code>话句创建了，或者必须是当前正在创建的表。如若是后一种情形，则被参照表与参照表是同一个表，这样的表称为自参照表（self referencing table），这种结构称为自参照完整性（ self-referential integrity）</li><li>必须为被参照表定义主键。</li><li>必须在被参照表的表名后面指定列名或列名的组合。这个列或列组合必须是这个被参照表的主键或候选键。</li><li>尽管主键是不能够包含空值的，但允许在外键中出现一个空值。这意味着，只要外键的每个非空值出现在指定的主键中，这个外键的内容就是正确的</li><li>外键中的列的数目必须和被参照表的主键中的列的数目相同</li><li>外键中的列的数据类型必须和被参照表的主键中的对应列的数据类型相同。</li></ol></li></ul></li></ol></li><li><p><strong>用户自定义的完整性</strong></p><ol><li><p><strong>非空约束:</strong> 在某个列定义后面，加上关键字“ <code>not null</code>”作为限定词，来约束该列的取值不能空。</p></li><li><p><strong><code>CHECK</code> 约束:</strong> 与非空约束一样，根据用户的实际完整性要求来定义的。它可以分别对列或表实施 <code>CHECK</code> 约束</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>CHECK</span>(expr)
</span></span></code></pre></div><ul><li>语法项“<code>expr</code>”是一个 SQL 表达式，用于指定需要检查的限定条件。在更新表数据时， MySQL 会检查更新后的数据行是否满足 <code>CHECK</code> 约束中的限定条件。</li><li>MQL 可以使用简单的表达式来实现 <code>CHECK</code> 约束，也允许使用复杂的表达式作为限定条件，例如，在限定条件中加入子查询。</li><li>若将 <code>CHECK</code> 约束子句置于表中某个列的定义之后，则这种约束也称为基于列的 <code>CHECK</code>约束；</li><li>若将 <code>CHECK</code> 约束子句置于表中所有列的定义以及主键约束和外键定义之后，则这种约束也称为基于表的 <code>CHECK</code> 约束，该约束可以同时对表中多个列设置限定条件</li></ul></li></ol></li><li><p>触发器</p></li></ol><h3 id=613-命名完整性约束>6.1.3 命名完整性约束<a hidden class=anchor aria-hidden=true href=#613-命名完整性约束>#</a></h3><ul><li><p>在各种完整性约束的定义说明之前加上关键字“ <code>constraint</code>”和该约束的名字</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>constraint</span> [symbol]
</span></span></code></pre></div><ul><li>其中，语法项“ <code>symbol</code>”是指定的<strong>约束名字</strong>，这个名字是在完整性约束说明的前面被定义，其在数据库里必须是唯一的。倘若没有明确给出约束的名字，则 MySQL 自动创建一个约束名字。</li><li>在定义完整性约束时，应当尽可能地为其指定名字，以便在需要对完整性约束进行修改或删除操作时，可以更加容易地引用它们。</li><li>需要注意的是，<strong>只能给基于表的完整性约束指定名字</strong>，而无法给基于列的完整性约束指定名字。因此，基于表的完整性约束比基于列的完整性约束更受欢迎</li></ul></li></ul><h3 id=614-更新完整性约束>6.1.4 更新完整性约束<a hidden class=anchor aria-hidden=true href=#614-更新完整性约束>#</a></h3><ul><li>当对各种约束进行命名后，就可以使用 <code>alter table</code>语句来更新与列或表有关的各种约束。例如，若要添加约束，可在 <code>alter table</code>语句中使用 <code>add constraint</code>子句，实际上这也是定义约束的一种形式。此外，需要注意以下两点。<ol><li><strong>完整性约束不能直接被修改</strong>。若要修改某个约束，实际上是用 <code>alter table</code>语句先删除该约束，然后再增加一个与该约束同名的新约束。（先删除，再增加）</li><li>使用 <code>alter table</code>语句，可以独立地删除完整性约束，而<strong>不会删除表本身</strong>。若使用 <code>drop table</code>语句删除一个表，则表中所有的完整性约束都会自动被删除。</li></ol></li></ul><h2 id=第二节-触发器难点>第二节 触发器(难点)<a hidden class=anchor aria-hidden=true href=#第二节-触发器难点>#</a></h2><ul><li>触发器（ Trigger）是用户定义在关系表上的一类由<strong>事件驱动的数据库对象</strong>，也是一种<strong>保证数据完整性的方法</strong>。</li><li>触发器一旦定义，无须用户调用，任何对表的修改操作均由数据库服务器自动激活相应的触发器。</li><li>每个表最多支持6个触发器。<ul><li>例如，每当客户订购一个产品时，都从产品库存量中减去可订购的数量；每当删除客户基本信息表中一个客户的全部基本信息数据时，该客户所订购的未完成订单信息也应该被自动删除。</li></ul></li></ul><h3 id=621-创建触发器>6.2.1 创建触发器<a hidden class=anchor aria-hidden=true href=#621-创建触发器>#</a></h3><ul><li><p>使用 create TRIGGER 语句创建触发器</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>TRIGGER</span> trigger_name trigger_time trigger_event
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> tbl_name <span style=color:#af3a03>FOR</span> <span style=color:#af3a03>EACH</span> ROW trigger_body
</span></span></code></pre></div><ol><li>语法项“ <code>trigger_name</code>”用于指定<strong>触发器的名称</strong>，触发器在当前数据库中必须具有唯的名称。<ul><li>如果要在某个特定数据库中创建，名称前面应该加上数据库的名称。</li></ul></li><li>语法项“ <code>trigger_time</code>”用于指定触发器<strong>被触发的时刻</strong>，它有两个选项，即关键字“ <code>BEFORE</code>”和关键字“ <code>after</code>”，用于表示触发器是在激活它的语句之前或者之后触发。<ul><li>如果希望验证新数据是否满足使用的限制，则使用 <code>BEFORE</code>选项；</li><li>如果希望在激活触发器的语句执行之后完成几个或更多的改变，通常使用 <code>after</code>选项。</li></ul></li><li>语法项“ <code>trigger_event</code>”用于指定<strong>触发事件</strong>，即指定激活触发器的语句的种类，其可以是下述值之一：<ul><li>关键字“ <code>insert</code>”，表示将新的数据行插入到表时激活触发器；</li><li>关键字“ <code>update</code>”，表示更改表中某一行数据时激活触发器；</li><li>关键字“ <code>delete</code>”，表示从表中删除某一行数据时激活触发器。</li></ul></li><li>语法项“ <code>tbl name</code>”用于指定<strong>与触发器相关联的表名</strong>，必须引用永久性表，不能将触发器与临时表或视图关联起来，且同一个表不能拥有两个具有相同触发时刻和事件的触发器</li><li>关键字“ <code>FOR EACH ROW</code>”用于指定对于<strong>受触发事件影响</strong>的每一行都要激活触发器的动作。<ul><li>例如，使用一条 insert 语句向一个表中插入多行数据时，触发器会对每一行数据的插入都执行相应触发器动作</li></ul></li><li>语法项“ <code>trigger body</code>”用于指定<strong>触发器动作主体</strong>，即包含触发器激活时将要<strong>执行的 MySQL 语句</strong>。<ul><li>如果要执行多个语句，可使用<code>BFGN…END</code>复合语句结构。</li><li>此外，需要注意的是，在触发器的创建中，<strong>每个表每个事件每次只允许一个触发器</strong>。因此，<strong>每个表最多支持 6 个触发器</strong>，即每条 <code>insert</code>、 <code>update</code>和 <code>delete</code>的“<strong>之前</strong>”与“<strong>之后</strong>”。单一触发器不能与多个事件或多个表关联，例如，需要一个对 NSERT 和 UPDATE 操作执行的触发器，则应该定义两个触发器。</li></ul></li></ol></li><li><p>例 6.2 在数据库 <code>test_db</code>的表 <code>customers</code> 中创建一个触发器 <code>customers insert trigger</code>用于每次向表插入一行数据时，将用户变量 <code>str</code> 的值设置为“ <code>one customer added!</code>”。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>TRIGGER</span> test_db.customers_insert_trigger after <span style=color:#af3a03>insert</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> test_db.customers <span style=color:#af3a03>FOR</span> <span style=color:#af3a03>EACH</span> ROW <span style=color:#b57614>set</span> <span style=color:#af3a03>@</span>str<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;one customer added!&#39;</span>;
</span></span></code></pre></div><p>在 MySQL 命令行客户端使用 <code>insert</code>语句向表 <code>customers</code>插入如下一行数据，并查询</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> test_db.customers <span style=color:#af3a03>values</span>(<span style=color:#d3869b>null</span>,<span style=color:#79740e>&#39;万华&#39;</span>,<span style=color:#79740e>&#39;F&#39;</span>,<span style=color:#79740e>&#39;长沙市&#39;</span>,<span style=color:#79740e>&#39;芙蓉区&#39;</span>,<span style=color:#d3869b>null</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>@</span>str;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#af3a03>@</span>str              <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> one customer <span style=color:#af3a03>add</span><span style=color:#af3a03>!</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div></li></ul><h3 id=622-删除触发器>6.2.2 删除触发器<a hidden class=anchor aria-hidden=true href=#622-删除触发器>#</a></h3><ul><li><p>使用 DROP 语句将触发器从数据库中删除</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> <span style=color:#af3a03>TRIGGER</span>[<span style=color:#af3a03>if</span> <span style=color:#af3a03>exists</span>][schema_name.]trigger_name
</span></span></code></pre></div><ul><li>其中，关键字“ <code>if exists</code>”用于避免在没有触发器的情况下删除触发器；</li><li>语法项“<code>schema_name</code>”用于指定触发器所在的数据库的名称，若没有指定，则为当前默认数据库；</li><li>语法项“ <code>trigger name</code>”指定要删除的触发器名称</li></ul></li><li><p>例 6.3 删除数据库 <code>test_db</code> 中的触发器 <code>customers_insert_trigger</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> <span style=color:#af3a03>TRIGGER</span> <span style=color:#af3a03>if</span> <span style=color:#af3a03>exists</span> test_db.customers_insert_trigger;
</span></span></code></pre></div><ul><li>当删除一个表的同时，也会自动地删除该表上的触发器，且触发器不能更新或覆盖，为了修改一个触发器，<strong>必须先删除它，然后再重新创建</strong>。</li></ul></li></ul><h3 id=623-使用触发器>6.2.3 使用触发器<a hidden class=anchor aria-hidden=true href=#623-使用触发器>#</a></h3><ol><li><p><code>insert</code> 触发器可在 <code>insert</code> 语句执行之前或之后执行。</p><ol><li>在 <code>insert</code>触发器代码内，可引用一个名为<code>NEW</code>的虚拟表，来访问被插入的行。</li><li>在 <code>BEFORE insert</code>触发器中，<code>NEW</code>中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</li><li>对于 <code>AUTO INCREMENT</code>列，<code>NEW</code>在 <code>insert</code>执行之前包含的是 0 值，在 <code>insert</code> 执行之后将包含新的自动生成值。</li></ol><ul><li><p>例 6.4 在数据库 <code>test_db</code>的表 <code>customers</code>中重新创建触发器 <code>customers insert trigger</code>用于每次向表 <code>customers</code>插入一行数据时，将用户变量 str 的值设置为新插入客户的 id 号</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>TRIGGER</span> test_db.customers_insert_trigger after <span style=color:#af3a03>insert</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> test_db.customers <span style=color:#af3a03>FOR</span> <span style=color:#af3a03>EACH</span> ROW <span style=color:#b57614>set</span> <span style=color:#af3a03>@</span>str<span style=color:#af3a03>=</span>NEW.cust_id;
</span></span><span style=display:flex><span><span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> test_db.customers
</span></span><span style=display:flex><span> <span style=color:#af3a03>values</span>(<span style=color:#d3869b>null</span>,<span style=color:#79740e>&#39;曾伟&#39;</span>,<span style=color:#79740e>&#39;F&#39;</span>,<span style=color:#79740e>&#39;长沙市&#39;</span>,<span style=color:#79740e>&#39;芙蓉区&#39;</span>,<span style=color:#d3869b>null</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>select</span> <span style=color:#af3a03>@</span>str;
</span></span></code></pre></div></li></ul></li><li><p><code>delete</code> 触发器可在 <code>delete</code>语句执行之前或之后执行。</p><ol><li>在 <code>delete</code>触发器代码内，可以引用一个名为<code>OLD</code>的虚拟表，来访问被删除的行。</li><li><code>OLD</code>中的值全部是只读的，不能被更新。</li></ol></li><li><p><code>update</code> 触发器在 <code>update</code>语句执行之前或之后执行。</p><ol><li>在 <code>update</code>触发器代码内，可以引用一个名为<code>OLD</code>的虚拟表访问以前（ <code>update</code>语句执行前）的值，也可以引用一个名为<code>NEW</code>的虚拟表访问新更新的值</li><li>在 <code>BEFORE update</code>触发器中，<code>NEW</code>中的值可能也被更新，即允许更改将要用于<code>update</code>语句中的值（只要具有对应的操作权限）。</li><li><code>OLD</code>中的值全部是只读的，不能被更新。</li><li>当触发器涉及对触发表自身的更新操作时，只能使用 <code>BEFORE update</code>触发器，而<code>after update</code>触发器将不被允许</li></ol><ul><li><p>例 6.5 在数据库 <code>test_db</code>的表 <code>customers</code>中创建一个触发器 <code>customers_update_trigger</code>，用于每次更新表 <code>customers</code>时，将该表中 <code>cust address</code>列的值设置为 <code>cust contact</code>列的值</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>TRIGGER</span> test_db.customers_update_trigger <span style=color:#af3a03>BEFORE</span> <span style=color:#af3a03>update</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> test_db.customers <span style=color:#af3a03>FOR</span> <span style=color:#af3a03>EACH</span> ROW
</span></span><span style=display:flex><span>    <span style=color:#b57614>set</span> NEW.cust_address<span style=color:#af3a03>=</span>OLD.cust_contact;
</span></span><span style=display:flex><span><span style=color:#af3a03>update</span> test_db.customers <span style=color:#b57614>set</span> cust_address<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;武汉市&#39;</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>where</span> cust_name<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;曾伟&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>select</span> cust_address <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span> <span style=color:#af3a03>where</span> cust_name<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;曾伟&#39;</span>;
</span></span></code></pre></div></li></ul></li></ol><h2 id=第三节-安全性与访问控制>第三节 安全性与访问控制<a hidden class=anchor aria-hidden=true href=#第三节-安全性与访问控制>#</a></h2><p><strong>数据库的安全性是指数据库以防止不合法的使用而造成数据泄露、更改或破坏。</strong>
安全性与访问性控制：<strong>身份验证、数据库用户权限确认</strong></p><h3 id=631-用户账号管理>6.3.1 用户账号管理<a hidden class=anchor aria-hidden=true href=#631-用户账号管理>#</a></h3><ul><li><p>MySQL 的用户账号及相关信息都存储在一个名为 <code>mysql</code> 的 MySQL 数据库中，这个数据库里有一个名为 <code>user</code>的数据表，包含了所有用户账号，并且它用一个名为<code>user</code> 的列存储用户的登录名。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>user</span> <span style=color:#af3a03>from</span> mysql.<span style=color:#af3a03>user</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>+------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#af3a03>user</span>             <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> mysql.infoschema <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> mysql.session    <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> mysql.sys        <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> root             <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+------------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>4</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div></li><li><p>在 MySQL 的日常管理和实际操作中，为了避免恶意用户冒名使用 <code>root</code>账号操控数据库，通常需要创建一系列具备适当权限的账号，而尽可能地不用或少用 <code>root</code>账号登录系统，以此来确保数据的安全访问。</p></li></ul><ol><li><p>使用 <code>create user</code> 语句来<strong>创建</strong>一个或多个 MySQL 账户，并设置相应的口令</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>user</span> <span style=color:#af3a03>user</span>[<span style=color:#af3a03>identified</span> <span style=color:#af3a03>by</span>[PASSWOED]<span style=color:#79740e>&#39;passwoed&#39;</span>]
</span></span></code></pre></div><ol><li>语法项“<code>user</code>”指定创建用户账号，其格式为 <code>user_name'@'host_name'</code>。<ul><li>其中，<code>user name</code>表示用户名， <code>host name</code>表示主机名，即用户连接 MySQL 时所在主机的名字。</li><li>如果在创建的过程中，只给出了账户中的用户名，而没指定主机名，则主机名会默认为是 “<code>%</code>”，其表示一组主机</li></ul></li><li>语法项“ <code>identified by</code>子句”是可选项，用于指定用户账号对应的口令，若该用户账号无口令，则可省略此子句</li><li>关键字“ <code>password</code>”是可选项，用于指定散列口令，即若使用明文设置口令时，需忽略 <code>password</code>关键字；<ul><li>如果不想以明文设置口令，且知道 <code>password()</code>函数返回给密码的散列值，则可以在此口令设置语句中指定此该散列值，但需要加上关键字 <code>password</code></li></ul></li><li>语法项“ <code>password</code>”指定用户账号的口令，其在 <code>identified by</code> 关键字或 <code>password</code> 关键字之后。<ul><li>设定的口令值可以是只由字母和数字组成的明文，也可以是通过<code>password()</code>函数得到散列值</li></ul></li></ol><ul><li><p>例 6.6 在 MySQL 服务器中添加两个新的用户，其用户名分别为 <code>zhangsan</code>和<code>lisi</code>，他们的主机名均为 <code>localhost</code>，用户 <code>zhangsan</code>的口令设置为明文<code>123</code>，用户<code>lisi</code>的口令设置为对明文<code>456</code>使用 <code>password()</code>函数加密返回的散列值。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#928374;font-style:italic># password() 功能已在MySQL 8.0.11中删除。
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>select</span> <span style=color:#b57614>MD5</span>(<span style=color:#8f3f71>456</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>user</span> <span style=color:#79740e>&#39;张三&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span> <span style=color:#af3a03>identified</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;123&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#79740e>&#39;李四&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span> <span style=color:#af3a03>identified</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;250cf8b51c773f3f8dc8b4be867a9a02&#39;</span>;
</span></span></code></pre></div><ol><li>要使用 <code>create user</code>语句，必须拥有 MySQL 中 <code>mysql</code> 数据库的 <code>insert</code> 权限或全局 <code>create user</code> 权限。</li><li>使用 <code>create user</code> 语句创建一个用户账号后，会在系统自身的 <code>mysql</code>数据库的<code>user</code>表中添加一条新记录。如果创建的账户已经存在，则语句执行会出现错误</li><li>如果两个用户具有<strong>相同的用户名和不同的主机名</strong>， MySQL 会将他们视为<strong>不同的用户</strong>，并允许为这两个用户分配不同的权限集合。</li><li>如果在 <code>create user</code> 语句的使用中，没有为用户指定口令，那么 MySQL 允许该用户可以不使用口令登录系统，然而从安全的角度而言，不推荐这种做法。</li><li>新创建的用户拥有的权限很少。他们可以登录到 MySQL，只允许进行不需要权限的操作，比如使用<code>show</code> 语句查询所有存储引擎和字符集的列表等，不能使用 <code>use</code> 语句来让其他用户已经创建了的任何数据库成为当前数据库，因而无法访问那些数据库的表。</li></ol></li></ul></li><li><p><strong>删除</strong>一个或多个用户账号以及相关的权限，可以使用 <code>drop user</code> 语句</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> <span style=color:#af3a03>user</span> <span style=color:#af3a03>user</span>[,<span style=color:#af3a03>user</span>]...
</span></span></code></pre></div><ul><li><p>例 6.7 删除前面例子中的<code>lisi</code>用户。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>drop</span> <span style=color:#af3a03>user</span> <span style=color:#79740e>&#39;李四&#39;</span><span style=color:#af3a03>@</span>localhost;
</span></span></code></pre></div><ul><li><code>drop user</code> 语句可用于删除一个或多个 MySQL 账户，并消除其权限。</li><li>要使用 <code>drop user</code>语句，必须拥有 MySQL 中 mysq 数据库的 delete 权限或全局 create user 权限</li><li>在 <code>drop user</code> 语句的使用中，如果没有明确地给出账户的主机名，则该主机名会默认为是 <code>%</code>。</li><li>用户的删除不会影响到他们之前所创建的表、索引或其他数据库对象，这是因为 MySQL 并没有记录是谁创建了这些对象。</li></ul></li></ul></li><li><p>使用 <code>rename user</code> 语句<strong>修改</strong>一个或多个已经存在的 MySQL 用户账号</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>rename</span> <span style=color:#af3a03>user</span> old_user <span style=color:#af3a03>TO</span> new_user[,old_user <span style=color:#af3a03>TO</span> new_user]...
</span></span></code></pre></div><ul><li><p>例 6.8 将前面例子中用户 <code>张三</code>的名字修改成 <code>王五</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>rename</span> <span style=color:#af3a03>user</span> <span style=color:#79740e>&#39;张三&#39;</span><span style=color:#af3a03>@</span>localhost <span style=color:#af3a03>TO</span> <span style=color:#79740e>&#39;王五&#39;</span><span style=color:#af3a03>@</span>localhost;
</span></span></code></pre></div><ul><li><code>rename user</code> 语句用于对原有 MySQL 账户进行重命名。</li><li>要使用 <code>rename user</code>语句，必须拥有 MySQL 中 <code>mysq</code> 数据库的 <code>update</code> 权限或全局 <code>create user</code>权限。</li><li>倘若系统中旧账户不存在或者新账户已存在，则语句执行会出现错误。</li></ul></li></ul></li><li><p>使用 <code>set password</code> 语句<strong>修改</strong>一个用户的登录口令</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#b57614>set</span> password [<span style=color:#af3a03>FOR</span> <span style=color:#af3a03>user</span>]<span style=color:#af3a03>=</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span> <span style=color:#b57614>password</span>(<span style=color:#79740e>&#39;new_password&#39;</span>)
</span></span><span style=display:flex><span> <span style=color:#af3a03>|</span><span style=color:#79740e>&#39;encrypted password&#39;</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><p>语法项“<code>FOR</code>子句”为可选项，用于指定欲修改口令的用户；</p></li><li><p>语法项“ <code>password(new password)</code>”表示使用函数 <code>password()</code> 设置新口令 <code>new password</code>，即新口令必须传递到函数 <code>password()</code> 中进行加密；</p></li><li><p>语法项“ <code>encrypted password</code>”表示已被函数 <code>password()</code> 加密的口令值。</p><ul><li><p>例 6.9 将前面例子中用户 <code>wangwu</code> 的口令修改成明文<code>hello</code>对应的散列值。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#b57614>set</span> password <span style=color:#af3a03>FOR</span> <span style=color:#79740e>&#39;王五&#39;</span><span style=color:#af3a03>@</span>localhost
</span></span><span style=display:flex><span><span style=color:#af3a03>=</span><span style=color:#79740e>&#39;5d41402abc4b2a76b9719d911017c592&#39;</span>;
</span></span></code></pre></div></li><li><p>若不加上 <code>FOR</code> 子句，表示<strong>修改当前用户</strong>的口令；</p></li><li><p>若加上 FOR 子句，表示修改账户为<code>user</code>的用户口令，其中<code>user</code>的格式必须以 <code>user name@ ahost name</code>的格式给定， <code>user name</code>为账户的用户名， <code>host name</code>为账户所在的主机名。该账户必须在系统中存在，否则语句执行会出现错误。</p></li><li><p>只能使用选项“ <code>password(new password)</code>”和“ <code>encrypted password</code>”中的一项，且必须使用其中的某一项。</p></li></ul></li></ul></li></ol><h3 id=632-用户权限管理>6.3.2 用户权限管理<a hidden class=anchor aria-hidden=true href=#632-用户权限管理>#</a></h3><ul><li><p>成功创建用户账号后，需要为该用户分配访问适当的权限，因为新创建的用户账号没有访问权限，只能登录 MySQL 服务器，不能执行任何数据库操作。</p><ul><li><p>例如，使用<code>show GRANTS FOR</code>语句就可以查看前面新创建的用户 <code>zhangsan</code>的如下授权表</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>show</span> GRANTS <span style=color:#af3a03>FOR</span> <span style=color:#79740e>&#39;王五&#39;</span><span style=color:#af3a03>@</span>localhost;
</span></span></code></pre></div></li></ul></li></ul><ol><li><p><strong>权限的授予</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>grant</span>
</span></span><span style=display:flex><span> priv_type[(column_list)]
</span></span><span style=display:flex><span> [,priv_type[(column_list)]]...
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span>[object_type]priv_level
</span></span><span style=display:flex><span> <span style=color:#af3a03>TO</span> user_specification[,user_specification]...
</span></span><span style=display:flex><span> [<span style=color:#af3a03>WITH</span> <span style=color:#af3a03>grant</span> <span style=color:#af3a03>OPTION</span>]
</span></span></code></pre></div><ol><li><p>语法项“ <code>priv type</code>”用于指定<strong>权限的名称</strong>，例如 <code>select</code>、 <code>update</code>、 <code>delete</code>等数据库操作。</p></li><li><p>可选语法项“ <code>column_list</code>”用于指定权限要授予给表中哪些<strong>具体的列</strong></p></li><li><p>语法项“<code>on</code>”用于指定权限授予的<strong>对象和级别</strong>，例如可在关键字“<code>on</code>”后面给出要授予权限的数据库名或表名。</p></li><li><p>可选项“ <code>object_type</code>”用于指定权限授予的<strong>对象类型</strong>，包括表、函数和存储过程分别用关键字“ <code>table</code>”“ <code>function</code>”和“ <code>procedure</code>”标识。</p></li><li><p>语法项“ <code>priv_level</code>”：用于指定<strong>权限的级别</strong>，其可以授予的权限有这样几个：</p><ul><li>列权限、表权限、数据库权限和用户权限。</li><li>相应地，在 grant 语句中可用于指定权限级别的值有这样几类格式：</li><li>“<code>*</code>”表示<strong>当前数据库中的所有表</strong>；</li><li>“<code>*.*</code>”表示<strong>所有数据库中的所有表</strong>；</li><li>“ <code>db_name.*</code>”表示<strong>某个数据库中的所有表</strong>， <code>db_name</code>指定数据库名；</li><li>“ <code>db_name.tbl_name</code>”表示某个数据库中的某个表或视图， <code>db_name</code>指定数据库名， <code>tbl_name</code>指定表名或视图名；</li><li>“ <code>tbl_name</code>”表示某个表或视图， <code>tbl_name</code>指定表名或视图名；</li><li>“ <code>db_name.routine_name</code>”表示某个数据库中的某个存储过程或函数， <code>routine_name</code>指定存储过程名或函数名。</li></ul></li><li><p>语法项“<code>TO</code>子句”用来设定<strong>用户的口令</strong>，以及指定被授予权限的用户<code>user</code>。</p><ul><li>若在<code>TO</code>子句中给系统中存在的用户指定口令，则新密码会将原密码覆盖；</li><li>如果权限被授予给个不存在的用户， MySQL 会自动执行一条 <code>create user</code> 语句来创建这个用户，但同时必须为该用户指定口令。</li><li>由此可见， <code>grant</code> 语句亦可以用于创建用户账号。</li></ul></li><li><p>语法项“ <code>user specification</code>”是<code>To</code>子句中的<strong>具体描述</strong>部分，其常用的语法格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>user</span> [<span style=color:#af3a03>identified</span> <span style=color:#af3a03>by</span> [password] <span style=color:#79740e>&#39;password&#39;</span>]
</span></span></code></pre></div></li><li><p>语法项“<code>WITH</code>子句”为可选项，用于实现权限的<strong>转移或限制</strong>。</p></li></ol><ul><li><p>例 6.10 授予用户 <code>Zhangsan</code>在数据库 <code>test_db</code>的表 <code>customers</code>上拥有对列 <code>cust_id</code>和列<code>cust_name</code>的 <code>select</code>权限</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>grant</span> <span style=color:#af3a03>select</span> (cust_id,cust_name)
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> test_db.customers
</span></span><span style=display:flex><span>  <span style=color:#af3a03>TO</span> <span style=color:#79740e>&#39;王五&#39;</span><span style=color:#af3a03>@</span>localhost;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span> <span style=color:#af3a03>from</span> test_db.customers;
</span></span><span style=display:flex><span>ERROR <span style=color:#8f3f71>1142</span> (<span style=color:#8f3f71>42000</span>): <span style=color:#af3a03>select</span> command denied <span style=color:#af3a03>to</span> <span style=color:#af3a03>user</span> <span style=color:#79740e>&#39;wangwu&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span> <span style=color:#af3a03>for</span> <span style=color:#af3a03>table</span> <span style=color:#79740e>&#39;customers&#39;</span>
</span></span></code></pre></div></li><li><p>例 6.11 当前系统中不存在用户 <code>liming</code>和用户 <code>huang</code>，要求创建这两个用户，并设置对应的系统登录口令，同时授予他们在数据库 <code>test_db</code>的表 <code>customers</code>上拥有 <code>select</code>和<code>update</code>的权限。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>user</span> <span style=color:#79740e>&#39;liming&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span> <span style=color:#af3a03>identified</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;123&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#79740e>&#39;huang&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span> <span style=color:#af3a03>identified</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;234&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>#查看更新权限
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>grant</span> <span style=color:#af3a03>select</span>,<span style=color:#af3a03>update</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>TO</span> <span style=color:#79740e>&#39;liming&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#39;huang&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>#数据库权限
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>grant</span> <span style=color:#af3a03>ALL</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> test_db.<span style=color:#af3a03>*</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>TO</span> <span style=color:#79740e>&#39;wangwu&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>#创建用户权限
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>grant</span> <span style=color:#af3a03>ALL</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> <span style=color:#af3a03>*</span>.<span style=color:#af3a03>*</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>TO</span> <span style=color:#79740e>&#39;wangwu&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span>;
</span></span></code></pre></div></li></ul><ol><li>授予<strong>表权限</strong>时，语法项“ <code>priv type</code>”可以指定为以下值。<ul><li>SELECT：表示授予用户可以使用 SELECT 语句访问特定表的权限。</li><li>INSERT：表示授予用户使用 insert 语句向一个特定表中添加数据行的权限。</li><li>DELETE：表示授予用户可以使用 delete 语句向一个特定表中删除数据行的权限</li><li>UPDATE：表示授予用户可以使用 UPDATE 语句修改特定数据表中值的权限。</li><li>REFERENCES：表示授予用户可以创建一个外键来参照特定数据表的权限</li><li>CREATE：表示授予用户可以使用特定的名字创建一个数据表的权限。</li><li>ALTER：表示授予用户可以使用 alter table 语句修改数据表的权限。</li><li>INDEX：表示授予用户可以在表上定义索引的权限。</li><li>DROP：表示授予用户可以删除数据表的权限。</li><li>ALL 或 ALL PRIVILEGES：表示所有的权限名。</li></ul></li><li>授予<strong>列权限</strong>时，语法项“ <code>priv type</code>”的值只能指定为 SELECT、 insert 和 UPDATE，同时权限的后面需要加上列名列表 <code>column list</code></li><li>授予<strong>数据库权限</strong>时，语法项“ <code>priv type</code>”可以指定为以下值。<ul><li>SELECT：表示授予用户可以使用 select 语句<strong>访问</strong>特定数据库中所有表和视图的权限。</li><li>INSERT：表示授予用户可以使用 insert 语句向特定数据库中所有表<strong>添加</strong>数据行的权限</li><li>DELETE：表示授予用户可以使用 delete 语句<strong>删除</strong>特定数据库中所有表的数据行的权限。</li><li>UPDATE：表示授予用户可以使用 update 语句<strong>更新</strong>特定数据库中所有数据表的值的权限。</li><li>REFERENCES：表示授予用户可以<strong>创建</strong>指向特定的数据库中的表<strong>外键</strong>的权限。</li><li>CREATE：表示授予用户可以使用 create table 语句在特定数据库中<strong>创建新表</strong>的权限。</li><li>ALTER：表示授予用户可以使用 alter table 语句<strong>修改</strong>特定数据库中所有数据表的权限。</li><li>INDEX：表示授予用户可以在特定数据库中的所有数据表上定义和删除<strong>索引</strong>的权限。</li><li>DROP：表示授予用户可以<strong>删除</strong>特定数据库中所有表和视图的权限</li><li>create TEMPORARY TABLES：表示授予用户可以在特定数据库中<strong>创建临时表</strong>的权限。</li><li>create VIEW：表示授予用户可以在特定数据库中<strong>创建新的视图</strong>的权限。</li><li>show VIEW：表示授予用户可以<strong>查看</strong>特定数据库中已有视图的视图定义的权限</li><li>create ROUTINE：表示授予用户可以为特定的数据库<strong>创建存储过程</strong>和存储函数等权限。</li><li>alter ROUTINE：表示授予用户可以<strong>更新</strong>和<strong>删除</strong>数据库中已有的存储过程和存储函数等权限。</li><li>EXECUTE ROUTINE：表示授予用户可以<strong>调用</strong>特定数据库的存储过程和存储函数的权限。</li><li>LOCK TABLES：表示授予用户可以<strong>锁定</strong>特定数据库的已有数据表的权限 AL 或 ALL</li><li>PRIVILEGES：表示以上<strong>所有</strong>的权限名。</li></ul></li><li>最有效率的权限是用户权限。<strong>授予用户权限</strong>时，语法项“ <code>priv type</code>”除了可以指定为授予数据库权限时的所有值之外，还可以是下面这些值。<ul><li>create USER：表示授予用户可以<strong>创建和删除新用户</strong>的权限。</li><li>show DATABASES：表示授予用户可以使用 show databases 语句<strong>查看</strong>所有已有的数据库的定义的权限。</li></ul></li></ol></li><li><p><strong>权限的转移</strong></p><p>通过在 <code>grant</code> 语句中使用 <code>WITH</code> 子句来实现。</p><ul><li><p>例 6.14 授予当前系统中一个不存在的用户<code>zhou</code>在数据库 <code>test_db</code>的表 <code>customers</code>上拥有 <code>select</code>和 <code>update</code>的权限，并允许其可以将自身的这个权限授予给其他用户。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>user</span> <span style=color:#79740e>&#39;zhou&#39;</span><span style=color:#af3a03>@</span>localhost <span style=color:#af3a03>identified</span> <span style=color:#af3a03>by</span><span style=color:#79740e>&#39;123&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>grant</span> <span style=color:#af3a03>select</span>,<span style=color:#af3a03>update</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>TO</span> <span style=color:#79740e>&#39;zhou&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>WITH</span> <span style=color:#af3a03>grant</span> <span style=color:#af3a03>OPTION</span>;
</span></span></code></pre></div></li></ul></li><li><p><strong>权限的撤销</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>revoke</span>
</span></span><span style=display:flex><span> priv_type[(column_list)]
</span></span><span style=display:flex><span> [,priv_type[(column_list)]]...
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> [object_type]privl_evel
</span></span><span style=display:flex><span> <span style=color:#af3a03>from</span> <span style=color:#af3a03>user</span>[,<span style=color:#af3a03>user</span>]...
</span></span></code></pre></div><p>回收特定用户的所有权限时</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>revoke</span> <span style=color:#af3a03>ALL</span> <span style=color:#af3a03>PRIVILEGES</span>,<span style=color:#af3a03>grant</span> <span style=color:#af3a03>OPTION</span> <span style=color:#af3a03>from</span> <span style=color:#af3a03>user</span>[,<span style=color:#af3a03>user</span>]...
</span></span></code></pre></div><ul><li><p>例 6.15 回收系统中已存在的用户<code>zhou</code>在数据库 <code>test_db</code>的表<code>customers</code>上的<code>select</code>权限。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>revoke</span> <span style=color:#af3a03>select</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>from</span> <span style=color:#79740e>&#39;zhou&#39;</span><span style=color:#af3a03>@</span>localhost;
</span></span></code></pre></div></li></ul></li></ol><h2 id=第四节-事务与并发控制-重点>第四节 事务与并发控制 （重点）<a hidden class=anchor aria-hidden=true href=#第四节-事务与并发控制-重点>#</a></h2><h3 id=641-事务的概念201810>6.4.1 事务的概念(201810)<a hidden class=anchor aria-hidden=true href=#641-事务的概念201810>#</a></h3><ul><li><strong>事务</strong>是用户定义的一个<strong>数据操作序列</strong>，这些操作可作为一个完整的<strong>工作单元</strong>，要么<strong>全部执行</strong>，要么<strong>全部不执行</strong>，是一个<strong>不可分割</strong>的工作单位。</li><li>在 SQL 中，用户显式定义事务的语句一般有这样三条：<strong>BEGIN TRANSACTION、 COMMIT 和 ROLLBACK，且事务通常是以 BEGIN TRANSACTION 语句开始，以 COMMIT 语句或 ROLLBACK 语句结束。</strong><ul><li>其中， COMMIT 语句表示提交，即提交事务的所有操作，具体地说就是将事务中所有对数据库的更新写回到磁盘上的物理数据库中去，事务正常结束；</li><li>ROLLBACK 语句表示回滚，即在事务运行的过程中若发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态。事务中的操作一般是对数据的更新操作，包括增、删、改。</li></ul></li></ul><h3 id=642-事务的特征acid>6.4.2 事务的特征(ACID)<a hidden class=anchor aria-hidden=true href=#642-事务的特征acid>#</a></h3><ol><li><strong>原子性</strong>（ Atomicity）<ul><li>事务的原子性保证事务包含的一组更新操作是原子不可分的，即<strong>事务是不可分割的最小工作单位</strong>，所包含的这些操作是一个整体。事务在执行时，要求遵守“要么全做，要么全不做”的原则。即使在系统崩溃之后，也能通过撤销系统崩溃时所处于活动状态的事务对数据库的影响，从而保证事务的原子性</li></ul></li><li><strong>一致性</strong>（ Consistency）<ul><li>一致性要求事务必须满足数据库的完整性约束，且事务执行完毕后将数据库<strong>由一个一致性状态转变到另一个一致性状态</strong>。其中，数据库的一致性状态是一种以一致性规则为基础的逻辑属性。例如一个典型实例：在银行数据库系统中，通常有这样一个事务“从账户 A 转账 S 金额资金到账户 B”，此事务包含两个操作，即从账户 A 减去 S 金额资金，和在账户 B 中增加 S 金额资金，如果只执行其中一个操作，则数据库会处于不一致状态，那么就需要这两个操作成为一个整体，要么全做，要么全不做，否则不能成为事务。由此可见，一致性和原子性密切相关。</li></ul></li><li><strong>隔离性</strong>（ Isolation）<ul><li>隔离性要求事务是<strong>彼此独立</strong>的、<strong>隔离</strong>的，即一个事务的执行<strong>不能被其他事务所干扰</strong>，个事务对数据库变更的结果必须在它 COMMIT 后，另一个事务才能存取。多个事务并发执行时，其结果应等价于它们的一种顺序执行的结果，就如同串行调度执行事务一般。这一特性也称为可串行性，即系统执行的任何交错操作调度实质上是一个串行调度，而串行调度是指每当调度一个事务，在该事务的所有操作没有结束之前其他的事务不能被执行。</li></ul></li><li><strong>持续性</strong>（ Durability）<ul><li>持续性也称为<strong>永久性</strong>（ Permanence），是指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的，且接下来的其他操作或故障不应该对其执行结果有任何影响。</li></ul></li></ol><ul><li><p>例 6.16 依据事务的 ACID 特征，分析并编写银行数据库系统中的转账事务 T：从账户 A 转账 S 金额资金到账户 B。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>read</span>(A);
</span></span><span style=display:flex><span>A<span style=color:#af3a03>=</span>A<span style=color:#af3a03>-</span>S;
</span></span><span style=display:flex><span><span style=color:#af3a03>write</span>(A);
</span></span><span style=display:flex><span><span style=color:#af3a03>read</span>(B);
</span></span><span style=display:flex><span>B<span style=color:#af3a03>=</span>B<span style=color:#af3a03>+</span>S;
</span></span><span style=display:flex><span><span style=color:#af3a03>write</span>(B);
</span></span></code></pre></div><ol><li>在数据库执行上述所有操作执行的过程中，若某一时刻账户 A 已减去 S 金额的资金，而账户 B 尚未增加，这显然就会出现一种不一致的状态，因此需要将所有操作当作一个不可分割的整体，遵守“要么全做，要么全不做”的原则，保证事务的原子性</li><li>在数据库上述所有操作执行的过程中，要求数据库中账户 A 减去 S 金额资金的同时，账户 B 增加 S 金额资金，即账户 A 和账户 B 之和不变，维系数据库的一致性状态，保证事务的一致性。</li><li>在数据库上述所有操作执行的过程中，如若有其他操作插入进来修改账户 A 或账户 B 的金额，会导致错误数据的产生，因此需要隔离上述所有操作，保证事务的隔离性。</li><li>在数据库上述所有操作成功执行完毕后，系统需要确保以后任何故障都不会再引起与这次转账相关的数据的丢失，保证事务的持久性。</li></ol><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>BEGIN TRANSACTION
</span></span><span style=display:flex><span><span style=color:#af3a03>read</span>(A);
</span></span><span style=display:flex><span>A<span style=color:#af3a03>=</span>A<span style=color:#af3a03>-</span>S;
</span></span><span style=display:flex><span><span style=color:#af3a03>write</span>(A);
</span></span><span style=display:flex><span><span style=color:#af3a03>if</span>(A<span style=color:#af3a03>&lt;</span><span style=color:#8f3f71>0</span>)ROLLBACK;
</span></span><span style=display:flex><span><span style=color:#af3a03>else</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span> <span style=color:#af3a03>read</span>(B);
</span></span><span style=display:flex><span> B<span style=color:#af3a03>=</span>B<span style=color:#af3a03>+</span>S;
</span></span><span style=display:flex><span> <span style=color:#af3a03>write</span>(B);
</span></span><span style=display:flex><span> COMMIT;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>其中， ROLLBACK 语句表示在账户 A 扣款透支时拒绝该转账操作，执行回滚操作，数据库中相关数据的值恢复到这个事务的初始状态； COMMIT 语句表示转账操作顺利结束，数据库处于新的一致性状态。</li></ul></li></ul><h3 id=643-并发操作问题>6.4.3 并发操作问题<a hidden class=anchor aria-hidden=true href=#643-并发操作问题>#</a></h3><ol><li><p>丢失更新</p><ul><li>设有两个事务 T1 和 T2 ，当它们同时读入同一数据并加以修改时，事务 T2 的提交结果会破坏事务 T1 提交的结果，由此导致事务 T1 的修改被丢失。这就是一种由于对数据的并发操作而带来的数据不一致性。</li></ul></li><li><p>不可重复读</p><p>设有两个事务 T1 和 T2 ，不可重复读是指事务 T1 读取数据后，事务 T2 执行更新操作，使事务 T1 无法再现前一次读取结果。通常，不可重复读包括三种情况。</p><ol><li>事务 T1 读取某一数据后，事务 T2 对其做了修改，当事务 T1 再次读该数据时，得到与前一次不同的值</li><li>事务 T1 按一定条件从数据库中读取了某些数据记录后，事务 T2 删除了其中部分记录，当事务 T1 再次按相同条件读取数据时，发现某些记录神秘地消失了</li><li>事务 T1 按一定条件从数据库中读取某些数据记录后，事务 T2 插入了一些记录，当事务 T1 再次按相同条件读取数据时，发现多了一些记录。</li></ol></li><li><p>读“脏”数据</p><ul><li>设有两个事务 T1 和 T2 ，读“脏”数据是指，事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，事务 T1 由于某种原因被撤销，这时事务 T1 已修改过的数据恢复原值，事务 T2 读到的数据就与数据库中的数据不一致，则事务 T2 读到的数据就为 “脏”数据，即不正确的数据。</li></ul></li></ol><p>解决并发操作所带来的数据不一致性问题的方法有<strong>封锁</strong>、<strong>时间戳</strong>、<strong>乐观控制法</strong>和<strong>多版本并发控制</strong>等。本节接下来主要介绍封锁方法，这也是众多数据库产品采用的基本方法。</p><h3 id=644-封锁-是最常用的并发控制技术>6.4.4 封锁 是最常用的并发控制技术<a hidden class=anchor aria-hidden=true href=#644-封锁-是最常用的并发控制技术>#</a></h3><ol><li><p>锁</p><ul><li><strong>一个锁实质上就是允许或阻止一个事务对一个数据对象的存取特权</strong>。 一个事务对一个对象加锁的结果是将别的事务“封锁”在该对象之外，特别是防止了其他事务对该对象的变更，而加锁的事务则可执行它所希望的处理并维持该对象的正确状态</li><li>确切的控制由封锁的类型决定。基本的封锁类型有两种：</li><li><strong>排他锁（ Exclusive lock，Ⅹ 锁）和共享锁（ Shared Lock, S 锁）</strong>。</li><li>写操作要求排它锁（X 锁），读操作要求共享锁（S 锁）</li></ul></li><li><p>用封锁进行并发控制</p><ol><li>若事务 T 对数据 D 加了 X 锁，则所有别的事务对数据 D 的锁请求都必须等待直到事务 T 释放锁</li><li>若事务 T 对数据 D 加了 S 锁，则别的事务还可对数据 D 请求 S 锁，而对数据 D 的 Ⅹ 锁请求必须等待直到事务 T 释放锁。</li><li>事务执行数据库操作时都要先请求相应的锁，即对读请求 S 锁，对更新（插入、删除、修改）请求 X 锁。这个过程一般是由 DBMS 在执行操作时自动隐含地进行。</li><li>事务一直占有获得的锁直到结束（ COMMIT 或 ROLLBACK）时释放。
因此，利用封锁机制可以解决上述并发操作所带来的三个不一致性问题。</li></ol></li><li><p>封锁的粒度</p><ul><li>通常以粒度来描述封锁的数据单元的大小。DBMS 可以决定不同粒度的锁。</li><li>由最底层的数据元素到最高层的整个数据库，粒度越细，并发性就越大，但软件复杂性和系统开销也就越大。锁住整个数据库，DBMS 的管理与控制最简单，只需设置和测试一个锁，故系统开销也最小。</li><li>然而对数据的存取则只能顺序进行，因而系统的总体性能大大下降。反之，数据元素层锁将提供最高的并发性，但 DBMS 要设置大量的锁装置来标识那些当前被封锁的数据元素，同时还要大量的锁检测，影响了每一事务的服务性能，系统总体性能也因此而下降。</li><li>所以，大多数高性能系统都选择折中的锁粒度，至于哪一层最合适，则与应用环境下事务量、数据量及数据的易变性特征等都紧密相关</li></ul></li><li><p>封锁的级别</p><ol><li>0 级封锁<ul><li>封锁的事务不重写其他非 0 级封锁事务的未提交的更新数据。这种状态实际上实用价值不大。</li></ul></li><li>1 级封<ul><li>锁被封锁的事务不允许重写未提交的更新数据。这防止了丢失更新的发生。</li></ul></li><li>2 级封锁<ul><li>被封锁的事务既不重写也不读未提交的更新数据。这除了 1 级封锁的效果外还防止了读脏数据。</li></ul></li><li><strong>3 级封锁</strong><ul><li>被封锁的事务不读未提交的更新数据，不写任何（包括读操作的）未提交数据。显然这除了包含 2 级封锁外，还不写未提交的读数据，因而防止了不可重读的问题。这是严格的封锁，它保证了多个事务并发执行的“可串行化”。</li></ul></li></ol></li><li><p>活锁与死锁</p></li></ol><p>活锁：活锁的处理方案：先来先服务
死锁：活锁的预防方案</p><ol><li><p>一次性锁请求</p><ul><li>每一事务在处理时一次提出所有的锁请求，仅当这些请求全部满足时事务处理才进行否则让其等待，这样则不会出现死锁的情况。这种方法实现简单，但因系统的并行性降低事务处理的等待时间加长，所以系统性能将下降</li></ul></li><li><p>锁请求排序</p><ul><li>将每个数据单元标以线性顺序，然后要求每一事务都按此顺序提出锁请求。这种方法也能防止死锁发生，但同样会降低系统的并行性</li></ul></li><li><p>序列化处理</p><ul><li>通过应用设计为每一数据单元建立一个“主人”程序，对给定数据单元的所有请求都发送给“主人”，而“主人”以单道的形式运行。这样系统可以是多道运行，但由于任何两道都不请求相同的数据单元，因而可避免死锁发生，但系统性能、数据的完整性可能受到影响。</li></ul></li><li><p>资源剥夺</p><ul><li>每当事务因锁请求不能满足而受阻时，强行令两个冲突的事务中的一个 ROLLBACK 释放所有的锁，以后再重新运行。使用这个方法必须注意防止活锁的发生</li></ul><p>对待死锁的另一种办法是不去防止，而让其发生并随时进行检测，一旦检测到系统已发生了死锁再进行解除处理。死锁检测可以用图论的方法实现，并以正在执行的事务为结点</p></li><li><p>可串行性</p></li></ol><ul><li><p>一组事务的一个调度就是它们的基本操作的一种排序。若在一个调度中，对于任意两个事务 T1 和 T2 ，要么 T1 的所有操作都在 T2 所有操作之前，要么反之，则该调度是串行的，因而是正确的。</p><ul><li>若一个调度等价于某一串行高度，即它所产生的结果与某一串行调度的结果样，则说调度是可串行化的（ Serializable）。</li><li>其中，需要指出的是：“可串行化的”不是调度本身“已串行化了”，只是其结果与某个串行调度一样；另外，一组事务的串行调度不是唯一的，因而可串行化的调度也不是唯一的。</li></ul></li><li><p>通常，在数据库系统中，<strong>可串行性就是并发执行的正确性准则</strong>，即当且仅当一组事务的并发执行调度是可串行化的，才认为它们是正确的</p><ol start=6><li>两段封锁法（Two- Phase Locking，2PL）</li></ol><p>两段封锁法是一种最简单而有效的保障封锁其调度是可串行性的方法。</p><ol><li><strong>发展</strong>（ Growing）或<strong>加锁</strong>阶段<ul><li>在此段期间，对任一数据对象进行任何操作之前，事务都要获得对该对象的一个相应的锁</li></ul></li><li><strong>收缩</strong>（ Shrinking）或<strong>释放锁</strong>阶段<ul><li>一旦事务释放了一个锁，则标明它已进入了此阶段，此后它就不能再请求任何另外的锁。</li></ul></li></ol><p>此外，关于两段锁协议有如下定理成立</p></li><li><p>定理 6.1：<strong>遵循两段锁协议的事务的任何并发调度都是可串行化的。</strong>
依据此定理，所有遵循 2PL 事务的任何并发执行的结果都是一致性的。需要指出的是，<code>2PL</code>是可串行化的充分条件，不是必要条件，即存在不全是<code>2PL</code>的事务的可串行化调度</p></li></ul><h2 id=第五章-备份与恢复>第五章 备份与恢复<a hidden class=anchor aria-hidden=true href=#第五章-备份与恢复>#</a></h2><p>数据备份是指通过导出数据或复制表文件的方式来制作数据库 的副本。
数据库恢复则是当数据库出现故障或遭到破坏时，将备份的数据库加载到系统，从而使数据库从错误状态恢复到备份时的正确状态。数据库的恢复是以备份为基础的，它是与备份相对应的系统维护和管理操作。</p><ul><li>数据丢失<ol><li>计算机硬件故障。</li><li>计算机软件故障。</li><li>病毒。</li><li>人为误操作。</li><li>自然灾害。</li><li>盗窃。</li></ol></li><li>MySQL 中使用 SQL 语句备份与恢复数据库中表数据的方法，这种方法有一点不足，就是只能导出或导入数据的内容，而不包括表的结构</li></ul><ol><li><p>使用 <code>select INTO… OUTFILE</code> 语句<strong>备份数据</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span> <span style=color:#af3a03>into</span> <span style=color:#af3a03>OUTFILE</span> <span style=color:#79740e>&#39;file_name&#39;</span> export_option
</span></span><span style=display:flex><span> <span style=color:#af3a03>|</span><span style=color:#af3a03>into</span> DUMPFILE <span style=color:#79740e>&#39;file_name&#39;</span>
</span></span></code></pre></div><p>语法项“ export options”的格式是：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>[FIELDS
</span></span><span style=display:flex><span> [<span style=color:#af3a03>TERMINATED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;string&#39;</span>]
</span></span><span style=display:flex><span> [[<span style=color:#af3a03>OPTIONALLY</span>]<span style=color:#af3a03>ENCLOSED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;char&#39;</span>]
</span></span><span style=display:flex><span> [<span style=color:#af3a03>ESCAPED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;char&#39;</span>]
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>LINES</span> TERMNIATED <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;string&#39;</span>]
</span></span></code></pre></div><ol><li>语法项" <code>file name</code>&ldquo;指定数据备份文件的名称。<ul><li>文件默认在服务器主机上创建，并且文件名不能是已经存在的，否则可能会将原文件覆盖。</li><li>如果要将该文件写入到一个特定的位置，则要在文件名前加上具体的路径。在文件中，导出的数据行会以一定的形式存储，其中空值是用"N"表示。</li></ul></li><li>导出语句中使用关键字&rdquo; <code>OUTFILE</code>&ldquo;时，可以在语法项&rdquo; <code>export options</code>&ldquo;中加入以下两个自选的子句，即 <code>FIELDS</code>子句和<code>LINES</code>子句，它们的作用是决定数据行在备份文件中存储的格式。<ul><li>如果 <code>FIELDS</code>和 <code>LINES</code>子句都不指定，则默认声明的是子句&rdquo; <code>FIELDS TERMINATED by '\t' ENCLOSED by '' ESCAPED by '\\' LINES TERMINATED by '\n'</code></li></ul></li><li>语法项" <code>FIELDS</code>子句"中有三个亚子句，分别是" <code>TERMINATED by</code>子句” “<code>[OPTIONALLY] ENCLOSED by</code>子句" 和 " <code>ESCAPED by</code>子句"。<ul><li>如果指定了 <code>FIELDS</code>子句，则这三个亚子句中至少要求指定一个。</li><li>其中， <code>TERMINATED by</code>子句用来指定字段值之间的符号，例如" <code>TERMINATED by ','</code>&ldquo;指定逗号作为两个字段值之间的标志；</li><li><code>ENCLOSED by</code>子句用来指定包裹文件中字符值的符号，例如&rdquo; <code>ENCLOSED by '"'</code>&ldquo;表示文件中字符值放在双引号之间，若加上关键字&rdquo; <code>OPTIONALLY</code>&ldquo;则表示所有的值都放在双引号之间；</li><li><code>ESCAPED by</code>子句用来指定转义字符，例如&rdquo; <code>ESCAPED by '*'</code>&ldquo;将&rdquo;<code>*</code>&ldquo;指定为转义字符，取代<code>"\"</code>，如空格将表示为&rdquo;<code>*N</code>"。</li></ul></li><li>在 LNES 子句中使用关键字" <code>TERMINATED by</code>&ldquo;指定一个数据行结束的标志，如
" <code>LINES TERMINATED by '?'</code>表示一个数据行以&rdquo;<code>?</code>&ldquo;作为结束标志</li><li>导出语句中使用的是关键字&rdquo; <code>DUMPFILE</code>"，而非" <code>OUTFILE</code>&ldquo;时，导出的备份文件里面所有的数据行都会彼此紧挨着放置，即值和行之间没有任何标记。</li></ol></li><li><p>使用 <code>LOAD DATA… INFILE</code> 语句<strong>恢复数据</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>LOAD</span> DATA <span style=color:#af3a03>INFILE</span> <span style=color:#79740e>&#39;file_name.txt&#39;</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>into</span> <span style=color:#af3a03>table</span> tbl_name
</span></span><span style=display:flex><span> [FIELDS
</span></span><span style=display:flex><span>  [<span style=color:#af3a03>TERMINATED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;string&#39;</span>]
</span></span><span style=display:flex><span>  [[<span style=color:#af3a03>OPTIONALLY</span>]<span style=color:#af3a03>ENCLOSED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;char&#39;</span>]
</span></span><span style=display:flex><span>  [<span style=color:#af3a03>ESCAPED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;char&#39;</span>]
</span></span><span style=display:flex><span> ]
</span></span><span style=display:flex><span> [<span style=color:#af3a03>LINES</span>
</span></span><span style=display:flex><span>  [<span style=color:#af3a03>STARTING</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;string&#39;</span>]
</span></span><span style=display:flex><span>  [<span style=color:#af3a03>TERMINATED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;string&#39;</span>]
</span></span><span style=display:flex><span> ]
</span></span></code></pre></div><ol><li>语法项“ <code>file name</code>”指定待导入的数据库备份文件名，文件中保存了待载入数据库的所有数据行。<ul><li>输入文件可以手动创建，也可以使用其他的程序创建。</li><li>导入文件时可以指定文件的绝对路径，则服务器会根据该路径搜索文件；若不指定路径，则服务器在默认数据库的数据库目录中读取。</li></ul></li><li>语法项“ <code>tb name</code>”指定需要导入数据的表名，该表在数据库中必须存在，表结构必须与导入文件的数据行一致。</li><li>此处的 <code>FIELDS</code>子句和 <code>SELECT… .into OUTFILE</code>语句中的 <code>FIELDS</code>子句类似，用于判断字段之间和数据行之间的符号。</li><li>语法项“<code>LNES</code>子句”中的 <code>TERMINATED by</code>亚子句用来指定一行结束的标志<code>STARTING by</code>亚子句则指定一个前缀，导入数据行时，忽略数据行中的该前缀和前缀之前的内容。如果某行不包括该前缀，则整个数据行被跳过。</li></ol></li></ol><ul><li><p>例 6.17 备份数据库 <code>test_db</code>中表 <code>customers</code>的全部数据到 C 盘的 <code>BACKUP</code> 目录下个名为 <code>backupfile. txt</code>的文件中，要求字段值如果是字符则用双引号标注，字段值之间用逗号隔开，每行以问号为结束标志。然后，将备份后的数据导入到一个和 <code>customers</code>表结构相同的空表 <code>customers copy</code>中。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>select</span><span style=color:#af3a03>*</span><span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span> <span style=color:#af3a03>into</span> <span style=color:#af3a03>OUTFILE</span> <span style=color:#79740e>&#39;D:/BACKUP/backupfile.txt&#39;</span>
</span></span><span style=display:flex><span>    FIELDS <span style=color:#af3a03>TERMINATED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;,&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>OPTIONALLY</span> <span style=color:#af3a03>ENCLOSED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;&#34;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>LINES</span> <span style=color:#af3a03>TERMINATED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;?&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span><span style=color:#af3a03>from</span> test_db.customers;
</span></span><span style=display:flex><span><span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span><span style=color:#af3a03>from</span> test_db.customers_copy;
</span></span><span style=display:flex><span><span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> test_db.customers <span style=color:#af3a03>drop</span> <span style=color:#af3a03>column</span> cust_city;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>table</span> <span style=color:#b57614>customers_copy</span>
</span></span><span style=display:flex><span>(
</span></span><span style=display:flex><span>cust_id <span style=color:#b57614>INT</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>cust_name <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>cust_sex <span style=color:#b57614>char</span>(<span style=color:#8f3f71>1</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>default</span> <span style=color:#8f3f71>0</span>,
</span></span><span style=display:flex><span>cust_address <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>cust_contact <span style=color:#b57614>char</span>(<span style=color:#8f3f71>50</span>) <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span><span style=color:#af3a03>primary</span> <span style=color:#af3a03>key</span>(cust_id)
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>LOAD</span> DATA <span style=color:#af3a03>INFILE</span> <span style=color:#79740e>&#39;D:/BACKUP/backupfile.txt&#39;</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>into</span> <span style=color:#af3a03>table</span> test_db.customers_copy
</span></span><span style=display:flex><span>    FIELDS <span style=color:#af3a03>TERMINATED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;,&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>OPTIONALLY</span> <span style=color:#af3a03>ENCLOSED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;&#34;&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>LINES</span> <span style=color:#af3a03>TERMINATED</span> <span style=color:#af3a03>by</span> <span style=color:#79740e>&#39;?&#39;</span>;
</span></span></code></pre></div><ul><li><p>在导入数据时需要特别注意，必须根据数据备份文件中数据行的格式来指定判断的符号。例如，在 <code>backupfile. txt</code>文件中字段值是以逗号隔开的，导入数据时就一定要使用<code>TERMINATED BY；</code>”子句指定逗号为字段值之间的分隔符，即与 <code>SELECT…INTo OUTFILE</code>语句相对应</p></li><li><blockquote><p><strong>Error Code] 1290 - The MySQL server is running with the &ndash;secure-file-priv option 解决办法</strong></p><p>1.进入 mysql 查看 secure_file_prive 的值</p><p>$mysql -u root -p</p><p>mysql>show VARIABLES like &ldquo;secure_file_priv&rdquo;;</p><p>secure_file_prive=null &ndash; 限制 mysqld 不允许导入导出</p><p>secure_file_priv=/tmp/ &ndash; 限制 mysqld 的导入导出只能发生在/tmp/目录下</p><p>secure_file_priv=&rsquo; &rsquo; &ndash; 不对 mysqld 的导入 导出做限制</p><p>2.更改 secure_file_pri 的值</p><p>找到 my.ini 配置文件，加入在 mysqld 目录下，secure_file_priv=&rsquo;&rsquo;，重启 mysql 服务器即可。</p></blockquote></li></ul></li><li><p>另外需要注意的是，在多个用户同时使用 MySQL 数据库的情况下，为了得到一个一致的备份，需要在指定的表上使用 <code>LOCK tables table name READ</code>语句做一个读锁定，以防止在备份过程中表被其他用户更新；而当恢复数据时，则需要使用 <code>LOCK tables table name WritE</code>语句做一个写锁定，以避免发生数据冲突。在数据库备份或恢复完毕之后需要使用 <code>UNLOCK tables</code>语句对该表进行解锁。</p></li></ul><h1 id=第七章-数据库应用设计与开发实例>第七章 数据库应用设计与开发实例<a hidden class=anchor aria-hidden=true href=#第七章-数据库应用设计与开发实例>#</a></h1><h2 id=第一节-需求描述与分析>第一节 需求描述与分析<a hidden class=anchor aria-hidden=true href=#第一节-需求描述与分析>#</a></h2><ul><li>结合某高校个性化课程在线选课的实际需求，给出一个简化的需求分析。</li><li>经过调研，得知选课系统的用户类型有教务管理员、学生和教师</li></ul><h3 id=711-功能性需求>7.1.1 功能性需求<a hidden class=anchor aria-hidden=true href=#711-功能性需求>#</a></h3><ol><li><p>管理员后台模块</p><p>管理员后台是专门为教务管理员使用的，主要用于系统的数据管理，包括学生管理、教师管理、班级管理和课程管理，其具体的功能需求如下。</p><ol><li>学生信息管理用于对学生进行管理。<ul><li>例如，若有学生信息发生变化时，管理员可及时补充或更正学生信息</li></ul></li><li>教师信息管理用于对教师进行管理。<ul><li>例如，当教师出现工作部门调动或职称变动等情况时，教务管理员需要及时修正教师信息。</li></ul></li><li>课程信息管理用于管理个性化课程。<ul><li>每一门个性化课程的信息都会在此模块中显示，如果遇到课程安排发生变动时，则要求管理员及时更正课程信息，以方便学生选课</li></ul></li><li>班级信息管理用于对班级进行管理。<ul><li>从建立一个班级开始，其信息已经基本固定下来，唯一有可能变化的就是班级人数。当有一名新学生加入班级时，学生人数自动加 1；相反，当有一名学生转专业、留级、休学或退学时，班级人数自动减 1。</li></ul></li></ol></li><li><p>学生使用模块</p><p>学生是使用个性课程选课系统的主体，学生使用学号和初始密码登录，在主页可以浏览到所有的课程信息并进行选课。学生使用模块包含三个功能，具体功能需求如下。</p><ol><li>查询课程根据学生输入的检索条件和值，模糊查询满足条件的课程。</li><li>浏览所选课程显示该学生选的所有课程。</li><li>查询成绩学生可以査看本人所选课程的最终成绩。</li></ol></li><li><p>教师使用模块</p><p>此模块主要完成教师登分和查询本人开设课程的操作。教师使用工号和初始密码登录系统，在教师主页可以査看所有的课程。教师使用模块有两个功能，其功能需求如下。</p><ol><li>我的课程负责显示教师本人开设的所有课程。</li><li>登分通过此功能，每位教师可以为所有的选择自己开设课程的学生录入分数到本系统中，以供学生查询和教务管理员统计分数。</li></ol></li></ol><h3 id=712-非功能性需求>7.1.2 非功能性需求<a hidden class=anchor aria-hidden=true href=#712-非功能性需求>#</a></h3><ul><li><p>作为一个基于网络的在线选课系统，本系统采用浏览器/服务器（BS）结构，即一种基于 Web 应用的客户服务器结构，因而对于客户端和服务器端，分别有不同的软、硬件环境需求。客户端要能在支持 IE 的浏览器上运行，并在客户机上安装了网卡；服务器要求部署 WAMP 环境，即使用 Windows 作为操作系统， Apache 作为 Web 服务器， MySQL 作为数据库管理系统，PHP 语言作为服务器端脚本解释器，同时要求具有 8GB 内存、2TB 磁盘容量、千兆带宽。</p></li><li><p>此外，还需要考虑质量要求。有关选课系统质量需求描述如 表 7.1 所示</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930163110112.png alt=image-20200930163110112></p></li></ul><h2 id=第二节-系统设计>第二节 系统设计<a hidden class=anchor aria-hidden=true href=#第二节-系统设计>#</a></h2><h3 id=721-功能模块设计>7.2.1 功能模块设计<a hidden class=anchor aria-hidden=true href=#721-功能模块设计>#</a></h3><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930163139906.png alt=image-20200930163139906></p><ol><li><p>登录验证模块</p><ul><li>此模块用于用户登录系统，只有当用户的身份信息被检验成功后，才可以进入系统，否则要重新登录。</li></ul></li><li><p>管理员后台模块</p><ul><li>此模块有学生信息管理、教师信息管理、课程信息管理、班级信息管理的功能，主要用于教务管理员对系统数据的日常维护，向学生和教师提供数据支撑，如 图 7.2 所示。</li></ul></li><li><p>学生使用模块</p><ul><li>学生模块可以査询课程、浏览已选课程、查询成绩和选/退课程，如 图 7.3 所示。</li></ul><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930163248832.png alt=image-20200930163248832></p><p>此模块主要用于学生自主选课，学生单击下拉菜单并选择课程类别、学分、教师、上课时间、上课地点、课程编号、课程名称等检索项并输入关键字来査询课程。例如，单击系统主页的课程编码可以査看课程细节并进行选课，如果想退选，则进入浏览已选课程模块单击课程编码进行退选，且当考试结束后，可查询成绩。</p></li><li><p>教师使用模块</p><ul><li>如 图 7.4 所示，教师可以在所有课程中浏览到自己的课程，并能知道每门课程的上课时间和上课地点等相关课程信息。此模块还用于教师给学生登分，教师进入登分模块单击下拉菜单中的某门课程，依次把所有学生的分数输入到系统中，以便学生可以查询成绩</li></ul><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930163358628.png alt=image-20200930163358628></p></li></ol><h3 id=722-数据库设计>7.2.2 数据库设计<a hidden class=anchor aria-hidden=true href=#722-数据库设计>#</a></h3><ul><li>根据系统的功能模块设计结果，以及前期的需求分析，可首先明确本系统的数据库范围，然后可通过使用 ER 图作为数据库概念设计的描述工具，建立本系统所涉及的局部信息结构，再将各个局部信息结构合并成为一个优化的全局信息结构，最后将全局信息结构的 E R 图转换为关系模型，并依据关系数据库规范化理论进行优化。</li></ul><ol><li><p>确定实体</p><ol><li><p>学生实体 用于描述学生的基本信息，包括学号、姓名、性别、密码等信息。</p></li><li><p>教师实体 用于描述教师的基本信息，包括教师工号、姓名、性别、年龄、职称、密码等信息</p></li><li><p>课程实体 用于描述课程的基本信息，包括课程号、课程名、学分、时间、地点、类别、开课学院、限选人数等信息。</p></li><li><p>院系实体 用于描述院系的基本信息，包括院系名称、办公地点、教师人数等信息。</p></li><li><p>系统管理员实体 用于描述系统管理员的基本信息，包括姓名、ID 号、密码等信息</p><p>需要注意的是：在数据库设计时，实体的描述信息可根据实际需求进行增加或删减，如果实体的属性较多，在构建 ER 模型时不一定需要把所有的属性都标识在 ER 模型上，可以另外用文字说明，这样也使得 ER 模型简明清晰，便于分析。</p></li></ol></li><li><p>局部信息结构</p><ol><li><p><strong>学生课程 ER 图</strong>如 图 7.5 所示，其描述了学生实体与课程实体之间的联系。其中，学生实体与课程实体之间的联系命名为“选修”，它是一个多对多的联系（M:N），即每个生可以选修多门个性化课程，同时每门个性化课程也可以被多名学生所选修。</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174535442.png alt=image-20200930174535442></p></li><li><p><strong>教师课程 ER 图</strong>如 图 7.6 所示，其描述了教师实体与课程实体之间的联系。其中教师实体与课程实体之间的联系命名为“授课”，它是一个一对多的联系（1:N），即每位教师可以教授多门个性化课程，但每门个性化课程只能由一名教师来教授。</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174552486.png alt=image-20200930174552486></p></li><li><p><strong>教师-院系 E-R 图</strong>如 图 7.7 所示，其描述了教师实体与院系实体之间的联系。其中，院系实体与教师实体之间的联系命名为“属于”，它是一个一对多的联系（1:N），即每个院系可以拥有多位教师，但每位教师只能在一个院系里任职。</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174613413.png alt=image-20200930174613413></p></li><li><p><strong>学生院系 ER 图</strong>如图 7.8 所示，其描述了学生实体与院系实体之间的联系。其中院系实体与学生实体之间的联系命名为“属于”，它是一个一对多的联系（1:N），即每个院系可以包含多名学生，但每名学生只能在一个院系里就读。</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174631366.png alt=image-20200930174631366></p></li><li><p><strong>系统管理员学生 E-R 图</strong>如 图 7.9 所示，其描述了系统管理员实体与学生实体之间的联系。其中，系统管理员实体与学生实体之间的联系命名为“管理”，它是一个多对多的联系（M:N），即每个系统管理员可以管理多名学生的信息，同时每名学生的信息可以被多个系统管理员管理。</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174642637.png alt=image-20200930174642637></p></li><li><p><strong>系统管理员-教师 ER 图</strong>如 图 7.10 所示，其描述了系统管理员实体与教师实体之间的联系。其中，系统管理员实体与教师实体之间的联系命名为“管理”，它是一个多对多的联系（M:N），即每个系统管理员可以管理多位教师的信息，同时每位教师的信息可以被多个系统管理员管理。</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174659325.png alt=image-20200930174659325></p></li><li><p><strong>系统管理员-课程 E-R 图</strong>如 图 7.11 所示，其描述了系统管理员实体与课程实体之间的联系。其中，系统管理员实体与课程实体之间的联系命名为“管理”，它是一个多对多的联系（M:N），即每个系统管理员可以管理多门课程的信息，同时每门课程的信息可以被多个系统管理员管理</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174717661.png alt=image-20200930174717661></p></li><li><p><strong>系统管理员-院系 ER 图</strong>如 图 7.12 所示，其描述了系统管理员实体与院系实体之间的联系。其中，系统管理员实体与院系实体之间的联系命名为“管理”，它是一个多对多的联系（M:N），即每个系统管理员可以管理多个院系的信息，同时每个院系的信息可以被多个系统管理员管理。</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174729526.png alt=image-20200930174729526></p></li></ol></li><li><p>全局信息结构</p><p>在构建出上述局部信息结构的基础上，通过采用逐步合并、进行累加的方式，以及消除可能存在的属性冲突、命名冲突和结构冲突，最终形成一个本系统的全局信息结构。</p><ol><li><p>首先将学生课程 ER 图、教师-课程 E-R 图、教师-院系 ER 图、学生-院系 ER 图合并成为一个较大的局部信息结构，即学生-教师-课程-院系 E-R 图，用于描述学生、教师、课程及院系四个实体之间的联系，如图 713 所示。其中，在教师院系 ER 图和学生院系 ER 图中均有同名的联系“属于”，但其实质内容是不同的，因而在合并这两个 ER 图时，应当为这两个同名的联系重新命名，分别是：“任职”和“从属”</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174822479.png alt=image-20200930174822479></p></li><li><p>同样，再将系统管理员-学生 ER 图、系统管理员-教师 E-R 图、系统管理员-课程 E-R 图、系统管理员-院系 ER 图合并成为另一个较大的局部信息结构，即系统管理员学生-教师课程-院系 ER 图，用于描述系统管理员实体与学生、教师、课程及院系四个实体之间的联系，如图 7.14 所示。其中，在系统管理员学生 ER 图、系统管理员-教师 ER 图、系统管理员-课程 ER 图、系统管理员-院系 ER 图中均有同名的联系“管理”，但其实质内容是不同的，因而在合并这 4 个 ER 图时，应当为这 4 个同名的联系重新命名，分别是：“管理学生”“管理教师”“管理课程”“管理院系”</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930174906569.png alt=image-20200930174906569></p></li><li><p>最后，将学生-教师-课程院系 ER 图和系统管理员-学生-教师课程-院系 ER 图合并成为一个本系统的全局 ER 图，如 图 7.15 所示。</p></li></ol></li><li><p>逻辑结构与规范化设计</p><ul><li>形成本系统的全局 ER 模型之后，即可开展关系数据库的逻辑结构设计了，也就是设计本数据库应用软件的基本关系模式。根据第三章介绍的 ER 图向关系模型转换的原则，可将图 7.15 所示的全局 ER 图转换为如下一些关系模式，其中主码用下划线标识。<ul><li>学生（学号、姓名、性别、登录密码、院系编号）</li><li>院系（院系编号、系名、学生人数、教师人数、办公地点）</li><li>教师（职工号、姓名、性别、年龄、职称、登录密码、院系编号）</li><li>课程（课程号、课程名称、课程类别、学分、上课时间、上课地点、开课学院、限选人数、职工号）</li><li>系统管理员（ID 号、姓名、登录密码）</li><li>选修（学号、课程号、成绩）</li><li>管理学生（管理员 ID 号、学号、操作时间）</li><li>管理院系（管理员 ID 号、院系编号、操作时间）</li><li>管理教师（管理员 ID 号、职工号、操作时间）</li><li>管理课程（管理员 ID 号、课程号、操作时间）</li></ul></li></ul><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175054177.png alt=image-20200930175054177></p></li></ol><ul><li>由此可见，上述转换是<ul><li>将全局 ER 图中的 5 个实体直接转换成了 5 个对应的关系模式即“学生”“院系”“教师”“课程”和“系统管理员”；</li><li>而后将全局 E-R 图中 3 个一对多（1：N）联系分别与对应的关系模式进行了合并，即“学生”“教师”“课程”；</li><li>最后是将全局 ER 图中 5 个多对多（MN）联系分别转换成 5 个独立的关系模式，且各关系的码分别是各自联系两端的实体码的组合。</li></ul></li><li>在将 ER 图转换为关系模式之后，还需要进一步分析各关系模式是否符合第三范式的要求。如若不符合，则通常需要将这些关系模式分解为符合第三范式要求的关系模式，从而实现数据库的规范化设计。</li><li>由此，根据第二章介绍的关系规范化理论，经分析发现：<ul><li>在上述这些关系模式中，“学生”“教师”“系统管理员”“选修”“管理学生”“管理院系”“管理教师”“管理课程”等 8 个关系模式既不存在部分函数依赖，也不存在传递函数依赖，满足第三范式要求；</li><li>而“院系”尽管不存在部分函数依赖，满足第二范式要求，但存在着传递函数依赖，故需要进一步分解，以满足第三范式的要求，其可分解成关系模式“院系编码（院系编号、系名）”和关系模式“院系（院系编号、学生人数、教师人数、办公地点）”；</li><li>同样，“课程”也是尽管不存在部分函数依赖，满足第二范式要求，但存在着传递函数依赖，需要进一步分解，以满足第三范式的要求，其可分解成关系模式“课程编码（课程号、课程名称）”和关系模式“课程（课程号、课程类别、学分、上课时间、上课地点、开课学院、限选人数、职工号）”。</li></ul></li></ul><h2 id=第三节-系统实现>第三节 系统实现<a hidden class=anchor aria-hidden=true href=#第三节-系统实现>#</a></h2><ul><li>按照数据库应用软件开发步骤的划分，在完成系统的数据库设计和功能设计之后，就可以采用相应的数据库管理系统和应用软件开发语言，分别实现系统的数据库和业务功能，即数据库实现和系统功能实现。这里，数据库实现是基于 MSQL 数据库来完成，系统的业务功能是采用 PP 语言来开发（关于使用 PHP 语言开发数据库应用的有关知识，读者可自行参阅本书附录 2）。</li></ul><ol><li><p>数据库的实现</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>database</span> db_xuanke;
</span></span></code></pre></div><p>然后，根据本应用数据库逻辑结构设计所得出的关系模式，通过使用 MySQL 数据库的 <code>create table</code> 命名，在数据库 <code>db xuanke</code> 中创建 12 张数据表，并建立各表的主键，从而构成主键索引。</p><ul><li>这些表的结构定义分别如表 7.2-7.13 所示。</li></ul><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175341555.png alt=image-20200930175341555></p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175355987.png alt=image-20200930175355987></p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175415535.png alt=image-20200930175415535></p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175436153.png alt=image-20200930175436153></p></li><li><p>系统功能的实现</p><p>实现数据库行为实现数据库行为是实现数据库行为设计的结果，主要是通过 SQL 语言完成与本应用功能相关的增、删、改、查等数据库操作，也包括为提髙数据库操作效率或保护数据库安全而创建的各种数据库对象，例如子査询、视图、触发器、存储过程或存储函数等。</p><ol><li><p>安全控制</p><p>例如，为新来的教务管理人员金老师（用户名 <code>jin</code>）分配具备管理学生、院系、教师和课程的权限，可在数据库中编写如下 SQL 语句实现：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>grant</span> <span style=color:#af3a03>select</span>,<span style=color:#af3a03>update</span>,<span style=color:#af3a03>insert</span>,<span style=color:#af3a03>delete</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>on</span> db_xuanke.<span style=color:#af3a03>*</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>TO</span> <span style=color:#79740e>&#39;jin&#39;</span><span style=color:#af3a03>@</span><span style=color:#79740e>&#39;localhost&#39;</span>
</span></span></code></pre></div></li><li><p>管理学生。
例如，教务管理人员金老师需要在学生管理功能中添加一名计算机学院的女生黄然同学时，可在数据库中编写如下 SQL 语句实现</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> db_xuanke.student
</span></span><span style=display:flex><span> <span style=color:#b57614>set</span> StuNo<span style=color:#af3a03>=</span><span style=color:#8f3f71>20170922</span>,StuName<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;黄然&#39;</span>,StuSex<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;女&#39;</span>,Pwd<span style=color:#af3a03>=</span><span style=color:#af3a03>default</span>,DeptNo<span style=color:#af3a03>=</span>
</span></span><span style=display:flex><span> <span style=color:#af3a03>select</span> DeptNo <span style=color:#af3a03>from</span> db_xuanke.deptcode <span style=color:#af3a03>where</span> DeptName<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;计算机学院&#39;</span>;
</span></span></code></pre></div></li><li><p>数据库保护。
例如，当每位教师进行登分操作时，系统需要根据教师所登分数值进行自动验证，判断该分数值是否位于 0~100 分区间，以此保护数据库中数据的正确性，因而可在数据库中编写如下 SQL 语句实现：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> <span style=color:#af3a03>TRIGGER</span> tri_test after <span style=color:#af3a03>insert</span> <span style=color:#af3a03>on</span> db_xuanke.electing
</span></span><span style=display:flex><span> <span style=color:#af3a03>FOR</span> <span style=color:#af3a03>EACH</span> ROW BEGIN
</span></span><span style=display:flex><span><span style=color:#af3a03>if</span> NEW.Score<span style=color:#af3a03>&lt;</span><span style=color:#8f3f71>0</span> <span style=color:#af3a03>and</span> NEW.Score<span style=color:#af3a03>&gt;</span><span style=color:#8f3f71>100</span> <span style=color:#af3a03>then</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>delete</span> <span style=color:#af3a03>from</span> db_xuanke.electing <span style=color:#af3a03>where</span> Score<span style=color:#af3a03>=</span>NEW.Score
</span></span><span style=display:flex><span>END <span style=color:#af3a03>if</span>
</span></span><span style=display:flex><span>END;
</span></span></code></pre></div></li><li><p>事务与并发控制。
例如，教务管理人员金老师需要批量录入教师信息时，为防止其他操作对数据的影响可通过使用事务处理来维护数据库的完整性，因而可在数据库中编写如下 SQL 语句实现：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>BEGIN; <span style=color:#928374;font-style:italic>#开始事务
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> db_xuanke.teacher <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>10021</span>,<span style=color:#79740e>&#39;万明&#39;</span>,<span style=color:#d3869b>null</span>,<span style=color:#d3869b>null</span>,<span style=color:#d3869b>null</span>,<span style=color:#af3a03>default</span>,<span style=color:#8f3f71>10</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> db_xuanke.teacher <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>10073</span>,<span style=color:#79740e>&#39;黄新&#39;</span>,<span style=color:#d3869b>null</span>,<span style=color:#d3869b>null</span>,<span style=color:#d3869b>null</span>,<span style=color:#af3a03>default</span>,<span style=color:#8f3f71>10</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> db_xuanke.teacher <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>11031</span>,<span style=color:#79740e>&#39;徐丽&#39;</span>,<span style=color:#d3869b>null</span>,<span style=color:#d3869b>null</span>,<span style=color:#d3869b>null</span>,<span style=color:#af3a03>default</span>,<span style=color:#8f3f71>11</span>);
</span></span><span style=display:flex><span>COMMIT; <span style=color:#928374;font-style:italic>#提交事务
</span></span></span></code></pre></div></li><li><p>数据查询与统计报表。
在数据库应用系统中，数据查询是最常用的功能，其应根据用户提出的查询条件实现相应的查询功能。其中，生成统计报表是很多数据库应用软件所提供的一个功能。例如，在本选课系统中，可以为教务管理人员提供统计每个学生选修课程总学分的报表，因而这个用户需求可以通过使用 SQL 语句定义如下视图来实现</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>create</span> VIEW <span style=color:#b57614>v_score</span>(StuNo,totlescore)
</span></span><span style=display:flex><span><span style=color:#af3a03>as</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>select</span> student.Student.StuNo,<span style=color:#b57614>SUM</span>(course.Credit)
</span></span><span style=display:flex><span><span style=color:#af3a03>from</span> student <span style=color:#af3a03>JOIN</span> electing <span style=color:#af3a03>on</span> student.StuNo<span style=color:#af3a03>=</span>electing.StuNo
</span></span><span style=display:flex><span><span style=color:#af3a03>JOIN</span> course <span style=color:#af3a03>on</span> course.CourseNo<span style=color:#af3a03>=</span>electing.CourseNo
</span></span><span style=display:flex><span><span style=color:#af3a03>where</span> electing.Scoure<span style=color:#af3a03>&gt;=</span><span style=color:#8f3f71>60</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span> student.StuNo;
</span></span></code></pre></div></li></ol></li><li><p>实现应用软件的业务逻辑</p><ul><li>这一阶段的开发工作主要是根据系统功能设计的结果，分别逐个实现各个功能模块。其中，各模块与底层数据库的交互操作，是通过应用软件的编程语言（如 PHP）进行封装的。</li><li>这里，以本系统的登录验证模块为例，简单描述其实现过程。</li><li>首先，使用网页设计语言 HTML/CSS 实现如 图 716 所示的系统登录验证页面</li><li>然后，通过使用 PHP 编程语言编写相应的服务器端代码，完成此登录验证页面与后台数据库的交互操作，具体包括建立与 MSQL 数据库服务器的连接，査询数据库表 student、 teacher administrator I 中是否存在通过登录验证页面表单采用 POST 方式传递到后台服务器的数据。</li><li>最后，后台服务器根据在数据库中进行查询操作的返回结果，向网络页面请求用户做出相应的反馈，即若查询操作返回存在数据的结果集，则用户正常登录系统，否则用户无法登录系统。</li></ul></li></ol><h2 id=第四节-系统测试与维护>第四节 系统测试与维护<a hidden class=anchor aria-hidden=true href=#第四节-系统测试与维护>#</a></h2><ul><li>完成系统的实现工作之后，在正式交付用户使用之前，需要对所开发的系统进行必要的测试，验证其是否满足用户的功能要求，并根据测试的结果，以及用户的反馈意见，对该系统进行进一步的修改、完善和维护工作。例如，在本系统中，可以分别针对不同的功能模块制定相应的测试方案</li></ul><ol><li><p>登录验证功能测试</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175840977.png alt=image-20200930175840977></p></li><li><p>管理员后台主要功能测试</p><ol><li><p>学生信息管理功能</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175906741.png alt=image-20200930175906741></p></li><li><p>课程信息管理功能</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175925624.png alt=image-20200930175925624></p></li></ol></li><li><p>学生使用模块功能测试</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930175944679.png alt=image-20200930175944679></p></li><li><p>教师使用模块功能测试</p><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930180022645.png alt=image-20200930180022645></p></li></ol><h2 id=本章小结>本章小结<a hidden class=anchor aria-hidden=true href=#本章小结>#</a></h2><h1 id=第八章-数据管理技术的发展>第八章 数据管理技术的发展<a hidden class=anchor aria-hidden=true href=#第八章-数据管理技术的发展>#</a></h1><h2 id=第一节-数据库技术发展概述>第一节 数据库技术发展概述<a hidden class=anchor aria-hidden=true href=#第一节-数据库技术发展概述>#</a></h2><ul><li>数据模型是数据库系统的核心和基础。以数据模型的发展为主线，数据库技术可以相应地分为三个发展阶段，即<strong>第一代的网状、层次数据库系统，第二代的关系数据库系统，以及新一代的数据库系统</strong></li></ul><h3 id=811-第一代数据库系统>8.1.1 第一代数据库系统<a hidden class=anchor aria-hidden=true href=#811-第一代数据库系统>#</a></h3><ul><li>第一代数据库系统有如下两类代表。<ol><li>1969 年 IBM 公司研制的<strong>层次模型数据库管理系统</strong> IMS</li><li>美国数据库系统语言研究会（ CODASYL）下属的数据库任务组（DBTG）对数据库方法进行了系统的研究和探讨，于 20 世纪 60 年代末 70 年代初提出了若干报告，称为 DBTG 报告。DBTG 报告确定并建立了数据库系统的许多概念、方法和技术。<strong>DBTG 所提议的方法是基于网状结构的，是网状模型数据库系统的典型代表</strong>。</li></ol></li><li>这两类数据库系统具有以下几个共同特点。<ol><li><strong>支持三级模式（外模式、模式、内模式）的体系结构。</strong> 模式之间具有转换（或称为映射）功能。</li><li><strong>用存取路径来表示数据之间的联系。</strong> 这是数据库系统和文件系统的主要区别之数据库不仅存储数据，而且存储数据之间的联系。数据之间的联系在层次和网状数据库系统中都是用存取路径来表示和实现的。</li><li><strong>独立的数据定义语言。</strong> 层次数据库系统和网状数据库系统有独立的数据定义语言，用以描述数据库的三级模式以及相互映像。诸模式一经定义，就很难修改。</li><li><strong>导航的数据操纵语言。</strong> 层次和网状数据库的数据查询和数据操纵语言是一次一个记录的导航式的过程化语言。这类语言通常嵌入某一种高级语言，例如 COBOL、 FORTRAN、C 语言中。</li></ol></li></ul><h3 id=812-第二代数据库系统-20世纪70年代称为数据库时代>8.1.2 第二代数据库系统 （20世纪70年代，称为数据库时代）<a hidden class=anchor aria-hidden=true href=#812-第二代数据库系统-20世纪70年代称为数据库时代>#</a></h3><p>把 20 世纪 70 年代称为数据库时代。20 世纪 80 年代几乎所有新开发的 DBMS 均是关系数据库系统。
关系数据库是以关系模型为基础的，而关系模型是由<strong>数据结构、关系操作和数据完整性</strong>三部分组成。
关系模型不仅简单、清晰，而且由关系代数作为语言模型，由关系数据理论作为理论基础。
因此，第二代关系数据库系统具有<strong>模型简单清晰、理论基础好、数据独立性强、数据库语言非过程化和标准化</strong>等特点。</p><h3 id=813-第三代数据库系统>8.1.3 第三代数据库系统<a hidden class=anchor aria-hidden=true href=#813-第三代数据库系统>#</a></h3><ol><li><p>第三代数据库系统应<strong>支持数据管理、对象管理和知识管理</strong>，除提供传统的数据管理服务外，第三代数据库系统将支持更加丰富的对象结构和规则，应该集数据管理、对象管理和知识管理为一体。《宣言》认为，无论该数据库系统支持何种复杂的、非传统的数据模型，它应该具有面向对象模型的基本特征。数据模型是划分数据库发展阶段的基本依据。因此，第三代数据库系统应该是以支持面向对象数据模型为主要特征的数据库系统。但是，只支持面向对象模型的系统不能称为第三代数据库系统。第三代数据库系统还应具备其他特征。</p></li><li><p>第三代数据库系统<strong>必须保持或继承第二代数据库系统的技术</strong>，第三代数据库系统必须保持第二代数据库系统的非过程化数据存取方式和数据独立性应继承第二代数据库系统已有的技术。不仅能很好地支持对象管理和规则管理，而且能更好地支持原有的数据管理，支持多数用户需要的即席查询等。</p></li><li><p>第三代数据库系统<strong>必须对其他系统开放数据库系统的开放性</strong>，表现在：支持数据库语言标准；在网络上支持标准网络协议；系统具有良好的可移植性、可连接性、可扩展性和互操作性等。这些新的数据库系统支持不同的数据模型，有<strong>扩展关系数据模型的对象关系数据库系统、面向对象模型的对象数据库系统、支持XML半结构化模型的XML数据库系统</strong>等。</p><p>既然对于第三代数据库系统并没有形成一致的认识，因而通常把第二代以后的数据库系统称为新一代数据库系统。新一代数据库系统将是以更加丰富的数据模型和更强大的数据管理功能为特征，从而满足广泛更加复杂的新应用的要求。</p></li></ol><p>数据库技术与其他计算机技术相结合是数据库技术发展的一个显著特征。</p><ul><li>与分布式处理技术结合出现的<strong>分布式数据库系统</strong></li><li>与并行处理技术相结合出现的并行数据库系统</li><li>与人工智能技术相结合出现的演绎数据库、知识和主动数据库系统等</li><li>与模糊技术想结合出现的模糊数据库系统</li><li>与Web技术相结合出现的Web数据库</li></ul><h2 id=第二节-数据仓库与数据挖掘>第二节 数据仓库与数据挖掘<a hidden class=anchor aria-hidden=true href=#第二节-数据仓库与数据挖掘>#</a></h2><h3 id=821-从数据库到数据仓库>8.2.1 从数据库到数据仓库<a hidden class=anchor aria-hidden=true href=#821-从数据库到数据仓库>#</a></h3><ul><li><p>数据库与数据仓库只有一字之差，似乎是一样的概念，但实际则不然。</p></li><li><p>计算机系统中存在着两类不同的数据处理工作：</p><ul><li><p>一类是操作型处理，也称为联机事务处理（ Online Transaction Processing, OLTP），它是针对具体业务在数据库联机的日常操作，通常对少数记录进行查询和修改，用户较为关心操作的响应时间、数据的安全性、完整性和并发支持的用户数等问题，传统的数据库系统作为数据管理的主要手段，主要用于操作型处理；</p></li><li><p>另类是分析型处理，也称为联机分析处理（ Online Analytical Processing, OLAP），一般针对某些主题的历史数据进行分析，支持管理决策，它通常是对海量的历史数据查询和分析，如金融风险预测预警系统、证券股市违规分析系统等，这些系统要访问的数据量非常大，查询和分析的操作十分复杂。</p><p>事务型处理数据和分析型处理数据的区别可如 表 8.1 所示。</p></li></ul><p><img loading=lazy src=%e6%95%b0%e6%8d%ae%e5%ba%93%e7%b3%bb%e7%bb%9f%e5%8e%9f%e7%90%86.assets/image-20200930164537182.png alt=image-20200930164537182></p><ul><li>DTP 和 OLAP 两者之间的差异使得传统的数据库技术不能同时满足两类数据的处理要求，因此在 20 世纪 80 年代数据仓库（ Data Warehouse,pw）技术应运而生。数据仓库的建立将操作型处理和分析型处理区分开来。传统的数据库技术为操作型处理服务，数据仓库为分析型处理服务。二者各司其职，泾渭分明。越来越多的组织或企业认识到数据仓库的重要性，逐步在原有数据库基础上建立起自己的数据仓库系统</li></ul></li><li><p><strong>数据仓库是面向主题的、集成的、稳定的、随时间变化的数据集合，用以支持管理决策的过程。</strong> 数据仓库不是可以买到的产品，而是一种面向分析的数据存储方案。对于数据仓库的概念，可以从两个层次进行理解：首先，数据仓库用于支持决策，面向分析型数据处理，不同于提高业务效率的操作型数据库；其次，数据仓库对分布在组织或企业中的多个异构数据源集成，按照决策主题选择数据并以新的数据模型存储。此外，存储在数据仓库中的数据一般不能修改。相应地，数据仓库主要有以下特征。</p><ol><li><strong>面向主题</strong>：数据仓库中的数据是按照各种主题来组织的。主题在数据仓库中的物理实现是一系列的相关表，这不同于面向应用环境。例如，保险公司按照应用组织可能是汽车保险、生命保险、伤亡保险，而数据仓库是按照客户、政策、保险金和索赔来组织数据。面向主题的数据组织方式可在较高层次上对分析对象的数据给出完整、一致的描述，能完整、统一地刻画各个分析对象所涉及的各项数据以及数据之间的联系，从而适应组织或企业各个部门的业务活动特点和数据的动态特征，从根本上实现数据与应用的分离。</li><li><strong>集成性</strong>：数据仓库中的数据是从原有分散的源数据库中提取出来的，其每一个主题所对应的源数据在原有的数据库中有许多冗余和不一致，且与不同的应用逻辑相关。为了创建一个有效的主题域，必须将这些来自不同数据源的数据集成起来，使之遵循统一的编码规则</li><li><strong>数据的非易失性</strong>：数据的非易失性主要是针对应用而言的。数据仓库的用户对数据的操作大多是数据查询或比较复杂的挖掘，一旦数据进入数据仓库以后，一般情况下都被较长时间的保留。数据仓库中一般有大量的查询操作，但修改和删除操作较少。因此，数据经加工和集成进入数据仓库后是极少更新的，通常只需要定期加载和更新。</li><li><strong>数据的时变性</strong>：许多商业分析要求对发展趋势做出预测，对发展趋势的分析需要访问历史数据。因此数据仓库必须不断捕捉 OLTP 数据库中变化的数据，生成数据库的快照，经集成后增加到数据仓库中去：另外数据仓库还需要随时间的变化删去过期的、对分析没有帮助的数据，并且还需要按规定的时间段增加综合数据。</li></ol></li><li><p><strong>数据仓库具有三个常用的重要概念，即粒度、分割和维。</strong></p><ol><li>粒度是指<strong>数据仓库的数据单位中保存数据的细化或综合程度的级别，细化程度越高，粒度级就越小，相反地，细化程度越低，粒度级就越大。</strong> 数据的粒度一直是一个设计问题。在早期建立的操作型系统中，粒度是用于访问授权的，当详细的数据被更新时，几乎总是把它存储在最低粒度级上。但在数据仓库环境中对粒度不做假设。在数据仓库环境中粒度之所以是主要的设计问题，是因为它深深地影响存储在数据仓库中的数据量的大小，同时影响数据仓库所能回答的查询类型。在数据仓库中的数据量大小与查询的详细程度之间要做出权衡。</li><li>分割是将数据分散到各自的物理单元中，以便能分别处理，以提高数据处理的效率。数据分割后的单元称为切片。数据分割的标准可以根据实际情况来确定，通常可按日期、地理分布、业务范围等进行分割，数据分割后较小单元的数据处理相对独立，使数据更易于重构、索引、恢复和监控，处理起来更快。</li><li>维是人们观察数据的特定角度，是考虑问题时的一类属性。此类属性的集合构成一个维度，例如时间维、产品维等。维可以有细节程度的不同描述方面，这些不同描述方面称为维的层次，维层次中维的一个取值称为维的一个成员，不同的多个维成员的组合组成了该维的不同维层次。最常用的维是时间维，时间维的维层次可以有日、周、月、季、年等。数据仓库中的数据按照不同的维组织起来形成了一个多维立方体。维的概念使用户能够从多个角度观察数据仓库中的数据，以便深入了解包含在数据中的信息。</li></ol><p>此外，数据仓库有时也称为企业仓库。企业数据仓库可以在大型机、超级计算机服务器或并行结构平台上实现，但建设数据仓库是一项庞大的系统工程，需要广泛业务建模，其工作量大、代价和风险很高。为此，人们提出了数据集市（ Data Mart）体系结构的数据仓库概念。数据集市的基本思想是自下而上的数据仓库的开发方法。数据集市结构的数据仓库，又称为主题结构数据仓库，是按照主题进行构思所形成的数据仓库。数据集市结构一般只能对某个主题进行操作，如果用户希望对两个以上的主题进行操作，则必须对这两主题的数据结构都了解，否则无法实现多主题的操作，而多主题的数据仓库结构往往会产生大量的冗余。一般可以将数据集市分为独立的数据集市（ Independent Data Mart）和从属的数据集市（ Dependent Data Ma）或这两种数据集市的混合。</p></li></ul><h3 id=822-数据挖掘技术>8.2.2 数据挖掘技术<a hidden class=anchor aria-hidden=true href=#822-数据挖掘技术>#</a></h3><ul><li><p><strong>数据挖掘</strong>（ Data Mining）是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中发现并提取隐藏在其中的、人们事先不知道的、但又是潜在有用的信息和知识的一种技术。它又被称为数据库中的<strong>知识发现</strong>（ Knowledge Discovery in DataBase,KDD），其与数据库、数理统计、机器学习、模式识别、模糊数学等诸多技术相关。</p></li><li><p><strong>OLAP</strong> 是数据汇总/聚集工具，可帮助简化数据分析，OLAP 工具的目标是简化和支持交互式数据分析。</p></li><li><p><strong>数据挖掘是自动地发现隐藏在大量数据中的隐含模式和有趣知识</strong>，而数据挖掘工具的目标是尽可能自动处理。</p></li><li><p>数据挖掘具备下列几种功能。</p><ol><li><strong>概念描述</strong>：归纳总结出数据的某些特征。</li><li><strong>关联分析</strong>：目的是找出数据库中数据项之间的相关性。关联规则表示了数据库中一组数据项间的相关性。关联可分为简单关联、时序关联、因果关联。常见的关联分析算法有 Apriori、FP growth 等。</li><li><strong>分类与预测</strong> ：分类是利用训练数据集通过一定的算法而求得分类规则，被用于规则描述和预测。根据不同类对象特征的描述可以得出辅助决策信息。<strong>常见的分类模型及算法有决策树模型、神经网络模型、线性回归模型等。</strong></li><li><strong>聚类</strong>：是把数据按照相似性归纳成若千类别。同一类中的数据彼此相似，不同类中的数据相异。聚类分析可以建立宏观的概念，发现数据的分布模式，以及可能的数据属性之间的相互关系。聚类的目的是使属于同一类别的对象之间的距离尽可能小，而不同类别的对象间的距离尽可能大。与分类方法不同的是，聚类没有预先的分类特征，而是根据一定的规则将对象归类，对分类后的对象类显式或隐式地描述其共同特征。常用的聚类算法有 K-Means、 GMM 等</li><li><strong>孤立点检测</strong>：孤立点是指数据中与整体表现行为不一致的数据集合。这些数据虽然是一些特例，但往往在错误检查和特例分析中是非常有用的。</li><li><strong>趋势和演变分析</strong>：可以描述行为随着时间变化的对象所遵循的规律或趋势</li></ol></li><li><p>在实际使用中，数据挖掘的过程通常由以下六个步骤构成。</p><ol><li>确定业务对象。将用户需求和目标转换成一种数据挖掘的问题定义，设计出达到目标的一个初步计划。认清数据挖掘的目的是数据挖掘的重要一步，挖掘的最后结果是不可预测的，但要探索的问题应是有预见的，为了数据挖掘而数据挖掘带有盲目性，是不会成功的。</li><li>数据的选择。搜索所有与业务对象有关的内部和外部数据信息，并从中选择出适用于数据挖掘应用的数据。数据挖掘的数据主要有两种来源，即数据可以是从数据仓库中来的，也可以是直接从数据库中而来。</li><li><strong>数据的预处理</strong>。实际应用数据往往是<strong>不完全的、有噪声的、模糊的、随机的</strong>，因此要根据不同的需求在挖掘之前<strong>进行预处理</strong>，即将最初的原始数据构造成最终适合建模工具处理的数据集，包括表、记录和属性的选择、数据转换和数据清洗等。其中，从数据仓库中直接得到数据挖掘的数据有许多好处，因为数据仓库的数据已经过了预处理，许多数据不一致的问题都较好地解决了，在数据挖掘时可大大减少清洗数据的工作量。</li><li>建模。选择和应用各种建模技术，并对模型参数选择合适的算法进行优化。</li><li>模型评估。对模型进行评价，并检査构建模型的每个步骤，确认其是否真正实现了预定的目的。</li><li>模型部署。创建完模型并不意味着工作结束，即使创建模型的目的是为了増加用户对数据的了解，所获得的知识也要用一种用户可以使用的方式来组织和表示，通常要将活动模型应用到决策制定的过程中。</li></ol></li></ul><h2 id=第三节-大数据管理技术>第三节 大数据管理技术<a hidden class=anchor aria-hidden=true href=#第三节-大数据管理技术>#</a></h2><h3 id=831-大数据定义>8.3.1 大数据定义<a hidden class=anchor aria-hidden=true href=#831-大数据定义>#</a></h3><ul><li>目前大数据尚无统一的定义，通常被认为是数据量很大、数据形式多样化的数据。例如，EMC 公司认为“大”是指大型数据集，一般在 10TB 规模左右，同时这些数据来自多种数据源，以实时、迭代的方式实现。IBM 则是把大数据概括为 4 个 V，即<strong>大量化（ Volume）、多样化（ Variety）、快速化（ Velocity）和真实性（ Verity）</strong>，强调大数据呈现价值稀疏性的特点。维基百科认为，大数据是指利用常用软件工具捕获、管理和处理数据所耗时间超过可忍时间的数据集。</li><li>大数据是指无法在可容忍的时间内用现有信息技术和软、硬件工具对其进行感知、获取、管理、处理的服务的数据集合，且其具有如下特征。<ol><li><strong>数据量巨大，即大量化（ Volume）</strong>。通过各种设备产生海量数据，数据规模庞大，数据量从 TB 级别，跃升到 PB 级别。IDC 的研究报告称，未来 10 年全球大数据将增加 50 倍，管理数据仓库的服务器数量将增加 10 倍。</li><li><strong>数据种类繁多，即多样化（ Variety）</strong>。大数据种类繁多，在编码方式、数据格式和应用特征等多个方面存在差异性，多信息源并发形成大量的异构数据。相对于以往便于存储和分析的结构化数据，大数据的数据类型不再是单一的文本形式，网络日志、音频、视频、图片、地理位置信息等多类型的数据对数据的存储和处理能力提出了更高的要求。据统计，企业中 80%的数据是非结构化或半结构化的</li><li><strong>处理速度快，即快速化（ Velocity）</strong>。大数据对实时处理有着较高的要求，在海量数据面前，处理数据的效率就是企业的竞争力</li><li><strong>价值（ Value）密度低</strong>。价值密度的高低与数据总量的大小成反比。在现实应用中，数据量大的数据并不一定有很大的价值，不能被及时有效处理分析的数据也没有很大的应用价值。大数据的本质并非在于大，而在于其价值含量。</li></ol></li></ul><h3 id=832-大数据管理技术典型代表>8.3.2 大数据管理技术典型代表<a hidden class=anchor aria-hidden=true href=#832-大数据管理技术典型代表>#</a></h3><ol><li><p>大数据存储 HDFS</p></li><li><p>NOSQL 数据管理系统</p><ul><li><p>NOSQL 是以互联网大数据应用为背景发展起来的分布式数据管理系统。 NoSQL 有两种解释：<strong>一种是 Non- Relational，即非关系数据库；另一种是 Not Only SQL，即数据管理技术不仅仅是 SQL</strong></p></li><li><p>NOSQL 系统为了提高存储能力和并发读写能力采用了极其简单的数据模型，支持简单的查询操作，而将复杂操作留给应用层实现。该系统对数据进行划分，对各个数据分区进行备份，以应对结点可能的失败，提高系统可用性；通过大量结点的并行处理获得高性能，采用的是横向扩展的方式。它弥补了传统数据库由于事务等机制而带来的对海量数据高并发请求处理性能上的欠缺，采用一种非关系的方式来解决大数据存储和管理的问题</p></li><li><p>NoSQL 系统支持的数据存储模型通常有键值（Key-vlue）模型、文档（ Document）模型、列（ Colum）模型和图（ Graph）模型等。</p><ol><li><p><strong>键值（Key-alue）存储</strong>
Key-value 存储是 NOSQL 数据库采用最多的数据存储方式，它的数据是以 Key-ahue 的形式存储的。Key-aue 数据模型是一个映射，Key 是查找数据地址的唯一关键字，而 Value 是数据实际存储的内容。它采用这个弱关系的数据模型，使用哈希函数实现关键字到值的快速映射，从而提高数据的存储能力和并发读/写能力。虽然它的数据处理速度非常快，适合通过主键进行查询或遍历，但基本上只能通过 Key 的完全一致查询获取数据。常见的键值存储数据库包括 Tokyo Cabinet/Tyrant、 <strong>Redis 和 Oracle bDB</strong> 等。</p></li><li><p><strong>文档存储</strong>
不需要定义表结构，但可以像定义表结构一样使用。文档存储的存储格式可以多样化，适合存储系统日志等非结构化数据。与 Key-Vale 存储不同的是，它可以通过复杂的查询条件来获取数据。虽然它不具备关系数据库所具有的事务处理和 JON 的处理能力但基本上能实现除此之外的其他处理。常见的文档型数据库有 CouchDB、 <strong>MongoDB</strong>等。</p></li><li><p><strong>列存储</strong>
列存储是以列为单位来存储数据的，擅长以列为单位读入数据，比较适合对某一列进行随杋査询处理。采用列存储数据模型让数据库系统具有高扩展性，即使数据增加也不会降低相应的处理速度，因此列存储主要应用于需要处理大量数据的情况。常见的列存储数据库有 Cassandra、<strong>HBase</strong> 等。</p></li><li><p><strong>图存储</strong>
数据库是基于图理论构建的，使用<strong>结点、属性和边</strong>的概念。结点代表实体，属性保存与结点相关的信息，而边用来连接结点，表示两者关系。图数据库存储某些数据集非常快，可以把图直接映射到面向对象应用程序中。</p></li></ol></li></ul></li><li><p>MapReduce 技术</p><ul><li>MapReduce 技术是（ Google 公司于 2004 年提出的<strong>大规模并行计算解决方案</strong>，主要应用于大规模廉价集群上的大数据并行处理。 MapReduce 以 Key/value 的分布式存储系统为基础，通过元数据集中存储、数据以chunk 为单位分布存储和数据 chunk 冗余复制来保证其高可用性。</li><li>MapReduce 是<strong>一种并行编程模型</strong>。它把计算过程分解为两个阶段，<strong>即 Map 阶段和 Reduce 阶段</strong>。具体执行过程是：首先，对输入的数据源进行分块，交给多个 Map 任务去执行，Map 任务执行 Map 函数，根据某种规则对数据分类，写入本地硬盘；然后，进入 Reduce 阶段，在该阶段由 Reduce 函数将 Map 阶段具有相同 Key 值的中间结果收集到相同的 Reduce 节点进行合并处理，并将结果写入本地磁盘。程序的最终结果可以通过合并所有 Reduce 任务的输出得到。其中，Map 函数和 Rduc 函数是用户根据应用的具体需求进行编写。</li><li>MapReduce 是一种简单易用的软件框架。基于它可以开发出运行在成千上万个结点上，并以容错的方式并行处理海量数据的算法和软件。通常，计算结点和存储结点是同一个节点，即 MapReduce 框架和 Hadoop 分布式文件系统运行于相同的结点集。</li></ul></li></ol><h1 id=last>Last<a hidden class=anchor aria-hidden=true href=#last>#</a></h1><h4 id=数据库操作>数据库操作<a hidden class=anchor aria-hidden=true href=#数据库操作>#</a></h4><p>创建数据库：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>database</span> testdb;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><p>删除数据库：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>drop</span> <span style=color:#af3a03>database</span> testdb;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><p>查看指定数据库使用的字符集：<code>show create database 数据库名;</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>show</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>database</span> lvsj;
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------+-----------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#af3a03>Database</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>Create</span> <span style=color:#af3a03>Database</span>                                                 <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------+-----------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> lvsj     <span style=color:#af3a03>|</span> <span style=color:#af3a03>CREATE</span> <span style=color:#af3a03>DATABASE</span> <span style=color:#af3a03>`</span>lvsj<span style=color:#af3a03>`</span> <span style=color:#928374;font-style:italic>/*!40100 DEFAULT CHARACTER SET gb2312 */</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+----------+-----------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h4 id=数据库表操作>数据库表操作<a hidden class=anchor aria-hidden=true href=#数据库表操作>#</a></h4><h6 id=创建库表>创建库表<a hidden class=anchor aria-hidden=true href=#创建库表>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>table</span> <span style=color:#af3a03>user</span>(
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> user_id  <span style=color:#b57614>int</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> user_name <span style=color:#b57614>char</span>(<span style=color:#8f3f71>10</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> user_age <span style=color:#b57614>int</span> <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span>,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>primary</span> <span style=color:#af3a03>key</span>(user_id)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> );
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>03</span> sec)
</span></span></code></pre></div><h6 id=插入数据>插入数据<a hidden class=anchor aria-hidden=true href=#插入数据>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#928374;font-style:italic># 方法一
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> lvsj.<span style=color:#af3a03>user</span>(user_id,user_name,user_age,user_Address)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>1</span>,<span style=color:#79740e>&#39;吕小布&#39;</span>,<span style=color:#8f3f71>25</span>,<span style=color:#79740e>&#39;bei jing&#39;</span>);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># 方法二
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> lvsj.course
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>3</span>,<span style=color:#79740e>&#39;语文&#39;</span>,<span style=color:#8f3f71>95</span>,<span style=color:#8f3f71>2</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h6 id=使用-insert-int-set插入数据>使用 insert int ..set插入数据<a hidden class=anchor aria-hidden=true href=#使用-insert-int-set插入数据>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> lvsj.<span style=color:#af3a03>user</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#b57614>set</span> user_name<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;吕x布&#39;</span>,user_age<span style=color:#af3a03>=</span><span style=color:#8f3f71>10</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h6 id=插入新列--alter----add-column>插入新列： alter &mldr; add column<a hidden class=anchor aria-hidden=true href=#插入新列--alter----add-column>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> lvsj.<span style=color:#af3a03>user</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>add</span> <span style=color:#af3a03>column</span> user_hobby <span style=color:#b57614>char</span>(<span style=color:#8f3f71>20</span>) <span style=color:#af3a03>not</span> <span style=color:#d3869b>null</span> <span style=color:#af3a03>default</span> <span style=color:#79740e>&#34;打游戏&#34;</span> after user_age;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>09</span> sec)
</span></span><span style=display:flex><span>Records: <span style=color:#8f3f71>0</span>  Duplicates: <span style=color:#8f3f71>0</span>  Warnings: <span style=color:#8f3f71>0</span>
</span></span></code></pre></div><h6 id=删除数据>删除数据<a hidden class=anchor aria-hidden=true href=#删除数据>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>delete</span> <span style=color:#af3a03>from</span> lvsj.<span style=color:#af3a03>user</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> user_id <span style=color:#af3a03>=</span> <span style=color:#8f3f71>11</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h6 id=更新数据-update---set>更新数据 update &mldr; set<a hidden class=anchor aria-hidden=true href=#更新数据-update---set>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>update</span> lvsj.<span style=color:#af3a03>user</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#b57614>set</span> user_name <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;Lv Sijun&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> user_id <span style=color:#af3a03>=</span> <span style=color:#8f3f71>12</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span><span style=display:flex><span>Rows matched: <span style=color:#8f3f71>1</span>  Changed: <span style=color:#8f3f71>1</span>  Warnings: <span style=color:#8f3f71>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>update</span> <span style=color:#af3a03>user</span> <span style=color:#b57614>set</span> user_age <span style=color:#af3a03>=</span> user_age<span style=color:#af3a03>*</span><span style=color:#8f3f71>1</span>.<span style=color:#8f3f71>05</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>8</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span><span style=display:flex><span>Rows matched: <span style=color:#8f3f71>8</span>  Changed: <span style=color:#8f3f71>8</span>  Warnings: <span style=color:#8f3f71>0</span>
</span></span></code></pre></div><p>更新多个值用 <code>,</code> 分隔， 删除即设置为空;</p><h6 id=查看指定数据库表使用的字符集>查看指定数据库表使用的字符集<a hidden class=anchor aria-hidden=true href=#查看指定数据库表使用的字符集>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>show</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>table</span> <span style=color:#af3a03>user</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------+-------------------------------------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#af3a03>Table</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>Create</span> <span style=color:#af3a03>Table</span>                                                                   <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------+-------------------------------------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#af3a03>user</span>  <span style=color:#af3a03>|</span> <span style=color:#af3a03>CREATE</span> <span style=color:#af3a03>TABLE</span> <span style=color:#af3a03>`</span><span style=color:#af3a03>user</span><span style=color:#af3a03>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#af3a03>`</span>user_id<span style=color:#af3a03>`</span> <span style=color:#b57614>int</span>(<span style=color:#8f3f71>11</span>) <span style=color:#af3a03>NOT</span> <span style=color:#d3869b>NULL</span> <span style=color:#af3a03>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>  <span style=color:#af3a03>`</span>user_name<span style=color:#af3a03>`</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>10</span>) <span style=color:#af3a03>NOT</span> <span style=color:#d3869b>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#af3a03>`</span>user_age<span style=color:#af3a03>`</span> <span style=color:#b57614>int</span>(<span style=color:#8f3f71>11</span>) <span style=color:#af3a03>NOT</span> <span style=color:#d3869b>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#af3a03>`</span>user_address<span style=color:#af3a03>`</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>20</span>) <span style=color:#af3a03>NOT</span> <span style=color:#d3869b>NULL</span> <span style=color:#af3a03>DEFAULT</span> <span style=color:#79740e>&#39;jiangxi&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#af3a03>PRIMARY</span> <span style=color:#af3a03>KEY</span> (<span style=color:#af3a03>`</span>user_id<span style=color:#af3a03>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#af3a03>ENGINE</span><span style=color:#af3a03>=</span>InnoDB <span style=color:#af3a03>AUTO_INCREMENT</span><span style=color:#af3a03>=</span><span style=color:#8f3f71>12</span> <span style=color:#af3a03>DEFAULT</span> <span style=color:#af3a03>CHARSET</span><span style=color:#af3a03>=</span>latin1 <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------+-------------------------------------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><h6 id=修改数据库表的字符集为-utf8-解决插入中文数据报错的问题>修改数据库表的字符集为 utf8 (解决插入中文数据报错的问题)<a hidden class=anchor aria-hidden=true href=#修改数据库表的字符集为-utf8-解决插入中文数据报错的问题>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#928374;font-style:italic># 语法
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> 表名 <span style=color:#af3a03>convert</span> <span style=color:#af3a03>to</span> <span style=color:#af3a03>character</span> <span style=color:#b57614>set</span> 字符集;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic># 示例，修改数据库表 user 的字符集为 utf8
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>alter</span> <span style=color:#af3a03>table</span> <span style=color:#af3a03>user</span> <span style=color:#af3a03>convert</span> <span style=color:#af3a03>to</span> <span style=color:#af3a03>character</span> <span style=color:#b57614>set</span> utf8;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>07</span> sec)
</span></span><span style=display:flex><span>Records: <span style=color:#8f3f71>1</span>  Duplicates: <span style=color:#8f3f71>0</span>  Warnings: <span style=color:#8f3f71>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>show</span> <span style=color:#af3a03>create</span> <span style=color:#af3a03>table</span> <span style=color:#af3a03>user</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------+-------------------------------------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#af3a03>Table</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>Create</span> <span style=color:#af3a03>Table</span>                                                     <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------+-------------------------------------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> <span style=color:#af3a03>user</span>  <span style=color:#af3a03>|</span> <span style=color:#af3a03>CREATE</span> <span style=color:#af3a03>TABLE</span> <span style=color:#af3a03>`</span><span style=color:#af3a03>user</span><span style=color:#af3a03>`</span> (
</span></span><span style=display:flex><span>  <span style=color:#af3a03>`</span>user_id<span style=color:#af3a03>`</span> <span style=color:#b57614>int</span>(<span style=color:#8f3f71>11</span>) <span style=color:#af3a03>NOT</span> <span style=color:#d3869b>NULL</span> <span style=color:#af3a03>AUTO_INCREMENT</span>,
</span></span><span style=display:flex><span>  <span style=color:#af3a03>`</span>user_name<span style=color:#af3a03>`</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>10</span>) <span style=color:#af3a03>NOT</span> <span style=color:#d3869b>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#af3a03>`</span>user_age<span style=color:#af3a03>`</span> <span style=color:#b57614>int</span>(<span style=color:#8f3f71>11</span>) <span style=color:#af3a03>NOT</span> <span style=color:#d3869b>NULL</span>,
</span></span><span style=display:flex><span>  <span style=color:#af3a03>`</span>user_address<span style=color:#af3a03>`</span> <span style=color:#b57614>char</span>(<span style=color:#8f3f71>20</span>) <span style=color:#af3a03>NOT</span> <span style=color:#d3869b>NULL</span> <span style=color:#af3a03>DEFAULT</span> <span style=color:#79740e>&#39;jiangxi&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#af3a03>PRIMARY</span> <span style=color:#af3a03>KEY</span> (<span style=color:#af3a03>`</span>user_id<span style=color:#af3a03>`</span>)
</span></span><span style=display:flex><span>) <span style=color:#af3a03>ENGINE</span><span style=color:#af3a03>=</span>InnoDB <span style=color:#af3a03>AUTO_INCREMENT</span><span style=color:#af3a03>=</span><span style=color:#8f3f71>12</span> <span style=color:#af3a03>DEFAULT</span> <span style=color:#af3a03>CHARSET</span><span style=color:#af3a03>=</span>utf8 <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-------+-------------------------------------------------------------------------------------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h4 id=数据查询>数据查询<a hidden class=anchor aria-hidden=true href=#数据查询>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>select</span> [<span style=color:#af3a03>ALL</span><span style=color:#af3a03>|</span><span style=color:#af3a03>DISTINCT</span><span style=color:#af3a03>|</span><span style=color:#af3a03>DISTINCTROW</span>] select_expr[,select_expr ...]
</span></span><span style=display:flex><span><span style=color:#af3a03>from</span> table_refrences
</span></span><span style=display:flex><span>[<span style=color:#af3a03>where</span> where_condition]  <span style=color:#928374;font-style:italic># 行级过滤
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>[<span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span>{col_name<span style=color:#af3a03>|</span>expr<span style=color:#af3a03>|</span>position} <span style=color:#928374;font-style:italic># 聚合计算
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span> [<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>],... [<span style=color:#af3a03>WITH</span> ROLLUP]]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>having</span> where_condition] <span style=color:#928374;font-style:italic># 组级过滤
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>[<span style=color:#af3a03>order</span> <span style=color:#af3a03>by</span> {col_name<span style=color:#af3a03>|</span>expr<span style=color:#af3a03>|</span>position}  <span style=color:#928374;font-style:italic># 排序
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span> [<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>], ...]
</span></span><span style=display:flex><span>[<span style=color:#af3a03>limit</span> {[offset,] row_count<span style=color:#af3a03>|</span>row_count offset offset}]
</span></span></code></pre></div><h6 id=case-when-else-end>case when else end<a hidden class=anchor aria-hidden=true href=#case-when-else-end>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> user_name,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>case</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span>  <span style=color:#af3a03>when</span> user_age <span style=color:#af3a03>&gt;</span><span style=color:#8f3f71>18</span>  <span style=color:#af3a03>then</span> <span style=color:#79740e>&#39;成年人&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span>  <span style=color:#af3a03>else</span> <span style=color:#79740e>&#39;小朋友&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> end <span style=color:#af3a03>as</span> 类别 <span style=color:#af3a03>from</span> <span style=color:#af3a03>user</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+-----------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> user_name <span style=color:#af3a03>|</span> 类别      <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+-----------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 吕小布    <span style=color:#af3a03>|</span> 成年人    <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 吕布      <span style=color:#af3a03>|</span> 小朋友    <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> Lv Sijun  <span style=color:#af3a03>|</span> 小朋友    <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+-----------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>3</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><h6 id=case-when-then-else-end-条件>case when then else end 条件<a hidden class=anchor aria-hidden=true href=#case-when-then-else-end-条件>#</a></h6><p>例 4.29 查询表 <code>customers</code>中客户的 <code>cust_name、cust_sex</code>, 要求判断结果集中 <code>cust_ sex</code>列的值, 如果该列的值为 M, 则显示输出"男&rdquo;, 否则为"女", 同时在结果集的显示中将 <code>cust_sex</code>列用别名"性别"标注</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> cust_name,
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>case</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>when</span> cust_sex<span style=color:#af3a03>=</span><span style=color:#79740e>&#39;M&#39;</span> <span style=color:#af3a03>then</span><span style=color:#79740e>&#39;男&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>else</span> <span style=color:#79740e>&#39;女&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> end <span style=color:#af3a03>as</span> 性别
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> test_db.customers;
</span></span></code></pre></div><h6 id=inner-join--内连接>inner join 内连接<a hidden class=anchor aria-hidden=true href=#inner-join--内连接>#</a></h6><p><strong>例 4.32</strong> 根据第二章描述的学生基本信息登记表 <code>user</code>和学生成绩表 <code>course</code>, 使用内连接查询每个学生及其选课成绩的详细信息;</p><p>由于学生基本信息存储在 <code>user</code>表中, 学生选课成绩信息存储在 <code>course</code>表中, 所以这个查询涉及两张表, 这两张表之间进行连接的连接条件是两个表中的 <code>id</code>相等</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span> <span style=color:#af3a03>from</span> <span style=color:#af3a03>user</span> <span style=color:#af3a03>inner</span> <span style=color:#af3a03>join</span> course
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>on</span> <span style=color:#af3a03>user</span>.user_id <span style=color:#af3a03>=</span> course.student_id;
</span></span><span style=display:flex><span><span style=color:#af3a03>+---------+-----------+----------+------------+--------------+-----------+-------------+--------------+------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> user_id <span style=color:#af3a03>|</span> user_name <span style=color:#af3a03>|</span> user_age <span style=color:#af3a03>|</span> user_hobby <span style=color:#af3a03>|</span> user_address <span style=color:#af3a03>|</span> course_id <span style=color:#af3a03>|</span> course_name <span style=color:#af3a03>|</span> course_grade <span style=color:#af3a03>|</span> student_id <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+---------+-----------+----------+------------+--------------+-----------+-------------+--------------+------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>       <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span> 吕小布    <span style=color:#af3a03>|</span>       <span style=color:#8f3f71>25</span> <span style=color:#af3a03>|</span> 打游戏     <span style=color:#af3a03>|</span> bei jing     <span style=color:#af3a03>|</span>         <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span> 语文        <span style=color:#af3a03>|</span>           <span style=color:#8f3f71>95</span> <span style=color:#af3a03>|</span>          <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>       <span style=color:#8f3f71>2</span> <span style=color:#af3a03>|</span> 吕布      <span style=color:#af3a03>|</span>       <span style=color:#8f3f71>10</span> <span style=color:#af3a03>|</span> 打游戏     <span style=color:#af3a03>|</span> jiangxi      <span style=color:#af3a03>|</span>         <span style=color:#8f3f71>2</span> <span style=color:#af3a03>|</span> 语文        <span style=color:#af3a03>|</span>           <span style=color:#8f3f71>69</span> <span style=color:#af3a03>|</span>          <span style=color:#8f3f71>2</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>       <span style=color:#8f3f71>2</span> <span style=color:#af3a03>|</span> 吕布      <span style=color:#af3a03>|</span>       <span style=color:#8f3f71>10</span> <span style=color:#af3a03>|</span> 打游戏     <span style=color:#af3a03>|</span> jiangxi      <span style=color:#af3a03>|</span>         <span style=color:#8f3f71>3</span> <span style=color:#af3a03>|</span> 语文        <span style=color:#af3a03>|</span>           <span style=color:#8f3f71>95</span> <span style=color:#af3a03>|</span>          <span style=color:#8f3f71>2</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+---------+-----------+----------+------------+--------------+-----------+-------------+--------------+------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>3</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h6 id=数据范围--between-and------in>数据范围 between and / in<a hidden class=anchor aria-hidden=true href=#数据范围--between-and------in>#</a></h6><p>例 4.36 在数据库 <code>test_db</code>的表 <code>customers</code>中，查询客户 id 号分别为 903、906 和 908 个客户的信息。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span> <span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span><span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_id <span style=color:#af3a03>in</span>(<span style=color:#8f3f71>903</span>,<span style=color:#8f3f71>906</span>,<span style=color:#8f3f71>908</span>);
</span></span></code></pre></div><p>例 4.35 在数据库 <code>test_db</code> 的表 <code>customers</code>中，查询客户 id 号在 903 至 912 之间的十个客户的信息。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span><span style=color:#af3a03>from</span> test_db.customers
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> cust_id <span style=color:#af3a03>BETWEEN</span> <span style=color:#8f3f71>903</span> <span style=color:#af3a03>AND</span> <span style=color:#8f3f71>912</span>;
</span></span></code></pre></div><p>例 4.38 根据第 2 章描述的学生基本信息登记表 <code>tb student</code>和学生成绩表 <code>tb score</code>，使用子査询的方式查询任意所选课程成绩高于 80 分的学生的学号和姓名信息。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>select</span> 学号，姓名信息 <span style=color:#af3a03>from</span> student <span style=color:#af3a03>where</span> studentNo <span style=color:#af3a03>in</span> (<span style=color:#af3a03>select</span> studentNo <span style=color:#af3a03>from</span> score <span style=color:#af3a03>where</span> grade <span style=color:#af3a03>&gt;</span> <span style=color:#8f3f71>80</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> studentNo,studentName
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>from</span> tb_student
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> studentNo <span style=color:#af3a03>in</span> (<span style=color:#af3a03>select</span> studentNo <span style=color:#af3a03>from</span> tb_score <span style=color:#af3a03>where</span> stScore<span style=color:#af3a03>&gt;</span><span style=color:#8f3f71>80</span>);
</span></span></code></pre></div><h5 id=group-by-子句与分组查询>group by 子句与分组查询<a hidden class=anchor aria-hidden=true href=#group-by-子句与分组查询>#</a></h5><p>在 <code>select</code>语句中，允许使用 <code>group by</code>子句，<strong>将结果集中的数据行根据选择列的值逻辑分组，以便能汇总表内容的子集，即实现对每个组的聚集计算。</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span> {col_name<span style=color:#af3a03>|</span>expr<span style=color:#af3a03>|</span>position} {<span style=color:#af3a03>asc</span><span style=color:#af3a03>|</span><span style=color:#af3a03>desc</span>},...[<span style=color:#af3a03>WITH</span> ROLLUP]
</span></span></code></pre></div><p>在表 <code>user</code>中获取一个数据结果集，要求该结果集中分别包含相同年龄的人数。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> user_name,user_age,<span style=color:#b57614>count</span>(<span style=color:#af3a03>*</span>) <span style=color:#af3a03>as</span> <span style=color:#79740e>&#34;人数&#34;</span> <span style=color:#af3a03>from</span> <span style=color:#af3a03>user</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span> user_age;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> user_name <span style=color:#af3a03>|</span> user_age <span style=color:#af3a03>|</span> 人数   <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 吕布      <span style=color:#af3a03>|</span>       <span style=color:#8f3f71>10</span> <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>2</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 吕小布    <span style=color:#af3a03>|</span>       <span style=color:#8f3f71>25</span> <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>2</span> rows <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h5 id=having-用于过滤分组>having 用于过滤分组<a hidden class=anchor aria-hidden=true href=#having-用于过滤分组>#</a></h5><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> user_name,user_age,<span style=color:#b57614>count</span>(<span style=color:#af3a03>*</span>) <span style=color:#af3a03>as</span> <span style=color:#79740e>&#34;人数&#34;</span> <span style=color:#af3a03>from</span> <span style=color:#af3a03>user</span> <span style=color:#af3a03>group</span> <span style=color:#af3a03>by</span> user_age <span style=color:#af3a03>with</span> rollup <span style=color:#af3a03>having</span> <span style=color:#b57614>count</span>(<span style=color:#af3a03>*</span>)<span style=color:#af3a03>&gt;=</span><span style=color:#8f3f71>3</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> user_name <span style=color:#af3a03>|</span> user_age <span style=color:#af3a03>|</span> 人数   <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> 吕小布    <span style=color:#af3a03>|</span>     <span style=color:#d3869b>NULL</span> <span style=color:#af3a03>|</span>      <span style=color:#8f3f71>3</span> <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+-----------+----------+--------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><h3 id=视图>视图<a hidden class=anchor aria-hidden=true href=#视图>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span><span style=color:#af3a03>CREATE</span> VIEW view_name[(column_list)]
</span></span><span style=display:flex><span> <span style=color:#af3a03>as</span> select_statement
</span></span><span style=display:flex><span> [ <span style=color:#af3a03>WITH</span> [CASCADED<span style=color:#af3a03>|</span>LOCAL] <span style=color:#af3a03>CHECK</span> <span style=color:#af3a03>OPTION</span> ]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span><span style=color:#af3a03>WITH</span> <span style=color:#af3a03>CHECK</span> <span style=color:#af3a03>OPTION</span> 是可选项,用于指定在可更新视图上所进行的修改都需要符合 <span style=color:#af3a03>`</span><span style=color:#af3a03>select</span> statement<span style=color:#af3a03>`</span>中所指定的限制条件
</span></span><span style=display:flex><span>关键字“ <span style=color:#af3a03>`</span>CASCADED<span style=color:#af3a03>`</span>”为选项默认值，它会对所有视图进行检查，而关键字“ <span style=color:#af3a03>`</span>LOCAL<span style=color:#af3a03>`</span>”则使 <span style=color:#af3a03>`</span><span style=color:#af3a03>CHECK</span> <span style=color:#af3a03>OPTION</span><span style=color:#af3a03>`</span>只对定义的视图进行检查。
</span></span></code></pre></div><h6 id=创建视图>创建视图<a hidden class=anchor aria-hidden=true href=#创建视图>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> view user_view
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>as</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span> <span style=color:#af3a03>from</span> <span style=color:#af3a03>user</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>where</span> user_age <span style=color:#af3a03>&gt;</span><span style=color:#8f3f71>15</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>-&gt;</span> <span style=color:#af3a03>with</span> <span style=color:#af3a03>check</span> <span style=color:#af3a03>option</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h6 id=创建视图-只取部分参数>创建视图 只取部分参数<a hidden class=anchor aria-hidden=true href=#创建视图-只取部分参数>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>create</span> view <span style=color:#b57614>CVIEW</span>(course_name,course_grade) <span style=color:#af3a03>as</span> <span style=color:#af3a03>select</span> course_name,course_grade <span style=color:#af3a03>from</span> course <span style=color:#af3a03>where</span> course_grade<span style=color:#af3a03>&gt;</span><span style=color:#8f3f71>80</span>;
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>0</span> rows <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><h6 id=查询视图>查询视图<a hidden class=anchor aria-hidden=true href=#查询视图>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>select</span> <span style=color:#af3a03>*</span> <span style=color:#af3a03>from</span> user_view;
</span></span><span style=display:flex><span><span style=color:#af3a03>+---------+-----------+----------+------------+--------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span> user_id <span style=color:#af3a03>|</span> user_name <span style=color:#af3a03>|</span> user_age <span style=color:#af3a03>|</span> user_hobby <span style=color:#af3a03>|</span> user_address <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+---------+-----------+----------+------------+--------------+</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>|</span>       <span style=color:#8f3f71>1</span> <span style=color:#af3a03>|</span> 吕小布    <span style=color:#af3a03>|</span>       <span style=color:#8f3f71>25</span> <span style=color:#af3a03>|</span> 打游戏     <span style=color:#af3a03>|</span> bei jing     <span style=color:#af3a03>|</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>+---------+-----------+----------+------------+--------------+</span>
</span></span><span style=display:flex><span><span style=color:#8f3f71>1</span> row <span style=color:#af3a03>in</span> <span style=color:#b57614>set</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>00</span> sec)
</span></span></code></pre></div><h6 id=插入数据-1>插入数据<a hidden class=anchor aria-hidden=true href=#插入数据-1>#</a></h6><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-mysql data-lang=mysql><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> user_view <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>11</span>,<span style=color:#79740e>&#39;李四&#39;</span>,<span style=color:#8f3f71>10</span>,<span style=color:#79740e>&#39;LOL&#39;</span>,<span style=color:#79740e>&#39;江西&#39;</span>);   <span style=color:#af3a03>//</span>错误示范
</span></span><span style=display:flex><span>ERROR <span style=color:#8f3f71>1369</span> (HY000): <span style=color:#af3a03>CHECK</span> <span style=color:#af3a03>OPTION</span> failed <span style=color:#79740e>&#39;lvsj.user_view&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mysql<span style=color:#af3a03>&gt;</span> <span style=color:#af3a03>insert</span> <span style=color:#af3a03>into</span> user_view <span style=color:#af3a03>values</span>(<span style=color:#8f3f71>13</span>,<span style=color:#79740e>&#39;王五&#39;</span>,<span style=color:#8f3f71>16</span>,<span style=color:#79740e>&#39;DOAT&#39;</span>,<span style=color:#79740e>&#39;江西&#39;</span>);
</span></span><span style=display:flex><span>Query OK, <span style=color:#8f3f71>1</span> row <span style=color:#b57614>affected</span> (<span style=color:#8f3f71>0</span>.<span style=color:#8f3f71>01</span> sec)
</span></span></code></pre></div><p>由于视图是一个虚拟表，所以通过插入、修改和删除等操作方法来更新视图中的数据，实质上是在更新视图所引用的表中的数据。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/exams/>exams</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/life/20230725-helloworld/><span class=title>« Prev</span><br><span>HelloWorld</span></a>
<a class=next href=https://bablvsj.github.io/posts/exams/english-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-%E5%B8%B8%E7%94%A8%E8%AF%8D%E7%BC%80/><span class=title>Next »</span><br><span>English 第一部分 常用词缀</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>