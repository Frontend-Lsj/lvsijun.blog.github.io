<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TypeScript | Bablvsj's Blog</title><meta name=keywords content="TypeScript,编程语言"><meta name=description content="快速学习Ts"><meta name=author content><link rel=canonical href=https://bablvsj.github.io/posts/work/tech/codelanguage/20230815-typescript/><link crossorigin=anonymous href=/assets/css/stylesheet.5bf4ce5e0c2ccae25e5f331fe0d2d10c34cd4c9d5185a3279b459f6a9fd761df.css integrity="sha256-W/TOXgwsyuJeXzMf4NLRDDTNTJ1RhaMnm0Wfap/XYd8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=16x16 href=https://bablvsj.github.io/img/Q.gif><link rel=icon type=image/png sizes=32x32 href=https://bablvsj.github.io/img/Q.gif><link rel=apple-touch-icon href=https://bablvsj.github.io/Q.gif><link rel=mask-icon href=https://bablvsj.github.io/Q.gif><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=stylesheet href=/css/syntax.css><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="TypeScript"><meta property="og:description" content="快速学习Ts"><meta property="og:type" content="article"><meta property="og:url" content="https://bablvsj.github.io/posts/work/tech/codelanguage/20230815-typescript/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-11T17:11:35+08:00"><meta property="article:modified_time" content="2023-08-11T17:11:35+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TypeScript"><meta name=twitter:description content="快速学习Ts"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"文章","item":"https://bablvsj.github.io/posts/"},{"@type":"ListItem","position":3,"name":"TypeScript","item":"https://bablvsj.github.io/posts/work/tech/codelanguage/20230815-typescript/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TypeScript","name":"TypeScript","description":"快速学习Ts","keywords":["TypeScript","编程语言"],"articleBody":"类型系统 TypeScript是静态类型 （根据类型检查的时机来分类） 动态类型是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误。JavaScript 是一门解释型语言，没有编译阶段，所以它是动态类型，以下这段代码在运行时才会报错：\nlet foo = 1; foo.split(' '); // Uncaught TypeError: foo.split is not a function // 运行时会报错（foo.split 不是一个函数），造成线上 bug 静态类型是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 TypeScript 是静态类型，这段 TypeScript 代码在编译阶段就会报错了：\nlet foo = 1; //类型推断 let foo: number = 1; foo.split(' '); // Property 'split' does not exist on type 'number'. // 编译时会报错（数字没有 split 方法），无法通过编译 TypeScript / JavaScript 都是弱类型 （根据是否允许隐式类型转换来分类） 安装typescript npm install -g typescript tsc -v // Version x.x.x TS基础 1.基础类型 布尔值 boolean let isDone: boolean = false; let createdByNewBoolean: Boolean = new Boolean(1); //非布尔值！ 返回的是一个 Boolean对象 let createdByBoolean: Boolean = Boolean(1) // 直接调用可返回一个 boolean 类型 数值 number let decLiteral: number = 6; let hexLiteral: number = 0xf00d; let binaryLiteral: number = 0b1010; //ES6的二进制表示法 会被编译成十进制 let octalLiteral: number = 0o744; //ES6的八进制表示法 ... let notANumber: number = NaN; let infinityNumber: number = Infinity; 字符串 string let myName: string = 'Tom'; let myAge: number = 25; // 模板字符串 let sentence: string = `Hello, my name is ${myName}. I'll be ${myAge + 1} years old next month.`; null 和 undefined 在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\nlet u: undefined = undefined; let n: null = null; 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n// 这样不会报错 let num: number = undefined; // 这样也不会报错 let u: undefined; let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量：\nlet u: void; let num: number = u; // Type 'void' is not assignable to type 'number'. 任意值 any 什么是任意值类型 如果是一个普通类型，在赋值过程中改变类型是不被允许的：\nlet myFavoriteNumber: string = 'seven'; myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 但如果是 any 类型，则允许被赋值为任意类型。\nlet myFavoriteNumber: any = 'seven'; myFavoriteNumber = 7; 任意值的属性和方法 在任意值上访问任何属性都是允许的：\nlet anyThing: any = 'hello'; console.log(anyThing.myName); console.log(anyThing.myName.firstName); 也允许调用任何方法：\nlet anyThing: any = 'Tom'; anyThing.setName('Jerry'); anyThing.setName('Jerry').sayHello(); anyThing.myName.setFirstName('Cat'); 可以认为，声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值。\n未声明类型的变量 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\nlet something; something = 'seven'; something = 7; something.setName('Tom'); 等价于\nlet something: any; something = 'seven'; something = 7; something.setName('Tom'); unknow 类型 就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。\nlet value: unknown; value = true; // OK value = 42; // OK value = \"Hello World\"; // OK value = []; // OK value = {}; // OK value = Math.random; // OK value = null; // OK value = undefined; // OK value = new TypeError(); // OK value = Symbol(\"type\"); // OK 不能将 unknown的值 赋值给其他类型的变量，unknown类型只能被赋值给 any 类型和 unknown 类型本身\nlet value: unknown; let value1: unknown = value; // OK let value2: any = value; // OK let value3: boolean = value; // Error let value4: number = value; // Error let value5: string = value; // Error let value6: object = value; // Error let value7: any[] = value; // Error let value8: Function = value; // Error **unknown 应用场景\n// any 写法，不推荐 function divide(param: any) { return param / 2; } // unknown写法，推荐 function divide(param:unknown) { return param as number / 2 } 空值 void void 表示没有任何返回值的函数\nfunction alertName(): void { alert('My name is Lv'); } 声明一个 void 类型的变量没用，因为你只能将它赋值为 undefined 和 null（只在 –strictNullChecks 未指定时）：\nlet unusable: void = undefined; never 类型 never类型表示的是那些用不存在的值的类型。\n有些情况下值会永不存在，比如，\n如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值，因为抛出异常会直接中断程序运行。 函数中执行无限循环的代码，使得程序永远无法运行到函数返回值那一步。 // 异常 function fn(msg: string): never { throw new Error(msg) } // 死循环 千万别这么写，会内存溢出 function fn(): never { while (true) {} } never 类型是任何类型的子类型，也可以赋值给任何类型。\nlet test1: never; test1 = 'lin' // 报错，Type 'string' is not assignable to type 'never' 没有类型是 never 的子类型，没有类型可以赋值给 never 类型（除了 never 本身之外）。 即使 any也不可以赋值给 never 。\nlet test1: never; let test2: any; test1 = test2 // 报错，Type 'any' is not assignable to type 'never' 数组的类型 类型+方括号 表示法 let fibonacci: number[] = [1, 1, 2, 3, 5]; 数组的项中不允许出现其他的类型：\nlet fibonacci: number[] = [1, '1', 2, 3, 5]; // Type 'string' is not assignable to type 'number'. 数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：\nlet fibonacci: number[] = [1, 1, 2, 3, 5]; fibonacci.push('8'); // Argument of type '\"8\"' is not assignable to parameter of type 'number'. 数组泛型 array 我们也可以使用数组泛型（Array Generic） Array来表示数组：\nlet fibonacci: Array\u003cnumber\u003e = [1, 1, 2, 3, 5]; 用接口表示数组 interface NumberArray { [index: number]: number; } let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 元组 Tuple 类型 在单个变量中存储不同类型的值\nlet tupleType: [string, boolean]; tupleType = [\"semlinker\", true]; 在元组初始化的时候，如果出现类型不匹配的话，比如：\ntupleType = [true, \"semlinker\"]; //报错 [0]: Type 'true' is not assignable to type 'string'. [1]: Type 'string' is not assignable to type 'boolean'. 在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误。\n可以对元组使用数组的方法，比如使用 push 时，不会有越界报错\nlet tuple: [number, string] = [18, 'lin'] tuple.push(100) // 但是只能 push 定义的 number 或者 string 类型 2.函数类型 function sum(x: number, y: number): number { return x + y; } //可选参数 function buildName(firstName: string, lastName?: string) { if (lastName) { return firstName + ' ' + lastName; } else { return firstName; } } let tomcat = buildName('Tom', 'Cat'); let tom = buildName('Tom'); //参数默认值 function buildName(firstName: string, lastName: string = 'Cat') { return firstName + ' ' + lastName; } let tomcat = buildName('Tom', 'Cat'); let tom = buildName('Tom'); //剩余参数 ...rest rest 参数只能是最后一个参数 function push(array, ...items) { items.forEach(function(item) { array.push(item); }); } let a: any[] = []; push(a, 1, 2, 3); 函数重载 重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。\n比如，我们需要实现一个函数 reverse，输入数字 123 的时候，输出反转的数字 321，输入字符串 'hello' 的时候，输出反转的字符串 'olleh'。\n利用联合类型，我们可以这么实现：\nfunction reverse(x: number | string): number | string | void { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); } } 然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。\n这时，我们可以使用重载定义多个 reverse 的函数类型：\nfunction reverse(x: number): number; function reverse(x: string): string; function reverse(x: number | string): number | string | void { if (typeof x === 'number') { return Number(x.toString().split('').reverse().join('')); } else if (typeof x === 'string') { return x.split('').reverse().join(''); } } 上例中，我们重复定义了多次函数 reverse，前几次都是函数定义，最后一次是函数实现。\nTypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。\n其实写起来挺麻烦的，后面了解泛型之后写起来会简洁一些，不必太纠结函数重载，知道有这个概念即可，平时一般用泛型来解决类似问题。\n3.interface 接口 基本概念 TypeScript 中的接口是一个非常灵活的概念，常用于对「对象的形状（Shape）」进行描述。\ninterface Person { name: string; age: number; } let tom: Person = { name: 'Tom', age: 25 }; 定义的变量比接口少了一些属性或多一些属性都是不允许的，赋值的时候，变量的形状必须和接口的形状保持一致\n可选属性 ？ interface Person { name: string; age?: number; } let tom: Person = { name: 'Tom' }; let tom: Person = { name: 'Tom', age:100, gender:\"male\" //报错 仍然不允许添加未定义的属性 }; 只读属性 readonly interface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { id: 89757, name: 'Tom', gender: 'male' }; tom.id = 9527; // index.ts(14,5): error TS2540: Cannot assign to 'id' because it is a constant or a read-only property. 只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候\ninterface Person { readonly id: number; name: string; age?: number; [propName: string]: any; } let tom: Person = { name: 'Tom', gender: 'male' }; tom.id = 89757; //第一错没有给id初始值，第二错id为只读属性 interface 描述函数类型 interface 也可以用来描述函数类型，代码如下：\ninterface ISum { (x:number,y:number):number } const add:ISum = (num1, num2) =\u003e { return num1 + num2 } 任意属性 一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：\ninterface Person { name: string; age?: number; [propName: string]: string | number; } let tom: Person = { name: 'Tom', age: 25, gender: 'male' }; duck typing ( 鸭子类型 ) const fn: FunctionWithProps = (x) =\u003e { return x } fn.fnName = 'hello world' //React 的 `FunctionComponent（函数式组件）` interface FunctionComponent\u003cP = {}\u003e { (props: PropsWithChildren\u003cP\u003e, context?: any): ReactElement\u003cany, any\u003e | null; propTypes?: WeakValidationMap\u003cP\u003e | undefined; contextTypes?: ValidationMap\u003cany\u003e | undefined; defaultProps?: Partial\u003cP\u003e | undefined; displayName?: string | undefined; } 4.class 类 类的属性与方法 在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。\n我们可以用Class关键字来定义一个类 class Person { // 成员属性 name: string //构造函数 - 执行初始化操作 constructor(name: string) { this.name = name } speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person('lin') // 新建实例 p1.name // 访问属性和方法 p1.speak() 继承 继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系。\n我们可以通过 extends 关键字来实现继承\nclass Student extends Person { study() { console.log(`${this.name} needs study`) } } const s1 = new Student('lin') s1.study() super关键字 注意，上例中 Student 类没有定义自己的属性，可以不写 super ，但是如果 Student 类有自己的属性，就要用到 super 关键字来把父类的属性继承过来。\n比如，Student 类新增一个 grade(成绩) 属性，就要这么写：\nclass Student extends Person { grade: number constructor(name: string,grade:number) { super(name) this.grade = grade } } const s1 = new Student('lin', 100) //不写 super 会报错。 多态 子类对父类的方法进行了重写，子类和父类调同一个方法时会不一样。\nclass Student extends Person { speak() { return `Student ${super.speak()}` } } 私有字段 与常规属性（甚至使用 private 修饰符声明的属性）不同，私有字段要牢记以下规则：\n私有字段以 # 字符开头，有时我们称之为私有名称； 每个私有字段名称都唯一地限定于其包含的类； 不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）； 私有字段不能在包含的类之外访问，甚至不能被检测到。 class Person { #name: string; //私有字段 constructor(name: string) { this.#name = name; } greet() { console.log(`Hello, my name is ${this.#name}!`); } } let semlinker = new Person(\"Semlinker\"); semlinker.#name; // ~~~~~ // Property '#name' is not accessible outside class 'Person' // because it has a private identifier. 只属于类自己 它的实例能否访问 继承它的子类能否访问 public 公有的 能 能 private 私有的 是 不能 不能 protected 受保护的 不能 能 static 不能 能 private\nclass Person { private name: string public constructor(name: string) { this.name = name } public speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person('lv') p1.name //报错 “name” is private... class Student extends Person { study(){ console.log(`${this.name} needs study`) //报错 “name” is private... } } protected\nclass Person { protected name: string public constructor(name: string) { this.name = name } public speak() { console.log(`${this.name} is speaking`) } } const p1 = new Person('lv') p1.name //报错 “name” is protected... class Student extends Person { study(){ console.log(`${this.name} needs study`) } } 访问器 我们可以通过 getter 和 setter 方法来实现数据的封装和有效性校验，防止出现异常数据。\nlet passcode = \"Hello TypeScript\"; class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode \u0026\u0026 passcode == \"Hello TypeScript\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } } } let employee = new Employee(); employee.fullName = \"Semlinker\"; if (employee.fullName) { console.log(employee.fullName); } 抽象类 使用 abstract 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多个抽象方法。所谓的抽象方法，是指不包含具体实现的方法：\nabstract class Person { constructor(public name: string){} abstract say(words: string) :void; } // Cannot create an instance of an abstract class.(2511) const lolo = new Person(); // Error 抽象类不能被直接实例化，我们只能实例化实现了所有抽象方法的子类。\nabstract class Person { constructor(public name: string){} // 抽象方法 abstract say(words: string) :void; } class Developer extends Person { constructor(name: string) { super(name); } say(words: string): void { console.log(`${this.name} says ${words}`); } } const lolo = new Developer(\"lolo\"); lolo.say(\"I love ts!\"); // lolo says I love ts! 类方法重载 对于类的方法来说，它也支持重载。比如，示例中我们重载了 ProductService 类的 getProducts 成员方法：\nclass ProductService { getProducts(): void; getProducts(id: number): void; getProducts(id?: number) { if(typeof id === 'number') { console.log(`获取id为 ${id} 的产品信息`); } else { console.log(`获取所有的产品信息`); } } } const productService = new ProductService(); productService.getProducts(666); // 获取id为 666 的产品信息 productService.getProducts(); // 获取所有的产品信息 5.interface 和 class 的关系 interface 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。 interface 同样可以用来约束 class，要实现约束，需要用到 implements 关键字。\nimplements implements 是实现的意思，class 实现 interface。\n比如手机有播放音乐的功能，可以这么写：\ninterface MusicInterface { playMusic(): void } class Cellphone implements MusicInterface { playMusic() {} // 如果 Cellphone 类上不写 playMusic 方法，会报错。 } 定义了约束后，class 必须要满足接口上的所有条件。\n处理公共的属性和方法 不同的类有一些共同的属性和方法，使用继承很难完成。\n比如汽车（Car 类）也有播放音乐的功能，你可以这么做：\n用 Car 类继承 Cellphone 类 找一个 Car 类和 Cellphone 类的父类，父类有播放音乐的方法，他们俩继承这个父类 很显然这两种方法都不合常理。\n实际上，使用 implements，问题就会迎刃而解\ninterface MusicInterface { playMusic(): void } //Car 类和 Cellphone 类都约束了播放音乐的功能。 class Car implements MusicInterface { playMusic() {} } class Cellphone implements MusicInterface { playMusic() {} } 再比如，手机还有打电话的功能，就可以这么做，Cellphone 类 implements 两个 interface。\ninterface MusicInterface { playMusic(): void } interface CallInterface { makePhoneCall(): void } class Cellphone implements MusicInterface, CallInterface { playMusic() {} makePhoneCall() {} } interface 来约束 class，class 实现了 interface 规定的属性或方法，没有继承那么多条条框框，非常灵活。\n约束构造函数和静态属性 使用 implements 只能约束类实例上的属性和方法，要约束构造函数和静态属性，需要这么写。\n以我们上文提过的 Circl 类为例：\ninterface CircleStatic { new (radius: number): void pi: number } const Circle:CircleStatic = class Circle { static pi: 3.14 public radius: number public constructor(radius: number) { this.radius = radius } } const Circle:CircleStatic = class Circle { public radius: number //未定义静态属性 pi，会报错： 'pi' is missing public constructor(radius:string){ //constructor 入参类型不对，会报错： type 'number' is not... to type 'string' this.radius = radius } } 6.Enum 枚举类型 枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。\n数字枚举 enum Direction { NORTH, //0 SOUTH, EAST, WEST, //3 } let dir: Direction = Direction.NORTH; 设置 NORTH 的初始值，比如：\nenum Direction { NORTH = 3, SOUTH, EAST, WEST, }` 字符串枚举 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。\nenum Direction { NORTH = \"NORTH\", SOUTH = \"SOUTH\", EAST = \"EAST\", WEST = \"WEST\", } 异构枚举 enum Enum { A, B, C = \"C\", D = \"D\", E = 8, F, } //反向映射 console.log(Enum.A) //输出：0 console.log(Enum[0]) // 输出：A 7.类型推论 TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。\nlet myFavoriteNumber = 'seven'; // let myFavoriteNumber: string = 'seven' myFavoriteNumber = 7; // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查\nlet myFavoriteNumber; myFavoriteNumber = 'seven'; myFavoriteNumber = 7; 虽然 TS 可以推导出最合适的类型，但最好还是在写的时候就定义好类型，下面的例子，可以用ts这么写：\n// let arr = [0, 1, null, 'lin']; type arrItem = number | string | null let arr: arrItem[] = [0, 1, null, 'lin']; let pets: Pets[] = [new Dog(), new Cat()] 8.内置类型 JS 八种内置类型 let name: string = \"lin\"; let age: number = 18; let isHandsome: boolean = true; let u: undefined = undefined; let n: null = null; let obj: object = {name: 'lin', age: 18}; let big: bigint = 100n; let sym: symbol = Symbol(\"lin\"); ECMAScript 的内置对象 比如，Array、Date、Error 等\nconst nums: Array\u003cnumber\u003e = [1,2,3] const date: Date = new Date() const err: Error = new Error('Error!'); const reg: RegExp = /abc/; Math.pow(2, 9) DOM 和 BOM 比如 HTMLElement、NodeList、MouseEvent 等\nlet body: HTMLElement = document.body let allDiv: NodeList = document.querySelectorAll('div'); document.addEventListener('click', (e: MouseEvent) =\u003e { e.preventDefault() // Do something }); TS 进阶 1.高级类型（一） 联合类型 联合类型表示可以取值为多类型中的一种\nlet myFavoriteNumber: string | number; myFavoriteNumber = 'seven'; myFavoriteNumber = 7; 只能访问此联合类型的所有类型里共有的属性或方法：\nfunction getLength(something: string | number): number { return something.length; } // index.ts(2,22): error TS2339: Property 'length' does not exist on type 'string | number'. // Property 'length' does not exist on type 'number'. 上例中，length 不是 string 和 number 的共有属性，所以会报错。 访问 string 和 number 的共有属性是没问题的：\nfunction getString(something: string | number): string { return something.toString(); } 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型\nlet myFavoriteNumber: string | number; myFavoriteNumber = 'seven'; console.log(myFavoriteNumber.length); // 5 被推断为string myFavoriteNumber = 7; console.log(myFavoriteNumber.length); // 编译时报错 被推断为number // index.ts(5,30): error TS2339: Property 'length' does not exist on type 'number'. 交叉类型 \u0026 运算符 在 TypeScript 中交叉类型是将多个类型合并为一个类型。通过 \u0026 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。\ninterface Person { name: string age: number } type Student = Person \u0026 { grade: number } 联合类型 | 是指可以取几种类型中的任意一种，而交叉类型 \u0026 是指把几种类型合并起来。\n交叉类型和 interface 的 extends 非常类似，都是为了实现对象形状的组合和扩展。\n类型别名（ type ） 类型别名（type aliase），听名字就很好理解，就是给类型起个别名。\n就像 NBA 球员 扬尼斯-阿德托昆博，名字太长难记，我们叫他字母哥。\n就像我们项目中配置 alias，不用写相对路径就能很方便地引入文件\nimport componentA from '../../../../components/componentA/index.vue' 变成 import componentA from '@/components/componentA/index.vue 类型别名用 type 关键字来书写，有了类型别名，我们书写 TS 的时候可以更加方便简洁。\n比如下面这个例子，getName 这个函数接收的参数可能是字符串，可能是函数，就可以这么写。\ntype Name = string type NameResolver = () =\u003e string type NameOrResolver = Name | NameResolver // 联合类型 function getName(n: NameOrResolver): Name { if (typeof n === 'string') { return n } else { return n() } } getName('lin') getName(() =\u003e 'lin') 类型别名的用法：\ntype Name = string // 基本类型 type arrItem = number | string // 联合类型 const arr: arrItem[] = [1,'2', 3] type Person = { name: Name } type Student = Person \u0026 { grade: number } // 交叉类型 type Teacher = Person \u0026 { major: string } type StudentAndTeacherList = [Student, Teacher] // 元组类型 const list:StudentAndTeacherList = [ { name: 'lin', grade: 100 }, { name: 'liu', major: 'Chinese' } ] 接口与类型别名的区别 共同点 都可以用来描述对象或函数签名 //接口 interface Point { x: number; y: number; } interface SetPoint { (x: number, y: number): void; } //类型别名 type Point = { x: number; y: number; }; type SetPoint = (x: number, y: number) =\u003e void; 都允许继承 // interface 继承 interface interface PartialPointX { x: number; } interface Point extends PartialPointX { y: number; } // type 继承 type type PartialPointX = { x: number; }; type Point = PartialPointX \u0026 { y: number; }; // interface 继承 type type Person = { name: string } interface Student extends Person { \"interface用 extends 来继承\" grade: number } // type 继承 interface interface Person { name: string } type Student = Person \u0026 { grade: number } \"type用交叉类型来继承\" 不同点 设计角度 interface（接口） 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。\ntype 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\ntype 用于其它类型 与 interface 不一样，**type 可以声明基本类型、联合类型、交叉类型、元组\n// primitive type Name = string; // object type PartialPointX = { x: number; }; type PartialPointY = { y: number; }; // union type PartialPoint = PartialPointX | PartialPointY; // tuple type Data = [number, string]; interface可以合并重复声明，type 不行 interface Person { name: string } interface Person { // 重复声明 interface，就合并了 age: number } const person: Person = { name: 'lin', age: 18 } type Person = { name: string } type Person = { // 报错，Duplicate identifier 'Person' age: number } const person: Person = { name: 'lin', age: 18 } Implements 类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型：\ninterface Point { x: number; y: number; } class SomePoint implements Point { x = 1; y = 2; } type Point2 = { x: number; y: number; }; class SomePoint2 implements Point2 { x = 1; y = 2; } // 错误示例 type PartialPoint = { x: number; } | { y: number; }; // A class can only implement an object type or // intersection of object types with statically known members. class SomePartialPoint implements PartialPoint { // Error x = 1; y = 2; } 这两者的区别说了这么多，其实本不该把这两个东西拿来做对比，他们俩是完全不同的概念。\ninterface 是接口，用于描述一个对象。\ntype 是类型别名，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。\n只是有时候两者都能实现同样的功能，才会经常被混淆\n平时开发中，一般使用组合或者交叉类型的时候，用 type。\n一般要用类的 extends 或 implements 时，用 interface。\n其他情况，比如定义一个对象或者函数，就看你心情了。\n类型保护 如果有一个 getLength 函数，入参是联合类型 number | string，返回入参的 length，\nfunction getLength(arg: number | string): number { return arg.length } 从上文可知，这么写会报错，因为 number 类型上没有 length 属性。\n这个时候，类型保护（Type Guards）出现了，可以使用 typeof 关键字判断变量的类型。\n我们把 getLength 方法改造一下，就可以精准地获取到 string 类型的 length 属性了，\nfunction getLength(arg: number | string): number { if(typeof arg === 'string') { return arg.length } else { return arg.toString().length } } 类型断言 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。\n尖括号语法 let someValue: any = \"this is a string\"; let strLength: number = (\u003cstring\u003esomeValue).length; as语法 let someValue: any = \"this is a string\"; let strLength: number = (someValue as string).length; 注意，类型断言不是类型转换，把一个类型断言成联合类型中不存在的类型会报错。\n字面量类型 有时候，我们需要定义一些常量，就需要用到字面量类型，比如，\ntype ButtonSize = 'mini' | 'small' | 'normal' | 'large' type Sex = '男' | '女' const theSet: Sex = \"不男不女\" // Type '不男不女' is not assignable to type 'sex' 这样就只能从这些定义的常量中取值，乱取值会报错。\n2.泛型 泛型（Generics）是允许同一个函数接受不同类型参数的一种模板。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。\n它可以轻松解决输入输出要一致的问题。\n泛型基本使用 处理函数参数 其中 T 代表 Type，在定义泛型时通常用作第一个类型变量名称。但实际上 T 可以用任何有效名称代替。除了 T 之外，以下是常见泛型变量代表的意思：\nK（Key）：表示对象中的键类型； V（Value）：表示对象中的值类型； E（Element）：表示元素类型。 其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 U，用于扩展我们定义的 identity 函数：\nfunction identity \u003cT, U\u003e(value: T, message: U) : T { console.log(message); return value; } console.log(identity\u003cNumber, string\u003e(68, \"Semlinker\")); TS 类型推断，自动推导出类型。\nconsole.log(identity(68, \"Semlinker\")); **ype 和 interface 都可以定义函数类型，也用泛型来写一下：\n// type type Print = \u003cT\u003e(arg: T) =\u003e T const printFn:Print = function print(arg) { console.log(arg) return arg } // interface interface Iprint\u003cT\u003e { (arg: T): T } function print\u003cT\u003e(arg:T) { console.log(arg) return arg } const myPrint: Iprint\u003cnumber\u003e = print 默认参数 interface Iprint\u003cT = number\u003e { (arg: T): T } function print\u003cT\u003e(arg:T) { console.log(arg) return arg } const myPrint: Iprint = print 处理多个函数参数 传入一个只有两项的元组，交换元组的第 0 项和第 1 项，返回这个元组。\nfunction swap\u003cT,U\u003e(tuple:[T,U]):[U,T]{ return [tuple[1], tuple[0]] } const swap = \u003cT,U\u003e(tuple:[T,U]): [U,T] =\u003e{ return [tuple[1],tuple[0]] } 函数副作用操作 调用 API 都清晰的知道返回类型是什么数据结构\ninterface UserInfo { name: string age: number } function request\u003cT\u003e(url:string): Promise\u003cT\u003e { return fetch(url).then(res =\u003e res.json()) } request\u003cUserInfo\u003e('user/info').then(res =\u003e{ console.log(res) }) 约束泛型 假设现在有这么一个函数，打印传入参数的长度，我们这么写：\nfunction printLength\u003cT\u003e(arg: T): T { console.log(arg.length) //不确定 T 是否有 length 属性，会报错： property 'length' does not ... return arg } 那么现在我想约束这个泛型，一定要有 length 属性，怎么办？\n可以和 interface 结合，来约束类型。\ninterface ILength { length: number } function printLength\u003cT extends ILength\u003e(arg: T): T { console.log(arg.length) return arg } 泛型的一些应用 **泛型约束类 定义一个栈，有入栈和出栈两个方法，如果想入栈和出栈的元素类型统一，就可以这么写：\nclass Stack\u003cT\u003e { private data: T[] = [] push(item:T) { return this.data.push(item) } static pop():T | undefined { //给pop方法定义 static 关键字，报错 return this.data.pop() '泛型无法约束类的静态成员' } } const stack = new Stack\u003cstring\u003e() stack.push('124') stack.push(123) // 类型number 不能复制给string stack.pop() **泛型约束接口 interface IKeyValue\u003cT, U\u003e { key: T value: U } const k1:IKeyValue\u003cnumber, string\u003e = { key: 18, value: 'lin'} const k2:IKeyValue\u003cstring, number\u003e = { key: 'lin', value: 18} **泛型定义数组 //之前我们这么写 const arr: number[] = [1,2,3] //现在可以这样写 const arr: Array\u003cnumber\u003e = [1,2,3] 小结 泛型的好处 函数和类可以轻松地支持多种类型，增强程序的拓展性\n不必写冗长的联合类型，增强代码的可读性\n灵活控制类型之间的约束\n泛型接口 interface GenericIdentityFn\u003cT\u003e { (arg: T): T; } 泛型类 class GenericNumber\u003cT\u003e { zeroValue: T; add: (x: T, y: T) =\u003e T; } let myGenericNumber = new GenericNumber\u003cnumber\u003e(); myGenericNumber.zeroValue = 0; myGenericNumber.add = function (x, y) { return x + y; }; 泛型工具类型 3.高级类型（二） 索引类型 从对象中抽取一些属性的值，然后拼接成数组，可以这么写\nconst userInfo = { name: 'lin', age: '18', } function getValues(userInfo: any, keys: string[]) { return keys.map(key =\u003e userInfo[key]) } // 抽取指定属性的值 console.log(getValues(userInfo, ['name','age'])) // ['lin', '18'] // 抽取obj中没有的属性: console.log(getValues(userInfo, ['sex','outlook'])) // [undefined, undefined] keyof（索引查询） keyof 操作符用于获取某种类型的所有键，其返回类型是联合类型。\ninterface Person { name: string; age: number; } type K1 = keyof Person; // \"name\" | \"age\" type K2 = keyof Person[]; // \"length\" | \"toString\" | \"pop\" | \"push\" | \"concat\" | \"join\" type K3 = keyof { [x: string]: Person }; // string | number T[K]（索引访问） T[K]，表示接口 T 的属性 K 所代表的类型\ninterface IPerson { name: string; age: number; } let type1: IPerson['name'] // string let type2: IPerson['age'] // number extends (泛型约束) T extends U，表示泛型变量可以通过继承某个类型，获得某些属性。\ninterface Lengthwise { length: number; } function loggingIdentity\u003cT extends Lengthwise\u003e(arg: T): T { console.log(arg.length); return arg; } 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：\nloggingIdentity(3); // Error, number doesn't have a .length property 这时我们需要传入符合约束类型的值，必须包含必须的属性\nloggingIdentity({length: 10, value: 3}); 检查动态属性 对 getValue 函数进行改造，实现对象上动态属性的检查。\n//改造前 const userInfo = { name: 'lin', age: '18', } function getValues(userInfo: any, keys: string[]) { return keys.map(key =\u003e userInfo[key]) } // 抽取指定属性的值 console.log(getValues(userInfo, ['name','age'])) // ['lin', '18'] // 抽取obj中没有的属性: console.log(getValues(userInfo, ['sex','outlook'])) // [undefined, undefined] //改造后 - 定义泛型 T、K，用于约束 userInfo 和 keys - 为 K 增加一个泛型约束,使 K 继承 userInfo 的所有属性的联合类型, 即`K extends keyof T` function getValues\u003cT, K extends keyof T\u003e(userInfo: T, keys: K[]): T[K][] { return keys.map(key =\u003e userInfo[key]) } getValues(userInfo,['sex','outlook']) //这样当我们指定不在对象里的属性时，就会报错，Type 'sex' is not assignable to type '\"name\"|\"age\"' 映射类型 TS允许将一个类型映射成另外一个类型。\nin in 用来遍历枚举类型\ntype Keys = \"a\" | \"b\" | \"c\" type Obj = { [p in Keys]: any } // -\u003e { a: any, b: any, c: any } Partial Partial 的作用就是将某个类型里的属性全部变为可选项 ?。\n/** * node_modules/typescript/lib/lib.es5.d.ts * Make all properties in T optional */ type Partial\u003cT\u003e = { [P in keyof T]?: T[P]; }; 示例\ninterface Todo { title: string; description: string; } function updateTodo(todo: Todo, fieldsToUpdate: Partial\u003cTodo\u003e) { return { ...todo, ...fieldsToUpdate }; } const todo1 = { title: \"Learn TS\", description: \"Learn TypeScript\", }; const todo2 = updateTodo(todo1, { description: \"Learn TypeScript Enum\", }); 上面的 updateTodo 方法中，我们利用 Partial 工具类型，定义 fieldsToUpdate 的类型为 Partial，即：\n{ title?: string | undefined; description?: string | undefined; } Partial 原理\nPartial 的实现用到了 in 和 keyof\n/** * Make all properties in T optional */ type Partial\u003cT\u003e = { [P in keyof T]?: T[P] } [P in keyof T]遍历T上的所有属性 ?:设置属性为可选的 T[P]设置类型为原来的类型 Readonly Readonly将T的所有属性映射为只读的，例如：\ninterface IPerson { name: string age: number } type IReadOnly = Readonly\u003cIPerson\u003e let p1: IReadOnly = { name: 'lin', age: 18 } p1.name = 'lv' //报错，Cannot assign to 'name' because it is a read-only property. **Readonly 原理\n和 Partial 几乎完全一样\n/** * Make all properties in T readonly */ type Readonly\u003cT\u003e = { readonly [P in keyof T]: T[P] } typeof typeof 操作符用来获取一个变量声明或对象的类型。\ninterface Person { name: string; age: number; } const sem: Person = { name: 'semlinker', age: 33 }; type Sem= typeof sem; // -\u003e Person function toArray(x: number): Array\u003cnumber\u003e { return [x]; } type Func = typeof toArray; // -\u003e (x: number) =\u003e number[] 条件类型 工具类型（Utility Types） 类型体操是什么？ 4.TS声明文件 TS 实战 todolist \u003cdiv style=\"padding: 50px; background: pink\"\u003e \u003cinput type=\"text\" v-model=\"todoMsg\" /\u003e \u003cbutton @click=\"add\"\u003e添加\u003c/button\u003e \u003cbutton @click=\"clearHasDone\"\u003e清理\u003c/button\u003e \u003cdiv v-if=\"lists.length\"\u003e \u003cdiv v-for=\"(item, index) in lists\" :key=\"item.msg\"\u003e \u003cinput type=\"checkbox\" v-model=\"item.done\" /\u003e \u003cspan :class=\"{ done: item.done }\"\u003e{{ item.msg }}\u003c/span\u003e \u003cspan @click=\"deleteItem(index)\"\u003e❎\u003c/span\u003e \u003c/div\u003e \u003cdiv\u003e \u003cspan\u003e全选\u003c/span\u003e \u003cinput type=\"checkbox\" v-model=\"isAllDone\" /\u003e \u003cspan\u003e{{ hasDone }} / {{ lists.length }}\u003c/span\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv v-else\u003e暂无数据\u003c/div\u003e \u003c/div\u003e import { ElMessage } from \"element-plus\"; import { ref, computed } from \"vue\"; interface listType { done: boolean; msg: string; } const lists = ref\u003clistType[]\u003e([ { msg: \"吃饭\", done: true }, { msg: \"睡觉\", done: false }, { msg: \"打游戏\", done: false } ]); const todoMsg = ref\u003cstring\u003e(\"\"); const add = () =\u003e { if (!todoMsg.value) { ElMessage.error(\"请输入相关值！\"); return; } let params: listType = { done: false, msg: todoMsg.value }; lists.value.push(params); todoMsg.value = \"\"; }; const clearHasDone = () =\u003e { lists.value = lists.value.filter(item =\u003e !item.done); }; const deleteItem = (index: number) =\u003e { lists.value.splice(index, 1); }; const hasDone = computed(() =\u003e { return lists.value.filter(item =\u003e item.done).length; }); const isAllDone = computed\u003cboolean\u003e({ // 所有的事项是否完成，双向绑定到全选按钮 get() { // isAllDone 的获取方法，用于双向绑定数据 return hasDone.value === lists.value.length; }, set(value: boolean) { // isAllDone 的更改方法，用于实现全选 和 取消全选功能 lists.value.forEach(item =\u003e { item.done = value; }); } }); 泛型约束后端接口参数类型 import axios from 'axios' interface API { '/book/detail': { id: number, }, '/book/comment': { id: number comment: string } ... } function request\u003cT extends keyof API\u003e(url: T, obj: API[T]) { return axios.post(url, obj) } request('/book/comment', { id: 1, comment: '非常棒！' }) TS 封装 axios 请求 import { HttpResponse } from '@/common/interface' import Taro from '@tarojs/taro' import publicConfig from '@/config/index' import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, Canceler } from 'axios-miniprogram' import errorHandle from '../common/errorHandle' const CancelToken = axios.CancelToken class HttpRequest { private baseUrl: string private pending: Record\u003cstring, Canceler\u003e constructor(baseUrl: string) { this.baseUrl = baseUrl this.pending = {} } // 获取axios配置 getInsideConfig() { const config = { baseURL: this.baseUrl, headers: { 'Content-Type': 'application/json;charset=utf-8' }, timeout: 10000 } return config } removePending(key: string, isRequest = false) { if (this.pending[key] \u0026\u0026 isRequest) { this.pending[key]('取消重复请求') } delete this.pending[key] } // 设定拦截器 interceptors(instance: AxiosInstance) { instance.interceptors.request.use( config =\u003e { let isPublic = false publicConfig.publicPath.map(path =\u003e { isPublic = isPublic || path.test(config.url || '') }) const token = Taro.getStorageSync('token') if (!isPublic \u0026\u0026 token) { config.headers.Authorization = 'Bearer ' + token } const key = config.url + '\u0026' + config.method this.removePending(key, true) config.cancelToken = new CancelToken(c =\u003e { this.pending[key] = c }) return config }, err =\u003e { errorHandle(err) return Promise.reject(err) } ) // 响应请求的拦截器 instance.interceptors.response.use( res =\u003e { const key = res.config.url + '\u0026' + res.config.method this.removePending(key) if (res.status === 200) { return Promise.resolve(res.data) } else { return Promise.reject(res) } }, err =\u003e { errorHandle(err) return Promise.reject(err) } ) } // 创建实例 request(options: AxiosRequestConfig) { const instance = axios.create() const newOptions = Object.assign(this.getInsideConfig(), options) this.interceptors(instance) return instance(newOptions) } get(url: string, config?: AxiosRequestConfig): Promise\u003cAxiosResponse\u003e | Promise\u003cHttpResponse\u003e { const options = Object.assign( { method: 'get', url: url }, config ) return this.request(options) } post(url: string, data?: unknown): Promise\u003cAxiosResponse\u003e | Promise\u003cHttpResponse\u003e { return this.request({ method: 'post', url: url, data: data }) } } export default HttpRequest waiting 七、TypeScript 数组 **数组解构\nlet x: number; let y: number; let z: number; let five_array = [0,1,2,3,4]; [x,y,z] = five_array; **数组展开运算符\nlet two_array = [0, 1]; let five_array = [...two_array, 2, 3, 4]; **数组遍历\nlet colors: string[] = [\"red\", \"green\", \"blue\"]; for (let i of colors) { //获取每一个对象 console.log(i); } // for (let i in colors) 获取下标 八、TypeScript 对象 //公共数组 let person = { name: \"Semlinker\", gender: \"Male\", address: \"Xiamen\", }; **对象解构\nlet {name, gender} = person **对象展开运算符\n组装对象 let personWithAge = { ...person, age: 33 }; 获取除了某些项外的其它项 let { name, ...rest } = person; 十三、配置文件 tsconfig.json 作用 用于标识 TypeScript 项目的根路径； 用于配置 TypeScript 编译器； 用于指定编译的文件。 重要字段 files - 设置要编译的文件的名称； include - 设置需要进行编译的文件，支持路径模式匹配； exclude - 设置无需进行编译的文件，支持路径模式匹配； compilerOptions - 设置与编译流程相关的选项 compilerOptions 选项 compilerOptions 支持很多选项，常见的有 baseUrl、 target、baseUrl、 moduleResolution 和 lib 等。\ncompilerOptions 每个选项的详细说明如下：\n{ \"compilerOptions\": { /* 基本选项 */ \"target\": \"es5\", // 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES6'/'ES2015', 'ES2016', 'ES2017', or 'ESNEXT' \"module\": \"commonjs\", // 指定使用模块: 'commonjs', 'amd', 'system', 'umd' or 'es2015' \"lib\": [], // 指定要包含在编译中的库文件 \"allowJs\": true, // 允许编译 javascript 文件 \"checkJs\": true, // 报告 javascript 文件中的错误 \"jsx\": \"preserve\", // 指定 jsx 代码的生成: 'preserve', 'react-native', or 'react' \"declaration\": true, // 生成相应的 '.d.ts' 文件 \"sourceMap\": true, // 生成相应的 '.map' 文件 \"outFile\": \"./\", // 将输出文件合并为一个文件 \"outDir\": \"./\", // 指定输出目录 \"rootDir\": \"./\", // 用来控制输出目录结构 --outDir. \"removeComments\": true, // 删除编译后的所有的注释 \"noEmit\": true, // 不生成输出文件 \"importHelpers\": true, // 从 tslib 导入辅助工具函数 \"isolatedModules\": true, // 将每个文件做为单独的模块 （与 'ts.transpileModule' 类似）. /* 严格的类型检查选项 */ \"strict\": true, // 启用所有严格类型检查选项 \"noImplicitAny\": true, // 在表达式和声明上有隐含的 any类型时报错 \"strictNullChecks\": true, // 启用严格的 null 检查 \"noImplicitThis\": true, // 当 this 表达式值为 any 类型的时候，生成一个错误 \"alwaysStrict\": true, // 以严格模式检查每个模块，并在每个文件里加入 'use strict' /* 额外的检查 */ \"noUnusedLocals\": true, // 有未使用的变量时，抛出错误 \"noUnusedParameters\": true, // 有未使用的参数时，抛出错误 \"noImplicitReturns\": true, // 并不是所有函数里的代码都有返回值时，抛出错误 \"noFallthroughCasesInSwitch\": true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ \"moduleResolution\": \"node\", // 选择模块解析策略： 'node' (Node.js) or 'classic' (TypeScript pre-1.6) \"baseUrl\": \"./\", // 用于解析非相对模块名称的基目录 \"paths\": {}, // 模块名到基于 baseUrl 的路径映射的列表 \"rootDirs\": [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 \"typeRoots\": [], // 包含类型声明的文件列表 \"types\": [], // 需要包含的类型声明文件名列表 \"allowSyntheticDefaultImports\": true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ \"sourceRoot\": \"./\", // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 \"mapRoot\": \"./\", // 指定调试器应该找到映射文件而不是生成文件的位置 \"inlineSourceMap\": true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 \"inlineSources\": true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ \"experimentalDecorators\": true, // 启用装饰器 \"emitDecoratorMetadata\": true // 为装饰器提供元数据的支持 } } 3.2 非空断言 在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 ! 可以用于断言操作对象是非 null 和非 undefined 类型。具体而言，x! 将从 x 值域中排除 null 和 undefined 。\n那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。\n1.忽略 undefined 和 null 类型 function myFunc(maybeString: string | undefined | null) { // Type 'string | null | undefined' is not assignable to type 'string'. // Type 'undefined' is not assignable to type 'string'. const onlyString: string = maybeString; // Error const ignoreUndefinedAndNull: string = maybeString!; // Ok } 2.调用函数时忽略 undefined 类型 type NumGenerator = () =\u003e number; function myFunc(numGenerator: NumGenerator | undefined) { // Object is possibly 'undefined'.(2532) // Cannot invoke an object which is possibly 'undefined'.(2722) const num1 = numGenerator(); // Error const num2 = numGenerator!(); //OK } 因为 ! 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：\nconst a: number | undefined = undefined; const b: number = a!; console.log(b); 以上 TS 代码会编译生成以下 ES5 代码：\nconst a: number | undefined = undefined; const b: number = a!; console.log(b); 虽然在 TS 代码中，我们使用了非空断言，使得 const b: number = a!; 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，! 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 undefined。\n3.3 确定赋值断言 在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 ! 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：\nlet x: number; initialize(); // Variable 'x' is used before being assigned.(2454) console.log(2 * x); // Error function initialize() { x = 10; } 很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：\nlet x!: number; initialize(); console.log(2 * x); // Ok function initialize() { x = 10; } 通过 let x!: number; 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。\n","wordCount":"11782","inLanguage":"en","datePublished":"2023-08-11T17:11:35+08:00","dateModified":"2023-08-11T17:11:35+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://bablvsj.github.io/posts/work/tech/codelanguage/20230815-typescript/"},"publisher":{"@type":"Organization","name":"Bablvsj's Blog","logo":{"@type":"ImageObject","url":"https://bablvsj.github.io/img/Q.gif"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bablvsj.github.io accesskey=h title="Bablvsj's Blog (Alt + H)">Bablvsj's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bablvsj.github.io/ title=主页><span>主页</span></a></li><li><a href=https://bablvsj.github.io/archives/ title=时间轴><span>时间轴</span></a></li><li><a href=https://bablvsj.github.io/tags title=标签><span>标签</span></a></li><li><a href=https://bablvsj.github.io/about title=关于><span>关于</span></a></li><li><a href=https://bablvsj.github.io/search title="🔍 (Alt + /)" accesskey=/><span>🔍</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>TypeScript</h1><div class=post-meta><div class=post-tags-meta><a href=https://bablvsj.github.io/tags/typescript/>TypeScript</a>
<a href=https://bablvsj.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>· 编程语言</a></div>24 min&nbsp;·&nbsp;<span title='2023-08-11 17:11:35 +0800 +0800'>2023/08/11</span></div></header><aside id=toc-container class="toc-container wide"><div class=toc><div class=inner><ul><li><a href=#%e7%b1%bb%e5%9e%8b%e7%b3%bb%e7%bb%9f aria-label=类型系统>类型系统</a><ul><li><a href=#typescript%e6%98%af%e9%9d%99%e6%80%81%e7%b1%bb%e5%9e%8b-%e6%a0%b9%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%a3%80%e6%9f%a5%e7%9a%84%e6%97%b6%e6%9c%ba%e6%9d%a5%e5%88%86%e7%b1%bb aria-label="TypeScript是静态类型 （根据类型检查的时机来分类）">TypeScript是静态类型 （根据类型检查的时机来分类）</a></li><li><a href=#typescript--javascript-%e9%83%bd%e6%98%af%e5%bc%b1%e7%b1%bb%e5%9e%8b---%e6%a0%b9%e6%8d%ae%e6%98%af%e5%90%a6%e5%85%81%e8%ae%b8%e9%9a%90%e5%bc%8f%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e6%9d%a5%e5%88%86%e7%b1%bb aria-label="TypeScript / JavaScript 都是弱类型   （根据是否允许隐式类型转换来分类）">TypeScript / JavaScript 都是弱类型 （根据是否允许隐式类型转换来分类）</a></li><li><a href=#%e5%ae%89%e8%a3%85typescript aria-label=安装typescript>安装typescript</a></li><li><a href=#ts%e5%9f%ba%e7%a1%80 aria-label=TS基础>TS基础</a></li></ul></li><li><a href=#1%e5%9f%ba%e7%a1%80%e7%b1%bb%e5%9e%8b aria-label=1.基础类型>1.基础类型</a><ul><li><a href=#%e5%b8%83%e5%b0%94%e5%80%bc-boolean aria-label="布尔值 boolean">布尔值 boolean</a></li><li><a href=#%e6%95%b0%e5%80%bc-number aria-label="数值 number">数值 number</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2-string aria-label="字符串 string">字符串 string</a></li><li><a href=#null-%e5%92%8c-undefined aria-label="null 和 undefined">null 和 undefined</a></li><li><a href=#%e4%bb%bb%e6%84%8f%e5%80%bc-any aria-label="任意值 any">任意值 any</a><ul><li><a href=#%e4%bb%80%e4%b9%88%e6%98%af%e4%bb%bb%e6%84%8f%e5%80%bc%e7%b1%bb%e5%9e%8b aria-label=什么是任意值类型>什么是任意值类型</a></li><li><a href=#%e4%bb%bb%e6%84%8f%e5%80%bc%e7%9a%84%e5%b1%9e%e6%80%a7%e5%92%8c%e6%96%b9%e6%b3%95 aria-label=任意值的属性和方法>任意值的属性和方法</a></li><li><a href=#%e6%9c%aa%e5%a3%b0%e6%98%8e%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8f%98%e9%87%8f aria-label=未声明类型的变量>未声明类型的变量</a></li></ul></li><li><a href=#unknow-%e7%b1%bb%e5%9e%8b aria-label="unknow 类型">unknow 类型</a></li><li><a href=#%e7%a9%ba%e5%80%bc-void aria-label="空值 void">空值 void</a></li><li><a href=#never-%e7%b1%bb%e5%9e%8b aria-label="never 类型">never 类型</a></li><li><a href=#%e6%95%b0%e7%bb%84%e7%9a%84%e7%b1%bb%e5%9e%8b aria-label=数组的类型>数组的类型</a><ul><li><a href=#%e7%b1%bb%e5%9e%8b%e6%96%b9%e6%8b%ac%e5%8f%b7-%e8%a1%a8%e7%a4%ba%e6%b3%95 aria-label="类型+方括号 表示法">类型+方括号 表示法</a></li><li><a href=#%e6%95%b0%e7%bb%84%e6%b3%9b%e5%9e%8b--arrayelemtype aria-label="数组泛型 array&amp;lt;elemType&amp;gt;">数组泛型 array<code>&lt;elemType></code></a></li><li><a href=#%e7%94%a8%e6%8e%a5%e5%8f%a3%e8%a1%a8%e7%a4%ba%e6%95%b0%e7%bb%84 aria-label=用接口表示数组>用接口表示数组</a></li></ul></li><li><a href=#%e5%85%83%e7%bb%84-tuple-%e7%b1%bb%e5%9e%8b aria-label="元组 Tuple 类型">元组 Tuple 类型</a></li></ul></li><li><a href=#2%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b aria-label=2.函数类型>2.函数类型</a><ul><li><a href=#%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd aria-label=函数重载>函数重载</a></li></ul></li><li><a href=#3interface-%e6%8e%a5%e5%8f%a3 aria-label="3.interface 接口">3.interface 接口</a><ul><li><a href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5 aria-label=基本概念>基本概念</a></li><li><a href=#%e5%8f%af%e9%80%89%e5%b1%9e%e6%80%a7- aria-label="可选属性 ？">可选属性 ？</a></li><li><a href=#%e5%8f%aa%e8%af%bb%e5%b1%9e%e6%80%a7-readonly aria-label="只读属性 readonly">只读属性 readonly</a></li><li><a href=#interface-%e6%8f%8f%e8%bf%b0%e5%87%bd%e6%95%b0%e7%b1%bb%e5%9e%8b aria-label="interface 描述函数类型">interface 描述函数类型</a></li><li><a href=#%e4%bb%bb%e6%84%8f%e5%b1%9e%e6%80%a7 aria-label=任意属性>任意属性</a></li><li><a href=#duck-typing--%e9%b8%ad%e5%ad%90%e7%b1%bb%e5%9e%8b- aria-label="duck typing ( 鸭子类型 )">duck typing ( 鸭子类型 )</a></li></ul></li><li><a href=#4class-%e7%b1%bb aria-label="4.class 类">4.class 类</a><ul><li><a href=#%e7%b1%bb%e7%9a%84%e5%b1%9e%e6%80%a7%e4%b8%8e%e6%96%b9%e6%b3%95 aria-label=类的属性与方法>类的属性与方法</a></li><li><a href=#%e7%bb%a7%e6%89%bf aria-label=继承>继承</a><ul><li><a href=#super%e5%85%b3%e9%94%ae%e5%ad%97 aria-label=super关键字>super关键字</a></li></ul></li><li><a href=#%e5%a4%9a%e6%80%81 aria-label=多态>多态</a></li><li><a href=#%e7%a7%81%e6%9c%89%e5%ad%97%e6%ae%b5 aria-label=私有字段>私有字段</a></li><li><a href=#%e8%ae%bf%e9%97%ae%e5%99%a8 aria-label=访问器>访问器</a></li><li><a href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb aria-label=抽象类>抽象类</a></li><li><a href=#%e7%b1%bb%e6%96%b9%e6%b3%95%e9%87%8d%e8%bd%bd aria-label=类方法重载>类方法重载</a></li></ul></li><li><a href=#5interface-%e5%92%8c-class-%e7%9a%84%e5%85%b3%e7%b3%bb aria-label="5.interface 和 class 的关系">5.interface 和 class 的关系</a><ul><li><a href=#implements aria-label=implements>implements</a></li><li><a href=#%e5%a4%84%e7%90%86%e5%85%ac%e5%85%b1%e7%9a%84%e5%b1%9e%e6%80%a7%e5%92%8c%e6%96%b9%e6%b3%95 aria-label=处理公共的属性和方法>处理公共的属性和方法</a></li><li><a href=#%e7%ba%a6%e6%9d%9f%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e5%92%8c%e9%9d%99%e6%80%81%e5%b1%9e%e6%80%a7 aria-label=约束构造函数和静态属性>约束构造函数和静态属性</a></li></ul></li><li><a href=#6enum-%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b aria-label="6.Enum 枚举类型">6.Enum 枚举类型</a><ul><li><a href=#%e6%95%b0%e5%ad%97%e6%9e%9a%e4%b8%be aria-label=数字枚举>数字枚举</a></li><li><a href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%9e%9a%e4%b8%be aria-label=字符串枚举>字符串枚举</a></li><li><a href=#%e5%bc%82%e6%9e%84%e6%9e%9a%e4%b8%be aria-label=异构枚举>异构枚举</a></li></ul></li><li><a href=#7%e7%b1%bb%e5%9e%8b%e6%8e%a8%e8%ae%ba aria-label=7.类型推论>7.类型推论</a></li><li><a href=#8%e5%86%85%e7%bd%ae%e7%b1%bb%e5%9e%8b aria-label=8.内置类型>8.内置类型</a><ul><li><a href=#js-%e5%85%ab%e7%a7%8d%e5%86%85%e7%bd%ae%e7%b1%bb%e5%9e%8b aria-label="JS 八种内置类型">JS 八种内置类型</a></li><li><a href=#ecmascript-%e7%9a%84%e5%86%85%e7%bd%ae%e5%af%b9%e8%b1%a1 aria-label="ECMAScript 的内置对象">ECMAScript 的内置对象</a></li><li><a href=#dom-%e5%92%8c-bom aria-label="DOM 和 BOM">DOM 和 BOM</a></li><li><a href=#ts-%e8%bf%9b%e9%98%b6 aria-label="TS 进阶">TS 进阶</a></li></ul></li><li><a href=#1%e9%ab%98%e7%ba%a7%e7%b1%bb%e5%9e%8b%e4%b8%80 aria-label=1.高级类型（一）>1.高级类型（一）</a><ul><li><a href=#%e8%81%94%e5%90%88%e7%b1%bb%e5%9e%8b aria-label=联合类型>联合类型</a></li><li><a href=#%e4%ba%a4%e5%8f%89%e7%b1%bb%e5%9e%8b aria-label=交叉类型>交叉类型</a><ul><li><a href=#-%e8%bf%90%e7%ae%97%e7%ac%a6 aria-label="&amp;amp; 运算符">& 运算符</a></li></ul></li><li><a href=#%e7%b1%bb%e5%9e%8b%e5%88%ab%e5%90%8d-type- aria-label="类型别名（ type ）">类型别名（ type ）</a></li><li><a href=#%e6%8e%a5%e5%8f%a3%e4%b8%8e%e7%b1%bb%e5%9e%8b%e5%88%ab%e5%90%8d%e7%9a%84%e5%8c%ba%e5%88%ab aria-label=接口与类型别名的区别>接口与类型别名的区别</a><ul><li><a href=#%e5%85%b1%e5%90%8c%e7%82%b9 aria-label=共同点>共同点</a></li><li><a href=#%e9%83%bd%e5%8f%af%e4%bb%a5%e7%94%a8%e6%9d%a5%e6%8f%8f%e8%bf%b0%e5%af%b9%e8%b1%a1%e6%88%96%e5%87%bd%e6%95%b0%e7%ad%be%e5%90%8d aria-label=都可以用来描述对象或函数签名>都可以用来描述对象或函数签名</a></li><li><a href=#%e9%83%bd%e5%85%81%e8%ae%b8%e7%bb%a7%e6%89%bf aria-label=都允许继承>都允许继承</a></li><li><a href=#%e4%b8%8d%e5%90%8c%e7%82%b9 aria-label=不同点>不同点</a></li><li><a href=#%e8%ae%be%e8%ae%a1%e8%a7%92%e5%ba%a6 aria-label=设计角度>设计角度</a></li><li><a href=#type-%e7%94%a8%e4%ba%8e%e5%85%b6%e5%ae%83%e7%b1%bb%e5%9e%8b aria-label="type 用于其它类型">type 用于其它类型</a></li><li><a href=#interface%e5%8f%af%e4%bb%a5%e5%90%88%e5%b9%b6%e9%87%8d%e5%a4%8d%e5%a3%b0%e6%98%8etype-%e4%b8%8d%e8%a1%8c aria-label="interface可以合并重复声明，type 不行">interface可以合并重复声明，type 不行</a></li><li><a href=#implements-1 aria-label=Implements>Implements</a></li></ul></li><li><a href=#%e7%b1%bb%e5%9e%8b%e4%bf%9d%e6%8a%a4 aria-label=类型保护>类型保护</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80 aria-label=类型断言>类型断言</a></li><li><a href=#%e5%ad%97%e9%9d%a2%e9%87%8f%e7%b1%bb%e5%9e%8b aria-label=字面量类型>字面量类型</a></li></ul></li><li><a href=#2%e6%b3%9b%e5%9e%8b aria-label=2.泛型>2.泛型</a><ul><li><a href=#%e6%b3%9b%e5%9e%8b%e5%9f%ba%e6%9c%ac%e4%bd%bf%e7%94%a8 aria-label=泛型基本使用>泛型基本使用</a><ul><li><a href=#%e5%a4%84%e7%90%86%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0 aria-label=处理函数参数>处理函数参数</a></li><li><a href=#%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0 aria-label=默认参数>默认参数</a></li><li><a href=#%e5%a4%84%e7%90%86%e5%a4%9a%e4%b8%aa%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0 aria-label=处理多个函数参数>处理多个函数参数</a></li><li><a href=#%e5%87%bd%e6%95%b0%e5%89%af%e4%bd%9c%e7%94%a8%e6%93%8d%e4%bd%9c aria-label=函数副作用操作>函数副作用操作</a></li><li><a href=#%e7%ba%a6%e6%9d%9f%e6%b3%9b%e5%9e%8b aria-label=约束泛型>约束泛型</a></li><li><a href=#%e6%b3%9b%e5%9e%8b%e7%9a%84%e4%b8%80%e4%ba%9b%e5%ba%94%e7%94%a8 aria-label=泛型的一些应用>泛型的一些应用</a></li></ul></li><li><a href=#%e5%b0%8f%e7%bb%93 aria-label=小结>小结</a><ul><li><a href=#%e6%b3%9b%e5%9e%8b%e7%9a%84%e5%a5%bd%e5%a4%84 aria-label=泛型的好处>泛型的好处</a></li><li><a href=#%e6%b3%9b%e5%9e%8b%e6%8e%a5%e5%8f%a3 aria-label=泛型接口>泛型接口</a></li><li><a href=#%e6%b3%9b%e5%9e%8b%e7%b1%bb aria-label=泛型类>泛型类</a></li><li><a href=#%e6%b3%9b%e5%9e%8b%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8b aria-label=泛型工具类型>泛型工具类型</a></li></ul></li></ul></li><li><a href=#3%e9%ab%98%e7%ba%a7%e7%b1%bb%e5%9e%8b%e4%ba%8c aria-label=3.高级类型（二）>3.高级类型（二）</a><ul><li><a href=#%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b aria-label=索引类型>索引类型</a><ul><li><a href=#keyof%e7%b4%a2%e5%bc%95%e6%9f%a5%e8%af%a2 aria-label=keyof（索引查询）>keyof（索引查询）</a></li><li><a href=#tk%e7%b4%a2%e5%bc%95%e8%ae%bf%e9%97%ae aria-label=T[K]（索引访问）>T[K]（索引访问）</a></li><li><a href=#extends-%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f aria-label="extends (泛型约束)">extends (泛型约束)</a></li><li><a href=#%e6%a3%80%e6%9f%a5%e5%8a%a8%e6%80%81%e5%b1%9e%e6%80%a7 aria-label=检查动态属性>检查动态属性</a></li></ul></li><li><a href=#%e6%98%a0%e5%b0%84%e7%b1%bb%e5%9e%8b aria-label=映射类型>映射类型</a><ul><li><a href=#in aria-label=in>in</a></li><li><a href=#partial aria-label=Partial>Partial</a></li><li><a href=#readonly aria-label=Readonly>Readonly</a></li><li><a href=#typeof aria-label=typeof>typeof</a></li></ul></li><li><a href=#%e6%9d%a1%e4%bb%b6%e7%b1%bb%e5%9e%8b aria-label=条件类型>条件类型</a></li><li><a href=#%e5%b7%a5%e5%85%b7%e7%b1%bb%e5%9e%8butility-types aria-label="工具类型（Utility Types）">工具类型（Utility Types）</a></li><li><a href=#%e7%b1%bb%e5%9e%8b%e4%bd%93%e6%93%8d%e6%98%af%e4%bb%80%e4%b9%88 aria-label=类型体操是什么？>类型体操是什么？</a></li></ul></li><li><a href=#4ts%e5%a3%b0%e6%98%8e%e6%96%87%e4%bb%b6 aria-label=4.TS声明文件>4.TS声明文件</a><ul><li><a href=#ts-%e5%ae%9e%e6%88%98 aria-label="TS 实战">TS 实战</a></li><li><a href=#todolist aria-label=todolist>todolist</a></li><li><a href=#%e6%b3%9b%e5%9e%8b%e7%ba%a6%e6%9d%9f%e5%90%8e%e7%ab%af%e6%8e%a5%e5%8f%a3%e5%8f%82%e6%95%b0%e7%b1%bb%e5%9e%8b aria-label=泛型约束后端接口参数类型>泛型约束后端接口参数类型</a></li><li><a href=#ts-%e5%b0%81%e8%a3%85-axios-%e8%af%b7%e6%b1%82 aria-label="TS 封装 axios 请求">TS 封装 axios 请求</a></li><li><a href=#waiting aria-label=waiting>waiting</a></li><li><a href=#%e4%b8%83typescript-%e6%95%b0%e7%bb%84 aria-label="七、TypeScript 数组">七、TypeScript 数组</a></li></ul></li><li><a href=#%e5%85%abtypescript-%e5%af%b9%e8%b1%a1 aria-label="八、TypeScript 对象">八、TypeScript 对象</a></li><li><a href=#%e5%8d%81%e4%b8%89%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6-tsconfigjson aria-label="十三、配置文件 tsconfig.json">十三、配置文件 tsconfig.json</a><ul><ul><li><a href=#%e4%bd%9c%e7%94%a8 aria-label=作用>作用</a></li><li><a href=#%e9%87%8d%e8%a6%81%e5%ad%97%e6%ae%b5 aria-label= 重要字段> 重要字段</a></li><li><a href=#compileroptions-%e9%80%89%e9%a1%b9 aria-label="compilerOptions 选项">compilerOptions 选项</a></li></ul><li><a href=#32-%e9%9d%9e%e7%a9%ba%e6%96%ad%e8%a8%80 aria-label="3.2 非空断言">3.2 非空断言</a><ul><li><a href=#1%e5%bf%bd%e7%95%a5-undefined-%e5%92%8c-null-%e7%b1%bb%e5%9e%8b aria-label="1.忽略 undefined 和 null 类型">1.忽略 undefined 和 null 类型</a></li><li><a href=#2%e8%b0%83%e7%94%a8%e5%87%bd%e6%95%b0%e6%97%b6%e5%bf%bd%e7%95%a5-undefined-%e7%b1%bb%e5%9e%8b aria-label="2.调用函数时忽略 undefined 类型">2.调用函数时忽略 undefined 类型</a></li></ul></li><li><a href=#33-%e7%a1%ae%e5%ae%9a%e8%b5%8b%e5%80%bc%e6%96%ad%e8%a8%80 aria-label="3.3 确定赋值断言">3.3 确定赋值断言</a></li></ul></li></ul></div></div></aside><script>let activeElement,elements;window.addEventListener("DOMContentLoaded",function(){checkTocPosition(),elements=document.querySelectorAll("h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]"),activeElement=elements[0];const t=encodeURI(activeElement.getAttribute("id")).toLowerCase();document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active")},!1),window.addEventListener("resize",function(){checkTocPosition()},!1),window.addEventListener("scroll",()=>{activeElement=Array.from(elements).find(e=>{if(getOffsetTop(e)-window.pageYOffset>0&&getOffsetTop(e)-window.pageYOffset<window.innerHeight/2)return e})||activeElement,elements.forEach(e=>{const t=encodeURI(e.getAttribute("id")).toLowerCase();e===activeElement?document.querySelector(`.inner ul li a[href="#${t}"]`).classList.add("active"):document.querySelector(`.inner ul li a[href="#${t}"]`).classList.remove("active")})},!1);const main=parseInt(getComputedStyle(document.body).getPropertyValue("--article-width"),10),toc=parseInt(getComputedStyle(document.body).getPropertyValue("--toc-width"),10),gap=parseInt(getComputedStyle(document.body).getPropertyValue("--gap"),10);function checkTocPosition(){const e=document.body.scrollWidth;e-main-toc*2-gap*4>0?document.getElementById("toc-container").classList.add("wide"):document.getElementById("toc-container").classList.remove("wide")}function getOffsetTop(e){if(!e.getClientRects().length)return 0;let t=e.getBoundingClientRect(),n=e.ownerDocument.defaultView;return t.top+n.pageYOffset}</script><div class=post-content><h2 id=类型系统>类型系统<a hidden class=anchor aria-hidden=true href=#类型系统>#</a></h2><h3 id=typescript是静态类型-根据类型检查的时机来分类>TypeScript是静态类型 （根据类型检查的时机来分类）<a hidden class=anchor aria-hidden=true href=#typescript是静态类型-根据类型检查的时机来分类>#</a></h3><p><code>动态类型</code>是指在运行时才会进行类型检查，这种语言的类型错误往往会导致运行时错误。JavaScript 是一门解释型语言，没有编译阶段，所以它是动态类型，以下这段代码在运行时才会报错：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#af3a03>let</span> foo <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>;
</span></span><span style=display:flex><span>foo.split(<span style=color:#79740e>&#39; &#39;</span>);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Uncaught TypeError: foo.split is not a function
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 运行时会报错（foo.split 不是一个函数），造成线上 bug
</span></span></span></code></pre></div><p><code>静态类型</code>是指编译阶段就能确定每个变量的类型，这种语言的类型错误往往会导致语法错误。TypeScript 在运行前需要先编译为 JavaScript，而在编译阶段就会进行类型检查，所以 <strong>TypeScript 是静态类型</strong>，这段 TypeScript 代码在编译阶段就会报错了：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> foo <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>;  <span style=color:#928374;font-style:italic>//类型推断 let foo: number = 1;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>foo.split(<span style=color:#79740e>&#39; &#39;</span>);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Property &#39;split&#39; does not exist on type &#39;number&#39;.
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 编译时会报错（数字没有 split 方法），无法通过编译
</span></span></span></code></pre></div><h3 id=typescript--javascript-都是弱类型---根据是否允许隐式类型转换来分类>TypeScript / JavaScript 都是弱类型 （根据是否允许隐式类型转换来分类）<a hidden class=anchor aria-hidden=true href=#typescript--javascript-都是弱类型---根据是否允许隐式类型转换来分类>#</a></h3><h3 id=安装typescript>安装typescript<a hidden class=anchor aria-hidden=true href=#安装typescript>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>npm install -g typescript
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tsc -v   // Version x.x.x
</span></span></code></pre></div><h3 id=ts基础>TS基础<a hidden class=anchor aria-hidden=true href=#ts基础>#</a></h3><h2 id=1基础类型>1.基础类型<a hidden class=anchor aria-hidden=true href=#1基础类型>#</a></h2><h3 id=布尔值-boolean>布尔值 boolean<a hidden class=anchor aria-hidden=true href=#布尔值-boolean>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> isDone: <span style=color:#b57614>boolean</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>false</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> createdByNewBoolean: <span style=color:#b57614>Boolean</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Boolean</span>(<span style=color:#8f3f71>1</span>);   <span style=color:#928374;font-style:italic>//非布尔值！ 返回的是一个 Boolean对象
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> createdByBoolean: <span style=color:#b57614>Boolean</span> <span style=color:#af3a03>=</span> <span style=color:#b57614>Boolean</span>(<span style=color:#8f3f71>1</span>)  <span style=color:#928374;font-style:italic>// 直接调用可返回一个 boolean 类型
</span></span></span></code></pre></div><h3 id=数值-number>数值 number<a hidden class=anchor aria-hidden=true href=#数值-number>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> decLiteral: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#8f3f71>6</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> hexLiteral: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#8f3f71>0xf00d</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> binaryLiteral: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#8f3f71>0</span>b1010; <span style=color:#928374;font-style:italic>//ES6的二进制表示法  会被编译成十进制
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> octalLiteral: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#8f3f71>0</span>o744;   <span style=color:#928374;font-style:italic>//ES6的八进制表示法  ...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> notANumber: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>NaN</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> infinityNumber: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>Infinity</span>;
</span></span></code></pre></div><h3 id=字符串-string>字符串 string<a hidden class=anchor aria-hidden=true href=#字符串-string>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> myName: <span style=color:#b57614>string</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;Tom&#39;</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> myAge: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#8f3f71>25</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 模板字符串
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> sentence: <span style=color:#b57614>string</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>`Hello, my name is </span><span style=color:#79740e>${</span>myName<span style=color:#79740e>}</span><span style=color:#79740e>.
</span></span></span><span style=display:flex><span><span style=color:#79740e>I&#39;ll be </span><span style=color:#79740e>${</span>myAge <span style=color:#af3a03>+</span> <span style=color:#8f3f71>1</span><span style=color:#79740e>}</span><span style=color:#79740e> years old next month.`</span>;
</span></span></code></pre></div><h3 id=null-和-undefined>null 和 undefined<a hidden class=anchor aria-hidden=true href=#null-和-undefined>#</a></h3><p>在 TypeScript 中，可以使用 <code>null</code> 和 <code>undefined</code> 来定义这两个原始数据类型：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> u: <span style=color:#b57614>undefined</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> n: <span style=color:#b57614>null</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>null</span>;
</span></span></code></pre></div><p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>// 这样不会报错
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> num: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>undefined</span>;
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>// 这样也不会报错
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> u: <span style=color:#b57614>undefined</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> num: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> u;
</span></span></code></pre></div><p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> u: <span style=color:#b57614>void</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> num: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> u;
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Type &#39;void&#39; is not assignable to type &#39;number&#39;.
</span></span></span></code></pre></div><h3 id=任意值-any>任意值 any<a hidden class=anchor aria-hidden=true href=#任意值-any>#</a></h3><h4 id=什么是任意值类型>什么是任意值类型<a hidden class=anchor aria-hidden=true href=#什么是任意值类型>#</a></h4><p>如果是一个普通类型，在赋值过程中改变类型是不被允许的：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> myFavoriteNumber: <span style=color:#b57614>string</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;seven&#39;</span>;
</span></span><span style=display:flex><span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#8f3f71>7</span>;
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</span></span></span></code></pre></div><p>但如果是 <code>any</code> 类型，则允许被赋值为任意类型。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> myFavoriteNumber: <span style=color:#b57614>any</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;seven&#39;</span>;
</span></span><span style=display:flex><span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#8f3f71>7</span>;
</span></span></code></pre></div><h4 id=任意值的属性和方法>任意值的属性和方法<a hidden class=anchor aria-hidden=true href=#任意值的属性和方法>#</a></h4><p>在任意值上访问任何属性都是允许的：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> anyThing: <span style=color:#b57614>any</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;hello&#39;</span>;
</span></span><span style=display:flex><span>console.log(anyThing.myName);
</span></span><span style=display:flex><span>console.log(anyThing.myName.firstName);
</span></span></code></pre></div><p>也允许调用任何方法：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> anyThing: <span style=color:#b57614>any</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;Tom&#39;</span>;
</span></span><span style=display:flex><span>anyThing.setName(<span style=color:#79740e>&#39;Jerry&#39;</span>);
</span></span><span style=display:flex><span>anyThing.setName(<span style=color:#79740e>&#39;Jerry&#39;</span>).sayHello();
</span></span><span style=display:flex><span>anyThing.myName.setFirstName(<span style=color:#79740e>&#39;Cat&#39;</span>);
</span></span></code></pre></div><p>可以认为，<strong>声明一个变量为任意值之后，对它的任何操作，返回的内容的类型都是任意值</strong>。</p><h4 id=未声明类型的变量>未声明类型的变量<a hidden class=anchor aria-hidden=true href=#未声明类型的变量>#</a></h4><p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> something;
</span></span><span style=display:flex><span>something <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;seven&#39;</span>;
</span></span><span style=display:flex><span>something <span style=color:#af3a03>=</span> <span style=color:#8f3f71>7</span>;
</span></span><span style=display:flex><span>something.setName(<span style=color:#79740e>&#39;Tom&#39;</span>);
</span></span></code></pre></div><p>等价于</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> something: <span style=color:#b57614>any</span>;
</span></span><span style=display:flex><span>something <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;seven&#39;</span>;
</span></span><span style=display:flex><span>something <span style=color:#af3a03>=</span> <span style=color:#8f3f71>7</span>;
</span></span><span style=display:flex><span>something.setName(<span style=color:#79740e>&#39;Tom&#39;</span>);
</span></span></code></pre></div><h3 id=unknow-类型>unknow 类型<a hidden class=anchor aria-hidden=true href=#unknow-类型>#</a></h3><p>就像所有类型都可以赋值给 any，所有类型也都可以赋值给 unknown。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> value: <span style=color:#b57614>unknown</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>value <span style=color:#af3a03>=</span> <span style=color:#af3a03>true</span>; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> <span style=color:#8f3f71>42</span>; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;Hello World&#34;</span>; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> []; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> {}; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> <span style=color:#b57614>Math</span>.random; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> <span style=color:#af3a03>null</span>; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> <span style=color:#af3a03>undefined</span>; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> TypeError(); <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>value <span style=color:#af3a03>=</span> Symbol(<span style=color:#79740e>&#34;type&#34;</span>); <span style=color:#928374;font-style:italic>// OK
</span></span></span></code></pre></div><p>不能将 unknown的值 赋值给其他类型的变量，unknown类型只能被赋值给 any 类型和 unknown 类型本身</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> value: <span style=color:#b57614>unknown</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> value1: <span style=color:#b57614>unknown</span> <span style=color:#af3a03>=</span> value; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> value2: <span style=color:#b57614>any</span> <span style=color:#af3a03>=</span> value; <span style=color:#928374;font-style:italic>// OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> value3: <span style=color:#b57614>boolean</span> <span style=color:#af3a03>=</span> value; <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> value4: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> value; <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> value5: <span style=color:#b57614>string</span> <span style=color:#af3a03>=</span> value; <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> value6: <span style=color:#b57614>object</span> <span style=color:#af3a03>=</span> value; <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> value7: <span style=color:#b57614>any</span>[] <span style=color:#af3a03>=</span> value; <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> value8: <span style=color:#b57614>Function</span> <span style=color:#af3a03>=</span> value; <span style=color:#928374;font-style:italic>// Error
</span></span></span></code></pre></div><p>**unknown 应用场景</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>// any 写法，不推荐
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>function</span> divide(param: <span style=color:#b57614>any</span>) { 
</span></span><span style=display:flex><span> <span style=color:#af3a03>return</span> param <span style=color:#af3a03>/</span> <span style=color:#8f3f71>2</span>; 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// unknown写法，推荐
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>function</span> divide(param:<span style=color:#b57614>unknown</span>) {
</span></span><span style=display:flex><span> <span style=color:#af3a03>return</span> param <span style=color:#af3a03>as</span> <span style=color:#b57614>number</span> <span style=color:#af3a03>/</span> <span style=color:#8f3f71>2</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=空值-void>空值 void<a hidden class=anchor aria-hidden=true href=#空值-void>#</a></h3><p><code>void</code> 表示没有任何返回值的函数</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> alertName()<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span> {
</span></span><span style=display:flex><span>    alert(<span style=color:#79740e>&#39;My name is Lv&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>声明一个 <code>void</code> 类型的变量没用，因为你只能将它赋值为 <code>undefined</code> 和 <code>null</code>（只在 &ndash;strictNullChecks 未指定时）：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> unusable: <span style=color:#b57614>void</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>undefined</span>;
</span></span></code></pre></div><h3 id=never-类型>never 类型<a hidden class=anchor aria-hidden=true href=#never-类型>#</a></h3><p><code>never</code>类型表示的是那些用不存在的值的类型。</p><p>有些情况下值会永不存在，比如，</p><ul><li>如果一个函数执行时抛出了异常，那么这个函数永远不存在返回值，因为抛出异常会直接中断程序运行。</li><li>函数中执行无限循环的代码，使得程序永远无法运行到函数返回值那一步。</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>// 异常
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>function</span> fn(msg: <span style=color:#b57614>string</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>never</span> { 
</span></span><span style=display:flex><span>  <span style=color:#af3a03>throw</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Error</span>(msg)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 死循环 千万别这么写，会内存溢出
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>function</span> fn()<span style=color:#af3a03>:</span> <span style=color:#b57614>never</span> { 
</span></span><span style=display:flex><span>  <span style=color:#af3a03>while</span> (<span style=color:#af3a03>true</span>) {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>never 类型是任何类型的子类型，也可以赋值给任何类型。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> test1: <span style=color:#b57614>never</span>;
</span></span><span style=display:flex><span>test1 <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;lin&#39;</span> <span style=color:#928374;font-style:italic>// 报错，Type &#39;string&#39; is not assignable to type &#39;never&#39;
</span></span></span></code></pre></div><p>没有类型是 never 的子类型，没有类型可以赋值给 never 类型（除了 never 本身之外）。
即使 <code>any</code>也不可以赋值给 never 。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> test1: <span style=color:#b57614>never</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> test2: <span style=color:#b57614>any</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>test1 <span style=color:#af3a03>=</span> test2 <span style=color:#928374;font-style:italic>// 报错，Type &#39;any&#39; is not assignable to type &#39;never&#39;
</span></span></span></code></pre></div><h3 id=数组的类型>数组的类型<a hidden class=anchor aria-hidden=true href=#数组的类型>#</a></h3><h4 id=类型方括号-表示法>类型+方括号 表示法<a hidden class=anchor aria-hidden=true href=#类型方括号-表示法>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> fibonacci: <span style=color:#b57614>number</span>[] <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>, <span style=color:#8f3f71>5</span>];
</span></span></code></pre></div><p>数组的项中<strong>不允许</strong>出现其他的类型：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> fibonacci: <span style=color:#b57614>number</span>[] <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>, <span style=color:#79740e>&#39;1&#39;</span>, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>, <span style=color:#8f3f71>5</span>];
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Type &#39;string&#39; is not assignable to type &#39;number&#39;.
</span></span></span></code></pre></div><p>数组的一些方法的参数也会根据数组在定义时约定的类型进行限制：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> fibonacci: <span style=color:#b57614>number</span>[] <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>, <span style=color:#8f3f71>5</span>];
</span></span><span style=display:flex><span>fibonacci.push(<span style=color:#79740e>&#39;8&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Argument of type &#39;&#34;8&#34;&#39; is not assignable to parameter of type &#39;number&#39;.
</span></span></span></code></pre></div><h4 id=数组泛型--arrayelemtype>数组泛型 array<code>&lt;elemType></code><a hidden class=anchor aria-hidden=true href=#数组泛型--arrayelemtype>#</a></h4><p>我们也可以使用数组泛型（Array Generic） Array<code>&lt;elemType></code>来表示数组：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> fibonacci: <span style=color:#b57614>Array</span>&lt;<span style=color:#9d0006>number</span>&gt; <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>, <span style=color:#8f3f71>5</span>];
</span></span></code></pre></div><h4 id=用接口表示数组>用接口表示数组<a hidden class=anchor aria-hidden=true href=#用接口表示数组>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> NumberArray {
</span></span><span style=display:flex><span>    [index: <span style=color:#b57614>number</span>]<span style=color:#af3a03>:</span> <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> fibonacci: <span style=color:#b57614>NumberArray</span> <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>, <span style=color:#8f3f71>5</span>];
</span></span></code></pre></div><h3 id=元组-tuple-类型>元组 Tuple 类型<a hidden class=anchor aria-hidden=true href=#元组-tuple-类型>#</a></h3><p><strong>在单个变量中存储不同类型的值</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> tupleType<span style=color:#af3a03>:</span> [<span style=color:#b57614>string</span>, <span style=color:#af3a03>boolean</span>];
</span></span><span style=display:flex><span>tupleType <span style=color:#af3a03>=</span> [<span style=color:#79740e>&#34;semlinker&#34;</span>, <span style=color:#af3a03>true</span>];
</span></span></code></pre></div><p>在元组初始化的时候，如果出现类型不匹配的话，比如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>tupleType <span style=color:#af3a03>=</span> [<span style=color:#af3a03>true</span>, <span style=color:#79740e>&#34;semlinker&#34;</span>];
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//报错
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>[<span style=color:#8f3f71>0</span>]<span style=color:#af3a03>:</span> Type <span style=color:#79740e>&#39;true&#39;</span> <span style=color:#af3a03>is</span> not assignable to <span style=color:#af3a03>type</span> <span style=color:#79740e>&#39;string&#39;</span>. 
</span></span><span style=display:flex><span>[<span style=color:#8f3f71>1</span>]<span style=color:#af3a03>:</span> Type <span style=color:#79740e>&#39;string&#39;</span> <span style=color:#af3a03>is</span> not assignable to <span style=color:#af3a03>type</span> <span style=color:#79740e>&#39;boolean&#39;</span>.
</span></span></code></pre></div><p>在元组初始化的时候，我们还必须提供每个属性的值，不然也会出现错误。</p><p>可以对元组使用数组的方法，比如使用 push 时，不会有越界报错</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> tuple<span style=color:#af3a03>:</span> [<span style=color:#b57614>number</span>, <span style=color:#b57614>string</span>] <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>18</span>, <span style=color:#79740e>&#39;lin&#39;</span>]
</span></span><span style=display:flex><span>tuple.push(<span style=color:#8f3f71>100</span>)       <span style=color:#928374;font-style:italic>// 但是只能 push 定义的 number 或者 string 类型
</span></span></span></code></pre></div><h2 id=2函数类型>2.函数类型<a hidden class=anchor aria-hidden=true href=#2函数类型>#</a></h2><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> sum(x: <span style=color:#b57614>number</span>, y: <span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>number</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> x <span style=color:#af3a03>+</span> y;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//可选参数
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>function</span> buildName(firstName: <span style=color:#b57614>string</span>, lastName?: <span style=color:#b57614>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span> (lastName) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> firstName <span style=color:#af3a03>+</span> <span style=color:#79740e>&#39; &#39;</span> <span style=color:#af3a03>+</span> lastName;
</span></span><span style=display:flex><span>    } <span style=color:#af3a03>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> firstName;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tomcat <span style=color:#af3a03>=</span> buildName(<span style=color:#79740e>&#39;Tom&#39;</span>, <span style=color:#79740e>&#39;Cat&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tom <span style=color:#af3a03>=</span> buildName(<span style=color:#79740e>&#39;Tom&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//参数默认值
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>function</span> buildName(firstName: <span style=color:#b57614>string</span>, lastName: <span style=color:#b57614>string</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;Cat&#39;</span>) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> firstName <span style=color:#af3a03>+</span> <span style=color:#79740e>&#39; &#39;</span> <span style=color:#af3a03>+</span> lastName;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tomcat <span style=color:#af3a03>=</span> buildName(<span style=color:#79740e>&#39;Tom&#39;</span>, <span style=color:#79740e>&#39;Cat&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tom <span style=color:#af3a03>=</span> buildName(<span style=color:#79740e>&#39;Tom&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//剩余参数 ...rest  rest 参数只能是最后一个参数
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>function</span> push(array, ...items) {
</span></span><span style=display:flex><span>    items.forEach(<span style=color:#af3a03>function</span>(item) {
</span></span><span style=display:flex><span>        array.push(item);
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> a: <span style=color:#b57614>any</span>[] <span style=color:#af3a03>=</span> [];
</span></span><span style=display:flex><span>push(a, <span style=color:#8f3f71>1</span>, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>);
</span></span></code></pre></div><h3 id=函数重载>函数重载<a hidden class=anchor aria-hidden=true href=#函数重载>#</a></h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p><p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>'hello'</code> 的时候，输出反转的字符串 <code>'olleh'</code>。</p><p>利用联合类型，我们可以这么实现：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> reverse(x: <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>string</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span> (<span style=color:#af3a03>typeof</span> x <span style=color:#af3a03>===</span> <span style=color:#79740e>&#39;number&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> <span style=color:#b57614>Number</span>(x.toString().split(<span style=color:#79740e>&#39;&#39;</span>).reverse().join(<span style=color:#79740e>&#39;&#39;</span>));
</span></span><span style=display:flex><span>    } <span style=color:#af3a03>else</span> <span style=color:#af3a03>if</span> (<span style=color:#af3a03>typeof</span> x <span style=color:#af3a03>===</span> <span style=color:#79740e>&#39;string&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> x.split(<span style=color:#79740e>&#39;&#39;</span>).reverse().join(<span style=color:#79740e>&#39;&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p><p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> reverse(x: <span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> reverse(x: <span style=color:#b57614>string</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> reverse(x: <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>string</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span> (<span style=color:#af3a03>typeof</span> x <span style=color:#af3a03>===</span> <span style=color:#79740e>&#39;number&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> <span style=color:#b57614>Number</span>(x.toString().split(<span style=color:#79740e>&#39;&#39;</span>).reverse().join(<span style=color:#79740e>&#39;&#39;</span>));
</span></span><span style=display:flex><span>    } <span style=color:#af3a03>else</span> <span style=color:#af3a03>if</span> (<span style=color:#af3a03>typeof</span> x <span style=color:#af3a03>===</span> <span style=color:#79740e>&#39;string&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> x.split(<span style=color:#79740e>&#39;&#39;</span>).reverse().join(<span style=color:#79740e>&#39;&#39;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>上例中，我们重复定义了多次函数 <code>reverse</code>，前几次都是函数定义，最后一次是函数实现。</p><p>TypeScript 会优先从最前面的函数定义开始匹配，所以多个函数定义如果有包含关系，需要优先把精确的定义写在前面。</p><p>其实写起来挺麻烦的，后面了解泛型之后写起来会简洁一些，不必太纠结函数重载，知道有这个概念即可，平时一般用泛型来解决类似问题。</p><h2 id=3interface-接口>3.interface 接口<a hidden class=anchor aria-hidden=true href=#3interface-接口>#</a></h2><h3 id=基本概念>基本概念<a hidden class=anchor aria-hidden=true href=#基本概念>#</a></h3><p>TypeScript 中的接口是一个非常灵活的概念，常用于对「对象的形状（Shape）」进行描述。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>    age: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tom: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;Tom&#39;</span>,
</span></span><span style=display:flex><span>    age: <span style=color:#b57614>25</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>定义的变量比接口少了一些属性或多一些属性都是不允许的，<strong>赋值的时候，变量的形状必须和接口的形状保持一致</strong></p><h3 id=可选属性->可选属性 ？<a hidden class=anchor aria-hidden=true href=#可选属性->#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>    age?: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tom: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;Tom&#39;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tom: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;Tom&#39;</span>,
</span></span><span style=display:flex><span>    age:<span style=color:#b57614>100</span>,
</span></span><span style=display:flex><span>    gender<span style=color:#af3a03>:</span><span style=color:#79740e>&#34;male&#34;</span> <span style=color:#928374;font-style:italic>//报错  仍然不允许添加未定义的属性 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>};
</span></span></code></pre></div><h3 id=只读属性-readonly>只读属性 readonly<a hidden class=anchor aria-hidden=true href=#只读属性-readonly>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>readonly</span> id: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>    age?: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>    [propName: <span style=color:#b57614>string</span>]<span style=color:#af3a03>:</span> <span style=color:#b57614>any</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tom: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    id: <span style=color:#b57614>89757</span>,
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;Tom&#39;</span>,
</span></span><span style=display:flex><span>    gender<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;male&#39;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tom.id <span style=color:#af3a03>=</span> <span style=color:#8f3f71>9527</span>;
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// index.ts(14,5): error TS2540: Cannot assign to &#39;id&#39; because it is a constant or a read-only property.
</span></span></span></code></pre></div><p><strong>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>readonly</span> id: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>    age?: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>    [propName: <span style=color:#b57614>string</span>]<span style=color:#af3a03>:</span> <span style=color:#b57614>any</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tom: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;Tom&#39;</span>,
</span></span><span style=display:flex><span>    gender<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;male&#39;</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>tom.id <span style=color:#af3a03>=</span> <span style=color:#8f3f71>89757</span>;  <span style=color:#928374;font-style:italic>//第一错没有给id初始值，第二错id为只读属性
</span></span></span></code></pre></div><h3 id=interface-描述函数类型>interface 描述函数类型<a hidden class=anchor aria-hidden=true href=#interface-描述函数类型>#</a></h3><p>interface 也可以用来描述函数类型，代码如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> ISum {
</span></span><span style=display:flex><span>    (x:<span style=color:#b57614>number</span>,y:<span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span><span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> add:<span style=color:#b57614>ISum</span> <span style=color:#af3a03>=</span> (num1, num2) <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> num1 <span style=color:#af3a03>+</span> num2
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=任意属性>任意属性<a hidden class=anchor aria-hidden=true href=#任意属性>#</a></h3><p>一个接口中只能定义一个任意属性。如果接口中有多个类型的属性，则可以在任意属性中使用联合类型：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>    age?: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>    [propName: <span style=color:#b57614>string</span>]<span style=color:#af3a03>:</span> <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> tom: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;Tom&#39;</span>,
</span></span><span style=display:flex><span>    age: <span style=color:#b57614>25</span>,
</span></span><span style=display:flex><span>    gender<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;male&#39;</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=duck-typing--鸭子类型->duck typing ( 鸭子类型 )<a hidden class=anchor aria-hidden=true href=#duck-typing--鸭子类型->#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>const</span> fn: <span style=color:#b57614>FunctionWithProps</span> <span style=color:#af3a03>=</span> (x) <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> x
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>fn.fnName <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;hello world&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//React 的 `FunctionComponent（函数式组件）`
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>interface</span> FunctionComponent&lt;<span style=color:#9d0006>P</span> = {}&gt; {
</span></span><span style=display:flex><span>  (props: <span style=color:#b57614>PropsWithChildren</span>&lt;<span style=color:#9d0006>P</span>&gt;, context?: <span style=color:#b57614>any</span>)<span style=color:#af3a03>:</span> ReactElement&lt;<span style=color:#9d0006>any</span>, <span style=color:#79740e;font-weight:700>any</span>&gt; <span style=color:#af3a03>|</span> <span style=color:#af3a03>null</span>;
</span></span><span style=display:flex><span>  propTypes?: <span style=color:#b57614>WeakValidationMap</span>&lt;<span style=color:#9d0006>P</span>&gt; <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span>  contextTypes?: <span style=color:#b57614>ValidationMap</span>&lt;<span style=color:#9d0006>any</span>&gt; <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span>  defaultProps?: <span style=color:#b57614>Partial</span>&lt;<span style=color:#9d0006>P</span>&gt; <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span>  displayName?: <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=4class-类>4.class 类<a hidden class=anchor aria-hidden=true href=#4class-类>#</a></h2><h3 id=类的属性与方法>类的属性与方法<a hidden class=anchor aria-hidden=true href=#类的属性与方法>#</a></h3><p>在面向对象语言中，类是一种面向对象计算机编程语言的构造，是创建对象的蓝图，描述了所创建的对象共同的属性和方法。</p><ul><li>我们可以用Class关键字来定义一个类</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> Person {
</span></span><span style=display:flex><span> <span style=color:#928374;font-style:italic>// 成员属性
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    name: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>//构造函数 - 执行初始化操作
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#af3a03>constructor</span>(name: <span style=color:#b57614>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>this</span>.name <span style=color:#af3a03>=</span> name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    speak() {
</span></span><span style=display:flex><span>        console.log(<span style=color:#79740e>`</span><span style=color:#79740e>${</span><span style=color:#af3a03>this</span>.name<span style=color:#79740e>}</span><span style=color:#79740e> is speaking`</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> p1 <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Person(<span style=color:#79740e>&#39;lin&#39;</span>)      <span style=color:#928374;font-style:italic>// 新建实例  
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>p1.name                           <span style=color:#928374;font-style:italic>// 访问属性和方法
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>p1.speak()
</span></span></code></pre></div><h3 id=继承>继承<a hidden class=anchor aria-hidden=true href=#继承>#</a></h3><p>继承（Inheritance）是一种联结类与类的层次模型。指的是<strong>一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力</strong>，继承是类与类或者接口与接口之间最常见的关系。</p><p>我们可以通过 <code>extends</code> 关键字来实现继承</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> Student <span style=color:#af3a03>extends</span> Person {
</span></span><span style=display:flex><span>    study() {
</span></span><span style=display:flex><span>        console.log(<span style=color:#79740e>`</span><span style=color:#79740e>${</span><span style=color:#af3a03>this</span>.name<span style=color:#79740e>}</span><span style=color:#79740e> needs study`</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> s1 <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Student(<span style=color:#79740e>&#39;lin&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>s1.study()
</span></span></code></pre></div><h4 id=super关键字>super关键字<a hidden class=anchor aria-hidden=true href=#super关键字>#</a></h4><p>注意，上例中 Student 类没有定义自己的属性，可以不写 super ，但是如果 Student 类有自己的属性，就要用到 super 关键字来把父类的属性继承过来。</p><p>比如，Student 类新增一个 grade(成绩) 属性，就要这么写：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> Student <span style=color:#af3a03>extends</span> Person {
</span></span><span style=display:flex><span>    grade: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>constructor</span>(name: <span style=color:#b57614>string</span>,grade:<span style=color:#b57614>number</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>super</span>(name)
</span></span><span style=display:flex><span>        <span style=color:#af3a03>this</span>.grade <span style=color:#af3a03>=</span> grade
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> s1 <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Student(<span style=color:#79740e>&#39;lin&#39;</span>, <span style=color:#8f3f71>100</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//不写 super 会报错。
</span></span></span></code></pre></div><h3 id=多态>多态<a hidden class=anchor aria-hidden=true href=#多态>#</a></h3><p>子类对父类的方法进行了重写，子类和父类调同一个方法时会不一样。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> Student <span style=color:#af3a03>extends</span> Person {
</span></span><span style=display:flex><span>    speak() {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> <span style=color:#79740e>`Student </span><span style=color:#79740e>${</span><span style=color:#af3a03>super</span>.speak()<span style=color:#79740e>}</span><span style=color:#79740e>`</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=私有字段>私有字段<a hidden class=anchor aria-hidden=true href=#私有字段>#</a></h3><p>与常规属性（甚至使用 <code>private</code> 修饰符声明的属性）不同，私有字段要牢记以下规则：</p><ul><li>私有字段以 <code>#</code> 字符开头，有时我们称之为私有名称；</li><li>每个私有字段名称都唯一地限定于其包含的类；</li><li>不能在私有字段上使用 TypeScript 可访问性修饰符（如 public 或 private）；</li><li><strong>私有字段不能在包含的类之外访问，甚至不能被检测到。</strong></li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> Person {
</span></span><span style=display:flex><span>  #name: <span style=color:#b57614>string</span>;   <span style=color:#928374;font-style:italic>//私有字段
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>constructor</span>(name: <span style=color:#b57614>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>this</span>.#name <span style=color:#af3a03>=</span> name;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  greet() {
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>`Hello, my name is </span><span style=color:#79740e>${</span><span style=color:#af3a03>this</span>.#name<span style=color:#79740e>}</span><span style=color:#79740e>!`</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> semlinker <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Person(<span style=color:#79740e>&#34;Semlinker&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>semlinker.#name;
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//     ~~~~~
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Property &#39;#name&#39; is not accessible outside class &#39;Person&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// because it has a private identifier.
</span></span></span></code></pre></div><table><thead><tr><th style=text-align:left></th><th style=text-align:left>只属于类自己</th><th style=text-align:left>它的实例能否访问</th><th style=text-align:left>继承它的子类能否访问</th></tr></thead><tbody><tr><td style=text-align:left>public 公有的</td><td style=text-align:left></td><td style=text-align:left>能</td><td style=text-align:left>能</td></tr><tr><td style=text-align:left>private 私有的</td><td style=text-align:left>是</td><td style=text-align:left>不能</td><td style=text-align:left>不能</td></tr><tr><td style=text-align:left>protected 受保护的</td><td style=text-align:left></td><td style=text-align:left>不能</td><td style=text-align:left>能</td></tr><tr><td style=text-align:left>static</td><td style=text-align:left></td><td style=text-align:left>不能</td><td style=text-align:left>能</td></tr></tbody></table><p>private</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>private</span> name: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>public</span> <span style=color:#af3a03>constructor</span>(name: <span style=color:#b57614>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>this</span>.name <span style=color:#af3a03>=</span> name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#af3a03>public</span> speak() {
</span></span><span style=display:flex><span>        console.log(<span style=color:#79740e>`</span><span style=color:#79740e>${</span><span style=color:#af3a03>this</span>.name<span style=color:#79740e>}</span><span style=color:#79740e> is speaking`</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> p1 <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Person(<span style=color:#79740e>&#39;lv&#39;</span>)   
</span></span><span style=display:flex><span>p1.name   <span style=color:#928374;font-style:italic>//报错   “name” is private...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> Student <span style=color:#af3a03>extends</span> Person {
</span></span><span style=display:flex><span> study(){
</span></span><span style=display:flex><span>  console.log(<span style=color:#79740e>`</span><span style=color:#79740e>${</span><span style=color:#af3a03>this</span>.name<span style=color:#79740e>}</span><span style=color:#79740e> needs study`</span>)    <span style=color:#928374;font-style:italic>//报错   “name” is private...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>protected</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> Person {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>protected</span> name: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>public</span> <span style=color:#af3a03>constructor</span>(name: <span style=color:#b57614>string</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>this</span>.name <span style=color:#af3a03>=</span> name
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#af3a03>public</span> speak() {
</span></span><span style=display:flex><span>        console.log(<span style=color:#79740e>`</span><span style=color:#79740e>${</span><span style=color:#af3a03>this</span>.name<span style=color:#79740e>}</span><span style=color:#79740e> is speaking`</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> p1 <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Person(<span style=color:#79740e>&#39;lv&#39;</span>)   
</span></span><span style=display:flex><span>p1.name   <span style=color:#928374;font-style:italic>//报错   “name” is protected...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> Student <span style=color:#af3a03>extends</span> Person {
</span></span><span style=display:flex><span> study(){
</span></span><span style=display:flex><span>  console.log(<span style=color:#79740e>`</span><span style=color:#79740e>${</span><span style=color:#af3a03>this</span>.name<span style=color:#79740e>}</span><span style=color:#79740e> needs study`</span>)   
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=访问器>访问器<a hidden class=anchor aria-hidden=true href=#访问器>#</a></h3><p>我们可以通过 <code>getter</code> 和 <code>setter</code> 方法来实现数据的封装和有效性校验，防止出现异常数据。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> passcode <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;Hello TypeScript&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> Employee {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>private</span> _fullName: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>get</span> fullName()<span style=color:#af3a03>:</span> <span style=color:#b57614>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> <span style=color:#af3a03>this</span>._fullName;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>set</span> fullName(newName: <span style=color:#b57614>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span> (passcode <span style=color:#af3a03>&amp;&amp;</span> passcode <span style=color:#af3a03>==</span> <span style=color:#79740e>&#34;Hello TypeScript&#34;</span>) {
</span></span><span style=display:flex><span>      <span style=color:#af3a03>this</span>._fullName <span style=color:#af3a03>=</span> newName;
</span></span><span style=display:flex><span>    } <span style=color:#af3a03>else</span> {
</span></span><span style=display:flex><span>      console.log(<span style=color:#79740e>&#34;Error: Unauthorized update of employee!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> employee <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Employee();
</span></span><span style=display:flex><span>employee.fullName <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;Semlinker&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>if</span> (employee.fullName) {
</span></span><span style=display:flex><span>  console.log(employee.fullName);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=抽象类>抽象类<a hidden class=anchor aria-hidden=true href=#抽象类>#</a></h3><p>使用 <code>abstract</code> 关键字声明的类，我们称之为抽象类。抽象类不能被实例化，因为它里面包含一个或多个抽象方法。所谓的抽象方法，是指不包含具体实现的方法：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>abstract</span> <span style=color:#af3a03>class</span> Person {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>constructor</span>(<span style=color:#af3a03>public</span> name: <span style=color:#b57614>string</span>){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>abstract</span> say(words: <span style=color:#b57614>string</span>) <span style=color:#af3a03>:</span><span style=color:#af3a03>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Cannot create an instance of an abstract class.(2511)
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>const</span> lolo <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Person(); <span style=color:#928374;font-style:italic>// Error
</span></span></span></code></pre></div><p>抽象类不能被直接实例化，我们只能实例化实现了所有抽象方法的子类。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>abstract</span> <span style=color:#af3a03>class</span> Person {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>constructor</span>(<span style=color:#af3a03>public</span> name: <span style=color:#b57614>string</span>){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// 抽象方法
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>abstract</span> say(words: <span style=color:#b57614>string</span>) <span style=color:#af3a03>:</span><span style=color:#af3a03>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> Developer <span style=color:#af3a03>extends</span> Person {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>constructor</span>(name: <span style=color:#b57614>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>super</span>(name);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  say(words: <span style=color:#b57614>string</span>)<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span> {
</span></span><span style=display:flex><span>    console.log(<span style=color:#79740e>`</span><span style=color:#79740e>${</span><span style=color:#af3a03>this</span>.name<span style=color:#79740e>}</span><span style=color:#79740e> says </span><span style=color:#79740e>${</span>words<span style=color:#79740e>}</span><span style=color:#79740e>`</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> lolo <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Developer(<span style=color:#79740e>&#34;lolo&#34;</span>);
</span></span><span style=display:flex><span>lolo.say(<span style=color:#79740e>&#34;I love ts!&#34;</span>); <span style=color:#928374;font-style:italic>// lolo says I love ts!
</span></span></span></code></pre></div><h3 id=类方法重载>类方法重载<a hidden class=anchor aria-hidden=true href=#类方法重载>#</a></h3><p>对于类的方法来说，它也支持重载。比如，示例中我们重载了 <code>ProductService</code> 类的 <code>getProducts</code> 成员方法：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> ProductService {
</span></span><span style=display:flex><span>    getProducts()<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span>;
</span></span><span style=display:flex><span>    getProducts(id: <span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span>;
</span></span><span style=display:flex><span>    getProducts(id?: <span style=color:#b57614>number</span>) {
</span></span><span style=display:flex><span>      <span style=color:#af3a03>if</span>(<span style=color:#af3a03>typeof</span> id <span style=color:#af3a03>===</span> <span style=color:#79740e>&#39;number&#39;</span>) {
</span></span><span style=display:flex><span>          console.log(<span style=color:#79740e>`获取id为 </span><span style=color:#79740e>${</span>id<span style=color:#79740e>}</span><span style=color:#79740e> 的产品信息`</span>);
</span></span><span style=display:flex><span>      } <span style=color:#af3a03>else</span> {
</span></span><span style=display:flex><span>          console.log(<span style=color:#79740e>`获取所有的产品信息`</span>);
</span></span><span style=display:flex><span>      }  
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> productService <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> ProductService();
</span></span><span style=display:flex><span>productService.getProducts(<span style=color:#8f3f71>666</span>); <span style=color:#928374;font-style:italic>// 获取id为 666 的产品信息
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>productService.getProducts(); <span style=color:#928374;font-style:italic>// 获取所有的产品信息 
</span></span></span></code></pre></div><h2 id=5interface-和-class-的关系>5.interface 和 class 的关系<a hidden class=anchor aria-hidden=true href=#5interface-和-class-的关系>#</a></h2><p>interface 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。
interface 同样可以用来约束 class，要实现约束，需要用到 <code>implements</code> 关键字。</p><h3 id=implements>implements<a hidden class=anchor aria-hidden=true href=#implements>#</a></h3><p>implements 是实现的意思，class 实现 interface。</p><p>比如手机有播放音乐的功能，可以这么写：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> MusicInterface {
</span></span><span style=display:flex><span>    playMusic()<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> Cellphone <span style=color:#af3a03>implements</span> MusicInterface {
</span></span><span style=display:flex><span>    playMusic() {}    <span style=color:#928374;font-style:italic>// 如果 Cellphone 类上不写 playMusic 方法，会报错。 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>}
</span></span></code></pre></div><p>定义了约束后，class 必须要满足接口上的所有条件。</p><h3 id=处理公共的属性和方法>处理公共的属性和方法<a hidden class=anchor aria-hidden=true href=#处理公共的属性和方法>#</a></h3><p>不同的类有一些共同的属性和方法，使用继承很难完成。</p><p>比如汽车（Car 类）也有播放音乐的功能，你可以这么做：</p><ul><li>用 Car 类继承 Cellphone 类</li><li>找一个 Car 类和 Cellphone 类的父类，父类有播放音乐的方法，他们俩继承这个父类</li></ul><p>很显然这两种方法都不合常理。</p><p>实际上，使用 implements，问题就会迎刃而解</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> MusicInterface {
</span></span><span style=display:flex><span>    playMusic()<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//Car 类和 Cellphone 类都约束了播放音乐的功能。
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>class</span> Car <span style=color:#af3a03>implements</span> MusicInterface {
</span></span><span style=display:flex><span>    playMusic() {}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> Cellphone <span style=color:#af3a03>implements</span> MusicInterface {
</span></span><span style=display:flex><span>    playMusic() {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>再比如，手机还有打电话的功能，就可以这么做，Cellphone 类 implements 两个 interface。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> MusicInterface {
</span></span><span style=display:flex><span>    playMusic()<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>interface</span> CallInterface {
</span></span><span style=display:flex><span>    makePhoneCall()<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> Cellphone <span style=color:#af3a03>implements</span> MusicInterface, CallInterface {
</span></span><span style=display:flex><span>    playMusic() {}
</span></span><span style=display:flex><span>    makePhoneCall() {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>interface 来约束 class，class 实现了 interface 规定的属性或方法，没有继承那么多条条框框，非常灵活。</p><h3 id=约束构造函数和静态属性>约束构造函数和静态属性<a hidden class=anchor aria-hidden=true href=#约束构造函数和静态属性>#</a></h3><p>使用 implements 只能约束类实例上的属性和方法，要约束构造函数和静态属性，需要这么写。</p><p>以我们上文提过的 Circl 类为例：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> CircleStatic {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>new</span> (radius: <span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span>
</span></span><span style=display:flex><span>    pi: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> Circle:<span style=color:#b57614>CircleStatic</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>class</span> Circle {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>static</span> pi: <span style=color:#b57614>3.14</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>public</span> radius: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>    <span style=color:#af3a03>public</span> <span style=color:#af3a03>constructor</span>(radius: <span style=color:#b57614>number</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>this</span>.radius <span style=color:#af3a03>=</span> radius
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> Circle:<span style=color:#b57614>CircleStatic</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>class</span> Circle {
</span></span><span style=display:flex><span> <span style=color:#af3a03>public</span> radius: <span style=color:#b57614>number</span>    <span style=color:#928374;font-style:italic>//未定义静态属性 pi，会报错：   &#39;pi&#39; is missing
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span> <span style=color:#af3a03>public</span> <span style=color:#af3a03>constructor</span>(radius:<span style=color:#b57614>string</span>){   <span style=color:#928374;font-style:italic>//constructor 入参类型不对，会报错： type &#39;number&#39; is not... to type &#39;string&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>this</span>.radius <span style=color:#af3a03>=</span> radius
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=6enum-枚举类型>6.Enum 枚举类型<a hidden class=anchor aria-hidden=true href=#6enum-枚举类型>#</a></h2><p>枚举（Enum）类型用于取值被限定在一定范围内的场景，比如一周只能有七天，颜色限定为红绿蓝等。</p><h3 id=数字枚举>数字枚举<a hidden class=anchor aria-hidden=true href=#数字枚举>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>enum</span> Direction {
</span></span><span style=display:flex><span>  NORTH,   <span style=color:#928374;font-style:italic>//0
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  SOUTH,
</span></span><span style=display:flex><span>  EAST,
</span></span><span style=display:flex><span>  WEST,   <span style=color:#928374;font-style:italic>//3
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> dir: <span style=color:#b57614>Direction</span> <span style=color:#af3a03>=</span> Direction.NORTH;
</span></span></code></pre></div><p>设置 NORTH 的初始值，比如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>enum</span> Direction {   NORTH <span style=color:#af3a03>=</span> <span style=color:#8f3f71>3</span>,   SOUTH,   EAST,   WEST, }<span style=color:#79740e>`
</span></span></span></code></pre></div><h3 id=字符串枚举>字符串枚举<a hidden class=anchor aria-hidden=true href=#字符串枚举>#</a></h3><p>在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>enum</span> Direction {
</span></span><span style=display:flex><span>  NORTH <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;NORTH&#34;</span>,
</span></span><span style=display:flex><span>  SOUTH <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;SOUTH&#34;</span>,
</span></span><span style=display:flex><span>  EAST <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;EAST&#34;</span>,
</span></span><span style=display:flex><span>  WEST <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;WEST&#34;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=异构枚举>异构枚举<a hidden class=anchor aria-hidden=true href=#异构枚举>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>enum</span> Enum {
</span></span><span style=display:flex><span>  A,
</span></span><span style=display:flex><span>  B,
</span></span><span style=display:flex><span>  C <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;C&#34;</span>,
</span></span><span style=display:flex><span>  D <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;D&#34;</span>,
</span></span><span style=display:flex><span>  E <span style=color:#af3a03>=</span> <span style=color:#8f3f71>8</span>,
</span></span><span style=display:flex><span>  F,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//反向映射
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(Enum.A) <span style=color:#928374;font-style:italic>//输出：0 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(Enum[<span style=color:#8f3f71>0</span>]) <span style=color:#928374;font-style:italic>// 输出：A
</span></span></span></code></pre></div><h2 id=7类型推论>7.类型推论<a hidden class=anchor aria-hidden=true href=#7类型推论>#</a></h2><p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;seven&#39;</span>;  <span style=color:#928374;font-style:italic>// let myFavoriteNumber: string = &#39;seven&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#8f3f71>7</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// index.ts(2,1): error TS2322: Type &#39;number&#39; is not assignable to type &#39;string&#39;.
</span></span></span></code></pre></div><p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> myFavoriteNumber;
</span></span><span style=display:flex><span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;seven&#39;</span>;
</span></span><span style=display:flex><span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#8f3f71>7</span>;
</span></span></code></pre></div><p>虽然 TS 可以推导出最合适的类型，但最好还是在写的时候就定义好类型，下面的例子，可以用ts这么写：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>// let arr = [0, 1, null, &#39;lin&#39;];
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> arrItem <span style=color:#af3a03>=</span> <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>null</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> arr: <span style=color:#b57614>arrItem</span>[] <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>0</span>, <span style=color:#8f3f71>1</span>, <span style=color:#af3a03>null</span>, <span style=color:#79740e>&#39;lin&#39;</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> pets: <span style=color:#b57614>Pets</span>[] <span style=color:#af3a03>=</span> [<span style=color:#af3a03>new</span> Dog(), <span style=color:#af3a03>new</span> Cat()]
</span></span></code></pre></div><h2 id=8内置类型>8.内置类型<a hidden class=anchor aria-hidden=true href=#8内置类型>#</a></h2><h3 id=js-八种内置类型>JS 八种内置类型<a hidden class=anchor aria-hidden=true href=#js-八种内置类型>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> name: <span style=color:#b57614>string</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;lin&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> age: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> <span style=color:#8f3f71>18</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> isHandsome: <span style=color:#b57614>boolean</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>true</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> u: <span style=color:#b57614>undefined</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> n: <span style=color:#b57614>null</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>null</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> obj: <span style=color:#b57614>object</span> <span style=color:#af3a03>=</span> {name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>, age: <span style=color:#b57614>18</span>};
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> big: <span style=color:#b57614>bigint</span> <span style=color:#af3a03>=</span> <span style=color:#8f3f71>100</span>n;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> sym: <span style=color:#b57614>symbol</span> <span style=color:#af3a03>=</span> Symbol(<span style=color:#79740e>&#34;lin&#34;</span>); 
</span></span></code></pre></div><h3 id=ecmascript-的内置对象>ECMAScript 的内置对象<a hidden class=anchor aria-hidden=true href=#ecmascript-的内置对象>#</a></h3><p>比如，<code>Array</code>、<code>Date</code>、<code>Error</code> 等</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>const</span> nums: <span style=color:#b57614>Array</span>&lt;<span style=color:#9d0006>number</span>&gt; <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>,<span style=color:#8f3f71>2</span>,<span style=color:#8f3f71>3</span>]
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> date: <span style=color:#b57614>Date</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Date</span>()
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> err: <span style=color:#b57614>Error</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> <span style=color:#b57614>Error</span>(<span style=color:#79740e>&#39;Error!&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> reg: <span style=color:#b57614>RegExp</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>/abc/</span>;
</span></span><span style=display:flex><span><span style=color:#b57614>Math</span>.pow(<span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>9</span>)
</span></span></code></pre></div><h3 id=dom-和-bom>DOM 和 BOM<a hidden class=anchor aria-hidden=true href=#dom-和-bom>#</a></h3><p>比如 <code>HTMLElement</code>、<code>NodeList</code>、<code>MouseEvent</code> 等</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> body: <span style=color:#b57614>HTMLElement</span> <span style=color:#af3a03>=</span> <span style=color:#b57614>document</span>.body
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> allDiv: <span style=color:#b57614>NodeList</span> <span style=color:#af3a03>=</span> <span style=color:#b57614>document</span>.querySelectorAll(<span style=color:#79740e>&#39;div&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b57614>document</span>.addEventListener(<span style=color:#79740e>&#39;click&#39;</span>, (e: <span style=color:#b57614>MouseEvent</span>) <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>    e.preventDefault()
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// Do something
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>});
</span></span></code></pre></div><h3 id=ts-进阶>TS 进阶<a hidden class=anchor aria-hidden=true href=#ts-进阶>#</a></h3><h2 id=1高级类型一>1.高级类型（一）<a hidden class=anchor aria-hidden=true href=#1高级类型一>#</a></h2><h3 id=联合类型>联合类型<a hidden class=anchor aria-hidden=true href=#联合类型>#</a></h3><p>联合类型表示可以取值为多类型中的一种</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> myFavoriteNumber: <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;seven&#39;</span>;
</span></span><span style=display:flex><span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#8f3f71>7</span>;
</span></span></code></pre></div><p><strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> getLength(something: <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>number</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> something.length;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// index.ts(2,22): error TS2339: Property &#39;length&#39; does not exist on type &#39;string | number&#39;.
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//   Property &#39;length&#39; does not exist on type &#39;number&#39;.
</span></span></span></code></pre></div><p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。
访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> getString(something: <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>string</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> something.toString();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> myFavoriteNumber: <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;seven&#39;</span>;
</span></span><span style=display:flex><span>console.log(myFavoriteNumber.length); <span style=color:#928374;font-style:italic>// 5  被推断为string
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>myFavoriteNumber <span style=color:#af3a03>=</span> <span style=color:#8f3f71>7</span>;
</span></span><span style=display:flex><span>console.log(myFavoriteNumber.length); <span style=color:#928374;font-style:italic>// 编译时报错  被推断为number
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// index.ts(5,30): error TS2339: Property &#39;length&#39; does not exist on type &#39;number&#39;.
</span></span></span></code></pre></div><h3 id=交叉类型>交叉类型<a hidden class=anchor aria-hidden=true href=#交叉类型>#</a></h3><h4 id=-运算符>& 运算符<a hidden class=anchor aria-hidden=true href=#-运算符>#</a></h4><p>在 TypeScript 中交叉类型是<strong>将多个类型合并为一个类型</strong>。通过 <code>&</code> 运算符可以将现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>    age: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Student <span style=color:#af3a03>=</span> Person <span style=color:#af3a03>&amp;</span> { grade: <span style=color:#b57614>number</span> }
</span></span></code></pre></div><p>联合类型 <code>|</code> 是指可以取几种类型中的任意一种，而交叉类型 <code>&</code> 是指把几种类型合并起来。</p><p>交叉类型和 interface 的 extends 非常类似，都是为了实现对象形状的组合和扩展。</p><h3 id=类型别名-type->类型别名（ type ）<a hidden class=anchor aria-hidden=true href=#类型别名-type->#</a></h3><p>类型别名（type aliase），听名字就很好理解，就是给类型起个别名。</p><p>就像 NBA 球员 扬尼斯-阿德托昆博，名字太长难记，我们叫他<code>字母哥</code>。</p><p>就像我们项目中配置 <code>alias</code>，不用写相对路径就能很方便地引入文件</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>import</span> componentA <span style=color:#af3a03>from</span> <span style=color:#79740e>&#39;../../../../components/componentA/index.vue&#39;</span>
</span></span><span style=display:flex><span>变成
</span></span><span style=display:flex><span><span style=color:#af3a03>import</span> componentA <span style=color:#af3a03>from</span> &#39;@<span style=color:#af3a03>/</span>components<span style=color:#af3a03>/</span>componentA<span style=color:#af3a03>/</span>index.vue
</span></span></code></pre></div><p>类型别名用 <code>type</code> 关键字来书写，有了类型别名，我们书写 TS 的时候可以更加方便简洁。</p><p>比如下面这个例子，<code>getName</code> 这个函数接收的参数可能是字符串，可能是函数，就可以这么写。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>type</span> Name <span style=color:#af3a03>=</span> <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> NameResolver <span style=color:#af3a03>=</span> () <span style=color:#af3a03>=&gt;</span> <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> NameOrResolver <span style=color:#af3a03>=</span> Name <span style=color:#af3a03>|</span> NameResolver          <span style=color:#928374;font-style:italic>// 联合类型
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>function</span> getName(n: <span style=color:#b57614>NameOrResolver</span>)<span style=color:#af3a03>:</span> Name {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span> (<span style=color:#af3a03>typeof</span> n <span style=color:#af3a03>===</span> <span style=color:#79740e>&#39;string&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> n
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#af3a03>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> n()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getName(<span style=color:#79740e>&#39;lin&#39;</span>)
</span></span><span style=display:flex><span>getName(() <span style=color:#af3a03>=&gt;</span> <span style=color:#79740e>&#39;lin&#39;</span>)
</span></span></code></pre></div><p><strong>类型别名的用法</strong>：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>type</span> Name <span style=color:#af3a03>=</span> <span style=color:#b57614>string</span>                              <span style=color:#928374;font-style:italic>// 基本类型
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> arrItem <span style=color:#af3a03>=</span> <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>string</span>                  <span style=color:#928374;font-style:italic>// 联合类型
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> arr: <span style=color:#b57614>arrItem</span>[] <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>,<span style=color:#79740e>&#39;2&#39;</span>, <span style=color:#8f3f71>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Person <span style=color:#af3a03>=</span> { 
</span></span><span style=display:flex><span>  name: <span style=color:#b57614>Name</span> 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Student <span style=color:#af3a03>=</span> Person <span style=color:#af3a03>&amp;</span> { grade: <span style=color:#b57614>number</span>  }       <span style=color:#928374;font-style:italic>// 交叉类型
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Teacher <span style=color:#af3a03>=</span> Person <span style=color:#af3a03>&amp;</span> { major: <span style=color:#b57614>string</span>  } 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> StudentAndTeacherList <span style=color:#af3a03>=</span> [Student, Teacher]  <span style=color:#928374;font-style:italic>// 元组类型
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> list:<span style=color:#b57614>StudentAndTeacherList</span> <span style=color:#af3a03>=</span> [
</span></span><span style=display:flex><span>  { name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>, grade: <span style=color:#b57614>100</span> }, 
</span></span><span style=display:flex><span>  { name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;liu&#39;</span>, major<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;Chinese&#39;</span> }
</span></span><span style=display:flex><span>]
</span></span></code></pre></div><h3 id=接口与类型别名的区别>接口与类型别名的区别<a hidden class=anchor aria-hidden=true href=#接口与类型别名的区别>#</a></h3><h4 id=共同点>共同点<a hidden class=anchor aria-hidden=true href=#共同点>#</a></h4><h4 id=都可以用来描述对象或函数签名>都可以用来描述对象或函数签名<a hidden class=anchor aria-hidden=true href=#都可以用来描述对象或函数签名>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>//接口
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>interface</span> Point {
</span></span><span style=display:flex><span>  x: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>  y: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>interface</span> SetPoint {
</span></span><span style=display:flex><span>  (x: <span style=color:#b57614>number</span>, y: <span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span> <span style=color:#af3a03>void</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//类型别名
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> Point <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>  x: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>  y: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> SetPoint <span style=color:#af3a03>=</span> (x: <span style=color:#b57614>number</span>, y: <span style=color:#b57614>number</span>) <span style=color:#af3a03>=&gt;</span> <span style=color:#af3a03>void</span>;
</span></span></code></pre></div><h4 id=都允许继承>都允许继承<a hidden class=anchor aria-hidden=true href=#都允许继承>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>// interface 继承 interface
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>interface</span> PartialPointX { x: <span style=color:#b57614>number</span>; }
</span></span><span style=display:flex><span><span style=color:#af3a03>interface</span> Point <span style=color:#af3a03>extends</span> PartialPointX { 
</span></span><span style=display:flex><span>  y: <span style=color:#b57614>number</span>; 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// type 继承 type
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> PartialPointX <span style=color:#af3a03>=</span> { x: <span style=color:#b57614>number</span>; };
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Point <span style=color:#af3a03>=</span> PartialPointX <span style=color:#af3a03>&amp;</span> { y: <span style=color:#b57614>number</span>; };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// interface 继承 type           
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> Person <span style=color:#af3a03>=</span> {       
</span></span><span style=display:flex><span>  name: <span style=color:#b57614>string</span> 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>interface</span> Student <span style=color:#af3a03>extends</span> Person {             <span style=color:#79740e>&#34;interface用 extends 来继承&#34;</span>
</span></span><span style=display:flex><span>  grade: <span style=color:#b57614>number</span> 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// type 继承 interface
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>interface</span> Person { 
</span></span><span style=display:flex><span>  name: <span style=color:#b57614>string</span> 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Student <span style=color:#af3a03>=</span> Person <span style=color:#af3a03>&amp;</span> { grade: <span style=color:#b57614>number</span>  }     <span style=color:#79740e>&#34;type用交叉类型来继承&#34;</span>
</span></span></code></pre></div><h4 id=不同点>不同点<a hidden class=anchor aria-hidden=true href=#不同点>#</a></h4><h4 id=设计角度>设计角度<a hidden class=anchor aria-hidden=true href=#设计角度>#</a></h4><ul><li><p>interface（接口） 是 TS 设计出来用于定义对象类型的，可以对对象的形状进行描述。</p></li><li><p>type 是<strong>类型别名</strong>，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。</p></li></ul><h4 id=type-用于其它类型>type 用于其它类型<a hidden class=anchor aria-hidden=true href=#type-用于其它类型>#</a></h4><p>与 interface 不一样，**type 可以声明基本类型、联合类型、交叉类型、元组</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>// primitive
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> Name <span style=color:#af3a03>=</span> <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// object
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> PartialPointX <span style=color:#af3a03>=</span> { x: <span style=color:#b57614>number</span>; };
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> PartialPointY <span style=color:#af3a03>=</span> { y: <span style=color:#b57614>number</span>; };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// union
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> PartialPoint <span style=color:#af3a03>=</span> PartialPointX <span style=color:#af3a03>|</span> PartialPointY;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// tuple
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> Data <span style=color:#af3a03>=</span> [<span style=color:#b57614>number</span>, <span style=color:#b57614>string</span>];
</span></span></code></pre></div><h4 id=interface可以合并重复声明type-不行>interface可以合并重复声明，type 不行<a hidden class=anchor aria-hidden=true href=#interface可以合并重复声明type-不行>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {         <span style=color:#928374;font-style:italic>// 重复声明 interface，就合并了
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    age: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> person: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>,
</span></span><span style=display:flex><span>    age: <span style=color:#b57614>18</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Person <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Person <span style=color:#af3a03>=</span> {            <span style=color:#928374;font-style:italic>// 报错，Duplicate identifier &#39;Person&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    age: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> person: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>,
</span></span><span style=display:flex><span>    age: <span style=color:#b57614>18</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=implements-1>Implements<a hidden class=anchor aria-hidden=true href=#implements-1>#</a></h4><p>类可以以相同的方式实现接口或类型别名，但类不能实现使用类型别名定义的联合类型：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Point {
</span></span><span style=display:flex><span>  x: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>  y: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> SomePoint <span style=color:#af3a03>implements</span> Point {
</span></span><span style=display:flex><span>  x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>;
</span></span><span style=display:flex><span>  y <span style=color:#af3a03>=</span> <span style=color:#8f3f71>2</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Point2 <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>  x: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>  y: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> SomePoint2 <span style=color:#af3a03>implements</span> Point2 {
</span></span><span style=display:flex><span>  x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>;
</span></span><span style=display:flex><span>  y <span style=color:#af3a03>=</span> <span style=color:#8f3f71>2</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 错误示例
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> PartialPoint <span style=color:#af3a03>=</span> { x: <span style=color:#b57614>number</span>; } <span style=color:#af3a03>|</span> { y: <span style=color:#b57614>number</span>; };
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// A class can only implement an object type or 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// intersection of object types with statically known members.
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>class</span> SomePartialPoint <span style=color:#af3a03>implements</span> PartialPoint { <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>1</span>;
</span></span><span style=display:flex><span>  y <span style=color:#af3a03>=</span> <span style=color:#8f3f71>2</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这两者的区别说了这么多，其实本不该把这两个东西拿来做对比，他们俩是完全不同的概念。</p><p>interface 是<strong>接口</strong>，用于描述一个对象。</p><p>type 是<strong>类型别名</strong>，用于给各种类型定义别名，让 TS 写起来更简洁、清晰。</p><p>只是有时候两者都能实现同样的功能，才会经常被混淆</p><p>平时开发中，一般<strong>使用组合或者交叉类型</strong>的时候，用 type。</p><p>一般要用类的 <strong>extends</strong> 或 <strong>implements</strong> 时，用 interface。</p><p>其他情况，比如定义一个对象或者函数，就看你心情了。</p><h3 id=类型保护>类型保护<a hidden class=anchor aria-hidden=true href=#类型保护>#</a></h3><p>如果有一个 <code>getLength</code> 函数，入参是联合类型 <code>number | string</code>，返回入参的 length，</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> getLength(arg: <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>string</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>number</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> arg.length
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>从上文可知，这么写会报错，因为 number 类型上没有 length 属性。</p><p>这个时候，类型保护（Type Guards）出现了，可以使用 <code>typeof</code> 关键字判断变量的类型。</p><p>我们把 getLength 方法改造一下，就可以精准地获取到 string 类型的 length 属性了，</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> getLength(arg: <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#b57614>string</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>number</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span>(<span style=color:#af3a03>typeof</span> arg <span style=color:#af3a03>===</span> <span style=color:#79740e>&#39;string&#39;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> arg.length
</span></span><span style=display:flex><span>    } <span style=color:#af3a03>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> arg.toString().length
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=类型断言>类型断言<a hidden class=anchor aria-hidden=true href=#类型断言>#</a></h3><p>通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><ul><li>尖括号语法</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> someValue: <span style=color:#b57614>any</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;this is a string&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> strLength: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> (&lt;<span style=color:#9d0006>string</span>&gt;someValue).length;
</span></span></code></pre></div><ul><li>as语法</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> someValue: <span style=color:#b57614>any</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;this is a string&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> strLength: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> (someValue <span style=color:#af3a03>as</span> <span style=color:#b57614>string</span>).length;
</span></span></code></pre></div><p>注意，类型断言不是类型转换，把一个类型断言成联合类型中不存在的类型会报错。</p><h3 id=字面量类型>字面量类型<a hidden class=anchor aria-hidden=true href=#字面量类型>#</a></h3><p>有时候，我们需要定义一些常量，就需要用到字面量类型，比如，</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>type</span> ButtonSize <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;mini&#39;</span> <span style=color:#af3a03>|</span> <span style=color:#79740e>&#39;small&#39;</span> <span style=color:#af3a03>|</span> <span style=color:#79740e>&#39;normal&#39;</span> <span style=color:#af3a03>|</span> <span style=color:#79740e>&#39;large&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Sex <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;男&#39;</span> <span style=color:#af3a03>|</span> <span style=color:#79740e>&#39;女&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> theSet: <span style=color:#b57614>Sex</span> <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;不男不女&#34;</span>  <span style=color:#928374;font-style:italic>// Type &#39;不男不女&#39; is not assignable to type &#39;sex&#39;
</span></span></span></code></pre></div><p>这样就只能从这些定义的常量中取值，乱取值会报错。</p><h2 id=2泛型>2.泛型<a hidden class=anchor aria-hidden=true href=#2泛型>#</a></h2><p><strong>泛型（Generics）是允许同一个函数接受不同类型参数的一种模板</strong>。相比于使用 any 类型，使用泛型来创建可复用的组件要更好，因为泛型会保留参数类型。</p><p>它可以轻松解决<strong>输入输出要一致</strong>的问题。</p><h3 id=泛型基本使用>泛型基本使用<a hidden class=anchor aria-hidden=true href=#泛型基本使用>#</a></h3><h4 id=处理函数参数>处理函数参数<a hidden class=anchor aria-hidden=true href=#处理函数参数>#</a></h4><p>其中 <code>T</code> 代表 <strong>Type</strong>，在定义泛型时通常用作第一个类型变量名称。但实际上 <code>T</code> 可以用任何有效名称代替。除了 <code>T</code> 之外，以下是常见泛型变量代表的意思：</p><ul><li>K（Key）：表示对象中的键类型；</li><li>V（Value）：表示对象中的值类型；</li><li>E（Element）：表示元素类型。</li></ul><p>其实并不是只能定义一个类型变量，我们可以引入希望定义的任何数量的类型变量。比如我们引入一个新的类型变量 <code>U</code>，用于扩展我们定义的 <code>identity</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> identity &lt;<span style=color:#9d0006>T</span>, <span style=color:#79740e;font-weight:700>U</span>&gt;(value: <span style=color:#b57614>T</span>, message: <span style=color:#b57614>U</span>) <span style=color:#af3a03>:</span> T {
</span></span><span style=display:flex><span>  console.log(message);
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> value;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>console.log(identity&lt;<span style=color:#9d0006>Number</span>, <span style=color:#79740e;font-weight:700>string</span>&gt;(<span style=color:#8f3f71>68</span>, <span style=color:#79740e>&#34;Semlinker&#34;</span>));
</span></span></code></pre></div><p><strong>TS 类型推断，自动推导出类型</strong>。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>console.log(identity(<span style=color:#8f3f71>68</span>, <span style=color:#79740e>&#34;Semlinker&#34;</span>));
</span></span></code></pre></div><p>**ype 和 interface 都可以定义函数类型，也用泛型来写一下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>// type
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> Print <span style=color:#af3a03>=</span> &lt;<span style=color:#9d0006>T</span>&gt;(arg: <span style=color:#b57614>T</span>) <span style=color:#af3a03>=&gt;</span> T
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> printFn:<span style=color:#b57614>Print</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span> print(arg) {
</span></span><span style=display:flex><span>    console.log(arg)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> arg
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// interface
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>interface</span> Iprint&lt;<span style=color:#9d0006>T</span>&gt; {
</span></span><span style=display:flex><span>    (arg: <span style=color:#b57614>T</span>)<span style=color:#af3a03>:</span> T
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> print&lt;<span style=color:#9d0006>T</span>&gt;(arg:<span style=color:#b57614>T</span>) {
</span></span><span style=display:flex><span>    console.log(arg)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> arg
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> myPrint: <span style=color:#b57614>Iprint</span>&lt;<span style=color:#9d0006>number</span>&gt; <span style=color:#af3a03>=</span> print
</span></span></code></pre></div><h4 id=默认参数>默认参数<a hidden class=anchor aria-hidden=true href=#默认参数>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Iprint&lt;<span style=color:#9d0006>T</span> = <span style=color:#79740e;font-weight:700>number</span>&gt; {
</span></span><span style=display:flex><span>    (arg: <span style=color:#b57614>T</span>)<span style=color:#af3a03>:</span> T
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> print&lt;<span style=color:#9d0006>T</span>&gt;(arg:<span style=color:#b57614>T</span>) {
</span></span><span style=display:flex><span>    console.log(arg)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> arg
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> myPrint: <span style=color:#b57614>Iprint</span> <span style=color:#af3a03>=</span> print
</span></span></code></pre></div><h4 id=处理多个函数参数>处理多个函数参数<a hidden class=anchor aria-hidden=true href=#处理多个函数参数>#</a></h4><p>传入一个只有两项的元组，交换元组的第 0 项和第 1 项，返回这个元组。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> swap&lt;<span style=color:#9d0006>T</span>,<span style=color:#79740e;font-weight:700>U</span>&gt;(tuple<span style=color:#af3a03>:</span>[T,U])<span style=color:#af3a03>:</span>[U,T]{
</span></span><span style=display:flex><span> <span style=color:#af3a03>return</span> [tuple[<span style=color:#8f3f71>1</span>], tuple[<span style=color:#8f3f71>0</span>]]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> swap <span style=color:#af3a03>=</span> &lt;<span style=color:#9d0006>T</span>,<span style=color:#79740e;font-weight:700>U</span>&gt;(tuple<span style=color:#af3a03>:</span>[T,U])<span style=color:#af3a03>:</span> [U,T] <span style=color:#af3a03>=&gt;</span>{
</span></span><span style=display:flex><span> <span style=color:#af3a03>return</span> [tuple[<span style=color:#8f3f71>1</span>],tuple[<span style=color:#8f3f71>0</span>]]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=函数副作用操作>函数副作用操作<a hidden class=anchor aria-hidden=true href=#函数副作用操作>#</a></h4><p>调用 API 都<strong>清晰的知道返回类型是什么数据结构</strong></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> UserInfo {
</span></span><span style=display:flex><span>    name: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>    age: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> request&lt;<span style=color:#9d0006>T</span>&gt;(url:<span style=color:#b57614>string</span>)<span style=color:#af3a03>:</span> Promise&lt;<span style=color:#9d0006>T</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> fetch(url).then(res <span style=color:#af3a03>=&gt;</span> res.json())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>request&lt;<span style=color:#9d0006>UserInfo</span>&gt;(<span style=color:#79740e>&#39;user/info&#39;</span>).then(res <span style=color:#af3a03>=&gt;</span>{
</span></span><span style=display:flex><span>    console.log(res)
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h4 id=约束泛型>约束泛型<a hidden class=anchor aria-hidden=true href=#约束泛型>#</a></h4><p>假设现在有这么一个函数，打印传入参数的长度，我们这么写：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>function</span> printLength&lt;<span style=color:#9d0006>T</span>&gt;(arg: <span style=color:#b57614>T</span>)<span style=color:#af3a03>:</span> T {
</span></span><span style=display:flex><span>    console.log(arg.length)  <span style=color:#928374;font-style:italic>//不确定 T 是否有 length 属性，会报错： property &#39;length&#39; does not ...
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#af3a03>return</span> arg
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那么现在我想约束这个泛型，一定要有 length 属性，怎么办？</p><p>可以和 interface 结合，来约束类型。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> ILength {
</span></span><span style=display:flex><span>    length: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> printLength&lt;<span style=color:#9d0006>T</span> <span style=color:#79740e;font-weight:700>extends</span> <span style=color:#79740e;font-weight:700>ILength</span>&gt;(arg: <span style=color:#b57614>T</span>)<span style=color:#af3a03>:</span> T {
</span></span><span style=display:flex><span>    console.log(arg.length)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> arg
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=泛型的一些应用>泛型的一些应用<a hidden class=anchor aria-hidden=true href=#泛型的一些应用>#</a></h4><ul><li>**泛型约束类</li></ul><p>定义一个栈，有入栈和出栈两个方法，如果想入栈和出栈的元素类型统一，就可以这么写：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> Stack&lt;<span style=color:#9d0006>T</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>private</span> data: <span style=color:#b57614>T</span>[] <span style=color:#af3a03>=</span> []
</span></span><span style=display:flex><span>    push(item:<span style=color:#b57614>T</span>) {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> <span style=color:#af3a03>this</span>.data.push(item)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#af3a03>static</span> pop()<span style=color:#af3a03>:</span>T <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span> {        <span style=color:#928374;font-style:italic>//给pop方法定义 static 关键字，报错  
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>        <span style=color:#af3a03>return</span> <span style=color:#af3a03>this</span>.data.pop()          <span style=color:#79740e>&#39;泛型无法约束类的静态成员&#39;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> stack <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> Stack&lt;<span style=color:#9d0006>string</span>&gt;()
</span></span><span style=display:flex><span>stack.push(<span style=color:#79740e>&#39;124&#39;</span>)
</span></span><span style=display:flex><span>stack.push(<span style=color:#8f3f71>123</span>)  <span style=color:#928374;font-style:italic>// 类型number 不能复制给string
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>stack.pop()
</span></span></code></pre></div><ul><li>**泛型约束接口</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> IKeyValue&lt;<span style=color:#9d0006>T</span>, <span style=color:#79740e;font-weight:700>U</span>&gt; {
</span></span><span style=display:flex><span>    key: <span style=color:#b57614>T</span>
</span></span><span style=display:flex><span>    value: <span style=color:#b57614>U</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> k1:<span style=color:#b57614>IKeyValue</span>&lt;<span style=color:#9d0006>number</span>, <span style=color:#79740e;font-weight:700>string</span>&gt; <span style=color:#af3a03>=</span> { key: <span style=color:#b57614>18</span>, value<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> k2:<span style=color:#b57614>IKeyValue</span>&lt;<span style=color:#9d0006>string</span>, <span style=color:#79740e;font-weight:700>number</span>&gt; <span style=color:#af3a03>=</span> { key<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>, value: <span style=color:#b57614>18</span>}
</span></span></code></pre></div><ul><li>**泛型定义数组</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>//之前我们这么写
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>const</span> arr: <span style=color:#b57614>number</span>[] <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>,<span style=color:#8f3f71>2</span>,<span style=color:#8f3f71>3</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//现在可以这样写
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>const</span> arr: <span style=color:#b57614>Array</span>&lt;<span style=color:#9d0006>number</span>&gt; <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>1</span>,<span style=color:#8f3f71>2</span>,<span style=color:#8f3f71>3</span>]
</span></span></code></pre></div><h3 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h3><h4 id=泛型的好处>泛型的好处<a hidden class=anchor aria-hidden=true href=#泛型的好处>#</a></h4><ul><li><p>函数和类可以轻松地支持多种类型，增强程序的拓展性</p></li><li><p>不必写冗长的联合类型，增强代码的可读性</p></li><li><p>灵活控制类型之间的约束</p></li></ul><h4 id=泛型接口>泛型接口<a hidden class=anchor aria-hidden=true href=#泛型接口>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> GenericIdentityFn&lt;<span style=color:#9d0006>T</span>&gt; {
</span></span><span style=display:flex><span>  (arg: <span style=color:#b57614>T</span>)<span style=color:#af3a03>:</span> T;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=泛型类>泛型类<a hidden class=anchor aria-hidden=true href=#泛型类>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>class</span> GenericNumber&lt;<span style=color:#9d0006>T</span>&gt; {
</span></span><span style=display:flex><span>  zeroValue: <span style=color:#b57614>T</span>;
</span></span><span style=display:flex><span>  add<span style=color:#af3a03>:</span> (x: <span style=color:#b57614>T</span>, y: <span style=color:#b57614>T</span>) <span style=color:#af3a03>=&gt;</span> T;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> myGenericNumber <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> GenericNumber&lt;<span style=color:#9d0006>number</span>&gt;();
</span></span><span style=display:flex><span>myGenericNumber.zeroValue <span style=color:#af3a03>=</span> <span style=color:#8f3f71>0</span>;
</span></span><span style=display:flex><span>myGenericNumber.add <span style=color:#af3a03>=</span> <span style=color:#af3a03>function</span> (x, y) {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> x <span style=color:#af3a03>+</span> y;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h4 id=泛型工具类型>泛型工具类型<a hidden class=anchor aria-hidden=true href=#泛型工具类型>#</a></h4><h2 id=3高级类型二>3.高级类型（二）<a hidden class=anchor aria-hidden=true href=#3高级类型二>#</a></h2><h3 id=索引类型>索引类型<a hidden class=anchor aria-hidden=true href=#索引类型>#</a></h3><p>从对象中抽取一些属性的值，然后拼接成数组，可以这么写</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>const</span> userInfo <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>  name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>,
</span></span><span style=display:flex><span>  age<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;18&#39;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> getValues(userInfo: <span style=color:#b57614>any</span>, keys: <span style=color:#b57614>string</span>[]) {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> keys.map(key <span style=color:#af3a03>=&gt;</span> userInfo[key])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 抽取指定属性的值
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(getValues(userInfo, [<span style=color:#79740e>&#39;name&#39;</span>,<span style=color:#79740e>&#39;age&#39;</span>]))  <span style=color:#928374;font-style:italic>// [&#39;lin&#39;, &#39;18&#39;]
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 抽取obj中没有的属性:
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(getValues(userInfo, [<span style=color:#79740e>&#39;sex&#39;</span>,<span style=color:#79740e>&#39;outlook&#39;</span>]))  <span style=color:#928374;font-style:italic>// [undefined, undefined]
</span></span></span></code></pre></div><h4 id=keyof索引查询>keyof（索引查询）<a hidden class=anchor aria-hidden=true href=#keyof索引查询>#</a></h4><p><code>keyof</code> 操作符用于获取某种类型的所有键，其返回类型是联合类型。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>  name: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>  age: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> K1 <span style=color:#af3a03>=</span> <span style=color:#af3a03>keyof</span> Person; <span style=color:#928374;font-style:italic>// &#34;name&#34; | &#34;age&#34;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> K2 <span style=color:#af3a03>=</span> <span style=color:#af3a03>keyof</span> Person[]; <span style=color:#928374;font-style:italic>// &#34;length&#34; | &#34;toString&#34; | &#34;pop&#34; | &#34;push&#34; | &#34;concat&#34; | &#34;join&#34; 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>type</span> K3 <span style=color:#af3a03>=</span> <span style=color:#af3a03>keyof</span> { [x: <span style=color:#b57614>string</span>]<span style=color:#af3a03>:</span> Person };  <span style=color:#928374;font-style:italic>// string | number
</span></span></span></code></pre></div><h4 id=tk索引访问>T[K]（索引访问）<a hidden class=anchor aria-hidden=true href=#tk索引访问>#</a></h4><p><code>T[K]</code>，表示接口 T 的属性 K 所代表的类型</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> IPerson {
</span></span><span style=display:flex><span>  name: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>  age: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> type1:  <span style=color:#b57614>IPerson</span>[<span style=color:#79740e>&#39;name&#39;</span>] <span style=color:#928374;font-style:italic>// string
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> type2:  <span style=color:#b57614>IPerson</span>[<span style=color:#79740e>&#39;age&#39;</span>]  <span style=color:#928374;font-style:italic>// number
</span></span></span></code></pre></div><h4 id=extends-泛型约束>extends (泛型约束)<a hidden class=anchor aria-hidden=true href=#extends-泛型约束>#</a></h4><p><code>T extends U</code>，表示泛型变量可以通过继承某个类型，获得某些属性。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Lengthwise {
</span></span><span style=display:flex><span>  length: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> loggingIdentity&lt;<span style=color:#9d0006>T</span> <span style=color:#79740e;font-weight:700>extends</span> <span style=color:#79740e;font-weight:700>Lengthwise</span>&gt;(arg: <span style=color:#b57614>T</span>)<span style=color:#af3a03>:</span> T {
</span></span><span style=display:flex><span>  console.log(arg.length);
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> arg;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>loggingIdentity(<span style=color:#8f3f71>3</span>);  <span style=color:#928374;font-style:italic>// Error, number doesn&#39;t have a .length property
</span></span></span></code></pre></div><p>这时我们需要传入符合约束类型的值，必须包含必须的属性</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>loggingIdentity({length: <span style=color:#b57614>10</span>, value: <span style=color:#b57614>3</span>});
</span></span></code></pre></div><h4 id=检查动态属性>检查动态属性<a hidden class=anchor aria-hidden=true href=#检查动态属性>#</a></h4><p>对 getValue 函数进行改造，实现对象上动态属性的检查。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>//改造前
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>const</span> userInfo <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>  name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>,
</span></span><span style=display:flex><span>  age<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;18&#39;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> getValues(userInfo: <span style=color:#b57614>any</span>, keys: <span style=color:#b57614>string</span>[]) {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> keys.map(key <span style=color:#af3a03>=&gt;</span> userInfo[key])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// 抽取指定属性的值 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(getValues(userInfo, [<span style=color:#79740e>&#39;name&#39;</span>,<span style=color:#79740e>&#39;age&#39;</span>])) 
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// [&#39;lin&#39;, &#39;18&#39;] // 抽取obj中没有的属性: 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(getValues(userInfo, [<span style=color:#79740e>&#39;sex&#39;</span>,<span style=color:#79740e>&#39;outlook&#39;</span>])) <span style=color:#928374;font-style:italic>// [undefined, undefined]
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>//改造后
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>-</span> 定义泛型 T、K，用于约束 userInfo 和 keys
</span></span><span style=display:flex><span><span style=color:#af3a03>-</span> 为 K 增加一个泛型约束,使 K 继承 userInfo 的所有属性的联合类型, 即<span style=color:#79740e>`K extends keyof T`</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> getValues&lt;<span style=color:#9d0006>T</span>, <span style=color:#79740e;font-weight:700>K</span> <span style=color:#79740e;font-weight:700>extends</span> <span style=color:#79740e;font-weight:700>keyof</span> <span style=color:#79740e;font-weight:700>T</span>&gt;(userInfo: <span style=color:#b57614>T</span>, keys: <span style=color:#b57614>K</span>[])<span style=color:#af3a03>:</span> T[K][] {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> keys.map(key <span style=color:#af3a03>=&gt;</span> userInfo[key])
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>getValues(userInfo,[<span style=color:#79740e>&#39;sex&#39;</span>,<span style=color:#79740e>&#39;outlook&#39;</span>])  <span style=color:#928374;font-style:italic>//这样当我们指定不在对象里的属性时，就会报错，Type &#39;sex&#39; is not assignable to type &#39;&#34;name&#34;|&#34;age&#34;&#39;
</span></span></span></code></pre></div><h3 id=映射类型>映射类型<a hidden class=anchor aria-hidden=true href=#映射类型>#</a></h3><p>TS允许将一个类型映射成另外一个类型。</p><h4 id=in>in<a hidden class=anchor aria-hidden=true href=#in>#</a></h4><p><code>in</code> 用来遍历枚举类型</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>type</span> Keys <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;a&#34;</span> <span style=color:#af3a03>|</span> <span style=color:#79740e>&#34;b&#34;</span> <span style=color:#af3a03>|</span> <span style=color:#79740e>&#34;c&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Obj <span style=color:#af3a03>=</span>  {
</span></span><span style=display:flex><span>  [p <span style=color:#af3a03>in</span> Keys]<span style=color:#af3a03>:</span> <span style=color:#b57614>any</span>
</span></span><span style=display:flex><span>} <span style=color:#928374;font-style:italic>// -&gt; { a: any, b: any, c: any }
</span></span></span></code></pre></div><h4 id=partial>Partial<a hidden class=anchor aria-hidden=true href=#partial>#</a></h4><p><code>Partial&lt;T></code> 的作用就是将某个类型里的属性全部变为可选项 <code>?</code>。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic> * node_modules/typescript/lib/lib.es5.d.ts
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic> * Make all properties in T optional
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Partial&lt;<span style=color:#9d0006>T</span>&gt; <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>  [P <span style=color:#af3a03>in</span> <span style=color:#af3a03>keyof</span> T]<span style=color:#af3a03>?:</span> T[P];
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>示例</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Todo {
</span></span><span style=display:flex><span>  title: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>  description: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> updateTodo(todo: <span style=color:#b57614>Todo</span>, fieldsToUpdate: <span style=color:#b57614>Partial</span>&lt;<span style=color:#9d0006>Todo</span>&gt;) {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> { ...todo, ...fieldsToUpdate };
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> todo1 <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>  title<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;Learn TS&#34;</span>,
</span></span><span style=display:flex><span>  description<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;Learn TypeScript&#34;</span>,
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> todo2 <span style=color:#af3a03>=</span> updateTodo(todo1, {
</span></span><span style=display:flex><span>  description<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;Learn TypeScript Enum&#34;</span>,
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><p>上面的 <code>updateTodo</code> 方法中，我们利用 <code>Partial&lt;T></code> 工具类型，定义 <code>fieldsToUpdate</code> 的类型为 <code>Partial&lt;Todo></code>，即：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>{
</span></span><span style=display:flex><span>   title?: <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span>   description?: <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>Partial 原理</strong></p><p><code>Partial</code> 的实现用到了 <code>in</code> 和 <code>keyof</code></p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic> * Make all properties in T optional
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Partial&lt;<span style=color:#9d0006>T</span>&gt; <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    [P <span style=color:#af3a03>in</span> <span style=color:#af3a03>keyof</span> T]<span style=color:#af3a03>?:</span> T[P]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>[P in keyof T]</code>遍历<code>T</code>上的所有属性</li><li><code>?:</code>设置属性为可选的</li><li><code>T[P]</code>设置类型为原来的类型</li></ul><h4 id=readonly>Readonly<a hidden class=anchor aria-hidden=true href=#readonly>#</a></h4><p><code>Readonly&lt;T></code>将<code>T</code>的所有属性映射为只读的，例如：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> IPerson {
</span></span><span style=display:flex><span>  name: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>  age: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> IReadOnly <span style=color:#af3a03>=</span> Readonly&lt;<span style=color:#9d0006>IPerson</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> p1: <span style=color:#b57614>IReadOnly</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>  name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;lin&#39;</span>,
</span></span><span style=display:flex><span>  age: <span style=color:#b57614>18</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>p1.name <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;lv&#39;</span>   <span style=color:#928374;font-style:italic>//报错，Cannot assign to &#39;name&#39; because it is a read-only property.
</span></span></span></code></pre></div><p>**Readonly 原理</p><p>和 <code>Partial</code> 几乎完全一样</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>/**
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic> * Make all properties in T readonly
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic> */</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Readonly&lt;<span style=color:#9d0006>T</span>&gt; <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>readonly</span> [P <span style=color:#af3a03>in</span> <span style=color:#af3a03>keyof</span> T]<span style=color:#af3a03>:</span> T[P]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=typeof>typeof<a hidden class=anchor aria-hidden=true href=#typeof>#</a></h4><p><code>typeof</code> 操作符用来获取一个变量声明或对象的类型。</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>interface</span> Person {
</span></span><span style=display:flex><span>  name: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>  age: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> sem: <span style=color:#b57614>Person</span> <span style=color:#af3a03>=</span> { name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;semlinker&#39;</span>, age: <span style=color:#b57614>33</span> };
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Sem<span style=color:#af3a03>=</span> <span style=color:#af3a03>typeof</span> sem; <span style=color:#928374;font-style:italic>// -&gt; Person
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> toArray(x: <span style=color:#b57614>number</span>)<span style=color:#af3a03>:</span> <span style=color:#b57614>Array</span>&lt;<span style=color:#9d0006>number</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> [x];
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>type</span> Func <span style=color:#af3a03>=</span> <span style=color:#af3a03>typeof</span> toArray; <span style=color:#928374;font-style:italic>// -&gt; (x: number) =&gt; number[]
</span></span></span></code></pre></div><h3 id=条件类型>条件类型<a hidden class=anchor aria-hidden=true href=#条件类型>#</a></h3><h3 id=工具类型utility-types>工具类型（Utility Types）<a hidden class=anchor aria-hidden=true href=#工具类型utility-types>#</a></h3><h3 id=类型体操是什么>类型体操是什么？<a hidden class=anchor aria-hidden=true href=#类型体操是什么>#</a></h3><h2 id=4ts声明文件>4.TS声明文件<a hidden class=anchor aria-hidden=true href=#4ts声明文件>#</a></h2><h3 id=ts-实战>TS 实战<a hidden class=anchor aria-hidden=true href=#ts-实战>#</a></h3><h3 id=todolist>todolist<a hidden class=anchor aria-hidden=true href=#todolist>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>&lt;<span style=color:#9d0006>div</span> <span style=color:#79740e;font-weight:700>style</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;padding: 50px; background: pink&#34;</span>&gt;
</span></span><span style=display:flex><span> &lt;<span style=color:#9d0006>input</span> <span style=color:#79740e;font-weight:700>type</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;text&#34;</span> <span style=color:#79740e;font-weight:700>v</span>-<span style=color:#79740e;font-weight:700>model</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;todoMsg&#34;</span> /&gt;
</span></span><span style=display:flex><span> &lt;<span style=color:#9d0006>button</span> @<span style=color:#79740e;font-weight:700>click</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;add&#34;</span>&gt;添加&lt;/<span style=color:#9d0006>button</span>&gt;
</span></span><span style=display:flex><span> &lt;<span style=color:#9d0006>button</span> @<span style=color:#79740e;font-weight:700>click</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;clearHasDone&#34;</span>&gt;清理&lt;/<span style=color:#9d0006>button</span>&gt;
</span></span><span style=display:flex><span> &lt;<span style=color:#9d0006>div</span> <span style=color:#79740e;font-weight:700>v</span>-<span style=color:#79740e;font-weight:700>if</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;lists.length&#34;</span>&gt;
</span></span><span style=display:flex><span>  &lt;<span style=color:#9d0006>div</span> <span style=color:#79740e;font-weight:700>v</span>-<span style=color:#79740e;font-weight:700>for</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;(item, index) in lists&#34;</span> :<span style=color:#79740e;font-weight:700>key</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;item.msg&#34;</span>&gt;
</span></span><span style=display:flex><span>   &lt;<span style=color:#9d0006>input</span> <span style=color:#79740e;font-weight:700>type</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;checkbox&#34;</span> <span style=color:#79740e;font-weight:700>v</span>-<span style=color:#79740e;font-weight:700>model</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;item.done&#34;</span> /&gt;              
</span></span><span style=display:flex><span>   &lt;<span style=color:#9d0006>span</span> :<span style=color:#79740e;font-weight:700>class</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;{ done: item.done }&#34;</span>&gt;{{ item.msg }}&lt;/<span style=color:#9d0006>span</span>&gt;
</span></span><span style=display:flex><span>            &lt;<span style=color:#9d0006>span</span> @<span style=color:#79740e;font-weight:700>click</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;deleteItem(index)&#34;</span>&gt;❎&lt;/<span style=color:#9d0006>span</span>&gt;
</span></span><span style=display:flex><span>        &lt;/<span style=color:#9d0006>div</span>&gt;
</span></span><span style=display:flex><span>     &lt;<span style=color:#9d0006>div</span>&gt;
</span></span><span style=display:flex><span>   &lt;<span style=color:#9d0006>span</span>&gt;全选&lt;/<span style=color:#9d0006>span</span>&gt;
</span></span><span style=display:flex><span>   &lt;<span style=color:#9d0006>input</span> <span style=color:#79740e;font-weight:700>type</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;checkbox&#34;</span> <span style=color:#79740e;font-weight:700>v</span>-<span style=color:#79740e;font-weight:700>model</span><span style=color:#af3a03>=</span><span style=color:#79740e>&#34;isAllDone&#34;</span> /&gt;
</span></span><span style=display:flex><span>   &lt;<span style=color:#9d0006>span</span>&gt;{{ hasDone }} <span style=color:#af3a03>/</span> {{ lists.length }}&lt;/<span style=color:#9d0006>span</span>&gt;
</span></span><span style=display:flex><span>  &lt;/<span style=color:#9d0006>div</span>&gt;
</span></span><span style=display:flex><span> &lt;/<span style=color:#9d0006>div</span>&gt;
</span></span><span style=display:flex><span> &lt;<span style=color:#9d0006>div</span> <span style=color:#79740e;font-weight:700>v</span>-<span style=color:#79740e;font-weight:700>else</span>&gt;暂无数据&lt;/<span style=color:#9d0006>div</span>&gt;
</span></span><span style=display:flex><span>&lt;/<span style=color:#9d0006>div</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>import</span> { ElMessage } <span style=color:#af3a03>from</span> <span style=color:#79740e>&#34;element-plus&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>import</span> { ref, computed } <span style=color:#af3a03>from</span> <span style=color:#79740e>&#34;vue&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>interface</span> listType {
</span></span><span style=display:flex><span>  done: <span style=color:#b57614>boolean</span>;
</span></span><span style=display:flex><span>  msg: <span style=color:#b57614>string</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> lists <span style=color:#af3a03>=</span> ref&lt;<span style=color:#9d0006>listType</span>[]&gt;([
</span></span><span style=display:flex><span>  { msg<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;吃饭&#34;</span>, done: <span style=color:#b57614>true</span> },
</span></span><span style=display:flex><span>  { msg<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;睡觉&#34;</span>, done: <span style=color:#b57614>false</span> },
</span></span><span style=display:flex><span>  { msg<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;打游戏&#34;</span>, done: <span style=color:#b57614>false</span> }
</span></span><span style=display:flex><span>]);
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> todoMsg <span style=color:#af3a03>=</span> ref&lt;<span style=color:#9d0006>string</span>&gt;(<span style=color:#79740e>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> add <span style=color:#af3a03>=</span> () <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>if</span> (<span style=color:#af3a03>!</span>todoMsg.value) {
</span></span><span style=display:flex><span>    ElMessage.error(<span style=color:#79740e>&#34;请输入相关值！&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#af3a03>let</span> params: <span style=color:#b57614>listType</span> <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>    done: <span style=color:#b57614>false</span>,
</span></span><span style=display:flex><span>    msg: <span style=color:#b57614>todoMsg.value</span>
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>  lists.value.push(params);
</span></span><span style=display:flex><span>  todoMsg.value <span style=color:#af3a03>=</span> <span style=color:#79740e>&#34;&#34;</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> clearHasDone <span style=color:#af3a03>=</span> () <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>  lists.value <span style=color:#af3a03>=</span> lists.value.filter(item <span style=color:#af3a03>=&gt;</span> <span style=color:#af3a03>!</span>item.done);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> deleteItem <span style=color:#af3a03>=</span> (index: <span style=color:#b57614>number</span>) <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>  lists.value.splice(index, <span style=color:#8f3f71>1</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> hasDone <span style=color:#af3a03>=</span> computed(() <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>return</span> lists.value.filter(item <span style=color:#af3a03>=&gt;</span> item.done).length;
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> isAllDone <span style=color:#af3a03>=</span> computed&lt;<span style=color:#9d0006>boolean</span>&gt;({
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// 所有的事项是否完成，双向绑定到全选按钮
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>get</span>() {
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// isAllDone 的获取方法，用于双向绑定数据
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#af3a03>return</span> hasDone.value <span style=color:#af3a03>===</span> lists.value.length;
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#af3a03>set</span>(value: <span style=color:#b57614>boolean</span>) {
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// isAllDone 的更改方法，用于实现全选 和 取消全选功能
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    lists.value.forEach(item <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>      item.done <span style=color:#af3a03>=</span> value;
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=泛型约束后端接口参数类型>泛型约束后端接口参数类型<a hidden class=anchor aria-hidden=true href=#泛型约束后端接口参数类型>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>import</span> axios <span style=color:#af3a03>from</span> <span style=color:#79740e>&#39;axios&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>interface</span> API {
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#39;/book/detail&#39;</span><span style=color:#af3a03>:</span> {
</span></span><span style=display:flex><span>        id: <span style=color:#b57614>number</span>,
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#39;/book/comment&#39;</span><span style=color:#af3a03>:</span> {
</span></span><span style=display:flex><span>        id: <span style=color:#b57614>number</span>
</span></span><span style=display:flex><span>        comment: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> request&lt;<span style=color:#9d0006>T</span> <span style=color:#79740e;font-weight:700>extends</span> <span style=color:#79740e;font-weight:700>keyof</span> <span style=color:#79740e;font-weight:700>API</span>&gt;(url: <span style=color:#b57614>T</span>, obj: <span style=color:#b57614>API</span>[T]) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> axios.post(url, obj)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>request(<span style=color:#79740e>&#39;/book/comment&#39;</span>, {
</span></span><span style=display:flex><span>    id: <span style=color:#b57614>1</span>,
</span></span><span style=display:flex><span>    comment<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;非常棒！&#39;</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h3 id=ts-封装-axios-请求>TS 封装 axios 请求<a hidden class=anchor aria-hidden=true href=#ts-封装-axios-请求>#</a></h3><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>import</span> { HttpResponse } <span style=color:#af3a03>from</span> <span style=color:#79740e>&#39;@/common/interface&#39;</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>import</span> Taro <span style=color:#af3a03>from</span> <span style=color:#79740e>&#39;@tarojs/taro&#39;</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>import</span> publicConfig <span style=color:#af3a03>from</span> <span style=color:#79740e>&#39;@/config/index&#39;</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>import</span> axios, {
</span></span><span style=display:flex><span>  AxiosInstance,
</span></span><span style=display:flex><span>  AxiosRequestConfig,
</span></span><span style=display:flex><span>  AxiosResponse,
</span></span><span style=display:flex><span>  Canceler
</span></span><span style=display:flex><span>} <span style=color:#af3a03>from</span> <span style=color:#79740e>&#39;axios-miniprogram&#39;</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>import</span> errorHandle <span style=color:#af3a03>from</span> <span style=color:#79740e>&#39;../common/errorHandle&#39;</span>
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> CancelToken <span style=color:#af3a03>=</span> axios.CancelToken
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>class</span> HttpRequest {
</span></span><span style=display:flex><span>  <span style=color:#af3a03>private</span> baseUrl: <span style=color:#b57614>string</span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>private</span> pending: <span style=color:#b57614>Record</span>&lt;<span style=color:#9d0006>string</span>, <span style=color:#79740e;font-weight:700>Canceler</span>&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>constructor</span>(baseUrl: <span style=color:#b57614>string</span>) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>this</span>.baseUrl <span style=color:#af3a03>=</span> baseUrl
</span></span><span style=display:flex><span>    <span style=color:#af3a03>this</span>.pending <span style=color:#af3a03>=</span> {}
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// 获取axios配置
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  getInsideConfig() {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>const</span> config <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>      baseURL: <span style=color:#b57614>this.baseUrl</span>,
</span></span><span style=display:flex><span>      headers<span style=color:#af3a03>:</span> {
</span></span><span style=display:flex><span>        <span style=color:#79740e>&#39;Content-Type&#39;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;application/json;charset=utf-8&#39;</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      timeout: <span style=color:#b57614>10000</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> config
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  removePending(key: <span style=color:#b57614>string</span>, isRequest <span style=color:#af3a03>=</span> <span style=color:#af3a03>false</span>) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>if</span> (<span style=color:#af3a03>this</span>.pending[key] <span style=color:#af3a03>&amp;&amp;</span> isRequest) {
</span></span><span style=display:flex><span>      <span style=color:#af3a03>this</span>.pending[key](<span style=color:#79740e>&#39;取消重复请求&#39;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#af3a03>delete</span> <span style=color:#af3a03>this</span>.pending[key]
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// 设定拦截器
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  interceptors(instance: <span style=color:#b57614>AxiosInstance</span>) {
</span></span><span style=display:flex><span>    instance.interceptors.request.use(
</span></span><span style=display:flex><span>      config <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>let</span> isPublic <span style=color:#af3a03>=</span> <span style=color:#af3a03>false</span>
</span></span><span style=display:flex><span>        publicConfig.publicPath.map(path <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>          isPublic <span style=color:#af3a03>=</span> isPublic <span style=color:#af3a03>||</span> path.test(config.url <span style=color:#af3a03>||</span> <span style=color:#79740e>&#39;&#39;</span>)
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        <span style=color:#af3a03>const</span> token <span style=color:#af3a03>=</span> Taro.getStorageSync(<span style=color:#79740e>&#39;token&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#af3a03>if</span> (<span style=color:#af3a03>!</span>isPublic <span style=color:#af3a03>&amp;&amp;</span> token) {
</span></span><span style=display:flex><span>          config.headers.Authorization <span style=color:#af3a03>=</span> <span style=color:#79740e>&#39;Bearer &#39;</span> <span style=color:#af3a03>+</span> token
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#af3a03>const</span> key <span style=color:#af3a03>=</span> config.url <span style=color:#af3a03>+</span> <span style=color:#79740e>&#39;&amp;&#39;</span> <span style=color:#af3a03>+</span> config.method
</span></span><span style=display:flex><span>        <span style=color:#af3a03>this</span>.removePending(key, <span style=color:#af3a03>true</span>)
</span></span><span style=display:flex><span>        config.cancelToken <span style=color:#af3a03>=</span> <span style=color:#af3a03>new</span> CancelToken(c <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>          <span style=color:#af3a03>this</span>.pending[key] <span style=color:#af3a03>=</span> c
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> config
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      err <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>        errorHandle(err)
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> Promise.reject(err)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>// 响应请求的拦截器
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    instance.interceptors.response.use(
</span></span><span style=display:flex><span>      res <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#af3a03>const</span> key <span style=color:#af3a03>=</span> res.config.url <span style=color:#af3a03>+</span> <span style=color:#79740e>&#39;&amp;&#39;</span> <span style=color:#af3a03>+</span> res.config.method
</span></span><span style=display:flex><span>        <span style=color:#af3a03>this</span>.removePending(key)
</span></span><span style=display:flex><span>        <span style=color:#af3a03>if</span> (res.status <span style=color:#af3a03>===</span> <span style=color:#8f3f71>200</span>) {
</span></span><span style=display:flex><span>          <span style=color:#af3a03>return</span> Promise.resolve(res.data)
</span></span><span style=display:flex><span>        } <span style=color:#af3a03>else</span> {
</span></span><span style=display:flex><span>          <span style=color:#af3a03>return</span> Promise.reject(res)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      err <span style=color:#af3a03>=&gt;</span> {
</span></span><span style=display:flex><span>        errorHandle(err)
</span></span><span style=display:flex><span>        <span style=color:#af3a03>return</span> Promise.reject(err)
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// 创建实例
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  request(options: <span style=color:#b57614>AxiosRequestConfig</span>) {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>const</span> instance <span style=color:#af3a03>=</span> axios.create()
</span></span><span style=display:flex><span>    <span style=color:#af3a03>const</span> newOptions <span style=color:#af3a03>=</span> <span style=color:#b57614>Object</span>.assign(<span style=color:#af3a03>this</span>.getInsideConfig(), options)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>this</span>.interceptors(instance)
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> instance(newOptions)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#af3a03>get</span>(url: <span style=color:#b57614>string</span>, config?: <span style=color:#b57614>AxiosRequestConfig</span>)<span style=color:#af3a03>:</span> Promise&lt;<span style=color:#9d0006>AxiosResponse</span>&gt; <span style=color:#af3a03>|</span> Promise&lt;<span style=color:#9d0006>HttpResponse</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>const</span> options <span style=color:#af3a03>=</span> <span style=color:#b57614>Object</span>.assign(
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        method<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;get&#39;</span>,
</span></span><span style=display:flex><span>        url: <span style=color:#b57614>url</span>
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      config
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> <span style=color:#af3a03>this</span>.request(options)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  post(url: <span style=color:#b57614>string</span>, data?: <span style=color:#b57614>unknown</span>)<span style=color:#af3a03>:</span> Promise&lt;<span style=color:#9d0006>AxiosResponse</span>&gt; <span style=color:#af3a03>|</span> Promise&lt;<span style=color:#9d0006>HttpResponse</span>&gt; {
</span></span><span style=display:flex><span>    <span style=color:#af3a03>return</span> <span style=color:#af3a03>this</span>.request({
</span></span><span style=display:flex><span>      method<span style=color:#af3a03>:</span> <span style=color:#79740e>&#39;post&#39;</span>,
</span></span><span style=display:flex><span>      url: <span style=color:#b57614>url</span>,
</span></span><span style=display:flex><span>      data: <span style=color:#b57614>data</span>
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>export</span> <span style=color:#af3a03>default</span> HttpRequest
</span></span></code></pre></div><h3 id=waiting>waiting<a hidden class=anchor aria-hidden=true href=#waiting>#</a></h3><h3 id=七typescript-数组>七、TypeScript 数组<a hidden class=anchor aria-hidden=true href=#七typescript-数组>#</a></h3><p>**数组解构</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> x: <span style=color:#b57614>number</span>; <span style=color:#af3a03>let</span> y: <span style=color:#b57614>number</span>; <span style=color:#af3a03>let</span> z: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> five_array <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>0</span>,<span style=color:#8f3f71>1</span>,<span style=color:#8f3f71>2</span>,<span style=color:#8f3f71>3</span>,<span style=color:#8f3f71>4</span>];
</span></span><span style=display:flex><span>[x,y,z] <span style=color:#af3a03>=</span> five_array;
</span></span></code></pre></div><p>**数组展开运算符</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> two_array <span style=color:#af3a03>=</span> [<span style=color:#8f3f71>0</span>, <span style=color:#8f3f71>1</span>];
</span></span><span style=display:flex><span><span style=color:#af3a03>let</span> five_array <span style=color:#af3a03>=</span> [...two_array, <span style=color:#8f3f71>2</span>, <span style=color:#8f3f71>3</span>, <span style=color:#8f3f71>4</span>];
</span></span></code></pre></div><p>**数组遍历</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> colors: <span style=color:#b57614>string</span>[] <span style=color:#af3a03>=</span> [<span style=color:#79740e>&#34;red&#34;</span>, <span style=color:#79740e>&#34;green&#34;</span>, <span style=color:#79740e>&#34;blue&#34;</span>];
</span></span><span style=display:flex><span><span style=color:#af3a03>for</span> (<span style=color:#af3a03>let</span> i <span style=color:#af3a03>of</span> colors) {   <span style=color:#928374;font-style:italic>//获取每一个对象
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  console.log(i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span> <span style=color:#928374;font-style:italic>//  for (let i in colors) 获取下标
</span></span></span></code></pre></div><h2 id=八typescript-对象>八、TypeScript 对象<a hidden class=anchor aria-hidden=true href=#八typescript-对象>#</a></h2><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#928374;font-style:italic>//公共数组
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span><span style=color:#af3a03>let</span> person <span style=color:#af3a03>=</span> {
</span></span><span style=display:flex><span>  name<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;Semlinker&#34;</span>,
</span></span><span style=display:flex><span>  gender<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;Male&#34;</span>,
</span></span><span style=display:flex><span>  address<span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;Xiamen&#34;</span>,
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>**对象解构</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> {name, gender} <span style=color:#af3a03>=</span> person
</span></span></code></pre></div><p>**对象展开运算符</p><ul><li>组装对象</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> personWithAge <span style=color:#af3a03>=</span> { ...person, age: <span style=color:#b57614>33</span> };
</span></span></code></pre></div><ul><li>获取除了某些项外的其它项</li></ul><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#af3a03>let</span> { name, ...rest } <span style=color:#af3a03>=</span> person;
</span></span></code></pre></div><h2 id=十三配置文件-tsconfigjson>十三、配置文件 tsconfig.json<a hidden class=anchor aria-hidden=true href=#十三配置文件-tsconfigjson>#</a></h2><h4 id=作用>作用<a hidden class=anchor aria-hidden=true href=#作用>#</a></h4><ul><li>用于标识 TypeScript 项目的根路径；</li><li>用于配置 TypeScript 编译器；</li><li>用于指定编译的文件。</li></ul><h4 id=重要字段> 重要字段<a hidden class=anchor aria-hidden=true href=#重要字段>#</a></h4><ul><li>files - 设置要编译的文件的名称；</li><li>include - 设置需要进行编译的文件，支持路径模式匹配；</li><li>exclude - 设置无需进行编译的文件，支持路径模式匹配；</li><li>compilerOptions - 设置与编译流程相关的选项</li></ul><h4 id=compileroptions-选项>compilerOptions 选项<a hidden class=anchor aria-hidden=true href=#compileroptions-选项>#</a></h4><p>compilerOptions 支持很多选项，常见的有 <code>baseUrl</code>、 <code>target</code>、<code>baseUrl</code>、 <code>moduleResolution</code> 和 <code>lib</code> 等。</p><p>compilerOptions 每个选项的详细说明如下：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#79740e>&#34;compilerOptions&#34;</span><span style=color:#af3a03>:</span> {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>/* 基本选项 */</span>
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#34;target&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;es5&#34;</span>,                       <span style=color:#928374;font-style:italic>// 指定 ECMAScript 目标版本: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES6&#39;/&#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, or &#39;ESNEXT&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;module&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;commonjs&#34;</span>,                  <span style=color:#928374;font-style:italic>// 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;lib&#34;</span><span style=color:#af3a03>:</span> [],                             <span style=color:#928374;font-style:italic>// 指定要包含在编译中的库文件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;allowJs&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                       <span style=color:#928374;font-style:italic>// 允许编译 javascript 文件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;checkJs&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                       <span style=color:#928374;font-style:italic>// 报告 javascript 文件中的错误
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;jsx&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;preserve&#34;</span>,                     <span style=color:#928374;font-style:italic>// 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;declaration&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                   <span style=color:#928374;font-style:italic>// 生成相应的 &#39;.d.ts&#39; 文件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;sourceMap&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                     <span style=color:#928374;font-style:italic>// 生成相应的 &#39;.map&#39; 文件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;outFile&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;./&#34;</span>,                       <span style=color:#928374;font-style:italic>// 将输出文件合并为一个文件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;outDir&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;./&#34;</span>,                        <span style=color:#928374;font-style:italic>// 指定输出目录
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;rootDir&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;./&#34;</span>,                       <span style=color:#928374;font-style:italic>// 用来控制输出目录结构 --outDir.
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;removeComments&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                <span style=color:#928374;font-style:italic>// 删除编译后的所有的注释
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;noEmit&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                        <span style=color:#928374;font-style:italic>// 不生成输出文件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;importHelpers&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                 <span style=color:#928374;font-style:italic>// 从 tslib 导入辅助工具函数
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;isolatedModules&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,               <span style=color:#928374;font-style:italic>// 将每个文件做为单独的模块 （与 &#39;ts.transpileModule&#39; 类似）.
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>/* 严格的类型检查选项 */</span>
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#34;strict&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                        <span style=color:#928374;font-style:italic>// 启用所有严格类型检查选项
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;noImplicitAny&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                 <span style=color:#928374;font-style:italic>// 在表达式和声明上有隐含的 any类型时报错
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;strictNullChecks&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,              <span style=color:#928374;font-style:italic>// 启用严格的 null 检查
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;noImplicitThis&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                <span style=color:#928374;font-style:italic>// 当 this 表达式值为 any 类型的时候，生成一个错误
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;alwaysStrict&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                  <span style=color:#928374;font-style:italic>// 以严格模式检查每个模块，并在每个文件里加入 &#39;use strict&#39;
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>/* 额外的检查 */</span>
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#34;noUnusedLocals&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                <span style=color:#928374;font-style:italic>// 有未使用的变量时，抛出错误
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;noUnusedParameters&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,            <span style=color:#928374;font-style:italic>// 有未使用的参数时，抛出错误
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;noImplicitReturns&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,             <span style=color:#928374;font-style:italic>// 并不是所有函数里的代码都有返回值时，抛出错误
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;noFallthroughCasesInSwitch&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,    <span style=color:#928374;font-style:italic>// 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>/* 模块解析选项 */</span>
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#34;moduleResolution&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;node&#34;</span>,            <span style=color:#928374;font-style:italic>// 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6)
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;baseUrl&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;./&#34;</span>,                       <span style=color:#928374;font-style:italic>// 用于解析非相对模块名称的基目录
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;paths&#34;</span><span style=color:#af3a03>:</span> {},                           <span style=color:#928374;font-style:italic>// 模块名到基于 baseUrl 的路径映射的列表
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;rootDirs&#34;</span><span style=color:#af3a03>:</span> [],                        <span style=color:#928374;font-style:italic>// 根文件夹列表，其组合内容表示项目运行时的结构内容
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;typeRoots&#34;</span><span style=color:#af3a03>:</span> [],                       <span style=color:#928374;font-style:italic>// 包含类型声明的文件列表
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;types&#34;</span><span style=color:#af3a03>:</span> [],                           <span style=color:#928374;font-style:italic>// 需要包含的类型声明文件名列表
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;allowSyntheticDefaultImports&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,  <span style=color:#928374;font-style:italic>// 允许从没有设置默认导出的模块中默认导入。
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>/* Source Map Options */</span>
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#34;sourceRoot&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;./&#34;</span>,                    <span style=color:#928374;font-style:italic>// 指定调试器应该找到 TypeScript 文件而不是源文件的位置
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;mapRoot&#34;</span><span style=color:#af3a03>:</span> <span style=color:#79740e>&#34;./&#34;</span>,                       <span style=color:#928374;font-style:italic>// 指定调试器应该找到映射文件而不是生成文件的位置
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;inlineSourceMap&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,               <span style=color:#928374;font-style:italic>// 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;inlineSources&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,                 <span style=color:#928374;font-style:italic>// 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#928374;font-style:italic>/* 其他选项 */</span>
</span></span><span style=display:flex><span>    <span style=color:#79740e>&#34;experimentalDecorators&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>,        <span style=color:#928374;font-style:italic>// 启用装饰器
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>    <span style=color:#79740e>&#34;emitDecoratorMetadata&#34;</span><span style=color:#af3a03>:</span> <span style=color:#af3a03>true</span>          <span style=color:#928374;font-style:italic>// 为装饰器提供元数据的支持
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=32-非空断言>3.2 非空断言<a hidden class=anchor aria-hidden=true href=#32-非空断言>#</a></h3><p>在上下文中当类型检查器无法断定类型时，一个新的后缀表达式操作符 <code>!</code> 可以用于断言操作对象是非 null 和非 undefined 类型。<strong>具体而言，x! 将从 x 值域中排除 null 和 undefined 。</strong></p><p>那么非空断言操作符到底有什么用呢？下面我们先来看一下非空断言操作符的一些使用场景。</p><h4 id=1忽略-undefined-和-null-类型>1.忽略 undefined 和 null 类型<a hidden class=anchor aria-hidden=true href=#1忽略-undefined-和-null-类型>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#af3a03>function</span> myFunc(maybeString: <span style=color:#b57614>string</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>null</span>) {
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// Type &#39;string | null | undefined&#39; is not assignable to type &#39;string&#39;.
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#928374;font-style:italic>// Type &#39;undefined&#39; is not assignable to type &#39;string&#39;. 
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>const</span> onlyString: <span style=color:#b57614>string</span> <span style=color:#af3a03>=</span> maybeString; <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>const</span> ignoreUndefinedAndNull: <span style=color:#b57614>string</span> <span style=color:#af3a03>=</span> maybeString<span style=color:#af3a03>!</span>; <span style=color:#928374;font-style:italic>// Ok
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>}
</span></span></code></pre></div><h4 id=2调用函数时忽略-undefined-类型>2.调用函数时忽略 undefined 类型<a hidden class=anchor aria-hidden=true href=#2调用函数时忽略-undefined-类型>#</a></h4><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#af3a03>type</span> NumGenerator <span style=color:#af3a03>=</span> () <span style=color:#af3a03>=&gt;</span> <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> myFunc(numGenerator: <span style=color:#b57614>NumGenerator</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span>) {
</span></span><span style=display:flex><span>  <span style=color:#928374;font-style:italic>// Object is possibly &#39;undefined&#39;.(2532)
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#928374;font-style:italic>// Cannot invoke an object which is possibly &#39;undefined&#39;.(2722)
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>const</span> num1 <span style=color:#af3a03>=</span> numGenerator(); <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>  <span style=color:#af3a03>const</span> num2 <span style=color:#af3a03>=</span> numGenerator<span style=color:#af3a03>!</span>(); <span style=color:#928374;font-style:italic>//OK
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>}
</span></span></code></pre></div><p>因为 <code>!</code> 非空断言操作符会从编译生成的 JavaScript 代码中移除，所以在实际使用的过程中，要特别注意。比如下面这个例子：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#af3a03>const</span> a: <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> b: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> a<span style=color:#af3a03>!</span>;
</span></span><span style=display:flex><span>console.log(b); 
</span></span></code></pre></div><p>以上 TS 代码会编译生成以下 ES5 代码：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#af3a03>const</span> a: <span style=color:#b57614>number</span> <span style=color:#af3a03>|</span> <span style=color:#af3a03>undefined</span> <span style=color:#af3a03>=</span> <span style=color:#af3a03>undefined</span>;
</span></span><span style=display:flex><span><span style=color:#af3a03>const</span> b: <span style=color:#b57614>number</span> <span style=color:#af3a03>=</span> a<span style=color:#af3a03>!</span>;
</span></span><span style=display:flex><span>console.log(b); 
</span></span></code></pre></div><p>虽然在 TS 代码中，我们使用了非空断言，使得 <code>const b: number = a!;</code> 语句可以通过 TypeScript 类型检查器的检查。但在生成的 ES5 代码中，<code>!</code> 非空断言操作符被移除了，所以在浏览器中执行以上代码，在控制台会输出 <code>undefined</code>。</p><h3 id=33-确定赋值断言>3.3 确定赋值断言<a hidden class=anchor aria-hidden=true href=#33-确定赋值断言>#</a></h3><p>在 TypeScript 2.7 版本中引入了确定赋值断言，即允许在实例属性和变量声明后面放置一个 <code>!</code> 号，从而告诉 TypeScript 该属性会被明确地赋值。为了更好地理解它的作用，我们来看个具体的例子：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#af3a03>let</span> x: <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>initialize();
</span></span><span style=display:flex><span><span style=color:#928374;font-style:italic>// Variable &#39;x&#39; is used before being assigned.(2454)
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>console.log(<span style=color:#8f3f71>2</span> <span style=color:#af3a03>*</span> x); <span style=color:#928374;font-style:italic>// Error
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> initialize() {
</span></span><span style=display:flex><span>  x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>10</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>很明显该异常信息是说变量 x 在赋值前被使用了，要解决该问题，我们可以使用确定赋值断言：</p><div class=highlight><pre tabindex=0 style=color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#af3a03>let</span> x<span style=color:#af3a03>!:</span> <span style=color:#b57614>number</span>;
</span></span><span style=display:flex><span>initialize();
</span></span><span style=display:flex><span>console.log(<span style=color:#8f3f71>2</span> <span style=color:#af3a03>*</span> x); <span style=color:#928374;font-style:italic>// Ok
</span></span></span><span style=display:flex><span><span style=color:#928374;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#af3a03>function</span> initialize() {
</span></span><span style=display:flex><span>  x <span style=color:#af3a03>=</span> <span style=color:#8f3f71>10</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过 <code>let x!: number;</code> 确定赋值断言，TypeScript 编译器就会知道该属性会被明确地赋值。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://bablvsj.github.io/tags/typescript/>TypeScript</a></li><li><a href=https://bablvsj.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/>编程语言</a></li></ul><nav class=paginav><a class=prev href=https://bablvsj.github.io/posts/life/exams/sql%E4%B9%8B%E6%AF%8D/><span class=title>« Prev</span><br><span>SQL之母</span></a>
<a class=next href=https://bablvsj.github.io/posts/life/20221216-%E5%80%BC%E5%BE%97%E4%B8%80%E7%9C%8B%E7%9A%84%E7%94%B5%E5%BD%B1/><span class=title>Next »</span><br><span>值得一看的电影</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://bablvsj.github.io>Bablvsj's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span><div class=flex-c-d><a class=flex-d-c href="https://www.upyun.com/?utm_source=lianmeng&utm_medium=referral" target=_blank><span>本站由</span><img width=60 src=/images/upyun.png>提供CDN加速/云存储服务</a></div></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>